{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CoalesceVariableNames.java",
  "functionName": "computeVariableNamesInterferenceGraph",
  "functionId": "computeVariableNamesInterferenceGraph___t-NodeTraversal__cfg-ControlFlowGraph__Node____escaped-Set__Var__",
  "sourceFilePath": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 199,
  "functionEndLine": 292,
  "numCommitsSeen": 25,
  "timeTaken": 1151,
  "changeHistory": [
    "a54f481f17f75d540426b958dd381f1556586960",
    "af3e9dbffe3f76e20389ce7d159a73cf8d91ea41",
    "3c5a6f6a1b87c655c5eb3ed0ebcfce886ab6a614",
    "a486b8345202c35efe3a2b63f16259e1933c359c",
    "c25df7eca2462861bf42ad8b74215099c3f81ae6",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "a54f481f17f75d540426b958dd381f1556586960": "Ybodychange",
    "af3e9dbffe3f76e20389ce7d159a73cf8d91ea41": "Ybodychange",
    "3c5a6f6a1b87c655c5eb3ed0ebcfce886ab6a614": "Ybodychange",
    "a486b8345202c35efe3a2b63f16259e1933c359c": "Ybodychange",
    "c25df7eca2462861bf42ad8b74215099c3f81ae6": "Yformatchange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a54f481f17f75d540426b958dd381f1556586960": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\ncauses runtime errors in gmail. added a test case demonstrating\nthe issue\n\n*** Original change description ***\n\nPrescreen variable for live range check. Makes CoalesceVariableNames 10times faster.\n\nR\u003dacleung\nDELTA\u003d111  (31 added, 80 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1140 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/27/11, 12:07 PM",
      "commitName": "a54f481f17f75d540426b958dd381f1556586960",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/23/11, 6:42 PM",
      "commitNameOld": "af3e9dbffe3f76e20389ce7d159a73cf8d91ea41",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 3.73,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n    Scope scope \u003d t.getScope();\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n        Var v1 \u003d i1.next();\n        NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n            Var v2 \u003d i2.next();\n            if (v1.index \u003e\u003d v2.index) {\n                continue;\n            }\n            if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                continue NEXT_VAR_PAIR;\n            }\n            if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                interferenceGraph.connectIfNotFound(v1, null, v2);\n                continue NEXT_VAR_PAIR;\n            }\n            NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_CROSS_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n            NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_INTRA_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                if (checker.connectIfCrossed(interferenceGraph)) {\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 199,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,72 +1,52 @@\n private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n     UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n-    Set\u003cVar\u003e unsafeCrossRangeSet \u003d Sets.newHashSet();\n     Scope scope \u003d t.getScope();\n-    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n-        if (cfg.isImplicitReturn(cfgNode)) {\n-            continue;\n-        }\n-        for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n-            final Var v \u003d i.next();\n-            if (!unsafeCrossRangeSet.contains(v)) {\n-                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n-                PrescreenCrossLiveRange check \u003d new PrescreenCrossLiveRange(v, state.getOut());\n-                NodeTraversal.traverse(compiler, cfgNode.getValue(), check);\n-                if (!check.isSafe()) {\n-                    unsafeCrossRangeSet.add(v);\n-                }\n-            }\n-        }\n-    }\n     for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n         Var v \u003d i.next();\n         if (!escaped.contains(v)) {\n             if (!NodeUtil.isFunction(v.getParentNode())) {\n                 interferenceGraph.createNode(v);\n             }\n         }\n     }\n     for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n         Var v1 \u003d i1.next();\n         NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n             Var v2 \u003d i2.next();\n             if (v1.index \u003e\u003d v2.index) {\n                 continue;\n             }\n             if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                 continue NEXT_VAR_PAIR;\n             }\n             if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                 interferenceGraph.connectIfNotFound(v1, null, v2);\n                 continue NEXT_VAR_PAIR;\n             }\n             NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_CROSS_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                     interferenceGraph.connectIfNotFound(v1, null, v2);\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n-            if (!unsafeCrossRangeSet.contains(v1) \u0026\u0026 !unsafeCrossRangeSet.contains(v2)) {\n-                continue NEXT_VAR_PAIR;\n-            }\n             NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_INTRA_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 boolean v1OutLive \u003d state.getOut().isLive(v1);\n                 boolean v2OutLive \u003d state.getOut().isLive(v2);\n                 CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                 NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                 if (checker.connectIfCrossed(interferenceGraph)) {\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n         }\n     }\n     return interferenceGraph;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af3e9dbffe3f76e20389ce7d159a73cf8d91ea41": {
      "type": "Ybodychange",
      "commitMessage": "\nPrescreen variable for live range check. Makes CoalesceVariableNames 10times faster.\n\nR\u003dnicksantos\nDELTA\u003d85  (83 added, 1 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1998\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1127 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/23/11, 6:42 PM",
      "commitName": "af3e9dbffe3f76e20389ce7d159a73cf8d91ea41",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "5/16/11, 3:01 PM",
      "commitNameOld": "828828472848b88b6d3b1e847fa8be5dde78e2da",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.15,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n    Set\u003cVar\u003e unsafeCrossRangeSet \u003d Sets.newHashSet();\n    Scope scope \u003d t.getScope();\n    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n        if (cfg.isImplicitReturn(cfgNode)) {\n            continue;\n        }\n        for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n            final Var v \u003d i.next();\n            if (!unsafeCrossRangeSet.contains(v)) {\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                PrescreenCrossLiveRange check \u003d new PrescreenCrossLiveRange(v, state.getOut());\n                NodeTraversal.traverse(compiler, cfgNode.getValue(), check);\n                if (!check.isSafe()) {\n                    unsafeCrossRangeSet.add(v);\n                }\n            }\n        }\n    }\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n        Var v1 \u003d i1.next();\n        NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n            Var v2 \u003d i2.next();\n            if (v1.index \u003e\u003d v2.index) {\n                continue;\n            }\n            if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                continue NEXT_VAR_PAIR;\n            }\n            if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                interferenceGraph.connectIfNotFound(v1, null, v2);\n                continue NEXT_VAR_PAIR;\n            }\n            NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_CROSS_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n            if (!unsafeCrossRangeSet.contains(v1) \u0026\u0026 !unsafeCrossRangeSet.contains(v2)) {\n                continue NEXT_VAR_PAIR;\n            }\n            NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_INTRA_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                if (checker.connectIfCrossed(interferenceGraph)) {\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 199,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,72 @@\n private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n     UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n+    Set\u003cVar\u003e unsafeCrossRangeSet \u003d Sets.newHashSet();\n     Scope scope \u003d t.getScope();\n+    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n+        if (cfg.isImplicitReturn(cfgNode)) {\n+            continue;\n+        }\n+        for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n+            final Var v \u003d i.next();\n+            if (!unsafeCrossRangeSet.contains(v)) {\n+                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n+                PrescreenCrossLiveRange check \u003d new PrescreenCrossLiveRange(v, state.getOut());\n+                NodeTraversal.traverse(compiler, cfgNode.getValue(), check);\n+                if (!check.isSafe()) {\n+                    unsafeCrossRangeSet.add(v);\n+                }\n+            }\n+        }\n+    }\n     for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n         Var v \u003d i.next();\n         if (!escaped.contains(v)) {\n             if (!NodeUtil.isFunction(v.getParentNode())) {\n                 interferenceGraph.createNode(v);\n             }\n         }\n     }\n     for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n         Var v1 \u003d i1.next();\n         NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n             Var v2 \u003d i2.next();\n             if (v1.index \u003e\u003d v2.index) {\n                 continue;\n             }\n             if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                 continue NEXT_VAR_PAIR;\n             }\n             if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                 interferenceGraph.connectIfNotFound(v1, null, v2);\n                 continue NEXT_VAR_PAIR;\n             }\n             NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_CROSS_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                     interferenceGraph.connectIfNotFound(v1, null, v2);\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n+            if (!unsafeCrossRangeSet.contains(v1) \u0026\u0026 !unsafeCrossRangeSet.contains(v2)) {\n+                continue NEXT_VAR_PAIR;\n+            }\n             NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_INTRA_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 boolean v1OutLive \u003d state.getOut().isLive(v1);\n                 boolean v2OutLive \u003d state.getOut().isLive(v2);\n                 CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                 NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                 if (checker.connectIfCrossed(interferenceGraph)) {\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n         }\n     }\n     return interferenceGraph;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3c5a6f6a1b87c655c5eb3ed0ebcfce886ab6a614": {
      "type": "Ybodychange",
      "commitMessage": "\nAllow graphs without annotations.\n\nR\u003dacleung\nDELTA\u003d405  (249 added, 83 deleted, 73 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d58\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@592 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/3/10, 2:10 PM",
      "commitName": "3c5a6f6a1b87c655c5eb3ed0ebcfce886ab6a614",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/11/10, 9:42 PM",
      "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.69,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n    Scope scope \u003d t.getScope();\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n        Var v1 \u003d i1.next();\n        NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n            Var v2 \u003d i2.next();\n            if (v1.index \u003e\u003d v2.index) {\n                continue;\n            }\n            if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                continue NEXT_VAR_PAIR;\n            }\n            if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                interferenceGraph.connectIfNotFound(v1, null, v2);\n                continue NEXT_VAR_PAIR;\n            }\n            NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_CROSS_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n            NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_INTRA_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                if (checker.connectIfCrossed(interferenceGraph)) {\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 199,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,52 @@\n private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n-    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n+    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d LinkedUndirectedGraph.create();\n     Scope scope \u003d t.getScope();\n     for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n         Var v \u003d i.next();\n         if (!escaped.contains(v)) {\n             if (!NodeUtil.isFunction(v.getParentNode())) {\n                 interferenceGraph.createNode(v);\n             }\n         }\n     }\n     for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n         Var v1 \u003d i1.next();\n         NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n             Var v2 \u003d i2.next();\n             if (v1.index \u003e\u003d v2.index) {\n                 continue;\n             }\n             if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                 continue NEXT_VAR_PAIR;\n             }\n             if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                 interferenceGraph.connectIfNotFound(v1, null, v2);\n                 continue NEXT_VAR_PAIR;\n             }\n             NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_CROSS_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                     interferenceGraph.connectIfNotFound(v1, null, v2);\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n             NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                 if (cfg.isImplicitReturn(cfgNode)) {\n                     continue NEXT_INTRA_CFG_NODE;\n                 }\n                 FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                 boolean v1OutLive \u003d state.getOut().isLive(v1);\n                 boolean v2OutLive \u003d state.getOut().isLive(v2);\n                 CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                 NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                 if (checker.connectIfCrossed(interferenceGraph)) {\n                     continue NEXT_VAR_PAIR;\n                 }\n             }\n         }\n     }\n     return interferenceGraph;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a486b8345202c35efe3a2b63f16259e1933c359c": {
      "type": "Ybodychange",
      "commitMessage": "\nCut variable coalescing runtime by about 40%.\nIf we know that variables x and y intersect, then we don\u0027t have\nto look at them again.\n\nR\u003djohnlenz\nDELTA\u003d140  (41 added, 61 deleted, 38 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d223254\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@430 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/15/10, 10:30 AM",
      "commitName": "a486b8345202c35efe3a2b63f16259e1933c359c",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n    Scope scope \u003d t.getScope();\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n        Var v1 \u003d i1.next();\n        NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n            Var v2 \u003d i2.next();\n            if (v1.index \u003e\u003d v2.index) {\n                continue;\n            }\n            if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                continue NEXT_VAR_PAIR;\n            }\n            if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                interferenceGraph.connectIfNotFound(v1, null, v2);\n                continue NEXT_VAR_PAIR;\n            }\n            NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_CROSS_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n            NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n                if (cfg.isImplicitReturn(cfgNode)) {\n                    continue NEXT_INTRA_CFG_NODE;\n                }\n                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n                NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n                if (checker.connectIfCrossed(interferenceGraph)) {\n                    continue NEXT_VAR_PAIR;\n                }\n            }\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 199,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,52 @@\n private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n     UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n     Scope scope \u003d t.getScope();\n     for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n         Var v \u003d i.next();\n         if (!escaped.contains(v)) {\n             if (!NodeUtil.isFunction(v.getParentNode())) {\n                 interferenceGraph.createNode(v);\n             }\n         }\n     }\n-    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n-        FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n-        if (cfg.isImplicitReturn(cfgNode)) {\n-            continue;\n-        }\n-        int varsInScope \u003d scope.getVarCount();\n-        ArrayList\u003cCombinedLiveRangeChecker\u003e rangesToCheck \u003d new ArrayList\u003cCombinedLiveRangeChecker\u003e(varsInScope * varsInScope);\n-        for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n-            Var v1 \u003d i1.next();\n-            for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n-                Var v2 \u003d i2.next();\n-                if (v1 \u003d\u003d v2 || !interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n-                    continue;\n+    for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n+        Var v1 \u003d i1.next();\n+        NEXT_VAR_PAIR: for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n+            Var v2 \u003d i2.next();\n+            if (v1.index \u003e\u003d v2.index) {\n+                continue;\n+            }\n+            if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n+                continue NEXT_VAR_PAIR;\n+            }\n+            if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n+                interferenceGraph.connectIfNotFound(v1, null, v2);\n+                continue NEXT_VAR_PAIR;\n+            }\n+            NEXT_CROSS_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n+                if (cfg.isImplicitReturn(cfgNode)) {\n+                    continue NEXT_CROSS_CFG_NODE;\n                 }\n-                boolean v1OutLive \u003d state.getOut().isLive(v1);\n-                boolean v2OutLive \u003d state.getOut().isLive(v2);\n-                if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n+                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n+                if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (state.getOut().isLive(v1) \u0026\u0026 state.getOut().isLive(v2))) {\n                     interferenceGraph.connectIfNotFound(v1, null, v2);\n-                } else if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (v1OutLive \u0026\u0026 v2OutLive)) {\n-                    interferenceGraph.connectIfNotFound(v1, null, v2);\n-                } else {\n-                    LiveRangeChecker checker1 \u003d new LiveRangeChecker(v1, v2OutLive ? null : v2);\n-                    LiveRangeChecker checker2 \u003d new LiveRangeChecker(v2, v1OutLive ? null : v1);\n-                    rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2));\n+                    continue NEXT_VAR_PAIR;\n                 }\n             }\n-        }\n-        checkRanges(rangesToCheck, cfgNode.getValue());\n-        for (CombinedLiveRangeChecker range : rangesToCheck) {\n-            range.connectIfCrossed(interferenceGraph);\n+            NEXT_INTRA_CFG_NODE: for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n+                if (cfg.isImplicitReturn(cfgNode)) {\n+                    continue NEXT_INTRA_CFG_NODE;\n+                }\n+                FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n+                boolean v1OutLive \u003d state.getOut().isLive(v1);\n+                boolean v2OutLive \u003d state.getOut().isLive(v2);\n+                CombinedLiveRangeChecker checker \u003d new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1));\n+                NodeTraversal.traverse(compiler, cfgNode.getValue(), checker);\n+                if (checker.connectIfCrossed(interferenceGraph)) {\n+                    continue NEXT_VAR_PAIR;\n+                }\n+            }\n         }\n     }\n     return interferenceGraph;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c25df7eca2462861bf42ad8b74215099c3f81ae6": {
      "type": "Yformatchange",
      "commitMessage": "Make lists the canonical representation of compiler sources.\nThey\u0027re so much easier to sort and mutate, which is going to\nmake a difference once we start sorting sources. (Nick)\nR\u003drobert\nDELTA\u003d97  (58 added, 6 deleted, 33 changed)\n\ninclude everything in the @license tag. (Nick)\nR\u003drobert\nDELTA\u003d78  (32 added, 19 deleted, 27 changed)\n\ntag externs files with the @externs tag. (Nick)\nR\u003dalan\nDELTA\u003d45  (45 added, 0 deleted, 0 changed)\n\nfix for issue 58.\nwork-around a bug in IE where it gets confused if the comparator\npassed to Array.prototype.sort writes to its own parameters. (Nick)\nR\u003dalan\nDELTA\u003d33  (30 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003ddpiluc\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@171 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 11:58 PM",
      "commitName": "c25df7eca2462861bf42ad8b74215099c3f81ae6",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/8/10, 1:41 PM",
      "commitNameOld": "6d374c3ee4c9c2651ffb44048924e127fd2bf37c",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 87.39,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n    Scope scope \u003d t.getScope();\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n        FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n        if (cfg.isImplicitReturn(cfgNode)) {\n            continue;\n        }\n        int varsInScope \u003d scope.getVarCount();\n        ArrayList\u003cCombinedLiveRangeChecker\u003e rangesToCheck \u003d new ArrayList\u003cCombinedLiveRangeChecker\u003e(varsInScope * varsInScope);\n        for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n            Var v1 \u003d i1.next();\n            for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n                Var v2 \u003d i2.next();\n                if (v1 \u003d\u003d v2 || !interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                    continue;\n                }\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                } else if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (v1OutLive \u0026\u0026 v2OutLive)) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                } else {\n                    LiveRangeChecker checker1 \u003d new LiveRangeChecker(v1, v2OutLive ? null : v2);\n                    LiveRangeChecker checker2 \u003d new LiveRangeChecker(v2, v1OutLive ? null : v1);\n                    rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2));\n                }\n            }\n        }\n        checkRanges(rangesToCheck, cfgNode.getValue());\n        for (CombinedLiveRangeChecker range : rangesToCheck) {\n            range.connectIfCrossed(interferenceGraph);\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 198,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,45 @@\n+private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n+    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n+    Scope scope \u003d t.getScope();\n+    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n+        Var v \u003d i.next();\n+        if (!escaped.contains(v)) {\n+            if (!NodeUtil.isFunction(v.getParentNode())) {\n+                interferenceGraph.createNode(v);\n+            }\n+        }\n+    }\n+    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n+        FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n+        if (cfg.isImplicitReturn(cfgNode)) {\n+            continue;\n+        }\n+        int varsInScope \u003d scope.getVarCount();\n+        ArrayList\u003cCombinedLiveRangeChecker\u003e rangesToCheck \u003d new ArrayList\u003cCombinedLiveRangeChecker\u003e(varsInScope * varsInScope);\n+        for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n+            Var v1 \u003d i1.next();\n+            for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n+                Var v2 \u003d i2.next();\n+                if (v1 \u003d\u003d v2 || !interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n+                    continue;\n+                }\n+                boolean v1OutLive \u003d state.getOut().isLive(v1);\n+                boolean v2OutLive \u003d state.getOut().isLive(v2);\n+                if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n+                    interferenceGraph.connectIfNotFound(v1, null, v2);\n+                } else if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (v1OutLive \u0026\u0026 v2OutLive)) {\n+                    interferenceGraph.connectIfNotFound(v1, null, v2);\n+                } else {\n+                    LiveRangeChecker checker1 \u003d new LiveRangeChecker(v1, v2OutLive ? null : v2);\n+                    LiveRangeChecker checker2 \u003d new LiveRangeChecker(v2, v1OutLive ? null : v1);\n+                    rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2));\n+                }\n+            }\n+        }\n+        checkRanges(rangesToCheck, cfgNode.getValue());\n+        for (CombinedLiveRangeChecker range : rangesToCheck) {\n+            range.connectIfCrossed(interferenceGraph);\n+        }\n+    }\n+    return interferenceGraph;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private UndiGraph\u003cVar, Void\u003e computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph\u003cNode\u003e cfg, Set\u003cVar\u003e escaped) {\n    UndiGraph\u003cVar, Void\u003e interferenceGraph \u003d new LinkedUndirectedGraph\u003cVar, Void\u003e();\n    Scope scope \u003d t.getScope();\n    for (Iterator\u003cVar\u003e i \u003d scope.getVars(); i.hasNext(); ) {\n        Var v \u003d i.next();\n        if (!escaped.contains(v)) {\n            if (!NodeUtil.isFunction(v.getParentNode())) {\n                interferenceGraph.createNode(v);\n            }\n        }\n    }\n    for (DiGraphNode\u003cNode, Branch\u003e cfgNode : cfg.getDirectedGraphNodes()) {\n        FlowState\u003cLiveVariableLattice\u003e state \u003d cfgNode.getAnnotation();\n        if (cfg.isImplicitReturn(cfgNode)) {\n            continue;\n        }\n        int varsInScope \u003d scope.getVarCount();\n        ArrayList\u003cCombinedLiveRangeChecker\u003e rangesToCheck \u003d new ArrayList\u003cCombinedLiveRangeChecker\u003e(varsInScope * varsInScope);\n        for (Iterator\u003cVar\u003e i1 \u003d scope.getVars(); i1.hasNext(); ) {\n            Var v1 \u003d i1.next();\n            for (Iterator\u003cVar\u003e i2 \u003d scope.getVars(); i2.hasNext(); ) {\n                Var v2 \u003d i2.next();\n                if (v1 \u003d\u003d v2 || !interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) {\n                    continue;\n                }\n                boolean v1OutLive \u003d state.getOut().isLive(v1);\n                boolean v2OutLive \u003d state.getOut().isLive(v2);\n                if (v1.getParentNode().getType() \u003d\u003d Token.LP \u0026\u0026 v2.getParentNode().getType() \u003d\u003d Token.LP) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                } else if ((state.getIn().isLive(v1) \u0026\u0026 state.getIn().isLive(v2)) || (v1OutLive \u0026\u0026 v2OutLive)) {\n                    interferenceGraph.connectIfNotFound(v1, null, v2);\n                } else {\n                    LiveRangeChecker checker1 \u003d new LiveRangeChecker(v1, v2OutLive ? null : v2);\n                    LiveRangeChecker checker2 \u003d new LiveRangeChecker(v2, v1OutLive ? null : v1);\n                    rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2));\n                }\n            }\n        }\n        checkRanges(rangesToCheck, cfgNode.getValue());\n        for (CombinedLiveRangeChecker range : rangesToCheck) {\n            range.connectIfCrossed(interferenceGraph);\n        }\n    }\n    return interferenceGraph;\n}",
      "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
      "functionStartLine": 161,
      "functionName": "computeVariableNamesInterferenceGraph",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}