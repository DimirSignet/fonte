{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExploitAssigns.java",
  "functionName": "collapseAssignEqualTo",
  "functionId": "collapseAssignEqualTo___expr-Node__exprParent-Node__value-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ExploitAssigns.java",
  "functionAnnotation": "",
  "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
  "functionStartLine": 108,
  "functionEndLine": 199,
  "numCommitsSeen": 17,
  "timeTaken": 1257,
  "changeHistory": [
    "b7d0c1729ff32aa456727ed8c04dce277b1ebf89",
    "e4cf805a6a27301672660756202e8dedee1e012b",
    "7c44f228de588387734227a0c08be36d11bf2b17",
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
    "9150994b2e41be7d49ca7ab03d3d751f782650ee",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "b7d0c1729ff32aa456727ed8c04dce277b1ebf89": "Ymultichange(Ymovefromfile,Yformatchange)",
    "e4cf805a6a27301672660756202e8dedee1e012b": "Ybodychange",
    "7c44f228de588387734227a0c08be36d11bf2b17": "Ybodychange",
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a": "Ybodychange",
    "9150994b2e41be7d49ca7ab03d3d751f782650ee": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b7d0c1729ff32aa456727ed8c04dce277b1ebf89": {
      "type": "Ymultichange(Ymovefromfile,Yformatchange)",
      "commitMessage": "\nMove ExploitAssigns on its own.\n\nR\u003djohnlenz\nDELTA\u003d785  (437 added, 348 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d878\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@886 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/15/11, 11:18 AM",
      "commitName": "b7d0c1729ff32aa456727ed8c04dce277b1ebf89",
      "commitAuthor": "acleung@google.com",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "\nMove ExploitAssigns on its own.\n\nR\u003djohnlenz\nDELTA\u003d785  (437 added, 348 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d878\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@886 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/15/11, 11:18 AM",
          "commitName": "b7d0c1729ff32aa456727ed8c04dce277b1ebf89",
          "commitAuthor": "acleung@google.com",
          "commitDateOld": "3/15/11, 9:26 AM",
          "commitNameOld": "8d1ce6799ec27e62fd39fa0abc30ec4664b9b209",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n        }\n    }\n    return false;\n}",
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
          "functionStartLine": 108,
          "functionName": "collapseAssignEqualTo",
          "functionAnnotation": "",
          "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
          "diff": "",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
            "newPath": "src/com/google/javascript/jscomp/ExploitAssigns.java",
            "oldMethodName": "collapseAssignEqualTo",
            "newMethodName": "collapseAssignEqualTo"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "\nMove ExploitAssigns on its own.\n\nR\u003djohnlenz\nDELTA\u003d785  (437 added, 348 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d878\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@886 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/15/11, 11:18 AM",
          "commitName": "b7d0c1729ff32aa456727ed8c04dce277b1ebf89",
          "commitAuthor": "acleung@google.com",
          "commitDateOld": "3/15/11, 9:26 AM",
          "commitNameOld": "8d1ce6799ec27e62fd39fa0abc30ec4664b9b209",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n        }\n    }\n    return false;\n}",
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
          "functionStartLine": 108,
          "functionName": "collapseAssignEqualTo",
          "functionAnnotation": "",
          "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "e4cf805a6a27301672660756202e8dedee1e012b": {
      "type": "Ybodychange",
      "commitMessage": "\nAvoid unnecessary temporary objects when comparing node trees.\n\nR\u003dacleung\nDELTA\u003d64  (17 added, 22 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d762\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@849 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/3/11, 5:04 PM",
      "commitName": "e4cf805a6a27301672660756202e8dedee1e012b",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/2/11, 3:41 PM",
      "commitNameOld": "7c44f228de588387734227a0c08be36d11bf2b17",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.06,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "functionStartLine": 188,
      "functionName": "collapseAssignEqualTo",
      "functionAnnotation": "",
      "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
      "diff": "@@ -1,58 +1,58 @@\n private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n     Node assign \u003d expr.getFirstChild();\n     Node parent \u003d exprParent;\n     Node next \u003d expr.getNext();\n     while (next !\u003d null) {\n         switch(next.getType()) {\n             case Token.AND:\n             case Token.OR:\n             case Token.HOOK:\n             case Token.IF:\n             case Token.RETURN:\n             case Token.EXPR_RESULT:\n                 parent \u003d next;\n                 next \u003d next.getFirstChild();\n                 break;\n             case Token.VAR:\n                 if (next.getFirstChild().hasChildren()) {\n                     parent \u003d next.getFirstChild();\n                     next \u003d parent.getFirstChild();\n                     break;\n                 }\n                 return false;\n             case Token.GETPROP:\n             case Token.NAME:\n                 if (next.isQualifiedName()) {\n                     String nextName \u003d next.getQualifiedName();\n                     if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                         if (!isSafeReplacement(next, assign)) {\n                             return false;\n                         }\n                         exprParent.removeChild(expr);\n                         expr.removeChild(assign);\n                         parent.replaceChild(next, assign);\n                         return true;\n                     }\n                 }\n                 return false;\n             case Token.ASSIGN:\n                 Node leftSide \u003d next.getFirstChild();\n                 if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                     parent \u003d next;\n                     next \u003d leftSide.getNext();\n                     break;\n                 } else {\n                     return false;\n                 }\n             default:\n-                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.checkTreeEqualsSilent(value)) {\n+                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n                     exprParent.removeChild(expr);\n                     expr.removeChild(assign);\n                     parent.replaceChild(next, assign);\n                     return true;\n                 }\n                 return false;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c44f228de588387734227a0c08be36d11bf2b17": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003dacleung\nDELTA\u003d118  (82 added, 32 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d751\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@845 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/2/11, 3:41 PM",
      "commitName": "7c44f228de588387734227a0c08be36d11bf2b17",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/24/11, 1:58 PM",
      "commitNameOld": "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
      "commitAuthorOld": "ankit@google.com",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.checkTreeEqualsSilent(value)) {\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "functionStartLine": 188,
      "functionName": "collapseAssignEqualTo",
      "functionAnnotation": "",
      "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
      "diff": "@@ -1,67 +1,58 @@\n private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n     Node assign \u003d expr.getFirstChild();\n     Node parent \u003d exprParent;\n     Node next \u003d expr.getNext();\n     while (next !\u003d null) {\n         switch(next.getType()) {\n             case Token.AND:\n             case Token.OR:\n             case Token.HOOK:\n             case Token.IF:\n             case Token.RETURN:\n             case Token.EXPR_RESULT:\n                 parent \u003d next;\n                 next \u003d next.getFirstChild();\n                 break;\n             case Token.VAR:\n                 if (next.getFirstChild().hasChildren()) {\n                     parent \u003d next.getFirstChild();\n                     next \u003d parent.getFirstChild();\n                     break;\n                 }\n                 return false;\n             case Token.GETPROP:\n             case Token.NAME:\n                 if (next.isQualifiedName()) {\n                     String nextName \u003d next.getQualifiedName();\n                     if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                         if (!isSafeReplacement(next, assign)) {\n                             return false;\n                         }\n                         exprParent.removeChild(expr);\n                         expr.removeChild(assign);\n                         parent.replaceChild(next, assign);\n                         return true;\n                     }\n                 }\n                 return false;\n-            case Token.NUMBER:\n-            case Token.TRUE:\n-            case Token.FALSE:\n-            case Token.NULL:\n-            case Token.STRING:\n-                if (value.getType() \u003d\u003d next.getType()) {\n-                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n-                        return false;\n-                    }\n-                    exprParent.removeChild(expr);\n-                    expr.removeChild(assign);\n-                    parent.replaceChild(next, assign);\n-                    return true;\n-                }\n-                return false;\n             case Token.ASSIGN:\n                 Node leftSide \u003d next.getFirstChild();\n                 if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                     parent \u003d next;\n                     next \u003d leftSide.getNext();\n                     break;\n                 } else {\n                     return false;\n                 }\n             default:\n+                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.checkTreeEqualsSilent(value)) {\n+                    exprParent.removeChild(expr);\n+                    expr.removeChild(assign);\n+                    parent.replaceChild(next, assign);\n+                    return true;\n+                }\n                 return false;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks gmail\n\n*** Original change description ***\n\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003djohnlenz\nDELTA\u003d114  (32 added, 78 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d668\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@817 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 1:58 PM",
      "commitName": "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
      "commitAuthor": "ankit@google.com",
      "commitDateOld": "2/24/11, 12:11 PM",
      "commitNameOld": "9150994b2e41be7d49ca7ab03d3d751f782650ee",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.NUMBER:\n            case Token.TRUE:\n            case Token.FALSE:\n            case Token.NULL:\n            case Token.STRING:\n                if (value.getType() \u003d\u003d next.getType()) {\n                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n                        return false;\n                    }\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                return false;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "functionStartLine": 192,
      "functionName": "collapseAssignEqualTo",
      "functionAnnotation": "",
      "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
      "diff": "@@ -1,58 +1,67 @@\n private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n     Node assign \u003d expr.getFirstChild();\n     Node parent \u003d exprParent;\n     Node next \u003d expr.getNext();\n     while (next !\u003d null) {\n         switch(next.getType()) {\n             case Token.AND:\n             case Token.OR:\n             case Token.HOOK:\n             case Token.IF:\n             case Token.RETURN:\n             case Token.EXPR_RESULT:\n                 parent \u003d next;\n                 next \u003d next.getFirstChild();\n                 break;\n             case Token.VAR:\n                 if (next.getFirstChild().hasChildren()) {\n                     parent \u003d next.getFirstChild();\n                     next \u003d parent.getFirstChild();\n                     break;\n                 }\n                 return false;\n             case Token.GETPROP:\n             case Token.NAME:\n                 if (next.isQualifiedName()) {\n                     String nextName \u003d next.getQualifiedName();\n                     if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                         if (!isSafeReplacement(next, assign)) {\n                             return false;\n                         }\n                         exprParent.removeChild(expr);\n                         expr.removeChild(assign);\n                         parent.replaceChild(next, assign);\n                         return true;\n                     }\n                 }\n                 return false;\n+            case Token.NUMBER:\n+            case Token.TRUE:\n+            case Token.FALSE:\n+            case Token.NULL:\n+            case Token.STRING:\n+                if (value.getType() \u003d\u003d next.getType()) {\n+                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n+                        return false;\n+                    }\n+                    exprParent.removeChild(expr);\n+                    expr.removeChild(assign);\n+                    parent.replaceChild(next, assign);\n+                    return true;\n+                }\n+                return false;\n             case Token.ASSIGN:\n                 Node leftSide \u003d next.getFirstChild();\n                 if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                     parent \u003d next;\n                     next \u003d leftSide.getNext();\n                     break;\n                 } else {\n                     return false;\n                 }\n             default:\n-                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n-                    exprParent.removeChild(expr);\n-                    expr.removeChild(assign);\n-                    parent.replaceChild(next, assign);\n-                    return true;\n-                }\n                 return false;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9150994b2e41be7d49ca7ab03d3d751f782650ee": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003dacleung\nDELTA\u003d114  (78 added, 32 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d665\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@814 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 12:11 PM",
      "commitName": "9150994b2e41be7d49ca7ab03d3d751f782650ee",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/16/10, 1:20 PM",
      "commitNameOld": "8936be78f9ecad965b20fbf9ea78eda49514454e",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 69.95,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "functionStartLine": 188,
      "functionName": "collapseAssignEqualTo",
      "functionAnnotation": "",
      "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n",
      "diff": "@@ -1,67 +1,58 @@\n private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n     Node assign \u003d expr.getFirstChild();\n     Node parent \u003d exprParent;\n     Node next \u003d expr.getNext();\n     while (next !\u003d null) {\n         switch(next.getType()) {\n             case Token.AND:\n             case Token.OR:\n             case Token.HOOK:\n             case Token.IF:\n             case Token.RETURN:\n             case Token.EXPR_RESULT:\n                 parent \u003d next;\n                 next \u003d next.getFirstChild();\n                 break;\n             case Token.VAR:\n                 if (next.getFirstChild().hasChildren()) {\n                     parent \u003d next.getFirstChild();\n                     next \u003d parent.getFirstChild();\n                     break;\n                 }\n                 return false;\n             case Token.GETPROP:\n             case Token.NAME:\n                 if (next.isQualifiedName()) {\n                     String nextName \u003d next.getQualifiedName();\n                     if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                         if (!isSafeReplacement(next, assign)) {\n                             return false;\n                         }\n                         exprParent.removeChild(expr);\n                         expr.removeChild(assign);\n                         parent.replaceChild(next, assign);\n                         return true;\n                     }\n                 }\n                 return false;\n-            case Token.NUMBER:\n-            case Token.TRUE:\n-            case Token.FALSE:\n-            case Token.NULL:\n-            case Token.STRING:\n-                if (value.getType() \u003d\u003d next.getType()) {\n-                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n-                        return false;\n-                    }\n-                    exprParent.removeChild(expr);\n-                    expr.removeChild(assign);\n-                    parent.replaceChild(next, assign);\n-                    return true;\n-                }\n-                return false;\n             case Token.ASSIGN:\n                 Node leftSide \u003d next.getFirstChild();\n                 if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                     parent \u003d next;\n                     next \u003d leftSide.getNext();\n                     break;\n                 } else {\n                     return false;\n                 }\n             default:\n+                if (NodeUtil.isImmutableValue(next) \u0026\u0026 next.isEquivalentTo(value)) {\n+                    exprParent.removeChild(expr);\n+                    expr.removeChild(assign);\n+                    parent.replaceChild(next, assign);\n+                    return true;\n+                }\n                 return false;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,67 @@\n+private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n+    Node assign \u003d expr.getFirstChild();\n+    Node parent \u003d exprParent;\n+    Node next \u003d expr.getNext();\n+    while (next !\u003d null) {\n+        switch(next.getType()) {\n+            case Token.AND:\n+            case Token.OR:\n+            case Token.HOOK:\n+            case Token.IF:\n+            case Token.RETURN:\n+            case Token.EXPR_RESULT:\n+                parent \u003d next;\n+                next \u003d next.getFirstChild();\n+                break;\n+            case Token.VAR:\n+                if (next.getFirstChild().hasChildren()) {\n+                    parent \u003d next.getFirstChild();\n+                    next \u003d parent.getFirstChild();\n+                    break;\n+                }\n+                return false;\n+            case Token.GETPROP:\n+            case Token.NAME:\n+                if (next.isQualifiedName()) {\n+                    String nextName \u003d next.getQualifiedName();\n+                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n+                        if (!isSafeReplacement(next, assign)) {\n+                            return false;\n+                        }\n+                        exprParent.removeChild(expr);\n+                        expr.removeChild(assign);\n+                        parent.replaceChild(next, assign);\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            case Token.NUMBER:\n+            case Token.TRUE:\n+            case Token.FALSE:\n+            case Token.NULL:\n+            case Token.STRING:\n+                if (value.getType() \u003d\u003d next.getType()) {\n+                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n+                        return false;\n+                    }\n+                    exprParent.removeChild(expr);\n+                    expr.removeChild(assign);\n+                    parent.replaceChild(next, assign);\n+                    return true;\n+                }\n+                return false;\n+            case Token.ASSIGN:\n+                Node leftSide \u003d next.getFirstChild();\n+                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n+                    parent \u003d next;\n+                    next \u003d leftSide.getNext();\n+                    break;\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                return false;\n+        }\n+    }\n+    return false;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) {\n    Node assign \u003d expr.getFirstChild();\n    Node parent \u003d exprParent;\n    Node next \u003d expr.getNext();\n    while (next !\u003d null) {\n        switch(next.getType()) {\n            case Token.AND:\n            case Token.OR:\n            case Token.HOOK:\n            case Token.IF:\n            case Token.RETURN:\n            case Token.EXPR_RESULT:\n                parent \u003d next;\n                next \u003d next.getFirstChild();\n                break;\n            case Token.VAR:\n                if (next.getFirstChild().hasChildren()) {\n                    parent \u003d next.getFirstChild();\n                    next \u003d parent.getFirstChild();\n                    break;\n                }\n                return false;\n            case Token.GETPROP:\n            case Token.NAME:\n                if (next.isQualifiedName()) {\n                    String nextName \u003d next.getQualifiedName();\n                    if (value.isQualifiedName() \u0026\u0026 nextName.equals(value.getQualifiedName())) {\n                        if (!isSafeReplacement(next, assign)) {\n                            return false;\n                        }\n                        exprParent.removeChild(expr);\n                        expr.removeChild(assign);\n                        parent.replaceChild(next, assign);\n                        return true;\n                    }\n                }\n                return false;\n            case Token.NUMBER:\n            case Token.TRUE:\n            case Token.FALSE:\n            case Token.NULL:\n            case Token.STRING:\n                if (value.getType() \u003d\u003d next.getType()) {\n                    if ((next.getType() \u003d\u003d Token.STRING || next.getType() \u003d\u003d Token.NUMBER) \u0026\u0026 !next.isEquivalentTo(value)) {\n                        return false;\n                    }\n                    exprParent.removeChild(expr);\n                    expr.removeChild(assign);\n                    parent.replaceChild(next, assign);\n                    return true;\n                }\n                return false;\n            case Token.ASSIGN:\n                Node leftSide \u003d next.getFirstChild();\n                if (leftSide.getType() \u003d\u003d Token.NAME || leftSide.getType() \u003d\u003d Token.GETPROP \u0026\u0026 leftSide.getFirstChild().getType() \u003d\u003d Token.THIS) {\n                    parent \u003d next;\n                    next \u003d leftSide.getNext();\n                    break;\n                } else {\n                    return false;\n                }\n            default:\n                return false;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
      "functionStartLine": 193,
      "functionName": "collapseAssignEqualTo",
      "functionAnnotation": "",
      "functionDoc": "Collapse the given assign expression into the expression directly\nfollowing it, if possible.\n\n@param expr The expression that may be moved.\n@param exprParent The parent of {@code expr}.\n@param value The value of this expression, expressed as a node. Each\n    expression may have multiple values, so this function may be called\n    multiple times for the same expression. For example,\n    \u003ccode\u003e\n    a \u003d true;\n    \u003c/code\u003e\n    is equal to the name \"a\" and the boolean \"true\".\n@return Whether the expression was collapsed succesfully.\n"
    }
  }
}