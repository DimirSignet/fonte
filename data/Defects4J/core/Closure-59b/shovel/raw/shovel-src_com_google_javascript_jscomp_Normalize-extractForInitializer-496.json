{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Normalize.java",
  "functionName": "extractForInitializer",
  "functionId": "$extractForInitializer___n-Node__before-Node__beforeParent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/Normalize.java",
  "functionAnnotation": "",
  "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
  "functionStartLine": 496,
  "functionEndLine": 543,
  "numCommitsSeen": 31,
  "timeTaken": 1505,
  "changeHistory": [
    "28e179cd72aa4a20155767563b2572424a8b1e56",
    "82ba14e2d8c636f707c65249f8968e89f72718d0",
    "2dc356a34ace77d20b27fa90fb6467d303bd09a8",
    "9a185e0c06b0a595ca0e6fb7990945cd0114a12f",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "28e179cd72aa4a20155767563b2572424a8b1e56": "Ybodychange",
    "82ba14e2d8c636f707c65249f8968e89f72718d0": "Ybodychange",
    "2dc356a34ace77d20b27fa90fb6467d303bd09a8": "Ybodychange",
    "9a185e0c06b0a595ca0e6fb7990945cd0114a12f": "Yformatchange",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "28e179cd72aa4a20155767563b2572424a8b1e56": {
      "type": "Ybodychange",
      "commitMessage": "\nFix normalization of var declarations in for-in statements.\n\nR\u003dacleung\nDELTA\u003d12  (7 added, 0 deleted, 5 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1311\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@985 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/8/11, 4:07 PM",
      "commitName": "28e179cd72aa4a20155767563b2572424a8b1e56",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/2/11, 3:30 PM",
      "commitNameOld": "5d397618f3c86d9c444a4c4c6441267b8a89a21d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 36.98,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (NodeUtil.isForIn(c)) {\n                    Node first \u003d c.getFirstChild();\n                    if (first.getType() \u003d\u003d Token.VAR) {\n                        Node newStatement \u003d first;\n                        Node name \u003d newStatement.getFirstChild().cloneNode();\n                        first.getParent().replaceChild(first, name);\n                        insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                        reportCodeChange(\"FOR-IN var declaration\");\n                    }\n                } else if (c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    Node empty \u003d new Node(Token.EMPTY);\n                    empty.copyInformationFrom(c);\n                    c.replaceChild(init, empty);\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 496,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
      "diff": "@@ -1,37 +1,37 @@\n private void extractForInitializer(Node n, Node before, Node beforeParent) {\n     for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n         next \u003d c.getNext();\n         Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n         Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n         switch(c.getType()) {\n             case Token.LABEL:\n                 extractForInitializer(c, insertBefore, insertBeforeParent);\n                 break;\n             case Token.FOR:\n                 if (NodeUtil.isForIn(c)) {\n                     Node first \u003d c.getFirstChild();\n                     if (first.getType() \u003d\u003d Token.VAR) {\n-                        Node newStatement \u003d first.cloneTree();\n-                        Node name \u003d first.removeFirstChild();\n+                        Node newStatement \u003d first;\n+                        Node name \u003d newStatement.getFirstChild().cloneNode();\n                         first.getParent().replaceChild(first, name);\n                         insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                         reportCodeChange(\"FOR-IN var declaration\");\n                     }\n                 } else if (c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                     Node init \u003d c.getFirstChild();\n                     Node empty \u003d new Node(Token.EMPTY);\n                     empty.copyInformationFrom(c);\n                     c.replaceChild(init, empty);\n                     Node newStatement;\n                     if (init.getType() \u003d\u003d Token.VAR) {\n                         newStatement \u003d init;\n                     } else {\n                         newStatement \u003d NodeUtil.newExpr(init);\n                     }\n                     insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                     reportCodeChange(\"FOR initializer\");\n                 }\n                 break;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82ba14e2d8c636f707c65249f8968e89f72718d0": {
      "type": "Ybodychange",
      "commitMessage": "\nA little more normalization: remove VAR declarations from FOR-IN looops.\n\nR\u003dnicksantos\nDELTA\u003d84  (71 added, 1 deleted, 12 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d207783\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@412 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 4:48 PM",
      "commitName": "82ba14e2d8c636f707c65249f8968e89f72718d0",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/1/10, 7:18 AM",
      "commitNameOld": "b9bc1534921f1e98da5a373e39ea2d71a4a39175",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.4,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (NodeUtil.isForIn(c)) {\n                    Node first \u003d c.getFirstChild();\n                    if (first.getType() \u003d\u003d Token.VAR) {\n                        Node newStatement \u003d first.cloneTree();\n                        Node name \u003d first.removeFirstChild();\n                        first.getParent().replaceChild(first, name);\n                        insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                        reportCodeChange(\"FOR-IN var declaration\");\n                    }\n                } else if (c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    Node empty \u003d new Node(Token.EMPTY);\n                    empty.copyInformationFrom(c);\n                    c.replaceChild(init, empty);\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 431,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
      "diff": "@@ -1,28 +1,37 @@\n private void extractForInitializer(Node n, Node before, Node beforeParent) {\n     for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n         next \u003d c.getNext();\n         Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n         Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n         switch(c.getType()) {\n             case Token.LABEL:\n                 extractForInitializer(c, insertBefore, insertBeforeParent);\n                 break;\n             case Token.FOR:\n-                if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n+                if (NodeUtil.isForIn(c)) {\n+                    Node first \u003d c.getFirstChild();\n+                    if (first.getType() \u003d\u003d Token.VAR) {\n+                        Node newStatement \u003d first.cloneTree();\n+                        Node name \u003d first.removeFirstChild();\n+                        first.getParent().replaceChild(first, name);\n+                        insertBeforeParent.addChildBefore(newStatement, insertBefore);\n+                        reportCodeChange(\"FOR-IN var declaration\");\n+                    }\n+                } else if (c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                     Node init \u003d c.getFirstChild();\n                     Node empty \u003d new Node(Token.EMPTY);\n                     empty.copyInformationFrom(c);\n                     c.replaceChild(init, empty);\n                     Node newStatement;\n                     if (init.getType() \u003d\u003d Token.VAR) {\n                         newStatement \u003d init;\n                     } else {\n                         newStatement \u003d NodeUtil.newExpr(init);\n                     }\n                     insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                     reportCodeChange(\"FOR initializer\");\n                 }\n                 break;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dc356a34ace77d20b27fa90fb6467d303bd09a8": {
      "type": "Ybodychange",
      "commitMessage": "Follow up on code review comments: preserve souce information during normalization. (John)\nR\u003dnick\nDELTA\u003d28  (22 added, 0 deleted, 6 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@150 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/23/10, 2:27 PM",
      "commitName": "2dc356a34ace77d20b27fa90fb6467d303bd09a8",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/22/10, 3:55 PM",
      "commitNameOld": "b347ce3a71e23a4ab92dc0a6c07d43e2f497c953",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    Node empty \u003d new Node(Token.EMPTY);\n                    empty.copyInformationFrom(c);\n                    c.replaceChild(init, empty);\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 404,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
      "diff": "@@ -1,26 +1,28 @@\n private void extractForInitializer(Node n, Node before, Node beforeParent) {\n     for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n         next \u003d c.getNext();\n         Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n         Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n         switch(c.getType()) {\n             case Token.LABEL:\n                 extractForInitializer(c, insertBefore, insertBeforeParent);\n                 break;\n             case Token.FOR:\n                 if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                     Node init \u003d c.getFirstChild();\n-                    c.replaceChild(init, new Node(Token.EMPTY));\n+                    Node empty \u003d new Node(Token.EMPTY);\n+                    empty.copyInformationFrom(c);\n+                    c.replaceChild(init, empty);\n                     Node newStatement;\n                     if (init.getType() \u003d\u003d Token.VAR) {\n                         newStatement \u003d init;\n                     } else {\n                         newStatement \u003d NodeUtil.newExpr(init);\n                     }\n                     insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                     reportCodeChange(\"FOR initializer\");\n                 }\n                 break;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a185e0c06b0a595ca0e6fb7990945cd0114a12f": {
      "type": "Yformatchange",
      "commitMessage": "Run cross module code motion before and after devirtualization. (Alan)\n\nMaking ErrorPass package-private. (Brad)\n\nImprove strict equality comparisons. (John)\n\nUpdate comments and minor cleanup of Normalize. (John)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@133 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/10/10, 9:49 PM",
      "commitName": "9a185e0c06b0a595ca0e6fb7990945cd0114a12f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 7:11 AM",
      "commitNameOld": "d48c365ba8251057a71a2e2b7aabff640209e31b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 12.61,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    c.replaceChild(init, new Node(Token.EMPTY));\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 331,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": {
      "type": "Ybodychange",
      "commitMessage": "Add a mechanism for inlining local vars, and turn it on by default.\nWarnings for \"ambiguous\" function definitions.\nRefactoring and renaming of some method names.\nUse \"\u003d\" optionality annotation in externs.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@15 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/25/09, 6:53 AM",
      "commitName": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/16/09, 4:04 PM",
      "commitNameOld": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 8.62,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    c.replaceChild(init, new Node(Token.EMPTY));\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 313,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n",
      "diff": "@@ -1,26 +1,26 @@\n private void extractForInitializer(Node n, Node before, Node beforeParent) {\n     for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n         next \u003d c.getNext();\n         Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n         Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n         switch(c.getType()) {\n             case Token.LABEL:\n                 extractForInitializer(c, insertBefore, insertBeforeParent);\n                 break;\n             case Token.FOR:\n-                if (c.getChildCount() \u003d\u003d 4 \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n+                if (!NodeUtil.isForIn(c) \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                     Node init \u003d c.getFirstChild();\n                     c.replaceChild(init, new Node(Token.EMPTY));\n                     Node newStatement;\n                     if (init.getType() \u003d\u003d Token.VAR) {\n                         newStatement \u003d init;\n                     } else {\n                         newStatement \u003d NodeUtil.newExpr(init);\n                     }\n                     insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                     reportCodeChange(\"FOR initializer\");\n                 }\n                 break;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,26 @@\n+private void extractForInitializer(Node n, Node before, Node beforeParent) {\n+    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n+        next \u003d c.getNext();\n+        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n+        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n+        switch(c.getType()) {\n+            case Token.LABEL:\n+                extractForInitializer(c, insertBefore, insertBeforeParent);\n+                break;\n+            case Token.FOR:\n+                if (c.getChildCount() \u003d\u003d 4 \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n+                    Node init \u003d c.getFirstChild();\n+                    c.replaceChild(init, new Node(Token.EMPTY));\n+                    Node newStatement;\n+                    if (init.getType() \u003d\u003d Token.VAR) {\n+                        newStatement \u003d init;\n+                    } else {\n+                        newStatement \u003d NodeUtil.newExpr(init);\n+                    }\n+                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n+                    reportCodeChange(\"FOR initializer\");\n+                }\n+                break;\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void extractForInitializer(Node n, Node before, Node beforeParent) {\n    for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n        next \u003d c.getNext();\n        Node insertBefore \u003d (before \u003d\u003d null) ? c : before;\n        Node insertBeforeParent \u003d (before \u003d\u003d null) ? n : beforeParent;\n        switch(c.getType()) {\n            case Token.LABEL:\n                extractForInitializer(c, insertBefore, insertBeforeParent);\n                break;\n            case Token.FOR:\n                if (c.getChildCount() \u003d\u003d 4 \u0026\u0026 c.getFirstChild().getType() !\u003d Token.EMPTY) {\n                    Node init \u003d c.getFirstChild();\n                    c.replaceChild(init, new Node(Token.EMPTY));\n                    Node newStatement;\n                    if (init.getType() \u003d\u003d Token.VAR) {\n                        newStatement \u003d init;\n                    } else {\n                        newStatement \u003d NodeUtil.newExpr(init);\n                    }\n                    insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                    reportCodeChange(\"FOR initializer\");\n                }\n                break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Normalize.java",
      "functionStartLine": 279,
      "functionName": "extractForInitializer",
      "functionAnnotation": "",
      "functionDoc": "Bring the initializers out of FOR loops.  These need to be placed\nbefore any associated LABEL nodes. This needs to be done from the top\nlevel label first so this is called as a pre-order callback (from\nshouldTraverse).\n\n@param n The node to inspect.\n@param before The node to insert the initializer before.\n@param beforeParent The parent of the node before which the initializer\n    will be inserted.\n"
    }
  }
}