{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CheckSideEffects.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/CheckSideEffects.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 47,
  "functionEndLine": 123,
  "numCommitsSeen": 12,
  "timeTaken": 409,
  "changeHistory": [
    "a07ce4c8fa380151233f3a155fff1e37c117aae0",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
    "c857311f08df730f98cc47e9b59383b0349fe9b3",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "a07ce4c8fa380151233f3a155fff1e37c117aae0": "Ybodychange",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": "Ybodychange",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": "Ybodychange",
    "c857311f08df730f98cc47e9b59383b0349fe9b3": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a07ce4c8fa380151233f3a155fff1e37c117aae0": {
      "type": "Ybodychange",
      "commitMessage": "\nBetter error messaging about operators whose result is unused.\n\nR\u003dacleung\nDELTA\u003d13  (12 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2507\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1249 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/6/11, 8:14 PM",
      "commitName": "a07ce4c8fa380151233f3a155fff1e37c117aae0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 85.33,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 47,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,47 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n-    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n+    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n+    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n+        } else if (isSimpleOp) {\n+            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/12/10, 7:59 AM",
      "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n-    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n+    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": {
      "type": "Ybodychange",
      "commitMessage": "Remove circular dependency between error-reporting and the rest\nof the compiler. (Nick)\nR\u003dalan\nDELTA\u003d152  (27 added, 28 deleted, 97 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@159 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/29/10, 7:04 AM",
      "commitName": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/27/10, 3:48 PM",
      "commitNameOld": "c857311f08df730f98cc47e9b59383b0349fe9b3",
      "commitAuthorOld": "dbentley@google.com",
      "daysBetweenCommits": 60.6,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n-        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n+        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c857311f08df730f98cc47e9b59383b0349fe9b3": {
      "type": "Ybodychange",
      "commitMessage": "Allow the COMMA operator to be used to make a call to eval indirect.\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@78 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/10, 3:48 PM",
      "commitName": "c857311f08df730f98cc47e9b59383b0349fe9b3",
      "commitAuthor": "dbentley@google.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 85.0,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n+        Node gramps \u003d parent.getParent();\n+        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n+            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n+                return;\n+            }\n+        }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n         t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,38 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n+        return;\n+    }\n+    if (parent \u003d\u003d null)\n+        return;\n+    int pt \u003d parent.getType();\n+    if (pt \u003d\u003d Token.COMMA) {\n+        if (n \u003d\u003d parent.getLastChild()) {\n+            for (Node an : parent.getAncestors()) {\n+                int ancestorType \u003d an.getType();\n+                if (ancestorType \u003d\u003d Token.COMMA)\n+                    continue;\n+                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n+                    return;\n+                else\n+                    break;\n+            }\n+        }\n+    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n+        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n+        } else {\n+            return;\n+        }\n+    }\n+    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n+        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n+            return;\n+        } else if (NodeUtil.isExpressionNode(n)) {\n+            return;\n+        }\n+        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n+        if (n.getType() \u003d\u003d Token.STRING) {\n+            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n+        }\n+        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}