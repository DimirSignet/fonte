{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MinimizeExitPoints.java",
  "functionName": "tryMinimizeExits",
  "functionId": "tryMinimizeExits___n-Node__exitType-int__labelName-String",
  "sourceFilePath": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
  "functionAnnotation": "",
  "functionDoc": "Attempts to minimize the number of explicit exit points in a control\nstructure to take advantage of the implied exit at the end of the\nstructure.  This is accomplished by removing redundant statements, and\nmoving statements following a qualifying IF node into that node.\nFor example:\n\nfunction () {\n  if (x) return;\n  else blah();\n  foo();\n}\n\nbecomes:\n\nfunction () {\n if (x) ;\n else {\n   blah();\n   foo();\n }\n\n@param n The execution node of a parent to inspect.\n@param exitType The type of exit to look for.\n@param labelName If parent is a label the name of the label to look for,\n  null otherwise.\n@nullable labelName non-null only for breaks within labels.\n",
  "functionStartLine": 113,
  "functionEndLine": 204,
  "numCommitsSeen": 9,
  "timeTaken": 416,
  "changeHistory": [
    "43859717972907dd1ecebd8dca6e05036386e28b",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "43859717972907dd1ecebd8dca6e05036386e28b": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "43859717972907dd1ecebd8dca6e05036386e28b": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/14 by john\n\n        Stop creating specialized Node types for FUNCTION and SCRIPT as the added functionality isn\u0027t used anywhere.\n\n        Also correct some formatting issue with Node (as it won\u0027t need to be merged with anything else anymore).\n\n        R\u003dsteve,robert\n        DELTA\u003d3969  (1913 added, 1925 deleted, 131 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source information in MinimizeExitPoints.\n\n        R\u003drobert\n        DELTA\u003d10  (5 added, 2 deleted, 3 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information.\n\n        R\u003dantonio\n        DELTA\u003d17  (11 added, 0 deleted, 6 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information through FoldConstants.\n\n        R\u003drobert\n        DELTA\u003d42  (22 added, 0 deleted, 20 changed)\n\nChange on 2010/04/14 by nick\n\n        lock down function type construction\n\n        R\u003djohn\n        DELTA\u003d111  (83 added, 9 deleted, 19 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source info in CollapseProperties.\n\n        R\u003dnick\n        DELTA\u003d17  (8 added, 3 deleted, 6 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmbevwz\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 4:53 PM",
      "commitName": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 33.77,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    if (n.getType() \u003d\u003d Token.IF) {\n        Node ifBlock \u003d n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock \u003d ifBlock.getNext();\n        if (elseBlock !\u003d null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    if (n.getType() \u003d\u003d Token.TRY) {\n        Node tryBlock \u003d n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes \u003d NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode \u003d allCatchNodes.getFirstChild();\n            Node catchCodeBlock \u003d catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock \u003d n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    if (n.getType() \u003d\u003d Token.LABEL) {\n        Node labelBlock \u003d n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    if (n.getType() !\u003d Token.BLOCK || n.getLastChild() \u003d\u003d null) {\n        return;\n    }\n    for (Node c : n.children()) {\n        if (c.getType() \u003d\u003d Token.IF) {\n            Node ifTree \u003d c;\n            Node trueBlock, falseBlock;\n            trueBlock \u003d ifTree.getFirstChild().getNext();\n            falseBlock \u003d trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            trueBlock \u003d ifTree.getFirstChild().getNext();\n            falseBlock \u003d trueBlock.getNext();\n            if (falseBlock !\u003d null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c \u003d\u003d n.getLastChild()) {\n            break;\n        }\n    }\n    for (Node c \u003d n.getLastChild(); c !\u003d null; c \u003d n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        if (c \u003d\u003d n.getLastChild()) {\n            break;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
      "functionStartLine": 112,
      "functionName": "tryMinimizeExits",
      "functionAnnotation": "",
      "functionDoc": "Attempts to minimize the number of explicit exit points in a control\nstructure to take advantage of the implied exit at the end of the\nstructure.  This is accomplished by removing redundant statements, and\nmoving statements following a qualifying IF node into that node.\nFor example:\n\nfunction () {\n  if (x) return;\n  else blah();\n  foo();\n}\n\nbecomes:\n\nfunction () {\n if (x) ;\n else {\n   blah();\n   foo();\n }\n\n@param n The execution node of a parent to inspect.\n@param exitType The type of exit to look for.\n@param labelName If parent is a label the name of the label to look for,\n  null otherwise.\n@nullable labelName non-null only for breaks within labels.\n",
      "diff": "@@ -1,62 +1,61 @@\n void tryMinimizeExits(Node n, int exitType, String labelName) {\n     if (matchingExitNode(n, exitType, labelName)) {\n         NodeUtil.removeChild(n.getParent(), n);\n         compiler.reportCodeChange();\n         return;\n     }\n     if (n.getType() \u003d\u003d Token.IF) {\n         Node ifBlock \u003d n.getFirstChild().getNext();\n         tryMinimizeExits(ifBlock, exitType, labelName);\n         Node elseBlock \u003d ifBlock.getNext();\n         if (elseBlock !\u003d null) {\n             tryMinimizeExits(elseBlock, exitType, labelName);\n         }\n         return;\n     }\n     if (n.getType() \u003d\u003d Token.TRY) {\n         Node tryBlock \u003d n.getFirstChild();\n         tryMinimizeExits(tryBlock, exitType, labelName);\n         Node allCatchNodes \u003d NodeUtil.getCatchBlock(n);\n         if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n             Preconditions.checkState(allCatchNodes.hasOneChild());\n             Node catchNode \u003d allCatchNodes.getFirstChild();\n             Node catchCodeBlock \u003d catchNode.getLastChild();\n             tryMinimizeExits(catchCodeBlock, exitType, labelName);\n         }\n         if (NodeUtil.hasFinally(n)) {\n             Node finallyBlock \u003d n.getLastChild();\n             tryMinimizeExits(finallyBlock, exitType, labelName);\n         }\n     }\n     if (n.getType() \u003d\u003d Token.LABEL) {\n         Node labelBlock \u003d n.getLastChild();\n         tryMinimizeExits(labelBlock, exitType, labelName);\n     }\n     if (n.getType() !\u003d Token.BLOCK || n.getLastChild() \u003d\u003d null) {\n         return;\n     }\n     for (Node c : n.children()) {\n         if (c.getType() \u003d\u003d Token.IF) {\n             Node ifTree \u003d c;\n             Node trueBlock, falseBlock;\n             trueBlock \u003d ifTree.getFirstChild().getNext();\n             falseBlock \u003d trueBlock.getNext();\n             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n             trueBlock \u003d ifTree.getFirstChild().getNext();\n             falseBlock \u003d trueBlock.getNext();\n             if (falseBlock !\u003d null) {\n                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n             }\n         }\n         if (c \u003d\u003d n.getLastChild()) {\n             break;\n         }\n     }\n     for (Node c \u003d n.getLastChild(); c !\u003d null; c \u003d n.getLastChild()) {\n         tryMinimizeExits(c, exitType, labelName);\n         if (c \u003d\u003d n.getLastChild()) {\n             break;\n         }\n     }\n-    return;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,62 @@\n+void tryMinimizeExits(Node n, int exitType, String labelName) {\n+    if (matchingExitNode(n, exitType, labelName)) {\n+        NodeUtil.removeChild(n.getParent(), n);\n+        compiler.reportCodeChange();\n+        return;\n+    }\n+    if (n.getType() \u003d\u003d Token.IF) {\n+        Node ifBlock \u003d n.getFirstChild().getNext();\n+        tryMinimizeExits(ifBlock, exitType, labelName);\n+        Node elseBlock \u003d ifBlock.getNext();\n+        if (elseBlock !\u003d null) {\n+            tryMinimizeExits(elseBlock, exitType, labelName);\n+        }\n+        return;\n+    }\n+    if (n.getType() \u003d\u003d Token.TRY) {\n+        Node tryBlock \u003d n.getFirstChild();\n+        tryMinimizeExits(tryBlock, exitType, labelName);\n+        Node allCatchNodes \u003d NodeUtil.getCatchBlock(n);\n+        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n+            Preconditions.checkState(allCatchNodes.hasOneChild());\n+            Node catchNode \u003d allCatchNodes.getFirstChild();\n+            Node catchCodeBlock \u003d catchNode.getLastChild();\n+            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+        }\n+        if (NodeUtil.hasFinally(n)) {\n+            Node finallyBlock \u003d n.getLastChild();\n+            tryMinimizeExits(finallyBlock, exitType, labelName);\n+        }\n+    }\n+    if (n.getType() \u003d\u003d Token.LABEL) {\n+        Node labelBlock \u003d n.getLastChild();\n+        tryMinimizeExits(labelBlock, exitType, labelName);\n+    }\n+    if (n.getType() !\u003d Token.BLOCK || n.getLastChild() \u003d\u003d null) {\n+        return;\n+    }\n+    for (Node c : n.children()) {\n+        if (c.getType() \u003d\u003d Token.IF) {\n+            Node ifTree \u003d c;\n+            Node trueBlock, falseBlock;\n+            trueBlock \u003d ifTree.getFirstChild().getNext();\n+            falseBlock \u003d trueBlock.getNext();\n+            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n+            trueBlock \u003d ifTree.getFirstChild().getNext();\n+            falseBlock \u003d trueBlock.getNext();\n+            if (falseBlock !\u003d null) {\n+                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n+            }\n+        }\n+        if (c \u003d\u003d n.getLastChild()) {\n+            break;\n+        }\n+    }\n+    for (Node c \u003d n.getLastChild(); c !\u003d null; c \u003d n.getLastChild()) {\n+        tryMinimizeExits(c, exitType, labelName);\n+        if (c \u003d\u003d n.getLastChild()) {\n+            break;\n+        }\n+    }\n+    return;\n+}\n\\ No newline at end of file\n",
      "actualSource": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n    if (n.getType() \u003d\u003d Token.IF) {\n        Node ifBlock \u003d n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock \u003d ifBlock.getNext();\n        if (elseBlock !\u003d null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n    if (n.getType() \u003d\u003d Token.TRY) {\n        Node tryBlock \u003d n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes \u003d NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode \u003d allCatchNodes.getFirstChild();\n            Node catchCodeBlock \u003d catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock \u003d n.getLastChild();\n            tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n    if (n.getType() \u003d\u003d Token.LABEL) {\n        Node labelBlock \u003d n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n    if (n.getType() !\u003d Token.BLOCK || n.getLastChild() \u003d\u003d null) {\n        return;\n    }\n    for (Node c : n.children()) {\n        if (c.getType() \u003d\u003d Token.IF) {\n            Node ifTree \u003d c;\n            Node trueBlock, falseBlock;\n            trueBlock \u003d ifTree.getFirstChild().getNext();\n            falseBlock \u003d trueBlock.getNext();\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n            trueBlock \u003d ifTree.getFirstChild().getNext();\n            falseBlock \u003d trueBlock.getNext();\n            if (falseBlock !\u003d null) {\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n        }\n        if (c \u003d\u003d n.getLastChild()) {\n            break;\n        }\n    }\n    for (Node c \u003d n.getLastChild(); c !\u003d null; c \u003d n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        if (c \u003d\u003d n.getLastChild()) {\n            break;\n        }\n    }\n    return;\n}",
      "path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
      "functionStartLine": 112,
      "functionName": "tryMinimizeExits",
      "functionAnnotation": "",
      "functionDoc": "Attempts to minimize the number of explicit exit points in a control\nstructure to take advantage of the implied exit at the end of the\nstructure.  This is accomplished by removing redundant statements, and\nmoving statements following a qualifying IF node into that node.\nFor example:\n\nfunction () {\n  if (x) return;\n  else blah();\n  foo();\n}\n\nbecomes:\n\nfunction () {\n if (x) ;\n else {\n   blah();\n   foo();\n }\n\n@param n The execution node of a parent to inspect.\n@param exitType The type of exit to look for.\n@param labelName If parent is a label the name of the label to look for,\n  null otherwise.\n@nullable labelName non-null only for breaks within labels.\n"
    }
  }
}