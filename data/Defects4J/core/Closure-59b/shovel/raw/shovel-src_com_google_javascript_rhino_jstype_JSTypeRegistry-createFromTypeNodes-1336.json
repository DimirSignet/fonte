{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JSTypeRegistry.java",
  "functionName": "createFromTypeNodes",
  "functionId": "createFromTypeNodes___n-Node__sourceName-String__scope-StaticScope__JSType__",
  "sourceFilePath": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
  "functionAnnotation": "",
  "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
  "functionStartLine": 1336,
  "functionEndLine": 1347,
  "numCommitsSeen": 41,
  "timeTaken": 3038,
  "changeHistory": [
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
    "de13c3313c05f4449c50c560324389d6905a214d",
    "2dbbe0784ee3e549eb0cc4d679aeddaac1243145",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0": "Ybodychange",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": "Ybodychange",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": "Ybodychange",
    "de13c3313c05f4449c50c560324389d6905a214d": "Ybodychange",
    "2dbbe0784ee3e549eb0cc4d679aeddaac1243145": "Ybodychange",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0": {
      "type": "Ybodychange",
      "commitMessage": "\nUnforgiven types.\nNow that you can suppress type-parsing warnings by simply turning\noff type checking, we should just get rid of all the old forgiving\nlogic.\n\nR\u003dacleung\nDELTA\u003d128  (5 added, 86 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d812\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@872 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/10/11, 8:26 AM",
      "commitName": "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/7/11, 5:08 PM",
      "commitNameOld": "f80152eb5a2de72e8336b26e0e78b9e6baae37d2",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 2.64,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n        boolean hasNames \u003d hasTypeName(n);\n        if (hasNames) {\n            return new UnresolvedTypeExpression(this, n, sourceName);\n        }\n    }\n    return createFromTypeNodesInternal(n, sourceName, scope);\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1336,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,3 +1,9 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n-    return createFromTypeNodes(n, sourceName, scope, false);\n+    if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n+        boolean hasNames \u003d hasTypeName(n);\n+        if (hasNames) {\n+            return new UnresolvedTypeExpression(this, n, sourceName);\n+        }\n+    }\n+    return createFromTypeNodesInternal(n, sourceName, scope);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": {
      "type": "Ybodychange",
      "commitMessage": "Change on 2010/04/26 by nick\n\n        forbid getters and setters. fixes closure-compiler issue 154.\n\n        R\u003drobert\n        DELTA\u003d57  (55 added, 0 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a helper method for getting the transitive closure of a\n        number of roots.\n\n        R\u003dalan\n        DELTA\u003d172  (168 added, 2 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a new mechanism for type name resolution.\n\n        R\u003djohn\n        DELTA\u003d222  (210 added, 5 deleted, 7 changed)\n\nChange on 2010/04/27 by john\n\n        Remove unused variables in uncalled global functions when not removing\n        unused global names. Fixes issue 155.\n\n        R\u003dnick\n        DELTA\u003d42  (34 added, 3 deleted, 5 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003daepekd\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@199 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/27/10, 12:02 PM",
      "commitName": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/21/10, 4:48 PM",
      "commitNameOld": "5bde370c377946671edd3408878413d236399944",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    return createFromTypeNodes(n, sourceName, scope, false);\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1301,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,86 +1,3 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n-    switch(n.getType()) {\n-        case Token.LC:\n-            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n-        case Token.BANG:\n-            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n-        case Token.QMARK:\n-            Node firstChild \u003d n.getFirstChild();\n-            if (firstChild \u003d\u003d null) {\n-                return getNativeType(UNKNOWN_TYPE);\n-            }\n-            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope));\n-        case Token.EQUALS:\n-            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n-        case Token.ELLIPSIS:\n-            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n-        case Token.STAR:\n-            return getNativeType(ALL_TYPE);\n-        case Token.LB:\n-            return getNativeType(ARRAY_TYPE);\n-        case Token.PIPE:\n-            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n-            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n-                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n-            }\n-            return builder.build();\n-        case Token.EMPTY:\n-            return getNativeType(UNKNOWN_TYPE);\n-        case Token.VOID:\n-            return getNativeType(VOID_TYPE);\n-        case Token.STRING:\n-            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n-            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n-                Node typeList \u003d n.getFirstChild();\n-                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n-                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n-                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n-                    if (typeList.hasMoreThanOneChild()) {\n-                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n-                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n-                    }\n-                }\n-                return createDefaultObjectUnion(namedType);\n-            } else {\n-                return namedType;\n-            }\n-        case Token.FUNCTION:\n-            ObjectType thisType \u003d null;\n-            Node current \u003d n.getFirstChild();\n-            if (current.getType() \u003d\u003d Token.THIS) {\n-                Node thisNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n-                if (thisType \u003d\u003d null) {\n-                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n-                }\n-                current \u003d current.getNext();\n-            }\n-            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n-            if (current.getType() \u003d\u003d Token.LP) {\n-                Node args \u003d current.getFirstChild();\n-                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n-                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n-                        if (arg.getChildCount() \u003d\u003d 0) {\n-                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n-                        } else {\n-                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n-                        }\n-                    } else {\n-                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n-                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n-                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n-                            if (!addSuccess) {\n-                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n-                            }\n-                        } else {\n-                            paramBuilder.addRequiredParams(type);\n-                        }\n-                    }\n-                }\n-                current \u003d current.getNext();\n-            }\n-            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n-            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n-    }\n-    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+    return createFromTypeNodes(n, sourceName, scope, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by nick\n\n        Move the construction of ArrowTypes out of FunctionType.\n\n        R\u003djohn\n        DELTA\u003d197  (79 added, 27 deleted, 91 changed)\n\nChange on 2010/04/15 by nick\n\n        if a file is marked as an @extern, then make it an extern.\n\n        R\u003drobert\n        DELTA\u003d51  (46 added, 0 deleted, 5 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information.\n\n        R\u003dalan\n        DELTA\u003d60  (28 added, 7 deleted, 25 changed)\n\nChange on 2010/04/15 by john\n\n        Fix overly aggressive RegExp check.\n\n        R\u003dalan\n        DELTA\u003d15  (12 added, 0 deleted, 3 changed)\n\nChange on 2010/04/15 by nick\n\n        more fun with function-type building.\n\n        R\u003djohn\n        DELTA\u003d432  (206 added, 142 deleted, 84 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003doqlcyn\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@186 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/15/10, 4:45 PM",
      "commitName": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 4:53 PM",
      "commitNameOld": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1245,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,86 +1,86 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n-            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de13c3313c05f4449c50c560324389d6905a214d": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Experimental option: Flag to change named object references from \"Object|null\" to \"Object|null|undefined\".\n\n        R\u003dalan,nick\n        DELTA\u003d7144  (7131 added, 5 deleted, 8 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        get rid of some backdoor gmail apis.\n\n        R\u003djohn\n        DELTA\u003d44  (0 added, 33 deleted, 11 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        fix TypeCheckTest to parse externs files properly.\n        i still need to merge the TypeCheckTest-forking cl into this one.\n\n        R\u003djohn\n        DELTA\u003d42  (12 added, 0 deleted, 30 changed)\n\nChange on 2010/04/13 by john\n\n        Enable expression decomposition for function inlining by default.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by john\n\n        Move ReplaceCssNames to allow type checking of goog.getCssName.\n\n        R\u003dmark\n        DELTA\u003d39  (35 added, 4 deleted, 0 changed)\n\nChange on 2010/04/13 by john\n\n        Maintain source and type information during ReplaceCssNames.\n\n        R\u003dmark\n        DELTA\u003d31  (30 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by nick\n\n        fix up type information on event listener functions.\n\n        R\u003dalan\n        DELTA\u003d2  (0 added, 0 deleted, 2 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dwescxy\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@182 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/13/10, 2:39 PM",
      "commitName": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/9/10, 11:07 AM",
      "commitNameOld": "2dbbe0784ee3e549eb0cc4d679aeddaac1243145",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.15,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1195,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,86 +1,86 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n-            return createNullableType(createFromTypeNodes(firstChild, sourceName, scope));\n+            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n-                return createNullableType(namedType);\n+                return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n             return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dbbe0784ee3e549eb0cc4d679aeddaac1243145": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/09 by nick\n\n        Make it possible to explicitly specify unknown parameter and\n        return types.\n\n        R\u003dnada\n        DELTA\u003d77  (74 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dwjzzsm\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@179 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/9/10, 11:07 AM",
      "commitName": "2dbbe0784ee3e549eb0cc4d679aeddaac1243145",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 8:34 AM",
      "commitNameOld": "a2f9d4f043be0fac4d868061fbc5d088ed31823b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createNullableType(createFromTypeNodes(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createNullableType(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1170,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,82 +1,86 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n-            return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+            Node firstChild \u003d n.getFirstChild();\n+            if (firstChild \u003d\u003d null) {\n+                return getNativeType(UNKNOWN_TYPE);\n+            }\n+            return createNullableType(createFromTypeNodes(firstChild, sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createNullableType(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n             return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": {
      "type": "Ybodychange",
      "commitMessage": "Add warnings for functions that are ambiguously defined on different\nbrowsers.\n\nAdd better support for Caja.\n\nRollback the change to CoalesceVariableNames, because it had problems.\n\nInternal type system refactoring.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@33 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/09, 1:52 PM",
      "commitName": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/8/09, 3:50 PM",
      "commitNameOld": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createNullableType(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1167,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n",
      "diff": "@@ -1,84 +1,82 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createNullableType(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n-                JSType maybeThisType \u003d createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined();\n-                if (maybeThisType instanceof ObjectType) {\n-                    thisType \u003d (ObjectType) maybeThisType;\n-                } else {\n+                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n+                if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n             return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,84 @@\n+public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n+    switch(n.getType()) {\n+        case Token.LC:\n+            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n+        case Token.BANG:\n+            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n+        case Token.QMARK:\n+            return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+        case Token.EQUALS:\n+            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+        case Token.ELLIPSIS:\n+            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+        case Token.STAR:\n+            return getNativeType(ALL_TYPE);\n+        case Token.LB:\n+            return getNativeType(ARRAY_TYPE);\n+        case Token.PIPE:\n+            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n+            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n+                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n+            }\n+            return builder.build();\n+        case Token.EMPTY:\n+            return getNativeType(UNKNOWN_TYPE);\n+        case Token.VOID:\n+            return getNativeType(VOID_TYPE);\n+        case Token.STRING:\n+            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+                Node typeList \u003d n.getFirstChild();\n+                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n+                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n+                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n+                    if (typeList.hasMoreThanOneChild()) {\n+                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n+                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n+                    }\n+                }\n+                return createNullableType(namedType);\n+            } else {\n+                return namedType;\n+            }\n+        case Token.FUNCTION:\n+            ObjectType thisType \u003d null;\n+            Node current \u003d n.getFirstChild();\n+            if (current.getType() \u003d\u003d Token.THIS) {\n+                Node thisNode \u003d current.getFirstChild();\n+                JSType maybeThisType \u003d createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined();\n+                if (maybeThisType instanceof ObjectType) {\n+                    thisType \u003d (ObjectType) maybeThisType;\n+                } else {\n+                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                }\n+                current \u003d current.getNext();\n+            }\n+            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n+            if (current.getType() \u003d\u003d Token.LP) {\n+                Node args \u003d current.getFirstChild();\n+                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n+                        if (arg.getChildCount() \u003d\u003d 0) {\n+                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n+                        } else {\n+                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n+                        }\n+                    } else {\n+                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n+                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n+                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n+                            if (!addSuccess) {\n+                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n+                            }\n+                        } else {\n+                            paramBuilder.addRequiredParams(type);\n+                        }\n+                    }\n+                }\n+                current \u003d current.getNext();\n+            }\n+            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n+            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n+    }\n+    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+}\n\\ No newline at end of file\n",
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createNullableType(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                JSType maybeThisType \u003d createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined();\n                if (maybeThisType instanceof ObjectType) {\n                    thisType \u003d (ObjectType) maybeThisType;\n                } else {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null);\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1167,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n"
    }
  }
}