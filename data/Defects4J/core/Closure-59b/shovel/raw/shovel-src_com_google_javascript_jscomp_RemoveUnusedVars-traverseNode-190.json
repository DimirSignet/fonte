{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RemoveUnusedVars.java",
  "functionName": "traverseNode",
  "functionId": "traverseNode___n-Node__parent-Node__scope-Scope",
  "sourceFilePath": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
  "functionAnnotation": "",
  "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
  "functionStartLine": 190,
  "functionEndLine": 294,
  "numCommitsSeen": 37,
  "timeTaken": 1664,
  "changeHistory": [
    "c49ac6ab45a86109a8b95432a8a773d7a62068b4",
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
    "24507d99ee74582adac5ea3cd2d971679dd73567",
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
    "833cd72a268c1161194038faf0d98ec6b1f203eb",
    "4672a1aca15e6d5c3e7c2e00e31767f3c8327335",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "c49ac6ab45a86109a8b95432a8a773d7a62068b4": "Ybodychange",
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31": "Ybodychange",
    "24507d99ee74582adac5ea3cd2d971679dd73567": "Ybodychange",
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56": "Ybodychange",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": "Ymultichange(Ybodychange,Ydocchange)",
    "833cd72a268c1161194038faf0d98ec6b1f203eb": "Ybodychange",
    "4672a1aca15e6d5c3e7c2e00e31767f3c8327335": "Ybodychange",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Ybodychange",
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c49ac6ab45a86109a8b95432a8a773d7a62068b4": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen arguments arrays is used, don\u0027t remove assignments on parameter even if they appear to be dead.\n\nR\u003dnicksantos\nDELTA\u003d18  (16 added, 1 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1769\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1057 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/4/11, 2:42 PM",
      "commitName": "c49ac6ab45a86109a8b95432a8a773d7a62068b4",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "4/20/11, 8:16 AM",
      "commitNameOld": "77063ce89ab93f9778c34804a992079c672d8ba5",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 14.27,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.CALL:\n            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n            if (subclassRelationship !\u003d null) {\n                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n                if (subclassVar !\u003d null \u0026\u0026 subclassVar.isGlobal() \u0026\u0026 !referenced.contains(subclassVar)) {\n                    inheritsCalls.put(subclassVar, parent);\n                    continuations.put(subclassVar, new Continuation(n, scope));\n                    return;\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (\"arguments\".equals(n.getString()) \u0026\u0026 scope.isLocal()) {\n                    Node lp \u003d scope.getRootNode().getFirstChild().getNext();\n                    for (Node a \u003d lp.getFirstChild(); a !\u003d null; a \u003d a.getNext()) {\n                        markReferencedVar(scope.getVar(a.getString()));\n                    }\n                }\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 190,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
      "diff": "@@ -1,64 +1,70 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 var \u003d scope.getVar(n.getFirstChild().getString());\n             }\n             if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                 continuations.put(var, new Continuation(n, scope));\n             } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.ASSIGN:\n             Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n             if (maybeAssign !\u003d null) {\n                 var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                 if (var !\u003d null) {\n                     assignsByVar.put(var, maybeAssign);\n                     assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                     if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                         continuations.put(var, new Continuation(n, scope));\n                         return;\n                     }\n                 }\n             }\n             break;\n         case Token.CALL:\n             SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n             if (subclassRelationship !\u003d null) {\n                 Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n                 if (subclassVar !\u003d null \u0026\u0026 subclassVar.isGlobal() \u0026\u0026 !referenced.contains(subclassVar)) {\n                     inheritsCalls.put(subclassVar, parent);\n                     continuations.put(subclassVar, new Continuation(n, scope));\n                     return;\n                 }\n             }\n             break;\n         case Token.NAME:\n             var \u003d scope.getVar(n.getString());\n             if (parent.getType() \u003d\u003d Token.VAR) {\n                 Node value \u003d n.getFirstChild();\n                 if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                     continuations.put(var, new Continuation(n, scope));\n                     return;\n                 }\n             } else {\n+                if (\"arguments\".equals(n.getString()) \u0026\u0026 scope.isLocal()) {\n+                    Node lp \u003d scope.getRootNode().getFirstChild().getNext();\n+                    for (Node a \u003d lp.getFirstChild(); a !\u003d null; a \u003d a.getNext()) {\n+                        markReferencedVar(scope.getVar(a.getString()));\n+                    }\n+                }\n                 if (var !\u003d null) {\n                     if (isRemovableVar(var)) {\n                         if (!assignsByNode.containsKey(n)) {\n                             markReferencedVar(var);\n                         }\n                     } else {\n                         markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31": {
      "type": "Ybodychange",
      "commitMessage": "\nMake RemoveUnusedVars know about goog.inherits (Attempt #2)\n\nR\u003dnicksantos\nDELTA\u003d153  (150 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d476\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@767 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/11, 2:27 PM",
      "commitName": "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
      "commitAuthor": "agrieve@google.com",
      "commitDateOld": "2/7/11, 10:20 AM",
      "commitNameOld": "24507d99ee74582adac5ea3cd2d971679dd73567",
      "commitAuthorOld": "agrieve@google.com",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.CALL:\n            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n            if (subclassRelationship !\u003d null) {\n                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n                if (subclassVar !\u003d null \u0026\u0026 subclassVar.isGlobal() \u0026\u0026 !referenced.contains(subclassVar)) {\n                    inheritsCalls.put(subclassVar, parent);\n                    continuations.put(subclassVar, new Continuation(n, scope));\n                    return;\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 187,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
      "diff": "@@ -1,53 +1,64 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 var \u003d scope.getVar(n.getFirstChild().getString());\n             }\n             if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                 continuations.put(var, new Continuation(n, scope));\n             } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.ASSIGN:\n             Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n             if (maybeAssign !\u003d null) {\n                 var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                 if (var !\u003d null) {\n                     assignsByVar.put(var, maybeAssign);\n                     assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                     if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                         continuations.put(var, new Continuation(n, scope));\n                         return;\n                     }\n                 }\n             }\n             break;\n+        case Token.CALL:\n+            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n+            if (subclassRelationship !\u003d null) {\n+                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n+                if (subclassVar !\u003d null \u0026\u0026 subclassVar.isGlobal() \u0026\u0026 !referenced.contains(subclassVar)) {\n+                    inheritsCalls.put(subclassVar, parent);\n+                    continuations.put(subclassVar, new Continuation(n, scope));\n+                    return;\n+                }\n+            }\n+            break;\n         case Token.NAME:\n             var \u003d scope.getVar(n.getString());\n             if (parent.getType() \u003d\u003d Token.VAR) {\n                 Node value \u003d n.getFirstChild();\n                 if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                     continuations.put(var, new Continuation(n, scope));\n                     return;\n                 }\n             } else {\n                 if (var !\u003d null) {\n                     if (isRemovableVar(var)) {\n                         if (!assignsByNode.containsKey(n)) {\n                             markReferencedVar(var);\n                         }\n                     } else {\n                         markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "24507d99ee74582adac5ea3cd2d971679dd73567": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\n-Broke gmail\n\n*** Original change description ***\n\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (0 added, 132 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d451\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@762 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/7/11, 10:20 AM",
      "commitName": "24507d99ee74582adac5ea3cd2d971679dd73567",
      "commitAuthor": "agrieve@google.com",
      "commitDateOld": "2/7/11, 9:18 AM",
      "commitNameOld": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
      "commitAuthorOld": "agrieve@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 175,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
      "diff": "@@ -1,64 +1,53 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 var \u003d scope.getVar(n.getFirstChild().getString());\n             }\n             if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                 continuations.put(var, new Continuation(n, scope));\n             } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.ASSIGN:\n             Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n             if (maybeAssign !\u003d null) {\n                 var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                 if (var !\u003d null) {\n                     assignsByVar.put(var, maybeAssign);\n                     assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                     if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                         continuations.put(var, new Continuation(n, scope));\n                         return;\n                     }\n                 }\n             }\n             break;\n-        case Token.CALL:\n-            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n-            if (subclassRelationship !\u003d null) {\n-                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n-                if (!referenced.contains(subclassVar)) {\n-                    inheritsCalls.put(subclassVar, parent);\n-                    continuations.put(subclassVar, new Continuation(n, scope));\n-                    return;\n-                }\n-            }\n-            break;\n         case Token.NAME:\n             var \u003d scope.getVar(n.getString());\n             if (parent.getType() \u003d\u003d Token.VAR) {\n                 Node value \u003d n.getFirstChild();\n                 if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                     continuations.put(var, new Continuation(n, scope));\n                     return;\n                 }\n             } else {\n                 if (var !\u003d null) {\n                     if (isRemovableVar(var)) {\n                         if (!assignsByNode.containsKey(n)) {\n                             markReferencedVar(var);\n                         }\n                     } else {\n                         markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56": {
      "type": "Ybodychange",
      "commitMessage": "\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (132 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d449\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@760 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/7/11, 9:18 AM",
      "commitName": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
      "commitAuthor": "agrieve@google.com",
      "commitDateOld": "12/16/10, 12:17 PM",
      "commitNameOld": "81a77a269d5a9cd6b9baf34812b17fd22933b46e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 52.88,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.CALL:\n            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n            if (subclassRelationship !\u003d null) {\n                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n                if (!referenced.contains(subclassVar)) {\n                    inheritsCalls.put(subclassVar, parent);\n                    continuations.put(subclassVar, new Continuation(n, scope));\n                    return;\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 187,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
      "diff": "@@ -1,53 +1,64 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 var \u003d scope.getVar(n.getFirstChild().getString());\n             }\n             if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                 continuations.put(var, new Continuation(n, scope));\n             } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.ASSIGN:\n             Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n             if (maybeAssign !\u003d null) {\n                 var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                 if (var !\u003d null) {\n                     assignsByVar.put(var, maybeAssign);\n                     assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                     if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                         continuations.put(var, new Continuation(n, scope));\n                         return;\n                     }\n                 }\n             }\n             break;\n+        case Token.CALL:\n+            SubclassRelationship subclassRelationship \u003d codingConvention.getClassesDefinedByCall(n);\n+            if (subclassRelationship !\u003d null) {\n+                Var subclassVar \u003d scope.getVar(subclassRelationship.subclassName);\n+                if (!referenced.contains(subclassVar)) {\n+                    inheritsCalls.put(subclassVar, parent);\n+                    continuations.put(subclassVar, new Continuation(n, scope));\n+                    return;\n+                }\n+            }\n+            break;\n         case Token.NAME:\n             var \u003d scope.getVar(n.getString());\n             if (parent.getType() \u003d\u003d Token.VAR) {\n                 Node value \u003d n.getFirstChild();\n                 if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                     continuations.put(var, new Continuation(n, scope));\n                     return;\n                 }\n             } else {\n                 if (var !\u003d null) {\n                     if (isRemovableVar(var)) {\n                         if (!assignsByNode.containsKey(n)) {\n                             markReferencedVar(var);\n                         }\n                     } else {\n                         markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/4/10, 5:48 PM",
      "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 157,
          "functionName": "traverseNode",
          "functionAnnotation": "",
          "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
          "diff": "@@ -1,26 +1,53 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n+    Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n-            if (traverseFunctionWhenFirstSeen(n, scope)) {\n+            if (NodeUtil.isFunctionDeclaration(n)) {\n+                var \u003d scope.getVar(n.getFirstChild().getString());\n+            }\n+            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n+                continuations.put(var, new Continuation(n, scope));\n+            } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n+        case Token.ASSIGN:\n+            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n+            if (maybeAssign !\u003d null) {\n+                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n+                if (var !\u003d null) {\n+                    assignsByVar.put(var, maybeAssign);\n+                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n+                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n+                        continuations.put(var, new Continuation(n, scope));\n+                        return;\n+                    }\n+                }\n+            }\n+            break;\n         case Token.NAME:\n-            if (parent.getType() !\u003d Token.VAR) {\n-                Var var \u003d scope.getVar(n.getString());\n-                if (var !\u003d null \u0026\u0026 !referenced.contains(var)) {\n-                    Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n-                    if (maybeAssign \u003d\u003d null) {\n-                        markReferencedVar(var);\n+            var \u003d scope.getVar(n.getString());\n+            if (parent.getType() \u003d\u003d Token.VAR) {\n+                Node value \u003d n.getFirstChild();\n+                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n+                    continuations.put(var, new Continuation(n, scope));\n+                    return;\n+                }\n+            } else {\n+                if (var !\u003d null) {\n+                    if (isRemovableVar(var)) {\n+                        if (!assignsByNode.containsKey(n)) {\n+                            markReferencedVar(var);\n+                        }\n                     } else {\n-                        assigns.put(var, maybeAssign);\n+                        markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    Var var \u003d null;\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                var \u003d scope.getVar(n.getFirstChild().getString());\n            }\n            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n                continuations.put(var, new Continuation(n, scope));\n            } else {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.ASSIGN:\n            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n            if (maybeAssign !\u003d null) {\n                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n                if (var !\u003d null) {\n                    assignsByVar.put(var, maybeAssign);\n                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n                        continuations.put(var, new Continuation(n, scope));\n                        return;\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            var \u003d scope.getVar(n.getString());\n            if (parent.getType() \u003d\u003d Token.VAR) {\n                Node value \u003d n.getFirstChild();\n                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n                    continuations.put(var, new Continuation(n, scope));\n                    return;\n                }\n            } else {\n                if (var !\u003d null) {\n                    if (isRemovableVar(var)) {\n                        if (!assignsByNode.containsKey(n)) {\n                            markReferencedVar(var);\n                        }\n                    } else {\n                        markReferencedVar(var);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 157,
          "functionName": "traverseNode",
          "functionAnnotation": "",
          "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n",
          "diff": "@@ -1,26 +1,53 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n+    Var var \u003d null;\n     switch(type) {\n         case Token.FUNCTION:\n-            if (traverseFunctionWhenFirstSeen(n, scope)) {\n+            if (NodeUtil.isFunctionDeclaration(n)) {\n+                var \u003d scope.getVar(n.getFirstChild().getString());\n+            }\n+            if (var !\u003d null \u0026\u0026 isRemovableVar(var)) {\n+                continuations.put(var, new Continuation(n, scope));\n+            } else {\n                 traverseFunction(n, scope);\n             }\n             return;\n+        case Token.ASSIGN:\n+            Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n+            if (maybeAssign !\u003d null) {\n+                var \u003d scope.getVar(maybeAssign.nameNode.getString());\n+                if (var !\u003d null) {\n+                    assignsByVar.put(var, maybeAssign);\n+                    assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n+                    if (isRemovableVar(var) \u0026\u0026 !maybeAssign.mayHaveSecondarySideEffects) {\n+                        continuations.put(var, new Continuation(n, scope));\n+                        return;\n+                    }\n+                }\n+            }\n+            break;\n         case Token.NAME:\n-            if (parent.getType() !\u003d Token.VAR) {\n-                Var var \u003d scope.getVar(n.getString());\n-                if (var !\u003d null \u0026\u0026 !referenced.contains(var)) {\n-                    Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n-                    if (maybeAssign \u003d\u003d null) {\n-                        markReferencedVar(var);\n+            var \u003d scope.getVar(n.getString());\n+            if (parent.getType() \u003d\u003d Token.VAR) {\n+                Node value \u003d n.getFirstChild();\n+                if (value !\u003d null \u0026\u0026 var !\u003d null \u0026\u0026 isRemovableVar(var) \u0026\u0026 !NodeUtil.mayHaveSideEffects(value)) {\n+                    continuations.put(var, new Continuation(n, scope));\n+                    return;\n+                }\n+            } else {\n+                if (var !\u003d null) {\n+                    if (isRemovableVar(var)) {\n+                        if (!assignsByNode.containsKey(n)) {\n+                            markReferencedVar(var);\n+                        }\n                     } else {\n-                        assigns.put(var, maybeAssign);\n+                        markReferencedVar(var);\n                     }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
            "newValue": "Traverses everything in the current scope and marks variables that\nare referenced.\n\nDuring traversal, we identify subtrees that will only be\nreferenced if their enclosing variables are referenced. Instead of\ntraversing those subtrees, we create a continuation for them,\nand traverse them lazily.\n"
          }
        }
      ]
    },
    "833cd72a268c1161194038faf0d98ec6b1f203eb": {
      "type": "Ybodychange",
      "commitMessage": "\nMake RemoveUnusedVars a lot smarter about dead assigns.\nGranted, it\u0027s still nowhere near as smart as the real dead-assignment\npass, so maybe it\u0027d be better to say that this makes the pass\nless dumb.\n\nR\u003dacleung\nDELTA\u003d251  (222 added, 15 deleted, 14 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@281 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/15/10, 2:02 PM",
      "commitName": "833cd72a268c1161194038faf0d98ec6b1f203eb",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/12/10, 3:20 PM",
      "commitNameOld": "b2c12cd9f4284d58450d1a487e29d6b6a065105e",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (traverseFunctionWhenFirstSeen(n, scope)) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null \u0026\u0026 !referenced.contains(var)) {\n                    Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n                    if (maybeAssign \u003d\u003d null) {\n                        markReferencedVar(var);\n                    } else {\n                        assigns.put(var, maybeAssign);\n                    }\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 102,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
      "diff": "@@ -1,21 +1,26 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     switch(type) {\n         case Token.FUNCTION:\n             if (traverseFunctionWhenFirstSeen(n, scope)) {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.NAME:\n             if (parent.getType() !\u003d Token.VAR) {\n                 Var var \u003d scope.getVar(n.getString());\n-                if (var !\u003d null) {\n-                    markReferencedVar(var);\n+                if (var !\u003d null \u0026\u0026 !referenced.contains(var)) {\n+                    Assign maybeAssign \u003d Assign.maybeCreateAssign(n);\n+                    if (maybeAssign \u003d\u003d null) {\n+                        markReferencedVar(var);\n+                    } else {\n+                        assigns.put(var, maybeAssign);\n+                    }\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4672a1aca15e6d5c3e7c2e00e31767f3c8327335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/01 by nicksantos\n\n        Rename a test file, since the class its testing has been renamed.\n\n        R\u003djohnlenz\n        DELTA\u003d112  (56 added, 56 deleted, 0 changed)\n\nChange on 2010/06/01 by johnlenz\n\n        RemoveUnusedVars: Prevent retraversal of exported function bodies.\n        Fixes issue 168.\n\n        R\u003dbowdidge\n        DELTA\u003d40  (32 added, 1 deleted, 7 changed)\n\nChange on 2010/06/01 by johnlenz\n\n        Our scope object can\u0027t model it properly, so report an error if a var\n        with the same name as a catch expression is used within a catch block.\n        Fixes issue 166.\n\n        R\u003dacleung\n        DELTA\u003d78  (75 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@237 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/2/10, 7:10 AM",
      "commitName": "4672a1aca15e6d5c3e7c2e00e31767f3c8327335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/27/10, 12:02 PM",
      "commitNameOld": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 35.8,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (traverseFunctionWhenFirstSeen(n, scope)) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null) {\n                    markReferencedVar(var);\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 112,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
      "diff": "@@ -1,21 +1,21 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     switch(type) {\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {\n+            if (traverseFunctionWhenFirstSeen(n, scope)) {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.NAME:\n             if (parent.getType() !\u003d Token.VAR) {\n                 Var var \u003d scope.getVar(n.getString());\n                 if (var !\u003d null) {\n                     markReferencedVar(var);\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": {
      "type": "Ybodychange",
      "commitMessage": "Change on 2010/04/26 by nick\n\n        forbid getters and setters. fixes closure-compiler issue 154.\n\n        R\u003drobert\n        DELTA\u003d57  (55 added, 0 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a helper method for getting the transitive closure of a\n        number of roots.\n\n        R\u003dalan\n        DELTA\u003d172  (168 added, 2 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a new mechanism for type name resolution.\n\n        R\u003djohn\n        DELTA\u003d222  (210 added, 5 deleted, 7 changed)\n\nChange on 2010/04/27 by john\n\n        Remove unused variables in uncalled global functions when not removing\n        unused global names. Fixes issue 155.\n\n        R\u003dnick\n        DELTA\u003d42  (34 added, 3 deleted, 5 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003daepekd\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@199 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/27/10, 12:02 PM",
      "commitName": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/23/10, 11:31 AM",
      "commitNameOld": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null) {\n                    markReferencedVar(var);\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 112,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
      "diff": "@@ -1,21 +1,21 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     switch(type) {\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionExpression(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n+            if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.NAME:\n             if (parent.getType() !\u003d Token.VAR) {\n                 Var var \u003d scope.getVar(n.getString());\n                 if (var !\u003d null) {\n                     markReferencedVar(var);\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/31/10, 2:45 PM",
      "commitNameOld": "fbf47bd6fe52121c22d9c1fa6764e6686221df99",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 22.87,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionExpression(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null) {\n                    markReferencedVar(var);\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 112,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
      "diff": "@@ -1,21 +1,21 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     switch(type) {\n         case Token.FUNCTION:\n-            if (NodeUtil.isFunctionAnonymous(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n+            if (NodeUtil.isFunctionExpression(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.NAME:\n             if (parent.getType() !\u003d Token.VAR) {\n                 Var var \u003d scope.getVar(n.getString());\n                 if (var !\u003d null) {\n                     markReferencedVar(var);\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419": {
      "type": "Ybodychange",
      "commitMessage": "Change the internal representation of constant variables.\n\nRun inline-variables before smart-name-removal.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@37 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/17/09, 4:20 PM",
      "commitName": "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 22.39,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionAnonymous(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null) {\n                    markReferencedVar(var);\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 125,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n",
      "diff": "@@ -1,21 +1,21 @@\n private void traverseNode(Node n, Node parent, Scope scope) {\n     int type \u003d n.getType();\n     switch(type) {\n         case Token.FUNCTION:\n             if (NodeUtil.isFunctionAnonymous(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n                 traverseFunction(n, scope);\n             }\n             return;\n         case Token.NAME:\n             if (parent.getType() !\u003d Token.VAR) {\n-                Scope.Var var \u003d scope.getVar(n.getString());\n+                Var var \u003d scope.getVar(n.getString());\n                 if (var !\u003d null) {\n                     markReferencedVar(var);\n                 }\n             }\n             break;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         traverseNode(c, n, scope);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,21 @@\n+private void traverseNode(Node n, Node parent, Scope scope) {\n+    int type \u003d n.getType();\n+    switch(type) {\n+        case Token.FUNCTION:\n+            if (NodeUtil.isFunctionAnonymous(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n+                traverseFunction(n, scope);\n+            }\n+            return;\n+        case Token.NAME:\n+            if (parent.getType() !\u003d Token.VAR) {\n+                Scope.Var var \u003d scope.getVar(n.getString());\n+                if (var !\u003d null) {\n+                    markReferencedVar(var);\n+                }\n+            }\n+            break;\n+    }\n+    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+        traverseNode(c, n, scope);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void traverseNode(Node n, Node parent, Scope scope) {\n    int type \u003d n.getType();\n    switch(type) {\n        case Token.FUNCTION:\n            if (NodeUtil.isFunctionAnonymous(n) || compiler_.getCodingConvention().isExported(n.getFirstChild().getString())) {\n                traverseFunction(n, scope);\n            }\n            return;\n        case Token.NAME:\n            if (parent.getType() !\u003d Token.VAR) {\n                Scope.Var var \u003d scope.getVar(n.getString());\n                if (var !\u003d null) {\n                    markReferencedVar(var);\n                }\n            }\n            break;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        traverseNode(c, n, scope);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 116,
      "functionName": "traverseNode",
      "functionAnnotation": "",
      "functionDoc": "Traverses everything in the current scope and marks variables that\nare referenced. Functions create their own scope, so we don\u0027t\nrecurse into them unless they are called.\n"
    }
  }
}