{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "VariableReferenceCheck.java",
  "functionName": "checkVar",
  "functionId": "$checkVar___t-NodeTraversal__v-Var__references-List__Reference__",
  "sourceFilePath": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
  "functionAnnotation": "",
  "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
  "functionStartLine": 106,
  "functionEndLine": 192,
  "numCommitsSeen": 13,
  "timeTaken": 664,
  "changeHistory": [
    "03db3415761aa9d8ba2fafa0ed64116a8331b1a9",
    "fb1ca6ab49d90553268b711edc805c47ceae5088",
    "ce838eec1b2f13856ddf664c5393b8486f47347c",
    "3d392879b6d7b3f3f947490c7aa6d515f6417374",
    "1b01c3730af79c363390fc2496df345eaf2eb88b",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "03db3415761aa9d8ba2fafa0ed64116a8331b1a9": "Ybodychange",
    "fb1ca6ab49d90553268b711edc805c47ceae5088": "Ybodychange",
    "ce838eec1b2f13856ddf664c5393b8486f47347c": "Ybodychange",
    "3d392879b6d7b3f3f947490c7aa6d515f6417374": "Ybodychange",
    "1b01c3730af79c363390fc2496df345eaf2eb88b": "Ybodychange",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": "Ybodychange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "03db3415761aa9d8ba2fafa0ed64116a8331b1a9": {
      "type": "Ybodychange",
      "commitMessage": "\nPrevent inlining of extern vars that are redeclared.\n\nR\u003dnicksantos\nDELTA\u003d92  (58 added, 16 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2401\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1204 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/23/11, 1:45 PM",
      "commitName": "03db3415761aa9d8ba2fafa0ed64116a8331b1a9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/16/11, 11:12 AM",
      "commitNameOld": "fb1ca6ab49d90553268b711edc805c47ceae5088",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        boolean allowDupe \u003d SyntacticScopeCreator.hasDuplicateDeclarationSuppression(reference.getNode(), v);\n        if (isDeclaration \u0026\u0026 !allowDupe) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            if (!reference.getSourceFile().isExtern()) {\n                Node grandparent \u003d reference.getGrandparent();\n                if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                    continue;\n                }\n                if (reference.getScope() \u003d\u003d v.scope) {\n                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n                }\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 106,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,52 +1,55 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n     boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n         } else if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {\n             isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n-        if (isDeclaration) {\n+        boolean allowDupe \u003d SyntacticScopeCreator.hasDuplicateDeclarationSuppression(reference.getNode(), v);\n+        if (isDeclaration \u0026\u0026 !allowDupe) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n         if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n-            Node grandparent \u003d reference.getGrandparent();\n-            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n-                continue;\n-            }\n-            if (reference.getScope() \u003d\u003d v.scope) {\n-                compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n+            if (!reference.getSourceFile().isExtern()) {\n+                Node grandparent \u003d reference.getGrandparent();\n+                if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n+                    continue;\n+                }\n+                if (reference.getScope() \u003d\u003d v.scope) {\n+                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n+                }\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb1ca6ab49d90553268b711edc805c47ceae5088": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate an inferface for references in the symbol table\n\nR\u003dacleung\nDELTA\u003d275  (214 added, 16 deleted, 45 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2317\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1185 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/11, 11:12 AM",
      "commitName": "fb1ca6ab49d90553268b711edc805c47ceae5088",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/24/11, 10:36 AM",
      "commitNameOld": "75a9013e3907e5db97f10578227497d7b018caf5",
      "commitAuthorOld": "bashir@google.com",
      "daysBetweenCommits": 23.02,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 107,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,52 +1,52 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n     boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n-        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n+        } else if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {\n             isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n-                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n+                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n         if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n-                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n+                    compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n-                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n+                compiler.report(JSError.make(reference.getSourceFile().getName(), reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ce838eec1b2f13856ddf664c5393b8486f47347c": {
      "type": "Ybodychange",
      "commitMessage": "\nAmbiguious function declarations warnings should only be controlled by\nthe diagnostic group.\n\nR\u003dnicksantos\nDELTA\u003d1  (0 added, 1 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d88002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@324 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/4/10, 12:45 PM",
      "commitName": "ce838eec1b2f13856ddf664c5393b8486f47347c",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "7/26/10, 5:34 PM",
      "commitNameOld": "3d392879b6d7b3f3f947490c7aa6d515f6417374",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 8.8,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 99,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,52 +1,52 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n     boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n         } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n             isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n         if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n-                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n+                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), AMBIGUOUS_FUNCTION_DECL, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n                 compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d392879b6d7b3f3f947490c7aa6d515f6417374": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate a disagnostic group for ambigious function declaration warnings.\n\nR\u003dnicksantos\nDELTA\u003d40  (27 added, 6 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d68001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@312 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/26/10, 5:34 PM",
      "commitName": "3d392879b6d7b3f3f947490c7aa6d515f6417374",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 136.79,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 99,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,52 +1,52 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n     boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n         } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n             isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n-        if (CHECK_UNHOISTED_NAMED_FUNCTIONS \u0026\u0026 isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n+        if (isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n                 compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1b01c3730af79c363390fc2496df345eaf2eb88b": {
      "type": "Ybodychange",
      "commitMessage": "Rollback the new ambiguous function def warning, because it still\nhas false positives.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@35 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/17/09, 10:06 AM",
      "commitName": "1b01c3730af79c363390fc2496df345eaf2eb88b",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/15/09, 1:52 PM",
      "commitNameOld": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (CHECK_UNHOISTED_NAMED_FUNCTIONS \u0026\u0026 isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 101,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,52 +1,52 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n     boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n         } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n             isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n-        if (!isDeclaration \u0026\u0026 isDeclaredInScope \u0026\u0026 isUnhoistedNamedFunction) {\n+        if (CHECK_UNHOISTED_NAMED_FUNCTIONS \u0026\u0026 isUnhoistedNamedFunction \u0026\u0026 !isDeclaration \u0026\u0026 isDeclaredInScope) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n                 compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": {
      "type": "Ybodychange",
      "commitMessage": "Add warnings for functions that are ambiguously defined on different\nbrowsers.\n\nAdd better support for Caja.\n\nRollback the change to CoalesceVariableNames, because it had problems.\n\nInternal type system refactoring.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@33 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/09, 1:52 PM",
      "commitName": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/10/09, 11:16 AM",
      "commitNameOld": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 35.11,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    boolean isUnhoistedNamedFunction \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n            isUnhoistedNamedFunction \u003d true;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 isDeclaredInScope \u0026\u0026 isUnhoistedNamedFunction) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 99,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,41 +1,52 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n+    boolean isUnhoistedNamedFunction \u003d false;\n     Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n         if (reference.isHoistedFunction()) {\n             blocksWithDeclarations.add(reference.getBasicBlock());\n             isDeclaredInScope \u003d true;\n             hoistedFn \u003d reference;\n             break;\n+        } else if (NodeUtil.isFunctionDeclaration(reference.getNameNode().getParent())) {\n+            isUnhoistedNamedFunction \u003d true;\n         }\n     }\n     for (Reference reference : references) {\n         if (reference \u003d\u003d hoistedFn) {\n             continue;\n         }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n+        if (!isDeclaration \u0026\u0026 isDeclaredInScope \u0026\u0026 isUnhoistedNamedFunction) {\n+            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n+                if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n+                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, AMBIGUOUS_FUNCTION_DECL, v.name));\n+                    break;\n+                }\n+            }\n+        }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n                 compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ybodychange",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 6.81,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    Reference hoistedFn \u003d null;\n    for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n            blocksWithDeclarations.add(reference.getBasicBlock());\n            isDeclaredInScope \u003d true;\n            hoistedFn \u003d reference;\n            break;\n        }\n    }\n    for (Reference reference : references) {\n        if (reference \u003d\u003d hoistedFn) {\n            continue;\n        }\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 95,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n",
      "diff": "@@ -1,29 +1,41 @@\n private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n     blocksWithDeclarations.clear();\n     boolean isDeclaredInScope \u003d false;\n+    Reference hoistedFn \u003d null;\n     for (Reference reference : references) {\n+        if (reference.isHoistedFunction()) {\n+            blocksWithDeclarations.add(reference.getBasicBlock());\n+            isDeclaredInScope \u003d true;\n+            hoistedFn \u003d reference;\n+            break;\n+        }\n+    }\n+    for (Reference reference : references) {\n+        if (reference \u003d\u003d hoistedFn) {\n+            continue;\n+        }\n         BasicBlock basicBlock \u003d reference.getBasicBlock();\n         boolean isDeclaration \u003d reference.isDeclaration();\n         if (isDeclaration) {\n             for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                 if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                     compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                     break;\n                 }\n             }\n         }\n         if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n             Node grandparent \u003d reference.getGrandparent();\n             if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                 continue;\n             }\n             if (reference.getScope() \u003d\u003d v.scope) {\n                 compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n             }\n         }\n         if (isDeclaration) {\n             blocksWithDeclarations.add(basicBlock);\n             isDeclaredInScope \u003d true;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,29 @@\n+private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n+    blocksWithDeclarations.clear();\n+    boolean isDeclaredInScope \u003d false;\n+    for (Reference reference : references) {\n+        BasicBlock basicBlock \u003d reference.getBasicBlock();\n+        boolean isDeclaration \u003d reference.isDeclaration();\n+        if (isDeclaration) {\n+            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n+                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n+                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n+                    break;\n+                }\n+            }\n+        }\n+        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n+            Node grandparent \u003d reference.getGrandparent();\n+            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n+                continue;\n+            }\n+            if (reference.getScope() \u003d\u003d v.scope) {\n+                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n+            }\n+        }\n+        if (isDeclaration) {\n+            blocksWithDeclarations.add(basicBlock);\n+            isDeclaredInScope \u003d true;\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void checkVar(NodeTraversal t, Var v, List\u003cReference\u003e references) {\n    blocksWithDeclarations.clear();\n    boolean isDeclaredInScope \u003d false;\n    for (Reference reference : references) {\n        BasicBlock basicBlock \u003d reference.getBasicBlock();\n        boolean isDeclaration \u003d reference.isDeclaration();\n        if (isDeclaration) {\n            for (BasicBlock declaredBlock : blocksWithDeclarations) {\n                if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n                    compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, REDECLARED_VARIABLE, v.name));\n                    break;\n                }\n            }\n        }\n        if (!isDeclaration \u0026\u0026 !isDeclaredInScope) {\n            Node grandparent \u003d reference.getGrandparent();\n            if (grandparent.getType() \u003d\u003d Token.NAME \u0026\u0026 grandparent.getString() \u003d\u003d v.name) {\n                continue;\n            }\n            if (reference.getScope() \u003d\u003d v.scope) {\n                compiler.report(JSError.make(reference.getSourceName(), reference.getNameNode(), checkLevel, UNDECLARED_REFERENCE, v.name));\n            }\n        }\n        if (isDeclaration) {\n            blocksWithDeclarations.add(basicBlock);\n            isDeclaredInScope \u003d true;\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
      "functionStartLine": 95,
      "functionName": "checkVar",
      "functionAnnotation": "",
      "functionDoc": "If the variable is declared more than once in a basic block, generate a\nwarning. Also check if a variable is used in a given scope before it is\ndeclared, which suggest a likely error. Relies on the fact that\nreferences is in parse-tree order.\n"
    }
  }
}