{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "defineSlot",
  "functionId": "$defineSlot___n-Node__parent-Node__type-JSType__inferred-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
  "functionStartLine": 1016,
  "functionEndLine": 1034,
  "numCommitsSeen": 59,
  "timeTaken": 4510,
  "changeHistory": [
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
    "6bbac115c9a7928a7053b2da3a78df9569df8570",
    "e9f7e6114414f68deb90f4116861d7a054365404",
    "a83c4868dbc0f3229d31af5ff1b8554c44908459",
    "f6607996d6d3bd6820ce3848d147991b27600a12",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
    "5da32cba7b68d69acfc535f57f21d652475d256f",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c": "Ybodychange",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Ybodychange",
    "6bbac115c9a7928a7053b2da3a78df9569df8570": "Ybodychange",
    "e9f7e6114414f68deb90f4116861d7a054365404": "Ybodychange",
    "a83c4868dbc0f3229d31af5ff1b8554c44908459": "Ybodychange",
    "f6607996d6d3bd6820ce3848d147991b27600a12": "Ybodychange",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": "Ybodychange",
    "5da32cba7b68d69acfc535f57f21d652475d256f": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen a property of a named object literal is declared,\ndeclare the qualified name of that property.\n\nR\u003djohnlenz\nDELTA\u003d82  (58 added, 3 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d546\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@793 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/16/11, 8:38 PM",
      "commitName": "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/1/11, 11:22 AM",
      "commitNameOld": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 15.39,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 996,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,55 +1,9 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n-    boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n-        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n-    String variableName \u003d n.getQualifiedName();\n-    Preconditions.checkArgument(!variableName.isEmpty());\n-    Scope scopeToDeclareIn \u003d scope;\n-    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n-        Scope globalScope \u003d scope.getGlobalScope();\n-        if (!globalScope.isDeclared(variableName, false)) {\n-            scopeToDeclareIn \u003d scope.getGlobalScope();\n-        }\n-    }\n-    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n-    } else {\n-        if (!inferred) {\n-            setDeferredType(n, type);\n-        }\n-        CompilerInput input \u003d compiler.getInput(sourceName);\n-        boolean isExtern \u003d input.isExtern();\n-        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n-        if (shouldDeclareOnGlobalThis) {\n-            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern, n);\n-            } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n-            }\n-        }\n-        if (type instanceof EnumType) {\n-            Node initialValue \u003d newVar.getInitialValue();\n-            boolean isValidValue \u003d initialValue !\u003d null \u0026\u0026 (initialValue.getType() \u003d\u003d Token.OBJECTLIT || initialValue.isQualifiedName());\n-            if (!isValidValue) {\n-                compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n-            }\n-        }\n-        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n-            FunctionType fnType \u003d (FunctionType) type;\n-            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n-                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n-                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n-                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n-                }\n-            }\n-        }\n-    }\n+    defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/27/11, 10:33 AM",
      "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.9,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    Scope scopeToDeclareIn \u003d scope;\n    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n        Scope globalScope \u003d scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n            scopeToDeclareIn \u003d scope.getGlobalScope();\n        }\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        boolean isExtern \u003d input.isExtern();\n        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern, n);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n            }\n        }\n        if (type instanceof EnumType) {\n            Node initialValue \u003d newVar.getInitialValue();\n            boolean isValidValue \u003d initialValue !\u003d null \u0026\u0026 (initialValue.getType() \u003d\u003d Token.OBJECTLIT || initialValue.isQualifiedName());\n            if (!isValidValue) {\n                compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n            }\n        }\n        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 975,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,48 +1,55 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     Scope scopeToDeclareIn \u003d scope;\n     if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n         Scope globalScope \u003d scope.getGlobalScope();\n         if (!globalScope.isDeclared(variableName, false)) {\n             scopeToDeclareIn \u003d scope.getGlobalScope();\n         }\n     }\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n         boolean isExtern \u003d input.isExtern();\n         Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern, n);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n             }\n         }\n+        if (type instanceof EnumType) {\n+            Node initialValue \u003d newVar.getInitialValue();\n+            boolean isValidValue \u003d initialValue !\u003d null \u0026\u0026 (initialValue.getType() \u003d\u003d Token.OBJECTLIT || initialValue.isQualifiedName());\n+            if (!isValidValue) {\n+                compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n+            }\n+        }\n         if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                 if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                     compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bbac115c9a7928a7053b2da3a78df9569df8570": {
      "type": "Ybodychange",
      "commitMessage": "\nAdding getPropertyNode functionality to ObjectType. This needs\nassociating nodes to properties in defineProperty.\n\nR\u003dnicksantos\nDELTA\u003d307  (127 added, 0 deleted, 180 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d223\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@674 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/7/11, 9:19 AM",
      "commitName": "6bbac115c9a7928a7053b2da3a78df9569df8570",
      "commitAuthor": "bashir@google.com",
      "commitDateOld": "12/14/10, 1:49 PM",
      "commitNameOld": "e9f7e6114414f68deb90f4116861d7a054365404",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 23.81,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    Scope scopeToDeclareIn \u003d scope;\n    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n        Scope globalScope \u003d scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n            scopeToDeclareIn \u003d scope.getGlobalScope();\n        }\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        boolean isExtern \u003d input.isExtern();\n        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern, n);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n            }\n        }\n        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 941,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,48 +1,48 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     Scope scopeToDeclareIn \u003d scope;\n     if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n         Scope globalScope \u003d scope.getGlobalScope();\n         if (!globalScope.isDeclared(variableName, false)) {\n             scopeToDeclareIn \u003d scope.getGlobalScope();\n         }\n     }\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n         boolean isExtern \u003d input.isExtern();\n         Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern, n);\n             } else {\n-                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+                globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n             }\n         }\n         if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                 if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                     compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e9f7e6114414f68deb90f4116861d7a054365404": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a syntax for constructors\n{function(new:Type)}\nfixes issue 281\n\nR\u003djschorr\nDELTA\u003d199  (73 added, 4 deleted, 122 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d133\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@630 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/14/10, 1:49 PM",
      "commitName": "e9f7e6114414f68deb90f4116861d7a054365404",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/2/10, 12:04 PM",
      "commitNameOld": "a83c4868dbc0f3229d31af5ff1b8554c44908459",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    Scope scopeToDeclareIn \u003d scope;\n    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n        Scope globalScope \u003d scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n            scopeToDeclareIn \u003d scope.getGlobalScope();\n        }\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        boolean isExtern \u003d input.isExtern();\n        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 941,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,48 +1,48 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     Scope scopeToDeclareIn \u003d scope;\n     if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n         Scope globalScope \u003d scope.getGlobalScope();\n         if (!globalScope.isDeclared(variableName, false)) {\n             scopeToDeclareIn \u003d scope.getGlobalScope();\n         }\n     }\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n         boolean isExtern \u003d input.isExtern();\n         Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n         if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                 scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n-                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern) {\n+                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern \u0026\u0026 variableName.equals(fnType.getInstanceType().getReferenceName())) {\n                     compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a83c4868dbc0f3229d31af5ff1b8554c44908459": {
      "type": "Ybodychange",
      "commitMessage": "\nWarn if a ctor or iface is not initialized\n\nR\u003djohnlenz\nDELTA\u003d120  (101 added, 1 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d38\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@583 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/2/10, 12:04 PM",
      "commitName": "a83c4868dbc0f3229d31af5ff1b8554c44908459",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/12/10, 1:38 PM",
      "commitNameOld": "25904fa3b61c1d6ef494dd7839eae1d1f49ff38d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 19.93,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    Scope scopeToDeclareIn \u003d scope;\n    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n        Scope globalScope \u003d scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n            scopeToDeclareIn \u003d scope.getGlobalScope();\n        }\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        boolean isExtern \u003d input.isExtern();\n        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern) {\n                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 941,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,45 +1,48 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     Scope scopeToDeclareIn \u003d scope;\n     if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n         Scope globalScope \u003d scope.getGlobalScope();\n         if (!globalScope.isDeclared(variableName, false)) {\n             scopeToDeclareIn \u003d scope.getGlobalScope();\n         }\n     }\n     if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+        boolean isExtern \u003d input.isExtern();\n+        Var newVar \u003d scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-            boolean isExtern \u003d input.isExtern();\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n-        if (scopeToDeclareIn.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n+        if (type instanceof FunctionType \u0026\u0026 !type.isEmptyType()) {\n             FunctionType fnType \u003d (FunctionType) type;\n-            if (fnType.isConstructor() || fnType.isInterface()) {\n+            if ((fnType.isConstructor() || fnType.isInterface()) \u0026\u0026 !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n-                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), input, superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                if (newVar.getInitialValue() \u003d\u003d null \u0026\u0026 !isExtern) {\n+                    compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName));\n+                }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6607996d6d3bd6820ce3848d147991b27600a12": {
      "type": "Ybodychange",
      "commitMessage": "\nIf a property is defined on a global name, but in a local scope,\ndeclare that property in the global scope.\nthis goes most of the way towards fixing issue 66.\n\nR\u003djohnlenz\nDELTA\u003d84  (78 added, 1 deleted, 5 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d219633\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@429 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/15/10, 7:50 AM",
      "commitName": "f6607996d6d3bd6820ce3848d147991b27600a12",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/14/10, 12:23 PM",
      "commitNameOld": "c2c15014b06a90e90c6f6c9be7fffd4a26883c86",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    Scope scopeToDeclareIn \u003d scope;\n    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n        Scope globalScope \u003d scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n            scopeToDeclareIn \u003d scope.getGlobalScope();\n        }\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern \u003d input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (scopeToDeclareIn.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 872,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,38 +1,45 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n-    if (scope.isDeclared(variableName, false)) {\n-        Var oldVar \u003d scope.getVar(variableName);\n+    Scope scopeToDeclareIn \u003d scope;\n+    if (n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 !scope.isGlobal() \u0026\u0026 isQnameRootedInGlobalScope(n)) {\n+        Scope globalScope \u003d scope.getGlobalScope();\n+        if (!globalScope.isDeclared(variableName, false)) {\n+            scopeToDeclareIn \u003d scope.getGlobalScope();\n+        }\n+    }\n+    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+        Var oldVar \u003d scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n-        scope.declare(variableName, n, type, input, inferred);\n+        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern \u003d input.isExtern();\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n-        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n+        if (scopeToDeclareIn.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n-                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n+                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": {
      "type": "Ybodychange",
      "commitMessage": "\nAttach types to literals at scope-creation time instead of at\ninference time.\nScope-creation already attaches types to function literals at\nscope-creation type, so this makes the other literals more consistent\nwith function literals.\n\nR\u003djohnlenz\nDELTA\u003d167  (102 added, 53 deleted, 12 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209649\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@411 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 12:26 PM",
      "commitName": "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/19/10, 5:30 PM",
      "commitNameOld": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 50.79,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    if (scope.isDeclared(variableName, false)) {\n        Var oldVar \u003d scope.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        scope.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern \u003d input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 798,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,38 +1,38 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     if (scope.isDeclared(variableName, false)) {\n         Var oldVar \u003d scope.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n             setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n         scope.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern \u003d input.isExtern();\n             if (inferred) {\n-                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n         if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n-                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));\n+                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da32cba7b68d69acfc535f57f21d652475d256f": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 4:28 PM",
      "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 4:53 PM",
      "commitNameOld": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    if (scope.isDeclared(variableName, false)) {\n        Var oldVar \u003d scope.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            setDeferredType(n, type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        scope.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern \u003d input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 750,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n",
      "diff": "@@ -1,38 +1,38 @@\n void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n     Preconditions.checkArgument(inferred || type !\u003d null);\n     boolean shouldDeclareOnGlobalThis \u003d false;\n     if (n.getType() \u003d\u003d Token.NAME) {\n         Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n         shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n     } else {\n         Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n     }\n     String variableName \u003d n.getQualifiedName();\n     Preconditions.checkArgument(!variableName.isEmpty());\n     if (scope.isDeclared(variableName, false)) {\n         Var oldVar \u003d scope.getVar(variableName);\n         validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n     } else {\n         if (!inferred) {\n-            n.setJSType(type);\n+            setDeferredType(n, type);\n         }\n         CompilerInput input \u003d compiler.getInput(sourceName);\n         scope.declare(variableName, n, type, input, inferred);\n         if (shouldDeclareOnGlobalThis) {\n             ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n             boolean isExtern \u003d input.isExtern();\n             if (inferred) {\n                 globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n             } else {\n                 globalThis.defineDeclaredProperty(variableName, type, isExtern);\n             }\n         }\n         if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n             FunctionType fnType \u003d (FunctionType) type;\n             if (fnType.isConstructor() || fnType.isInterface()) {\n                 FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                 scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,38 @@\n+void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n+    Preconditions.checkArgument(inferred || type !\u003d null);\n+    boolean shouldDeclareOnGlobalThis \u003d false;\n+    if (n.getType() \u003d\u003d Token.NAME) {\n+        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n+        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n+    } else {\n+        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n+    }\n+    String variableName \u003d n.getQualifiedName();\n+    Preconditions.checkArgument(!variableName.isEmpty());\n+    if (scope.isDeclared(variableName, false)) {\n+        Var oldVar \u003d scope.getVar(variableName);\n+        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n+    } else {\n+        if (!inferred) {\n+            n.setJSType(type);\n+        }\n+        CompilerInput input \u003d compiler.getInput(sourceName);\n+        scope.declare(variableName, n, type, input, inferred);\n+        if (shouldDeclareOnGlobalThis) {\n+            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+            boolean isExtern \u003d input.isExtern();\n+            if (inferred) {\n+                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n+            } else {\n+                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+            }\n+        }\n+        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n+            FunctionType fnType \u003d (FunctionType) type;\n+            if (fnType.isConstructor() || fnType.isInterface()) {\n+                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n+                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n    Preconditions.checkArgument(inferred || type !\u003d null);\n    boolean shouldDeclareOnGlobalThis \u003d false;\n    if (n.getType() \u003d\u003d Token.NAME) {\n        Preconditions.checkArgument(parent.getType() \u003d\u003d Token.FUNCTION || parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.LP || parent.getType() \u003d\u003d Token.CATCH);\n        shouldDeclareOnGlobalThis \u003d scope.isGlobal() \u0026\u0026 (parent.getType() \u003d\u003d Token.VAR || parent.getType() \u003d\u003d Token.FUNCTION);\n    } else {\n        Preconditions.checkArgument(n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 (parent.getType() \u003d\u003d Token.ASSIGN || parent.getType() \u003d\u003d Token.EXPR_RESULT));\n    }\n    String variableName \u003d n.getQualifiedName();\n    Preconditions.checkArgument(!variableName.isEmpty());\n    if (scope.isDeclared(variableName, false)) {\n        Var oldVar \u003d scope.getVar(variableName);\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\n    } else {\n        if (!inferred) {\n            n.setJSType(type);\n        }\n        CompilerInput input \u003d compiler.getInput(sourceName);\n        scope.declare(variableName, n, type, input, inferred);\n        if (shouldDeclareOnGlobalThis) {\n            ObjectType globalThis \u003d typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern \u003d input.isExtern();\n            if (inferred) {\n                globalThis.defineInferredProperty(variableName, type \u003d\u003d null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\n            } else {\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\n            }\n        }\n        if (scope.isGlobal() \u0026\u0026 type instanceof FunctionType) {\n            FunctionType fnType \u003d (FunctionType) type;\n            if (fnType.isConstructor() || fnType.isInterface()) {\n                FunctionType superClassCtor \u003d fnType.getSuperClassConstructor();\n                scope.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), superClassCtor \u003d\u003d null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 630,
      "functionName": "defineSlot",
      "functionAnnotation": "",
      "functionDoc": "Defines a typed variable. The defining node will be annotated with the\nvariable\u0027s type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\ninferred.\n\nSlots may be any variable or any qualified name in the global scope.\n\n@param n the defining NAME or GETPROP node.\n@param parent the {@code n}\u0027s parent.\n@param type the variable\u0027s type. It may be {@code null} if\n    {@code inferred} is {@code true}.\n"
    }
  }
}