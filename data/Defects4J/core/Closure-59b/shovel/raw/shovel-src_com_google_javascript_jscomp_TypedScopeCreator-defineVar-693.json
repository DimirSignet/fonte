{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "defineVar",
  "functionId": "$defineVar___n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Defines a VAR initialization.\n",
  "functionStartLine": 693,
  "functionEndLine": 709,
  "numCommitsSeen": 77,
  "timeTaken": 4304,
  "changeHistory": [
    "e8eafe7acfd53e5385e4f31692c4db67c3777185",
    "3c4504a78a84e4715439cddb4028c25be2ce308f",
    "5da32cba7b68d69acfc535f57f21d652475d256f",
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "e8eafe7acfd53e5385e4f31692c4db67c3777185": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
    "3c4504a78a84e4715439cddb4028c25be2ce308f": "Ybodychange",
    "5da32cba7b68d69acfc535f57f21d652475d256f": "Ybodychange",
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e8eafe7acfd53e5385e4f31692c4db67c3777185": {
      "type": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
      "commitMessage": "\nRefactor typedscopecreator a bit to make it easier\nto see what\u0027s going on. basically, i removed a level of dynamic\ndispatch. there should be no functional changes in this cl.\n\nR\u003djohnlenz\nDELTA\u003d228  (89 added, 62 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d54005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@292 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/19/10, 5:30 PM",
      "commitName": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nRefactor typedscopecreator a bit to make it easier\nto see what\u0027s going on. basically, i removed a level of dynamic\ndispatch. there should be no functional changes in this cl.\n\nR\u003djohnlenz\nDELTA\u003d228  (89 added, 62 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d54005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@292 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/19/10, 5:30 PM",
          "commitName": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "7/16/10, 2:56 AM",
          "commitNameOld": "192a60673cfd308fbcb735664fbab98e3cb3a21a",
          "commitAuthorOld": "nadaa@google.com",
          "daysBetweenCommits": 3.61,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "void defineVar(Node n, Node parent) {\n    assertDefinitionNode(n, Token.VAR);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (n.hasMoreThanOneChild()) {\n        if (info !\u003d null) {\n            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n            defineName(name, n, parent, name.getJSDocInfo());\n        }\n    } else {\n        Node name \u003d n.getFirstChild();\n        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 437,
          "functionName": "defineVar",
          "functionAnnotation": "",
          "functionDoc": "Defines a VAR initialization.\n",
          "diff": "@@ -1,47 +1,15 @@\n-void define(Node n, Node parent) {\n-    Preconditions.checkState(sourceName !\u003d null);\n+void defineVar(Node n, Node parent) {\n+    assertDefinitionNode(n, Token.VAR);\n     JSDocInfo info \u003d n.getJSDocInfo();\n-    switch(n.getType()) {\n-        case Token.CATCH:\n-            Node catchName \u003d n.getFirstChild();\n-            defineSlot(catchName, n, null);\n-            break;\n-        case Token.VAR:\n-            if (n.hasMoreThanOneChild()) {\n-                if (info !\u003d null) {\n-                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n-                }\n-                for (Node name : n.children()) {\n-                    defineName(name, n, parent, name.getJSDocInfo());\n-                }\n-            } else {\n-                Node name \u003d n.getFirstChild();\n-                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            int parentType \u003d parent.getType();\n-            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n-            String functionName \u003d n.getFirstChild().getString();\n-            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n-            if (NodeUtil.isFunctionDeclaration(n)) {\n-                defineSlot(n.getFirstChild(), n, functionType);\n-            }\n-            break;\n-        case Token.ASSIGN:\n-            Node rvalue \u003d n.getLastChild();\n-            Node lvalue \u003d n.getFirstChild();\n-            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n-            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n-                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n-            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n-                if (type !\u003d null) {\n-                    setDeferredType(lvalue, type);\n-                }\n-            }\n-            break;\n-        default:\n-            throw new IllegalStateException(Integer.toString(n.getType()));\n+    if (n.hasMoreThanOneChild()) {\n+        if (info !\u003d null) {\n+            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+        }\n+        for (Node name : n.children()) {\n+            defineName(name, n, parent, name.getJSDocInfo());\n+        }\n+    } else {\n+        Node name \u003d n.getFirstChild();\n+        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "define",
            "newValue": "defineVar"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nRefactor typedscopecreator a bit to make it easier\nto see what\u0027s going on. basically, i removed a level of dynamic\ndispatch. there should be no functional changes in this cl.\n\nR\u003djohnlenz\nDELTA\u003d228  (89 added, 62 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d54005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@292 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/19/10, 5:30 PM",
          "commitName": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "7/16/10, 2:56 AM",
          "commitNameOld": "192a60673cfd308fbcb735664fbab98e3cb3a21a",
          "commitAuthorOld": "nadaa@google.com",
          "daysBetweenCommits": 3.61,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "void defineVar(Node n, Node parent) {\n    assertDefinitionNode(n, Token.VAR);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (n.hasMoreThanOneChild()) {\n        if (info !\u003d null) {\n            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n            defineName(name, n, parent, name.getJSDocInfo());\n        }\n    } else {\n        Node name \u003d n.getFirstChild();\n        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 437,
          "functionName": "defineVar",
          "functionAnnotation": "",
          "functionDoc": "Defines a VAR initialization.\n",
          "diff": "@@ -1,47 +1,15 @@\n-void define(Node n, Node parent) {\n-    Preconditions.checkState(sourceName !\u003d null);\n+void defineVar(Node n, Node parent) {\n+    assertDefinitionNode(n, Token.VAR);\n     JSDocInfo info \u003d n.getJSDocInfo();\n-    switch(n.getType()) {\n-        case Token.CATCH:\n-            Node catchName \u003d n.getFirstChild();\n-            defineSlot(catchName, n, null);\n-            break;\n-        case Token.VAR:\n-            if (n.hasMoreThanOneChild()) {\n-                if (info !\u003d null) {\n-                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n-                }\n-                for (Node name : n.children()) {\n-                    defineName(name, n, parent, name.getJSDocInfo());\n-                }\n-            } else {\n-                Node name \u003d n.getFirstChild();\n-                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            int parentType \u003d parent.getType();\n-            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n-            String functionName \u003d n.getFirstChild().getString();\n-            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n-            if (NodeUtil.isFunctionDeclaration(n)) {\n-                defineSlot(n.getFirstChild(), n, functionType);\n-            }\n-            break;\n-        case Token.ASSIGN:\n-            Node rvalue \u003d n.getLastChild();\n-            Node lvalue \u003d n.getFirstChild();\n-            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n-            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n-                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n-            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n-                if (type !\u003d null) {\n-                    setDeferredType(lvalue, type);\n-                }\n-            }\n-            break;\n-        default:\n-            throw new IllegalStateException(Integer.toString(n.getType()));\n+    if (n.hasMoreThanOneChild()) {\n+        if (info !\u003d null) {\n+            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+        }\n+        for (Node name : n.children()) {\n+            defineName(name, n, parent, name.getJSDocInfo());\n+        }\n+    } else {\n+        Node name \u003d n.getFirstChild();\n+        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nRefactor typedscopecreator a bit to make it easier\nto see what\u0027s going on. basically, i removed a level of dynamic\ndispatch. there should be no functional changes in this cl.\n\nR\u003djohnlenz\nDELTA\u003d228  (89 added, 62 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d54005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@292 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/19/10, 5:30 PM",
          "commitName": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "7/16/10, 2:56 AM",
          "commitNameOld": "192a60673cfd308fbcb735664fbab98e3cb3a21a",
          "commitAuthorOld": "nadaa@google.com",
          "daysBetweenCommits": 3.61,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "void defineVar(Node n, Node parent) {\n    assertDefinitionNode(n, Token.VAR);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (n.hasMoreThanOneChild()) {\n        if (info !\u003d null) {\n            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n            defineName(name, n, parent, name.getJSDocInfo());\n        }\n    } else {\n        Node name \u003d n.getFirstChild();\n        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 437,
          "functionName": "defineVar",
          "functionAnnotation": "",
          "functionDoc": "Defines a VAR initialization.\n",
          "diff": "@@ -1,47 +1,15 @@\n-void define(Node n, Node parent) {\n-    Preconditions.checkState(sourceName !\u003d null);\n+void defineVar(Node n, Node parent) {\n+    assertDefinitionNode(n, Token.VAR);\n     JSDocInfo info \u003d n.getJSDocInfo();\n-    switch(n.getType()) {\n-        case Token.CATCH:\n-            Node catchName \u003d n.getFirstChild();\n-            defineSlot(catchName, n, null);\n-            break;\n-        case Token.VAR:\n-            if (n.hasMoreThanOneChild()) {\n-                if (info !\u003d null) {\n-                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n-                }\n-                for (Node name : n.children()) {\n-                    defineName(name, n, parent, name.getJSDocInfo());\n-                }\n-            } else {\n-                Node name \u003d n.getFirstChild();\n-                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            int parentType \u003d parent.getType();\n-            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n-            String functionName \u003d n.getFirstChild().getString();\n-            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n-            if (NodeUtil.isFunctionDeclaration(n)) {\n-                defineSlot(n.getFirstChild(), n, functionType);\n-            }\n-            break;\n-        case Token.ASSIGN:\n-            Node rvalue \u003d n.getLastChild();\n-            Node lvalue \u003d n.getFirstChild();\n-            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n-            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n-                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n-            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n-                if (type !\u003d null) {\n-                    setDeferredType(lvalue, type);\n-                }\n-            }\n-            break;\n-        default:\n-            throw new IllegalStateException(Integer.toString(n.getType()));\n+    if (n.hasMoreThanOneChild()) {\n+        if (info !\u003d null) {\n+            compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+        }\n+        for (Node name : n.children()) {\n+            defineName(name, n, parent, name.getJSDocInfo());\n+        }\n+    } else {\n+        Node name \u003d n.getFirstChild();\n+        defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Defines variable(s) or modifies types based on the content of the node\n{@code n}. A variable definition creates variables in the current scope,\na function definition creates a binding, and an assignment updates the\ntype of the namespaces on which the definition is made (e.g.\n{@code goog.FOO \u003d 6}).\n\n@param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n    {@link Token#ASSIGN} node\n@param parent @code n}\u0027s parent\n",
            "newValue": "Defines a VAR initialization.\n"
          }
        }
      ]
    },
    "3c4504a78a84e4715439cddb4028c25be2ce308f": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/13 17:21:32 by dhans\n\n        A few optimizations which replace getChildCount with more efficient functions for Node class.\n\n        R\u003djohnlenz\n        DELTA\u003d13  (2 added, 0 deleted, 11 changed)\n\nChange on 2010/07/13 18:08:42 by johnlenz\n\n        Add info for newly json.jar to README\n\n        R\u003dnicksantos\n        DELTA\u003d13  (13 added, 0 deleted, 0 changed)\n\nChange on 2010/07/14 08:51:02 by johnlenz\n\n        Attempt to add \"@nosideeffects\" to appropriate dom methods.\n\n        R\u003dgboyer\n        DELTA\u003d93  (91 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d48012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@276 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/14/10, 10:45 AM",
      "commitName": "3c4504a78a84e4715439cddb4028c25be2ce308f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/30/10, 3:28 PM",
      "commitNameOld": "b8fb1c4377809503625087f13c1ade664ce9b7e2",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 13.8,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "void define(Node n, Node parent) {\n    Preconditions.checkState(sourceName !\u003d null);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    switch(n.getType()) {\n        case Token.CATCH:\n            Node catchName \u003d n.getFirstChild();\n            defineSlot(catchName, n, null);\n            break;\n        case Token.VAR:\n            if (n.hasMoreThanOneChild()) {\n                if (info !\u003d null) {\n                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                }\n                for (Node name : n.children()) {\n                    defineName(name, n, parent, name.getJSDocInfo());\n                }\n            } else {\n                Node name \u003d n.getFirstChild();\n                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n            }\n            break;\n        case Token.FUNCTION:\n            int parentType \u003d parent.getType();\n            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n            String functionName \u003d n.getFirstChild().getString();\n            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                defineSlot(n.getFirstChild(), n, functionType);\n            }\n            break;\n        case Token.ASSIGN:\n            Node rvalue \u003d n.getLastChild();\n            Node lvalue \u003d n.getFirstChild();\n            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n                if (type !\u003d null) {\n                    setDeferredType(lvalue, type);\n                }\n            }\n            break;\n        default:\n            throw new IllegalStateException(Integer.toString(n.getType()));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 422,
      "functionName": "define",
      "functionAnnotation": "",
      "functionDoc": "Defines variable(s) or modifies types based on the content of the node\n{@code n}. A variable definition creates variables in the current scope,\na function definition creates a binding, and an assignment updates the\ntype of the namespaces on which the definition is made (e.g.\n{@code goog.FOO \u003d 6}).\n\n@param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n    {@link Token#ASSIGN} node\n@param parent @code n}\u0027s parent\n",
      "diff": "@@ -1,47 +1,47 @@\n void define(Node n, Node parent) {\n     Preconditions.checkState(sourceName !\u003d null);\n     JSDocInfo info \u003d n.getJSDocInfo();\n     switch(n.getType()) {\n         case Token.CATCH:\n             Node catchName \u003d n.getFirstChild();\n             defineSlot(catchName, n, null);\n             break;\n         case Token.VAR:\n-            if (n.getChildCount() \u003e 1) {\n+            if (n.hasMoreThanOneChild()) {\n                 if (info !\u003d null) {\n                     compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                 }\n                 for (Node name : n.children()) {\n                     defineName(name, n, parent, name.getJSDocInfo());\n                 }\n             } else {\n                 Node name \u003d n.getFirstChild();\n                 defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n             }\n             break;\n         case Token.FUNCTION:\n             int parentType \u003d parent.getType();\n             Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n             String functionName \u003d n.getFirstChild().getString();\n             FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 defineSlot(n.getFirstChild(), n, functionType);\n             }\n             break;\n         case Token.ASSIGN:\n             Node rvalue \u003d n.getLastChild();\n             Node lvalue \u003d n.getFirstChild();\n             info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n             if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                 getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n             } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n                 JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n                 if (type !\u003d null) {\n                     setDeferredType(lvalue, type);\n                 }\n             }\n             break;\n         default:\n             throw new IllegalStateException(Integer.toString(n.getType()));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da32cba7b68d69acfc535f57f21d652475d256f": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 4:28 PM",
      "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 4:53 PM",
      "commitNameOld": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "void define(Node n, Node parent) {\n    Preconditions.checkState(sourceName !\u003d null);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    switch(n.getType()) {\n        case Token.CATCH:\n            Node catchName \u003d n.getFirstChild();\n            defineSlot(catchName, n, null);\n            break;\n        case Token.VAR:\n            if (n.getChildCount() \u003e 1) {\n                if (info !\u003d null) {\n                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                }\n                for (Node name : n.children()) {\n                    defineName(name, n, parent, name.getJSDocInfo());\n                }\n            } else {\n                Node name \u003d n.getFirstChild();\n                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n            }\n            break;\n        case Token.FUNCTION:\n            int parentType \u003d parent.getType();\n            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n            String functionName \u003d n.getFirstChild().getString();\n            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                defineSlot(n.getFirstChild(), n, functionType);\n            }\n            break;\n        case Token.ASSIGN:\n            Node rvalue \u003d n.getLastChild();\n            Node lvalue \u003d n.getFirstChild();\n            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n                if (type !\u003d null) {\n                    setDeferredType(lvalue, type);\n                }\n            }\n            break;\n        default:\n            throw new IllegalStateException(Integer.toString(n.getType()));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 424,
      "functionName": "define",
      "functionAnnotation": "",
      "functionDoc": "Defines variable(s) or modifies types based on the content of the node\n{@code n}. A variable definition creates variables in the current scope,\na function definition creates a binding, and an assignment updates the\ntype of the namespaces on which the definition is made (e.g.\n{@code goog.FOO \u003d 6}).\n\n@param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n    {@link Token#ASSIGN} node\n@param parent @code n}\u0027s parent\n",
      "diff": "@@ -1,44 +1,47 @@\n void define(Node n, Node parent) {\n     Preconditions.checkState(sourceName !\u003d null);\n     JSDocInfo info \u003d n.getJSDocInfo();\n     switch(n.getType()) {\n         case Token.CATCH:\n             Node catchName \u003d n.getFirstChild();\n             defineSlot(catchName, n, null);\n             break;\n         case Token.VAR:\n             if (n.getChildCount() \u003e 1) {\n                 if (info !\u003d null) {\n                     compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                 }\n                 for (Node name : n.children()) {\n                     defineName(name, n, parent, name.getJSDocInfo());\n                 }\n             } else {\n                 Node name \u003d n.getFirstChild();\n                 defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n             }\n             break;\n         case Token.FUNCTION:\n             int parentType \u003d parent.getType();\n             Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n             String functionName \u003d n.getFirstChild().getString();\n             FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 defineSlot(n.getFirstChild(), n, functionType);\n             }\n             break;\n         case Token.ASSIGN:\n             Node rvalue \u003d n.getLastChild();\n             Node lvalue \u003d n.getFirstChild();\n             info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n             if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                 getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n             } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)));\n+                JSType type \u003d getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry));\n+                if (type !\u003d null) {\n+                    setDeferredType(lvalue, type);\n+                }\n             }\n             break;\n         default:\n             throw new IllegalStateException(Integer.toString(n.getType()));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/13/10, 2:39 PM",
      "commitNameOld": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void define(Node n, Node parent) {\n    Preconditions.checkState(sourceName !\u003d null);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    switch(n.getType()) {\n        case Token.CATCH:\n            Node catchName \u003d n.getFirstChild();\n            defineSlot(catchName, n, null);\n            break;\n        case Token.VAR:\n            if (n.getChildCount() \u003e 1) {\n                if (info !\u003d null) {\n                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                }\n                for (Node name : n.children()) {\n                    defineName(name, n, parent, name.getJSDocInfo());\n                }\n            } else {\n                Node name \u003d n.getFirstChild();\n                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n            }\n            break;\n        case Token.FUNCTION:\n            int parentType \u003d parent.getType();\n            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n            String functionName \u003d n.getFirstChild().getString();\n            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                defineSlot(n.getFirstChild(), n, functionType);\n            }\n            break;\n        case Token.ASSIGN:\n            Node rvalue \u003d n.getLastChild();\n            Node lvalue \u003d n.getFirstChild();\n            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)));\n            }\n            break;\n        default:\n            throw new IllegalStateException(Integer.toString(n.getType()));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 369,
      "functionName": "define",
      "functionAnnotation": "",
      "functionDoc": "Defines variable(s) or modifies types based on the content of the node\n{@code n}. A variable definition creates variables in the current scope,\na function definition creates a binding, and an assignment updates the\ntype of the namespaces on which the definition is made (e.g.\n{@code goog.FOO \u003d 6}).\n\n@param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n    {@link Token#ASSIGN} node\n@param parent @code n}\u0027s parent\n",
      "diff": "@@ -1,44 +1,44 @@\n void define(Node n, Node parent) {\n     Preconditions.checkState(sourceName !\u003d null);\n     JSDocInfo info \u003d n.getJSDocInfo();\n     switch(n.getType()) {\n         case Token.CATCH:\n             Node catchName \u003d n.getFirstChild();\n             defineSlot(catchName, n, null);\n             break;\n         case Token.VAR:\n             if (n.getChildCount() \u003e 1) {\n                 if (info !\u003d null) {\n                     compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                 }\n                 for (Node name : n.children()) {\n                     defineName(name, n, parent, name.getJSDocInfo());\n                 }\n             } else {\n                 Node name \u003d n.getFirstChild();\n                 defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n             }\n             break;\n         case Token.FUNCTION:\n             int parentType \u003d parent.getType();\n             Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n             String functionName \u003d n.getFirstChild().getString();\n             FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n             if (NodeUtil.isFunctionDeclaration(n)) {\n                 defineSlot(n.getFirstChild(), n, functionType);\n             }\n             break;\n         case Token.ASSIGN:\n             Node rvalue \u003d n.getLastChild();\n             Node lvalue \u003d n.getFirstChild();\n             info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n             if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                 getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n             } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope)));\n+                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope, typeRegistry)));\n             }\n             break;\n         default:\n             throw new IllegalStateException(Integer.toString(n.getType()));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,44 @@\n+void define(Node n, Node parent) {\n+    Preconditions.checkState(sourceName !\u003d null);\n+    JSDocInfo info \u003d n.getJSDocInfo();\n+    switch(n.getType()) {\n+        case Token.CATCH:\n+            Node catchName \u003d n.getFirstChild();\n+            defineSlot(catchName, n, null);\n+            break;\n+        case Token.VAR:\n+            if (n.getChildCount() \u003e 1) {\n+                if (info !\u003d null) {\n+                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+                }\n+                for (Node name : n.children()) {\n+                    defineName(name, n, parent, name.getJSDocInfo());\n+                }\n+            } else {\n+                Node name \u003d n.getFirstChild();\n+                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            int parentType \u003d parent.getType();\n+            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n+            String functionName \u003d n.getFirstChild().getString();\n+            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n+            if (NodeUtil.isFunctionDeclaration(n)) {\n+                defineSlot(n.getFirstChild(), n, functionType);\n+            }\n+            break;\n+        case Token.ASSIGN:\n+            Node rvalue \u003d n.getLastChild();\n+            Node lvalue \u003d n.getFirstChild();\n+            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n+            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n+                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n+            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope)));\n+            }\n+            break;\n+        default:\n+            throw new IllegalStateException(Integer.toString(n.getType()));\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "void define(Node n, Node parent) {\n    Preconditions.checkState(sourceName !\u003d null);\n    JSDocInfo info \u003d n.getJSDocInfo();\n    switch(n.getType()) {\n        case Token.CATCH:\n            Node catchName \u003d n.getFirstChild();\n            defineSlot(catchName, n, null);\n            break;\n        case Token.VAR:\n            if (n.getChildCount() \u003e 1) {\n                if (info !\u003d null) {\n                    compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n                }\n                for (Node name : n.children()) {\n                    defineName(name, n, parent, name.getJSDocInfo());\n                }\n            } else {\n                Node name \u003d n.getFirstChild();\n                defineName(name, n, parent, (info !\u003d null) ? info : name.getJSDocInfo());\n            }\n            break;\n        case Token.FUNCTION:\n            int parentType \u003d parent.getType();\n            Preconditions.checkState((scope.isLocal() || parentType !\u003d Token.ASSIGN) \u0026\u0026 parentType !\u003d Token.NAME, \"function defined as standalone function when it is being \" + \"assigned\");\n            String functionName \u003d n.getFirstChild().getString();\n            FunctionType functionType \u003d getFunctionType(functionName, n, info, null);\n            if (NodeUtil.isFunctionDeclaration(n)) {\n                defineSlot(n.getFirstChild(), n, functionType);\n            }\n            break;\n        case Token.ASSIGN:\n            Node rvalue \u003d n.getLastChild();\n            Node lvalue \u003d n.getFirstChild();\n            info \u003d (info !\u003d null) ? info : rvalue.getJSDocInfo();\n            if (rvalue.getType() \u003d\u003d Token.FUNCTION || info !\u003d null \u0026\u0026 info.isConstructor()) {\n                getFunctionType(lvalue.getQualifiedName(), rvalue, info, lvalue);\n            } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n                lvalue.setJSType(getEnumType(lvalue.getQualifiedName(), n, rvalue, info.getEnumParameterType().evaluate(scope)));\n            }\n            break;\n        default:\n            throw new IllegalStateException(Integer.toString(n.getType()));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 331,
      "functionName": "define",
      "functionAnnotation": "",
      "functionDoc": "Defines variable(s) or modifies types based on the content of the node\n{@code n}. A variable definition creates variables in the current scope,\na function definition creates a binding, and an assignment updates the\ntype of the namespaces on which the definition is made (e.g.\n{@code goog.FOO \u003d 6}).\n\n@param n a {@link Token#VAR}, {@link Token#FUNCTION} or\n    {@link Token#ASSIGN} node\n@param parent @code n}\u0027s parent\n"
    }
  }
}