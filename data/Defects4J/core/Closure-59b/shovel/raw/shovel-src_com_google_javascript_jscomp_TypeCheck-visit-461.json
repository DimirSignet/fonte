{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "",
  "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
  "functionStartLine": 461,
  "functionEndLine": 812,
  "numCommitsSeen": 48,
  "timeTaken": 4084,
  "changeHistory": [
    "0235adc719d0858653861b8ced39a1d057cf93a0",
    "59a30b48325cccadabae8687fdf603d72e26c157",
    "75aa5f653b08995428743f6951a99ad101e73e37",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "0235adc719d0858653861b8ced39a1d057cf93a0": "Ybodychange",
    "59a30b48325cccadabae8687fdf603d72e26c157": "Ybodychange",
    "75aa5f653b08995428743f6951a99ad101e73e37": "Ybodychange",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": "Ybodychange",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": "Ybodychange",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0235adc719d0858653861b8ced39a1d057cf93a0": {
      "type": "Ybodychange",
      "commitMessage": "\nMake DELPROP of a non-reference a parser error\n\nR\u003dacleung\nDELTA\u003d73  (30 added, 39 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2230\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1169 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/9/11, 12:01 PM",
      "commitName": "0235adc719d0858653861b8ced39a1d057cf93a0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/8/11, 1:18 PM",
      "commitNameOld": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,275 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n-            if (!isReference(n.getFirstChild())) {\n-                report(t, n, BAD_DELETE);\n-            }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59a30b48325cccadabae8687fdf603d72e26c157": {
      "type": "Ybodychange",
      "commitMessage": "\nFixes Issue 482\nIn percent typed counting, ignore the nodes of Enum elements\n\nR\u003dacleung\nDELTA\u003d13  (13 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2202\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/8/11, 1:18 PM",
      "commitName": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/31/11, 8:14 AM",
      "commitNameOld": "63df133d0850805818d1e280ba47dcefc9763c89",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,276 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75aa5f653b08995428743f6951a99ad101e73e37": {
      "type": "Ybodychange",
      "commitMessage": "\nCleanup obsolete handling of NUMBER keys of OBJECTLIT.\n\nR\u003dnicksantos\nDELTA\u003d109  (3 added, 48 deleted, 58 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1253\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@967 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/11, 2:40 PM",
      "commitName": "75aa5f653b08995428743f6951a99ad101e73e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/23/11, 3:36 PM",
      "commitNameOld": "fdce3fde269834d9907127955701fc6d783fb3bc",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 439,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,276 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-                ensureTyped(t, n, NUMBER_TYPE);\n-            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic getters and setters support to TypeInference.\n\nR\u003dnicksantos\nDELTA\u003d573  (533 added, 15 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d366\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@735 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/11, 10:33 AM",
      "commitName": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/26/11, 8:30 AM",
      "commitNameOld": "043a352c2e85815a90a1926d112902d924bab6c1",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            }\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n-            } else {\n-                typeable \u003d false;\n             }\n             break;\n+        case Token.STRING:\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            }\n+            break;\n+        case Token.GET:\n+        case Token.SET:\n+            break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n-        case Token.STRING:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n-                ensureTyped(t, n, STRING_TYPE);\n-            } else {\n-                typeable \u003d false;\n-            }\n-            break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key : n.children()) {\n+                    visitObjLitKey(t, key, n);\n+                }\n+            }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": {
      "type": "Ybodychange",
      "commitMessage": "\nFlag null pointer exceptions that are provable at compile time.\n\nR\u003djohnlenz\nDELTA\u003d48  (38 added, 0 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d236\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@682 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/10/11, 12:54 PM",
      "commitName": "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/2/10, 12:04 PM",
      "commitNameOld": "a83c4868dbc0f3229d31af5ff1b8554c44908459",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n-                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n-                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/06/16 by johnlenz\n\n        Remove unused member variable.\n\n        R\u003dacleung\n        DELTA\u003d17  (0 added, 12 deleted, 5 changed)\n\nChange on 2010/06/16 by acleung\n\n        Make @notypecheck behaves like it is doing typechecking except for reporting errors.\n\n        R\u003djohnlenz\n        DELTA\u003d144  (89 added, 17 deleted, 38 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d28012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@245 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/17/10, 10:16 AM",
      "commitName": "0895c28861ee4a1969acc858f1a703ab11ddc64c",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/3/10, 7:03 AM",
      "commitNameOld": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 45.13,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 444,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n-                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n-                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n-                t.report(n, BAD_DELETE);\n+                report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n-            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n+    checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/30/10, 9:01 PM",
      "commitNameOld": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,272 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n-        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": {
      "type": "Ybodychange",
      "commitMessage": "Refactor how coding conventions are set (Nick)\nR\u003dalan\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves\nthe correctness of the compiler as many passes don\u0027t distinguish\nbetween label names and variable names appropriately. (John)\nR\u003drobert\nDELTA\u003d57  (29 added, 12 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@163 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/10, 9:01 PM",
      "commitName": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,272 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    JSType childType;\n+    JSType leftType, rightType;\n+    Node left, right;\n+    boolean typeable \u003d true;\n+    switch(n.getType()) {\n+        case Token.NAME:\n+            typeable \u003d visitName(t, n, parent);\n+            break;\n+        case Token.LP:\n+            if (parent.getType() !\u003d Token.FUNCTION) {\n+                ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.COMMA:\n+            ensureTyped(t, n, getJSType(n.getLastChild()));\n+            break;\n+        case Token.TRUE:\n+        case Token.FALSE:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.THIS:\n+            ensureTyped(t, n, t.getScope().getTypeOfThis());\n+            break;\n+        case Token.REF_SPECIAL:\n+            ensureTyped(t, n);\n+            break;\n+        case Token.GET_REF:\n+            ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            break;\n+        case Token.NULL:\n+            ensureTyped(t, n, NULL_TYPE);\n+            break;\n+        case Token.NUMBER:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, NUMBER_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.ARRAYLIT:\n+            ensureTyped(t, n, ARRAY_TYPE);\n+            break;\n+        case Token.STRING:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.REGEXP:\n+            ensureTyped(t, n, REGEXP_TYPE);\n+            break;\n+        case Token.GETPROP:\n+            visitGetProp(t, n, parent);\n+            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n+            break;\n+        case Token.GETELEM:\n+            visitGetElem(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.VAR:\n+            visitVar(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.NEW:\n+            visitNew(t, n);\n+            typeable \u003d true;\n+            break;\n+        case Token.CALL:\n+            visitCall(t, n);\n+            typeable \u003d !NodeUtil.isExpressionNode(parent);\n+            break;\n+        case Token.RETURN:\n+            visitReturn(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.DEC:\n+        case Token.INC:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.NOT:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.VOID:\n+            ensureTyped(t, n, VOID_TYPE);\n+            break;\n+        case Token.TYPEOF:\n+            ensureTyped(t, n, STRING_TYPE);\n+            break;\n+        case Token.BITNOT:\n+            childType \u003d getJSType(n.getFirstChild());\n+            if (!childType.matchesInt32Context()) {\n+                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.POS:\n+        case Token.NEG:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.EQ:\n+        case Token.NE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    if (n.getType() \u003d\u003d Token.NE) {\n+                        result \u003d result.not();\n+                    }\n+                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.SHEQ:\n+        case Token.SHNE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.LT:\n+        case Token.LE:\n+        case Token.GT:\n+        case Token.GE:\n+            leftType \u003d getJSType(n.getFirstChild());\n+            rightType \u003d getJSType(n.getLastChild());\n+            if (rightType.isNumber()) {\n+                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n+            } else if (leftType.isNumber()) {\n+                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n+            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n+            } else {\n+                String message \u003d \"left side of comparison\";\n+                validator.expectString(t, n, leftType, message);\n+                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                message \u003d \"right side of comparison\";\n+                validator.expectString(t, n, rightType, message);\n+                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.IN:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right);\n+            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n+            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.INSTANCEOF:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n+            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n+            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.ASSIGN:\n+            visitAssign(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.ASSIGN_LSH:\n+        case Token.ASSIGN_RSH:\n+        case Token.ASSIGN_URSH:\n+        case Token.ASSIGN_DIV:\n+        case Token.ASSIGN_MOD:\n+        case Token.ASSIGN_BITOR:\n+        case Token.ASSIGN_BITXOR:\n+        case Token.ASSIGN_BITAND:\n+        case Token.ASSIGN_SUB:\n+        case Token.ASSIGN_ADD:\n+        case Token.ASSIGN_MUL:\n+        case Token.LSH:\n+        case Token.RSH:\n+        case Token.URSH:\n+        case Token.DIV:\n+        case Token.MOD:\n+        case Token.BITOR:\n+        case Token.BITXOR:\n+        case Token.BITAND:\n+        case Token.SUB:\n+        case Token.ADD:\n+        case Token.MUL:\n+            visitBinaryOperator(n.getType(), t, n);\n+            break;\n+        case Token.DELPROP:\n+            if (!isReference(n.getFirstChild())) {\n+                t.report(n, BAD_DELETE);\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.CASE:\n+            JSType switchType \u003d getJSType(parent.getFirstChild());\n+            JSType caseType \u003d getJSType(n.getFirstChild());\n+            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n+            typeable \u003d false;\n+            break;\n+        case Token.WITH:\n+            {\n+                Node child \u003d n.getFirstChild();\n+                childType \u003d getJSType(child);\n+                validator.expectObject(t, child, childType, \"with requires an object\");\n+                typeable \u003d false;\n+                break;\n+            }\n+        case Token.FUNCTION:\n+            visitFunction(t, n);\n+            break;\n+        case Token.LABEL:\n+        case Token.SWITCH:\n+        case Token.BREAK:\n+        case Token.CATCH:\n+        case Token.TRY:\n+        case Token.SCRIPT:\n+        case Token.EXPR_RESULT:\n+        case Token.BLOCK:\n+        case Token.EMPTY:\n+        case Token.DEFAULT:\n+        case Token.CONTINUE:\n+        case Token.DEBUGGER:\n+        case Token.THROW:\n+            typeable \u003d false;\n+            break;\n+        case Token.DO:\n+        case Token.FOR:\n+        case Token.IF:\n+        case Token.WHILE:\n+            typeable \u003d false;\n+            break;\n+        case Token.AND:\n+        case Token.HOOK:\n+        case Token.OBJECTLIT:\n+        case Token.OR:\n+            if (n.getJSType() !\u003d null) {\n+                ensureTyped(t, n);\n+            } else {\n+                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n+                    ensureTyped(t, n, parent.getJSType());\n+                } else {\n+                    ensureTyped(t, n);\n+                }\n+            }\n+            break;\n+        default:\n+            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            ensureTyped(t, n);\n+            break;\n+    }\n+    typeable \u003d typeable \u0026\u0026 !inExterns;\n+    if (typeable) {\n+        doPercentTypedAccounting(t, n);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 408,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n"
    }
  }
}