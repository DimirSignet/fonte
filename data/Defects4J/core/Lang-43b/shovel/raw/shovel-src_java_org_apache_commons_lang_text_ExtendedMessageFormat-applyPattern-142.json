{
  "origin": "codeshovel",
  "repositoryName": "Lang-43b",
  "repositoryPath": "/tmp/Lang-43b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExtendedMessageFormat.java",
  "functionName": "applyPattern",
  "functionId": "applyPattern___pattern-String",
  "sourceFilePath": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
  "functionAnnotation": "",
  "functionDoc": "Apply the specified pattern.\n\n@param pattern String\n",
  "functionStartLine": 142,
  "functionEndLine": 206,
  "numCommitsSeen": 15,
  "timeTaken": 966,
  "changeHistory": [
    "bf1476fafba6a50d40db1765859f47954dd5428c",
    "29c6baa30cb6e1c7a28ec20210cdbd7ac79b15e3",
    "695289c466e51ff7f211867dccbc755fd515fc43",
    "9d5837bfc4b05cc2659e9c920d75a07a4a07b2ab",
    "b2f1757bf9ec1632a940b9a2e65a1a022ba54af8"
  ],
  "changeHistoryShort": {
    "bf1476fafba6a50d40db1765859f47954dd5428c": "Ybodychange",
    "29c6baa30cb6e1c7a28ec20210cdbd7ac79b15e3": "Ybodychange",
    "695289c466e51ff7f211867dccbc755fd515fc43": "Ybodychange",
    "9d5837bfc4b05cc2659e9c920d75a07a4a07b2ab": "Ydocchange",
    "b2f1757bf9ec1632a940b9a2e65a1a022ba54af8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bf1476fafba6a50d40db1765859f47954dd5428c": {
      "type": "Ybodychange",
      "commitMessage": "Dealing with some of the \u003e120 length lines as per checkstyle. A few still need reducing. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@635447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/9/08, 11:27 PM",
      "commitName": "bf1476fafba6a50d40db1765859f47954dd5428c",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "3/7/08, 4:30 PM",
      "commitNameOld": "29c6baa30cb6e1c7a28ec20210cdbd7ac79b15e3",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 2.25,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public final void applyPattern(String pattern) {\n    if (registry \u003d\u003d null) {\n        super.applyPattern(pattern);\n        toPattern \u003d super.toPattern();\n        return;\n    }\n    ArrayList foundFormats \u003d new ArrayList();\n    ArrayList foundDescriptions \u003d new ArrayList();\n    StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n    ParsePosition pos \u003d new ParsePosition(0);\n    char[] c \u003d pattern.toCharArray();\n    int fmtCount \u003d 0;\n    while (pos.getIndex() \u003c pattern.length()) {\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start \u003d pos.getIndex();\n                int index \u003d readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format \u003d null;\n                String formatDescription \u003d null;\n                if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n                    formatDescription \u003d parseFormatDescription(pattern, next(pos));\n                    format \u003d getFormat(formatDescription);\n                    if (format \u003d\u003d null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n                Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n                if (c[pos.getIndex()] !\u003d END_FE) {\n                    throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                }\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n        }\n    }\n    super.applyPattern(stripCustom.toString());\n    toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n    if (containsElements(foundFormats)) {\n        Format[] origFormats \u003d getFormats();\n        int i \u003d 0;\n        for (Iterator it \u003d foundFormats.iterator(); it.hasNext(); i++) {\n            Format f \u003d (Format) it.next();\n            if (f !\u003d null) {\n                origFormats[i] \u003d f;\n            }\n        }\n        super.setFormats(origFormats);\n    }\n}",
      "path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "functionStartLine": 142,
      "functionName": "applyPattern",
      "functionAnnotation": "",
      "functionDoc": "Apply the specified pattern.\n\n@param pattern String\n",
      "diff": "",
      "extendedDetails": {}
    },
    "29c6baa30cb6e1c7a28ec20210cdbd7ac79b15e3": {
      "type": "Ybodychange",
      "commitMessage": "get ExtendedMessageFormat working on JDK 1.3, sort of\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@634874 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/7/08, 4:30 PM",
      "commitName": "29c6baa30cb6e1c7a28ec20210cdbd7ac79b15e3",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "3/5/08, 4:58 PM",
      "commitNameOld": "206bc239a4ac1d8441eadab2bfa315d893f506d9",
      "commitAuthorOld": "Niall Kegan Pemberton",
      "daysBetweenCommits": 1.98,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public final void applyPattern(String pattern) {\n    if (registry \u003d\u003d null) {\n        super.applyPattern(pattern);\n        toPattern \u003d super.toPattern();\n        return;\n    }\n    ArrayList foundFormats \u003d new ArrayList();\n    ArrayList foundDescriptions \u003d new ArrayList();\n    StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n    ParsePosition pos \u003d new ParsePosition(0);\n    char[] c \u003d pattern.toCharArray();\n    int fmtCount \u003d 0;\n    while (pos.getIndex() \u003c pattern.length()) {\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start \u003d pos.getIndex();\n                int index \u003d readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format \u003d null;\n                String formatDescription \u003d null;\n                if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n                    formatDescription \u003d parseFormatDescription(pattern, next(pos));\n                    format \u003d getFormat(formatDescription);\n                    if (format \u003d\u003d null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n                Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n                if (c[pos.getIndex()] !\u003d END_FE) {\n                    throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                }\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n        }\n    }\n    super.applyPattern(stripCustom.toString());\n    toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n    if (containsElements(foundFormats)) {\n        Format[] origFormats \u003d getFormats();\n        int i \u003d 0;\n        for (Iterator it \u003d foundFormats.iterator(); it.hasNext(); i++) {\n            Format f \u003d (Format) it.next();\n            if (f !\u003d null) {\n                origFormats[i] \u003d f;\n            }\n        }\n        super.setFormats(origFormats);\n    }\n}",
      "path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "functionStartLine": 142,
      "functionName": "applyPattern",
      "functionAnnotation": "",
      "functionDoc": "Apply the specified pattern.\n\n@param pattern String\n",
      "diff": "@@ -1,58 +1,59 @@\n public final void applyPattern(String pattern) {\n     if (registry \u003d\u003d null) {\n         super.applyPattern(pattern);\n         toPattern \u003d super.toPattern();\n         return;\n     }\n     ArrayList foundFormats \u003d new ArrayList();\n     ArrayList foundDescriptions \u003d new ArrayList();\n     StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n     ParsePosition pos \u003d new ParsePosition(0);\n     char[] c \u003d pattern.toCharArray();\n     int fmtCount \u003d 0;\n     while (pos.getIndex() \u003c pattern.length()) {\n         switch(c[pos.getIndex()]) {\n             case QUOTE:\n                 appendQuotedString(pattern, pos, stripCustom, true);\n                 break;\n             case START_FE:\n                 fmtCount++;\n                 seekNonWs(pattern, pos);\n                 int start \u003d pos.getIndex();\n                 int index \u003d readArgumentIndex(pattern, next(pos));\n                 stripCustom.append(START_FE).append(index);\n                 seekNonWs(pattern, pos);\n                 Format format \u003d null;\n                 String formatDescription \u003d null;\n                 if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n                     formatDescription \u003d parseFormatDescription(pattern, next(pos));\n                     format \u003d getFormat(formatDescription);\n                     if (format \u003d\u003d null) {\n                         stripCustom.append(START_FMT).append(formatDescription);\n                     }\n                 }\n                 foundFormats.add(format);\n                 foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n                 Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n                 Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n                 if (c[pos.getIndex()] !\u003d END_FE) {\n                     throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                 }\n             default:\n                 stripCustom.append(c[pos.getIndex()]);\n                 next(pos);\n         }\n     }\n     super.applyPattern(stripCustom.toString());\n     toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n     if (containsElements(foundFormats)) {\n         Format[] origFormats \u003d getFormats();\n-        for (int i \u003d 0; i \u003c origFormats.length; i++) {\n-            Format f \u003d (Format) foundFormats.get(i);\n+        int i \u003d 0;\n+        for (Iterator it \u003d foundFormats.iterator(); it.hasNext(); i++) {\n+            Format f \u003d (Format) it.next();\n             if (f !\u003d null) {\n                 origFormats[i] \u003d f;\n             }\n         }\n         super.setFormats(origFormats);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "695289c466e51ff7f211867dccbc755fd515fc43": {
      "type": "Ybodychange",
      "commitMessage": "[LANG-362] simplify ExtendedMessageFormat design; recycle as much of super implementation as possible\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@630969 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/25/08, 11:51 AM",
      "commitName": "695289c466e51ff7f211867dccbc755fd515fc43",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "1/16/08, 4:31 PM",
      "commitNameOld": "d22a7081177900da607990bfa75cdf28d01abff0",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 39.81,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public final void applyPattern(String pattern) {\n    if (registry \u003d\u003d null) {\n        super.applyPattern(pattern);\n        toPattern \u003d super.toPattern();\n        return;\n    }\n    ArrayList foundFormats \u003d new ArrayList();\n    ArrayList foundDescriptions \u003d new ArrayList();\n    StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n    ParsePosition pos \u003d new ParsePosition(0);\n    char[] c \u003d pattern.toCharArray();\n    int fmtCount \u003d 0;\n    while (pos.getIndex() \u003c pattern.length()) {\n        switch(c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start \u003d pos.getIndex();\n                int index \u003d readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format \u003d null;\n                String formatDescription \u003d null;\n                if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n                    formatDescription \u003d parseFormatDescription(pattern, next(pos));\n                    format \u003d getFormat(formatDescription);\n                    if (format \u003d\u003d null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n                Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n                if (c[pos.getIndex()] !\u003d END_FE) {\n                    throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                }\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n        }\n    }\n    super.applyPattern(stripCustom.toString());\n    toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n    if (containsElements(foundFormats)) {\n        Format[] origFormats \u003d getFormats();\n        for (int i \u003d 0; i \u003c origFormats.length; i++) {\n            Format f \u003d (Format) foundFormats.get(i);\n            if (f !\u003d null) {\n                origFormats[i] \u003d f;\n            }\n        }\n        super.setFormats(origFormats);\n    }\n}",
      "path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "functionStartLine": 112,
      "functionName": "applyPattern",
      "functionAnnotation": "",
      "functionDoc": "Apply the specified pattern.\n\n@param pattern String\n",
      "diff": "@@ -1,10 +1,58 @@\n public final void applyPattern(String pattern) {\n-    if (metaFormat \u003d\u003d null) {\n+    if (registry \u003d\u003d null) {\n+        super.applyPattern(pattern);\n+        toPattern \u003d super.toPattern();\n         return;\n     }\n-    applyPatternPre(pattern);\n-    strippedPattern \u003d PARSER.stripFormats(pattern);\n-    super.applyPattern(strippedPattern);\n-    setFormats(PARSER.parseFormats(pattern, metaFormat));\n-    applyPatternPost(pattern);\n+    ArrayList foundFormats \u003d new ArrayList();\n+    ArrayList foundDescriptions \u003d new ArrayList();\n+    StringBuffer stripCustom \u003d new StringBuffer(pattern.length());\n+    ParsePosition pos \u003d new ParsePosition(0);\n+    char[] c \u003d pattern.toCharArray();\n+    int fmtCount \u003d 0;\n+    while (pos.getIndex() \u003c pattern.length()) {\n+        switch(c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start \u003d pos.getIndex();\n+                int index \u003d readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format \u003d null;\n+                String formatDescription \u003d null;\n+                if (c[pos.getIndex()] \u003d\u003d START_FMT) {\n+                    formatDescription \u003d parseFormatDescription(pattern, next(pos));\n+                    format \u003d getFormat(formatDescription);\n+                    if (format \u003d\u003d null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format \u003d\u003d null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() \u003d\u003d fmtCount);\n+                Validate.isTrue(foundDescriptions.size() \u003d\u003d fmtCount);\n+                if (c[pos.getIndex()] !\u003d END_FE) {\n+                    throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n+                }\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+        }\n+    }\n+    super.applyPattern(stripCustom.toString());\n+    toPattern \u003d insertFormats(super.toPattern(), foundDescriptions);\n+    if (containsElements(foundFormats)) {\n+        Format[] origFormats \u003d getFormats();\n+        for (int i \u003d 0; i \u003c origFormats.length; i++) {\n+            Format f \u003d (Format) foundFormats.get(i);\n+            if (f !\u003d null) {\n+                origFormats[i] \u003d f;\n+            }\n+        }\n+        super.setFormats(origFormats);\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d5837bfc4b05cc2659e9c920d75a07a4a07b2ab": {
      "type": "Ydocchange",
      "commitMessage": "[LANG-362] checkstyle; javadoc; extended testing which necessitated some refactorings\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@598707 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/27/07, 9:27 AM",
      "commitName": "9d5837bfc4b05cc2659e9c920d75a07a4a07b2ab",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "11/5/07, 8:16 AM",
      "commitNameOld": "783f8b9c552be16a92e8d0241a321378defacd51",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 22.05,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "public final void applyPattern(String pattern) {\n    if (metaFormat \u003d\u003d null) {\n        return;\n    }\n    applyPatternPre(pattern);\n    strippedPattern \u003d PARSER.stripFormats(pattern);\n    super.applyPattern(strippedPattern);\n    setFormats(PARSER.parseFormats(pattern, metaFormat));\n    applyPatternPost(pattern);\n}",
      "path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "functionStartLine": 366,
      "functionName": "applyPattern",
      "functionAnnotation": "",
      "functionDoc": "Apply the specified pattern.\n\n@param pattern String\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Apply the specified pattern.\n\n@param pattern pattern String\n",
        "newValue": "Apply the specified pattern.\n\n@param pattern String\n"
      }
    },
    "b2f1757bf9ec1632a940b9a2e65a1a022ba54af8": {
      "type": "Yintroduced",
      "commitMessage": "[LANG-362] Add ExtendedMessageFormat\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@590106 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/30/07, 8:06 AM",
      "commitName": "b2f1757bf9ec1632a940b9a2e65a1a022ba54af8",
      "commitAuthor": "Matthew Jason Benson",
      "diff": "@@ -0,0 +1,10 @@\n+public final void applyPattern(String pattern) {\n+    if (metaFormat \u003d\u003d null) {\n+        return;\n+    }\n+    applyPatternPre(pattern);\n+    strippedPattern \u003d PARSER.stripFormats(pattern);\n+    super.applyPattern(strippedPattern);\n+    setFormats(PARSER.parseFormats(pattern, metaFormat));\n+    applyPatternPost(pattern);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public final void applyPattern(String pattern) {\n    if (metaFormat \u003d\u003d null) {\n        return;\n    }\n    applyPatternPre(pattern);\n    strippedPattern \u003d PARSER.stripFormats(pattern);\n    super.applyPattern(strippedPattern);\n    setFormats(PARSER.parseFormats(pattern, metaFormat));\n    applyPatternPost(pattern);\n}",
      "path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java",
      "functionStartLine": 282,
      "functionName": "applyPattern",
      "functionAnnotation": "",
      "functionDoc": "Apply the specified pattern.\n\n@param pattern pattern String\n"
    }
  }
}