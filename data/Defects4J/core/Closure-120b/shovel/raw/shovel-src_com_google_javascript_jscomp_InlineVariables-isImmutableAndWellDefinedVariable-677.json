{
  "origin": "codeshovel",
  "repositoryName": "Closure-120b",
  "repositoryPath": "/tmp/Closure-120b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InlineVariables.java",
  "functionName": "isImmutableAndWellDefinedVariable",
  "functionId": "$isImmutableAndWellDefinedVariable___v-Var__refInfo-ReferenceCollection",
  "sourceFilePath": "src/com/google/javascript/jscomp/InlineVariables.java",
  "functionAnnotation": "",
  "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
  "functionStartLine": 677,
  "functionEndLine": 727,
  "numCommitsSeen": 34,
  "timeTaken": 1758,
  "changeHistory": [
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "40ab7fc97ed52e3a1c1235ee20f97c10e39d6390",
    "1771d2005a441cb87df2a488069f265bd71ed9ee",
    "bca9abb0e3062d373fe52c0e8340337588c05708",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "40ab7fc97ed52e3a1c1235ee20f97c10e39d6390": "Ybodychange",
    "1771d2005a441cb87df2a488069f265bd71ed9ee": "Yformatchange",
    "bca9abb0e3062d373fe52c0e8340337588c05708": "Ybodychange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 4.4,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n    if (!isNeverAssigned) {\n        Reference refInit \u003d refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n            return false;\n        }\n        if (refDecl !\u003d refInit) {\n            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n            startingReadRef \u003d 2;\n        }\n        if (!refInfo.isWellDefined()) {\n            return false;\n        }\n        Node value \u003d refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (!value.isString() || isStringWorthInlining(v, refInfo.references));\n        boolean isInlinableThisAlias \u003d value.isThis() \u0026\u0026 !refInfo.isEscaped();\n        if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n            return false;\n        }\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 668,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "@@ -1,36 +1,36 @@\n private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n     List\u003cReference\u003e refSet \u003d refInfo.references;\n     int startingReadRef \u003d 1;\n     Reference refDecl \u003d refSet.get(0);\n     if (!isValidDeclaration(refDecl)) {\n         return false;\n     }\n     boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n     if (!isNeverAssigned) {\n         Reference refInit \u003d refInfo.getInitializingReference();\n         if (!isValidInitialization(refInit)) {\n             return false;\n         }\n         if (refDecl !\u003d refInit) {\n             Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n             startingReadRef \u003d 2;\n         }\n         if (!refInfo.isWellDefined()) {\n             return false;\n         }\n         Node value \u003d refInit.getAssignedValue();\n         Preconditions.checkNotNull(value);\n-        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n+        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (!value.isString() || isStringWorthInlining(v, refInfo.references));\n         boolean isInlinableThisAlias \u003d value.isThis() \u0026\u0026 !refInfo.isEscaped();\n         if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n             return false;\n         }\n     }\n     for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/23/11, 1:45 PM",
      "commitNameOld": "03db3415761aa9d8ba2fafa0ed64116a8331b1a9",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 139.83,
      "commitsBetweenForRepo": 340,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n    if (!isNeverAssigned) {\n        Reference refInit \u003d refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n            return false;\n        }\n        if (refDecl !\u003d refInit) {\n            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n            startingReadRef \u003d 2;\n        }\n        if (!refInfo.isWellDefined()) {\n            return false;\n        }\n        Node value \u003d refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n        boolean isInlinableThisAlias \u003d value.isThis() \u0026\u0026 !refInfo.isEscaped();\n        if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n            return false;\n        }\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 670,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "@@ -1,36 +1,36 @@\n private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n     List\u003cReference\u003e refSet \u003d refInfo.references;\n     int startingReadRef \u003d 1;\n     Reference refDecl \u003d refSet.get(0);\n     if (!isValidDeclaration(refDecl)) {\n         return false;\n     }\n     boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n     if (!isNeverAssigned) {\n         Reference refInit \u003d refInfo.getInitializingReference();\n         if (!isValidInitialization(refInit)) {\n             return false;\n         }\n         if (refDecl !\u003d refInit) {\n             Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n             startingReadRef \u003d 2;\n         }\n         if (!refInfo.isWellDefined()) {\n             return false;\n         }\n         Node value \u003d refInit.getAssignedValue();\n         Preconditions.checkNotNull(value);\n         boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n-        boolean isInlinableThisAlias \u003d value.getType() \u003d\u003d Token.THIS \u0026\u0026 !refInfo.isEscaped();\n+        boolean isInlinableThisAlias \u003d value.isThis() \u0026\u0026 !refInfo.isEscaped();\n         if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n             return false;\n         }\n     }\n     for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "40ab7fc97ed52e3a1c1235ee20f97c10e39d6390": {
      "type": "Ybodychange",
      "commitMessage": "Delete the heuristic arity checks.\nAlmost all BUILD rules in google3 with this flag turned on are using\ntype-checking, which overrides this flag. I don\u0027t think it\u0027s worth\nsupporting for the few people left who use it. (Nick)\nR\u003dJohn\nDELTA\u003d659  (0 added, 654 deleted, 5 changed)\n\nuse the right error-reporting apis. (Nick)\nR\u003dJohn\nDELTA\u003d19  (2 added, 0 deleted, 17 changed)\n\ninline aliases of \u0027this\u0027 (Nick)\nR\u003dJohn\nDELTA\u003d34  (31 added, 1 deleted, 2 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@155 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/25/10, 1:21 PM",
      "commitName": "40ab7fc97ed52e3a1c1235ee20f97c10e39d6390",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 13.62,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n    if (!isNeverAssigned) {\n        Reference refInit \u003d refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n            return false;\n        }\n        if (refDecl !\u003d refInit) {\n            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n            startingReadRef \u003d 2;\n        }\n        if (!refInfo.isWellDefined()) {\n            return false;\n        }\n        Node value \u003d refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n        boolean isInlinableThisAlias \u003d value.getType() \u003d\u003d Token.THIS \u0026\u0026 !refInfo.isEscaped();\n        if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n            return false;\n        }\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 624,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "@@ -1,34 +1,36 @@\n private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n     List\u003cReference\u003e refSet \u003d refInfo.references;\n     int startingReadRef \u003d 1;\n     Reference refDecl \u003d refSet.get(0);\n     if (!isValidDeclaration(refDecl)) {\n         return false;\n     }\n     boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n     if (!isNeverAssigned) {\n         Reference refInit \u003d refInfo.getInitializingReference();\n         if (!isValidInitialization(refInit)) {\n             return false;\n         }\n         if (refDecl !\u003d refInit) {\n             Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n             startingReadRef \u003d 2;\n         }\n         if (!refInfo.isWellDefined()) {\n             return false;\n         }\n         Node value \u003d refInit.getAssignedValue();\n         Preconditions.checkNotNull(value);\n-        if (!(NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references)))) {\n+        boolean isImmutableValueWorthInlining \u003d NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n+        boolean isInlinableThisAlias \u003d value.getType() \u003d\u003d Token.THIS \u0026\u0026 !refInfo.isEscaped();\n+        if (!isImmutableValueWorthInlining \u0026\u0026 !isInlinableThisAlias) {\n             return false;\n         }\n     }\n     for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n             return false;\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1771d2005a441cb87df2a488069f265bd71ed9ee": {
      "type": "Yformatchange",
      "commitMessage": "delete some dead code\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@103 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/11/10, 1:02 PM",
      "commitName": "1771d2005a441cb87df2a488069f265bd71ed9ee",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/26/10, 1:59 PM",
      "commitNameOld": "bca9abb0e3062d373fe52c0e8340337588c05708",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 15.96,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n    if (!isNeverAssigned) {\n        Reference refInit \u003d refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n            return false;\n        }\n        if (refDecl !\u003d refInit) {\n            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n            startingReadRef \u003d 2;\n        }\n        if (!refInfo.isWellDefined()) {\n            return false;\n        }\n        Node value \u003d refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        if (!(NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references)))) {\n            return false;\n        }\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 610,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "bca9abb0e3062d373fe52c0e8340337588c05708": {
      "type": "Ybodychange",
      "commitMessage": "Make sure that InlineVariables can inline variables that are never defined.\n\nCreate a function-inlining blacklist.\n\nSome minor type inference fixes.\n\nStart re-architecting type resolution to happen differently.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@77 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/26/10, 1:59 PM",
      "commitName": "bca9abb0e3062d373fe52c0e8340337588c05708",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 62.3,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n    if (!isNeverAssigned) {\n        Reference refInit \u003d refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n            return false;\n        }\n        if (refDecl !\u003d refInit) {\n            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n            startingReadRef \u003d 2;\n        }\n        if (!refInfo.isWellDefined()) {\n            return false;\n        }\n        Node value \u003d refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        if (!(NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references)))) {\n            return false;\n        }\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 610,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "@@ -1,28 +1,34 @@\n private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n     List\u003cReference\u003e refSet \u003d refInfo.references;\n     int startingReadRef \u003d 1;\n     Reference refDecl \u003d refSet.get(0);\n     if (!isValidDeclaration(refDecl)) {\n         return false;\n     }\n-    Reference refInit \u003d refInfo.getInitializingReference();\n-    if (!isValidInitialization(refInit)) {\n-        return false;\n-    }\n-    if (refDecl !\u003d refInit) {\n-        Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n-        startingReadRef \u003d 2;\n+    boolean isNeverAssigned \u003d refInfo.isNeverAssigned();\n+    if (!isNeverAssigned) {\n+        Reference refInit \u003d refInfo.getInitializingReference();\n+        if (!isValidInitialization(refInit)) {\n+            return false;\n+        }\n+        if (refDecl !\u003d refInit) {\n+            Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n+            startingReadRef \u003d 2;\n+        }\n+        if (!refInfo.isWellDefined()) {\n+            return false;\n+        }\n+        Node value \u003d refInit.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        if (!(NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references)))) {\n+            return false;\n+        }\n     }\n     for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n             return false;\n         }\n     }\n-    if (!refInfo.isWellDefined()) {\n-        return false;\n-    }\n-    Node value \u003d refInit.getAssignedValue();\n-    Preconditions.checkNotNull(value);\n-    return NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n+    return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ybodychange",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/6/09, 5:24 PM",
      "commitNameOld": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.74,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    int startingReadRef \u003d 1;\n    Reference refDecl \u003d refSet.get(0);\n    if (!isValidDeclaration(refDecl)) {\n        return false;\n    }\n    Reference refInit \u003d refInfo.getInitializingReference();\n    if (!isValidInitialization(refInit)) {\n        return false;\n    }\n    if (refDecl !\u003d refInit) {\n        Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n        startingReadRef \u003d 2;\n    }\n    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    if (!refInfo.isWellDefined()) {\n        return false;\n    }\n    Node value \u003d refInit.getAssignedValue();\n    Preconditions.checkNotNull(value);\n    return NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 573,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n",
      "diff": "@@ -1,17 +1,28 @@\n private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n     List\u003cReference\u003e refSet \u003d refInfo.references;\n-    if (!isValidDeclaration(refSet.get(0))) {\n+    int startingReadRef \u003d 1;\n+    Reference refDecl \u003d refSet.get(0);\n+    if (!isValidDeclaration(refDecl)) {\n         return false;\n     }\n-    for (int i \u003d 1; i \u003c refSet.size(); i++) {\n+    Reference refInit \u003d refInfo.getInitializingReference();\n+    if (!isValidInitialization(refInit)) {\n+        return false;\n+    }\n+    if (refDecl !\u003d refInit) {\n+        Preconditions.checkState(refInit \u003d\u003d refSet.get(1));\n+        startingReadRef \u003d 2;\n+    }\n+    for (int i \u003d startingReadRef; i \u003c refSet.size(); i++) {\n         Reference ref \u003d refSet.get(i);\n         if (!isValidReference(ref)) {\n             return false;\n         }\n     }\n     if (!refInfo.isWellDefined()) {\n         return false;\n     }\n-    Node value \u003d refSet.get(0).getNameNode().getFirstChild();\n+    Node value \u003d refInit.getAssignedValue();\n+    Preconditions.checkNotNull(value);\n     return NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,17 @@\n+private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n+    List\u003cReference\u003e refSet \u003d refInfo.references;\n+    if (!isValidDeclaration(refSet.get(0))) {\n+        return false;\n+    }\n+    for (int i \u003d 1; i \u003c refSet.size(); i++) {\n+        Reference ref \u003d refSet.get(i);\n+        if (!isValidReference(ref)) {\n+            return false;\n+        }\n+    }\n+    if (!refInfo.isWellDefined()) {\n+        return false;\n+    }\n+    Node value \u003d refSet.get(0).getNameNode().getFirstChild();\n+    return NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n+}\n\\ No newline at end of file\n",
      "actualSource": "private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) {\n    List\u003cReference\u003e refSet \u003d refInfo.references;\n    if (!isValidDeclaration(refSet.get(0))) {\n        return false;\n    }\n    for (int i \u003d 1; i \u003c refSet.size(); i++) {\n        Reference ref \u003d refSet.get(i);\n        if (!isValidReference(ref)) {\n            return false;\n        }\n    }\n    if (!refInfo.isWellDefined()) {\n        return false;\n    }\n    Node value \u003d refSet.get(0).getNameNode().getFirstChild();\n    return NodeUtil.isImmutableValue(value) \u0026\u0026 (value.getType() !\u003d Token.STRING || isStringWorthInlining(v, refInfo.references));\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 503,
      "functionName": "isImmutableAndWellDefinedVariable",
      "functionAnnotation": "",
      "functionDoc": "Determines whether the reference collection describes a variable that\nis initialized to an immutable value, never modified, and defined before\nevery reference.\n"
    }
  }
}