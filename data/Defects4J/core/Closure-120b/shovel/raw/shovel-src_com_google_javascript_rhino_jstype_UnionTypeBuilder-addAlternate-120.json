{
  "origin": "codeshovel",
  "repositoryName": "Closure-120b",
  "repositoryPath": "/tmp/Closure-120b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnionTypeBuilder.java",
  "functionName": "addAlternate",
  "functionId": "addAlternate___alternate-JSType",
  "sourceFilePath": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
  "functionAnnotation": "",
  "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
  "functionStartLine": 120,
  "functionEndLine": 281,
  "numCommitsSeen": 28,
  "timeTaken": 1769,
  "changeHistory": [
    "44ebf6062655dc55d0569c80ce7806100435fba0",
    "4cac8c1e896e04418f57f9a6208311444aa3d5f3",
    "9bf6d8db973a4691ad1551bdcbc559a86ba60532",
    "e14000ea47087087d79dd4e5b7425439c7e5c12a",
    "177d001a30c568037141e555d84f9bd28d3d2d86",
    "30a88df811879f5d389f56257c93ab5f740a0518",
    "59aac0b247db74ec7047132f368953935edd81b8",
    "465b84d337b9ac732b6890fae3c4deea46bc0fb4",
    "6c7c28651eac368f7ff4180abff580114fd0113d",
    "4fe98319ed6ad9110a0722bfb39efacf181bbba1",
    "57ed289a74973e0bc04bd684faf3c4580e0cb812",
    "dc58965f18f524c67556aa4d750cd1d7f5cd1c83",
    "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9",
    "79c373c265c0444e0e1edb014ec4e763689879dc",
    "043a352c2e85815a90a1926d112902d924bab6c1",
    "11bd742011d67590031dba6e9d1f7186393b38a0",
    "6dbca87c463d8a1e229a0d92d5cdf92247fdefde",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "44ebf6062655dc55d0569c80ce7806100435fba0": "Ybodychange",
    "4cac8c1e896e04418f57f9a6208311444aa3d5f3": "Ybodychange",
    "9bf6d8db973a4691ad1551bdcbc559a86ba60532": "Ybodychange",
    "e14000ea47087087d79dd4e5b7425439c7e5c12a": "Ybodychange",
    "177d001a30c568037141e555d84f9bd28d3d2d86": "Ybodychange",
    "30a88df811879f5d389f56257c93ab5f740a0518": "Ybodychange",
    "59aac0b247db74ec7047132f368953935edd81b8": "Yformatchange",
    "465b84d337b9ac732b6890fae3c4deea46bc0fb4": "Yformatchange",
    "6c7c28651eac368f7ff4180abff580114fd0113d": "Yformatchange",
    "4fe98319ed6ad9110a0722bfb39efacf181bbba1": "Ybodychange",
    "57ed289a74973e0bc04bd684faf3c4580e0cb812": "Ybodychange",
    "dc58965f18f524c67556aa4d750cd1d7f5cd1c83": "Ybodychange",
    "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9": "Ybodychange",
    "79c373c265c0444e0e1edb014ec4e763689879dc": "Ybodychange",
    "043a352c2e85815a90a1926d112902d924bab6c1": "Ybodychange",
    "11bd742011d67590031dba6e9d1f7186393b38a0": "Ybodychange",
    "6dbca87c463d8a1e229a0d92d5cdf92247fdefde": "Ybodychange",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "44ebf6062655dc55d0569c80ce7806100435fba0": {
      "type": "Ybodychange",
      "commitMessage": "\nExtends TemplatizedType to handle any number of template types, and removes IndexedType. Converts Array and Object to the new generic templatized type system.\n\nR\u003ddimvar,nicksantos,johnlenz,tylerg\nDELTA\u003d544 (273 added, 143 deleted, 128 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6255\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2504 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/4/13, 1:10 PM",
      "commitName": "44ebf6062655dc55d0569c80ce7806100435fba0",
      "commitAuthor": "izaakr@google.com",
      "commitDateOld": "1/30/13, 3:40 PM",
      "commitNameOld": "e46b1409d092a859fa9821af8bba0f480164de3e",
      "commitAuthorOld": "blickly@google.com",
      "daysBetweenCommits": 4.9,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                boolean removeCurrent \u003d false;\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isTemplatizedType() || current.isTemplatizedType()) {\n                        if (!current.isTemplatizedType()) {\n                            if (alternate.isSubtype(current)) {\n                                return this;\n                            }\n                        } else if (!alternate.isTemplatizedType()) {\n                            if (current.isSubtype(alternate)) {\n                                removeCurrent \u003d true;\n                            }\n                        } else {\n                            Preconditions.checkState(current.isTemplatizedType() \u0026\u0026 alternate.isTemplatizedType());\n                            TemplatizedType templatizedAlternate \u003d alternate.toMaybeTemplatizedType();\n                            TemplatizedType templatizedCurrent \u003d current.toMaybeTemplatizedType();\n                            if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n                                if (alternate.getTemplateTypeMap().checkEquivalenceHelper(current.getTemplateTypeMap(), EquivalenceMethod.IDENTITY)) {\n                                    return this;\n                                } else {\n                                    JSType merged \u003d templatizedCurrent.getReferencedObjTypeInternal();\n                                    return addAlternate(merged);\n                                }\n                            }\n                        }\n                    } else if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        removeCurrent \u003d true;\n                    }\n                }\n                if (removeCurrent) {\n                    it.remove();\n                    if (currentIndex \u003d\u003d functionTypePosition) {\n                        functionTypePosition \u003d -1;\n                    } else if (currentIndex \u003c functionTypePosition) {\n                        functionTypePosition--;\n                        currentIndex--;\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,89 +1,88 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 boolean removeCurrent \u003d false;\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isTemplatizedType() || current.isTemplatizedType()) {\n                         if (!current.isTemplatizedType()) {\n                             if (alternate.isSubtype(current)) {\n                                 return this;\n                             }\n                         } else if (!alternate.isTemplatizedType()) {\n                             if (current.isSubtype(alternate)) {\n                                 removeCurrent \u003d true;\n                             }\n                         } else {\n                             Preconditions.checkState(current.isTemplatizedType() \u0026\u0026 alternate.isTemplatizedType());\n                             TemplatizedType templatizedAlternate \u003d alternate.toMaybeTemplatizedType();\n                             TemplatizedType templatizedCurrent \u003d current.toMaybeTemplatizedType();\n                             if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n-                                JSType currentTypeParameter \u003d templatizedCurrent.getTemplateType();\n-                                if (currentTypeParameter.isEquivalentTo(templatizedCurrent)) {\n+                                if (alternate.getTemplateTypeMap().checkEquivalenceHelper(current.getTemplateTypeMap(), EquivalenceMethod.IDENTITY)) {\n                                     return this;\n                                 } else {\n                                     JSType merged \u003d templatizedCurrent.getReferencedObjTypeInternal();\n                                     return addAlternate(merged);\n                                 }\n                             }\n                         }\n                     } else if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         removeCurrent \u003d true;\n                     }\n                 }\n                 if (removeCurrent) {\n                     it.remove();\n                     if (currentIndex \u003d\u003d functionTypePosition) {\n                         functionTypePosition \u003d -1;\n                     } else if (currentIndex \u003c functionTypePosition) {\n                         functionTypePosition--;\n                         currentIndex--;\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4cac8c1e896e04418f57f9a6208311444aa3d5f3": {
      "type": "Ybodychange",
      "commitMessage": "\nRenames ParameterizedType to TemplatizedType.\n\nR\u003ddimvar,nicksantos,johnlenz\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6186\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2486 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/23/13, 5:45 PM",
      "commitName": "4cac8c1e896e04418f57f9a6208311444aa3d5f3",
      "commitAuthor": "izaakr@google.com",
      "commitDateOld": "1/10/13, 4:31 PM",
      "commitNameOld": "9bf6d8db973a4691ad1551bdcbc559a86ba60532",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 13.05,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                boolean removeCurrent \u003d false;\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isTemplatizedType() || current.isTemplatizedType()) {\n                        if (!current.isTemplatizedType()) {\n                            if (alternate.isSubtype(current)) {\n                                return this;\n                            }\n                        } else if (!alternate.isTemplatizedType()) {\n                            if (current.isSubtype(alternate)) {\n                                removeCurrent \u003d true;\n                            }\n                        } else {\n                            Preconditions.checkState(current.isTemplatizedType() \u0026\u0026 alternate.isTemplatizedType());\n                            TemplatizedType templatizedAlternate \u003d alternate.toMaybeTemplatizedType();\n                            TemplatizedType templatizedCurrent \u003d current.toMaybeTemplatizedType();\n                            if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n                                JSType currentTypeParameter \u003d templatizedCurrent.getTemplateType();\n                                if (currentTypeParameter.isEquivalentTo(templatizedCurrent)) {\n                                    return this;\n                                } else {\n                                    JSType merged \u003d templatizedCurrent.getReferencedObjTypeInternal();\n                                    return addAlternate(merged);\n                                }\n                            }\n                        }\n                    } else if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        removeCurrent \u003d true;\n                    }\n                }\n                if (removeCurrent) {\n                    it.remove();\n                    if (currentIndex \u003d\u003d functionTypePosition) {\n                        functionTypePosition \u003d -1;\n                    } else if (currentIndex \u003c functionTypePosition) {\n                        functionTypePosition--;\n                        currentIndex--;\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,89 +1,89 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 boolean removeCurrent \u003d false;\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n-                    if (alternate.isParameterizedType() || current.isParameterizedType()) {\n-                        if (!current.isParameterizedType()) {\n+                    if (alternate.isTemplatizedType() || current.isTemplatizedType()) {\n+                        if (!current.isTemplatizedType()) {\n                             if (alternate.isSubtype(current)) {\n                                 return this;\n                             }\n-                        } else if (!alternate.isParameterizedType()) {\n+                        } else if (!alternate.isTemplatizedType()) {\n                             if (current.isSubtype(alternate)) {\n                                 removeCurrent \u003d true;\n                             }\n                         } else {\n-                            Preconditions.checkState(current.isParameterizedType() \u0026\u0026 alternate.isParameterizedType());\n-                            ParameterizedType parameterizedAlternate \u003d alternate.toMaybeParameterizedType();\n-                            ParameterizedType parameterizedCurrent \u003d current.toMaybeParameterizedType();\n-                            if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n-                                JSType currentTypeParameter \u003d parameterizedCurrent.getParameterType();\n-                                if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n+                            Preconditions.checkState(current.isTemplatizedType() \u0026\u0026 alternate.isTemplatizedType());\n+                            TemplatizedType templatizedAlternate \u003d alternate.toMaybeTemplatizedType();\n+                            TemplatizedType templatizedCurrent \u003d current.toMaybeTemplatizedType();\n+                            if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n+                                JSType currentTypeParameter \u003d templatizedCurrent.getTemplateType();\n+                                if (currentTypeParameter.isEquivalentTo(templatizedCurrent)) {\n                                     return this;\n                                 } else {\n-                                    JSType merged \u003d parameterizedCurrent.getReferencedObjTypeInternal();\n+                                    JSType merged \u003d templatizedCurrent.getReferencedObjTypeInternal();\n                                     return addAlternate(merged);\n                                 }\n                             }\n                         }\n                     } else if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         removeCurrent \u003d true;\n                     }\n                 }\n                 if (removeCurrent) {\n                     it.remove();\n                     if (currentIndex \u003d\u003d functionTypePosition) {\n                         functionTypePosition \u003d -1;\n                     } else if (currentIndex \u003c functionTypePosition) {\n                         functionTypePosition--;\n                         currentIndex--;\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9bf6d8db973a4691ad1551bdcbc559a86ba60532": {
      "type": "Ybodychange",
      "commitMessage": "\nMore unused locals and parameter removal and unused parameter warning suppression.\n\nR\u003ddimvar\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6122\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2457 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/10/13, 4:31 PM",
      "commitName": "9bf6d8db973a4691ad1551bdcbc559a86ba60532",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/12/12, 11:54 AM",
      "commitNameOld": "e14000ea47087087d79dd4e5b7425439c7e5c12a",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 29.19,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                boolean removeCurrent \u003d false;\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isParameterizedType() || current.isParameterizedType()) {\n                        if (!current.isParameterizedType()) {\n                            if (alternate.isSubtype(current)) {\n                                return this;\n                            }\n                        } else if (!alternate.isParameterizedType()) {\n                            if (current.isSubtype(alternate)) {\n                                removeCurrent \u003d true;\n                            }\n                        } else {\n                            Preconditions.checkState(current.isParameterizedType() \u0026\u0026 alternate.isParameterizedType());\n                            ParameterizedType parameterizedAlternate \u003d alternate.toMaybeParameterizedType();\n                            ParameterizedType parameterizedCurrent \u003d current.toMaybeParameterizedType();\n                            if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n                                JSType currentTypeParameter \u003d parameterizedCurrent.getParameterType();\n                                if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n                                    return this;\n                                } else {\n                                    JSType merged \u003d parameterizedCurrent.getReferencedObjTypeInternal();\n                                    return addAlternate(merged);\n                                }\n                            }\n                        }\n                    } else if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        removeCurrent \u003d true;\n                    }\n                }\n                if (removeCurrent) {\n                    it.remove();\n                    if (currentIndex \u003d\u003d functionTypePosition) {\n                        functionTypePosition \u003d -1;\n                    } else if (currentIndex \u003c functionTypePosition) {\n                        functionTypePosition--;\n                        currentIndex--;\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,90 +1,89 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 boolean removeCurrent \u003d false;\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isParameterizedType() || current.isParameterizedType()) {\n                         if (!current.isParameterizedType()) {\n                             if (alternate.isSubtype(current)) {\n                                 return this;\n                             }\n                         } else if (!alternate.isParameterizedType()) {\n                             if (current.isSubtype(alternate)) {\n                                 removeCurrent \u003d true;\n                             }\n                         } else {\n                             Preconditions.checkState(current.isParameterizedType() \u0026\u0026 alternate.isParameterizedType());\n                             ParameterizedType parameterizedAlternate \u003d alternate.toMaybeParameterizedType();\n                             ParameterizedType parameterizedCurrent \u003d current.toMaybeParameterizedType();\n                             if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n-                                JSType alternateTypeParameter \u003d parameterizedAlternate.getParameterType();\n                                 JSType currentTypeParameter \u003d parameterizedCurrent.getParameterType();\n                                 if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n                                     return this;\n                                 } else {\n                                     JSType merged \u003d parameterizedCurrent.getReferencedObjTypeInternal();\n                                     return addAlternate(merged);\n                                 }\n                             }\n                         }\n                     } else if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         removeCurrent \u003d true;\n                     }\n                 }\n                 if (removeCurrent) {\n                     it.remove();\n                     if (currentIndex \u003d\u003d functionTypePosition) {\n                         functionTypePosition \u003d -1;\n                     } else if (currentIndex \u003c functionTypePosition) {\n                         functionTypePosition--;\n                         currentIndex--;\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e14000ea47087087d79dd4e5b7425439c7e5c12a": {
      "type": "Ybodychange",
      "commitMessage": "\nTighten leastSupertype/greatestSubtype relationships for parameterized\ntypes in advance of creating a true subtype relationship between the\ntypes.\n\nR\u003dnicksantos\nDELTA\u003d1898  (1179 added, 275 deleted, 444 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5969\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2393 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/12/12, 11:54 AM",
      "commitName": "e14000ea47087087d79dd4e5b7425439c7e5c12a",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/24/12, 2:07 PM",
      "commitNameOld": "177d001a30c568037141e555d84f9bd28d3d2d86",
      "commitAuthorOld": "izaakr@google.com",
      "daysBetweenCommits": 48.95,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                boolean removeCurrent \u003d false;\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isParameterizedType() || current.isParameterizedType()) {\n                        if (!current.isParameterizedType()) {\n                            if (alternate.isSubtype(current)) {\n                                return this;\n                            }\n                        } else if (!alternate.isParameterizedType()) {\n                            if (current.isSubtype(alternate)) {\n                                removeCurrent \u003d true;\n                            }\n                        } else {\n                            Preconditions.checkState(current.isParameterizedType() \u0026\u0026 alternate.isParameterizedType());\n                            ParameterizedType parameterizedAlternate \u003d alternate.toMaybeParameterizedType();\n                            ParameterizedType parameterizedCurrent \u003d current.toMaybeParameterizedType();\n                            if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n                                JSType alternateTypeParameter \u003d parameterizedAlternate.getParameterType();\n                                JSType currentTypeParameter \u003d parameterizedCurrent.getParameterType();\n                                if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n                                    return this;\n                                } else {\n                                    JSType merged \u003d parameterizedCurrent.getReferencedObjTypeInternal();\n                                    return addAlternate(merged);\n                                }\n                            }\n                        }\n                    } else if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        removeCurrent \u003d true;\n                    }\n                }\n                if (removeCurrent) {\n                    it.remove();\n                    if (currentIndex \u003d\u003d functionTypePosition) {\n                        functionTypePosition \u003d -1;\n                    } else if (currentIndex \u003c functionTypePosition) {\n                        functionTypePosition--;\n                        currentIndex--;\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,62 +1,90 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n+                boolean removeCurrent \u003d false;\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n-                    if (alternate.isSubtype(current)) {\n+                    if (alternate.isParameterizedType() || current.isParameterizedType()) {\n+                        if (!current.isParameterizedType()) {\n+                            if (alternate.isSubtype(current)) {\n+                                return this;\n+                            }\n+                        } else if (!alternate.isParameterizedType()) {\n+                            if (current.isSubtype(alternate)) {\n+                                removeCurrent \u003d true;\n+                            }\n+                        } else {\n+                            Preconditions.checkState(current.isParameterizedType() \u0026\u0026 alternate.isParameterizedType());\n+                            ParameterizedType parameterizedAlternate \u003d alternate.toMaybeParameterizedType();\n+                            ParameterizedType parameterizedCurrent \u003d current.toMaybeParameterizedType();\n+                            if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n+                                JSType alternateTypeParameter \u003d parameterizedAlternate.getParameterType();\n+                                JSType currentTypeParameter \u003d parameterizedCurrent.getParameterType();\n+                                if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n+                                    return this;\n+                                } else {\n+                                    JSType merged \u003d parameterizedCurrent.getReferencedObjTypeInternal();\n+                                    return addAlternate(merged);\n+                                }\n+                            }\n+                        }\n+                    } else if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n-                        it.remove();\n-                        if (currentIndex \u003d\u003d functionTypePosition) {\n-                            functionTypePosition \u003d -1;\n-                        } else if (currentIndex \u003c functionTypePosition) {\n-                            functionTypePosition--;\n-                            currentIndex--;\n-                        }\n+                        removeCurrent \u003d true;\n+                    }\n+                }\n+                if (removeCurrent) {\n+                    it.remove();\n+                    if (currentIndex \u003d\u003d functionTypePosition) {\n+                        functionTypePosition \u003d -1;\n+                    } else if (currentIndex \u003c functionTypePosition) {\n+                        functionTypePosition--;\n+                        currentIndex--;\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "177d001a30c568037141e555d84f9bd28d3d2d86": {
      "type": "Ybodychange",
      "commitMessage": "\nAdds basic support for template keys and templatized types to the base JSType. Array and Object will be converted to this templatized type system.\n\nR\u003ddimvar,nicksantos\nDELTA\u003d324  (225 added, 17 deleted, 82 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5698\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2278 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/24/12, 2:07 PM",
      "commitName": "177d001a30c568037141e555d84f9bd28d3d2d86",
      "commitAuthor": "izaakr@google.com",
      "commitDateOld": "6/7/12, 11:57 AM",
      "commitNameOld": "30a88df811879f5d389f56257c93ab5f740a0518",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 139.09,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,62 +1,62 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n-                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplate() || current.hasAnyTemplate()) {\n+                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplateTypes() || current.hasAnyTemplateTypes()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                         if (currentIndex \u003d\u003d functionTypePosition) {\n                             functionTypePosition \u003d -1;\n                         } else if (currentIndex \u003c functionTypePosition) {\n                             functionTypePosition--;\n                             currentIndex--;\n                         }\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "30a88df811879f5d389f56257c93ab5f740a0518": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t collapse templated types in unions.\n\nR\u003dnicksantos\nDELTA\u003d120  (119 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4967\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2029 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/7/12, 11:57 AM",
      "commitName": "30a88df811879f5d389f56257c93ab5f740a0518",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/23/12, 9:49 AM",
      "commitNameOld": "59aac0b247db74ec7047132f368953935edd81b8",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 15.09,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplate() || current.hasAnyTemplate()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,62 +1,62 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n             int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n-                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n+                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType() || alternate.hasAnyTemplate() || current.hasAnyTemplate()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                         if (currentIndex \u003d\u003d functionTypePosition) {\n                             functionTypePosition \u003d -1;\n                         } else if (currentIndex \u003c functionTypePosition) {\n                             functionTypePosition--;\n                             currentIndex--;\n                         }\n                     }\n                 }\n                 currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59aac0b247db74ec7047132f368953935edd81b8": {
      "type": "Yformatchange",
      "commitMessage": "\n\nMore typos and stuff, fixing bad merge\nFixes issue 734\n\nR\u003dnicksantos\nDELTA\u003d125  (0 added, 0 deleted, 125 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4852\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1992 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/23/12, 9:49 AM",
      "commitName": "59aac0b247db74ec7047132f368953935edd81b8",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/22/12, 5:42 PM",
      "commitNameOld": "465b84d337b9ac732b6890fae3c4deea46bc0fb4",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "465b84d337b9ac732b6890fae3c4deea46bc0fb4": {
      "type": "Yformatchange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nbreaks docs\n\n*** Original change description ***\n\nMore typos and stuff.\nFixes issue 734\n\nDELTA\u003d136  (0 added, 0 deleted, 136 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4846\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1990 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/22/12, 5:42 PM",
      "commitName": "465b84d337b9ac732b6890fae3c4deea46bc0fb4",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/22/12, 4:00 PM",
      "commitNameOld": "6c7c28651eac368f7ff4180abff580114fd0113d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "6c7c28651eac368f7ff4180abff580114fd0113d": {
      "type": "Yformatchange",
      "commitMessage": "\nMore typos and stuff.\nFixes issue 734\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4844\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1988 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/22/12, 4:00 PM",
      "commitName": "6c7c28651eac368f7ff4180abff580114fd0113d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/17/11, 9:08 AM",
      "commitNameOld": "4fe98319ed6ad9110a0722bfb39efacf181bbba1",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 218.29,
      "commitsBetweenForRepo": 407,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "4fe98319ed6ad9110a0722bfb39efacf181bbba1": {
      "type": "Ybodychange",
      "commitMessage": "\nfix up the function type de-duping logic with tests\ni should have written in the first place\n\nR\u003dtylerg\nDELTA\u003d36  (32 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3483\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1516 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/17/11, 9:08 AM",
      "commitName": "4fe98319ed6ad9110a0722bfb39efacf181bbba1",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/6/11, 10:41 AM",
      "commitNameOld": "57ed289a74973e0bc04bd684faf3c4580e0cb812",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 10.94,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int currentIndex \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (currentIndex \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        } else if (currentIndex \u003c functionTypePosition) {\n                            functionTypePosition--;\n                            currentIndex--;\n                        }\n                    }\n                }\n                currentIndex++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 121,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,59 +1,62 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                 FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                 FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                 alternates.set(functionTypePosition, supremum);\n                 result \u003d null;\n                 return this;\n             }\n-            int i \u003d 0;\n+            int currentIndex \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n-                        if (i \u003d\u003d functionTypePosition) {\n+                        if (currentIndex \u003d\u003d functionTypePosition) {\n                             functionTypePosition \u003d -1;\n+                        } else if (currentIndex \u003c functionTypePosition) {\n+                            functionTypePosition--;\n+                            currentIndex--;\n                         }\n                     }\n                 }\n-                i++;\n+                currentIndex++;\n             }\n             if (alternate.isFunctionType()) {\n                 Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                 functionTypePosition \u003d alternates.size();\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "57ed289a74973e0bc04bd684faf3c4580e0cb812": {
      "type": "Ybodychange",
      "commitMessage": "\n\nOriginal change by tylerg on 2011/10/05 14:37:35.\n\nFlesh out the function type lattice a bit better.\nThis is mostly just implementing tylerg\u0027s original suggestion,\nbut with more comments\n\nR\u003dtylerg\nDELTA\u003d135  (53 added, 33 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3421\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1495 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/6/11, 10:41 AM",
      "commitName": "57ed289a74973e0bc04bd684faf3c4580e0cb812",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/27/11, 1:57 PM",
      "commitNameOld": "dc58965f18f524c67556aa4d750cd1d7f5cd1c83",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n                alternates.set(functionTypePosition, supremum);\n                result \u003d null;\n                return this;\n            }\n            int i \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (i \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        }\n                    }\n                }\n                i++;\n            }\n            if (alternate.isFunctionType()) {\n                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n                functionTypePosition \u003d alternates.size();\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,59 +1,59 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n+            if (alternate.isFunctionType() \u0026\u0026 functionTypePosition !\u003d -1) {\n+                FunctionType other \u003d alternates.get(functionTypePosition).toMaybeFunctionType();\n+                FunctionType supremum \u003d alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n+                alternates.set(functionTypePosition, supremum);\n+                result \u003d null;\n+                return this;\n+            }\n             int i \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                         if (i \u003d\u003d functionTypePosition) {\n                             functionTypePosition \u003d -1;\n                         }\n                     }\n                 }\n                 i++;\n             }\n             if (alternate.isFunctionType()) {\n-                if (functionTypePosition \u003d\u003d -1) {\n-                    functionTypePosition \u003d alternates.size();\n-                    alternates.add(alternate);\n-                } else {\n-                    JSType supremum \u003d alternate.toMaybeFunctionType().getLeastSupertype(alternates.get(functionTypePosition).toMaybeFunctionType());\n-                    Preconditions.checkState(supremum.isFunctionType());\n-                    alternates.set(functionTypePosition, supremum);\n-                }\n-            } else {\n-                alternates.add(alternate);\n+                Preconditions.checkState(functionTypePosition \u003d\u003d -1);\n+                functionTypePosition \u003d alternates.size();\n             }\n+            alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc58965f18f524c67556aa4d750cd1d7f5cd1c83": {
      "type": "Ybodychange",
      "commitMessage": "\nOriginal change by tylerg@tylerg-jsdev on 2011/09/22 16:26:04.\nCannibalizes a small piece of tyler\u0027s change, which surfaced\nan ambiguity in the function type lattice. We try to resolve this\nambiguity by normalizing how structural functions are\nhandled in union types.\n\nR\u003dtylerg\nDELTA\u003d137  (132 added, 1 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3359\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1466 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/27/11, 1:57 PM",
      "commitName": "dc58965f18f524c67556aa4d750cd1d7f5cd1c83",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/17/11, 11:43 AM",
      "commitNameOld": "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 41.09,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            int i \u003d 0;\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                        if (i \u003d\u003d functionTypePosition) {\n                            functionTypePosition \u003d -1;\n                        }\n                    }\n                }\n                i++;\n            }\n            if (alternate.isFunctionType()) {\n                if (functionTypePosition \u003d\u003d -1) {\n                    functionTypePosition \u003d alternates.size();\n                    alternates.add(alternate);\n                } else {\n                    JSType supremum \u003d alternate.toMaybeFunctionType().getLeastSupertype(alternates.get(functionTypePosition).toMaybeFunctionType());\n                    Preconditions.checkState(supremum.isFunctionType());\n                    alternates.set(functionTypePosition, supremum);\n                }\n            } else {\n                alternates.add(alternate);\n            }\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 120,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,59 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate.isUnionType()) {\n             UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n+            int i \u003d 0;\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n+                        if (i \u003d\u003d functionTypePosition) {\n+                            functionTypePosition \u003d -1;\n+                        }\n                     }\n                 }\n+                i++;\n             }\n-            alternates.add(alternate);\n+            if (alternate.isFunctionType()) {\n+                if (functionTypePosition \u003d\u003d -1) {\n+                    functionTypePosition \u003d alternates.size();\n+                    alternates.add(alternate);\n+                } else {\n+                    JSType supremum \u003d alternate.toMaybeFunctionType().getLeastSupertype(alternates.get(functionTypePosition).toMaybeFunctionType());\n+                    Preconditions.checkState(supremum.isFunctionType());\n+                    alternates.set(functionTypePosition, supremum);\n+                }\n+            } else {\n+                alternates.add(alternate);\n+            }\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a toUnionType method.\nI think this should be a lot more correct and easier for clients\nto use, because it will resolve typedefs of UnionTypes better.\nI will probably do this for all other instanceof checks if we\nagree that this is the way we want to go.\n\nR\u003djohnlenz\nDELTA\u003d79  (14 added, 7 deleted, 58 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3047\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1362 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/17/11, 11:43 AM",
      "commitName": "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/27/11, 4:17 AM",
      "commitNameOld": "79c373c265c0444e0e1edb014ec4e763689879dc",
      "commitAuthorOld": "henrywong@google.com",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate.isUnionType()) {\n            UnionType union \u003d alternate.toMaybeUnionType();\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 99,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n-        if (alternate instanceof UnionType) {\n-            UnionType union \u003d (UnionType) alternate;\n+        if (alternate.isUnionType()) {\n+            UnionType union \u003d alternate.toMaybeUnionType();\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "79c373c265c0444e0e1edb014ec4e763689879dc": {
      "type": "Ybodychange",
      "commitMessage": "\nAs per email/IM conversations, this CL raises the maximum number of alternate types tracked by the UnionTypeBuilder during property checking. This prevents methods that appear on more than 20 types from always being reported as being a property of ?\n\nR\u003dmoedinger,nicksantos\nDELTA\u003d63  (58 added, 1 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2760\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1293 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/27/11, 4:17 AM",
      "commitName": "79c373c265c0444e0e1edb014ec4e763689879dc",
      "commitAuthor": "henrywong@google.com",
      "commitDateOld": "7/26/11, 3:36 PM",
      "commitNameOld": "c9855bee34deaee86909d3786db294a1341e496a",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e maxUnionSize) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 99,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate instanceof UnionType) {\n             UnionType union \u003d (UnionType) alternate;\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n-            if (alternates.size() \u003e MAX_UNION_SIZE) {\n+            if (alternates.size() \u003e maxUnionSize) {\n                 return this;\n             }\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n                 if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "043a352c2e85815a90a1926d112902d924bab6c1": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen we can\u0027t find a forward-declared type,\nthat type should resolve to an empty type.\nThis ensures that if someone tries to pass a param or return\nvalue to it, they get a type warning.\nTry #3\n!!!\n\nR\u003djohnlenz\nDELTA\u003d534  (451 added, 37 deleted, 46 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d362\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@731 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/26/11, 8:30 AM",
      "commitName": "043a352c2e85815a90a1926d112902d924bab6c1",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/21/11, 1:01 PM",
      "commitNameOld": "5bebea634889ca79649889eaa21205880eb3ad33",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 4.81,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e MAX_UNION_SIZE) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 95,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate instanceof UnionType) {\n             UnionType union \u003d (UnionType) alternate;\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e MAX_UNION_SIZE) {\n                 return this;\n             }\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n-                if (alternate.isUnknownType() || current.isUnknownType()) {\n+                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "11bd742011d67590031dba6e9d1f7186393b38a0": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbreaks contacts\n\n*** Original change description ***\n\nWhen we can\u0027t find a forward-declared type,\nthat type should resolve to an empty type.\nThis ensures that if someone tries to pass a param or return\nvalue to it, they get a type warning.\n\nDELTA\u003d461  (37 added, 385 deleted, 39 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d302\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@703 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/18/11, 5:02 PM",
      "commitName": "11bd742011d67590031dba6e9d1f7186393b38a0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/18/11, 3:28 PM",
      "commitNameOld": "6dbca87c463d8a1e229a0d92d5cdf92247fdefde",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e MAX_UNION_SIZE) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 95,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate instanceof UnionType) {\n             UnionType union \u003d (UnionType) alternate;\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e MAX_UNION_SIZE) {\n                 return this;\n             }\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n-                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n+                if (alternate.isUnknownType() || current.isUnknownType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6dbca87c463d8a1e229a0d92d5cdf92247fdefde": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen we can\u0027t find a forward-declared type,\nthat type should resolve to an empty type.\nThis ensures that if someone tries to pass a param or return\nvalue to it, they get a type warning.\n\nR\u003djohnlenz\nDELTA\u003d461  (385 added, 37 deleted, 39 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d301\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@702 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/18/11, 3:28 PM",
      "commitName": "6dbca87c463d8a1e229a0d92d5cdf92247fdefde",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/13/10, 8:10 AM",
      "commitNameOld": "1c75a5484b515bd593295fbf0c8491e2dd1f1c45",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 36.3,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e MAX_UNION_SIZE) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 95,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,43 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate instanceof UnionType) {\n             UnionType union \u003d (UnionType) alternate;\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n             if (alternates.size() \u003e MAX_UNION_SIZE) {\n                 return this;\n             }\n             Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n             while (it.hasNext()) {\n                 JSType current \u003d it.next();\n-                if (alternate.isUnknownType() || current.isUnknownType()) {\n+                if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) {\n                     if (alternate.isEquivalentTo(current)) {\n                         return this;\n                     }\n                 } else {\n                     if (alternate.isSubtype(current)) {\n                         return this;\n                     } else if (current.isSubtype(alternate)) {\n                         it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/17 by nicksantos\n\n        don\u0027t use Sets to build union types.\n\n        R\u003djohnlenz\n        DELTA\u003d76  (52 added, 6 deleted, 18 changed)\n\nChange on 2010/06/17 by nicksantos\n\n        fix a couple bugs in goog.scope processing\n\n        R\u003drobbyw\n        DELTA\u003d54  (42 added, 11 deleted, 1 changed)\n\n\nChange on 2010/06/17 by acleung\n\n        Disables function argument check with @notypecheck is on for the whole file.\n\n        R\u003djohnlenz\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/06/17 by dcc\n\n        Fix NPE in ExportExternsPass with --check_types\u003dfalse.\n\n        R\u003dacleung\n        DELTA\u003d72  (66 added, 4 deleted, 2 changed)\n\nChange on 2010/06/17 by johnlenz\n\n        Change stub method parameters to allow sanity checks to pass with\n        CrossModuleMethodMotion.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (3 added, 0 deleted, 4 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Modify AliasKeywords so passes the sanity checks: don\u0027t create coding\n        convention constants without annotation them so that the tests pass\n        when the sanity checks are on.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Fix source maps when run with sanity checks.\n\n        R\u003dnicksantos\n        DELTA\u003d10  (7 added, 0 deleted, 3 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Changes to PrepareAst to make it valid to run during SanityChecks.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by nicksantos\n\n        fix constant annotations in CollapseProperties.\n\n        R\u003djohnlenz\n        DELTA\u003d61  (49 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d30002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@246 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/18/10, 5:18 PM",
      "commitName": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/7/10, 11:34 AM",
      "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 72.24,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (alternates.size() \u003e MAX_UNION_SIZE) {\n                return this;\n            }\n            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n            while (it.hasNext()) {\n                JSType current \u003d it.next();\n                if (alternate.isUnknownType() || current.isUnknownType()) {\n                    if (alternate.isEquivalentTo(current)) {\n                        return this;\n                    }\n                } else {\n                    if (alternate.isSubtype(current)) {\n                        return this;\n                    } else if (current.isSubtype(alternate)) {\n                        it.remove();\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 87,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n",
      "diff": "@@ -1,38 +1,43 @@\n UnionTypeBuilder addAlternate(JSType alternate) {\n     if (alternate.isNoType()) {\n         return this;\n     }\n     isAllType \u003d isAllType || alternate.isAllType();\n     boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n     isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n     if (isAlternateUnknown) {\n         areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n     }\n     if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n         if (alternate instanceof UnionType) {\n             UnionType union \u003d (UnionType) alternate;\n             for (JSType unionAlt : union.getAlternates()) {\n                 addAlternate(unionAlt);\n             }\n         } else {\n-            if (!alternate.isUnknownType()) {\n-                Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n-                while (it.hasNext()) {\n-                    JSType current \u003d it.next();\n-                    if (!current.isUnknownType()) {\n-                        if (alternate.isSubtype(current)) {\n-                            return this;\n-                        } else if (current.isSubtype(alternate)) {\n-                            it.remove();\n-                        }\n+            if (alternates.size() \u003e MAX_UNION_SIZE) {\n+                return this;\n+            }\n+            Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n+            while (it.hasNext()) {\n+                JSType current \u003d it.next();\n+                if (alternate.isUnknownType() || current.isUnknownType()) {\n+                    if (alternate.isEquivalentTo(current)) {\n+                        return this;\n+                    }\n+                } else {\n+                    if (alternate.isSubtype(current)) {\n+                        return this;\n+                    } else if (current.isSubtype(alternate)) {\n+                        it.remove();\n                     }\n                 }\n             }\n             alternates.add(alternate);\n             result \u003d null;\n         }\n     } else {\n         result \u003d null;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,38 @@\n+UnionTypeBuilder addAlternate(JSType alternate) {\n+    if (alternate.isNoType()) {\n+        return this;\n+    }\n+    isAllType \u003d isAllType || alternate.isAllType();\n+    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n+    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n+    if (isAlternateUnknown) {\n+        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n+    }\n+    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n+        if (alternate instanceof UnionType) {\n+            UnionType union \u003d (UnionType) alternate;\n+            for (JSType unionAlt : union.getAlternates()) {\n+                addAlternate(unionAlt);\n+            }\n+        } else {\n+            if (!alternate.isUnknownType()) {\n+                Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n+                while (it.hasNext()) {\n+                    JSType current \u003d it.next();\n+                    if (!current.isUnknownType()) {\n+                        if (alternate.isSubtype(current)) {\n+                            return this;\n+                        } else if (current.isSubtype(alternate)) {\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+            }\n+            alternates.add(alternate);\n+            result \u003d null;\n+        }\n+    } else {\n+        result \u003d null;\n+    }\n+    return this;\n+}\n\\ No newline at end of file\n",
      "actualSource": "UnionTypeBuilder addAlternate(JSType alternate) {\n    if (alternate.isNoType()) {\n        return this;\n    }\n    isAllType \u003d isAllType || alternate.isAllType();\n    boolean isAlternateUnknown \u003d alternate instanceof UnknownType;\n    isNativeUnknownType \u003d isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n        areAllUnknownsChecked \u003d areAllUnknownsChecked \u0026\u0026 alternate.isCheckedUnknownType();\n    }\n    if (!isAllType \u0026\u0026 !isNativeUnknownType) {\n        if (alternate instanceof UnionType) {\n            UnionType union \u003d (UnionType) alternate;\n            for (JSType unionAlt : union.getAlternates()) {\n                addAlternate(unionAlt);\n            }\n        } else {\n            if (!alternate.isUnknownType()) {\n                Iterator\u003cJSType\u003e it \u003d alternates.iterator();\n                while (it.hasNext()) {\n                    JSType current \u003d it.next();\n                    if (!current.isUnknownType()) {\n                        if (alternate.isSubtype(current)) {\n                            return this;\n                        } else if (current.isSubtype(alternate)) {\n                            it.remove();\n                        }\n                    }\n                }\n            }\n            alternates.add(alternate);\n            result \u003d null;\n        }\n    } else {\n        result \u003d null;\n    }\n    return this;\n}",
      "path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
      "functionStartLine": 85,
      "functionName": "addAlternate",
      "functionAnnotation": "",
      "functionDoc": "Adds an alternate to the union type under construction. Returns this\nfor easy chaining.\n"
    }
  }
}