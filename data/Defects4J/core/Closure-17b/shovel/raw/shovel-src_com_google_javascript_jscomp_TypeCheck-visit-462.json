{
  "origin": "codeshovel",
  "repositoryName": "Closure-17b",
  "repositoryPath": "/tmp/Closure-17b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "@Override",
  "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
  "functionStartLine": 462,
  "functionEndLine": 810,
  "numCommitsSeen": 80,
  "timeTaken": 7482,
  "changeHistory": [
    "23a670113ef854291ae5e3d7209657d372fefd8e",
    "9f0375c73c77ef134000d980a32f46f6085db042",
    "cd25d5c37ab839090a74c2ed49f924e22de13057",
    "f412f0c0efd54842b30207c845d65cb826217fd6",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37",
    "925a8f78c8c6a407435e6fb4513ad96d617643a3",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "5524adbda991632656059566b69cc2771ba42b7d",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
    "76abdf11394c0e7515ae63335676ea3657badb45",
    "0235adc719d0858653861b8ced39a1d057cf93a0",
    "59a30b48325cccadabae8687fdf603d72e26c157",
    "75aa5f653b08995428743f6951a99ad101e73e37",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "23a670113ef854291ae5e3d7209657d372fefd8e": "Ybodychange",
    "9f0375c73c77ef134000d980a32f46f6085db042": "Ybodychange",
    "cd25d5c37ab839090a74c2ed49f924e22de13057": "Ybodychange",
    "f412f0c0efd54842b30207c845d65cb826217fd6": "Ybodychange",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": "Ybodychange",
    "925a8f78c8c6a407435e6fb4513ad96d617643a3": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "5524adbda991632656059566b69cc2771ba42b7d": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": "Ybodychange",
    "76abdf11394c0e7515ae63335676ea3657badb45": "Yannotationchange",
    "0235adc719d0858653861b8ced39a1d057cf93a0": "Ybodychange",
    "59a30b48325cccadabae8687fdf603d72e26c157": "Ybodychange",
    "75aa5f653b08995428743f6951a99ad101e73e37": "Ybodychange",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": "Ybodychange",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": "Ybodychange",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "23a670113ef854291ae5e3d7209657d372fefd8e": {
      "type": "Ybodychange",
      "commitMessage": "\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\ntry #2, papering over some bugs in the inf() relation on function types\n\nR\u003djohnlenz\nDELTA\u003d100  (72 added, 18 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4938\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2019 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/4/12, 11:45 AM",
      "commitName": "23a670113ef854291ae5e3d7209657d372fefd8e",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/1/12, 3:23 PM",
      "commitNameOld": "9f0375c73c77ef134000d980a32f46f6085db042",
      "commitAuthorOld": "tjblasi@google.com",
      "daysBetweenCommits": 2.85,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n-            {\n-                leftType \u003d getJSType(n.getFirstChild());\n-                rightType \u003d getJSType(n.getLastChild());\n-                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n-                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n-                }\n-                ensureTyped(t, n, BOOLEAN_TYPE);\n-                break;\n-            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                TernaryValue result \u003d TernaryValue.UNKNOWN;\n+                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n+                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                } else {\n+                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n+                    }\n+                }\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f0375c73c77ef134000d980a32f46f6085db042": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback \n\n*** Reason for rollback ***\n\nBreaks some tests\n\n*** Original change description ***\n\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\n\nR\u003djohnlenz\nDELTA\u003d70  (18 added, 42 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4927\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2013 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/1/12, 3:23 PM",
      "commitName": "9f0375c73c77ef134000d980a32f46f6085db042",
      "commitAuthor": "tjblasi@google.com",
      "commitDateOld": "6/1/12, 1:45 PM",
      "commitNameOld": "cd25d5c37ab839090a74c2ed49f924e22de13057",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,265 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d TernaryValue.UNKNOWN;\n-                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n-                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                } else {\n-                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n-                    }\n-                }\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd25d5c37ab839090a74c2ed49f924e22de13057": {
      "type": "Ybodychange",
      "commitMessage": "\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\n\nR\u003djohnlenz\nDELTA\u003d70  (42 added, 18 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4926\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2012 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/1/12, 1:45 PM",
      "commitName": "cd25d5c37ab839090a74c2ed49f924e22de13057",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n-            {\n-                leftType \u003d getJSType(n.getFirstChild());\n-                rightType \u003d getJSType(n.getLastChild());\n-                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n-                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n-                }\n-                ensureTyped(t, n, BOOLEAN_TYPE);\n-                break;\n-            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                TernaryValue result \u003d TernaryValue.UNKNOWN;\n+                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n+                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                } else {\n+                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n+                    }\n+                }\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f412f0c0efd54842b30207c845d65cb826217fd6": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate a separate token for object literal keys.\ni was surprised how easy this was\n\nR\u003dacleung,johnlenz\nDELTA\u003d139  (52 added, 26 deleted, 61 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4618\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1922 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/25/12, 1:34 PM",
      "commitName": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/3/12, 5:11 PM",
      "commitNameOld": "06c4d2f84718b7ad601a1429420d000911192d80",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.85,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n-            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-                ensureTyped(t, n, STRING_TYPE);\n-            } else {\n-                typeable \u003d false;\n-            }\n+            ensureTyped(t, n, STRING_TYPE);\n+            break;\n+        case Token.STRING_KEY:\n+            typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": {
      "type": "Ybodychange",
      "commitMessage": "\nInline NodeUtil.isExpressionNode\n\nR\u003dnicksantos\nDELTA\u003d37  (0 added, 4 deleted, 33 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4037\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1702 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/4/12, 11:53 AM",
      "commitName": "5f8b6f54294ce8b454f78165f5230b3759d11e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/17/11, 10:08 AM",
      "commitNameOld": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 48.07,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n-            typeable \u003d !NodeUtil.isExpressionNode(parent);\n+            typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "925a8f78c8c6a407435e6fb4513ad96d617643a3": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace some straggler \"n.isType() \u003d\u003d Token.XX\" calls.\n\nR\u003dnicksantos\nDELTA\u003d70  (36 added, 6 deleted, 28 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3725\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1601 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/15/11, 5:35 PM",
      "commitName": "925a8f78c8c6a407435e6fb4513ad96d617643a3",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.getType() \u003d\u003d Token.NE) {\n+                    if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n-            if (parent.getType() !\u003d Token.FUNCTION) {\n+            if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5524adbda991632656059566b69cc2771ba42b7d": {
      "type": "Ybodychange",
      "commitMessage": "\nRename a couple of AST nodes:\nDEFAULT becomes DEFAULT_CASE\nLP becomes PARAM_LIST\nGET becomes GETTER_DEF\nSET becomes SETTER_DEF\n\nR\u003dnicksantos\nDELTA\u003d215  (40 added, 5 deleted, 170 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1590 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/11, 4:42 PM",
      "commitName": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 9:57 AM",
      "commitNameOld": "3517e9bad4eceb4aefaa9f3a999ec83f2db33f25",
      "commitAuthorOld": "tylerg@google.com",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n-        case Token.LP:\n+        case Token.PARAM_LIST:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n-        case Token.GET:\n-        case Token.SET:\n+        case Token.GETTER_DEF:\n+        case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/8/11, 12:25 PM",
      "commitNameOld": "9d8201624c22636577d47a40aa03de44363b695b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n-            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n+            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n-                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n+                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n-            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+            if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove unused Token ids.\n\nR\u003dnicksantos\nDELTA\u003d1258  (4 added, 1244 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3647\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1562 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/7/11, 2:21 PM",
      "commitName": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/12/11, 8:07 PM",
      "commitNameOld": "9614c7c0ffe2418359fe91be2a0e61400142237d",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 25.8,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,276 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n-        case Token.REF_SPECIAL:\n-            ensureTyped(t, n);\n-            break;\n-        case Token.GET_REF:\n-            ensureTyped(t, n, getJSType(n.getFirstChild()));\n-            break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76abdf11394c0e7515ae63335676ea3657badb45": {
      "type": "Yannotationchange",
      "commitMessage": "\nMake our build warnings free.\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2830\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1301 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 4:19 PM",
      "commitName": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/9/11, 12:01 PM",
      "commitNameOld": "0235adc719d0858653861b8ced39a1d057cf93a0",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 49.18,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 464,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,275 +1,276 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "0235adc719d0858653861b8ced39a1d057cf93a0": {
      "type": "Ybodychange",
      "commitMessage": "\nMake DELPROP of a non-reference a parser error\n\nR\u003dacleung\nDELTA\u003d73  (30 added, 39 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2230\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1169 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/9/11, 12:01 PM",
      "commitName": "0235adc719d0858653861b8ced39a1d057cf93a0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/8/11, 1:18 PM",
      "commitNameOld": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,275 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n-            if (!isReference(n.getFirstChild())) {\n-                report(t, n, BAD_DELETE);\n-            }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59a30b48325cccadabae8687fdf603d72e26c157": {
      "type": "Ybodychange",
      "commitMessage": "\nFixes Issue 482\nIn percent typed counting, ignore the nodes of Enum elements\n\nR\u003dacleung\nDELTA\u003d13  (13 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2202\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/8/11, 1:18 PM",
      "commitName": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/31/11, 8:14 AM",
      "commitNameOld": "63df133d0850805818d1e280ba47dcefc9763c89",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,276 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75aa5f653b08995428743f6951a99ad101e73e37": {
      "type": "Ybodychange",
      "commitMessage": "\nCleanup obsolete handling of NUMBER keys of OBJECTLIT.\n\nR\u003dnicksantos\nDELTA\u003d109  (3 added, 48 deleted, 58 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1253\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@967 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/11, 2:40 PM",
      "commitName": "75aa5f653b08995428743f6951a99ad101e73e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/23/11, 3:36 PM",
      "commitNameOld": "fdce3fde269834d9907127955701fc6d783fb3bc",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 439,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,276 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-                ensureTyped(t, n, NUMBER_TYPE);\n-            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic getters and setters support to TypeInference.\n\nR\u003dnicksantos\nDELTA\u003d573  (533 added, 15 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d366\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@735 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/11, 10:33 AM",
      "commitName": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/26/11, 8:30 AM",
      "commitNameOld": "043a352c2e85815a90a1926d112902d924bab6c1",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            }\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n-            } else {\n-                typeable \u003d false;\n             }\n             break;\n+        case Token.STRING:\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            }\n+            break;\n+        case Token.GET:\n+        case Token.SET:\n+            break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n-        case Token.STRING:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n-                ensureTyped(t, n, STRING_TYPE);\n-            } else {\n-                typeable \u003d false;\n-            }\n-            break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key : n.children()) {\n+                    visitObjLitKey(t, key, n);\n+                }\n+            }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": {
      "type": "Ybodychange",
      "commitMessage": "\nFlag null pointer exceptions that are provable at compile time.\n\nR\u003djohnlenz\nDELTA\u003d48  (38 added, 0 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d236\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@682 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/10/11, 12:54 PM",
      "commitName": "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/2/10, 12:04 PM",
      "commitNameOld": "a83c4868dbc0f3229d31af5ff1b8554c44908459",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n-                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n-                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/06/16 by johnlenz\n\n        Remove unused member variable.\n\n        R\u003dacleung\n        DELTA\u003d17  (0 added, 12 deleted, 5 changed)\n\nChange on 2010/06/16 by acleung\n\n        Make @notypecheck behaves like it is doing typechecking except for reporting errors.\n\n        R\u003djohnlenz\n        DELTA\u003d144  (89 added, 17 deleted, 38 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d28012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@245 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/17/10, 10:16 AM",
      "commitName": "0895c28861ee4a1969acc858f1a703ab11ddc64c",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/3/10, 7:03 AM",
      "commitNameOld": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 45.13,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 444,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n-                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n-                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n-                t.report(n, BAD_DELETE);\n+                report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n-            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n+    checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/30/10, 9:01 PM",
      "commitNameOld": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,272 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n-        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": {
      "type": "Ybodychange",
      "commitMessage": "Refactor how coding conventions are set (Nick)\nR\u003dalan\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves\nthe correctness of the compiler as many passes don\u0027t distinguish\nbetween label names and variable names appropriately. (John)\nR\u003drobert\nDELTA\u003d57  (29 added, 12 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@163 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/10, 9:01 PM",
      "commitName": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,272 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    JSType childType;\n+    JSType leftType, rightType;\n+    Node left, right;\n+    boolean typeable \u003d true;\n+    switch(n.getType()) {\n+        case Token.NAME:\n+            typeable \u003d visitName(t, n, parent);\n+            break;\n+        case Token.LP:\n+            if (parent.getType() !\u003d Token.FUNCTION) {\n+                ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.COMMA:\n+            ensureTyped(t, n, getJSType(n.getLastChild()));\n+            break;\n+        case Token.TRUE:\n+        case Token.FALSE:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.THIS:\n+            ensureTyped(t, n, t.getScope().getTypeOfThis());\n+            break;\n+        case Token.REF_SPECIAL:\n+            ensureTyped(t, n);\n+            break;\n+        case Token.GET_REF:\n+            ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            break;\n+        case Token.NULL:\n+            ensureTyped(t, n, NULL_TYPE);\n+            break;\n+        case Token.NUMBER:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, NUMBER_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.ARRAYLIT:\n+            ensureTyped(t, n, ARRAY_TYPE);\n+            break;\n+        case Token.STRING:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.REGEXP:\n+            ensureTyped(t, n, REGEXP_TYPE);\n+            break;\n+        case Token.GETPROP:\n+            visitGetProp(t, n, parent);\n+            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n+            break;\n+        case Token.GETELEM:\n+            visitGetElem(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.VAR:\n+            visitVar(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.NEW:\n+            visitNew(t, n);\n+            typeable \u003d true;\n+            break;\n+        case Token.CALL:\n+            visitCall(t, n);\n+            typeable \u003d !NodeUtil.isExpressionNode(parent);\n+            break;\n+        case Token.RETURN:\n+            visitReturn(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.DEC:\n+        case Token.INC:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.NOT:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.VOID:\n+            ensureTyped(t, n, VOID_TYPE);\n+            break;\n+        case Token.TYPEOF:\n+            ensureTyped(t, n, STRING_TYPE);\n+            break;\n+        case Token.BITNOT:\n+            childType \u003d getJSType(n.getFirstChild());\n+            if (!childType.matchesInt32Context()) {\n+                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.POS:\n+        case Token.NEG:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.EQ:\n+        case Token.NE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    if (n.getType() \u003d\u003d Token.NE) {\n+                        result \u003d result.not();\n+                    }\n+                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.SHEQ:\n+        case Token.SHNE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.LT:\n+        case Token.LE:\n+        case Token.GT:\n+        case Token.GE:\n+            leftType \u003d getJSType(n.getFirstChild());\n+            rightType \u003d getJSType(n.getLastChild());\n+            if (rightType.isNumber()) {\n+                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n+            } else if (leftType.isNumber()) {\n+                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n+            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n+            } else {\n+                String message \u003d \"left side of comparison\";\n+                validator.expectString(t, n, leftType, message);\n+                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                message \u003d \"right side of comparison\";\n+                validator.expectString(t, n, rightType, message);\n+                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.IN:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right);\n+            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n+            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.INSTANCEOF:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n+            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n+            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.ASSIGN:\n+            visitAssign(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.ASSIGN_LSH:\n+        case Token.ASSIGN_RSH:\n+        case Token.ASSIGN_URSH:\n+        case Token.ASSIGN_DIV:\n+        case Token.ASSIGN_MOD:\n+        case Token.ASSIGN_BITOR:\n+        case Token.ASSIGN_BITXOR:\n+        case Token.ASSIGN_BITAND:\n+        case Token.ASSIGN_SUB:\n+        case Token.ASSIGN_ADD:\n+        case Token.ASSIGN_MUL:\n+        case Token.LSH:\n+        case Token.RSH:\n+        case Token.URSH:\n+        case Token.DIV:\n+        case Token.MOD:\n+        case Token.BITOR:\n+        case Token.BITXOR:\n+        case Token.BITAND:\n+        case Token.SUB:\n+        case Token.ADD:\n+        case Token.MUL:\n+            visitBinaryOperator(n.getType(), t, n);\n+            break;\n+        case Token.DELPROP:\n+            if (!isReference(n.getFirstChild())) {\n+                t.report(n, BAD_DELETE);\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.CASE:\n+            JSType switchType \u003d getJSType(parent.getFirstChild());\n+            JSType caseType \u003d getJSType(n.getFirstChild());\n+            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n+            typeable \u003d false;\n+            break;\n+        case Token.WITH:\n+            {\n+                Node child \u003d n.getFirstChild();\n+                childType \u003d getJSType(child);\n+                validator.expectObject(t, child, childType, \"with requires an object\");\n+                typeable \u003d false;\n+                break;\n+            }\n+        case Token.FUNCTION:\n+            visitFunction(t, n);\n+            break;\n+        case Token.LABEL:\n+        case Token.SWITCH:\n+        case Token.BREAK:\n+        case Token.CATCH:\n+        case Token.TRY:\n+        case Token.SCRIPT:\n+        case Token.EXPR_RESULT:\n+        case Token.BLOCK:\n+        case Token.EMPTY:\n+        case Token.DEFAULT:\n+        case Token.CONTINUE:\n+        case Token.DEBUGGER:\n+        case Token.THROW:\n+            typeable \u003d false;\n+            break;\n+        case Token.DO:\n+        case Token.FOR:\n+        case Token.IF:\n+        case Token.WHILE:\n+            typeable \u003d false;\n+            break;\n+        case Token.AND:\n+        case Token.HOOK:\n+        case Token.OBJECTLIT:\n+        case Token.OR:\n+            if (n.getJSType() !\u003d null) {\n+                ensureTyped(t, n);\n+            } else {\n+                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n+                    ensureTyped(t, n, parent.getJSType());\n+                } else {\n+                    ensureTyped(t, n);\n+                }\n+            }\n+            break;\n+        default:\n+            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            ensureTyped(t, n);\n+            break;\n+    }\n+    typeable \u003d typeable \u0026\u0026 !inExterns;\n+    if (typeable) {\n+        doPercentTypedAccounting(t, n);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 408,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n"
    }
  }
}