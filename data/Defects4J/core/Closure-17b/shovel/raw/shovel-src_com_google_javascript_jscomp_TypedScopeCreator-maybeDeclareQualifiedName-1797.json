{
  "origin": "codeshovel",
  "repositoryName": "Closure-17b",
  "repositoryPath": "/tmp/Closure-17b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "maybeDeclareQualifiedName",
  "functionId": "$maybeDeclareQualifiedName___t-NodeTraversal__info-JSDocInfo__n-Node__parent-Node__rhsValue-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 1797,
  "functionEndLine": 1802,
  "numCommitsSeen": 98,
  "timeTaken": 7254,
  "changeHistory": [
    "bf8fc4533884f914182f861576808e71c18410cc",
    "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
    "41abf3b75893403d9e21c33d06e8dc233b5cf657",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
    "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
    "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "bf8fc4533884f914182f861576808e71c18410cc": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
    "07dd3707c1a61ff21de3f7a7f15585bbb5f70573": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
    "41abf3b75893403d9e21c33d06e8dc233b5cf657": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": "Ybodychange",
    "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd": "Ybodychange",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": "Ybodychange",
    "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bf8fc4533884f914182f861576808e71c18410cc": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61.\nTry #2\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215716\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@424 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/13/10, 5:41 PM",
      "commitName": "bf8fc4533884f914182f861576808e71c18410cc",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61.\nTry #2\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215716\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@424 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 5:41 PM",
          "commitName": "bf8fc4533884f914182f861576808e71c18410cc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 1:29 PM",
          "commitNameOld": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61.\nTry #2\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215716\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@424 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 5:41 PM",
          "commitName": "bf8fc4533884f914182f861576808e71c18410cc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 1:29 PM",
          "commitNameOld": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61.\nTry #2\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215716\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@424 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 5:41 PM",
          "commitName": "bf8fc4533884f914182f861576808e71c18410cc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 1:29 PM",
          "commitNameOld": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61.\nTry #2\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215716\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@424 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 5:41 PM",
          "commitName": "bf8fc4533884f914182f861576808e71c18410cc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 1:29 PM",
          "commitNameOld": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
            "newValue": ""
          }
        }
      ]
    },
    "07dd3707c1a61ff21de3f7a7f15585bbb5f70573": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nmay be causing gmail issue, but not sure. rolling back to be safe.\n\n*** Original change description ***\n\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nDELTA\u003d507  (218 added, 257 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d214753\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@423 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/13/10, 1:29 PM",
      "commitName": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nmay be causing gmail issue, but not sure. rolling back to be safe.\n\n*** Original change description ***\n\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nDELTA\u003d507  (218 added, 257 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d214753\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@423 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 1:29 PM",
          "commitName": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 12:20 PM",
          "commitNameOld": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1150,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "",
          "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,5 +1,53 @@\n-@Override\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    checkForTypedef(t, n, info);\n-    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    Node ownerNode \u003d n.getFirstChild();\n+    String ownerName \u003d ownerNode.getQualifiedName();\n+    String qName \u003d n.getQualifiedName();\n+    String propName \u003d n.getLastChild().getString();\n+    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+    if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+            if (!qVar.isTypeInferred()) {\n+                return;\n+            }\n+            scope.undeclare(qVar);\n+        }\n+    }\n+    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        valueType \u003d rhsValue.getJSType();\n+    }\n+    if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n+        }\n+        return;\n+    }\n+    boolean inferred \u003d true;\n+    if (info !\u003d null) {\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+    }\n+    if (inferred) {\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n+    }\n+    if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+            boolean isExtern \u003d t.getInput().isExtern();\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n+                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            }\n+        }\n+        defineSlot(n, parent, valueType, inferred);\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n+            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nmay be causing gmail issue, but not sure. rolling back to be safe.\n\n*** Original change description ***\n\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nDELTA\u003d507  (218 added, 257 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d214753\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@423 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 1:29 PM",
          "commitName": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 12:20 PM",
          "commitNameOld": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1150,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "",
          "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,5 +1,53 @@\n-@Override\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    checkForTypedef(t, n, info);\n-    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    Node ownerNode \u003d n.getFirstChild();\n+    String ownerName \u003d ownerNode.getQualifiedName();\n+    String qName \u003d n.getQualifiedName();\n+    String propName \u003d n.getLastChild().getString();\n+    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+    if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+            if (!qVar.isTypeInferred()) {\n+                return;\n+            }\n+            scope.undeclare(qVar);\n+        }\n+    }\n+    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        valueType \u003d rhsValue.getJSType();\n+    }\n+    if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n+        }\n+        return;\n+    }\n+    boolean inferred \u003d true;\n+    if (info !\u003d null) {\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+    }\n+    if (inferred) {\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n+    }\n+    if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+            boolean isExtern \u003d t.getInput().isExtern();\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n+                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            }\n+        }\n+        defineSlot(n, parent, valueType, inferred);\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n+            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nmay be causing gmail issue, but not sure. rolling back to be safe.\n\n*** Original change description ***\n\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nDELTA\u003d507  (218 added, 257 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d214753\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@423 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 1:29 PM",
          "commitName": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 12:20 PM",
          "commitNameOld": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1150,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "",
          "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,5 +1,53 @@\n-@Override\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    checkForTypedef(t, n, info);\n-    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    Node ownerNode \u003d n.getFirstChild();\n+    String ownerName \u003d ownerNode.getQualifiedName();\n+    String qName \u003d n.getQualifiedName();\n+    String propName \u003d n.getLastChild().getString();\n+    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+    if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+            if (!qVar.isTypeInferred()) {\n+                return;\n+            }\n+            scope.undeclare(qVar);\n+        }\n+    }\n+    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        valueType \u003d rhsValue.getJSType();\n+    }\n+    if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n+        }\n+        return;\n+    }\n+    boolean inferred \u003d true;\n+    if (info !\u003d null) {\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+    }\n+    if (inferred) {\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n+    }\n+    if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+            boolean isExtern \u003d t.getInput().isExtern();\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n+                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            }\n+        }\n+        defineSlot(n, parent, valueType, inferred);\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n+            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": ""
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nmay be causing gmail issue, but not sure. rolling back to be safe.\n\n*** Original change description ***\n\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nDELTA\u003d507  (218 added, 257 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d214753\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@423 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 1:29 PM",
          "commitName": "07dd3707c1a61ff21de3f7a7f15585bbb5f70573",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 12:20 PM",
          "commitNameOld": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1150,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "",
          "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,5 +1,53 @@\n-@Override\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    checkForTypedef(t, n, info);\n-    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    Node ownerNode \u003d n.getFirstChild();\n+    String ownerName \u003d ownerNode.getQualifiedName();\n+    String qName \u003d n.getQualifiedName();\n+    String propName \u003d n.getLastChild().getString();\n+    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+    if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+            if (!qVar.isTypeInferred()) {\n+                return;\n+            }\n+            scope.undeclare(qVar);\n+        }\n+    }\n+    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        valueType \u003d rhsValue.getJSType();\n+    }\n+    if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n+        }\n+        return;\n+    }\n+    boolean inferred \u003d true;\n+    if (info !\u003d null) {\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+    }\n+    if (inferred) {\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n+    }\n+    if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+            boolean isExtern \u003d t.getInput().isExtern();\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n+                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            }\n+        }\n+        defineSlot(n, parent, valueType, inferred);\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n+            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n"
          }
        }
      ]
    },
    "41abf3b75893403d9e21c33d06e8dc233b5cf657": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215715\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@422 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/13/10, 12:20 PM",
      "commitName": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215715\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@422 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 12:20 PM",
          "commitName": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 7:29 AM",
          "commitNameOld": "0a40e6661cd197e1cd0d3a3bccaa4c5313df8514",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215715\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@422 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 12:20 PM",
          "commitName": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 7:29 AM",
          "commitNameOld": "0a40e6661cd197e1cd0d3a3bccaa4c5313df8514",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215715\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@422 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 12:20 PM",
          "commitName": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 7:29 AM",
          "commitNameOld": "0a40e6661cd197e1cd0d3a3bccaa4c5313df8514",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nUnify global scope building and local scope building.\nThis goes a long way towards fixing issue 61\n\nR\u003djohnlenz\nDELTA\u003d492  (242 added, 203 deleted, 47 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d215715\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@422 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/13/10, 12:20 PM",
          "commitName": "41abf3b75893403d9e21c33d06e8dc233b5cf657",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/13/10, 7:29 AM",
          "commitNameOld": "0a40e6661cd197e1cd0d3a3bccaa4c5313df8514",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    checkForTypedef(t, n, info);\n    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1338,
          "functionName": "maybeDeclareQualifiedName",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,5 @@\n-private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode \u003d n.getFirstChild();\n-    String ownerName \u003d ownerNode.getQualifiedName();\n-    String qName \u003d n.getQualifiedName();\n-    String propName \u003d n.getLastChild().getString();\n-    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar \u003d scope.getVar(qName);\n-        if (qVar !\u003d null) {\n-            if (!qVar.isTypeInferred()) {\n-                return;\n-            }\n-            scope.undeclare(qVar);\n-        }\n-    }\n-    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n-    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n-        valueType \u003d rhsValue.getJSType();\n-    }\n-    if (valueType \u003d\u003d null) {\n-        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred \u003d true;\n-    if (info !\u003d null) {\n-        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType !\u003d null) {\n-            boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n-            }\n-        }\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-        ObjectType ownerType \u003d getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+@Override\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    checkForTypedef(t, n, info);\n+    super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
            "newValue": ""
          }
        }
      ]
    },
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": {
      "type": "Ybodychange",
      "commitMessage": "\nAttach types to literals at scope-creation time instead of at\ninference time.\nScope-creation already attaches types to function literals at\nscope-creation type, so this makes the other literals more consistent\nwith function literals.\n\nR\u003djohnlenz\nDELTA\u003d167  (102 added, 53 deleted, 12 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209649\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@411 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 12:26 PM",
      "commitName": "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/19/10, 5:30 PM",
      "commitNameOld": "e8eafe7acfd53e5385e4f31692c4db67c3777185",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 50.79,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1148,
      "functionName": "maybeDeclareQualifiedName",
      "functionAnnotation": "",
      "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,53 +1,53 @@\n private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n     Node ownerNode \u003d n.getFirstChild();\n     String ownerName \u003d ownerNode.getQualifiedName();\n     String qName \u003d n.getQualifiedName();\n     String propName \u003d n.getLastChild().getString();\n     Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n     if (\"prototype\".equals(propName)) {\n         Var qVar \u003d scope.getVar(qName);\n         if (qVar !\u003d null) {\n             if (!qVar.isTypeInferred()) {\n                 return;\n             }\n             scope.undeclare(qVar);\n         }\n     }\n     JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n     if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n         valueType \u003d rhsValue.getJSType();\n     }\n     if (valueType \u003d\u003d null) {\n         if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n             stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n-        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n-            ObjectType ownerType \u003d getObjectSlot(ownerName);\n-            if (ownerType instanceof FunctionType) {\n-                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-                String delegateName \u003d codingConvention.getDelegateSuperclassName();\n-                JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n-                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n-                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n-                }\n-            }\n         }\n         return;\n     }\n     boolean inferred \u003d true;\n     if (info !\u003d null) {\n         inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred) {\n         inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n     }\n     if (!inferred) {\n         ObjectType ownerType \u003d getObjectSlot(ownerName);\n         if (ownerType !\u003d null) {\n             boolean isExtern \u003d t.getInput().isExtern();\n             if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n             }\n         }\n         defineSlot(n, parent, valueType, inferred);\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+            JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+            String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+            JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n+            if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd": {
      "type": "Ybodychange",
      "commitMessage": "Add more unit tests for type checking.\n\nAdd phase optimization.\n\nFix a type inference bug.\n\nString.prototype.split may not return null.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@55 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/4/10, 12:18 PM",
      "commitName": "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/15/09, 1:52 PM",
      "commitNameOld": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 19.93,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            if (ownerType instanceof FunctionType) {\n                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                String delegateName \u003d codingConvention.getDelegateSuperclassName();\n                JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                }\n            }\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 965,
      "functionName": "maybeDeclareQualifiedName",
      "functionAnnotation": "",
      "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,53 +1,53 @@\n private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n     Node ownerNode \u003d n.getFirstChild();\n     String ownerName \u003d ownerNode.getQualifiedName();\n     String qName \u003d n.getQualifiedName();\n     String propName \u003d n.getLastChild().getString();\n     Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n     if (\"prototype\".equals(propName)) {\n         Var qVar \u003d scope.getVar(qName);\n         if (qVar !\u003d null) {\n             if (!qVar.isTypeInferred()) {\n                 return;\n             }\n             scope.undeclare(qVar);\n         }\n     }\n     JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n     if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n         valueType \u003d rhsValue.getJSType();\n     }\n     if (valueType \u003d\u003d null) {\n         if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n             stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n         } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n             ObjectType ownerType \u003d getObjectSlot(ownerName);\n             if (ownerType instanceof FunctionType) {\n                 JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                 String delegateName \u003d codingConvention.getDelegateSuperclassName();\n                 JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                 if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                     defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                 }\n             }\n         }\n         return;\n     }\n     boolean inferred \u003d true;\n     if (info !\u003d null) {\n         inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred) {\n         inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n     }\n     if (!inferred) {\n         ObjectType ownerType \u003d getObjectSlot(ownerName);\n         if (ownerType !\u003d null) {\n             boolean isExtern \u003d t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 ((isExtern \u0026\u0026 !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n             }\n         }\n         defineSlot(n, parent, valueType, inferred);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": {
      "type": "Ybodychange",
      "commitMessage": "Better number printing.\nAdd flags for fine-grained warning controls.\nBetter type-declaration finding.\nAdded some missing externs.\nMarked externs that don\u0027t have side effects.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@10 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/13/09, 11:38 AM",
      "commitName": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/6/09, 5:24 PM",
      "commitNameOld": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 6.76,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            if (ownerType instanceof FunctionType) {\n                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                String delegateName \u003d codingConvention.getDelegateSuperclassName();\n                JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                }\n            }\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 971,
      "functionName": "maybeDeclareQualifiedName",
      "functionAnnotation": "",
      "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,64 +1,53 @@\n private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n     Node ownerNode \u003d n.getFirstChild();\n     String ownerName \u003d ownerNode.getQualifiedName();\n     String qName \u003d n.getQualifiedName();\n     String propName \u003d n.getLastChild().getString();\n     Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n     if (\"prototype\".equals(propName)) {\n         Var qVar \u003d scope.getVar(qName);\n         if (qVar !\u003d null) {\n             if (!qVar.isTypeInferred()) {\n                 return;\n             }\n             scope.undeclare(qVar);\n         }\n     }\n     JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n     if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n         valueType \u003d rhsValue.getJSType();\n     }\n     if (valueType \u003d\u003d null) {\n         if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-            ObjectType ownerType \u003d getObjectSlot(ownerName);\n-            JSType unknownType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n-            if (ownerType \u003d\u003d null) {\n-                defineSlot(n, parent, unknownType, false);\n-            } else {\n-                boolean isExtern \u003d t.getInput().isExtern();\n-                if (isExtern || ownerType.isFunctionPrototypeType()) {\n-                    ownerType.defineDeclaredProperty(propName, unknownType, isExtern);\n-                } else {\n-                    typeRegistry.registerPropertyOnType(propName, ownerType);\n-                }\n-            }\n+            stubDeclarations.add(new StubDeclaration(n, t.getInput().isExtern(), ownerName));\n         } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n             ObjectType ownerType \u003d getObjectSlot(ownerName);\n             if (ownerType instanceof FunctionType) {\n                 JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                 String delegateName \u003d codingConvention.getDelegateSuperclassName();\n                 JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                 if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                     defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                 }\n             }\n         }\n         return;\n     }\n     boolean inferred \u003d true;\n     if (info !\u003d null) {\n         inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred) {\n         inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n     }\n     if (!inferred) {\n         ObjectType ownerType \u003d getObjectSlot(ownerName);\n         if (ownerType !\u003d null) {\n             boolean isExtern \u003d t.getInput().isExtern();\n             if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n             }\n         }\n         defineSlot(n, parent, valueType, inferred);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0": {
      "type": "Ybodychange",
      "commitMessage": "A bunch of bug fixes\nAdded the --warning_level\u003d{QUIET|DEFAULT|VERBOSE} flag,\nto match the webservice API\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@3 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/6/09, 5:24 PM",
      "commitName": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            JSType unknownType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n            if (ownerType \u003d\u003d null) {\n                defineSlot(n, parent, unknownType, false);\n            } else {\n                boolean isExtern \u003d t.getInput().isExtern();\n                if (isExtern || ownerType.isFunctionPrototypeType()) {\n                    ownerType.defineDeclaredProperty(propName, unknownType, isExtern);\n                } else {\n                    typeRegistry.registerPropertyOnType(propName, ownerType);\n                }\n            }\n        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            if (ownerType instanceof FunctionType) {\n                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                String delegateName \u003d codingConvention.getDelegateSuperclassName();\n                JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                }\n            }\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 961,
      "functionName": "maybeDeclareQualifiedName",
      "functionAnnotation": "",
      "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,63 +1,64 @@\n private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n     Node ownerNode \u003d n.getFirstChild();\n     String ownerName \u003d ownerNode.getQualifiedName();\n     String qName \u003d n.getQualifiedName();\n     String propName \u003d n.getLastChild().getString();\n     Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n     if (\"prototype\".equals(propName)) {\n         Var qVar \u003d scope.getVar(qName);\n         if (qVar !\u003d null) {\n             if (!qVar.isTypeInferred()) {\n                 return;\n             }\n             scope.undeclare(qVar);\n         }\n     }\n     JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n     if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n         valueType \u003d rhsValue.getJSType();\n     }\n     if (valueType \u003d\u003d null) {\n         if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n             ObjectType ownerType \u003d getObjectSlot(ownerName);\n             JSType unknownType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n             if (ownerType \u003d\u003d null) {\n                 defineSlot(n, parent, unknownType, false);\n             } else {\n                 boolean isExtern \u003d t.getInput().isExtern();\n                 if (isExtern || ownerType.isFunctionPrototypeType()) {\n                     ownerType.defineDeclaredProperty(propName, unknownType, isExtern);\n                 } else {\n                     typeRegistry.registerPropertyOnType(propName, ownerType);\n                 }\n             }\n         } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n             ObjectType ownerType \u003d getObjectSlot(ownerName);\n             if (ownerType instanceof FunctionType) {\n                 JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n-                JSType delegateType \u003d typeRegistry.getType(codingConvention.getDelegateSuperclassName());\n+                String delegateName \u003d codingConvention.getDelegateSuperclassName();\n+                JSType delegateType \u003d delegateName \u003d\u003d null ? null : typeRegistry.getType(delegateName);\n                 if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                     defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                 }\n             }\n         }\n         return;\n     }\n     boolean inferred \u003d true;\n     if (info !\u003d null) {\n         inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n     }\n     if (inferred) {\n         inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n     }\n     if (!inferred) {\n         ObjectType ownerType \u003d getObjectSlot(ownerName);\n         if (ownerType !\u003d null) {\n             boolean isExtern \u003d t.getInput().isExtern();\n             if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n                 ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n             }\n         }\n         defineSlot(n, parent, valueType, inferred);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,63 @@\n+private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+    Node ownerNode \u003d n.getFirstChild();\n+    String ownerName \u003d ownerNode.getQualifiedName();\n+    String qName \u003d n.getQualifiedName();\n+    String propName \u003d n.getLastChild().getString();\n+    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n+    if (\"prototype\".equals(propName)) {\n+        Var qVar \u003d scope.getVar(qName);\n+        if (qVar !\u003d null) {\n+            if (!qVar.isTypeInferred()) {\n+                return;\n+            }\n+            scope.undeclare(qVar);\n+        }\n+    }\n+    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n+    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n+        valueType \u003d rhsValue.getJSType();\n+    }\n+    if (valueType \u003d\u003d null) {\n+        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+            ObjectType ownerType \u003d getObjectSlot(ownerName);\n+            JSType unknownType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n+            if (ownerType \u003d\u003d null) {\n+                defineSlot(n, parent, unknownType, false);\n+            } else {\n+                boolean isExtern \u003d t.getInput().isExtern();\n+                if (isExtern || ownerType.isFunctionPrototypeType()) {\n+                    ownerType.defineDeclaredProperty(propName, unknownType, isExtern);\n+                } else {\n+                    typeRegistry.registerPropertyOnType(propName, ownerType);\n+                }\n+            }\n+        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n+            ObjectType ownerType \u003d getObjectSlot(ownerName);\n+            if (ownerType instanceof FunctionType) {\n+                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n+                JSType delegateType \u003d typeRegistry.getType(codingConvention.getDelegateSuperclassName());\n+                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n+                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+    boolean inferred \u003d true;\n+    if (info !\u003d null) {\n+        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+    }\n+    if (inferred) {\n+        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n+    }\n+    if (!inferred) {\n+        ObjectType ownerType \u003d getObjectSlot(ownerName);\n+        if (ownerType !\u003d null) {\n+            boolean isExtern \u003d t.getInput().isExtern();\n+            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n+                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            }\n+        }\n+        defineSlot(n, parent, valueType, inferred);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode \u003d n.getFirstChild();\n    String ownerName \u003d ownerNode.getQualifiedName();\n    String qName \u003d n.getQualifiedName();\n    String propName \u003d n.getLastChild().getString();\n    Preconditions.checkArgument(qName !\u003d null \u0026\u0026 ownerName !\u003d null);\n    if (\"prototype\".equals(propName)) {\n        Var qVar \u003d scope.getVar(qName);\n        if (qVar !\u003d null) {\n            if (!qVar.isTypeInferred()) {\n                return;\n            }\n            scope.undeclare(qVar);\n        }\n    }\n    JSType valueType \u003d getDeclaredGetPropType(t, info, n, rhsValue);\n    if (valueType \u003d\u003d null \u0026\u0026 rhsValue !\u003d null) {\n        valueType \u003d rhsValue.getJSType();\n    }\n    if (valueType \u003d\u003d null) {\n        if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            JSType unknownType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n            if (ownerType \u003d\u003d null) {\n                defineSlot(n, parent, unknownType, false);\n            } else {\n                boolean isExtern \u003d t.getInput().isExtern();\n                if (isExtern || ownerType.isFunctionPrototypeType()) {\n                    ownerType.defineDeclaredProperty(propName, unknownType, isExtern);\n                } else {\n                    typeRegistry.registerPropertyOnType(propName, ownerType);\n                }\n            }\n        } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.TRUE) {\n            ObjectType ownerType \u003d getObjectSlot(ownerName);\n            if (ownerType instanceof FunctionType) {\n                JSType ownerTypeOfThis \u003d ((FunctionType) ownerType).getTypeOfThis();\n                JSType delegateType \u003d typeRegistry.getType(codingConvention.getDelegateSuperclassName());\n                if (delegateType !\u003d null \u0026\u0026 ownerTypeOfThis.isSubtype(delegateType)) {\n                    defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE), true);\n                }\n            }\n        }\n        return;\n    }\n    boolean inferred \u003d true;\n    if (info !\u003d null) {\n        inferred \u003d !(info.hasType() || info.hasEnumParameterType() || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        inferred \u003d !(rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 !scope.isDeclared(qName, false));\n    }\n    if (!inferred) {\n        ObjectType ownerType \u003d getObjectSlot(ownerName);\n        if (ownerType !\u003d null) {\n            boolean isExtern \u003d t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \u0026\u0026 (isExtern || !ownerType.isInstanceType())) {\n                ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n            }\n        }\n        defineSlot(n, parent, valueType, inferred);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 961,
      "functionName": "maybeDeclareQualifiedName",
      "functionAnnotation": "",
      "functionDoc": "Declare the symbol for a qualified name in the global scope.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param parent The parent of {@code n}.\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n"
    }
  }
}