{
  "origin": "codeshovel",
  "repositoryName": "Closure-17b",
  "repositoryPath": "/tmp/Closure-17b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeInference.java",
  "functionName": "updateScopeForTypeChange",
  "functionId": "updateScopeForTypeChange___scope-FlowScope__left-Node__leftType-JSType__resultType-JSType",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeInference.java",
  "functionAnnotation": "",
  "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n",
  "functionStartLine": 462,
  "functionEndLine": 505,
  "numCommitsSeen": 81,
  "timeTaken": 5095,
  "changeHistory": [
    "2427228f43a8ace0d18597ab828f5f4775f5d716",
    "dff730a3759cad9c491f72d9905eee93962d3d35",
    "de684ba3efacbeb36f741eb8ed1598cf34df7783",
    "f78e933dbc678936ed5fcf453ab3c80b87d1e59d",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "2427228f43a8ace0d18597ab828f5f4775f5d716": "Ybodychange",
    "dff730a3759cad9c491f72d9905eee93962d3d35": "Ybodychange",
    "de684ba3efacbeb36f741eb8ed1598cf34df7783": "Ybodychange",
    "f78e933dbc678936ed5fcf453ab3c80b87d1e59d": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2427228f43a8ace0d18597ab828f5f4775f5d716": {
      "type": "Ybodychange",
      "commitMessage": "\nGive declaration nodes to locally qualified names\n\nR\u003dacleung\nDELTA\u003d42  (30 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3328\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1462 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/23/11, 3:22 PM",
      "commitName": "2427228f43a8ace0d18597ab828f5f4775f5d716",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/21/11, 5:18 PM",
      "commitNameOld": "dff730a3759cad9c491f72d9905eee93962d3d35",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName \u003d left.getString();\n            Var var \u003d syntacticScope.getVar(varName);\n            boolean isVarDeclaration \u003d left.hasChildren();\n            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                JSType oldType \u003d var.getType();\n                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName \u003d left.getQualifiedName();\n            if (qualifiedName !\u003d null) {\n                scope.inferQualifiedSlot(left, qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 441,
      "functionName": "updateScopeForTypeChange",
      "functionAnnotation": "",
      "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n",
      "diff": "@@ -1,26 +1,26 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n     switch(left.getType()) {\n         case Token.NAME:\n             String varName \u003d left.getString();\n             Var var \u003d syntacticScope.getVar(varName);\n             boolean isVarDeclaration \u003d left.hasChildren();\n             if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n             if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                 JSType oldType \u003d var.getType();\n                 var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName \u003d left.getQualifiedName();\n             if (qualifiedName !\u003d null) {\n-                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n+                scope.inferQualifiedSlot(left, qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n             }\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dff730a3759cad9c491f72d9905eee93962d3d35": {
      "type": "Ybodychange",
      "commitMessage": "\nBreak out basic function analysis into a separate pass, rather\nthan trying to do it as we go.\nThere should be no functional change, but this should make it\na lot easier to move things around in the future.\n\nR\u003dacleung\nDELTA\u003d332  (224 added, 89 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3318\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1460 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/21/11, 5:18 PM",
      "commitName": "dff730a3759cad9c491f72d9905eee93962d3d35",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/8/11, 3:30 PM",
      "commitNameOld": "b52343f59b46c0730b090e358f3a5dbcb0dc976c",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 13.07,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName \u003d left.getString();\n            Var var \u003d syntacticScope.getVar(varName);\n            boolean isVarDeclaration \u003d left.hasChildren();\n            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                JSType oldType \u003d var.getType();\n                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName \u003d left.getQualifiedName();\n            if (qualifiedName !\u003d null) {\n                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 441,
      "functionName": "updateScopeForTypeChange",
      "functionAnnotation": "",
      "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n",
      "diff": "@@ -1,29 +1,26 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n     switch(left.getType()) {\n         case Token.NAME:\n             String varName \u003d left.getString();\n             Var var \u003d syntacticScope.getVar(varName);\n-            if (var !\u003d null \u0026\u0026 var.isLocal() \u0026\u0026 var.getScope() !\u003d syntacticScope) {\n-                assignedOuterLocalVars.put(var.getScope(), var);\n-            }\n             boolean isVarDeclaration \u003d left.hasChildren();\n             if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                 redeclareSimpleVar(scope, left, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n             if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                 JSType oldType \u003d var.getType();\n                 var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName \u003d left.getQualifiedName();\n             if (qualifiedName !\u003d null) {\n                 scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n             }\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de684ba3efacbeb36f741eb8ed1598cf34df7783": {
      "type": "Ybodychange",
      "commitMessage": "\ndereference all qualified names, not just simple ones\nFixes issue 483\n\nR\u003dacleung\nDELTA\u003d41  (30 added, 3 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2680\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1273 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/19/11, 4:09 PM",
      "commitName": "de684ba3efacbeb36f741eb8ed1598cf34df7783",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/1/11, 2:00 PM",
      "commitNameOld": "03ce555bcedcf98d99de1b4f8a6238ba75ee6850",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 18.09,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName \u003d left.getString();\n            Var var \u003d syntacticScope.getVar(varName);\n            if (var !\u003d null \u0026\u0026 var.isLocal() \u0026\u0026 var.getScope() !\u003d syntacticScope) {\n                assignedOuterLocalVars.put(var.getScope(), var);\n            }\n            boolean isVarDeclaration \u003d left.hasChildren();\n            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                redeclareSimpleVar(scope, left, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                JSType oldType \u003d var.getType();\n                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName \u003d left.getQualifiedName();\n            if (qualifiedName !\u003d null) {\n                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 494,
      "functionName": "updateScopeForTypeChange",
      "functionAnnotation": "",
      "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n",
      "diff": "@@ -1,29 +1,29 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n     switch(left.getType()) {\n         case Token.NAME:\n             String varName \u003d left.getString();\n             Var var \u003d syntacticScope.getVar(varName);\n             if (var !\u003d null \u0026\u0026 var.isLocal() \u0026\u0026 var.getScope() !\u003d syntacticScope) {\n                 assignedOuterLocalVars.put(var.getScope(), var);\n             }\n             boolean isVarDeclaration \u003d left.hasChildren();\n             if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n-                redeclare(scope, varName, resultType);\n+                redeclareSimpleVar(scope, left, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n             if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                 JSType oldType \u003d var.getType();\n                 var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName \u003d left.getQualifiedName();\n             if (qualifiedName !\u003d null) {\n                 scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n             }\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f78e933dbc678936ed5fcf453ab3c80b87d1e59d": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t do local type inference on local vars that are assigned in inner\nscopes, because it\u0027s pretty close to impossible to do it right.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@84 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/1/10, 4:09 PM",
      "commitName": "f78e933dbc678936ed5fcf453ab3c80b87d1e59d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/28/10, 1:52 PM",
      "commitNameOld": "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.1,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName \u003d left.getString();\n            Var var \u003d syntacticScope.getVar(varName);\n            if (var !\u003d null \u0026\u0026 var.isLocal() \u0026\u0026 var.getScope() !\u003d syntacticScope) {\n                assignedOuterLocalVars.put(var.getScope(), var);\n            }\n            boolean isVarDeclaration \u003d left.hasChildren();\n            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                redeclare(scope, varName, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                JSType oldType \u003d var.getType();\n                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName \u003d left.getQualifiedName();\n            if (qualifiedName !\u003d null) {\n                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 487,
      "functionName": "updateScopeForTypeChange",
      "functionAnnotation": "",
      "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n",
      "diff": "@@ -1,26 +1,29 @@\n private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n     switch(left.getType()) {\n         case Token.NAME:\n             String varName \u003d left.getString();\n             Var var \u003d syntacticScope.getVar(varName);\n+            if (var !\u003d null \u0026\u0026 var.isLocal() \u0026\u0026 var.getScope() !\u003d syntacticScope) {\n+                assignedOuterLocalVars.put(var.getScope(), var);\n+            }\n             boolean isVarDeclaration \u003d left.hasChildren();\n             if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                 redeclare(scope, varName, resultType);\n             }\n             left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n             if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                 JSType oldType \u003d var.getType();\n                 var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n             }\n             break;\n         case Token.GETPROP:\n             String qualifiedName \u003d left.getQualifiedName();\n             if (qualifiedName !\u003d null) {\n                 scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n             }\n             left.setJSType(resultType);\n             ensurePropertyDefined(left, resultType);\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,26 @@\n+private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n+    Preconditions.checkNotNull(resultType);\n+    switch(left.getType()) {\n+        case Token.NAME:\n+            String varName \u003d left.getString();\n+            Var var \u003d syntacticScope.getVar(varName);\n+            boolean isVarDeclaration \u003d left.hasChildren();\n+            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n+                redeclare(scope, varName, resultType);\n+            }\n+            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n+            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n+                JSType oldType \u003d var.getType();\n+                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n+            }\n+            break;\n+        case Token.GETPROP:\n+            String qualifiedName \u003d left.getQualifiedName();\n+            if (qualifiedName !\u003d null) {\n+                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n+            }\n+            left.setJSType(resultType);\n+            ensurePropertyDefined(left, resultType);\n+            break;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch(left.getType()) {\n        case Token.NAME:\n            String varName \u003d left.getString();\n            Var var \u003d syntacticScope.getVar(varName);\n            boolean isVarDeclaration \u003d left.hasChildren();\n            if (!isVarDeclaration || var \u003d\u003d null || var.isTypeInferred()) {\n                redeclare(scope, varName, resultType);\n            }\n            left.setJSType(isVarDeclaration || leftType \u003d\u003d null ? resultType : null);\n            if (var !\u003d null \u0026\u0026 var.isTypeInferred()) {\n                JSType oldType \u003d var.getType();\n                var.setType(oldType \u003d\u003d null ? resultType : oldType.getLeastSupertype(resultType));\n            }\n            break;\n        case Token.GETPROP:\n            String qualifiedName \u003d left.getQualifiedName();\n            if (qualifiedName !\u003d null) {\n                scope.inferQualifiedSlot(qualifiedName, leftType \u003d\u003d null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType);\n            }\n            left.setJSType(resultType);\n            ensurePropertyDefined(left, resultType);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 461,
      "functionName": "updateScopeForTypeChange",
      "functionAnnotation": "",
      "functionDoc": "Updates the scope according to the result of a type change, like\nan assignment or a type cast.\n"
    }
  }
}