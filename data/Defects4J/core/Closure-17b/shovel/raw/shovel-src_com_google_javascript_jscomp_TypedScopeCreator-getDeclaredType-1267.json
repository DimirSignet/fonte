{
  "origin": "codeshovel",
  "repositoryName": "Closure-17b",
  "repositoryPath": "/tmp/Closure-17b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "getDeclaredType",
  "functionId": "$getDeclaredType___sourceName-String__info-JSDocInfo__lValue-Node__rValue-Node(annotations-@Nullable)",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
  "functionStartLine": 1267,
  "functionEndLine": 1315,
  "numCommitsSeen": 214,
  "timeTaken": 8407,
  "changeHistory": [
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "bd9c7b620384fe5a98772729001ed56304459bc6",
    "01d1238a2a577d8988a72c29304a3283ca05a29a",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f",
    "f80152eb5a2de72e8336b26e0e78b9e6baae37d2",
    "a2153e7405e09c8fa413a01874c949b8b2bcd32b",
    "1d806d5becb1be384050f49ffadbb57b7523db35",
    "b30eb41c34d380c0f5ab6d98bff95dc437179a52",
    "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
    "c64b9350aa206a4ec8deedaca08d6e4f1d84f4e8",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "bd9c7b620384fe5a98772729001ed56304459bc6": "Ybodychange",
    "01d1238a2a577d8988a72c29304a3283ca05a29a": "Ybodychange",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": "Ybodychange",
    "f80152eb5a2de72e8336b26e0e78b9e6baae37d2": "Ybodychange",
    "a2153e7405e09c8fa413a01874c949b8b2bcd32b": "Ybodychange",
    "1d806d5becb1be384050f49ffadbb57b7523db35": "Ybodychange",
    "b30eb41c34d380c0f5ab6d98bff95dc437179a52": "Ybodychange",
    "b489cf1f4089225b5ae06b6f30aa82d3438210aa": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95": "Ymultichange(Yrename,Yparameterchange,Ybodychange,Ydocchange)",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Ybodychange",
    "c64b9350aa206a4ec8deedaca08d6e4f1d84f4e8": "Yparametermetachange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 2:45 PM",
      "commitNameOld": "103bd46736cbbbabe6ad27ab11da10d6dbb1a8e5",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.isFunction() \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.isObjectLit()) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            if (info.isConstant()) {\n                JSType knownType \u003d null;\n                if (rValue !\u003d null) {\n                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                        return rValue.getJSType();\n                    } else if (rValue.isOr()) {\n                        Node firstClause \u003d rValue.getFirstChild();\n                        Node secondClause \u003d firstClause.getNext();\n                        boolean namesMatch \u003d firstClause.isName() \u0026\u0026 lValue.isName() \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1215,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,34 +1,34 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n-    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.isFunction() \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null) {\n         if (info.hasEnumParameterType()) {\n-            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            if (rValue !\u003d null \u0026\u0026 rValue.isObjectLit()) {\n                 return rValue.getJSType();\n             } else {\n                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n             }\n         } else if (info.isConstructor() || info.isInterface()) {\n             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         } else {\n             if (info.isConstant()) {\n                 JSType knownType \u003d null;\n                 if (rValue !\u003d null) {\n                     if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                         return rValue.getJSType();\n-                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n+                    } else if (rValue.isOr()) {\n                         Node firstClause \u003d rValue.getFirstChild();\n                         Node secondClause \u003d firstClause.getNext();\n-                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n+                        boolean namesMatch \u003d firstClause.isName() \u0026\u0026 lValue.isName() \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                         if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                             return secondClause.getJSType();\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd9c7b620384fe5a98772729001ed56304459bc6": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\ntry #2. the bugs in jstestc were fixed. this cl is exactly\nthe same as the original\n\nR\u003djohnlenz\nDELTA\u003d317  (79 added, 47 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1367 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 3:46 PM",
      "commitName": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 10:40 AM",
      "commitNameOld": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            if (info.isConstant()) {\n                JSType knownType \u003d null;\n                if (rValue !\u003d null) {\n                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                        return rValue.getJSType();\n                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n                        Node firstClause \u003d rValue.getFirstChild();\n                        Node secondClause \u003d firstClause.getNext();\n                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1181,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,34 +1,34 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n-    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null) {\n         if (info.hasEnumParameterType()) {\n             if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                 return rValue.getJSType();\n             } else {\n                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n             }\n         } else if (info.isConstructor() || info.isInterface()) {\n             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         } else {\n             if (info.isConstant()) {\n                 JSType knownType \u003d null;\n                 if (rValue !\u003d null) {\n                     if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                         return rValue.getJSType();\n                     } else if (rValue.getType() \u003d\u003d Token.OR) {\n                         Node firstClause \u003d rValue.getFirstChild();\n                         Node secondClause \u003d firstClause.getNext();\n                         boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                         if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                             return secondClause.getJSType();\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01d1238a2a577d8988a72c29304a3283ca05a29a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbroke some tests\n\n*** Original change description ***\n\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nDELTA\u003d318  (48 added, 79 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3075\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1364 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 10:40 AM",
      "commitName": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 9:38 AM",
      "commitNameOld": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            if (info.isConstant()) {\n                JSType knownType \u003d null;\n                if (rValue !\u003d null) {\n                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                        return rValue.getJSType();\n                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n                        Node firstClause \u003d rValue.getFirstChild();\n                        Node secondClause \u003d firstClause.getNext();\n                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1179,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,34 +1,34 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n-    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null) {\n         if (info.hasEnumParameterType()) {\n             if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                 return rValue.getJSType();\n             } else {\n                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n             }\n         } else if (info.isConstructor() || info.isInterface()) {\n             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         } else {\n             if (info.isConstant()) {\n                 JSType knownType \u003d null;\n                 if (rValue !\u003d null) {\n                     if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                         return rValue.getJSType();\n                     } else if (rValue.getType() \u003d\u003d Token.OR) {\n                         Node firstClause \u003d rValue.getFirstChild();\n                         Node secondClause \u003d firstClause.getNext();\n                         boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                         if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                             return secondClause.getJSType();\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nR\u003djohnlenz\nDELTA\u003d318  (79 added, 48 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3074\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1363 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 9:38 AM",
      "commitName": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/12/11, 9:46 AM",
      "commitNameOld": "7ab44a5f66e5889e71bb56bb91eb29066cf82530",
      "commitAuthorOld": "pdoyle@google.com",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            if (info.isConstant()) {\n                JSType knownType \u003d null;\n                if (rValue !\u003d null) {\n                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                        return rValue.getJSType();\n                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n                        Node firstClause \u003d rValue.getFirstChild();\n                        Node secondClause \u003d firstClause.getNext();\n                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1181,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,34 +1,34 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n-    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null) {\n         if (info.hasEnumParameterType()) {\n             if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                 return rValue.getJSType();\n             } else {\n                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n             }\n         } else if (info.isConstructor() || info.isInterface()) {\n             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         } else {\n             if (info.isConstant()) {\n                 JSType knownType \u003d null;\n                 if (rValue !\u003d null) {\n                     if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                         return rValue.getJSType();\n                     } else if (rValue.getType() \u003d\u003d Token.OR) {\n                         Node firstClause \u003d rValue.getFirstChild();\n                         Node secondClause \u003d firstClause.getNext();\n                         boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                         if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                             return secondClause.getJSType();\n                         }\n                     }\n                 }\n             }\n         }\n     }\n     return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f80152eb5a2de72e8336b26e0e78b9e6baae37d2": {
      "type": "Ybodychange",
      "commitMessage": "\nMake the global-this a true subtype of window.\nDeclare \u0027goog\u0027 at scope-declaration time.\n\n\nR\u003djohnlenz\nDELTA\u003d166  (126 added, 11 deleted, 29 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d784\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@861 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/7/11, 5:08 PM",
      "commitName": "f80152eb5a2de72e8336b26e0e78b9e6baae37d2",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/1/11, 7:50 AM",
      "commitNameOld": "a2153e7405e09c8fa413a01874c949b8b2bcd32b",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 6.39,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n            if (info.isConstant()) {\n                JSType knownType \u003d null;\n                if (rValue !\u003d null) {\n                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n                        return rValue.getJSType();\n                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n                        Node firstClause \u003d rValue.getFirstChild();\n                        Node secondClause \u003d firstClause.getNext();\n                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n                            return secondClause.getJSType();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1139,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,20 +1,34 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null) {\n         if (info.hasEnumParameterType()) {\n             if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                 return rValue.getJSType();\n             } else {\n                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n             }\n         } else if (info.isConstructor() || info.isInterface()) {\n             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n-        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n-            return rValue.getJSType();\n+        } else {\n+            if (info.isConstant()) {\n+                JSType knownType \u003d null;\n+                if (rValue !\u003d null) {\n+                    if (rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n+                        return rValue.getJSType();\n+                    } else if (rValue.getType() \u003d\u003d Token.OR) {\n+                        Node firstClause \u003d rValue.getFirstChild();\n+                        Node secondClause \u003d firstClause.getNext();\n+                        boolean namesMatch \u003d firstClause.getType() \u003d\u003d Token.NAME \u0026\u0026 lValue.getType() \u003d\u003d Token.NAME \u0026\u0026 firstClause.getString().equals(lValue.getString());\n+                        if (namesMatch \u0026\u0026 secondClause.getJSType() !\u003d null \u0026\u0026 !secondClause.getJSType().isUnknownType()) {\n+                            return secondClause.getJSType();\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n     return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2153e7405e09c8fa413a01874c949b8b2bcd32b": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nDon\u0027t infer enum properties twice\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\ncausing some problems for enums with @const members\n\n*** Original change description ***\n\nIf a variable is declared @const, and we know the type of its\nvalue, then we can just use that as the type.\n\nR\u003djohnlenz\nDELTA\u003d94  (69 added, 7 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d696\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@833 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/1/11, 7:50 AM",
      "commitName": "a2153e7405e09c8fa413a01874c949b8b2bcd32b",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/28/11, 3:43 PM",
      "commitNameOld": "1d806d5becb1be384050f49ffadbb57b7523db35",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n            return rValue.getJSType();\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1127,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,17 +1,20 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n-    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+    } else if (info !\u003d null) {\n+        if (info.hasEnumParameterType()) {\n+            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+                return rValue.getJSType();\n+            } else {\n+                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n+            }\n+        } else if (info.isConstructor() || info.isInterface()) {\n+            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n+        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n             return rValue.getJSType();\n-        } else {\n-            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n-    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n-    } else {\n-        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n+    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d806d5becb1be384050f49ffadbb57b7523db35": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\ncausing some problems for enums with @const members\n\n*** Original change description ***\n\nIf a variable is declared @const, and we know the type of its\nvalue, then we can just use that as the type.\n\nDELTA\u003d70  (0 added, 47 deleted, 23 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@832 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/28/11, 3:43 PM",
      "commitName": "1d806d5becb1be384050f49ffadbb57b7523db35",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/25/11, 12:18 PM",
      "commitNameOld": "b30eb41c34d380c0f5ab6d98bff95dc437179a52",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 3.14,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1122,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,20 +1,17 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n-    } else if (info !\u003d null) {\n-        if (info.hasEnumParameterType()) {\n-            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n-                return rValue.getJSType();\n-            } else {\n-                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n-            }\n-        } else if (info.isConstructor() || info.isInterface()) {\n-            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n-        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n+    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n             return rValue.getJSType();\n+        } else {\n+            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n+    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n+        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n+    } else {\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n-    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b30eb41c34d380c0f5ab6d98bff95dc437179a52": {
      "type": "Ybodychange",
      "commitMessage": "\nIf a variable is declared @const, and we know the type of its\nvalue, then we can just use that as the type.\n\nR\u003djohnlenz,zhuyi\nDELTA\u003d79  (56 added, 7 deleted, 16 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d678\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@822 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/25/11, 12:18 PM",
      "commitName": "b30eb41c34d380c0f5ab6d98bff95dc437179a52",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/24/11, 1:22 PM",
      "commitNameOld": "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null) {\n        if (info.hasEnumParameterType()) {\n            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n                return rValue.getJSType();\n            } else {\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n            }\n        } else if (info.isConstructor() || info.isInterface()) {\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n            return rValue.getJSType();\n        }\n    }\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1122,
      "functionName": "getDeclaredType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,17 +1,20 @@\n private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n-    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+    } else if (info !\u003d null) {\n+        if (info.hasEnumParameterType()) {\n+            if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+                return rValue.getJSType();\n+            } else {\n+                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n+            }\n+        } else if (info.isConstructor() || info.isInterface()) {\n+            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n+        } else if (info.isConstant() \u0026\u0026 rValue !\u003d null \u0026\u0026 rValue.getJSType() !\u003d null \u0026\u0026 !rValue.getJSType().isUnknownType()) {\n             return rValue.getJSType();\n-        } else {\n-            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n-    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n-    } else {\n-        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n+    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b489cf1f4089225b5ae06b6f30aa82d3438210aa": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "\nFix some bugs by removing redundant code.\n\nR\u003djohnlenz\nDELTA\u003d61  (4 added, 34 deleted, 23 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d667\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@816 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 1:22 PM",
      "commitName": "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nFix some bugs by removing redundant code.\n\nR\u003djohnlenz\nDELTA\u003d61  (4 added, 34 deleted, 23 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d667\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@816 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/11, 1:22 PM",
          "commitName": "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "2/16/11, 8:38 PM",
          "commitNameOld": "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 7.7,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1122,
          "functionName": "getDeclaredType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n+private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n         if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n             return rValue.getJSType();\n         } else {\n             return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n         return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getDeclaredPropType",
            "newValue": "getDeclaredType"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nFix some bugs by removing redundant code.\n\nR\u003djohnlenz\nDELTA\u003d61  (4 added, 34 deleted, 23 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d667\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@816 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/11, 1:22 PM",
          "commitName": "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "2/16/11, 8:38 PM",
          "commitNameOld": "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 7.7,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1122,
          "functionName": "getDeclaredType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n+private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n         if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n             return rValue.getJSType();\n         } else {\n             return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n         return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, info-JSDocInfo, lValue-Node, rValue-Node(annotations-@Nullable)]",
            "newValue": "[sourceName-String, info-JSDocInfo, lValue-Node, rValue-Node(annotations-@Nullable)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nFix some bugs by removing redundant code.\n\nR\u003djohnlenz\nDELTA\u003d61  (4 added, 34 deleted, 23 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d667\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@816 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/11, 1:22 PM",
          "commitName": "b489cf1f4089225b5ae06b6f30aa82d3438210aa",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "2/16/11, 8:38 PM",
          "commitNameOld": "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 7.7,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1122,
          "functionName": "getDeclaredType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n+private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n         return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n         if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n             return rValue.getJSType();\n         } else {\n             return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n         return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, lValue, info);\n+        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/1/11, 11:22 AM",
      "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/1/11, 11:22 AM",
          "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/31/11, 8:08 AM",
          "commitNameOld": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1125,
          "functionName": "getDeclaredPropType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n+private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+        return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n-            return rhsValue.getJSType();\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            return rValue.getJSType();\n         } else {\n-            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getDeclaredGetPropType",
            "newValue": "getDeclaredPropType"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/1/11, 11:22 AM",
          "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/31/11, 8:08 AM",
          "commitNameOld": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1125,
          "functionName": "getDeclaredPropType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n+private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+        return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n-            return rhsValue.getJSType();\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            return rValue.getJSType();\n         } else {\n-            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, info-JSDocInfo, n-Node, rhsValue-Node(annotations-@Nullable)]",
            "newValue": "[t-NodeTraversal, info-JSDocInfo, lValue-Node, rValue-Node(annotations-@Nullable)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/1/11, 11:22 AM",
          "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/31/11, 8:08 AM",
          "commitNameOld": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1125,
          "functionName": "getDeclaredPropType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n+private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+        return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n-            return rhsValue.getJSType();\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            return rValue.getJSType();\n         } else {\n-            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/1/11, 11:22 AM",
          "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/31/11, 8:08 AM",
          "commitNameOld": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n    } else {\n        return getDeclaredTypeInAnnotation(t, lValue, info);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 1125,
          "functionName": "getDeclaredPropType",
          "functionAnnotation": "",
          "functionDoc": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
          "diff": "@@ -1,17 +1,17 @@\n-private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n+private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n+    } else if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 shouldUseFunctionLiteralType((FunctionType) rValue.getJSType(), info, lValue)) {\n+        return rValue.getJSType();\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n-            return rhsValue.getJSType();\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            return rValue.getJSType();\n         } else {\n-            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+            return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n         }\n     } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n-        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+        return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\n     } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Look for a type declaration on a GETPROP node.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
            "newValue": "Look for a type declaration on a property assignment\n(in an ASSIGN or an object literal key).\n\n@param info The doc info for this property.\n@param lValue The l-value node.\n@param rValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n"
          }
        }
      ]
    },
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/27/11, 10:33 AM",
      "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.9,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n        return rhsValue.getJSType();\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            return rhsValue.getJSType();\n        } else {\n            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n        }\n    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n    } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1113,
      "functionName": "getDeclaredGetPropType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a GETPROP node.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,11 +1,17 @@\n private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(t, n, info);\n-    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-        return n.getJSType();\n     } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n         return rhsValue.getJSType();\n+    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+        if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            return rhsValue.getJSType();\n+        } else {\n+            return createEnumTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n+        }\n+    } else if (info !\u003d null \u0026\u0026 (info.isConstructor() || info.isInterface())) {\n+        return createFunctionTypeFromNodes(rhsValue, n.getQualifiedName(), info, n);\n     } else {\n         return getDeclaredTypeInAnnotation(t, n, info);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c64b9350aa206a4ec8deedaca08d6e4f1d84f4e8": {
      "type": "Yparametermetachange",
      "commitMessage": "\nfix bad inference of function member properties declared in\nthe constructor.\n\nR\u003djohnlenz\nDELTA\u003d20  (15 added, 0 deleted, 5 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1169981\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@538 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/9/10, 5:43 PM",
      "commitName": "c64b9350aa206a4ec8deedaca08d6e4f1d84f4e8",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/28/10, 8:31 AM",
      "commitNameOld": "3698fee71e3671171c587f932795a8ab8e852cd8",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 12.42,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        return n.getJSType();\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n        return rhsValue.getJSType();\n    } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1035,
      "functionName": "getDeclaredGetPropType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a GETPROP node.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n",
      "diff": "@@ -1,11 +1,11 @@\n-private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) {\n+private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, @Nullable Node rhsValue) {\n     if (info !\u003d null \u0026\u0026 info.hasType()) {\n         return getDeclaredTypeInAnnotation(t, n, info);\n     } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n         return n.getJSType();\n     } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n         return rhsValue.getJSType();\n     } else {\n         return getDeclaredTypeInAnnotation(t, n, info);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[t-NodeTraversal, info-JSDocInfo, n-Node, rhsValue-Node]",
        "newValue": "[t-NodeTraversal, info-JSDocInfo, n-Node, rhsValue-Node(annotations-@Nullable)]"
      }
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,11 @@\n+private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) {\n+    if (info !\u003d null \u0026\u0026 info.hasType()) {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+        return n.getJSType();\n+    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n+        return rhsValue.getJSType();\n+    } else {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info, Node n, Node rhsValue) {\n    if (info !\u003d null \u0026\u0026 info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    } else if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n        return n.getJSType();\n    } else if (rhsValue !\u003d null \u0026\u0026 rhsValue.getType() \u003d\u003d Token.FUNCTION) {\n        return rhsValue.getJSType();\n    } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 1104,
      "functionName": "getDeclaredGetPropType",
      "functionAnnotation": "",
      "functionDoc": "Look for a type declaration on a GETPROP node.\n\n@param info The doc info for this property.\n@param n A top-level GETPROP node (it should not be contained inside\n    another GETPROP).\n@param rhsValue The node that {@code n} is being initialized to,\n    or {@code null} if this is a stub declaration.\n"
    }
  }
}