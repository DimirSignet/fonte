{"sha": "e1fb7cf92c47eb262cdf37a8497fba75e522fe8c", "log": "Initial checkin of reflection code (not all working)   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+/**\n+ * <code>ClassUtils</code> contains utility methods for working for\n+ * classes without using reflection.\n+ *\n+ * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n+ * @version $Id: ClassUtils.java,v 1.3 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class ClassUtils {\n+\n+    /**\n+     * ClassUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ClassUtils.getShortClassName(cls)</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public ClassUtils() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the class name minus the package name from a Class.\n+     * \n+     * @param cls  the class to get the short name for, must not be null\n+     * @return the class name without the package name\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static String getShortClassName(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        return getShortClassName(cls.getName());\n+    }\n+    \n+    /**\n+     * Gets the class name minus the package name for an Object.\n+     * \n+     * @param object  the class to get the short name for, must not be null\n+     * @return the class name of the object without the package name\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static String getShortClassName(Object object) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object must not be null\");\n+        }\n+        return getShortClassName(object.getClass().getName());\n+    }\n+    \n+    /**\n+     * Gets the class name minus the package name from a String.\n+     * <p>\n+     * The string passed in is assumed to be a class name - it is not\n+     * checked.\n+     * \n+     * @param className  the className to get the short name for, must not be empty\n+     * @return the class name of the class without the package name\n+     * @throws IllegalArgumentException if the className is empty\n+     */\n+    public static String getShortClassName(String className) {\n+        if (StringUtils.isEmpty(className)) {\n+            throw new IllegalArgumentException(\"The class name must not be empty\");\n+        }\n+        char[] chars = className.toCharArray();\n+        int lastDot = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] == '.') {\n+                lastDot = i + 1;\n+            } else if (chars[i] == '$') {  // handle inner classes\n+                chars[i] = '.';\n+            }\n+        }\n+        return new String(chars, lastDot, chars.length - lastDot);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the package name of a Class.\n+     * \n+     * @param cls  the class to get the package name for, must not be null\n+     * @return the package name\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static String getPackageName(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        return getPackageName(cls.getName());\n+    }\n+    \n+    /**\n+     * Gets the package name of an Object.\n+     * \n+     * @param object  the class to get the package name for, must not be null\n+     * @return the package name\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static String getPackageName(Object object) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object must not be null\");\n+        }\n+        return getPackageName(object.getClass().getName());\n+    }\n+    \n+    /**\n+     * Gets the package name from a String.\n+     * <p>\n+     * The string passed in is assumed to be a class name - it is not\n+     * checked.\n+     * \n+     * @param className  the className to get the package name for, must not be empty\n+     * @return the package name\n+     * @throws IllegalArgumentException if the className is empty\n+     */\n+    public static String getPackageName(String className) {\n+        if (StringUtils.isEmpty(className)) {\n+            throw new IllegalArgumentException(\"The class name must not be empty\");\n+        }\n+        int i = className.lastIndexOf('.');\n+        if (i == -1) {\n+            return \"\";\n+        }\n+        return className.substring(0, i);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a list of superclasses for the given class.\n+     * \n+     * @param cls  the class to look up, must not be null\n+     * @return the list of superclasses in order going up from this one\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static List getAllSuperclasses(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        List classes = new ArrayList();\n+        Class superclass = cls.getSuperclass();\n+        while (superclass != null) {\n+            classes.add(superclass);\n+            superclass = superclass.getSuperclass();\n+        }\n+        return classes;\n+    }\n+    \n+    /**\n+     * Gets a list of all interfaces implemented by the given class.\n+     * <p>\n+     * The order is determined by looking through each interface in turn as\n+     * declared in the source file and following its hieracrchy up. Later\n+     * duplicates are ignored, so the order is maintained.\n+     * \n+     * @param cls  the class to look up, must not be null\n+     * @return the list of interfaces in order\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static List getAllInterfaces(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        List list = new ArrayList();\n+        Class[] interfaces = cls.getInterfaces();\n+        for (int i = 0; i < interfaces.length; i++) {\n+            if (list.contains(interfaces[i]) == false) {\n+                list.add(interfaces[i]);\n+            }\n+            List superInterfaces = getAllInterfaces(interfaces[i]);\n+            for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n+                Class intface = (Class) it.next();\n+                if (list.contains(intface) == false) {\n+                    list.add(intface);\n+                }\n+            }\n+        }\n+        return list;\n+    }\n+    \n+    /**\n+     * Gets a list of subclasses of the specified class.\n+     * <p>\n+     * This method searches the classpath to find all the subclasses\n+     * of a particular class available. No classes are loaded, the \n+     * returned list contains class names, not classes.\n+     *\n+     * @param cls  the class to find subclasses for\n+     * @return the list of subclass String class names\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static List getAllSubclassNames(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        // TODO Use JavaWorld tip for searching the classpath\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a list of subclasses of the specified class.\n+     * <p>\n+     * This method searches the classpath to find all the subclasses\n+     * of a particular class available.\n+     *\n+     * @param cls  the class to find subclasses for\n+     * @return the list of subclasses\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static List getAllSubclasses(Class cls) {\n+        List names = getAllSubclassNames(cls);\n+        return convertClassNamesToClasses(names);\n+    }\n+\n+    /**\n+     * Gets a list of implementations of the specified interface.\n+     * <p>\n+     * This method searches the classpath to find all the implementations\n+     * of a particular interface available. No classes are loaded, the \n+     * returned list contains class names, not classes.\n+     *\n+     * @param cls  the class to find sub classes for\n+     * @return the list of implementation String class names\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static List getAllImplementationClassNames(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        // TODO Use JavaWorld tip for searching the classpath\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class names, this method converts them into classes.\n+     * A new list is returned. If the class name cannot be found, null is\n+     * stored in the list. If the class name in the list is null, null is \n+     * stored in the output list.\n+     * \n+     * @param classes  the classNames to change, the class is stored back\n+     *  into the list. null will be stored in the list if no class is found.\n+     * @return the list of Class objects corresponding to the class names\n+     * @throws IllegalArgumentException if the classNames is null\n+     */\n+    public static List convertClassNamesToClasses(List classNames) {\n+        if (classNames == null) {\n+            throw new IllegalArgumentException(\"The class names must not be null\");\n+        }\n+        List classes = new ArrayList(classNames.size());\n+        for (Iterator it = classNames.iterator(); it.hasNext();) {\n+            String className = (String) it.next();\n+            try {\n+                classes.add(Class.forName(className));\n+            } catch (Exception ex) {\n+                classes.add(null);\n+            }\n+        }\n+        return classes;\n+    }\n+    \n+    /**\n+     * Given a list of classes, this method finds all those which are\n+     * subclasses or implementations of a specified superclass.\n+     * \n+     * @param classes  the classes to check\n+     * @param superclass  the superclass to check for\n+     * @return the list of subclasses or implementations\n+     * @throws IllegalArgumentException if the classes or superClass is null\n+     */\n+    public static List getAssignableFrom(List classes, Class superclass) {\n+        if (classes == null) {\n+            throw new IllegalArgumentException(\"The classes must not be null\");\n+        }\n+        if (superclass == null) {\n+            throw new IllegalArgumentException(\"The superclass must not be null\");\n+        }\n+        List subs = new ArrayList();\n+        Iterator it = classes.iterator();\n+        while (it.hasNext()) {\n+            Class cls = (Class) it.next();\n+            if (cls == null) {\n+                throw new IllegalArgumentException(\"The class list must not contain nulls\");\n+            }\n+            if (isAssignable(cls, superclass)) {\n+                subs.add(cls);\n+            }\n+        }\n+        return subs;\n+    }\n+\n+    /**\n+     * Checks if an array of Classes can be assigned to another array of Classes.\n+     * <p>\n+     * This can be used to check if parameter types are suitably compatable for\n+     * reflection invocation.\n+     * <p>\n+     * Unlike the Class.isAssignableFrom method, this method takes into \n+     * account widenings of primitive classes and nulls.\n+     * <p>\n+     * Primitive widenings allow an int to be assigned to a long, float or \n+     * double. This method returns the correct result for these cases.\n+     * <p>\n+     * Null may be assigned to any reference type. This method will return\n+     * true if null is passed in and the toClass is non-primitive.\n+     * <p>\n+     * Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See \n+     * <em>The Java Language Specification</em>, sections 5.1.1, 5.1.2 and \n+     * 5.1.4 for details.\n+     *\n+     * @param classArray  the array of Classes to check, may be null\n+     * @param toClassArray  the array of Classes to try to assign into, may be null\n+     * @return true if assignment possible\n+     */\n+    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n+        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n+            return false;\n+        }\n+        if (classArray == null) {\n+            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (toClassArray == null) {\n+            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        for (int i = 0; i < classArray.length; i++) {\n+            if (isAssignable(classArray[i], toClassArray[i]) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Checks if one Class can be assigned to a variable of another Class.\n+     * <p>\n+     * Unlike the Class.isAssignableFrom method, this method takes into \n+     * account widenings of primitive classes and nulls.\n+     * <p>\n+     * Primitive widenings allow an int to be assigned to a long, float or \n+     * double. This method returns the correct result for these cases.\n+     * <p>\n+     * Null may be assigned to any reference type. This method will return\n+     * true if null is passed in and the toClass is non-primitive.\n+     * <p>\n+     * Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See \n+     * <em>The Java Language Specification</em>, sections 5.1.1, 5.1.2 and \n+     * 5.1.4 for details.\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, must not be null\n+     * @return true if assignment possible\n+     * @throws IllegalArgumentException if the toClass is null\n+     */\n+    public static boolean isAssignable(Class cls, Class toClass) {\n+        if (toClass == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        // have to check for null, as isAssignableFrom doesn't\n+        if (cls == null) {\n+            return !(toClass.isPrimitive());\n+        }\n+        if (cls.equals(toClass)) {\n+            return true;\n+        }\n+        if (cls.isPrimitive()) {\n+            if (toClass.isPrimitive() == false) {\n+                return false;\n+            }\n+            if (Integer.TYPE.equals(cls)) {\n+                return Long.TYPE.equals(toClass) \n+                    || Float.TYPE.equals(toClass) \n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Long.TYPE.equals(cls)) {\n+                return Float.TYPE.equals(toClass) \n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Boolean.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Double.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Float.TYPE.equals(cls)) {\n+                return Double.TYPE.equals(toClass);\n+            }\n+            if (Character.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass) \n+                    || Long.TYPE.equals(toClass) \n+                    || Float.TYPE.equals(toClass) \n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Short.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass) \n+                    || Long.TYPE.equals(toClass) \n+                    || Float.TYPE.equals(toClass) \n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Byte.TYPE.equals(cls)) {\n+                return Short.TYPE.equals(toClass) \n+                    || Integer.TYPE.equals(toClass) \n+                    || Long.TYPE.equals(toClass) \n+                    || Float.TYPE.equals(toClass) \n+                    || Double.TYPE.equals(toClass);\n+            }\n+            // should never get here\n+            return false;\n+        }\n+        return toClass.isAssignableFrom(cls);\n+    }\n+    \n+    /**\n+     * Is the specified class an inner class or static nested class.\n+     * \n+     * @param cls  the class to check\n+     * @return true if the class is an inner or static nested class\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static boolean isInnerClass(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        return (cls.getDeclaringClass() != null);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/ConstructorUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+/**\n+ * <code>ConstructorUtils</code> contains utility methods for working for\n+ * constructors by reflection.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can allow classes to be created that shouldn't be, for\n+ * example new instances of an enumerated type. Thus, this facility should\n+ * be used with care.\n+ *\n+ * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n+ * @version $Id: ConstructorUtils.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class ConstructorUtils {\n+\n+    /** An empty constructor array */\n+    public static final Constructor[] EMPTY_CONSTRUCTOR_ARRAY = new Constructor[0];\n+    \n+    /**\n+     * ConstructorUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ConstructorUtils.newInstance(...)</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public ConstructorUtils() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a public <code>Constructor</code> object by matching the \n+     * parameter types as per the Java Language Specification.\n+     *\n+     * @param cls  Class object to find constructor for, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @return Constructor object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Constructor getConstructor(Class cls, Class[] types) {\n+        return getConstructor(cls, types, false);\n+    }\n+    \n+    /**\n+     * Gets a public <code>Constructor</code> object by matching the \n+     * parameter types as per the Java Language Specification.\n+     *\n+     * @param cls  Class object to find constructor for, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return Constructor object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Constructor getConstructor(Class cls, Class[] types, boolean breakScope) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        // try exact call first for speed\n+        try {\n+            getConstructorExact(cls, types, breakScope);\n+            \n+        } catch (ReflectionException ex) {\n+            if (types == null || types.length == 0) {\n+                throw ex;\n+            }\n+            if (ex.getCause() instanceof NoSuchMethodException == false) {\n+                throw ex;\n+            }\n+        }\n+        // try to find best match\n+        try {\n+            Constructor[] cons = cls.getDeclaredConstructors();\n+            for (int i = 0; i < cons.length; i++) {\n+                if (cons[i].getParameterTypes().length == types.length) {\n+                    // TODO\n+                }\n+            }\n+            return null;\n+\n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting constructor\", cls.getName(), types, null), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting constructor\", cls.getName(), types, null), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a public <code>Constructor</code> object by exactly matching the\n+     * parameter types.\n+     *\n+     * @param cls  Class object to find constructor for, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @return Constructor object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Constructor getConstructorExact(Class cls, Class[] types) {\n+        return getConstructorExact(cls, types, false);\n+    }\n+    \n+    /**\n+     * Gets a <code>Constructor</code> object by exactly matching the\n+     * parameter types.\n+     *\n+     * @param cls  Class object to find constructor for, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return Constructor object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Constructor getConstructorExact(Class cls, Class[] types, boolean breakScope) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        try {\n+            if (breakScope) {\n+                Constructor con = cls.getDeclaredConstructor(types);\n+                if (Modifier.isPublic(con.getModifiers()) == false) {\n+                    con.setAccessible(true);\n+                }\n+                return con;\n+                \n+            } else {\n+                return cls.getConstructor(types);\n+            }\n+\n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting constructor\", cls.getName(), types, null), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting constructor\", cls.getName(), types, null), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Creates a new instance using a <code>Constructor</code> and parameters.\n+     * \n+     * @param con  Class object to find constructor for, must not be null\n+     * @param param  the single parameter to pass to the constructor, may be null\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the constructor is null\n+     */\n+    public static Object newInstance(Constructor con, Object param) {\n+        return newInstance(con, new Object[] {param}, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance using a <code>Constructor</code> and parameters.\n+     * \n+     * @param con  Class object to find constructor for, must not be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the constructor is null\n+     */\n+    public static Object newInstance(Constructor con, Object[] params) {\n+        return newInstance(con, params, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance using a <code>Constructor</code> and parameters.\n+     * \n+     * @param con  Class object to find constructor for, must not be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the constructor is null\n+     */\n+    public static Object newInstance(Constructor con, Object[] params, boolean breakScope) {\n+        if (con == null) {\n+            throw new IllegalArgumentException(\"The constructor must not be null\");\n+        }\n+        try {\n+            if (breakScope && Modifier.isPublic(con.getModifiers()) == false) {\n+                con.setAccessible(true);\n+            }\n+            return con.newInstance(params);\n+    \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"invoking constructor\", con.getDeclaringClass().getName(), con.getParameterTypes(), null), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"invoking constructor\", con.getDeclaringClass().getName(), con.getParameterTypes(), null), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code> by name.\n+     * \n+     * @param className  String class name to instantiate, must not be empty\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class name is empty\n+     */\n+    public static Object newInstance(String className) {\n+        return newInstance(className, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code> by name.\n+     * If the constructor is not public, <code>setAccessible(true)</code>\n+     * is used to make it accessible.\n+     * \n+     * @param className  String class name to instantiate, must not be empty\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class name is empty\n+     */\n+    public static Object newInstance(String className, boolean breakScope) {\n+        Class cls = ReflectionUtils.getClass(className);\n+        return newInstance(cls, breakScope);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstance(Class cls) {\n+        return newInstance(cls, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * If the constructor is not public, <code>setAccessible(true)</code>\n+     * is used to make it accessible.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstance(Class cls, boolean breakScope) {\n+        if (breakScope) {\n+            return newInstanceExact(cls, null, null, true);\n+            \n+        } else {\n+            if (cls == null) {\n+                throw new IllegalArgumentException(\"The constructor must not be null\");\n+            }\n+            try {\n+                return cls.newInstance();\n+        \n+            } catch (ReflectionException ex) {\n+                throw ex;\n+            } catch (LinkageError ex) {\n+                throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                    ex, \"instantiating class\", cls.getName(), null, null), ex);\n+            } catch (Exception ex) {\n+                throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                    ex, \"instantiating class\", cls.getName(), null, null), ex);\n+            }\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * The constructor is found by matching the \n+     * parameter types as per the Java Language Specification.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstance(Class cls, Class[] types, Object[] params) {\n+        return newInstance(cls, types, params, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * The constructor is found by matching the \n+     * parameter types as per the Java Language Specification.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the types and params lengths differ\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstance(Class cls, Class[] types, Object[] params, boolean breakScope) {\n+        if (ArrayUtils.isSameLength(types, params) == false) {\n+            throw new IllegalArgumentException(\"The types and params lengths must be the same\");\n+        }\n+        Constructor con = getConstructor(cls, types, breakScope);\n+        return newInstance(con, params, breakScope);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * The constructor is found by matching the parameter types exactly.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstanceExact(Class cls, Class[] types, Object[] params) {\n+        return newInstanceExact(cls, types, params, false);\n+    }\n+    \n+    /**\n+     * Creates a new instance of the specified <code>Class</code>.\n+     * The constructor is found by matching the parameter types exactly.\n+     * \n+     * @param cls  Class object to instantiate, must not be null\n+     * @param types  array of Class objects representing parameter types, may be null\n+     * @param params  array of objects to pass as parameters, may be null\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the newly created object\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the types and params lengths differ\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Object newInstanceExact(Class cls, Class[] types, Object[] params, boolean breakScope) {\n+        if (ArrayUtils.isSameLength(types, params) == false) {\n+            throw new IllegalArgumentException(\"The types and params lengths must be the same\");\n+        }\n+        Constructor con = getConstructorExact(cls, types, breakScope);\n+        return newInstance(con, params, breakScope);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/FieldUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+/**\n+ * <code>FieldUtils</code> contains utility methods for working with\n+ * fields by reflection.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can allow fields to be changed that shouldn't be. This\n+ * facility should be used with care.\n+ *\n+ * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n+ * @version $Id: FieldUtils.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class FieldUtils {\n+    \n+    /** An empty field array */\n+    public static final Field[] EMPTY_FIELD_ARRAY = new Field[0];\n+    \n+    /**\n+     * FieldUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>FieldUtils.getField(cls, name)</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public FieldUtils() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets an accessible Field by name repecting scope.\n+     * Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Field getField(Class cls, String fieldName) {\n+        return getField(cls, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets an accessible Field by name breaking scope if requested.\n+     * Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Field getField(Class cls, String fieldName, boolean breakScope) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n+        // code ourselves\n+        \n+        // getField() will return the Field object with the declaring class\n+        // set correctly to the class that declares the field. Thus requesting the\n+        // field on a subclass will return the field from the superclass.\n+        //\n+        // priority order for lookup:\n+        // searchclass private/protected/package/public\n+        // superclass protected/package/public\n+        //  private/different package blocks access to further superclasses\n+        // implementedinterface public\n+        try {\n+            // check up the superclass hierarchy\n+            Class acls = cls;\n+            Field match = null;\n+            while (acls != null && acls != Object.class) {\n+                // getDeclaredField checks for non-public scopes as well\n+                // and it returns accurate results\n+                try {\n+                    Field field = acls.getDeclaredField(fieldName);\n+                    if (Modifier.isPublic(field.getModifiers()) == false) {\n+                        field.setAccessible(breakScope);\n+                        return field;\n+                    }\n+                    if (breakScope == false) {\n+                        // only public acceptable if not breaking scope\n+                        throw new IllegalAccessException(\"The field '\" + fieldName + \n+                            \"' was found, but it's scope prevents direct access by reflection\");\n+                    }\n+                    field.setAccessible(true);\n+                    match = field;\n+                    break;\n+                    \n+                } catch (NoSuchFieldException ex) {\n+                    // ignore\n+                }\n+                // next superclass\n+                acls = acls.getSuperclass();\n+            }\n+            // check the public interface case. This must be manually searched for\n+            // incase there is a public supersuperclass field hidden by a private/package\n+            // superclass field.\n+            // check up the superclass hierarchy\n+            Class[] ints = cls.getInterfaces();\n+            for (int i = 0; i < ints.length; i++) {\n+                // getField is fine here, because everything is public, and thus it works\n+                try {\n+                    Field field = ints[i].getField(fieldName);\n+                    return field;\n+                    \n+                } catch (NoSuchFieldException ex) {\n+                    // ignore\n+                }\n+            }\n+            if (match != null) {\n+                return match;\n+            }\n+            throw new NoSuchFieldException(\"The field '\" + fieldName + \"' could not be found\");\n+    \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field\", cls.getName(), null, fieldName), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field\", cls.getName(), null, fieldName), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets an accessible Field by name respecting scope.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Field getFieldExact(Class cls, String fieldName) {\n+        return getFieldExact(cls, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets an accessible Field by name breaking scope if requested.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Field getFieldExact(Class cls, String fieldName, boolean breakScope) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        try {\n+            // only consider the specified class by using getDeclaredField()\n+            Field field = cls.getDeclaredField(fieldName);\n+            if (Modifier.isPublic(field.getModifiers()) == false) {\n+                if (breakScope) {\n+                    field.setAccessible(true);\n+                } else {\n+                    throw new IllegalAccessException(\"The field '\" + fieldName + \"' was found, but it's scope prevents direct access by reflection\");\n+                }\n+            }\n+            return field;\n+    \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field\", cls.getName(), null, fieldName), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field\", cls.getName(), null, fieldName), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a static Field value from a Field object.\n+     * \n+     * @param field  the field to use\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValue(Field field) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) == false) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        return getFieldValue(field, (Object) null, false);\n+    }\n+    \n+    /**\n+     * Gets a static Field value from a Field object.\n+     * \n+     * @param field  the field to use\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValue(Field field, boolean breakScope) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) == false) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        return getFieldValue(field, (Object) null, breakScope);\n+    }\n+    \n+    /**\n+     * Gets a Field value from a Field object.\n+     * \n+     * @param field  the field to use\n+     * @param object  the object to call on, may be null for static fields\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValue(Field field, Object object) {\n+        return getFieldValue(field, object, false);\n+    }\n+    \n+    /**\n+     * Gets a Field value from a Field object.\n+     * \n+     * @param field  the field to use\n+     * @param object  the object to call on, may be null for static fields\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public methods.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValue(Field field, Object object, boolean breakScope) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        try {\n+            if (breakScope && Modifier.isPublic(field.getModifiers()) == false) {\n+                field.setAccessible(true);\n+            }\n+            return field.get(object);\n+    \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", field.getDeclaringClass().getName(), null, field.getName()), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", field.getDeclaringClass().getName(), null, field.getName()), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a static Field value by name. The field must be public.\n+     * Superclasses will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValue(Class cls, String fieldName) {\n+        return getStaticFieldValue(cls, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets a static Field value by name.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValue(Class cls, String fieldName, boolean breakScope) {\n+        try {\n+            Field field = getField(cls, fieldName, breakScope);\n+            if (Modifier.isStatic(field.getModifiers()) == false) {\n+                throw new NoSuchMethodException(\"The field '\" + fieldName + \"' is not static\");\n+            }\n+            return getStaticFieldValue(field, breakScope);\n+            \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", cls.getName(), null, fieldName), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", cls.getName(), null, fieldName), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a static Field value by name. The field must be public.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValueExact(Class cls, String fieldName) {\n+        return getStaticFieldValueExact(cls, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets a static Field value by name.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getStaticFieldValueExact(Class cls, String fieldName, boolean breakScope) {\n+        try {\n+            Field field = getFieldExact(cls, fieldName, breakScope);\n+            if (Modifier.isStatic(field.getModifiers()) == false) {\n+                throw new NoSuchMethodException(\"The field '\" + fieldName + \"' is not static\");\n+            }\n+            return getStaticFieldValue(field, breakScope);\n+            \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", cls.getName(), null, fieldName), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting field value\", cls.getName(), null, fieldName), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a Field value by name. The field must be public.\n+     * Superclasses will be considered.\n+     *\n+     * @param object  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValue(Object object, String fieldName) {\n+        return getFieldValue(object, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets a Field value by name.\n+     * Only the specified class will be considered.\n+     *\n+     * @param object  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValue(Object object, String fieldName, boolean breakScope) {\n+        Field field = getField(object.getClass(), fieldName, breakScope);\n+        return getFieldValue(field, object, breakScope);\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a Field value by name. The field must be public.\n+     * Only the class of the specified object will be considered.\n+     *\n+     * @param object  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValueExact(Object object, String fieldName) {\n+        return getFieldValueExact(object, fieldName, false);\n+    }\n+    \n+    /**\n+     * Gets a Field value by name.\n+     * Only the class of the specified object will be considered.\n+     *\n+     * @param object  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object getFieldValueExact(Object object, String fieldName, boolean breakScope) {\n+        Field field = getFieldExact(object.getClass(), fieldName, breakScope);\n+        return getFieldValue(field, object, breakScope);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.StringUtils;\n+/**\n+ * <code>MethodUtils</code> contains utility methods for working for\n+ * methods by reflection.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can break an implementation if used incorrectly. This\n+ * facility should be used with care.\n+ *\n+ * @author Based on code from BeanUtils\n+ * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n+ * @version $Id: MethodUtils.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class MethodUtils {\n+    \n+    /** An empty method array */\n+    public static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n+    \n+    /**\n+     * MethodUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>MethodUtils.getMethod(cls, name)</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public MethodUtils() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a Method by name. The method must be public and take no parameters.\n+     * Superclasses will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param methodName  the field name to obtain\n+     * @return the Method object\n+     * @throws IllegalArgumentException if the class or method name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Method getMethod(Class cls, String methodName) {\n+        return getMethod(cls, methodName, ArrayUtils.EMPTY_CLASS_ARRAY, false);\n+    }\n+    \n+    /**\n+     * Gets a Method by name. The method must be public.\n+     * Superclasses will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param methodName  the field name to obtain\n+     * @return the Method object\n+     * @throws IllegalArgumentException if the class or method name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Method getMethod(Class cls, String methodName, Class[] paramTypes) {\n+        return getMethod(cls, methodName, paramTypes, false);\n+    }\n+    \n+    /**\n+     * Gets a Method by name.\n+     * Superclasses will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param methodName  the method name to obtain\n+     * @param breakScope  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Method object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Method getMethod(Class cls, String methodName, Class[] paramTypes, boolean breakScope) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method name must not be null\");\n+        }\n+        try {\n+            if (breakScope) {\n+                try {\n+                    // most common case, always do this for speed\n+                    return cls.getMethod(methodName, paramTypes);  // must be public\n+                } catch (NoSuchMethodException ex) {\n+                    // ignore\n+                }\n+                Class acls = cls;\n+                while (acls != null) {\n+                    Method[] methods = acls.getDeclaredMethods();\n+                    for (int i = 0; i < methods.length; i++) {\n+                        if (methods[i].getName().equals(methodName) &&\n+                            ReflectionUtils.isCompatable(paramTypes, methods[i].getParameterTypes())) {\n+                            if (Modifier.isPublic(methods[i].getModifiers())) {\n+                                methods[i].setAccessible(true);\n+                            }\n+                            return methods[i];\n+                        }\n+                    }\n+                    acls = acls.getSuperclass();  // TODO interfaces\n+                }\n+                throw new NoSuchMethodException(\"The method '\" + methodName + \"' could not be found\");\n+            } else {\n+                return cls.getMethod(methodName, paramTypes);\n+            }\n+    \n+        } catch (ReflectionException ex) {\n+            throw ex;\n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting method\", cls.getName(), null, methodName), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(ReflectionUtils.getThrowableText(\n+                ex, \"getting method\", cls.getName(), null, methodName), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>The behaviour of this method is less deterministic \n+     * than {@link #invokeExactMethod}. \n+     * It loops through all methods with names that match\n+     * and then executes the first it finds with compatable parameters.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param objectToInvoke  invoke method on this object, must not be null\n+     * @param methodName  get method with this name, must not be null\n+     * @param arg  use this argument, must not be null\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     * @throws IllegalArgumentException if any parameter is null\n+     */\n+    public static Object invokeMethod(\n+            Object objectToInvoke,\n+            String methodName,\n+            Object arg)\n+                throws\n+                    NoSuchMethodException,\n+                    IllegalAccessException,\n+                    InvocationTargetException {\n+\n+        if (objectToInvoke == null) {\n+            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n+        }\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method name must not be null\");\n+        }\n+        if (arg == null) {\n+            throw new IllegalArgumentException(\"The argument must not be null\");\n+        }\n+        Object[] args = {arg};\n+        return invokeMethod(objectToInvoke, methodName, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>The behaviour of this method is less deterministic \n+     * than {@link #invokeExactMethod(Object object,String methodName,Object [] args)}. \n+     * It loops through all methods with names that match\n+     * and then executes the first it finds with compatable parameters.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param objectToInvoke  invoke method on this object, must not be null\n+     * @param methodName  get method with this name, must not be null\n+     * @param args  use these arguments - treat null as empty array\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     * @throws IllegalArgumentException if the objectToInvoke, methodName or any argument is null\n+     */\n+    public static Object invokeMethod(\n+            Object objectToInvoke,\n+            String methodName,\n+            Object[] args)\n+                throws\n+                    NoSuchMethodException,\n+                    IllegalAccessException,\n+                    InvocationTargetException {\n+        \n+        if (objectToInvoke == null) {\n+            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n+        }\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method name must not be null\");\n+        }\n+        if (args == null) {\n+            return invokeMethod(objectToInvoke, methodName, null, null);\n+        } else {\n+            int arguments = args.length;\n+            Class parameterTypes [] = new Class[arguments];\n+            for (int i = 0; i < arguments; i++) {\n+                if (args[i] == null) {\n+                    throw new IllegalArgumentException(\"The arguments must not be null. Index \" + i + \" was null.\");\n+                }\n+                parameterTypes[i] = args[i].getClass();\n+            }\n+            return invokeMethod(objectToInvoke, methodName, args, parameterTypes);\n+        }\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>The behaviour of this method is less deterministic \n+     * than {@link \n+     * #invokeExactMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}. \n+     * It loops through all methods with names that match\n+     * and then executes the first it finds with compatable parameters.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     *\n+     * @param object  invoke method on this object\n+     * @param methodName  get method with this name\n+     * @param args  use these arguments - treat null as empty array\n+     * @param parameterTypes  match these parameters - treat null as empty array\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeMethod(\n+            Object object,\n+            String methodName,\n+            Object[] args,\n+            Class[] parameterTypes)\n+                throws\n+                    NoSuchMethodException,\n+                    IllegalAccessException,\n+                    InvocationTargetException {\n+                    \n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }        \n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }  \n+\n+return null;\n+//        Method method = getMatchingAccessibleMethod(\n+//                object.getClass(),\n+//                methodName,\n+//                parameterTypes);\n+//        if (method == null)\n+//            throw new NoSuchMethodException(\"No such accessible method: \" +\n+//                    methodName + \"() on object: \" + object.getClass().getName());\n+//        return method.invoke(object, args);\n+    }\n+\n+\n+    /**\n+     * <p>Invoke a method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(\n+            Object object,\n+            String methodName,\n+            Object arg)\n+            throws\n+            NoSuchMethodException,\n+            IllegalAccessException,\n+            InvocationTargetException {\n+\n+        Object[] args = {arg};\n+        return invokeExactMethod(object, methodName, args);\n+\n+    }\n+\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod}.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(\n+            Object object,\n+            String methodName,\n+            Object[] args)\n+            throws\n+            NoSuchMethodException,\n+            IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }  \n+        int arguments = args.length;\n+        Class parameterTypes [] = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactMethod(object, methodName, args, parameterTypes);\n+\n+    }\n+\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod}.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(\n+            Object object,\n+            String methodName,\n+            Object[] args,\n+            Class[] parameterTypes)\n+            throws\n+            NoSuchMethodException,\n+            IllegalAccessException,\n+            InvocationTargetException {\n+        \n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }  \n+                \n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+\n+        Method method = getAccessibleMethod(\n+                object.getClass(),\n+                methodName,\n+                parameterTypes);\n+        if (method == null)\n+            throw new NoSuchMethodException(\"No such accessible method: \" +\n+                    methodName + \"() on object: \" + object.getClass().getName());\n+        return method.invoke(object, args);\n+\n+    }\n+\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and a single parameter.  If no such method\n+     * can be found, return <code>null</code>.\n+     * Basically, a convenience wrapper that constructs a <code>Class</code>\n+     * array for you.</p>\n+     *\n+     * @param clazz get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterType taking this type of parameter\n+     */\n+    public static Method getAccessibleMethod(\n+            Class clazz,\n+            String methodName,\n+            Class parameterType) {\n+\n+        Class[] parameterTypes = {parameterType};\n+        return getAccessibleMethod(clazz, methodName, parameterTypes);\n+\n+    }\n+\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and parameters.  If no such method\n+     * can be found, return <code>null</code>.\n+     * This is just a convenient wrapper for\n+     * {@link #getAccessibleMethod(Method method)}.</p>\n+     *\n+     * @param clazz get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterTypes with these parameters types\n+     */\n+    public static Method getAccessibleMethod(\n+            Class clazz,\n+            String methodName,\n+            Class[] parameterTypes) {\n+\n+        try {\n+            return getAccessibleMethod\n+                    (clazz.getMethod(methodName, parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified Method.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param method The method that we wish to call\n+     */\n+    public static Method getAccessibleMethod(Method method) {\n+\n+        // Make sure we have a method to check\n+        if (method == null) {\n+            return (null);\n+        }\n+\n+        // If the requested method is not public we cannot call it\n+        if (!Modifier.isPublic(method.getModifiers())) {\n+            return (null);\n+        }\n+\n+        // If the declaring class is public, we are done\n+        Class clazz = method.getDeclaringClass();\n+        if (Modifier.isPublic(clazz.getModifiers())) {\n+            return (method);\n+        }\n+\n+        // Check the implemented interfaces and subinterfaces\n+        String methodName = method.getName();\n+        Class[] parameterTypes = method.getParameterTypes();\n+        method =\n+                getAccessibleMethodFromInterfaceNest(clazz,\n+                        method.getName(),\n+                        method.getParameterTypes());\n+        return (method);\n+\n+    }\n+\n+\n+    // -------------------------------------------------------- Private Methods\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * <p> There isn't any good reason why this method must be private.\n+     * It is because there doesn't seem any reason why other classes should\n+     * call this rather than the higher level methods.</p>\n+     *\n+     * @param clazz Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest\n+            (Class clazz, String methodName, Class parameterTypes[]) {\n+\n+        Method method = null;\n+\n+        // Search up the superclass chain\n+        for (; clazz != null; clazz = clazz.getSuperclass()) {\n+\n+            // Check the implemented interfaces of the parent class\n+            Class interfaces[] = clazz.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+\n+                // Is this interface public?\n+                if (!Modifier.isPublic(interfaces[i].getModifiers()))\n+                    continue;\n+\n+                // Does the method exist on this interface?\n+                try {\n+                    method = interfaces[i].getDeclaredMethod(methodName,\n+                            parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    ;\n+                }\n+                if (method != null)\n+                    break;\n+\n+                // Recursively check our parent interfaces\n+                method =\n+                        getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                                methodName,\n+                                parameterTypes);\n+                if (method != null)\n+                    break;\n+\n+            }\n+\n+        }\n+\n+        // If we found a method return it\n+        if (method != null)\n+            return (method);\n+\n+        // We did not find anything\n+        return (null);\n+\n+    }\n+\n+//    /**\n+//     * <p>Find an accessible method that matches the given name and has compatible parameters.\n+//     * Compatible parameters mean that every method parameter is assignable from \n+//     * the given parameters.\n+//     * In other words, it finds a method with the given name \n+//     * that will take the parameters given.<p>\n+//     *\n+//     * <p>This method is slightly undeterminstic since it loops \n+//     * through methods names and return the first matching method.</p>\n+//     * \n+//     * <p>This method is used by \n+//     * {@link \n+//     * #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n+//     *\n+//     * <p>This method can match primitive parameter by passing in wrapper classes.\n+//     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n+//     * parameter.\n+//     *\n+//     * @param clazz find method in this class\n+//     * @param methodName find method with this name\n+//     * @param parameterTypes find method with compatible parameters \n+//     */\n+//    private static Method getMatchingAccessibleMethod(\n+//                                                Class clazz,\n+//                                                String methodName,\n+//                                                Class[] parameterTypes) {\n+//        // trace logging\n+//        if (log.isTraceEnabled()) {\n+//            log.trace(\"Matching name=\" + methodName + \" on \" + clazz);\n+//        }\n+//        \n+//        // see if we can find the method directly\n+//        // most of the time this works and it's much faster\n+//        try {\n+//            Method method = clazz.getMethod(methodName, parameterTypes);\n+//            return method;\n+//            \n+//        } catch (NoSuchMethodException e) { /* SWALLOW */ }\n+//        \n+//        // search through all methods \n+//        int paramSize = parameterTypes.length;\n+//        Method[] methods = clazz.getMethods();\n+//        for (int i = 0, size = methods.length; i < size ; i++) {\n+//            if (methods[i].getName().equals(methodName)) {\t\n+//                // log some trace information\n+//                if (log.isTraceEnabled()) {\n+//                    log.trace(\"Found matching name:\");\n+//                    log.trace(methods[i]);\n+//                }                \n+//                \n+//                // compare parameters\n+//                Class[] methodsParams = methods[i].getParameterTypes();\n+//                int methodParamSize = methodsParams.length;\n+//                if (methodParamSize == paramSize) {          \n+//                    boolean match = true;\n+//                    for (int n = 0 ; n < methodParamSize; n++) {\n+//                        if (log.isTraceEnabled()) {\n+//                            log.trace(\"Param=\" + parameterTypes[n].getName());\n+//                            log.trace(\"Method=\" + methodsParams[n].getName());\n+//                        }\n+//                        if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {\n+//                            if (log.isTraceEnabled()) {\n+//                                log.trace(methodsParams[n] + \" is not assignable from \" \n+//                                            + parameterTypes[n]);\n+//                            }    \n+//                            match = false;\n+//                            break;\n+//                        }\n+//                    }\n+//                    \n+//                    if (match) {\n+//                        // get accessible version of method\n+//                        Method method = getAccessibleMethod(methods[i]);\n+//                        if (method != null) {\n+//                            if (log.isTraceEnabled()) {\n+//                                log.trace(method + \" accessible version of \" \n+//                                            + methods[i]);\n+//                            }\n+//                            return method;\n+//                        }\n+//                        \n+//                        log.trace(\"Couldn't find accessible method.\");\n+//                    }\n+//                }\n+//            }\n+//        }\n+//        \n+//        // didn't find a match\n+//        log.trace(\"No match found.\");\n+//        return null;                                        \n+//    }\n+//\n+//    /**\n+//     * <p>Determine whether a type can be used as a parameter in a method invocation.\n+//     * This method handles primitive conversions correctly.</p>\n+//     *\n+//     * <p>In order words, it will match a <code>Boolean</code> to a <code>boolean</code>,\n+//     * a <code>Long</code> to a <code>long</code>,\n+//     * a <code>Float</code> to a <code>float</code>,\n+//     * a <code>Integer</code> to a <code>int</code>,\n+//     * and a <code>Double</code> to a <code>double</code>.\n+//     * Now logic widening matches are allowed.\n+//     * For example, a <code>Long</code> will not match a <code>int</code>.\n+//     *\n+//     * @param parameterType the type of parameter accepted by the method\n+//     * @param parameterization the type of parameter being tested \n+//     *\n+//     * @return true if the assignement is compatible.\n+//     */\n+//    private static final boolean isAssignmentCompatible(Class parameterType, Class parameterization) {\n+//        // try plain assignment\n+//        if (parameterType.isAssignableFrom(parameterization)) {\n+//            return true;\n+//        }\n+//        \n+//        if (parameterType.isPrimitive()) {\n+//            // does anyone know a better strategy than comparing names?\n+//            // also, this method does *not* do widening - you must specify exactly\n+//            // is this the right behaviour?\n+//            if (boolean.class.equals(parameterType)) {\n+//                return Boolean.class.equals(parameterization);\n+//            }         \n+//            if (float.class.equals(parameterType)) {\n+//                return Float.class.equals(parameterization);\n+//            }     \n+//            if (long.class.equals(parameterType)) {\n+//                return Long.class.equals(parameterization);\n+//            }     \n+//            if (int.class.equals(parameterType)) {\n+//                return Integer.class.equals(parameterization);\n+//            }                \n+//            if (double.class.equals(parameterType)) {\n+//                return Double.class.equals(parameterization);\n+//            }               \n+//        }\n+//        \n+//        return false;\n+//    }\n+//    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/ReflectionException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the Reflection process fails. The original\n+ * error is wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ReflectionException.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class ReflectionException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>ReflectionException</code> without specified\n+     * detail message.\n+     */\n+    public ReflectionException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReflectionException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  The error message.\n+     */\n+    public ReflectionException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReflectionException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param cause  The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public ReflectionException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReflectionException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    The error message.\n+     * @param cause  The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public ReflectionException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/reflect/ReflectionUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.reflect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.*;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.StringUtils;\n+/**\n+ * <code>ReflectionUtils</code> contains utility methods for working for\n+ * reflection.\n+ *\n+ * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n+ * @version $Id: ReflectionUtils.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ */\n+public class ReflectionUtils {\n+    \n+    /**\n+     * ReflectionUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ReflectionUtils.getShortClassName(obj)</code>.\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public ReflectionUtils() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Tests whether the specified field or method is \n+     * <code>static</code>.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is static\n+     */\n+    public static boolean isStatic(Member member) {\n+        if (member == null) {\n+            throw new IllegalArgumentException(\"The member must not be null\");\n+        }    \n+        return Modifier.isStatic(member.getModifiers());\n+    }\n+\n+    /**\n+     * Tests whether the specified field or method is \n+     * <code>static</code>.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is final\n+     */\n+    public static boolean isFinal(Member member) {\n+        if (member == null) {\n+            throw new IllegalArgumentException(\"The member must not be null\");\n+        }    \n+        return Modifier.isFinal(member.getModifiers());\n+    }\n+\n+    /**\n+     * Tests whether the specified field, method or constructor is \n+     * <code>public</code>.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is public scoped\n+     */\n+    public static boolean isPublicScope(Member member) {\n+        if (member == null) {\n+            throw new IllegalArgumentException(\"The member must not be null\");\n+        }    \n+        return Modifier.isStatic(member.getModifiers());\n+    }\n+\n+    /**\n+     * Tests whether the specified field, method or constructor is \n+     * <code>protected</code>.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is protected scoped\n+     */\n+    public static boolean isProtectedScope(Member member) {\n+        if (member == null) {\n+            throw new IllegalArgumentException(\"The member must not be null\");\n+        }    \n+        return Modifier.isProtected(member.getModifiers());\n+    }\n+\n+    /**\n+     * Tests whether the specified field, method or constructor is \n+     * package (default) scoped.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is package scoped\n+     */\n+    public static boolean isPackageScope(Member member) {\n+        return !(isPublicScope(member) || isProtectedScope(member) || isPrivateScope(member));\n+    }\n+\n+    /**\n+     * Tests whether the specified field, method or constructor is \n+     * <code>private</code>.\n+     * \n+     * @param member  the member to test, must not be null\n+     * @return true if the member is private scoped\n+     */\n+    public static boolean isPrivateScope(Member member) {\n+        if (member == null) {\n+            throw new IllegalArgumentException(\"The member must not be null\");\n+        }    \n+        return Modifier.isPrivate(member.getModifiers());\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a class object for the specified string.\n+     *\n+     * @param className  fully qualified class name to find, must not be empty\n+     * @return Class object for class\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the class name is empty\n+     */\n+    public static Class getClass(String className) throws ReflectionException {\n+        if (StringUtils.isEmpty(className)) {\n+            throw new IllegalArgumentException(\"The class name must not be null\");\n+        }\n+        try {\n+            return Class.forName(className);\n+    \n+        } catch (LinkageError ex) {\n+            throw new ReflectionException(getThrowableText(ex, \"getting class\", className, null, null), ex);\n+        } catch (Exception ex) {\n+            throw new ReflectionException(getThrowableText(ex, \"getting class\", className, null, null), ex);\n+        }\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Checks if the requested Class array is compatable with the specified\n+     * parameter array.\n+     * Primitive classes are handled correctly .\n+     * <p>\n+     * In other words, a <code>boolean</code> Class will be converted to \n+     * a <code>Boolean</code> Class and so on.\n+     *\n+     * @param requestedTypes  the class array requested\n+     * @param paramTypes  the actual class array for the method\n+     * @return true if the parameters are compatable\n+     */\n+    public static boolean isCompatable(Class[] requestedTypes, Class[] paramTypes) {\n+        if (ArrayUtils.isSameLength(requestedTypes, paramTypes) == false) {\n+            return false;\n+        }\n+        if (requestedTypes == null) {\n+            requestedTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (paramTypes == null) {\n+            paramTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        for (int i = 0; i < requestedTypes.length; i++) {\n+            if (ClassUtils.isAssignable(requestedTypes[i], paramTypes[i]) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Converts a primitive class to its matching object class.\n+     * Non-primitive classes are unaffected.\n+     * <p>\n+     * In other words, a <code>boolean</code> Class will be converted to \n+     * a <code>Boolean</code> Class and so on.\n+     *\n+     * @param cls  the class to convert\n+     * @return converted class\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Class convertPrimitiveClass(Class cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (cls.isPrimitive()) {\n+            if (Integer.TYPE.equals(cls)) {\n+                return Integer.class;\n+            } else if (Long.TYPE.equals(cls)) {\n+                return Long.class;\n+            } else if (Boolean.TYPE.equals(cls)) {\n+                return Boolean.class;\n+            } else if (Double.TYPE.equals(cls)) {\n+                return Double.class;\n+            } else if (Float.TYPE.equals(cls)) {\n+                return Float.class;\n+            } else if (Character.TYPE.equals(cls)) {\n+                return Character.class;\n+            } else if (Short.TYPE.equals(cls)) {\n+                return Short.class;\n+            } else if (Byte.TYPE.equals(cls)) {\n+                return Byte.class;\n+            }         \n+        }\n+        return cls;\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * Produces nicely formatted informational error messages for reflection errors.\n+     * \n+     * @param th  the throwable\n+     * @param desc  the short description of the action, such as 'getting field'\n+     * @param className  the class name being used\n+     * @param types  the parameter types\n+     * @param memberName  the name of the field or method\n+     * @return a suitable error message\n+     */\n+    public static String getThrowableText(Throwable th, String desc, String className, Class[] types, String memberName) {\n+        String message = null;\n+        try {\n+            throw th;\n+    \n+        } catch (NoSuchMethodException ex) {\n+            message = \"the method does not exist\";\n+        } catch (NoSuchFieldException ex) {\n+            message = \"the field does not exist\";\n+        } catch (ClassNotFoundException ex) {\n+            message = \"the class could not be found in the classpath\";\n+        } catch (InvocationTargetException ex) {\n+            message = \"the method threw an exception\";\n+        } catch (InstantiationException ex) {\n+            message = \"the class is abstract/interface/array/primitive\";\n+        } catch (IllegalAccessException ex) {\n+            message = \"the method was not public/accessible\";\n+        } catch (IllegalArgumentException ex) {\n+            message = \"the parameters did not match those expected\";\n+        } catch (SecurityException ex) {\n+            message = \"the security manager prevents reflection\";\n+        } catch (ExceptionInInitializerError ex) {\n+            message = \"the class initialization for static variables threw an exception\";\n+        } catch (ClassCircularityError ex) {\n+            message = \"a circularity has been detected while initializing a class\";\n+        } catch (ClassFormatError ex) {\n+            message = \"the class file is malformed or otherwise cannot be interpreted as a class\";\n+        } catch (IncompatibleClassChangeError ex) {\n+            message = \"the method references another class that has changed incompatibly since compile time\";\n+        } catch (UnsatisfiedLinkError ex) {\n+            message = \"no implementation found for a native method\";\n+        } catch (VerifyError ex) {\n+            message = \"the class file contains an internal inconsistency or security problem\";\n+        } catch (NoClassDefFoundError ex) {\n+            message = \"the class references another class that was present at compile time but is no longer available\";\n+        } catch (LinkageError ex) {\n+            message = \"the class references another class that has changed incompatibly since compile time\";\n+        } catch (Throwable ex) {\n+            message = null;\n+        }\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(ClassUtils.getShortClassName(th));\n+        buf.append(\" while \");\n+        buf.append(desc);\n+        buf.append(\" on Class '\");\n+        buf.append(className);\n+        buf.append(\"'\");\n+        if (types != null) {\n+            buf.append(\" for types \");\n+            buf.append(ArrayUtils.toString(types));\n+        }\n+        if (memberName != null) {\n+            buf.append(\" for method '\");\n+            buf.append(memberName);\n+            buf.append(\"'\");\n+        }\n+        if (message != null) {\n+            buf.append(\" - \");\n+            buf.append(message);\n+        }\n+        return buf.toString();\n+    }\n+    \n+}", "timestamp": 1035501174, "metainfo": ""}