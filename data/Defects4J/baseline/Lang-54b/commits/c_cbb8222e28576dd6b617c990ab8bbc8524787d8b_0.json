{"sha": "cbb8222e28576dd6b617c990ab8bbc8524787d8b", "log": "Transfer of some of Patterns over to Lang.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/Closure.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+/**\n+ * <code>Closure</code> defines an interface implemented by classes that\n+ * do something.\n+ *\n+ * @author <a href=\"mailto:nicolaken@apache.org\">Nicola Ken Barozzi</a>\n+ * @version $Id: Closure.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public interface Closure {\n+    \n+    /**\n+     * Does what it has to.\n+     *\n+     * @param description  the extra information needed to execute the \n+     *                     command\n+     *\n+     * @throws ClosureException (runtime) if the execution fails\n+     */\n+    public void execute(Object description);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/ClosureException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the Comand fails to execute.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:nicolaken@apache.org\">Nicola Ken Barozzi</a>\n+ * @version $Id: ClosureException.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class ClosureException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>ClosureException</code> without specified\n+     * detail message.\n+     */\n+    public ClosureException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>ClosureException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public ClosureException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ClosureException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public ClosureException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ClosureException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public ClosureException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/ClosureUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.functor.Predicate;\n+import org.apache.commons.lang.functor.PredicateUtils;\n+import org.apache.commons.lang.functor.Transformer;\n+import org.apache.commons.lang.functor.TransformerException;\n+import org.apache.commons.lang.functor.TransformerUtils;\n+/**\n+ * <code>ClosureUtils</code> provides reference implementations and utilities\n+ * for the Closure pattern interface. The supplied commands are:\n+ * <ul>\n+ * <li>Invoker - invokes a method on the input object\n+ * <li>For - repeatedly calls a command for a fixed number of times\n+ * <li>While - repeatedly calls a command while a predicate is true\n+ * <li>DoWhile - repeatedly calls a command while a predicate is true\n+ * <li>Chained - chains two or more commands together\n+ * <li>Switch - calls one command based on one or more predicates\n+ * <li>SwitchMap - calls one command looked up from a Map\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>NOP - does nothing\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied commands are Serializable.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ClosureUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class ClosureUtils {\n+\n+    /**\n+     * A Closure that always throws an exception\n+     */\n+    private static final Closure EXCEPTION_COMMAND = new ExceptionClosure();\n+    /**\n+     * A Closure that does nothing\n+     */\n+    private static final Closure NOP_COMMAND = new NOPClosure();\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected ClosureUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Closure that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the command\n+     */\n+    public static Closure exceptionClosure() {\n+        return EXCEPTION_COMMAND;\n+    }\n+\n+    /**\n+     * Gets a Closure that will do nothing.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the command\n+     */\n+    public static Closure nopClosure() {\n+        return NOP_COMMAND;\n+    }\n+\n+    /**\n+     * Creates a Closure that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @param transformer  the transformer to run each time in the command\n+     * @return the command.\n+     */\n+    public static Closure asClosure(Transformer transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"TransformerClosure: The transformer must not be null\");\n+        }\n+        return new TransformerClosure(transformer);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the command <code>count</code> times.\n+     *\n+     * @param count  the number of times to loop\n+     * @param command  the command to call repeatedly\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure forClosure(int count, Closure command) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"ForClosure: The loop count must not be less than zero, it was \" + count);\n+        }\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"ForClosure: The command must not be null\");\n+        }\n+        return new ForClosure(count, command);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the command repeatedly until the \n+     * predicate returns false.\n+     *\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @param command  the command to call repeatedly\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure whileClosure(Predicate predicate, Closure command) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"WhileClosure: The predicate must not be null\");\n+        }\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"WhileClosure: The command must not be null\");\n+        }\n+        return new WhileClosure(predicate, command, false);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the command once and then repeatedly\n+     * until the predicate returns false.\n+     *\n+     * @param command  the command to call repeatedly\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure doWhileClosure(Closure command, Predicate predicate) {\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"DoWhileClosure: The command must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"DoWhileClosure: The predicate must not be null\");\n+        }\n+        return new WhileClosure(predicate, command, true);\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the command's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @return the command\n+     * @throws IllegalArgumentException if the method name is null\n+     */\n+    public static Closure invokerClosure(String methodName) {\n+        return asClosure(TransformerUtils.invokerTransformer(methodName, null, null));\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the command's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the command\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Closure invokerClosure(String methodName, Class[] paramTypes, Object[] args) {\n+        return asClosure(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    /**\n+     * Create a new Closure that calls two Closures, passing the result of\n+     * the first into the second.\n+     * \n+     * @param command1  the first command\n+     * @param command2  the second command\n+     * @return the command\n+     * @throws IllegalArgumentException if either command is null\n+     */\n+    public static Closure chainedClosure(Closure command1, Closure command2) {\n+        Closure[] commands = new Closure[] { command1, command2 };\n+        validate(commands);\n+        return new ChainedClosure(commands);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each command in turn, passing the \n+     * result into the next command.\n+     * \n+     * @param commands  an array of commands to chain\n+     * @return the command\n+     * @throws IllegalArgumentException if the commands array is null\n+     * @throws IllegalArgumentException if the commands array has 0 elements\n+     * @throws IllegalArgumentException if any command in the array is null\n+     */\n+    public static Closure chainedClosure(Closure[] commands) {\n+        commands = copy(commands);\n+        validate(commands);\n+        return new ChainedClosure(commands);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each command in turn, passing the \n+     * result into the next command. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param commands  a collection of commands to chain\n+     * @return the command\n+     * @throws IllegalArgumentException if the commands collection is null\n+     * @throws IllegalArgumentException if the commands collection is empty\n+     * @throws IllegalArgumentException if any command in the collection is null\n+     */\n+    public static Closure chainedClosure(Collection commands) {\n+        if (commands == null) {\n+            throw new IllegalArgumentException(\"ChainedClosure: The command collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure[] cmds = new Closure[commands.size()];\n+        int i = 0;\n+        for (Iterator it = commands.iterator(); it.hasNext();) {\n+            cmds[i++] = (Closure) it.next();\n+        }\n+        validate(cmds);\n+        return new ChainedClosure(cmds);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of two commands depending \n+     * on the specified predicate.\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueClosure  the command called if the predicate is true\n+     * @param falseClosure  the command called if the predicate is false\n+     * @return the command\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either command is null\n+     */\n+    public static Closure switchClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+        return switchClosureInternal(new Predicate[] { predicate }, new Closure[] { trueClosure }, falseClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the commands depending \n+     * on the predicates. The command at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param commands  an array of commands to call\n+     * @return the command\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Closure switchClosure(Predicate[] predicates, Closure[] commands) {\n+        return switchClosureInternal(copy(predicates), copy(commands), null);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the commands depending \n+     * on the predicates. The command at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * command is called.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param commands  an array of commands to call\n+     * @param defaultClosure  the default to call if no predicate matches\n+     * @return the command\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Closure switchClosure(Predicate[] predicates, Closure[] commands, Closure defaultClosure) {\n+        return switchClosureInternal(copy(predicates), copy(commands), defaultClosure);\n+    }\n+    \n+    /**\n+     * Create a new Closure that calls one of the commands depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A command \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * command is called. The default command is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndClosures  a map of predicates to commands\n+     * @return the command\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any command in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Closure switchClosure(Map predicatesAndClosures) {\n+        Closure[] trs = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndClosures == null) {\n+            throw new IllegalArgumentException(\"SwitchClosure: The predicate and command map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure def = (Closure) predicatesAndClosures.remove(null);\n+        int size = predicatesAndClosures.size();\n+        trs = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndClosures.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            trs[i] = (Closure) entry.getValue();\n+            i++;\n+        }\n+        return switchClosureInternal(preds, trs, def);\n+    }\n+\n+    /**\n+     * Validate input and create command\n+     */\n+    private static Closure switchClosureInternal(Predicate[] predicates, Closure[] commands, Closure defaultClosure) {\n+        validate(predicates);\n+        validate(commands);\n+        if (predicates.length != commands.length) {\n+            throw new IllegalArgumentException(\"SwitchClosure: The predicate and command arrays must be the same size\");\n+        }\n+        if (defaultClosure == null) {\n+            defaultClosure = nopClosure();\n+        }\n+        return new SwitchClosure(predicates, commands, defaultClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that uses the input object as a key to find the\n+     * command to call. \n+     * <p>\n+     * The Map consists of object keys and Closure values. A command \n+     * is called if the input object equals the key. If there is no match, the\n+     * default command is called. The default command is set in the map\n+     * using a null key.\n+     * \n+     * @param objectsAndClosures  a map of objects to commands\n+     * @return the command\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any command in the map is null\n+     */\n+    public static Closure switchMapClosure(Map objectsAndClosures) {\n+        Closure[] trs = null;\n+        Predicate[] preds = null;\n+        if (objectsAndClosures == null) {\n+            throw new IllegalArgumentException(\"SwitchEqualsClosure: The obejct and command map must not be null\");\n+        }\n+        Closure def = (Closure) objectsAndClosures.remove(null);\n+        int size = objectsAndClosures.size();\n+        trs = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = objectsAndClosures.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = PredicateUtils.equalPredicate(entry.getKey());\n+            trs[i] = (Closure) entry.getValue();\n+            i++;\n+        }\n+        return switchClosure(preds, trs, def);\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param predicates  the predicates to copy\n+     */\n+    private static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param predicates  the predicates to validate\n+     */\n+    private static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"ClosureUtils: The predicate array must not be null\");\n+        }\n+        if (predicates.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"ClosureUtils: At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"ClosureUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param commands  the commands to copy\n+     */\n+    private static Closure[] copy(Closure[] commands) {\n+        if (commands == null) {\n+            return null;\n+        }\n+        return (Closure[]) commands.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param commands  the commands to validate\n+     */\n+    private static void validate(Closure[] commands) {\n+        if (commands == null) {\n+            throw new IllegalArgumentException(\"ClosureUtils: The command array must not be null\");\n+        }\n+        if (commands.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"ClosureUtils: At least 1 command must be specified in the command array, size was \" + commands.length);\n+        }\n+        for (int i = 0; i < commands.length; i++) {\n+            if (commands[i] == null) {\n+                throw new IllegalArgumentException(\"ClosureUtils: The command array must not contain a null command, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    // ExceptionClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionClosure always throws an exception\n+     */\n+    private static class ExceptionClosure implements Closure, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionClosure() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public void execute(Object input) {\n+            throw new ClosureException(\"ExceptionClosure invoked\");\n+        }\n+    }\n+\n+    // NOPClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NOPClosure does nothing\n+     */\n+    private static class NOPClosure implements Closure, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private NOPClosure() {\n+            super();\n+        }\n+\n+        /**\n+         * Do nothing\n+         */\n+        public void execute(Object input) {\n+            // do nothing\n+        }\n+    }\n+\n+    // TransformerClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * TransformerClosure returns the result of calling a Transformer.\n+     */\n+    private static class TransformerClosure implements Closure, Serializable {\n+\n+        private final Transformer iTransformer;\n+\n+        /**\n+         * Constructor to store factory\n+         */\n+        private TransformerClosure(Transformer transformer) {\n+            super();\n+            iTransformer = transformer;\n+        }\n+\n+        /**\n+         * Return the result of calling the factory\n+         */\n+        public void execute(Object input) {\n+            try {\n+                iTransformer.transform(input);\n+\n+            } catch (TransformerException ex) {\n+                throw new ClosureException(\"TransformerClosure: \" + ex.getMessage(), ex);\n+            }\n+        }\n+    }\n+\n+    // ChainedClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ChainedClosure calls a list of commands.\n+     */\n+    private static class ChainedClosure implements Closure, Serializable {\n+\n+        private final Closure[] iClosures;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ChainedClosure(Closure[] commands) {\n+            super();\n+            iClosures = commands;\n+        }\n+\n+        /**\n+         * Execute a list of commands\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iClosures.length; i++) {\n+                iClosures[i].execute(input);\n+            }\n+        }\n+    }\n+\n+    // SwitchClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * SwitchClosure calls the command whose predicate returns true.\n+     */\n+    private static class SwitchClosure implements Closure, Serializable {\n+\n+        private final Predicate[] iPredicates;\n+        private final Closure[] iClosures;\n+        private final Closure iDefault;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private SwitchClosure(Predicate[] predicates, Closure[] commands, Closure defaultClosure) {\n+            super();\n+            iPredicates = predicates;\n+            iClosures = commands;\n+            iDefault = defaultClosure;\n+        }\n+\n+        /**\n+         * Execute the command whose predicate returns true\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(input) == true) {\n+                    iClosures[i].execute(input);\n+                    return;\n+                }\n+            }\n+            iDefault.execute(input);\n+        }\n+    }\n+\n+    // ForClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ForClosure calls the command a fixed nunmber of times.\n+     */\n+    private static class ForClosure implements Closure, Serializable {\n+\n+        private final int iCount;\n+        private final Closure iClosure;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ForClosure(int count, Closure command) {\n+            super();\n+            iCount = count;\n+            iClosure = command;\n+        }\n+\n+        /**\n+         * Execute the command count times\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iCount; i++) {\n+                iClosure.execute(input);\n+            }\n+        }\n+    }\n+\n+    // WhileClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * WhileClosure calls the command until the predicate is false.\n+     */\n+    private static class WhileClosure implements Closure, Serializable {\n+\n+        private final Predicate iPredicate;\n+        private final Closure iClosure;\n+        private final boolean iDoLoop;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private WhileClosure(Predicate predicate, Closure command, boolean doLoop) {\n+            super();\n+            iPredicate = predicate;\n+            iClosure = command;\n+            iDoLoop = doLoop;\n+        }\n+\n+        /**\n+         * Execute the command until the predicate is false\n+         */\n+        public void execute(Object input) {\n+            if (iDoLoop) {\n+                iClosure.execute(input);\n+            }\n+            while (iPredicate.evaluate(input)) {\n+                iClosure.execute(input);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/Factory.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+/**\n+ * <code>Factory</code> defines an interface implemented by classes that\n+ * create objects.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: Factory.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public interface Factory {\n+    \n+    /**\n+     * Create a new object.\n+     *\n+     * @return an new object\n+     * @throws FactoryException (runtime) if the factory cannot create an object\n+     */\n+    public Object create();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/FactoryException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the a Factory cannot create the object as requested.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: FactoryException.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class FactoryException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>FactoryException</code> without specified\n+     * detail message.\n+     */\n+    public FactoryException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FactoryException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public FactoryException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FactoryException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FactoryException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FactoryException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FactoryException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/FactoryUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.lang.SerializationException;\n+import org.apache.commons.lang.SerializationUtils;\n+/**\n+ * <code>FactoryUtils</code> provides reference implementations and utilities\n+ * for the Factory pattern interface. The supplied factories are:\n+ * <ul>\n+ * <li>Prototype - clones a specified object\n+ * <li>Reflection - creates objects using reflection\n+ * <li>Constant - always returns the same object\n+ * <li>Null - always returns null\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied factories are Serializable.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: FactoryUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class FactoryUtils {\n+\n+    /**\n+     * A factory that always throws an exception\n+     */\n+    private static final Factory EXCEPTION_FACTORY = new ExceptionFactory();\n+    /**\n+     * A factory that always returns null\n+     */\n+    private static final Factory NULL_FACTORY = new ConstantFactory(null);\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected FactoryUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Factory that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the factory\n+     */\n+    public static Factory exceptionFactory() {\n+        return EXCEPTION_FACTORY;\n+    }\n+\n+    /**\n+     * Gets a Factory that will return null each time the factory is used.\n+     *\n+     * @return the factory\n+     */\n+    public static Factory nullFactory() {\n+        return NULL_FACTORY;\n+    }\n+\n+    /**\n+     * Creates a Factory that will return the same object each time the factory\n+     * is used. No check is made that the object is immutable. In general, only\n+     * immutable objects should use the constant factory. Mutable objects should\n+     * use the prototype factory.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the factory.\n+     */\n+    public static Factory constantFactory(Object constantToReturn) {\n+        return new ConstantFactory(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @param prototype  the object to clone each time in the factory\n+     * @return the factory\n+     * @throws IllegalArgumentException if the prototype is null\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    public static Factory prototypeFactory(Object prototype) {\n+        if (prototype == null) {\n+            throw new IllegalArgumentException(\"PrototypeFactory: The prototype must not be null\");\n+        }\n+        // TODO: move to cloneable pattern\n+        try {\n+            prototype.getClass().getMethod(\"clone\", null);\n+            return new PrototypeCloneFactory(prototype);\n+\n+        } catch (NoSuchMethodException ex) {\n+            try {\n+                prototype.getClass().getConstructor(new Class[] { prototype.getClass()});\n+                return new ReflectionFactory(prototype.getClass(), new Class[] { prototype.getClass()}, new Object[] { prototype });\n+\n+            } catch (NoSuchMethodException ex2) {\n+                if (prototype instanceof Serializable) {\n+                    return new PrototypeSerializationFactory((Serializable) prototype);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"PrototypeFactory: The prototype must be cloneable\");\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * a no-args constructor.\n+     *\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @return the factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     */\n+    public static Factory reflectionFactory(Class classToInstantiate) {\n+        return new ReflectionFactory(classToInstantiate);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * the arguments specified to this method.\n+     *\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @throws IllegalArgumentException if the constructor doesn't exist\n+     */\n+    public static Factory reflectionFactory(Class classToInstantiate, Class[] paramTypes, Object[] args) {\n+        return new ReflectionFactory(classToInstantiate, paramTypes, args);\n+    }\n+\n+    // ExceptionFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionFactory always throws an exception\n+     */\n+    private static class ExceptionFactory implements Factory, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionFactory() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public Object create() {\n+            throw new FactoryException(\"ExceptionFactory invoked\");\n+        }\n+    }\n+\n+    // ConstantFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantFactory returns the same instance each time.\n+     */\n+    private static class ConstantFactory implements Factory, Serializable {\n+\n+        private final Object iConstant;\n+\n+        /**\n+         * Constructor to store constant\n+         */\n+        private ConstantFactory(Object constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant\n+         */\n+        public Object create() {\n+            return iConstant;\n+        }\n+    }\n+\n+    // PrototypeCloneFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n+     */\n+    private static class PrototypeCloneFactory implements Factory, Serializable {\n+        private final Object iPrototype;\n+        private transient Method iCloneMethod;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeCloneFactory(Object prototype) {\n+            super();\n+            if (prototype == null) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The prototype must not be null\");\n+            }\n+            iPrototype = prototype;\n+\n+            findCloneMethod();\n+        }\n+\n+        /**\n+         * Find the Clone method for the class specified.\n+         */\n+        private void findCloneMethod() {\n+            try {\n+                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", null);\n+\n+            } catch (NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Return clone of prototype\n+         */\n+        public Object create() {\n+            // needed for post-serialization\n+            if (iCloneMethod == null) {\n+                findCloneMethod();\n+            }\n+\n+            try {\n+                return iCloneMethod.invoke(iPrototype, null);\n+\n+            } catch (IllegalAccessException ex) {\n+                throw new FactoryException(\"ReflectionFactory: Clone method must be public\", ex);\n+            } catch (InvocationTargetException ex) {\n+                throw new FactoryException(\"ReflectionFactory: Clone method threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+    // PrototypeSerializationFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n+     */\n+    private static class PrototypeSerializationFactory implements Factory, Serializable {\n+\n+        private final Serializable iPrototype;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeSerializationFactory(Serializable prototype) {\n+            super();\n+            if (prototype == null) {\n+                throw new IllegalArgumentException(\"PrototypeSerializationFactory: The prototype must not be null\");\n+            }\n+            iPrototype = prototype;\n+        }\n+\n+        /**\n+         * Return clone of prototype by serialization\n+         */\n+        public Object create() {\n+            try {\n+                return SerializationUtils.clone(iPrototype);\n+\n+            } catch (SerializationException ex) {\n+                throw new FactoryException(\"PrototypeSerializationFactory: Unable to clone by serialization\", ex);\n+            }\n+        }\n+    }\n+\n+    // ReflectionFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ReflectionFactory creates objects using reflection.\n+     */\n+    private static class ReflectionFactory implements Factory, Serializable {\n+\n+        private final Class iClassToInstantiate;\n+        private final Class[] iParamTypes;\n+        private final Object[] iArgs;\n+        private transient Constructor iConstructor = null;\n+\n+        /**\n+         * Constructor\n+         */\n+        public ReflectionFactory(Class classToInstantiate) {\n+            this(classToInstantiate, null, null);\n+        }\n+\n+        /* builds the object factory taking all the options needed to provide\n+         * arguments to a constructor.\n+         */\n+        public ReflectionFactory(Class classToInstantiate, Class[] paramTypes, Object[] args) {\n+            super();\n+            if (classToInstantiate == null) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The class to instantiate must not be null\");\n+            }\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The parameter types must match the arguments\");\n+            }\n+\n+            iClassToInstantiate = classToInstantiate;\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+\n+            findConstructor();\n+        }\n+\n+        /**\n+         * Find the Constructor for the class specified.\n+         */\n+        private void findConstructor() {\n+            try {\n+                iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n+\n+            } catch (NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The constructor must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Create the object using a constructor\n+         */\n+        public Object create() {\n+            // needed for post-serialization\n+            if (iConstructor == null) {\n+                findConstructor();\n+            }\n+\n+            try {\n+                return iConstructor.newInstance(iArgs);\n+\n+            } catch (InstantiationException ex) {\n+                throw new FactoryException(\"ReflectionFactory: InstantiationException\", ex);\n+            } catch (IllegalAccessException ex) {\n+                throw new FactoryException(\"ReflectionFactory: Constructor must be public\", ex);\n+            } catch (InvocationTargetException ex) {\n+                throw new FactoryException(\"ReflectionFactory: Constructor threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/Predicate.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+/**\n+ * <code>Predicate</code> defines an interface implemented by classes that\n+ * perform a predicate test on an object. Predicate instances can be used\n+ * to implement queries or to do filtering. \n+ * \n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: Predicate.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public interface Predicate {\n+    \n+    /**\n+     * Use the specified parameter to perform a test that returns true or false.\n+     *\n+     * @param object  the object to evaluate\n+     * @return true or false\n+     * @throws PredicateException (runtime) if the predicate encounters a problem\n+     */\n+    public boolean evaluate(Object object);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/PredicateException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the a Predicate encounters a problem.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: PredicateException.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class PredicateException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>PredicateException</code> without specified\n+     * detail message.\n+     */\n+    public PredicateException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>PredicateException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public PredicateException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>PredicateException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public PredicateException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>PredicateException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public PredicateException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/PredicateUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.functor.Transformer;\n+import org.apache.commons.lang.functor.TransformerException;\n+import org.apache.commons.lang.functor.TransformerUtils;\n+/**\n+ * <code>PredicateUtils</code> provides reference implementations and utilities\n+ * for the Predicate pattern interface. The supplied predicates are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>InstanceOf - true if the object is an instanceof a class\n+ * <li>Equal - true if the object equals() a specified object\n+ * <li>Identity - true if the object == a specified object\n+ * <li>Null - true if the object is null\n+ * <li>NotNull - true if the object is not null\n+ * <li>Unique - true if the object has not already been evaluated\n+ * <li>And/All - true if all of the predicates are true\n+ * <li>Or/Any - true if any of the predicates is true\n+ * <li>Either/One - true if only one of the predicate is true\n+ * <li>Neither/None - true if none of the predicates are true\n+ * <li>Not - true if the predicate is false, and vice versa\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>True - always return true\n+ * <li>False - always return false\n+ * <li>Exception - always throws an exception\n+ * <li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n+ * </ul>\n+ * All the supplied predicates are Serializable.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author Ola Berg\n+ * @version $Id: PredicateUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class PredicateUtils {\n+\n+    /**\n+     * A predicate that always throws an exception\n+     */\n+    private static final Predicate EXCEPTION_PREDICATE = new ExceptionPredicate();\n+    /**\n+     * A predicate that always returns true\n+     */\n+    private static final Predicate TRUE_PREDICATE = new ConstantPredicate(true);\n+    /**\n+     * A predicate that always returns false\n+     */\n+    private static final Predicate FALSE_PREDICATE = new ConstantPredicate(false);\n+    /**\n+     * A predicate that returns true if the object is null\n+     */\n+    private static final Predicate NULL_PREDICATE = new IdentityPredicate(null);\n+    /**\n+     * A predicate that returns true if the object is not null\n+     */\n+    private static final Predicate NOT_NULL_PREDICATE = new NotPredicate(NULL_PREDICATE);\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected PredicateUtils() {\n+        super();\n+    }\n+\n+    // Simple predicates\n+    //-----------------------------------------------------------------------------\n+\n+    /** \n+     * Gets a Predicate that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the factory\n+     */\n+    public static Predicate exceptionPredicate() {\n+        return EXCEPTION_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns true.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate truePredicate() {\n+        return TRUE_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns false.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate falsePredicate() {\n+        return FALSE_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is null.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate nullPredicate() {\n+        return NULL_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is not null.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate notNullPredicate() {\n+        return NOT_NULL_PREDICATE;\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object using equals().\n+     * \n+     * @param value  the value to compare against\n+     * @return the predicate\n+     */\n+    public static Predicate equalPredicate(Object value) {\n+        if (value == null) {\n+            return NULL_PREDICATE;\n+        }\n+        return new EqualPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object by identity.\n+     * \n+     * @param value  the value to compare against\n+     * @return the predicate\n+     */\n+    public static Predicate identityPredicate(Object value) {\n+        if (value == null) {\n+            return NULL_PREDICATE;\n+        }\n+        return new IdentityPredicate(value);\n+    }\n+    \n+    /**\n+     * Creates a Predicate that checks if the object passed in is of\n+     * a particular type, using instanceof.\n+     * \n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Predicate instanceofPredicate(Class type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"InstanceofPredicate: The type to check instanceof must not be null\");\n+        }\n+        return new InstanceofPredicate(type);\n+    }\n+\n+    /**\n+     * Creates a Predicate that returns true the first time an object is\n+     * encoutered, and false if the same object is received \n+     * again. The comparison is by equals().\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate uniquePredicate() {\n+        // must return new instance each time\n+        return new UniquePredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a \n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to \n+     * determine the predicate result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static Predicate invokerPredicate(String methodName){\n+        return asPredicate(TransformerUtils.invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a \n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to \n+     * determine the predicate result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Predicate invokerPredicate(String methodName, Class[] paramTypes, Object[] args){\n+        return asPredicate(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    // Boolean combinations\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that returns true only if both of the specified\n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate andPredicate(Predicate predicate1, Predicate predicate2) {\n+        return allPredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate allPredicate(Predicate[] predicates) {\n+        return new AllPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate allPredicate(Collection predicates) {\n+        return new AllPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if either of the specified\n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate orPredicate(Predicate predicate1, Predicate predicate2) {\n+        return anyPredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate anyPredicate(Predicate[] predicates) {\n+        return new AnyPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate anyPredicate(Collection predicates) {\n+        return new AnyPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if one, but not both, of the\n+     * specified predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate eitherPredicate(Predicate predicate1, Predicate predicate2) {\n+        return onePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate onePredicate(Predicate[] predicates) {\n+        return new OnePredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate onePredicate(Collection predicates) {\n+        return new OnePredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if neither of the specified \n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate neitherPredicate(Predicate predicate1, Predicate predicate2) {\n+        return nonePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate nonePredicate(Predicate[] predicates) {\n+        Predicate[] preds = validate(predicates);\n+        for (int i = 0; i < preds.length; i++) {\n+            preds[i] = notPredicate(preds[i]);\n+        }\n+        return new AllPredicate(preds);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate nonePredicate(Collection predicates) {\n+        Predicate[] preds = validate(predicates);\n+        for (int i = 0; i < preds.length; i++) {\n+            preds[i] = notPredicate(preds[i]);\n+        }\n+        return new AllPredicate(preds);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if the specified predicate\n+     * returns false and vice versa.\n+     * \n+     * @param predicate  the predicate to not\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static Predicate notPredicate(Predicate predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"NotPredicate: The predicate must not be null\");\n+        }\n+        return new NotPredicate(predicate);\n+    }\n+\n+    // Adaptors\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that wraps a Transformer. The Transformer must\n+     * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n+     * will be thrown.\n+     * \n+     * @param transformer  the transformer to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     */\n+    public static Predicate asPredicate(Transformer transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"TransformerPredicate: The transformer to call must not be null\");\n+        }\n+        return new TransformerPredicate(transformer);\n+    }\n+\n+    // Null handlers\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that throws an exception if the input object is null, \n+     * otherwise it calls the specified Predicate. This allows null handling \n+     * behaviour to be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsExceptionPredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsExceptionPredicate( predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns false if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsFalsePredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsFalsePredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns true if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsTruePredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsTruePredicate(predicate);\n+    }\n+\n+    /**\n+     * Convert a collection to an array using the iterator.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return predicate array\n+     */\n+    private static Predicate[] validate(Collection predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"PredicateUtils: The predicate collection must not be null\");\n+        }\n+        if (predicates.size() < 2) {\n+            throw new IllegalArgumentException(\n+                \"PredicateUtils: At least 2 predicates must be specified in the predicate collection, size was \" + predicates.size());\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Predicate[] preds = new Predicate[predicates.size()];\n+        int i = 0;\n+        for (Iterator it = predicates.iterator(); it.hasNext();) {\n+            preds[i] = (Predicate) it.next();\n+            if (preds[i] == null) {\n+                throw new IllegalArgumentException(\"PredicateUtils: The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            i++;\n+        }\n+        return preds;\n+    }\n+    \n+    /**\n+     * Validate method shared amongst predicate implementations.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return predicate array (copy)\n+     */\n+    private static Predicate[] validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"PredicateUtils: The predicate array must not be null\");\n+        }\n+        if (predicates.length < 2) {\n+            throw new IllegalArgumentException(\n+                \"PredicateUtils: At least 2 predicates must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        Predicate[] preds = new Predicate[predicates.length];\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"PredicateUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            preds[i] = predicates[i];\n+        }\n+        return preds;\n+    }\n+\n+    // ExceptionPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionPredicate always throws an exception\n+     */\n+    private static class ExceptionPredicate implements Predicate, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionPredicate() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public boolean evaluate(Object object) {\n+            throw new PredicateException(\"ExceptionPredicate invoked\");\n+        }\n+    }\n+\n+    // ConstantPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantPredicate returns the same instance each time.\n+     */\n+    private static class ConstantPredicate implements Predicate, Serializable {\n+\n+        private final boolean iConstant;\n+\n+        /**\n+         * Constructor to store constant\n+         */\n+        private ConstantPredicate(boolean constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant\n+         */\n+        public boolean evaluate(Object object) {\n+            return iConstant;\n+        }\n+    }\n+\n+    // AllPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * AllPredicate returns true if all predicates return true\n+     */\n+    private static class AllPredicate implements Predicate, Serializable {\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private AllPredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if all predicates return true\n+         */\n+        public boolean evaluate(Object object) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object) == false) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // AnyPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * AnyPredicate returns true if one of the predicates return true\n+     */\n+    private static class AnyPredicate implements Predicate, Serializable {\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private AnyPredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if one of the predicates returns true\n+         */\n+        public boolean evaluate(Object object) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // OnePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * OnePredicate returns true if only one of the predicates return true\n+     */\n+    private static class OnePredicate implements Predicate, Serializable {\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private OnePredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if only one of the predicates returns true\n+         */\n+        public boolean evaluate(Object object) {\n+            boolean match = false;\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object)) {\n+                    if (match) {\n+                        return false;\n+                    }\n+                    match = true;\n+                }\n+            }\n+            return match;\n+        }\n+    }\n+\n+    // NotPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NotPredicate returns the opposite of the wrapped predicate\n+     */\n+    private static class NotPredicate implements Predicate, Serializable {\n+        private final Predicate iPredicate;\n+\n+        /**\n+         * Constructor\n+         */\n+        private NotPredicate(Predicate predicate) {\n+            super();\n+            iPredicate = predicate;\n+        }\n+\n+        /**\n+         * Return true if the wrapped predicate returns false, and vice versa\n+         */\n+        public boolean evaluate(Object object) {\n+            return !iPredicate.evaluate(object);\n+        }\n+    }\n+\n+    // InstanceofPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InstanceofPredicate checks the type of an object\n+     */\n+    private static class InstanceofPredicate implements Predicate, Serializable {\n+        private final Class iType;\n+\n+        /**\n+         * Constructor\n+         */\n+        public InstanceofPredicate(Class type) {\n+            super();\n+            iType = type;\n+        }\n+\n+        /**\n+         * Return true if the object is an instanceof the type of the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iType.isInstance(object);\n+        }\n+    }\n+\n+    // EqualPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * EqualPredicate that checks if the object is a particular value by equals().\n+     */\n+    private static class EqualPredicate implements Predicate, Serializable {\n+        private final Object iValue;\n+\n+        /**\n+         * Constructor\n+         */\n+        public EqualPredicate(Object value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        /**\n+         * Return true if the object is equals() to the value stored in the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iValue.equals(object);\n+        }\n+    }\n+\n+    // IdentityPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * IdentityPredicate that checks if the object is a particular value by identity.\n+     */\n+    private static class IdentityPredicate implements Predicate, Serializable {\n+        private final Object iValue;\n+\n+        /**\n+         * Constructor\n+         */\n+        public IdentityPredicate(Object value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        /**\n+         * Return true if the object is equals() to the value stored in the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iValue == object;\n+        }\n+    }\n+\n+    // UniquePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * UniquePredicate returns true the first time an object is\n+     * encoutered, and false if the same object is received \n+     * again using equals().\n+     */\n+    private static class UniquePredicate implements Predicate, Serializable {\n+        private final Set iSet = new HashSet();\n+\n+        /**\n+         * Constructor\n+         */\n+        public UniquePredicate() {\n+            super();\n+        }\n+\n+        /**\n+         * Return true the first time, and false subsequant times\n+         * that an object is encountered, using equals().\n+         */\n+        public boolean evaluate(Object object) {\n+            return iSet.add(object);\n+        }\n+    }\n+\n+    // TransformerPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * TransformerPredicate returns the result of the Transformer as a boolean.\n+     */\n+    private static class TransformerPredicate implements Predicate, Serializable {\n+\n+        private final Transformer iTransformer;\n+\n+        /**\n+         * Constructor\n+         */\n+        public TransformerPredicate(Transformer transformer) {\n+            super();\n+            iTransformer = transformer;\n+        }\n+\n+        /**\n+         * Return the boolean result of a Transformer\n+         */\n+        public boolean evaluate(Object object) {\n+            Object result = null;\n+            try {\n+                result = iTransformer.transform(object);\n+\n+            } catch (TransformerException ex) {\n+                throw new PredicateException(\"TransformerPredicate: \" + ex.getMessage(), ex);\n+            }\n+            if (result instanceof Boolean == false) {\n+                throw new PredicateException(\n+                    \"TransformerPredicate: Transformer must return an instanceof Boolean, it was a \"\n+                        + (result == null ? \"null object\" : result.getClass().getName()));\n+            }\n+            return ((Boolean) result).booleanValue();\n+        }\n+    }\n+\n+    // NullIsExceptionPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsExceptionPredicate returns an exception if null is passed in.\n+     */\n+    private static class NullIsExceptionPredicate implements Predicate, Serializable {\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsExceptionPredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return an exception if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                throw new PredicateException(\"NullIsExceptionPredicate: Input Object must not be null\");\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+    // NullIsFalsePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsFalsePredicate returns false if null is passed in.\n+     */\n+    private static class NullIsFalsePredicate implements Predicate, Serializable {\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsFalsePredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return false if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                return false;\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+    // NullIsTruePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsTruePredicate returns true if null is passed in.\n+     */\n+    private static class NullIsTruePredicate implements Predicate, Serializable {\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsTruePredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return true if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                return true;\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/Transformer.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+/**\n+ * <code>Transformer</code> defines an interface implemented by classes that\n+ * transform one object into another. The original object is left unchanged.\n+ * Transformers are typically used for type conversions, or extracting data\n+ * from an object.\n+ * \n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: Transformer.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public interface Transformer {\n+\n+    /**\n+     * Transforms the input object (leaving it unchanged) into some output object.\n+     *\n+     * @param input  the object to be transformed\n+     * @return a transformed object\n+     * @throws TransformException (runtime) if the transform cannot be completed\n+     */\n+    public Object transform(Object input);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/TransformerException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the a Transformer encounters a problem.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: TransformerException.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class TransformerException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>TransformerException</code> without specified\n+     * detail message.\n+     */\n+    public TransformerException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformerException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public TransformerException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformerException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public TransformerException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformerException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public TransformerException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/TransformerUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <code>TransformerUtils</code> provides reference implementations and \n+ * utilities for the Transformer pattern interface. The supplied transformers are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>Clone - returns a clone of the input object\n+ * <li>Constant - always returns the same object\n+ * <li>Closure - performs a Closure and returns the input object\n+ * <li>Predicate - returns the result of the predicate as a Boolean\n+ * <li>Factory - returns a new object from a factory\n+ * <li>Chained - chains two or more transformers together\n+ * <li>Switch - calls one transformer based on one or more predicates\n+ * <li>SwitchMap - calls one transformer looked up from a Map\n+ * <li>Instantiate - the Class input object is instantiated\n+ * <li>Map - returns an object from a supplied Map\n+ * <li>Null - always returns null\n+ * <li>NOP - returns the input object, which should be immutable\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied transformers are Serializable.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: TransformerUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ */\n+public class TransformerUtils {\n+\n+    /**\n+     * A transformer that always throws an exception\n+     */\n+    private static final Transformer EXCEPTION_TRANSFORMER = new ExceptionTransformer();\n+    /**\n+     * A transformer that always returns null\n+     */\n+    private static final Transformer NULL_TRANSFORMER = new ConstantTransformer(null);\n+    /**\n+     * A transformer that returns the input object\n+     */\n+    private static final Transformer NOP_TRANSFORMER = new NOPTransformer();\n+    /**\n+     * A transformer that clones the input object\n+     */\n+    private static final Transformer CLONE_TRANSFORMER = new CloneTransformer();\n+    /**\n+     * A transformer that creates an object from a Class\n+     */\n+    private static final Transformer INSTANTIATE_TRANSFORMER = new InstantiateTransformer(null, null);\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected TransformerUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a transformer that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer exceptionTransformer() {\n+        return EXCEPTION_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that always returns null.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer nullTransformer() {\n+        return NULL_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that returns the input object.\n+     * The input object should be immutable to maintain the\n+     * contract of Transformer (although this is not checked).\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer nopTransformer() {\n+        return NOP_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a clone of the input\n+     * object. The input object will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer cloneTransformer() {\n+        return CLONE_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Creates a Transformer that will return the same object each time the \n+     * transformer is used.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer constantTransformer(Object constantToReturn) {\n+        return new ConstantTransformer(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Closure each time the transformer is used.\n+     * The transformer returns the input object.\n+     *\n+     * @param command  the command to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Closure command) {\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"ClosureTransformer: The command must not be null\");\n+        }\n+        return new ClosureTransformer(command);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Predicate each time the transformer is used.\n+     * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n+     *\n+     * @param predicate  the predicate to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Predicate predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"PredicateTransformer: The predicate must not be null\");\n+        }\n+        return new PredicateTransformer(predicate);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @param factory  the factory to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Factory factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"FactoryTransformer: The factory must not be null\");\n+        }\n+        return new FactoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls two transformers, passing the result of\n+     * the first into the second.\n+     * \n+     * @param transformer1  the first transformer\n+     * @param transformer2  the second transformer\n+     * @return the transformer\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    public static Transformer chainedTransformer(Transformer transformer1, Transformer transformer2) {\n+        Transformer[] trs = new Transformer[] {transformer1, transformer2};\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer.\n+     * \n+     * @param transformers  an array of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if the transformers array has 0 elements\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static Transformer chainedTransformer(Transformer[] transformers) {\n+        Transformer[] trs = copy(transformers);\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param transformers  a collection of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if the transformers collection is empty\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    public static Transformer chainedTransformer(Collection transformers) {\n+        Transformer[] trs = null;\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"ChainedTransformer: The transformer collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        trs = new Transformer[transformers.size()];\n+        int i = 0;\n+        for (Iterator it = transformers.iterator(); it.hasNext();) {\n+            trs[i++] = (Transformer) it.next();\n+        }\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of two transformers depending \n+     * on the specified predicate.\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueTransformer  the transformer called if the predicate is true\n+     * @param falseTransformer  the transformer called if the predicate is false\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    public static Transformer switchTransformer(Predicate predicate, Transformer trueTransformer, Transformer falseTransformer) {\n+        return switchTransformerInternal(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, null is returned.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers) {\n+        return switchTransformerInternal(copy(predicates), copy(transformers), null);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @param defaultTransformer  the default to call if no predicate matches\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        return switchTransformerInternal(copy(predicates), copy(transformers), defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. If no default transformer is set, null will be returned in a default\n+     * case. The ordering is that of the iterator() method on the entryset collection \n+     * of the map.\n+     * \n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Transformer switchTransformer(Map predicatesAndTransformers) {\n+        Transformer[] trs = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndTransformers == null) {\n+            throw new IllegalArgumentException(\"SwitchTransformer: The predicate and transformer map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer def = (Transformer) predicatesAndTransformers.remove(null);\n+        int size = predicatesAndTransformers.size();\n+        trs = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndTransformers.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            trs[i] = (Transformer) entry.getValue();\n+            i++;\n+        }\n+        return switchTransformerInternal(preds, trs, def);\n+    }\n+\n+    /**\n+     * Validate input and create transformer\n+     */\n+    private static Transformer switchTransformerInternal(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        validate(predicates);\n+        validate(transformers);\n+        if (predicates.length != transformers.length) {\n+            throw new IllegalArgumentException(\"SwitchTransformer: The predicate and transformer arrays must be the same size\");\n+        }\n+        if (defaultTransformer == null) {\n+            defaultTransformer = nullTransformer();\n+        }\n+        return new SwitchTransformer(predicates, transformers, defaultTransformer);\n+    }\n+    \n+    /**\n+     * Create a new Transformer that uses the input object as a key to find the\n+     * transformer to call. \n+     * <p>\n+     * The Map consists of object keys and Transformer values. A transformer \n+     * is called if the input object equals the key. If there is no match, the\n+     * default transformer is called. The default transformer is set in the map\n+     * using a null key. If no default is set, null will be returned in a default case.\n+     * \n+     * @param objectsAndTransformers  a map of objects to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     */\n+    public static Transformer switchMapTransformer(Map objectsAndTransformers) {\n+        Transformer[] trs = null;\n+        Predicate[] preds = null;\n+        if (objectsAndTransformers == null) {\n+            throw new IllegalArgumentException(\"SwitchEqualsTransformer: The obejct and transformer map must not be null\");\n+        }\n+        Transformer def = (Transformer) objectsAndTransformers.remove(null);\n+        int size = objectsAndTransformers.size();\n+        trs = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = objectsAndTransformers.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = PredicateUtils.equalPredicate(entry.getKey());\n+            trs[i] = (Transformer) entry.getValue();\n+            i++;\n+        }\n+        return switchTransformer(preds, trs, def);\n+    }\n+\n+    /**\n+     * Gets a Transformer that expects an input Class object that it will instantiate.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer instantiateTransformer() {\n+        return INSTANTIATE_TRANSFORMER;\n+    }\n+\n+    /** \n+     * Creates a Transformer that expects an input Class object that it will \n+     * instantiate. The constructor used is determined by the arguments specified\n+     * to this method.\n+     *\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Transformer instantiateTransformer(Class[] paramTypes, Object[] args) {\n+        return new InstantiateTransformer(paramTypes, args);\n+    }\n+\n+    /** \n+     * Creates a Transformer that uses the passed in Map to transform the input \n+     * object (as a simple lookup).\n+     *\n+     * @param map  the map to use to transform the objects\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static Transformer mapTransformer(Map map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"MapTransformer: The map must not be null\");\n+        }\n+        return new MapTransformer(map);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method must have no parameters. If the input object is null, \n+     * null is returned.\n+     * <p>\n+     * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n+     * will call the <code>getName/code> method on the input object to \n+     * determine the transformer result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static Transformer invokerTransformer(String methodName){\n+        return new InvokerTransformer(methodName, null, null);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method parameters are specified. If the input object is null, \n+     * null is returned.\n+     * \n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Transformer invokerTransformer(String methodName, Class[] paramTypes, Object[] args){\n+        return new InvokerTransformer(methodName, paramTypes, args);\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param predicates  the predicates to copy\n+     */\n+    private static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param predicates  the predicates to validate\n+     */\n+    private static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"TransformerUtils: The predicate array must not be null\");\n+        }\n+        if (predicates.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"TransformerUtils: At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"TransformerUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param transformers  the transformers to copy\n+     */\n+    private static Transformer[] copy(Transformer[] transformers) {\n+        if (transformers == null) {\n+            return null;\n+        }\n+        return (Transformer[]) transformers.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param transformers  the transformers to validate\n+     */\n+    private static void validate(Transformer[] transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"TransformerUtils: The transformer array must not be null\");\n+        }\n+        if (transformers.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"TransformerUtils: At least 1 transformer must be specified in the transformer array, size was \" + transformers.length);\n+        }\n+        for (int i = 0; i < transformers.length; i++) {\n+            if (transformers[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"TransformerUtils: The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    // ExceptionTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionTransformer always throws an exception.\n+     */\n+    private static class ExceptionTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw exception\n+         */\n+        public Object transform(Object input) {\n+            throw new TransformerException(\"ExceptionTransformer invoked\");\n+        }\n+    }\n+\n+    // NOPTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NOPTransformer returns the input object.\n+     */\n+    private static class NOPTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private NOPTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Return the input object\n+         */\n+        public Object transform(Object input) {\n+            return input;\n+        }\n+    }\n+\n+    // CloneTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * CloneTransformer returns a clone of the input object.\n+     */\n+    private static class CloneTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private CloneTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns a clone of the input object\n+         */\n+        public Object transform(Object input) {\n+            if (input == null) {\n+                return null;\n+            }\n+            try {\n+                return FactoryUtils.prototypeFactory(input).create();\n+\n+            } catch (IllegalArgumentException ex) {\n+                throw new TransformerException(\"CloneTransformer\", ex);\n+            } catch (FactoryException ex) {\n+                throw new TransformerException(\"CloneTransformer\", ex);\n+            }\n+        }\n+    }\n+\n+    // ConstantTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantTransformer returns the same instance each time.\n+     */\n+    private static class ConstantTransformer implements Transformer, Serializable {\n+\n+        private final Object iConstant;\n+\n+        /**\n+         * Constructor to store constant\n+         */\n+        private ConstantTransformer(Object constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant\n+         */\n+        public Object transform(Object input) {\n+            return iConstant;\n+        }\n+    }\n+\n+    // ClosureTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ClosureTransformer executes a Closure object.\n+     */\n+    private static class ClosureTransformer implements Transformer, Serializable {\n+\n+        private final Closure iClosure;\n+\n+        /**\n+         * Constructor to store command\n+         */\n+        private ClosureTransformer(Closure command) {\n+            super();\n+            iClosure = command;\n+        }\n+\n+        /**\n+         * Exceute the command and return the input\n+         */\n+        public Object transform(Object input) {\n+            try {\n+                iClosure.execute(input);\n+                return input;\n+\n+            } catch (ClosureException ex) {\n+                throw new TransformerException(\"ClosureTransformer: \" + ex.getMessage(), ex);\n+            }\n+        }\n+    }\n+\n+    // PredicateTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PredicateTransformer evaluates a Predicate object.\n+     */\n+    private static class PredicateTransformer implements Transformer, Serializable {\n+\n+        private final Predicate iPredicate;\n+\n+        /**\n+         * Constructor to store predicate\n+         */\n+        private PredicateTransformer(Predicate predicate) {\n+            super();\n+            iPredicate = predicate;\n+        }\n+\n+        /**\n+         * Evaluate the predicate and return the result as a Boolean\n+         */\n+        public Object transform(Object input) {\n+            try {\n+                return new Boolean(iPredicate.evaluate(input));\n+\n+            } catch (PredicateException ex) {\n+                throw new TransformerException(\"PredicateTransformer: \" + ex.getMessage(), ex);\n+            }\n+        }\n+    }\n+\n+    // FactoryTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * FactoryTransformer returns the result of calling a Factory.\n+     */\n+    private static class FactoryTransformer implements Transformer, Serializable {\n+\n+        private final Factory iFactory;\n+\n+        /**\n+         * Constructor to store factory\n+         */\n+        private FactoryTransformer(Factory factory) {\n+            super();\n+            iFactory = factory;\n+        }\n+\n+        /**\n+         * Return the result of calling the factory\n+         */\n+        public Object transform(Object input) {\n+            try {\n+                return iFactory.create();\n+\n+            } catch (FactoryException ex) {\n+                throw new TransformerException(\"FactoryTransformer: \" + ex.getMessage(), ex);\n+            }\n+        }\n+    }\n+\n+    // ChainedTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ChainedTransformer returns the result of calling a list of transformers.\n+     */\n+    private static class ChainedTransformer implements Transformer, Serializable {\n+\n+        private final Transformer[] iTransformers;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ChainedTransformer(Transformer[] transformers) {\n+            super();\n+            iTransformers = transformers;\n+        }\n+\n+        /**\n+         * Returns the result of calling a list of transformers\n+         */\n+        public Object transform(Object object) {\n+            for (int i = 0; i < iTransformers.length; i++) {\n+                object = iTransformers[i].transform(object);\n+            }\n+            return object;\n+        }\n+    }\n+\n+    // SwitchTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * SwitchTransformer returns the result of the transformer whose predicate returns true.\n+     */\n+    private static class SwitchTransformer implements Transformer, Serializable {\n+\n+        private final Predicate[] iPredicates;\n+        private final Transformer[] iTransformers;\n+        private final Transformer iDefault;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+            super();\n+            iPredicates = predicates;\n+            iTransformers = transformers;\n+            iDefault = defaultTransformer;\n+        }\n+\n+        /**\n+         * Returns the result of the transformer whose predicate returns true\n+         */\n+        public Object transform(Object input) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(input) == true) {\n+                    return iTransformers[i].transform(input);\n+                }\n+            }\n+            return iDefault.transform(input);\n+        }\n+    }\n+\n+    // InstantiateTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InstantiateTransformer returns the result of calling a Factory.\n+     */\n+    private static class InstantiateTransformer implements Transformer, Serializable {\n+\n+        private final Class[] iParamTypes;\n+        private final Object[] iArgs;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private InstantiateTransformer(Class[] paramTypes, Object[] args) {\n+            super();\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"InstantiateTransformer: The parameter types must match the arguments\");\n+            }\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+        }\n+\n+        /**\n+         * Return the result of calling the factory\n+         */\n+        public Object transform(Object input) {\n+            try {\n+                if (input instanceof Class == false) {\n+                    throw new TransformerException(\n+                        \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n+                            + (input == null ? \"null object\" : input.getClass().getName()));\n+                }\n+                return FactoryUtils.reflectionFactory((Class) input, iParamTypes, iArgs).create();\n+\n+            } catch (IllegalArgumentException ex) {\n+                throw new TransformerException(\"InstantiateTransformer\", ex);\n+            } catch (FactoryException ex) {\n+                throw new TransformerException(\"InstantiateTransformer\", ex);\n+            }\n+        }\n+    }\n+\n+    // MapTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * MapTransformer returns the result by looking up in the map.\n+     */\n+    private static class MapTransformer implements Transformer, Serializable {\n+\n+        private final Map iMap;\n+\n+        /**\n+         * Constructor to store map\n+         */\n+        private MapTransformer(Map map) {\n+            super();\n+            iMap = map;\n+        }\n+\n+        /**\n+         * Returns the result by looking up in the map\n+         */\n+        public Object transform(Object input) {\n+            return iMap.get(input);\n+        }\n+    }\n+\n+    // InvokerTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InvokerTransformer returns the result of invoking the specified method on \n+     * the input object.\n+     */\n+    private static class InvokerTransformer implements Transformer, Serializable {\n+        private final String iMethodName;\n+        private final Class[] iParamTypes;\n+        private final Object[] iArgs;\n+\n+        /**\n+         * Constructor\n+         */\n+        public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n+            super();\n+            if (methodName == null) {\n+                throw new IllegalArgumentException(\"InvokerTransformer: The method to invoke must not be null\");\n+            }\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"InvokerTransformer: The parameter types must match the arguments\");\n+            }\n+\n+            iMethodName = methodName;\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+        }\n+\n+        /**\n+         * Execute the command based on the input object.\n+         */\n+        public Object transform(Object input) {\n+            if (input == null) {\n+                return null;\n+            }\n+            try {\n+                Class cls = input.getClass();\n+                Method method = cls.getMethod(iMethodName, iParamTypes);\n+                return method.invoke(input, iArgs);\n+                \n+            } catch (NoSuchMethodException ex) {\n+                throw new TransformerException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n+            } catch (IllegalAccessException ex) {\n+                throw new TransformerException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n+            } catch (InvocationTargetException ex) {\n+                throw new TransformerException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1036514668, "metainfo": ""}