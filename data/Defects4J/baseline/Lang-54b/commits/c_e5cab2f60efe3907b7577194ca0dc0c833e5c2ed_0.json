{"sha": "e5cab2f60efe3907b7577194ca0dc0c833e5c2ed", "log": "Added Collection APIs for the excludeFieldNames as suggested at the end of LANG-226  ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.Comparator;\n import java.util.List;\n \n      *\n      * @param lhs  left-hand object\n      * @param rhs  right-hand object\n-     * @param excludeFields  fields to exclude\n+     * @param excludeFields  Collection of String fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  array of fields to exclude\n      * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n      *  is less than, equal to, or greater than <code>rhs</code>\n      * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.List;\n \n /**\n      *\n      * @param lhs  <code>this</code> object\n      * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n      * @param excludeFields  array of field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Collection;\n import java.util.List;\n \n /**\n      */\n     public static int reflectionHashCode(Object object) {\n         return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants\n+     * needed to build a hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection /*String*/ excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n      *            The field names to exclude. Null excludes nothing.\n      * @return The toString value.\n      */\n-    public static String toStringExclude(Object object, Collection excludeFieldNames) {\n+    public static String toStringExclude(Object object, Collection /*String*/ excludeFieldNames) {\n         return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n     }\n \n      *            The collection to convert\n      * @return A new array of Strings.\n      */\n-    private static String[] toNoNullStringArray(Collection collection) {\n+    static String[] toNoNullStringArray(Collection collection) {\n         if (collection == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n      *            The array to check\n      * @return The given array or a new array without null.\n      */\n-    private static String[] toNoNullStringArray(Object[] array) {\n+    static String[] toNoNullStringArray(Object[] array) {\n         ArrayList list = new ArrayList(array.length);\n         for (int i = 0; i < array.length; i++) {\n             Object e = array[i];", "timestamp": 1151014844, "metainfo": ""}