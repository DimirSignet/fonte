{"sha": "d23b22c78078ee7468e797e80188ae9508c0eee0", "log": "Initial copy from jakarta-commons-sandbox   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/CharRange.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+/**\n+ * A range of characters. Able to understand the idea of a contiguous \n+ * sublist of an alphabet, a negated concept, and a set of characters.\n+ * Used by CharSet to handle sets of characters.\n+ *\n+ * @author <a href=\"bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: CharRange.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+class CharRange {\n+\n+    /**\n+     * Used internally to represent null in a char.\n+     */\n+    private static char UNSET;\n+\n+    private char start;\n+    private char close;\n+    private boolean negated;\n+\n+    /**\n+     * Construct a CharRange over a single character.\n+     *\n+     * @param start char over which this range is placed\n+     */\n+    public CharRange(char start) {\n+        this.start = start;\n+    }\n+\n+    /**\n+     * Construct a CharRange over a set of characters.\n+     *\n+     * @param start  char start character in this range. inclusive\n+     * @param close  char close character in this range. inclusive\n+     */\n+    public CharRange(char start, char close) {\n+        this.start = start;\n+        this.close = close;\n+    }\n+\n+    /**\n+     * Construct a CharRange over a set of characters.\n+     *\n+     * @param start  String start first character is in this range (inclusive).\n+     * @param close  String first character is close character in this\n+     * range (inclusive).\n+     */\n+    public CharRange(String start, String close) {\n+        this.start = start.charAt(0);\n+        this.close = close.charAt(0);\n+    }\n+\n+    /**\n+     * Get the start character for this character range\n+     * \n+     * @return start char (inclusive)\n+     */\n+    public char getStart() {\n+        return this.start;\n+    }\n+\n+    /**\n+     * Get the end character for this character range\n+     * \n+     * @return end char (inclusive)\n+     */\n+    public char getEnd() {\n+        return this.close;\n+    }\n+\n+    /**\n+     * Set the start character for this character range\n+     * \n+     * @param ch  start char (inclusive)\n+     */\n+    public void setStart(char ch) {\n+        this.start = ch;\n+    }\n+\n+    /**\n+     * Set the end character for this character range\n+     * \n+     * @param ch  start char (inclusive)\n+     */\n+    public void setEnd(char ch) {\n+        this.close = ch;\n+    }\n+\n+    /**\n+     * Is this CharRange over many characters\n+     *\n+     * @return boolean true is many characters\n+     */\n+    public boolean isRange() {\n+        return this.close != UNSET;\n+    }\n+\n+    /**\n+     * Is the passed in character inside this range\n+     *\n+     * @return boolean true is in range\n+     */\n+    public boolean inRange(char ch) {\n+        if(isRange()) {\n+            return ((ch >= start) && (ch <= close) );\n+        } else {\n+            return start == ch;\n+        }\n+    }\n+\n+    /**\n+     * Checks if this CharRange is negated.\n+     *\n+     * @return boolean true is negated\n+     */\n+    public boolean isNegated() {\n+        return negated;\n+    }\n+\n+    /**\n+     * Sets this character range to be negated or not. \n+     * This implies that this CharRange is over all characters except \n+     * the ones in this range.\n+     * \n+     * @param negated  true to negate the range\n+     */\n+    public void setNegated(boolean negated) {\n+        this.negated = negated;\n+    }\n+\n+    /**\n+     * Output a string representation of the character range\n+     * \n+     * @return string representation\n+     */\n+    public String toString() {\n+        String str = \"\";\n+        if(isNegated()) {\n+            str += \"^\";\n+        }\n+        str += start;\n+        if(isRange()) {\n+            str += \"-\";\n+            str += close;\n+        }\n+        return str;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/CharSet.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.LinkedList;\n+/**\n+ * A set of characters. You can iterate over the characters in the \n+ * set. \n+ *\n+ * @author <a href=\"bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: CharSet.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class CharSet {\n+\n+    private LinkedList set = new LinkedList();\n+\n+    /**\n+     * Restricted consructor. Use the factory method evaluateSet().\n+     */\n+    protected CharSet(String[] set) {\n+        int sz = set.length;\n+        for (int i = 0; i < sz; i++) {\n+            add(set[i]);\n+        }\n+    }\n+\n+    /**\n+     * Does the set contain the character specified\n+     * \n+     * @param ch  the character to check for\n+     * @return true if it does contain it\n+     */\n+    public boolean contains(char ch) {\n+        Iterator iterator = set.iterator();\n+        boolean bool = false;\n+        while (iterator.hasNext()) {\n+            CharRange range = (CharRange) iterator.next();\n+            if (range.isNegated()) {\n+                if (!range.inRange(ch)) {\n+                    bool = true;\n+                }\n+            } else {\n+                if (range.inRange(ch)) {\n+                    bool = true;\n+                }\n+            }\n+        }\n+        return bool;\n+    }\n+\n+    /**\n+     * Add a set definition string to the set\n+     * \n+     * @param str  set definition string\n+     */\n+    protected void add(String str) {\n+        int sz = str.length();\n+        CharRange range = null;\n+\n+        if(\"-\".equals(str)) {\n+            range = new CharRange('_');\n+            set.add(range);\n+            return;\n+        } \n+\n+        boolean end = false;\n+        boolean negated = false;\n+        for(int i=0; i<sz; i++) {\n+            char ch = str.charAt(i);\n+            if(ch == '-') {\n+                end = true;\n+                continue;\n+            }\n+            if(end) {\n+                range.setEnd(ch);\n+                continue;\n+            }\n+            if(ch == '^') {\n+                negated = true;\n+                continue;\n+            }\n+            range = new CharRange(ch);\n+            range.setNegated(negated);\n+            set.add(range);\n+        }\n+    }\n+\n+    /**\n+     * Returns a string representation of the set\n+     * \n+     * @return string representation\n+     */\n+    public String toString() {\n+        return set.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/CharSetUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.LinkedList;\n+\n+/**\n+ * Numerous routines to manipulate a character set.\n+ *\n+ * @author <a href=\"bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: CharSetUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class CharSetUtils {\n+\n+    /**\n+     * Creates a CharSetUtils object which allows a certain amount of \n+     * set logic to be performed upon the following syntax:\n+     *\n+     * \"aeio\" which implies 'a','e',..\n+     * \"^e\" implies not e. However it only negates, it's not \n+     * a set in itself due to the size of that set in unicode.\n+     * \"ej-m\" implies e,j->m. e,j,k,l,m.\n+     */\n+    public static CharSet evaluateSet(String[] set) {\n+        return new CharSet(set); \n+    }\n+\n+    /**\n+     * Squeezes any repititions of a character that is mentioned in the \n+     * supplied set. An example is:\n+     *    squeeze(\"hello\", \"el\")  => \"helo\"\n+     * See evaluateSet for set-syntax.\n+     * \n+     * @param str  the string to work from\n+     * @param set  the character set to use for manipulation\n+     */\n+    public static String squeeze(String str, String set) {\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return squeeze(str, strs);\n+    }\n+\n+    /**\n+     * Squeezes any repititions of a character that is mentioned in the \n+     * supplied set. An example is:\n+     *    squeeze(\"hello\", {\"el\"})  => \"helo\"\n+     * See evaluateSet for set-syntax.\n+     * \n+     * @param str  the string to work from\n+     * @param set  the character set to use for manipulation\n+     */\n+    public static String squeeze(String str, String[] set) {\n+        CharSet chars = evaluateSet(set);\n+        StringBuffer buffer = new StringBuffer(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        char lastChar = ' ';\n+        char ch = ' ';\n+        for (int i = 0; i < sz; i++) {\n+            ch = chrs[i];\n+            if (chars.contains(ch)) {\n+                if ((ch == lastChar) && (i != 0)) {\n+                    continue;\n+                }\n+            }\n+            buffer.append(ch);\n+            lastChar = ch;\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.\n+     * An example would be:   count(\"hello\", {\"c-f\",\"o\"}) returns 2.\n+     *\n+     * @param str  String target to count characters in\n+     * @param set  String set of characters to count\n+     */\n+    public static int count(String str, String set) {\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return count(str, strs);\n+    }\n+    \n+    /**\n+     * Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.\n+     * An example would be:   count(\"hello\", {\"c-f\",\"o\"}) returns 2.\n+     *\n+     * @param str  String target to count characters in\n+     * @param set  String[] set of characters to count\n+     */\n+    public static int count(String str, String[] set) {\n+        CharSet chars = evaluateSet(set);\n+        int count = 0;\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i])) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.\n+     * An example would be:   delete(\"hello\", {\"c-f\",\"o\"}) returns \"hll\"\n+     *\n+     * @param str  String target to delete characters from\n+     * @param set  String set of characters to delete\n+     */\n+    public static String delete(String str, String set) {\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return delete(str, strs);\n+    }\n+    \n+    /**\n+     * Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.\n+     * An example would be:   delete(\"hello\", {\"c-f\",\"o\"}) returns \"hll\"\n+     *\n+     * @param str  String target to delete characters from\n+     * @param set  String[] set of characters to delete\n+     */\n+    public static String delete(String str, String[] set) {\n+        CharSet chars = evaluateSet(set);\n+        StringBuffer buffer = new StringBuffer(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(!chars.contains(chrs[i])) {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * NEEDS TO TAKE A CHAR-SET.\n+     * Translate characters in a String.\n+     * An example is:  translate(\"hello\", \"ho\", \"jy\") => jelly\n+     * If the length of characters to search for is greater than the \n+     * length of characters to replace, then the last character is \n+     * used.\n+     *\n+     * @param target String to replace characters  in\n+     * @param repl String to find that will be replaced\n+     * @param with String to put into the target String\n+     */\n+    public static String translate(String target, String repl, String with) {\n+        StringBuffer buffer = new StringBuffer(target.length());\n+        char[] chrs = target.toCharArray();\n+        char[] withChrs = with.toCharArray();\n+        int sz = chrs.length;\n+        int withMax = with.length() - 1;\n+        for(int i=0; i<sz; i++) {\n+            int idx = repl.indexOf(chrs[i]);\n+            if(idx != -1) {\n+                if(idx > withMax) {\n+                    idx = withMax;\n+                }\n+                buffer.append(withChrs[idx]);\n+            } else {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/NumberRange.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+/**\n+ * Represents a range of {@link Number} objects.\n+ *\n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Revision: 1.1 $ $Date: 2002/07/19 03:35:54 $\n+ */\n+public final class NumberRange {\n+\n+\n+    /* The minimum number in this range. */\n+    private final Number min;\n+\n+    /* The maximum number in this range. */\n+    private final Number max;\n+\n+\n+    /**\n+     * Constructs a new instance using the specified number as both the\n+     * minimum and maximum in theis range.\n+     *\n+     * @param num the number to use for this range\n+     * @throws NullPointerException if the number is <code>null</code>\n+     */\n+    public NumberRange(Number num) {\n+        if (num == null) {\n+            throw new NullPointerException(\"num cannot be null\");\n+        }\n+\n+        this.min = num;\n+        this.max = num;\n+    }\n+\n+    /**\n+     * Constructs a new instance with the specified minimum and maximum\n+     * numbers.\n+     *\n+     * @param min the minimum number in this range\n+     * @param max the maximum number in this range\n+     * @throws NullPointerException if either the minimum or maximum number is\n+     *         <code>null</code>\n+     */\n+    public NumberRange(Number min, Number max) {\n+        if (min == null) {\n+            throw new NullPointerException(\"min cannot be null\");\n+        } else if (max == null) {\n+            throw new NullPointerException(\"max cannot be null\");\n+        }\n+\n+        if (max.doubleValue() < min.doubleValue()) {\n+            this.min = this.max = min;\n+        } else {\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+\n+    /**\n+     * Returns the minimum number in this range.\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimum() {\n+        return min;\n+    }\n+\n+    /**\n+     * Returns the maximum number in this range.\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximum() {\n+        return min;\n+    }\n+\n+    /**\n+     * Tests whether the specified number occurs within this range.\n+     *\n+     * @param number the number to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *         range; otherwise, <code>false</code>\n+     */\n+    public boolean includesNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        } else {\n+            return !(min.doubleValue() > number.doubleValue()) &&\n+                !(max.doubleValue() < number.doubleValue());\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the specified range occurs entirely within this range.\n+     *\n+     * @param range the range to test\n+     * @return <code>true</code> if the specified range occurs entirely within\n+     *         this range; otherwise, <code>false</code>\n+     */\n+    public boolean includesRange(NumberRange range) {\n+        if (range == null) {\n+            return false;\n+        } else {\n+            return includesNumber(range.min) && includesNumber(range.max);\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the specified range overlaps with this range.\n+     *\n+     * @param range the range to test\n+     * @return <code>true</code> if the specified range overlaps with this\n+     *         range; otherwise, <code>false</code>\n+     */\n+    public boolean overlaps(NumberRange range) {\n+        if (range == null) {\n+            return false;\n+        } else {\n+            return range.includesNumber(min) || range.includesNumber(max) || \n+                includesRange(range);\n+        }\n+    }\n+\n+    /**\n+     * Indicates whether some other object is \"equal\" to this one.\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is the same as the obj\n+     *         argument; <code>false</code> otherwise\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        } else if (!(obj instanceof NumberRange)) {\n+            return false;\n+        } else {\n+            NumberRange range = (NumberRange)obj;\n+            return min.equals(range.min) && max.equals(range.max);\n+        }\n+    }\n+\n+    /**\n+     * Returns a hash code value for this object.\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        int result = 17;\n+        result = 37 * result + min.hashCode();\n+        result = 37 * result + max.hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the string representation of this range. This string is the\n+     * string representation of the minimum and maximum numbers in the range,\n+     * separated by a hyphen. If a number is negative, then it is enclosed\n+     * in parentheses.\n+     *\n+     * @return the string representation of this range\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer();\n+\n+        if (min.intValue() < 0) {\n+            sb.append('(')\n+                .append(min)\n+                .append(')');\n+        } else {\n+            sb.append(min);\n+        }\n+\n+        sb.append('-');\n+\n+        if (max.intValue() < 0) {\n+            sb.append('(')\n+                .append(max)\n+                .append(')');\n+        } else {\n+            sb.append(max);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+/**\n+ * Provides extra functionality for java Number classes.\n+ *\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: NumberUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public final class NumberUtils {\n+\n+    /**\n+     * Convert a String to an int, returning zero if the conversion fails\n+     * \n+     * @param str  the string to convert\n+     * @return the int represented by the string, or zero if conversion fails\n+     */\n+    public static int stringToInt(String str) {\n+        return stringToInt(str, 0);\n+    }\n+\n+    /**\n+     * Convert a String to an int, returning a default value if the \n+     * conversion fails.\n+     * \n+     * @param str  the string to convert\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     */\n+    public static int stringToInt(String str, int defaultValue) {\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    // must handle Long, Float, Integer, Float, Short,\n+    //                  BigDecimal, BigInteger and Byte\n+    // useful methods:\n+    // Byte.decode(String)\n+    // Byte.valueOf(String,int radix)\n+    // Byte.valueOf(String)\n+    // Double.valueOf(String)\n+    // Float.valueOf(String)\n+    // new Float(String)\n+    // Integer.valueOf(String,int radix)\n+    // Integer.valueOf(String)\n+    // Integer.decode(String)\n+    // Integer.getInteger(String)\n+    // Integer.getInteger(String,int val)\n+    // Integer.getInteger(String,Integer val)\n+    // new Integer(String)\n+    // new Double(String)\n+    // new Byte(String)\n+    // new Long(String)\n+    // Long.getLong(String)\n+    // Long.getLong(String,int)\n+    // Long.getLong(String,Integer)\n+    // Long.valueOf(String,int)\n+    // Long.valueOf(String)\n+    // new Short(String)\n+    // Short.decode(String)\n+    // Short.valueOf(String,int)\n+    // Short.valueOf(String)\n+    // new BigDecimal(String)\n+    // new BigInteger(String)\n+    // new BigInteger(String,int radix)\n+    // Possible inputs:\n+    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n+    // plus minus everything. Prolly more. A lot are not separable.\n+\n+    /**\n+     * <p>\n+     * Turns a string value into a java.lang.Number.\n+     * First, the value is examined for a type qualifier on the end \n+     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n+     * trying to create succissively larger types from the type specified\n+     * until one is found that can hold the value.\n+     * </p>\n+     * <p>\n+     * If a type specifier is not found, it will check for a decimal point\n+     * and then try successively larger types from Integer to BigInteger \n+     * and from Float to BigDecimal.\n+     * </p>\n+     * <p>\n+     * If the string starts with \"0x\" or \"-0x\", it will be interpreted as a \n+     * hexadecimal integer.  Values with leading 0's will not be interpreted \n+     * as octal.\n+     * </p>\n+     * \n+     * @param val String containing a number\n+     * @return Number created from the string\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Number createNumber(String val) throws NumberFormatException {\n+        if (val == null) {\n+            return null;\n+        }\n+        if (val.length() == 0) {\n+            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+        }\n+        if (val.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n+            return createInteger(val);\n+        }   \n+        char lastChar = val.charAt(val.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos = val.indexOf('.');\n+        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                }\n+                dec = val.substring(decPos + 1, expPos);\n+            } else {\n+                dec = val.substring(decPos + 1);\n+            }\n+            mant = val.substring(0, decPos);\n+        } else {\n+            if (expPos > -1) {\n+                mant = val.substring(0, expPos);\n+            } else {\n+                mant = val;\n+            }\n+            dec = null;\n+        }\n+        if (!Character.isDigit(lastChar)) {\n+            if (expPos > -1 && expPos < val.length() - 1) {\n+                exp = val.substring(expPos + 1, val.length() - 1);\n+            } else {\n+                exp = null;\n+            }\n+            //Requesting a specific type..\n+            String numeric = val.substring(0, val.length() - 1);\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            switch (lastChar) {\n+                case 'l' :\n+                case 'L' :\n+                    if (dec == null\n+                        && exp == null\n+                        && isDigits(numeric.substring(1))\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                case 'f' :\n+                case 'F' :\n+                    try {\n+                        Float f = NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                            //If it's too big for a float or the float value = 0 and the string\n+                            //has non-zeros in it, then float doens't have the presision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    //Fall through\n+                case 'd' :\n+                case 'D' :\n+                    try {\n+                        Double d = NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                    }\n+                    //Fall through\n+                default :\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn't have a preference on the return type, so let's start\n+            //small and go from there...\n+            if (expPos > -1 && expPos < val.length() - 1) {\n+                exp = val.substring(expPos + 1, val.length());\n+            } else {\n+                exp = null;\n+            }\n+            if (dec == null && exp == null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(val);\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    return createLong(val);\n+                } catch (NumberFormatException nfe) {\n+                }\n+                return createBigInteger(val);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                try {\n+                    Float f = createFloat(val);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    Double d = createDouble(val);\n+                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+\n+                return createBigDecimal(val);\n+\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Utility method for createNumber.  Returns true if s is null\n+     * \n+     * @param s the String to check\n+     * @return if it is all zeros or null\n+     */\n+    private static boolean isAllZeros(String s) {\n+        if (s == null) {\n+            return true;\n+        }\n+        for (int i = s.length() - 1; i >= 0; i--) {\n+            if (s.charAt(i) != '0') {\n+                return false;\n+            }\n+        }\n+        return s.length() > 0;\n+    }\n+\n+    /**\n+     * Convert a String to a Float\n+     * \n+     * @param val  a String to convert\n+     * @return converted Float\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Float createFloat(String val) {\n+        return Float.valueOf(val);\n+    }\n+\n+    /**\n+     * Convert a String to a Double\n+     * \n+     * @param val  a String to convert\n+     * @return converted Double\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Double createDouble(String val) {\n+        return Double.valueOf(val);\n+    }\n+\n+    /**\n+     * Convert a String to a Integer, handling hex and\n+     * octal notations.\n+     * \n+     * @param val  a String to convert\n+     * @return converted Integer\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Integer createInteger(String val) {\n+        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n+        return Integer.decode(val);\n+    }\n+\n+    /**\n+     * Convert a String to a Long\n+     * \n+     * @param val  a String to convert\n+     * @return converted Long\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Long createLong(String val) {\n+        return Long.valueOf(val);\n+    }\n+\n+    /**\n+     * Convert a String to a BigInteger\n+     * \n+     * @param val  a String to convert\n+     * @return converted BigInteger\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigInteger createBigInteger(String val) {\n+        BigInteger bi = new BigInteger(val);\n+        return bi;\n+    }\n+\n+    /**\n+     * Convert a String to a BigDecimal\n+     * \n+     * @param val  a String to convert\n+     * @return converted BigDecimal\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigDecimal createBigDecimal(String val) {\n+        BigDecimal bd = new BigDecimal(val);\n+        return bd;\n+    }\n+\n+    /**\n+     * Get the minimum of three values.\n+     */\n+    public static int minimum(int a, int b, int c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * Get the maximum of three values.\n+     */\n+    public static int maximum(int a, int b, int c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * Checks whether the String contains only digit characters.\n+     * Null and blank string will return false.\n+     *\n+     * @param str  the string to check\n+     * @return boolean contains only unicode numeric\n+     */\n+    public static boolean isDigits(String str) {\n+        if ((str == null) || (str.length() == 0)) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (!Character.isDigit(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Checks whether the String a valid Java number.\n+     * Valid numbers include hexadecimal marked with the \"0x\" qualifier,\n+     * scientific notation and numbers marked with a type qualifier (e.g. 123L).\n+     * </p>\n+     * <p>\n+     * Null and blank string will return false.\n+     * </p>\n+     * \n+     * @param str  the string to check\n+     * @return true if the string is a correctly formatted number\n+     */\n+    public static boolean isNumber(String str) {\n+        if ((str == null) || (str.length() == 0)) {\n+            return false;\n+        }\n+        char[] chars = str.toCharArray();\n+        int sz = chars.length;\n+        boolean hasExp = false;\n+        boolean hasDecPoint = false;\n+        boolean allowSigns = false;\n+        boolean foundDigit = false;\n+        //Deal with any possible sign up front\n+        int start = (chars[0] == '-') ? 1 : 0;\n+        if (sz > start + 1) {\n+            if (chars[start] == '0' && chars[start + 1] == 'x') {\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n+                }\n+                //Checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; //Don't want to loop to the last char, check it afterwords\n+              //for type qualifiers\n+        int i = start;\n+        //Loop to the next to last char or to the last char if we need another digit to\n+        //make a valid number (e.g. chars[0..5] = \"1234E\")\n+        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                foundDigit = true;\n+                allowSigns = false;\n+\n+            } else if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    //Two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint = true;\n+            } else if (chars[i] == 'e' || chars[i] == 'E') {\n+                //We've already taken care of hex.\n+                if (hasExp) {\n+                    //Two E's\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp = true;\n+                allowSigns = true;\n+            } else if (chars[i] == '+' || chars[i] == '-') {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns = false;\n+                foundDigit = false; //We need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i < chars.length) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                //No type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] == 'e' || chars[i] == 'E') {\n+                //Can't have an E at the last byte\n+                return false;\n+            }\n+            if (!allowSigns\n+                && (chars[i] == 'd'\n+                    || chars[i] == 'D'\n+                    || chars[i] == 'f'\n+                    || chars[i] == 'F')) {\n+                return foundDigit;\n+            }\n+            if (chars[i] == 'l'\n+                || chars[i] == 'L') {\n+                //Not allowing L with an exponoent\n+                return foundDigit && !hasExp;\n+            }\n+        }\n+        //allowSigns is true iff the val ends in 'E'\n+        //Found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n+        return !allowSigns && foundDigit;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/ObjectUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+/**\n+ * Common <code>Object</code> manipulation routines.\n+ *\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ObjectUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class ObjectUtils {\n+    \n+    /**\n+     * Prevent construction of ObjectUtils instances\n+     */\n+    private ObjectUtils() {\n+    }\n+\n+    /**\n+     * Returns a default value if the object passed is null.\n+     *\n+     * @param object  the object to test.\n+     * @param defaultValue  the default value to return.\n+     * @return object if it is not null, defaultValue otherwise.\n+     */\n+    public static Object defaultIfNull(Object object, Object defaultValue) {\n+        return (object != null ? object : defaultValue);\n+    }\n+\n+    /**\n+     * Compares two objects for equality, where either one or both\n+     * objects may be <code>null</code>.\n+     *\n+     * @param object1  the first object.\n+     * @param object2  the second object.\n+     * @return True if the values of both objects are the same.\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == null) {\n+            return (object2 == null);\n+        } else if (object2 == null) {\n+            // object1 is not null\n+            return false;\n+        } else {\n+            return object1.equals(object2);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/RandomStringUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Commons\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Random;\n+/**\n+ * <p>Common random <code>String</code> manipulation routines.</p>\n+ *\n+ * <p>Originally from \n+ *  <a href=\"http://jakarta.apache.org/turbine/\">Turbine</a> and the\n+ * GenerationJavaCore library.</p>\n+ *\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Bayard</a>\n+ * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: RandomStringUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class RandomStringUtils {\n+\n+    /**\n+     * Random object used by random method. This has to be not local \n+     * to the random method so as to not return the same value in the \n+     * same millisecond. \n+     */\n+    private static final Random RANDOM = new Random();\n+\n+    /**\n+     * Prevent construction of RandomStringUtils instances\n+     */\n+    private RandomStringUtils() {\n+    }\n+\n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of all characters.\n+     *\n+     * @param count length of random string to create\n+     * @return the random string\n+     */\n+    public static String random(int count) {\n+        return random(count, false, false);\n+    }\n+\n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of characters whose\n+     * ASCII value is between 32 and 127 .\n+     *\n+     * @param count length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAscii(int count) {\n+        return random(count, 32, 127, false, false);\n+    }\n+    \n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of alphabetic\n+     * characters.\n+     *\n+     * @param count length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphabetic(int count) {\n+        return random(count, true, false);\n+    }\n+    \n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of alpha-numeric\n+     * characters.\n+     *\n+     * @param count length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphanumeric(int count) {\n+        return random(count, true, true);\n+    }\n+    \n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of numeric\n+     * characters.\n+     *\n+     * @param count length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomNumeric(int count) {\n+        return random(count, false, true);\n+    }\n+\n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.\n+     *\n+     * @param count length of random string to create\n+     * @param letters if <code>true</code>, generated string will include\n+     * alphabetic characters\n+     * @param numbers if <code>true</code>, generatd string will include\n+     * numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, boolean letters, boolean numbers) {\n+        return random(count, 0, 0, letters, numbers);\n+    }\n+    \n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.\n+     *\n+     * @param count length of random string to create\n+     * @param start int position in set of chars to start at\n+     * @param end int position in set of chars to end before\n+     * @param letters if <code>true</code>, generated string will include\n+     * alphabetic characters\n+     * @param numbers if <code>true</code>, generatd string will include\n+     * numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n+        return random(count, start, end, letters, numbers, null);\n+    }\n+    \n+    /**\n+     * Creates a random string based on a variety of options.\n+     *\n+     * @param count int length of random string to create\n+     * @param start int position in set of chars to start at\n+     * @param end int position in set of chars to end before\n+     * @param letters boolean only allow letters?\n+     * @param numbers boolean only allow numbers?\n+     * @param set char[] set of chars to choose randoms from.\n+     *        If null, then it will use the set of all chars.\n+     * @return the random string\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] set) {\n+        if( (start == 0) && (end == 0) ) {\n+            end = (int)'z';\n+            start = (int)' ';\n+            if(!letters && !numbers) {\n+                start = 0;\n+                end = Integer.MAX_VALUE;\n+            }\n+        }\n+\n+        StringBuffer buffer = new StringBuffer();\n+        int gap = end - start;\n+\n+        while(count-- != 0) {\n+            char ch;\n+            if(set == null) {\n+                ch = (char)(RANDOM.nextInt(gap) + start);\n+            } else {\n+                ch = set[RANDOM.nextInt(gap) + start];\n+            }\n+            if( (letters && numbers && Character.isLetterOrDigit(ch)) ||\n+                (letters && Character.isLetter(ch)) ||\n+                (numbers && Character.isDigit(ch)) ||\n+                (!letters && !numbers)\n+              ) \n+            {\n+                buffer.append( ch );\n+            } else {\n+                count++;\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of characters\n+     * specified.\n+     *\n+     * @param count int length of random string to create\n+     * @param set String containing the set of characters to use\n+     * @return the random string\n+     */\n+    public static String random(int count, String set) {\n+        return random(count, set.toCharArray());\n+    }\n+\n+    /**\n+     * Creates a random string whose length is the number of characters\n+     * specified. Characters will be chosen from the set of characters\n+     * specified.\n+     *\n+     * @param count int length of random string to create\n+     * @param set character array containing the set of characters to use\n+     * @return the random string\n+     */\n+    public static String random(int count, char[] set) {\n+        return random(count, 0, set.length - 1, false, false, set);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/SerializationException.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+\n+/**\n+ * Exception thrown when the Serialization process fails. The original\n+ * error is wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: SerializationException.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class SerializationException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>SerializationException</code> without specified\n+     * detail message.\n+     */\n+    public SerializationException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>SerializationException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg The error message.\n+     */\n+    public SerializationException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>SerializationException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public SerializationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>SerializationException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    The error message.\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public SerializationException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/SerializationUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Methods that assist with the serialization process, or perform\n+ * additional functionality based on serialization.\n+ * <ul>\n+ * <li>Deep clone using serialization\n+ * <li>Serialize managing finally and IOException\n+ * <li>Deserialize managing finally and IOException\n+ * </ul>\n+ *\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: SerializationUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class SerializationUtils {\n+    \n+    /**\n+     * Constructor for SerializationUtils is private\n+     */\n+    private SerializationUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Deep clone an object using serialization.\n+     * <p>\n+     * This is many times slower than writing clone methods by hand\n+     * on all objects in your object graph. However, for complex object\n+     * graphs, or for those that don't support deep cloning this can\n+     * be a simple alternative implementation. Of course all the objects\n+     * must be <code>Serializable</code>.\n+     * \n+     * @param object  the <code>Serializable</code> object to clone\n+     * @return the cloned object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object clone(Serializable object) {\n+        return deserialize( serialize(object) );\n+    }\n+    \n+    /**\n+     * Serializes an object to the specified stream. The stream will\n+     * be closed once the object is written. This avoids the need for\n+     * a finally clause, and maybe also exception handling, in the\n+     * application code.\n+     *\n+     * @param obj  the object to serialize to bytes\n+     * @param outputStream  the stream to write to\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static void serialize(Serializable obj, OutputStream outputStream) {\n+        ObjectOutputStream out = null;\n+        try {\n+            // stream closed in the finally\n+            out = new ObjectOutputStream(outputStream);\n+            out.writeObject(obj);\n+            \n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (out != null) {\n+                    out.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Serializes an object to a byte array for storage/serialization.\n+     *\n+     * @param obj  the object to serialize to bytes\n+     * @return a byte[] with the converted Serializable.\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static byte[] serialize(Serializable obj) {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        serialize(obj, baos);\n+        return baos.toByteArray();\n+    }\n+\n+    /**\n+     * Deserializes an object from the specified stream. The stream will\n+     * be closed once the object is written. This avoids the need for\n+     * a finally clause, and maybe also exception handling, in the\n+     * application code.\n+     *\n+     * @param objectData  the serialized object.\n+     * @return the deserialized object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(InputStream inputStream) {\n+        ObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ObjectInputStream(inputStream);\n+            return in.readObject();\n+            \n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deserializes a single object from an array of bytes.\n+     *\n+     * @param objectData  the serialized object.\n+     * @return the deserialized object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(byte[] objectData) {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+        return deserialize(bais);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.IOException;\n+import java.util.NoSuchElementException;\n+import java.util.StringTokenizer;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * <p>Common <code>String</code> manipulation routines.</p>\n+ *\n+ * <p>Originally from \n+ * <a href=\"http://jakarta.apache.org/turbine/\">Turbine</a> and the\n+ * GenerationJavaCore library.</p>\n+ *\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Bayard</a>\n+ * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com>Rand McNeely</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org>Stephen Colebourne</a>\n+ * @version $Id: StringUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class StringUtils {\n+\n+    /**\n+     * The size of the buffer to use when working with I/O (4 kB).\n+     */\n+    public static int CHAR_BUFFER_SIZE = 4 * 1024;\n+    \n+    /**\n+     * Prevent construction of StringUtils instances\n+     */\n+    private StringUtils() {\n+    }\n+\n+    // Empty\n+    //--------------------------------------------------------------------------\n+\n+    /**\n+     * Removes white space from both ends of this string, handling null\n+     * by returning an empty string.\n+     *\n+     * @see java.lang.String#trim()\n+     * @param str  the string to check\n+     * @return the trimmed text (never <code>null</code>)\n+     */\n+    public static String clean(String str) {\n+        return (str == null ? \"\" : str.trim());\n+    }\n+\n+    /**\n+     * Removes white space from both ends of this string, handling null\n+     * by returning null.\n+     *\n+     * @see java.lang.String#trim()\n+     * @param str  the string to check\n+     * @return the trimmed text (or <code>null</code>)\n+     */\n+    public static String trim(String str) {\n+        return (str == null ? null : str.trim());\n+    }\n+\n+    /**\n+     * Checks if a String is non null and is not empty (length > 0).\n+     *\n+     * @param str  the string to check\n+     * @return true if the String is non-null, and not length zero\n+     */\n+    public static boolean isNotEmpty(String str) {\n+        return (str != null && str.length() > 0);\n+    }\n+\n+    /**\n+     * Checks if a (trimmed) String is null or empty.\n+     *\n+     * @param str  the string to check\n+     * @return true if the String is null, or length zero once trimmed\n+     */\n+    public static boolean isEmpty(String str) {\n+        return (str == null || str.trim().length() == 0);\n+    }\n+\n+    // Equals and IndexOf\n+    //--------------------------------------------------------------------------\n+\n+    /**\n+     * Compares two Strings, returning true if they are equal.\n+     * Nulls are handled without exceptions. Two <code>null</code>\n+     * references are considered equal. Comparison is case sensitive.\n+     *\n+     * @param str1  the first string\n+     * @param str2  the second string\n+     * @return true if the Strings are equal, case sensitive, or both null\n+     */\n+    public static boolean equals(String str1, String str2) {\n+        return (str1 == null ? str2 == null : str1.equals(str2));\n+    }\n+\n+    /**\n+     * Compares two Strings, returning true if they are equal ignoring case.\n+     * Nulls are handled without exceptions. Two <code>null</code>\n+     * references are considered equal. Comparison is case insensitive.\n+     *\n+     * @param str1  the first string\n+     * @param str2  the second string\n+     * @return true if the Strings are equal, case insensitive, or both null\n+     */\n+    public static boolean equalsIgnoreCase(String str1, String str2) {\n+        return (str1 == null ? str2 == null : str1.equalsIgnoreCase(str2));\n+    }\n+\n+    /**\n+     * Find the earliest index of any of a set of potential substrings.\n+     * Null string will return -1.\n+     * \n+     * @param str  the string to check\n+     * @param searchStrs  the strings to search for\n+     * @return the earliest index of any of the strings\n+     */\n+    public static int indexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+\n+        // String's can't have a MAX_VALUEth index.\n+        int ret = Integer.MAX_VALUE;\n+\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            tmp = str.indexOf(searchStrs[i]);\n+            if (tmp == -1) {\n+                continue;\n+            }\n+\n+            if (tmp < ret) {\n+                ret = tmp;\n+            }\n+        }\n+\n+        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n+    }\n+\n+    /**\n+     * Find the latest index of any of a set of potential substrings.\n+     * Null string will return -1.\n+     * \n+     * @param str  the string to check\n+     * @param searchStrs  the strings to search for\n+     * @return the last index of any of the strings\n+     */\n+    public static int lastIndexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+        int ret = -1;\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            tmp = str.lastIndexOf(searchStrs[i]);\n+            if (tmp > ret) {\n+                ret = tmp;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Substring\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets a substring of the specified string avoiding exceptions.\n+     * A negative start position can be used to start n characters from\n+     * the end of the string.\n+     * \n+     * @param str  the string to get the substring from\n+     * @param start  the position to start from,  negative means \n+     * count back from the end of the string by this many characters\n+     * @return substring from start position\n+     */\n+    public static String substring(String str, int start) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives, which means last n characters\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > str.length()) {\n+            return \"\";\n+        }\n+\n+        return str.substring(start);\n+    }\n+    \n+    /**\n+     * Gets a substring of the specified string avoiding exceptions.\n+     * A negative start position can be used to start/end n characters\n+     * from the end of the string.\n+     * \n+     * @param str  the string to get the substring from\n+     * @param start  the position to start from, negative means \n+     * count back from the end of the string by this many characters\n+     * @param end  the position to end at (exclusive),  negative means \n+     * count back from the end of the string by this many characters\n+     * @return substring from start position to end positon\n+     */\n+    public static String substring(String str, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives\n+        if (end < 0) {\n+            end = str.length() + end; // remember end is negative\n+        }\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        // check length next\n+        if (end > str.length()) {\n+            // check this works.\n+            end = str.length();\n+        }\n+\n+        // if start is greater than end, return \"\"\n+        if (start > end) {\n+            return \"\";\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+\n+        return str.substring(start, end);\n+    }\n+\n+    /**\n+     * Gets the leftmost n characters of a string. If n characters are not \n+     * available, or the string is null, the string will be returned \n+     * without an exception.\n+     *\n+     * @param str  the string to get the leftmost characters from\n+     * @param len  the length of the required string\n+     * @return the leftmost characters\n+     * @throws IllegalArgumentException if len is less than zero\n+     */\n+    public static String left(String str, int len) {\n+        if (len < 0) {\n+            throw new IllegalArgumentException(\"Requested String length \" + len + \" is less than zero\");\n+        }\n+        if ((str == null) || (str.length() <= len)) {\n+            return str;\n+        } else {\n+            return str.substring(0, len);\n+        }\n+    }\n+\n+    /**\n+     * Gets the rightmost n characters of a string. If n characters are not \n+     * available, or the string is null, the string will be returned \n+     * without an exception.\n+     *\n+     * @param str  the string to get the rightmost characters from\n+     * @param len  the length of the required string\n+     * @return the leftmost characters\n+     * @throws IllegalArgumentException if len is less than zero\n+     */\n+    public static String right(String str, int len) {\n+        if (len < 0) {\n+            throw new IllegalArgumentException(\"Requested String length \" + len + \" is less than zero\");\n+        }\n+        if ((str == null) || (str.length() <= len)) {\n+            return str;\n+        } else {\n+            return str.substring(str.length() - len);\n+        }\n+    }\n+\n+    /**\n+     * Gets n characters from the middle of a string. If n characters are \n+     * not available, the remainder of the string will be returned \n+     * without an exception. If the string is null, null will be returned.\n+     *\n+     * @param str  the string to get the characters from\n+     * @param pos  the position to start from\n+     * @param len  the length of the required string\n+     * @return the leftmost characters\n+     * @throws IndexOutOfBoundsException if pos is out of bounds\n+     * @throws IllegalArgumentException if len is less than zero\n+     */\n+    public static String mid(String str, int pos, int len) {\n+        if ((pos < 0) ||\n+            (str != null && pos > str.length())) {\n+            throw new StringIndexOutOfBoundsException(\"String index \" + pos + \" is out of bounds\");\n+        }\n+        if (len < 0) {\n+            throw new IllegalArgumentException(\"Requested String length \" + len + \" is less than zero\");\n+        }\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() <= (pos + len)) {\n+            return str.substring(pos);\n+        } else {\n+            return str.substring(pos, pos + len);\n+        }\n+    }\n+\n+    // Splitting\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Splits the provided text into a list, using whitespace as the separator.\n+     * The separator is not included in the returned String array.\n+     *\n+     * @param str  the string to parse\n+     * @return an array of parsed Strings \n+     */\n+    public static String[] split(String text) {\n+        return split(text, null, -1);\n+    }\n+\n+    /**\n+     * Splits the provided text into a list, based on a given separator.\n+     * The separator is not included in the returned String array.\n+     * A null separator will cause parsing to be on whitespace.\n+     *\n+     * @param str  the string to parse\n+     * @param separator  The separator character. If <code>null</code>, splits\n+     *  on whitespace.\n+     * @return an array of parsed Strings \n+     */\n+    public static String[] split(String text, String separator) {\n+        return split(text, separator, -1);\n+    }\n+\n+    /**\n+     * Splits the provided text into a list, based on a given separator.\n+     * The separator is not included in the returned String array.\n+     * The maximum number of splits to perfom can be controlled.\n+     * A null separator will cause parsing to be on whitespace.\n+     *\n+     * @param str  the string to parse\n+     * @param separator  The separator character. If <code>null</code>, splits\n+     *  on whitespace.\n+     * @param max  The maximum number of elements to include in the\n+     *  list.  A zero or negative value implies no limit.\n+     * @return an array of parsed Strings \n+     */\n+    public static String[] split(String text, String separator, int max) {\n+        StringTokenizer tok = null;\n+        if (separator == null) {\n+            // Null separator means we're using StringTokenizer's default\n+            // delimiter, which comprises all whitespace characters.\n+            tok = new StringTokenizer(text);\n+        } else {\n+            tok = new StringTokenizer(text, separator);\n+        }\n+\n+        int listSize = tok.countTokens();\n+        if (max > 0 && listSize > max) {\n+            listSize = max;\n+        }\n+\n+        String[] list = new String[listSize];\n+        int i = 0;\n+        while (tok.hasMoreTokens()) {\n+            if (max > 0 && i == listSize - 1) {\n+                // In the situation where we hit the max yet have\n+                // tokens left over in our input, the last list\n+                // element gets all remaining text.\n+                StringBuffer buf = new StringBuffer((int) 1.2 * text.length() * (listSize - i) / listSize);\n+                while (tok.hasMoreTokens()) {\n+                    buf.append(tok.nextToken());\n+                    if (tok.hasMoreTokens()) {\n+                        buf.append(separator);\n+                    }\n+                }\n+                list[i] = buf.toString();\n+                break;\n+            } else {\n+                list[i] = tok.nextToken();\n+            }\n+            i++;\n+        }\n+        return list;\n+    }\n+\n+    // Joining\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Joins the elements of the provided array into a single string\n+     * containing the provided list of elements. \n+     * No delimiter is added before or after the list.\n+     * A null separator is the same as a blank String.\n+     *\n+     * @param array  the array of values to join together\n+     * @param separator  the separator character to use\n+     * @return the joined String\n+     */\n+    public static String join(Object[] array, String separator) {\n+        if (separator == null) {\n+            separator = \"\";\n+        }\n+        int arraySize = array.length;\n+        int bufSize = (arraySize == 0 ? 0 : (array[0].toString().length() +\n+                                 separator.length()) * arraySize);\n+        StringBuffer buf = new StringBuffer(bufSize);\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            if (i > 0) {\n+                buf.append(separator);\n+            }\n+            buf.append(array[i]);\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Joins the elements of the provided iterator into a single string\n+     * containing the provided elements.\n+     * No delimiter is added before or after the list.\n+     * A null separator is the same as a blank String.\n+     *\n+     * @param iterator  the iterator of values to join together\n+     * @param separator  the separator character to use\n+     * @return the joined String\n+     */\n+    public static String join(Iterator iterator, String separator) {\n+        if (separator == null) {\n+            separator = \"\";\n+        }\n+        StringBuffer buf = new StringBuffer(256);  // Java default is 16, probably too small\n+        while (iterator.hasNext()) {\n+            buf.append(iterator.next());\n+            if (iterator.hasNext()) {\n+                buf.append(separator);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+\n+    // Replacing\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Replace a string with another string inside a larger string, once.\n+     *\n+     * @see #replace(String text, String repl, String with, int max)\n+     * @param text  text to search and replace in\n+     * @param repl  String to search for\n+     * @param with  String to replace with\n+     * @return the text with any replacements processed\n+     */\n+    public static String replaceOnce(String text, String repl, String with) {\n+        return replace(text, repl, with, 1);\n+    }\n+\n+    /**\n+     * Replace all occurances of a string within another string.\n+     *\n+     * @see #replace(String text, String repl, String with, int max)\n+     * @param text  text to search and replace in\n+     * @param repl  String to search for\n+     * @param with  String to replace with\n+     * @return the text with any replacements processed\n+     */\n+    public static String replace(String text, String repl, String with) {\n+        return replace(text, repl, with, -1);\n+    }\n+\n+    /**\n+     * Replace a string with another string inside a larger string,\n+     * for the first <code>max</code> values of the search string.  A\n+     * <code>null</code> reference is passed to this method is a\n+     * no-op.\n+     *\n+     * @param text  text to search and replace in\n+     * @param repl  String to search for\n+     * @param with  String to replace with\n+     * @param max  maximum number of values to replace, or\n+     * <code>-1</code> if no maximum\n+     * @return the text with any replacements processed\n+     */\n+    public static String replace(String text, String repl, String with,\n+                                 int max) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        StringBuffer buf = new StringBuffer(text.length());\n+        int start = 0, end = 0;\n+        while ( (end = text.indexOf(repl, start)) != -1 ) {\n+            buf.append(text.substring(start, end)).append(with);\n+            start = end + repl.length();\n+\n+            if (--max == 0) {\n+                break;\n+            }\n+        }\n+        buf.append(text.substring(start));\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Overlay a part of a string with another string.\n+     *\n+     * @param text String to do overlaying in\n+     * @param overlay String to overlay\n+     * @param start int to start overlaying at\n+     * @param end   int to stop overlaying before\n+     * @return String with overlayed text\n+     */\n+    public static String overlayString(String text, String overlay, int start, int end) {\n+        return new StringBuffer(start + overlay.length() + text.length() - end + 1)\n+\t\t\t.append(text.substring(0, start))\n+\t\t\t.append(overlay)\n+\t\t\t.append(text.substring(end))\n+\t\t\t.toString();\n+    }\n+\n+    // Centering\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Center a string in a larger string of size n.\n+     * Uses spaces as the value to buffer the string with..\n+     *\n+     * @param str  String to center\n+     * @param size  int size of new String\n+     * @return String containing centered String\n+     */\n+    public static String center(String str, int size) {\n+        return center(str, size, \" \");\n+    }\n+\n+    /**\n+     * Center a string in a larger string of size n.\n+     * Uses a supplied String as the value to buffer the string with..\n+     *\n+     * @param str  String to center\n+     * @param size  int size of new String\n+     * @param delim  String to buffer the new String with\n+     * @return String containing centered String\n+     */\n+    public static String center(String str, int size, String delim) {\n+        int sz = str.length();\n+        int p = size - sz;\n+        if (p < 1) {\n+            return str;\n+        }\n+        str = leftPad(str, sz + p / 2, delim);\n+        str = rightPad(str, size, delim);\n+        return str;\n+    }\n+\n+    // Chomping\n+    //--------------------------------------------------------------------------\n+    \n+    /** \n+     * Remove the last newline, and everything after it from a String.\n+     *\n+     * @param str  String to chomp the newline from\n+     * @return String without chomped newline\n+     */\n+    public static String chomp(String str) {\n+        return chomp(str, \"\\n\");\n+    }\n+    \n+    /** \n+     * Remove the last value of a supplied String, and everything after it \n+     * from a String.\n+     *\n+     * @param str  String to chomp from\n+     * @param sep  String to chomp\n+     * @return String without chomped ending\n+     */\n+    public static String chomp(String str, String sep) {\n+        int idx = str.lastIndexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(0,idx);\n+        } else {\n+            return str;\n+        }\n+    }\n+    \n+    /**\n+     * Remove a newline if and only if it is at the end \n+     * of the supplied string.\n+     * \n+     * @param str  String to chomp from\n+     * @return String without chomped ending\n+     */\n+    public static String chompLast(String str) {\n+        return chompLast(str, \"\\n\");\n+    }\n+    \n+    /**\n+     * Remove a value if and only if the string ends with that value.\n+     * \n+     * @param str  String to chomp from\n+     * @param sep  String to chomp\n+     * @return String without chomped ending\n+     */\n+    public static String chompLast(String str, String sep) {\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+        String sub = str.substring(str.length() - sep.length());\n+        if (sep.equals(sub)) {\n+            return str.substring(0, str.length() - sep.length());\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /** \n+     * Remove everything and return the last value of a supplied String, and \n+     * everything after it from a String.\n+     *\n+     * @param str String to chomp from\n+     * @param sep String to chomp\n+     * @return String chomped\n+     */\n+    public static String getChomp(String str, String sep) {\n+        int idx = str.lastIndexOf(sep);\n+        if (idx == str.length() - sep.length()) {\n+            return sep;\n+        } else if (idx != -1) {\n+            return str.substring(idx);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    /** \n+     * Remove the first value of a supplied String, and everything before it \n+     * from a String.\n+     *\n+     * @param str String to chomp from\n+     * @param sep String to chomp\n+     * @return String without chomped beginning\n+     */\n+    public static String prechomp(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(idx + sep.length());\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /** \n+     * Remove and return everything before the first value of a \n+     * supplied String from another String.\n+     *\n+     * @param str String to chomp from\n+     * @param sep String to chomp\n+     * @return String prechomped\n+     */\n+    public static String getPrechomp(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(0, idx + sep.length());\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    // Chopping\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Remove the last character from a String. If the String \n+     * ends in \\r\\n, then remove both of them.\n+     *\n+     * @param str String to chop last character from\n+     * @return String without last character\n+     */\n+    public static String chop(String str) {\n+        if (\"\".equals(str)) {\n+            return \"\";\n+        }\n+        if (str.length() == 1) {\n+            return \"\";\n+        }\n+        int lastIdx = str.length() - 1;\n+        String ret = str.substring(0, lastIdx);\n+        char last = str.charAt(lastIdx);\n+        if (last == '\\n') {\n+            if (ret.charAt(lastIdx - 1) == '\\r') {\n+                return ret.substring(0, lastIdx - 1);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Remove \\n from end of a String if it's there.\n+     * If a \\r precedes it, then remove that too.\n+     *\n+     * @param str String to chop a newline from\n+     * @param String without newline on end\n+     * @return String without newline\n+     */\n+    public static String chopNewline(String str) {\n+        int lastIdx = str.length()-1;\n+        char last = str.charAt(lastIdx);\n+        if(last == '\\n') {\n+            if(str.charAt(lastIdx-1) == '\\r') {\n+                lastIdx --;\n+            }\n+        } else {\n+            lastIdx++;\n+        }\n+        return str.substring(0,lastIdx);\n+    }\n+\n+\n+    // Conversion\n+    //--------------------------------------------------------------------------\n+    \n+    // spec 3.10.6\n+    /**\n+     * Escapes any values it finds into their String form.\n+     * So a tab becomes the characters '\\\\' and 't'.\n+     *\n+     * @param str String to escape values in\n+     *\n+     * @return String with escaped values\n+     */\n+    // improved with code from  cybertiger@cyberiantiger.org\n+    // unicode from him, and defaul for < 32's.\n+    public static String escape(String str) {\n+        int sz = str.length();\n+        StringBuffer buffer = new StringBuffer(2*sz);\n+        for(int i=0; i<sz; i++) {\n+            char ch = str.charAt(i);\n+\n+            // handle unicode\n+            if(ch > 0xfff) {\n+                buffer.append(\"\\\\u\"+Integer.toHexString(ch));\n+            } else \n+            if(ch > 0xff) {\n+                buffer.append(\"\\\\u0\"+Integer.toHexString(ch));\n+            } else \n+            if(ch > 0x7f) {\n+                buffer.append(\"\\\\u00\"+Integer.toHexString(ch));\n+            } else \n+            if(ch < 32) {\n+                switch(ch) {\n+                    case '\\b' : \n+                        buffer.append('\\\\');\n+                        buffer.append('b');\n+                        break;\n+                    case '\\n' : \n+                        buffer.append('\\\\');\n+                        buffer.append('n');\n+                        break;\n+                    case '\\t' : \n+                        buffer.append('\\\\');\n+                        buffer.append('t');\n+                        break;\n+                    case '\\f' : \n+                        buffer.append('\\\\');\n+                        buffer.append('f');\n+                        break;\n+                    case '\\r' : \n+                        buffer.append('\\\\');\n+                        buffer.append('r');\n+                        break;\n+                    default :\n+                        if( ch > 0xf ) {\n+                            buffer.append(\"\\\\u00\"+Integer.toHexString(ch));\n+                        } else {\n+                            buffer.append(\"\\\\u000\"+Integer.toHexString(ch));\n+                        }\n+                        break;\n+                }\n+            } else {\n+                switch(ch) {\n+                    case '\\'' : \n+                        buffer.append('\\\\');\n+                        buffer.append('\\'');\n+                        break;\n+                    case '\"' : \n+                        buffer.append('\\\\');\n+                        buffer.append('\"');\n+                        break;\n+                    case '\\\\' : \n+                        buffer.append('\\\\');\n+                        buffer.append('\\\\');\n+                        break;\n+                    default :\n+                        buffer.append(ch);\n+                        break;\n+                }\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Padding\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Repeat a string n times to form a new string.\n+     *\n+     * @param str  String to repeat\n+     * @param repeat  int number of times to repeat\n+     * @return String with repeated string\n+     */\n+    public static String repeat(String str, int repeat) {\n+        StringBuffer buffer = new StringBuffer(repeat * str.length());\n+        for (int i = 0; i < repeat; i++) {\n+            buffer.append(str);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Right pad a String with spaces. Pad to a size of n.\n+     * \n+     * @param str  String to repeat\n+     * @param size  int number of times to repeat\n+     * @return String with repeated string\n+     */\n+    public static String rightPad(String str, int size) {\n+        return rightPad(str, size, \" \");\n+    }\n+    \n+    /**\n+     * Right pad a String with a specified string. Pad to a size of n.\n+     *\n+     * @param str  String to pad out\n+     * @param size  int size to pad to\n+     * @param delim  String to pad with\n+     */\n+    public static String rightPad(String str, int size, String delim) {\n+        size = (size - str.length()) / delim.length();\n+        if (size > 0) {\n+            str += repeat(delim, size);\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * Left pad a String with spaces. Pad to a size of n.\n+     *\n+     * @param str  String to pad out\n+     * @param size  int size to pad to\n+     */\n+    public static String leftPad(String str, int size) {\n+        return leftPad(str, size, \" \");\n+    }\n+    /**\n+     * Left pad a String with a specified string. Pad to a size of n.\n+     *\n+     * @param str  String to pad out\n+     * @param size  int size to pad to\n+     * @param delim  String to pad with\n+     */\n+    public static String leftPad(String str, int size, String delim) {\n+        size = (size - str.length()) / delim.length();\n+        if (size > 0) {\n+            str = repeat(delim, size) + str;\n+        }\n+        return str;\n+    }\n+\n+    // Stripping\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Remove whitespace from the front and back of a String.\n+     * \n+     * @param str  the string to remove whitespace from\n+     * @return the stripped string\n+     */\n+    public static String strip(String str) {\n+        return strip(str, null);\n+    }\n+    /**\n+     * Remove a specified String from the front and back of a \n+     * String. If Whitespace is wanted to be removed, used the \n+     * strip(String) method.\n+     * \n+     * @param str  the string to remove a string from\n+     * @param delim  the string to remove at start and end\n+     * @return the stripped string\n+     */\n+    public static String strip(String str, String delim) {\n+        str = stripStart(str, delim);\n+        return stripEnd(str, delim);\n+    }\n+\n+    /**\n+     * Strip whitespace from the front and back of every string\n+     * in the array.\n+     * \n+     * @param strs  the strings to remove whitespace from\n+     * @return the stripped strings\n+     */\n+    public static String[] stripAll(String[] strs) {\n+        return stripAll(strs, null);\n+    }\n+ \n+    /**\n+     * Strip the specified delimiter from the front and back of\n+     * every String in the array.\n+     * \n+     * @param strs  the strings to remove a string from\n+     * @param delim  the string to remove at start and end\n+     * @return the stripped strings\n+     */\n+    public static String[] stripAll(String[] strs, String delimiter) {\n+        if ((strs == null) || (strs.length == 0)) {\n+            return strs;\n+        }\n+        int sz = strs.length;\n+        String[] newArr = new String[sz];\n+        for (int i = 0; i < sz; i++) {\n+            newArr[i] = strip(strs[i], delimiter);\n+        }\n+        return newArr;\n+    }   \n+\n+    /**\n+     * Strip any of a supplied string (first letter) from the end of a String..\n+     * If the strip string is null, whitespace is stripped.\n+     * \n+     * @param str  the string to remove characters from\n+     * @param strip  the string to remove\n+     * @return the stripped string\n+     */\n+    public static String stripEnd(String str, String strip) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int end = str.length();\n+ \n+        if (strip == null) {\n+            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+                end--;\n+            }\n+        } else {\n+            char chr = strip.charAt(0);\n+            while ((end != 0) && (str.charAt(end - 1) == chr)) {\n+                end--;\n+            }\n+        }\n+        return str.substring(0, end);\n+    }\n+\n+    /**\n+     * Strip any of a supplied string (first letter) from the start of a String.\n+     * If the strip string is null, whitespace is stripped.\n+     * \n+     * @param str  the string to remove characters from\n+     * @param strip  the string to remove\n+     * @return the stripped string\n+     */\n+    public static String stripStart(String str, String strip) {\n+        if (str == null) {\n+            return null;\n+        }\n+ \n+        int start = 0;\n+ \n+        int sz = str.length();\n+ \n+        if (strip == null) {\n+            while ((start != sz) && Character.isWhitespace(str.charAt(start))) {\n+                start++;\n+            }\n+        } else {\n+            char chr = strip.charAt(0);\n+            while ((start != sz) && (str.charAt(start) == chr)) {\n+                start++;\n+            }\n+        }\n+        return str.substring(start);\n+    }\n+\n+    // Case conversion\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Convert a String to upper case, null string returns null.\n+     * \n+     * @param str  the string to uppercase\n+     * @return the upper cased string\n+     */\n+    public static String upperCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase();\n+    }\n+\n+    /**\n+     * Convert a String to lower case, null string returns null.\n+     * \n+     * @param str  the string to lowercase\n+     * @return the lower cased string\n+     */\n+    public static String lowerCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase();\n+    }\n+\n+    /**\n+     * Uncapitalise a string. That is, convert the first character into \n+     * lower-case. Null is returned as null.\n+     *\n+     * @param str  the string to uncapitalise\n+     * @return uncapitalised string\n+     */\n+    public static String uncapitalise(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return \"\";\n+        }\n+        return new StringBuffer(str.length())\n+            .append(Character.toLowerCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * Capitalise a string. That is, convert the first character into \n+     * title-case. Null is returned as null.\n+     *\n+     * @param str  the string to capitalise\n+     * @return capitalised string\n+     */\n+    public static String capitalise(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return \"\";\n+        }\n+        return new StringBuffer(str.length())\n+            .append(Character.toTitleCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * Swaps the case of String. Properly looks after \n+     * making sure the start of words are Titlecase and not \n+     * Uppercase. Null is returned as null.\n+     * \n+     * @param str  the string to swap the case of\n+     * @return the modified string\n+     */\n+    public static String swapCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int sz = str.length();\n+        StringBuffer buffer = new StringBuffer(sz);\n+\n+        boolean whitespace = false;\n+        char ch = 0;\n+        char tmp = 0;\n+\n+        for(int i=0; i<sz; i++) {\n+            ch = str.charAt(i);\n+            if(Character.isUpperCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else\n+            if(Character.isTitleCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else\n+            if(Character.isLowerCase(ch)) {\n+                if(whitespace) {\n+                    tmp = Character.toTitleCase(ch);\n+                } else {\n+                    tmp = Character.toUpperCase(ch);\n+                }\n+            } else {\n+                tmp = ch;\n+            }\n+            buffer.append(tmp);\n+            whitespace = Character.isWhitespace(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+\n+    /**\n+     * Capitalise all the words in a string. Uses Character.isWhitespace \n+     * as a separator between words. Null will return null.\n+     *\n+     * @param str  the string to capitalise\n+     * @return capitalised string\n+     */\n+    public static String capitaliseAllWords(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int sz = str.length();\n+        StringBuffer buffer = new StringBuffer(sz);\n+        boolean space = true;\n+        for(int i=0; i<sz; i++) {\n+            char ch = str.charAt(i);\n+            if(Character.isWhitespace(ch)) {\n+                buffer.append(ch);\n+                space = true;\n+            } else\n+            if(space) {\n+                buffer.append(Character.toTitleCase(ch));\n+                space = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Nested extraction\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Get the String that is nested in between two instances of the \n+     * same String.\n+     *\n+     * @param str  the string containing nested-string\n+     * @param tag  the string before and after nested-string\n+     * @return the string that was nested, or null\n+     */\n+    public static String getNestedString(String str, String tag) {\n+        return getNestedString(str, tag, tag);\n+    }\n+    \n+    /**\n+     * Get the string that is nested in between two strings.\n+     *\n+     * @param str  the string containing nested-string\n+     * @param open  the string before nested-string\n+     * @param close  the string after nested-string\n+     * @return the string that was nested, or null\n+     */\n+    public static String getNestedString(String str, String open, String close) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int start = str.indexOf(open);\n+        if (start != -1) {\n+            int end = str.indexOf(close, start + open.length());\n+            if (end != -1) {\n+                return str.substring(start + open.length(), end);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * How many times is the substring in the larger string.\n+     * Null returns 0.\n+     * \n+     * @param str  the string to check\n+     * @return the number of occurances, 0 if the string is null\n+     */\n+    public static int countMatches(String str, String sub) {\n+        if (str == null) {\n+            return 0;\n+        }\n+        int count = 0;\n+        int idx = 0;\n+        while ((idx = str.indexOf(sub, idx)) != -1) {\n+            count++;\n+            idx += sub.length();\n+        }\n+        return count;\n+    }\n+\n+    // Character Tests\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Checks if the string contains only unicode letters.\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains letters, and is non-null\n+     */\n+    public static boolean isAlpha(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetter(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the string contains only unicode letters and space (' ').\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains letters and space, and is non-null\n+     */\n+    public static boolean isAlphaSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetter(str.charAt(i)) == false) &&\n+                (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the string contains only unicode letters or digits.\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains letters or digits, and is non-null\n+     */\n+    public static boolean isAlphanumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the string contains only unicode letters, digits or space (' ').\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains letters, digits or space, and is non-null\n+     */\n+    public static boolean isAlphanumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetterOrDigit(str.charAt(i)) == false) &&\n+                (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the string contains only unicode digits.\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains digits, and is non-null\n+     */\n+    public static boolean isNumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the string contains only unicode digits or space (' ').\n+     * Null will return null.\n+     * \n+     * @param str  the string to check\n+     * @return true if only contains digits or space, and is non-null\n+     */\n+    public static boolean isNumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isDigit(str.charAt(i)) == false) &&\n+                (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Defaults\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Return either the passed in String, or if it is null, \n+     * then an empty String.\n+     * \n+     * @param str  the string to check\n+     * @return the passed in string, or blank if it was null\n+     */\n+    public static String defaultString(String str) {\n+        return defaultString(str, \"\");\n+    }\n+\n+    /**\n+     * Return either the passed in String, or if it is null, \n+     * then a passed in default String.\n+     * \n+     * @param str  the string to check\n+     * @param defaultString  the default string to return is str is null\n+     * @return the passed in string, or the default if it was null\n+     */\n+    public static String defaultString(String str, String defaultString) {\n+        return (str == null) ? defaultString : str;\n+    }\n+\n+    // Reversing\n+    //--------------------------------------------------------------------------\n+\n+    /**\n+     * Reverse a String, null string returns null.\n+     * \n+     * @param str  the string to reverse\n+     * @return the reversed string\n+     */\n+    public static String reverse(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new StringBuffer(str).reverse().toString();\n+    }\n+\n+    /**\n+     * Reverses a string that is delimited by a specific character.\n+     * The strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter is '.').\n+     * \n+     * @param str  the string to reverse\n+     * @param delimiter  the delimiter to use\n+     * @return the reversed string\n+     */\n+    public static String reverseDelimitedString(String str, String delimiter) {\n+        // could implement manually, but simple way is to reuse other, \n+        // probably slower, methods.\n+        String[] strs = split(str, delimiter);\n+        reverseArray(strs);\n+        return join(strs, delimiter);\n+    }\n+\n+    /**\n+     * Reverses an array. \n+     * TAKEN FROM CollectionsUtils.\n+     */\n+    private static void reverseArray(Object[] array) {\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+\n+    // Misc\n+    //--------------------------------------------------------------------------\n+    \n+    /**\n+     * Get the stack trace from a Throwable as a String.\n+     * <p>\n+     * This method uses printStackTrace() internally to obtain the stack trace.\n+     *\n+     * @see java.lang.Throwable#printStackTrace()\n+     * @param throwable  the throwable to extract a stack trace from\n+     * @return the extracted stack trace, or null if an error occurs\n+     */\n+    public static String stackTrace(Throwable throwable) {\n+        String trace = null;\n+        try {\n+            // And show the Error Screen.\n+            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+            throwable.printStackTrace( new PrintWriter(buf, true) );\n+            trace = buf.toString();\n+            \n+        } catch (Exception ex) {\n+            // ignore\n+        }\n+        return trace;\n+    }\n+\n+    /**\n+     * Find the Levenshtein distance between two strings.\n+     * This is the number of changes needed to change one string into \n+     * another. Where each change is a single character modification.\n+     *\n+     * This implemmentation of the levenshtein distance algorithm \n+     * is from http://www.merriampark.com/ld.htm\n+     */\n+    public static int getLevenshteinDistance(String s, String t) {\n+        int d[][]; // matrix\n+        int n; // length of s\n+        int m; // length of t\n+        int i; // iterates through s\n+        int j; // iterates through t\n+        char s_i; // ith character of s\n+        char t_j; // jth character of t\n+        int cost; // cost\n+\n+        // Step 1\n+        n = s.length ();\n+        m = t.length ();\n+        if (n == 0) {\n+            return m;\n+        }\n+        if (m == 0) {\n+            return n;\n+        }\n+        d = new int[n+1][m+1];\n+\n+        // Step 2\n+        for (i = 0; i <= n; i++) {\n+            d[i][0] = i;\n+        }\n+\n+        for (j = 0; j <= m; j++) {\n+            d[0][j] = j;\n+        }\n+\n+        // Step 3\n+        for (i = 1; i <= n; i++) {\n+            s_i = s.charAt (i - 1);\n+\n+            // Step 4\n+            for (j = 1; j <= m; j++) {\n+                t_j = t.charAt (j - 1);\n+\n+                // Step 5\n+                if (s_i == t_j) {\n+                    cost = 0;\n+                } else {\n+                    cost = 1;\n+                }\n+\n+                // Step 6\n+                d[i][j] = NumberUtils.minimum(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1] + cost);\n+            }\n+        }\n+\n+        // Step 7\n+        return d[n][m];\n+    }\n+\n+    /**\n+     * Convert a string from unicode to bytes in a native encoding.\n+     * The string must be in unicode (as Java always expects this);\n+     * {@link #convertNativeToUnicode(String, String)} will convert\n+     * strings in native encodings into unicode.  This method is\n+     * generally used to create a <code>String</code> for use as\n+     * output, and is useful when dealing with I18N.\n+     *\n+     * @param source String the unicode string to convert\n+     * @param charset String the name of the charset into which to\n+     * convert.\n+     * @return The string given represented in the native encoding\n+     * specified.\n+     * @see #convertNativeToUnicode(String, String)\n+     */\n+    public static String convertUnicodeToNative(String source, String charset)\n+            throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        OutputStreamWriter out = new OutputStreamWriter(baos, charset);\n+        out.write(source);\n+        out.close();\n+        return baos.toString();\n+    }\n+\n+    /**\n+     * Convert a string from a native encoding to unicode.  This\n+     * method is generally used to create a <code>String</code> for\n+     * use as input, and is useful when dealing with I18N.\n+     *\n+     * @param input String the input to convert from native encoding\n+     * to unicode.\n+     * @param charset String the charset from which to convert.\n+     * @return The string given represented in unicode rather than the\n+     * specified native encoding.\n+     */\n+    public static String convertNativeToUnicode(String input, String charset)\n+            throws IOException {\n+        InputStreamReader in = new InputStreamReader\n+            (new ByteArrayInputStream(input.getBytes()), charset);\n+        StringBuffer output = new StringBuffer();\n+        char[] buf = new char[CHAR_BUFFER_SIZE];\n+        int count = 0;\n+        while ((count = in.read(buf, 0, CHAR_BUFFER_SIZE)) > 0)\n+        {\n+            output.append(buf, 0, count);\n+        }\n+        in.close();\n+        return output.toString();\n+    }\n+    \n+// these are not really of use in the Java world. Only if you're a C afficionado\n+//    public static String sprintf(String format, Object[] list);\n+//    public static Object[] sscanf(String str, String format);\n+//    public static String pack(String[] strs, String format);\n+//    public static String[] unpack(String str, String format);\n+\n+}\n+\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/exception/Nestable.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.PrintWriter;\n+\n+/**\n+ * An interface to be implemented by {@link java.lang.Throwable}\n+ * extensions which would like to be able to nest root exceptions\n+ * inside themselves.\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: Nestable.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public interface Nestable\n+{\n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause();\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength();\n+    \n+    /**\n+     * Returns the error message of this and any nested\n+     * <code>Throwable</code>.\n+     *\n+     * @return The error message.\n+     */\n+    public String getMessage();\n+\n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbererd from 0.\n+     * If <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the message of the last <code>Throwable</code> in the\n+     * chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the error message\n+     */\n+    public String getMessage(int index);\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the error messages\n+     */\n+    public String[] getMessages();\n+\n+    /**\n+     * Returns the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s at the specified index, numbererd from 0. If\n+     * <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the last <code>Throwable</code> in the chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the <code>Throwable</code>\n+     */\n+    public Throwable getThrowable(int index);\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the <code>Throwable</code>s\n+     */\n+    public Throwable[] getThrowables();\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type in the chain of <code>Throwable</code>s, or -1 if the\n+     * specified type is not found in the chain. If <code>pos</code> is\n+     * negative, the effect is the same as if it were 0. If <code>pos</code>\n+     * is greater than or equal to the length of the chain, the effect is the\n+     * same as if it were the index of the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type);\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified position, or -1 if\n+     * the type is not found. If <code>pos</code> is negative, the effect is the\n+     * same as if it were 0. If <code>pos</code> is greater than or equal to the\n+     * length of the chain, the effect is the same as if it were the index of\n+     * the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos index, numbered from 0, of the starting position in the chain\n+     * to be searched\n+     * \n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type);\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * writer.  Includes inforamation from the exception--if\n+     * any--which caused this exception.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out);\n+\n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/exception/NestableDelegate.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.util.LinkedList;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: NestableDelegate.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class NestableDelegate\n+{\n+    /**\n+     * Constructor error message.\n+     */\n+    private static final String MUST_BE_THROWABLE =\n+        \"The Nestable implementation passed to the NestableDelegate(Nestable) \"\n+        + \"constructor must extend java.lang.Throwable\";\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Nestable cause = null;\n+\n+    /**\n+     * @param cause The Nestable implementation to get a stack trace for\n+     * (<i>must</i> extend {@link java.lang.Throwable}).\n+     */\n+    NestableDelegate(Nestable cause) // package\n+    {\n+        if (cause instanceof Throwable)\n+        {\n+            this.cause = cause;\n+        }\n+        else\n+        {\n+            throw new IllegalArgumentException(MUST_BE_THROWABLE);\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of <code>Throwable</code>s contained in the\n+     * <code>Nestable</code> contained by this delegate.\n+     */\n+    int getLength() // package\n+    {\n+        // Count the number of throwables\n+        int count = 1;\n+        String msg = null;\n+        if(this.cause.getCause() == null)\n+        {\n+            return count;\n+        }\n+        Throwable t = this.cause.getCause();\n+        while(t != null)\n+        {\n+            ++count;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                t = ((Nestable) t).getCause();\n+            }\n+            else\n+            {\n+                t = null;\n+            }\n+        }\n+        return count;\n+    }\n+    \n+    /**\n+     * @param baseMsg The base message to use when creating the full\n+     * message.  Should be generally be called via\n+     * <code>nestableHelper.getMessage(super.getMessage())</code>,\n+     * where <code>super</code> is an instance of {@link\n+     * java.lang.Throwable}.\n+     * @return The concatenated message for this and all nested\n+     * exceptions.\n+     */\n+    String getMessage(String baseMsg) // package\n+    {\n+        StringBuffer msg = new StringBuffer();\n+        if (baseMsg != null)\n+        {\n+            msg.append(baseMsg);\n+        }\n+\n+        Throwable nestedCause = cause.getCause();\n+        if (nestedCause != null)\n+        {\n+            String causeMsg = nestedCause.getMessage();\n+            if (causeMsg != null)\n+            {\n+                if (baseMsg != null)\n+                {\n+                    msg.append(\": \");\n+                }\n+                msg.append(causeMsg);\n+            }\n+\n+        }\n+        return (msg.length() > 0 ? msg.toString() : null);\n+    }\n+\n+    String getMessage(int index)\n+    {\n+        Throwable t = this.getThrowable(index);\n+        if(Nestable.class.isInstance(t))\n+        {\n+            return ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            return t.getMessage();\n+        }\n+    }\n+    \n+    Throwable getThrowable(int index)\n+    {\n+        Throwable[] throwables = this.getThrowables();\n+        if(index < 0)\n+        {\n+            index = 0;\n+        }\n+        if(index == 0)\n+        {\n+            return (Throwable) this.cause;\n+        }\n+        if(index >= throwables.length)\n+        {\n+            index = throwables.length - 1;\n+        }\n+        return throwables[index];\n+    }\n+    \n+    Throwable[] getThrowables() // package\n+    {\n+        int count = this.getLength();\n+        // Allocate an array to hold the messages\n+        Throwable[] throwables = new Throwable[count];\n+        count = 0;\n+        if(cause != null)\n+        {\n+            throwables[count++] = (Throwable) this.cause;\n+            Throwable t = this.cause.getCause();\n+            while(t != null)\n+            {\n+                throwables[count++] = t;\n+                if(Nestable.class.isInstance(t))\n+                {\n+                    t = ((Nestable) t).getCause();\n+                }\n+                else\n+                {\n+                    t = null;\n+                }\n+            }\n+        }\n+        return throwables;\n+    }\n+\n+    String[] getMessages() // package\n+    {\n+        Throwable throwables[] = this.getThrowables();\n+        String[] msgs = new String[throwables.length];\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            msgs[i] = (Nestable.class.isInstance(throwables[i]) ? ((Nestable) throwables[i]).getMessage(0) : throwables[i].getMessage());\n+        }\n+        return msgs;\n+    }\n+\n+    int indexOfThrowable(int pos, Class type) // package\n+    {\n+        pos = (pos < 0) ? 0 : pos;\n+        Throwable throwables[] = this.getThrowables();\n+        pos = (pos >= throwables.length) ? throwables.length - 1 : pos;\n+        for(int i = pos; i < throwables.length; i++)\n+        {\n+            if(throwables[i].getClass().equals(type))\n+            {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception the the standar error\n+     * stream.\n+     */\n+    public void printStackTrace()\n+    {\n+        synchronized (System.err)\n+        {\n+            printStackTrace(System.err);\n+        }\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print stream.\n+     *\n+     * @param out <code>PrintStream</code> to use for output.\n+     */\n+    public void printStackTrace(PrintStream out)\n+    {\n+        synchronized (out)\n+        {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print writer.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+        synchronized (out)\n+        {\n+            String[] st = decompose((Throwable) cause);\n+            Throwable nestedCause = cause.getCause();\n+            if (nestedCause != null)\n+            {\n+                if (nestedCause instanceof Nestable)\n+                {\n+                    // Recurse until a non-Nestable is encountered.\n+                    ((Nestable) nestedCause).printStackTrace(out);\n+                }\n+                else\n+                {\n+                    String[] nst = decompose(nestedCause);\n+                    for (int i = 0; i < nst.length; i++)\n+                    {\n+                        out.println(nst[i]);\n+                    }\n+                }\n+                out.print(\"rethrown as \");\n+            }\n+\n+            // Output desired frames from stack trace.\n+            for (int i = 0; i < st.length; i++)\n+            {\n+                out.println(st[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Captures the stack trace associated with a <code>Throwable</code>\n+     * object, decomposing it into a list of stack frames.\n+     *\n+     * @param t The <code>Throwable</code>.\n+     * @return  An array of strings describing each stack frame.\n+     */\n+    private String[] decompose(Throwable t)\n+    {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+\n+        // Avoid infinite loop between decompose() and printStackTrace().\n+        if (t instanceof Nestable)\n+        {\n+            ((Nestable) t).printPartialStackTrace(pw);\n+        }\n+        else\n+        {\n+            t.printStackTrace(pw);\n+        }\n+\n+        String linebreak = System.getProperty(\"line.separator\");\n+        StringTokenizer st = new StringTokenizer(sw.getBuffer().toString(),\n+                                                 linebreak);\n+        LinkedList list = new LinkedList();\n+        while (st.hasMoreTokens())\n+        {\n+            list.add(st.nextToken());\n+        }\n+        return (String []) list.toArray(new String[] {});\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/exception/NestableException.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.util.LinkedList;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * The base class of all exceptions which can contain other exceptions.\n+ *\n+ * It is intended to ease the debugging by carrying on the information\n+ * about the exception which was caught and provoked throwing the\n+ * current exception. Catching and rethrowing may occur multiple\n+ * times, and provided that all exceptions except the first one\n+ * are descendands of <code>NestedException</code>, when the\n+ * exception is finally printed out using any of the <code>\n+ * printStackTrace()</code> methods, the stacktrace will contain\n+ * the information about all exceptions thrown and caught on\n+ * the way.\n+ * <p> Running the following program\n+ * <p><blockquote><pre>\n+ *  1 import org.apache.commons.NestedException;\n+ *  2\n+ *  3 public class Test {\n+ *  4     public static void main( String[] args ) {\n+ *  5         try {\n+ *  6             a();\n+ *  7         } catch(Exception e) {\n+ *  8             e.printStackTrace();\n+ *  9         }\n+ * 10      }\n+ * 11\n+ * 12      public static void a() throws Exception {\n+ * 13          try {\n+ * 14              b();\n+ * 15          } catch(Exception e) {\n+ * 16              throw new NestedException(\"foo\", e);\n+ * 17          }\n+ * 18      }\n+ * 19\n+ * 20      public static void b() throws Exception {\n+ * 21          try {\n+ * 22              c();\n+ * 23          } catch(Exception e) {\n+ * 24              throw new NestedException(\"bar\", e);\n+ * 25          }\n+ * 26      }\n+ * 27\n+ * 28      public static void c() throws Exception {\n+ * 29          throw new Exception(\"baz\");\n+ * 30      }\n+ * 31 }\n+ * </pre></blockquote>\n+ * <p>Yields the following stacktrace:\n+ * <p><blockquote><pre>\n+ * java.lang.Exception: baz: bar: foo\n+ *    at Test.c(Test.java:29)\n+ *    at Test.b(Test.java:22)\n+ * rethrown as NestedException: bar\n+ *    at Test.b(Test.java:24)\n+ *    at Test.a(Test.java:14)\n+ * rethrown as NestedException: foo\n+ *    at Test.a(Test.java:16)\n+ *    at Test.main(Test.java:6)\n+ * </pre></blockquote><br>\n+ *\n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: NestableException.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class NestableException extends Exception implements Nestable\n+{\n+    /**\n+     * The helper instance which contains much of the code which we\n+     * delegate to.\n+     */\n+    protected NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause = null;\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> without specified\n+     * detail message.\n+     */\n+    public NestableException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg The error message.\n+     */\n+    public NestableException(String msg)\n+    {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public NestableException(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    The error message.\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public NestableException(String msg, Throwable cause)\n+    {\n+        super(msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength()\n+    {\n+        return delegate.getLength();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#getMessage()\n+     */\n+    public String getMessage()\n+    {\n+        StringBuffer msg = new StringBuffer();\n+        String ourMsg = super.getMessage();\n+        if (ourMsg != null)\n+        {\n+            msg.append(ourMsg);\n+        }\n+        if (cause != null)\n+        {\n+            String causeMsg = cause.getMessage();\n+            if (causeMsg != null)\n+            {\n+                if (ourMsg != null)\n+                {\n+                    msg.append(\": \");\n+                }\n+                msg.append(causeMsg);\n+            }\n+\n+        }\n+        return (msg.length() > 0 ? msg.toString() : null);\n+    }\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     */\n+    public String[] getMessages()\n+    {\n+        return delegate.getMessages();\n+    }\n+    \n+    public Throwable getThrowable(int index)\n+    {\n+        return delegate.getThrowable(index);\n+    }\n+    \n+    public Throwable[] getThrowables()\n+    {\n+        return delegate.getThrowables();\n+    }\n+    \n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return delegate.getMessage(index);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type in the chain of <code>Throwable</code>s, or -1 if the\n+     * specified type is not found in the chain. If <code>pos</code> is\n+     * negative, the effect is the same as if it were 0. If <code>pos</code>\n+     * is greater than or equal to the length of the chain, the effect is the\n+     * same as if it were the index of the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return delegate.indexOfThrowable(0, type);\n+    }\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified position, or -1 if\n+     * the type is not found. If <code>pos</code> is negative, the effect is the\n+     * same as if it were 0. If <code>pos</code> is greater than or equal to the\n+     * length of the chain, the effect is the same as if it were the index of\n+     * the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos index, numbered from 0, of the starting position in the chain\n+     * to be searched\n+     * \n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return delegate.indexOfThrowable(pos, type);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception the the standar error\n+     * stream.\n+     */\n+    public void printStackTrace()\n+    {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print stream.\n+     *\n+     * @param out <code>PrintStream</code> to use for output.\n+     */\n+    public void printStackTrace(PrintStream out)\n+    {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#printStackTrace(PrintWriter out)\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#printPartialStackTrace(PrintWriter out)\n+     */\n+    public final void printPartialStackTrace(PrintWriter out)\n+    {\n+        super.printStackTrace(out);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/exception/NestableRuntimeException.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.util.LinkedList;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * The base class of all runtime exceptions which can contain other\n+ * exceptions.\n+ *\n+ * @see org.apache.commons.lang.exception.NestableException\n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: NestableRuntimeException.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class NestableRuntimeException extends RuntimeException\n+    implements Nestable\n+{\n+    /**\n+     * The helper instance which contains much of the code which we\n+     * delegate to.\n+     */\n+    protected NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause = null;\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> without specified\n+     * detail message.\n+     */\n+    public NestableRuntimeException()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg The error message.\n+     */\n+    public NestableRuntimeException(String msg)\n+    {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public NestableRuntimeException(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    The error message.\n+     * @param nested The exception or error that caused this exception\n+     *               to be thrown.\n+     */\n+    public NestableRuntimeException(String msg, Throwable cause)\n+    {\n+        super(msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength()\n+    {\n+        return delegate.getLength();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#getMessage()\n+     */\n+    public String getMessage()\n+    {\n+        StringBuffer msg = new StringBuffer();\n+        String ourMsg = super.getMessage();\n+        if (ourMsg != null)\n+        {\n+            msg.append(ourMsg);\n+        }\n+        if (cause != null)\n+        {\n+            String causeMsg = cause.getMessage();\n+            if (causeMsg != null)\n+            {\n+                if (ourMsg != null)\n+                {\n+                    msg.append(\": \");\n+                }\n+                msg.append(causeMsg);\n+            }\n+\n+        }\n+        return (msg.length() > 0 ? msg.toString() : null);\n+    }\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     */\n+    public String[] getMessages()\n+    {\n+        return delegate.getMessages();\n+    }\n+    \n+    public Throwable getThrowable(int index)\n+    {\n+        return delegate.getThrowable(index);\n+    }\n+    \n+    public Throwable[] getThrowables()\n+    {\n+        return delegate.getThrowables();\n+    }\n+    \n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return delegate.getMessage(index);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type in the chain of <code>Throwable</code>s, or -1 if the\n+     * specified type is not found in the chain. If <code>pos</code> is\n+     * negative, the effect is the same as if it were 0. If <code>pos</code>\n+     * is greater than or equal to the length of the chain, the effect is the\n+     * same as if it were the index of the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return delegate.indexOfThrowable(0, type);\n+    }\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified position, or -1 if\n+     * the type is not found. If <code>pos</code> is negative, the effect is the\n+     * same as if it were 0. If <code>pos</code> is greater than or equal to the\n+     * length of the chain, the effect is the same as if it were the index of\n+     * the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos index, numbered from 0, of the starting position in the chain\n+     * to be searched\n+     * \n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return delegate.indexOfThrowable(pos, type);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception the the standar error\n+     * stream.\n+     */\n+    public void printStackTrace()\n+    {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print stream.\n+     *\n+     * @param out <code>PrintStream</code> to use for output.\n+     */\n+    public void printStackTrace(PrintStream out)\n+    {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#printStackTrace(PrintWriter out)\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.lang.exception.Nestable#printPartialStackTrace(PrintWriter out)\n+     */\n+    public final void printPartialStackTrace(PrintWriter out)\n+    {\n+        super.printStackTrace(out);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/CharSetUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharSetUtils}.\n+ *\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: CharSetUtilsTest.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class CharSetUtilsTest extends TestCase\n+{\n+    public CharSetUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(CharSetUtilsTest.class);\n+    \tsuite.setName(\"CharSetUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testSqueeze()\n+    {\n+        assertEquals(\"squeeze(String,String[]) failed\",\n+                     \"helo\", CharSetUtils.squeeze(\"hello\", new String[] {\"el\"}));\n+        assertEquals(\"squeeze(String,String[]) failed\",\n+                     \"\", CharSetUtils.squeeze(\"\", new String[] {\"el\"}));\n+        assertEquals(\"squeeze(String,String[]) failed\",\n+                     \"hello\", CharSetUtils.squeeze(\"hello\", new String[] {\"e\"}));\n+        assertEquals(\"squeeze(String,String[]) failed\",\n+                     \"fofof\", CharSetUtils.squeeze(\"fooffooff\", new String[] {\"of\"}));\n+        assertEquals(\"squeeze(String,String[]) failed\",\n+                     \"fof\", CharSetUtils.squeeze(\"fooooff\", new String[] {\"fo\"}));\n+    }\n+\n+    public void testCount()\n+    {\n+        assertEquals(\"count(String,String[]) failed\",\n+                     3, CharSetUtils.count(\"hello\", new String[] {\"el\"}));\n+        assertEquals(\"count(String,String[]) failed\",\n+                     0, CharSetUtils.count(\"\", new String[] {\"el\"}));\n+        assertEquals(\"count(String,String[]) failed\",\n+                     0, CharSetUtils.count(\"hello\", new String[] {\"x\"}));\n+        assertEquals(\"count(String,String[]) failed\",\n+                     2, CharSetUtils.count(\"hello\", new String[] {\"e-i\"}));\n+        assertEquals(\"count(String,String[]) failed\",\n+                     5, CharSetUtils.count(\"hello\", new String[] {\"a-z\"}));\n+        assertEquals(\"count(String,String[]) failed\",\n+                     0, CharSetUtils.count(\"hello\", new String[] {\"\"}));\n+    }\n+\n+    public void testDelete()\n+    {\n+        assertEquals(\"delete(String,String[]) failed\",\n+                     \"ho\", CharSetUtils.delete(\"hello\", new String[] {\"el\"}));\n+        assertEquals(\"delete(String,String[]) failed\",\n+                     \"\", CharSetUtils.delete(\"hello\", new String[] {\"elho\"}));\n+        assertEquals(\"delete(String,String[]) failed\",\n+                     \"hello\", CharSetUtils.delete(\"hello\", new String[] {\"\"}));\n+        assertEquals(\"delete(String,String[]) failed\",\n+                     \"\", CharSetUtils.delete(\"hello\", new String[] {\"a-z\"}));\n+        assertEquals(\"delete(String,String[]) failed\",\n+                     \"heo\", CharSetUtils.delete(\"hello\", new String[] {\"l\"}));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Test suite for the Lang package.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: LangTestSuite.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ */\n+public class LangTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public LangTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang Tests\");\n+        suite.addTest(CharSetUtilsTest.suite());\n+        suite.addTest(NumberRangeTest.suite());\n+        suite.addTest(NumberUtilsTest.suite());\n+        suite.addTest(ObjectUtilsTest.suite());\n+        suite.addTest(RandomStringUtilsTest.suite());\n+        suite.addTest(SerializationUtilsTest.suite());\n+        suite.addTest(StringUtilsTest.suite());\n+        suite.addTest(StringUtilsTrimEmptyTest.suite());\n+        suite.addTest(StringUtilsSubstringTest.suite());\n+        suite.addTest(StringUtilsEqualsIndexOfTest.suite());\n+        suite.addTest(StringUtilsIsTest.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/NumberRangeTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+\n+/**\n+ * Test cases for the {@link NumberRange} class.\n+ *\n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Revision: 1.1 $ $Date: 2002/07/19 03:35:55 $\n+ */\n+\n+public final class NumberRangeTest extends TestCase {\n+\n+\n+    private NumberRange tenToTwenty;\n+    private Number five;\n+    private Number ten;\n+    private Number fifteen;\n+    private Number twenty;\n+    private Number twentyFive;\n+\n+\n+    public NumberRangeTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    public void setUp() {\n+        five       = new Integer(5);\n+        ten        = new Integer(10);\n+        fifteen    = new Integer(15);\n+        twenty     = new Integer(20);\n+        twentyFive = new Integer(25);\n+\n+        tenToTwenty = new NumberRange(ten, twenty);\n+    }\n+\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberRangeTest.class);\n+        suite.setName(\"NumberRange Tests\");\n+        return suite;\n+    }\n+\n+\n+    public void testEquals() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.equals(new NumberRange(five, ten));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.equals(new NumberRange(ten, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.equals(new NumberRange(ten, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.equals(new NumberRange(fifteen, twenty));\n+        assertEquals(expected, result);\n+    }\n+\n+\n+    public void testIncludesNumber() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.includesNumber(five);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(ten);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(fifteen);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(twenty);\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.includesNumber(twentyFive);\n+        assertEquals(expected, result);\n+    }\n+\n+\n+    public void testIncludesRange() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.includesRange(new NumberRange(five, ten));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.includesRange(new NumberRange(five, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(ten, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(ten, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(fifteen, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = \n+            tenToTwenty.includesRange(new NumberRange(fifteen, twentyFive));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = \n+            tenToTwenty.includesRange(new NumberRange(twenty, twentyFive));\n+        assertEquals(expected, result);\n+    }\n+\n+\n+    public void testToString() {\n+        String expected = \"10-20\";\n+        String result = tenToTwenty.toString();\n+        assertEquals(expected, result);\n+    }\n+\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/NumberUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.NumberUtils}.\n+ *\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: NumberUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class NumberUtilsTest extends TestCase {\n+\n+    public NumberUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberUtilsTest.class);\n+        suite.setName(\"NumberUtils Tests\");\n+        return suite;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * Test for int stringToInt(String)\n+     */\n+    public void testStringToIntString() {\n+        assertTrue(\"stringToInt(String) 1 failed\", NumberUtils.stringToInt(\"12345\") == 12345);\n+        assertTrue(\"stringToInt(String) 2 failed\", NumberUtils.stringToInt(\"abc\") == 0);\n+    }\n+\n+    /**\n+     * Test for int stringToInt(String, int)\n+     */\n+    public void testStringToIntStringI() {\n+        assertTrue(\"stringToInt(String,int) 1 failed\", NumberUtils.stringToInt(\"12345\", 5) == 12345);\n+        assertTrue(\"stringToInt(String,int) 2 failed\", NumberUtils.stringToInt(\"1234.5\", 5) == 5);\n+    }\n+\n+    public void testCreateNumber() {\n+        //a lot of things can go wrong\n+        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n+        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n+        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\" + (Integer.MAX_VALUE + 1L)));\n+        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n+        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n+        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n+        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n+        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n+        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n+        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n+        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n+        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n+        assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils.createNumber(\"1.1E-700F\"));\n+        assertEquals(\n+            \"createNumber(String) 16 failed\",\n+            new Long(\"10\" + Integer.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n+        assertEquals(\n+            \"createNumber(String) 17 failed\",\n+            new Long(\"10\" + Integer.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Integer.MAX_VALUE));\n+        assertEquals(\n+            \"createNumber(String) 18 failed\",\n+            new BigInteger(\"10\" + Long.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Long.MAX_VALUE));\n+\n+    }\n+\n+    public void testCreateFloat() {\n+        assertEquals(\"createFloat(String) failed\", new Float(\"1234.5\"), NumberUtils.createFloat(\"1234.5\"));\n+    }\n+\n+    public void testCreateDouble() {\n+        assertEquals(\"createDouble(String) failed\", new Double(\"1234.5\"), NumberUtils.createDouble(\"1234.5\"));\n+    }\n+\n+    public void testCreateInteger() {\n+        assertEquals(\"createInteger(String) failed\", new Integer(\"12345\"), NumberUtils.createInteger(\"12345\"));\n+    }\n+\n+    public void testCreateLong() {\n+        assertEquals(\"createInteger(String) failed\", new Long(\"12345\"), NumberUtils.createLong(\"12345\"));\n+    }\n+\n+    public void testCreateBigInteger() {\n+        assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n+    }\n+\n+    public void testCreateBigDecimal() {\n+        assertEquals(\"createBigDecimal(String) failed\", new BigDecimal(\"1234.5\"), NumberUtils.createBigDecimal(\"1234.5\"));\n+    }\n+\n+    public void testMinimum() {\n+        assertEquals(\"minimum(int,int,int) 1 failed\", 12345, NumberUtils.minimum(12345, 12345 + 1, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 2 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 3 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345 + 2, 12345));\n+        assertEquals(\"minimum(int,int,int) 4 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345));\n+        assertEquals(\"minimum(int,int,int) 5 failed\", 12345, NumberUtils.minimum(12345, 12345, 12345));\n+\n+    }\n+\n+    public void testMaximum() {\n+        assertEquals(\"maximum(int,int,int) 1 failed\", 12345, NumberUtils.maximum(12345, 12345 - 1, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 2 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 3 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345 - 2, 12345));\n+        assertEquals(\"maximum(int,int,int) 4 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345));\n+        assertEquals(\"maximum(int,int,int) 5 failed\", 12345, NumberUtils.maximum(12345, 12345, 12345));\n+\n+    }\n+\n+    public void testIsDigits() {\n+        assertEquals(\"isDigits(null) failed\", false, NumberUtils.isDigits(null));\n+        assertEquals(\"isDigits('') failed\", false, NumberUtils.isDigits(\"\"));\n+        assertEquals(\"isDigits(String) failed\", true, NumberUtils.isDigits(\"12345\"));\n+        assertEquals(\"isDigits(String) neg 1 failed\", false, NumberUtils.isDigits(\"1234.5\"));\n+        assertEquals(\"isDigits(String) neg 3 failed\", false, NumberUtils.isDigits(\"1ab\"));\n+        assertEquals(\"isDigits(String) neg 4 failed\", false, NumberUtils.isDigits(\"abc\"));\n+    }\n+    \n+    /**\n+     * Tests isNumber(String) and tests that createNumber(String) returns\n+     * a valid number iff isNumber(String) returns false.\n+     */\n+    public void testIsNumber() {\n+        String val = \"12345\";\n+        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n+        val = \"1234.5\";\n+        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n+        val = \".12345\";\n+        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n+        val = \"1234E5\";\n+        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n+        val = \"1234E+5\";\n+        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n+        val = \"1234E-5\";\n+        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n+        val = \"123.4E5\";\n+        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n+        val = \"-1234\";\n+        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n+        val = \"-1234.5\";\n+        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n+        val = \"-.12345\";\n+        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n+        val = \"-1234E5\";\n+        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n+        val = \"0\";\n+        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n+        val = \"-0\";\n+        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n+        val = \"01234\";\n+        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n+        val = \"-01234\";\n+        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n+        val = \"0xABC123\";\n+        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n+        val = \"0x0\";\n+        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n+        val = \"123.4E21D\";\n+        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n+        val = \"-221.23F\";\n+        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n+        val = \"22338L\";\n+        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n+        val = null;\n+        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n+        val = \"\";\n+        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n+        val = \"--2.3\";\n+        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n+        val = \".12.3\";\n+        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E\";\n+        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E+-212\";\n+        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E2.12\";\n+        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xGF\";\n+        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xFAE-1\";\n+        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n+        val = \".\";\n+        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n+        val = \"-0ABC123\";\n+        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4E-D\";\n+        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4ED\";\n+        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n+        val = \"1234E5l\";\n+        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n+\n+    }\n+\n+    private boolean checkCreateNumber(String val) {\n+        try {\n+            Object obj = NumberUtils.createNumber(val);\n+            if(obj == null) {\n+                return false;\n+            }\n+            return true;\n+        } catch (NumberFormatException e) {\n+            return false;\n+        } catch (NullPointerException e) {\n+            return false;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/ObjectUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ObjectUtils}.\n+ *\n+ * @author <a href=\"mailto:jmcnally@collab.net\">John McNally</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: ObjectUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class ObjectUtilsTest extends TestCase\n+{\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+\n+    public ObjectUtilsTest(String name)\n+    {\n+        super(name);\n+    }\n+    \n+    public static void main(String[] args) \n+    {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() \n+    {\n+    \tTestSuite suite = new TestSuite(ObjectUtilsTest.class);\n+    \tsuite.setName(\"ObjectUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception \n+    {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception\n+    {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void testIsNull()\n+    {\n+        Object o = FOO;\n+        Object dflt = BAR;\n+        assertSame(\"dflt was not returned when o was null\", dflt,\n+                     ObjectUtils.defaultIfNull(null, dflt));\n+        assertSame(\"dflt was returned when o was not null\", o,\n+                     ObjectUtils.defaultIfNull(o, dflt));\n+    }\n+        \n+    public void testEquals()\n+    {\n+        assertTrue(\"ObjectUtils.equals(null, null) returned false\", \n+                   ObjectUtils.equals(null, null));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", null) returned true\", \n+                   !ObjectUtils.equals(FOO, null));\n+        assertTrue(\"ObjectUtils.equals(null, \\\"bar\\\") returned true\", \n+                   !ObjectUtils.equals(null, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"bar\\\") returned true\", \n+                   !ObjectUtils.equals(FOO, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"foo\\\") returned false\", \n+                   ObjectUtils.equals(FOO, FOO));\n+    }        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/RandomStringUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Commons\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import junit.framework.*;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.RandomStringUtils}.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: RandomStringUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class RandomStringUtilsTest extends junit.framework.TestCase {\n+    /**\n+     * Construct a new instance of RandomStringUtilsTest with the specified name\n+     */\n+    public RandomStringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(RandomStringUtilsTest.class);\n+    \tsuite.setName(\"RandomStringUtils Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+    \n+    /**\n+     * Test the implementation\n+     */\n+    public void testRandomStringUtils() {\n+        String r1 = RandomStringUtils.random(50);\n+        assertEquals(\"random(5) length\", 50, r1.length());\n+        String r2 = RandomStringUtils.random(50);\n+        assertEquals(\"random(5) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAscii(50);\n+        assertEquals(\"randomAscii(10) length\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"char between 32 and 127\", (int) r1.charAt(i) >= 32 && (int) r1.charAt(i) <= 127);\n+        }        \n+        r2 = RandomStringUtils.randomAscii(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+\n+        r1 = RandomStringUtils.randomAlphabetic(50);\n+        assertEquals(\"randomAlphabetic(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphabetic\", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAlphanumeric(50);\n+        assertEquals(\"randomAlphanumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphanumeric\", true, Character.isLetterOrDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomNumeric(50);\n+        assertEquals(\"randomNumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains numeric\", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomNumeric(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        String set = \"abcdefg\";\n+        r1 = RandomStringUtils.random(50, set);\n+        assertEquals(\"random(50, \\\"abcdefg\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        set = \"stuvwxyz\";\n+        r1 = RandomStringUtils.random(50, set.toCharArray());\n+        assertEquals(\"random(50, \\\"stuvwxyz\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+    }\n+\n+    public static void main(String args[]) {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/SerializationUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.SerializationUtils}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: SerializationUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class SerializationUtilsTest extends TestCase {\n+    private String iString;\n+    private Integer iInteger;\n+    private HashMap iMap;\n+\n+    public SerializationUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(SerializationUtilsTest.class);\n+    \tsuite.setName(\"SerializationUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        iString = \"foo\";\n+        iInteger = new Integer(7);\n+        iMap = new HashMap();\n+        iMap.put(\"FOO\", iString);\n+        iMap.put(\"BAR\", iInteger);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testSerializeStream() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(iMap, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamUnserializable() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap, streamTest);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullObj() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(null, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamObjNull() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            SerializationUtils.serialize(iMap, null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullNull() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            SerializationUtils.serialize(null, null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeStream() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeStreamOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeStreamNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((InputStream) null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeStreamBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testSerializeBytes() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(iMap);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeBytesUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeBytesNull() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(null);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeBytes() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeBytesOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeBytesNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((byte[]) null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeBytesBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new byte[0]);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testClone() throws Exception {\n+        Object test = SerializationUtils.clone(iMap);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testCloneNull() throws Exception {\n+        Object test = SerializationUtils.clone(null);\n+        assertNull(test);\n+    }\n+\n+    public void testCloneUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.clone(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/StringUtilsEqualsIndexOfTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class StringUtilsEqualsIndexOfTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String[] FOOBAR_SUB_ARRAY = new String[] {\"ob\", \"ba\"};\n+\n+    public StringUtilsEqualsIndexOfTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);\n+    \tsuite.setName(\"StringUtilsEqualsIndexOf Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testEquals() {\n+        assertEquals(true, StringUtils.equals(null, null));\n+        assertEquals(true, StringUtils.equals(FOO, FOO));\n+        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equals(FOO, BAR));\n+        assertEquals(false, StringUtils.equals(FOO, null));\n+        assertEquals(false, StringUtils.equals(null, FOO));\n+    }\n+\n+    public void testEqualsIgnoreCase() {\n+        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));\n+    }\n+\n+    public void testIndexOfAny() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, null));\n+        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {\"llll\"}));\n+    }\n+\n+    public void testLastIndexOfAny() {\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));\n+        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {\"llll\"}));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/StringUtilsIsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: StringUtilsIsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class StringUtilsIsTest extends TestCase {\n+\n+    public StringUtilsIsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(StringUtilsIsTest.class);\n+    \tsuite.setName(\"StringUtilsIsXxx Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testIsAlpha() {\n+        assertEquals(false, StringUtils.isAlpha(null));\n+        assertEquals(true, StringUtils.isAlpha(\"\"));\n+        assertEquals(false, StringUtils.isAlpha(\" \"));\n+        assertEquals(true, StringUtils.isAlpha(\"a\"));\n+        assertEquals(true, StringUtils.isAlpha(\"A\"));\n+        assertEquals(true, StringUtils.isAlpha(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlpha(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlpha(\"1\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlpha(\"_\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumeric() {\n+        assertEquals(false, StringUtils.isAlphanumeric(null));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphaspace() {\n+        assertEquals(false, StringUtils.isAlphaSpace(null));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"1\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumericSpace() {\n+        assertEquals(false, StringUtils.isAlphanumericSpace(null));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsNumeric() {\n+        assertEquals(false, StringUtils.isNumeric(null));\n+        assertEquals(true, StringUtils.isNumeric(\"\"));\n+        assertEquals(false, StringUtils.isNumeric(\" \"));\n+        assertEquals(false, StringUtils.isNumeric(\"a\"));\n+        assertEquals(false, StringUtils.isNumeric(\"A\"));\n+        assertEquals(false, StringUtils.isNumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1000\"));\n+        assertEquals(false, StringUtils.isNumeric(\"2.3\"));\n+        assertEquals(false, StringUtils.isNumeric(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumeric(\"_\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsNumericSpace() {\n+        assertEquals(false, StringUtils.isNumericSpace(null));\n+        assertEquals(true, StringUtils.isNumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\" \"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"a\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"A\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1000\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"2.3\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: StringUtilsSubstringTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class StringUtilsSubstringTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String BAZ = \"baz\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String SENTENCE = \"foo bar baz\";\n+\n+    public StringUtilsSubstringTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(StringUtilsSubstringTest.class);\n+    \tsuite.setName(\"StringUtilsSubstring Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    public void testSubstring2() {\n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 80));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));\n+    }\n+    \n+    public void testSubstring3() {\n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 8, 6));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, 3));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, -8));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));\n+    }\n+    \n+    public void testLeft() {\n+        assertSame(null, StringUtils.left(null, 0));\n+        assertSame(null, StringUtils.left(null, 2));\n+        assertSame(\"\", StringUtils.left(\"\", 0));\n+        assertSame(\"\", StringUtils.left(\"\", 2));\n+        assertEquals(\"\", StringUtils.left(FOOBAR, 0));\n+        assertEquals(FOO, StringUtils.left(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));\n+    }\n+    \n+    public void testLeftEx() {\n+        try {\n+            StringUtils.left(FOOBAR, -1);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testRight() {\n+        assertSame(null, StringUtils.right(null, 0));\n+        assertSame(null, StringUtils.right(null, 2));\n+        assertSame(\"\", StringUtils.right(\"\", 0));\n+        assertSame(\"\", StringUtils.right(\"\", 2));\n+        assertEquals(\"\", StringUtils.right(FOOBAR, 0));\n+        assertEquals(BAR, StringUtils.right(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));\n+    }\n+    \n+    public void testRightEx() {\n+        try {\n+            StringUtils.right(FOOBAR, -1);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testMid() {\n+        assertSame(null, StringUtils.mid(null, 3, 0));\n+        assertSame(null, StringUtils.mid(null, 3, 2));\n+        assertSame(\"\", StringUtils.mid(\"\", 0, 0));\n+        assertSame(\"\", StringUtils.mid(\"\", 0, 2));\n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 3, 0));\n+        assertEquals(\"b\", StringUtils.mid(FOOBAR, 3, 1));\n+        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));\n+        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));\n+    }\n+    \n+    public void testMidEx1() {\n+        try {\n+            StringUtils.mid(FOOBAR, 0, -1);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testMidEx2() {\n+        try {\n+            StringUtils.mid(FOOBAR, -1, 3);\n+        } catch (IndexOutOfBoundsException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testMidEx3() {\n+        try {\n+            StringUtils.mid(FOOBAR, 7, 3);\n+        } catch (IndexOutOfBoundsException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testCountMatches() {\n+        assertEquals(3, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"one\"));\n+        assertEquals(0, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"two\"));\n+        assertEquals(4, \n+             StringUtils.countMatches(\"oooooooooooo\", \"ooo\"));\n+    }\n+\n+    public void testGetNestedString() {\n+        assertEquals( \"\", StringUtils.getNestedString(\"\", \"\") );\n+        assertEquals( \"\", StringUtils.getNestedString(\"    \", \" \") );\n+        assertEquals( \"bar\", StringUtils.getNestedString(\"\\nbar\\n\", \"\\n\") );\n+        assertEquals( \"\", StringUtils.getNestedString(\"\", \"\", \"\") );\n+        assertEquals( \"\", StringUtils.getNestedString(\"    \", \" \", \"  \") );\n+        assertEquals( \"bar\", StringUtils.getNestedString(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils}.\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: StringUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class StringUtilsTest extends TestCase\n+{\n+    private static final String[] ARRAY_LIST = { \"foo\", \"bar\", \"baz\" };\n+\n+    private static final String SEPARATOR = \",\";\n+\n+    private static final String TEXT_LIST = \"foo,bar,baz\";\n+\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String CAP_FOO = \"Foo\";\n+    private static final String UPPER_FOO = \"FOO\";\n+\n+    private static final String SENTENCE = \"foo bar baz\";\n+\n+    public StringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(StringUtilsTest.class);\n+    \tsuite.setName(\"StringUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testCaseFunctions()\n+    {\n+        assertEquals(\"capitalise(String) failed\",\n+                     CAP_FOO, StringUtils.capitalise(FOO) );\n+        assertEquals(\"capitalise(empty-string) failed\",\n+                     \"\", StringUtils.capitalise(\"\") );\n+        assertEquals(\"capitaliseAllWords(String) failed\",\n+                     \"Foo Bar Baz\", StringUtils.capitaliseAllWords(SENTENCE) );\n+        assertEquals(\"capitaliseAllWords(empty-string) failed\",\n+                     \"\", StringUtils.capitaliseAllWords(\"\") );\n+        assertEquals(\"uncapitalise(String) failed\",\n+                     FOO, StringUtils.uncapitalise(CAP_FOO) );\n+        assertEquals(\"uncapitalise(empty-string) failed\",\n+                     \"\", StringUtils.uncapitalise(\"\") );\n+\n+        assertEquals(\"upperCase(String) failed\",\n+                     \"FOO TEST THING\", StringUtils.upperCase(\"fOo test THING\") );\n+        assertEquals(\"upperCase(empty-string) failed\",\n+                     \"\", StringUtils.upperCase(\"\") );\n+        assertEquals(\"lowerCase(String) failed\",\n+                     \"foo test thing\", StringUtils.lowerCase(\"fOo test THING\") );\n+        assertEquals(\"lowerCase(empty-string) failed\",\n+                     \"\", StringUtils.lowerCase(\"\") );\n+\n+        assertEquals(\"swapCase(empty-string) failed\",\n+                     \"\", StringUtils.swapCase(\"\") );\n+        assertEquals(\"swapCase(String-with-numbers) failed\",\n+                     \"a123RgYu\", StringUtils.swapCase(\"A123rGyU\") );\n+        assertEquals(\"swapCase(String) failed\",\n+                     \"Hello aPACHE\", StringUtils.swapCase(\"hELLO Apache\") );\n+    }\n+\n+    public void testJoin()\n+    {\n+        assertEquals(\"join(Object[], String) failed\", TEXT_LIST,\n+                     StringUtils.join(ARRAY_LIST, SEPARATOR));\n+        assertEquals(\"join(Iterator, String) failed\", TEXT_LIST,\n+                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),\n+                                      SEPARATOR));\n+    }\n+\n+    public void testSplit()\n+    {\n+        String[] result = StringUtils.split(TEXT_LIST, SEPARATOR, 2);\n+        String[] expected = { \"foo\", \"bar,baz\" };\n+        assertEquals(\"split(Object[], String, int) yielded unexpected length\",\n+                     expected.length, result.length);\n+        for (int i = 0; i < result.length; i++)\n+        {\n+            assertEquals(\"split(Object[], String, int) failed\", expected[i],\n+                         result[i]);\n+        }\n+\n+        result = StringUtils.split(TEXT_LIST, SEPARATOR, 0);\n+        expected = ARRAY_LIST;\n+        assertEquals(\"split(Object[], String, int) yielded unexpected length\",\n+                     expected.length, result.length);\n+        for (int i = 0; i < result.length; i++)\n+        {\n+            assertEquals(\"split(Object[], String, int) failed\", expected[i],\n+                         result[i]);\n+        }\n+\n+        result = StringUtils.split(TEXT_LIST, SEPARATOR, -1);\n+        expected = ARRAY_LIST;\n+        assertEquals(\"split(Object[], String, int) yielded unexpected length\",\n+                     expected.length, result.length);\n+        for (int i = 0; i < result.length; i++)\n+        {\n+            assertEquals(\"split(Object[], String, int) failed\", expected[i],\n+                         result[i]);\n+        }\n+    }\n+\n+    public void testReplaceFunctions()\n+    {\n+        assertEquals(\"replace(String, String, String, int) failed\",\n+                     FOO, StringUtils.replace(\"oo\" + FOO, \"o\", \"\", 2));\n+        assertEquals(\"replace(String, String, String) failed\",\n+                     \"\", StringUtils.replace(FOO + FOO + FOO, FOO, \"\"));\n+        assertEquals(\"replaceOnce(String, String, String) failed\",\n+                     FOO, StringUtils.replaceOnce(FOO + FOO, FOO, \"\"));\n+    }\n+\n+    public void testOverlayString()\n+    {\n+        assertEquals(\"overlayString(String, String, int, int) failed\",\n+                     \"foo foor baz\", StringUtils.overlayString(SENTENCE, FOO, 4, 6) );\n+    }\n+\n+    public void testRepeat()\n+    {\n+        assertEquals(\"repeat(String, int) failed\",\n+                     FOO + FOO + FOO, StringUtils.repeat(FOO, 3) );\n+    }\n+\n+    public void testCenter()\n+    {\n+        assertEquals(\"center(String, int) failed\",\n+                     \"   \"+FOO+\"   \", StringUtils.center(FOO, 9) );\n+    }\n+\n+    public void testChompFunctions()\n+    {\n+\n+        assertEquals(\"chomp(String) failed\",\n+                     FOO, StringUtils.chomp(FOO + \"\\n\" + FOO) );\n+\n+        assertEquals(\"chompLast(String) failed\",\n+                     FOO, StringUtils.chompLast(FOO + \"\\n\") );\n+\n+        assertEquals(\"getChomp(String, String) failed\",\n+                     \"\\n\" + FOO, StringUtils.getChomp(FOO + \"\\n\" + FOO, \"\\n\") );\n+\n+        assertEquals(\"prechomp(String, String) failed\",\n+                     FOO, StringUtils.prechomp(FOO + \"\\n\" + FOO, \"\\n\") );\n+\n+        assertEquals(\"getPrechomp(String, String) failed\",\n+                     FOO + \"\\n\", StringUtils.getPrechomp(FOO + \"\\n\" + FOO, \"\\n\") );\n+\n+        assertEquals(\"chop(String, String) failed\",\n+                     FOO, StringUtils.chop(FOO + \"\\r\\n\") );\n+\n+        assertEquals(\"chopNewline(String, String) failed\",\n+                     FOO, StringUtils.chopNewline(FOO + \"\\r\\n\") );\n+    }\n+\n+    public void testPadFunctions()\n+    {\n+        assertEquals(\"rightPad(String, int) failed\",\n+                     \"1234    \", StringUtils.rightPad (\"1234\", 8) );\n+\n+        assertEquals(\"rightPad(String, int, String) failed\",\n+                     \"1234-+-+\", StringUtils.rightPad (\"1234\", 8, \"-+\") );\n+\n+        assertEquals(\"rightPad(String, int, String) failed\",\n+                     \"123456-+~\", StringUtils.rightPad (\"123456\", 9, \"-+~\") );\n+\n+        assertEquals(\"leftPad(String, int) failed\",\n+                     \"    1234\", StringUtils.leftPad(\"1234\", 8) );\n+\n+        assertEquals(\"leftPad(String, int, String) failed\",\n+                     \"-+-+1234\", StringUtils.leftPad(\"1234\", 8, \"-+\") );\n+\n+        assertEquals(\"leftPad(String, int, String) failed\",\n+                     \"-+~123456\", StringUtils.leftPad(\"123456\", 9, \"-+~\") );\n+    }\n+\n+    public void testUnicodeFunctions() throws java.io.IOException\n+    {\n+        /* this test fails on my window box with an Sun english JDK 1.3.1\n+           I think that the input string is not right\n+        */\n+/* Kept out for the moment.\n+        String input = \"\u001b$B$3$l$OF|K\\\\8l$N%F%9%H$G$9!\u001b(B#\";\n+        String unicode = StringUtils.convertNativeToUnicode(input, \"iso-2022-jp\");\n+        String iso = StringUtils.convertUnicodeToNative(unicode, \"iso-2022-jp\");\n+        assertEquals(\"Unicode conversions failed\", input, iso);\n+*/\n+    }\n+\n+    public void testReverseFunctions() {\n+        assertEquals(\"reverse(String) failed\",\n+                     \"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n+        assertEquals(\"reverse(empty-string) failed\",\n+                     \"\", StringUtils.reverse(\"\") );\n+        assertEquals(\"reverseDelimitedString(String,'.') failed\",\n+                     \"org.apache.test\", \n+                       StringUtils.reverseDelimitedString(\"test.apache.org\", \".\") );\n+        assertEquals(\"reverseDelimitedString(empty-string,'.') failed\",\n+                     \"\", \n+                       StringUtils.reverseDelimitedString(\"\", \".\") );\n+        assertEquals(\"reverseDelimitedString(String,' ') failed\",\n+                     \"once upon a time\", \n+                       StringUtils.reverseDelimitedString(\"time a upon once\",\" \") );\n+    }\n+\n+    public void testDefaultFunctions() {\n+        assertEquals(\"defaultString(empty-string) failed\",\n+                     \"\", StringUtils.defaultString(\"\") );\n+        assertEquals(\"defaultString(String) failed\",\n+                     FOO, StringUtils.defaultString(FOO) );\n+        assertEquals(\"defaultString(null) failed\",\n+                     \"\", StringUtils.defaultString(null) );\n+        assertEquals(\"defaultString(empty-string,String) failed\",\n+                     \"\", StringUtils.defaultString(\"\", BAR) );\n+        assertEquals(\"defaultString(String,String) failed\",\n+                     FOO, StringUtils.defaultString(FOO, BAR) );\n+        assertEquals(\"defaultString(null,String) failed\",\n+                     BAR, StringUtils.defaultString(null, BAR) );\n+    }\n+\n+    public void testEscapeFunctions() {\n+        assertEquals(\"escape(empty-string) failed\",\n+                     \"\", StringUtils.escape(\"\") );\n+        assertEquals(\"escape(String) failed\",\n+                     FOO, StringUtils.escape(FOO) );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\t\", StringUtils.escape(\"\\t\") );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\\\\\\", StringUtils.escape(\"\\\\\") );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\\\\\\\\\b\\\\t\\\\r\", StringUtils.escape(\"\\\\\\b\\t\\r\") );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\u1234\", StringUtils.escape(\"\\u1234\") );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\u0234\", StringUtils.escape(\"\\u0234\") );\n+        assertEquals(\"escape(String) failed\",\n+                     \"\\\\u00fd\", StringUtils.escape(\"\\u00fd\") );\n+    }\n+\n+    public void testGetLevenshteinDistance() {\n+        assertEquals(\"getLevenshteinDistance(empty-string, empty-string) failed\",\n+                     0, StringUtils.getLevenshteinDistance(\"\", \"\") );\n+        assertEquals(\"getLevenshteinDistance(empty-string, String) failed\",\n+                     1, StringUtils.getLevenshteinDistance(\"\", \"a\") );\n+        assertEquals(\"getLevenshteinDistance(String, empty-string) failed\",\n+                     7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\") );\n+        assertEquals(\"getLevenshteinDistance(String, String) failed\",\n+                     1, StringUtils.getLevenshteinDistance(\"frog\", \"fog\") );\n+        assertEquals(\"getLevenshteinDistance(String, String) failed\",\n+                     3, StringUtils.getLevenshteinDistance(\"fly\", \"ant\") );\n+        assertEquals(\"getLevenshteinDistance(String, String) failed\",\n+                     7, StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") );\n+        assertEquals(\"getLevenshteinDistance(String, String) failed\",\n+                     7, StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") );\n+        assertEquals(\"getLevenshteinDistance(String, String) failed\",\n+                     1, StringUtils.getLevenshteinDistance(\"hello\", \"hallo\") );\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/StringUtilsTrimEmptyTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id: StringUtilsTrimEmptyTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class StringUtilsTrimEmptyTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+\n+    public StringUtilsTrimEmptyTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);\n+    \tsuite.setName(\"StringUtilsTrimEmpty Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testClean() {\n+        assertEquals(FOO, StringUtils.clean(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.clean(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.clean(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.clean(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.clean(null));\n+    }\n+\n+    public void testTrim() {\n+        assertEquals(FOO, StringUtils.trim(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trim(FOO + \"\"));\n+        assertEquals(null, StringUtils.trim(null));\n+    }\n+\n+    public void testIsNotEmpty() {\n+        assertEquals(true, StringUtils.isNotEmpty(FOO));\n+        assertEquals(true, StringUtils.isNotEmpty(\" \"));\n+        assertEquals(false, StringUtils.isNotEmpty(\"\"));\n+        assertEquals(false, StringUtils.isNotEmpty(null));\n+    }\n+\n+    public void testIsEmpty() {\n+        assertEquals(false, StringUtils.isEmpty(FOO));\n+        assertEquals(true, StringUtils.isEmpty(\" \"));\n+        assertEquals(true, StringUtils.isEmpty(\"\"));\n+        assertEquals(true, StringUtils.isEmpty(null));\n+    }\n+\n+    public void testStrip() {\n+        // it's important that foo2Space is fooLeftSpace and fooRightSpace \n+        // merged together. So same number of spaces to left as fLS and same \n+        // to right as fLS. Same applies for foo2Dots.\n+        String foo2Space = \"    \"+FOO+\"    \";\n+        String foo2Dots = \"......\"+FOO+\".........\";\n+        String fooLeftSpace = \"    \"+FOO;\n+        String fooLeftDots = \"......\"+FOO;\n+        String fooRightSpace = FOO+\"    \";\n+        String fooRightDots = FOO+\".........\";\n+\n+        assertEquals(\"\", StringUtils.strip(\"\"));\n+        assertEquals(FOO, StringUtils.strip(foo2Space));\n+        assertEquals(FOO, StringUtils.strip(foo2Dots, \".\"));\n+        assertEquals(FOO, StringUtils.strip(fooRightSpace));\n+        assertEquals(FOO, StringUtils.strip(fooRightDots, \".\"));\n+        assertEquals(FOO, StringUtils.strip(fooLeftSpace));\n+        assertEquals(FOO, StringUtils.strip(fooLeftDots, \".\"));\n+\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \" \"));\n+        assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, \" \"));\n+        assertEquals(fooRightDots, StringUtils.stripStart(foo2Dots, \".\"));\n+        assertEquals(fooRightSpace, StringUtils.stripStart(fooRightSpace, \" \"));\n+        assertEquals(fooRightDots, StringUtils.stripStart(fooRightDots, \".\"));\n+        assertEquals(FOO, StringUtils.stripStart(fooLeftSpace, \" \"));\n+        assertEquals(FOO, StringUtils.stripStart(fooLeftDots, \".\"));\n+\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \" \"));\n+        assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, \" \"));\n+        assertEquals(fooLeftDots, StringUtils.stripEnd(foo2Dots, \".\"));\n+        assertEquals(FOO, StringUtils.stripEnd(fooRightSpace, \" \"));\n+        assertEquals(FOO, StringUtils.stripEnd(fooRightDots, \".\"));\n+        assertEquals(fooLeftSpace, StringUtils.stripEnd(fooLeftSpace, \" \"));\n+        assertEquals(fooLeftDots, StringUtils.stripEnd(fooLeftDots, \".\"));\n+\n+        // test stripAll method, merely an array version of the above strip\n+        String[] empty = new String[0];\n+        String[] fooSpace = new String[] { foo2Space, fooLeftSpace, fooRightSpace };\n+        String[] fooDots = new String[] { foo2Dots, fooLeftDots, fooRightDots };\n+        String[] foo = new String[] { FOO, FOO, FOO };\n+\n+        assertArrayEquals(empty, StringUtils.stripAll(empty));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooDots, \".\"));\n+    }\n+\n+    private void assertArrayEquals(Object[] o1, Object[] o2) {\n+        if(o1 == null) {\n+            assertEquals(o1,o2);\n+            return;\n+        }\n+        assertEquals(\"Length not equal. \", o1.length, o2.length);\n+        int sz = o1.length;\n+        for(int i=0; i<sz; i++) {\n+            if(o1[i] instanceof Object[]) {\n+                // do an assert equals on type....\n+                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );\n+            } else {\n+                assertEquals(o1[i], o2[i]);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/exception/ExceptionTestSuite.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test manager for the org.apache.commons.lang.exception classes.\n+ *\n+ * @author <a href=\"mailto:stevencaswell@yahoo.com\">Steven Caswell</a>\n+ */\n+public class ExceptionTestSuite extends TestCase\n+{\n+    /**\n+     * Construct a new instance.\n+     */\n+    public ExceptionTestSuite(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args)\n+    {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite()\n+    {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(NestableDelegateTestCase.suite());\n+        suite.addTest(NestableExceptionTestCase.suite());\n+        suite.addTest(NestableRuntimeExceptionTestCase.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/exception/NestableDelegateTestCase.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintWriter;\n+import java.io.PrintStream;\n+\n+import junit.framework.*;\n+import junit.textui.TestRunner;\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableDelegate class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @version $Id: NestableDelegateTestCase.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class NestableDelegateTestCase extends junit.framework.TestCase\n+{\n+    private static final String CONSTRUCTOR_FAILED_MSG = \n+    \"The Nestable implementation passed to the NestableDelegate(Nestable) constructor must extend java.lang.Throwable\";\n+\n+    private static final String PARTIAL_STACK_TRACE =\n+        \"rethrown as ThrowableNestedNestable partial stack trace place-holder\";\n+\n+    protected String lineSeparator;\n+\n+    /**\n+     * Construct a new instance of NestableDelegateTestCase with the specified name\n+     */\n+    public NestableDelegateTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+        lineSeparator = System.getProperty(\"line.separator\");\n+    }\n+    \n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableDelegateTestCase.class);\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+        lineSeparator = null;\n+    }\n+    \n+    /**\n+     * Test the implementation\n+     */\n+    public void testNestableDelegateConstructor()\n+    {\n+        String msg = null;\n+        boolean constructorFailed = false;\n+        try\n+        {\n+            NestableDelegate nonThrowableCause = new NestableDelegate(new NonThrowableNestable());\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            constructorFailed = true;\n+            msg = iae.getMessage();\n+        }\n+        assertTrue(\"nestable delegate constructor with non-throwable cause failed == true\", constructorFailed);\n+        assertTrue(\"constructor failed exception msg == \" + CONSTRUCTOR_FAILED_MSG,\n+            msg.equals(CONSTRUCTOR_FAILED_MSG));\n+\n+        constructorFailed = false;\n+        try\n+        {\n+            NestableDelegate nd1 = new NestableDelegate(new ThrowableNestable());\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            constructorFailed = true;\n+        }\n+        assertTrue(\"nestable delegate constructor with throwable cause failed == false\", !constructorFailed);\n+    }\n+\n+    public void testNestableDelegateGetMessage()\n+    {\n+        Nestable ne1 = new ThrowableNestable();\n+        assertTrue(\"ThrowableNestable ne1 getMessage() == ThrowableNestable exception\",\n+            ne1.getMessage().equals(\"ThrowableNestable exception\"));\n+        NestableDelegate nd1 = new NestableDelegate(ne1);\n+        assertTrue(\"nd1 getMessage() == \" + ne1.getCause().getMessage(),\n+            nd1.getMessage(\"base\").equals(\"base: \" + ne1.getCause().getMessage()));\n+        \n+        Nestable ne2 = new ThrowableNestedNestable(new Exception(\"nested exception 2\"));\n+        NestableDelegate nd2 = new NestableDelegate(ne2);\n+        assertTrue(\"nd2 getMessage() == base: \" + ne2.getCause().getMessage(),\n+            nd2.getMessage(\"base\").equals(\"base: \" + ne2.getCause().getMessage()));\n+    }\n+\n+    public void testNestableDelegateGetLength()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        \n+        n = new NestableDelegateTester1();\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetLength(d, 1);\n+        \n+        n = new NestableDelegateTester1(\"level 1\");\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetLength(d, 1);\n+        \n+        n = new NestableDelegateTester1(new Exception());\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetLength(d, 2);\n+        \n+        n = new NestableDelegateTester1(new Exception(\"level 2\"));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetLength(d, 2);\n+        \n+        n = new NestableDelegateTester1(\"level 1\", new NestableDelegateTester2(\"level 2\", new NestableDelegateTester1(new NestableDelegateTester2(\"level 4\", new Exception(\"level 5\")))));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetLength(d, 5);\n+    }\n+\n+    private void doNestableDelegateGetLength(NestableDelegate d, int len)\n+    {\n+        // Compare the lengths\n+        assertEquals(\"delegate length\", len, d.getLength());\n+    }\n+    \n+    public void testNestableDelegateGetMessages()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        \n+        msgs = new String[1];\n+        n = new NestableDelegateTester1();\n+        d = new NestableDelegate(n);        \n+        doNestableDelegateGetMessages(d, msgs);\n+        \n+        msgs = new String[1];\n+        msgs[0] = \"level 1\";\n+        n = new NestableDelegateTester1(msgs[0]);\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+\n+        msgs = new String[2];\n+        n = new NestableDelegateTester1(new Exception());\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+\n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        n = new NestableDelegateTester1(msgs[0], new NestableDelegateTester2(msgs[1], new NestableDelegateTester1(new NestableDelegateTester2(msgs[3], new Exception(msgs[4])))));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+    }\n+\n+    private void doNestableDelegateGetMessages(NestableDelegate d, String[] nMsgs)\n+    {\n+        // Compare the messages\n+        String[] dMsgs = d.getMessages();\n+        assertEquals(\"messages length\", nMsgs.length, dMsgs.length);\n+        for(int i = 0; i < nMsgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, nMsgs[i], dMsgs[i]);\n+        }\n+    }\n+\n+    public void testNestableDelegateGetMessageN()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        n = new NestableDelegateTester1(msgs[0], new NestableDelegateTester2(msgs[1], new NestableDelegateTester1(new NestableDelegateTester2(msgs[3], new Exception(msgs[4])))));\n+        d = new NestableDelegate(n);\n+        for(int i = 0; i < msgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], d.getMessage(i));\n+        }\n+        assertEquals(\"message -1\", msgs[0], d.getMessage(-1));\n+        assertEquals(\"message -1\", msgs[msgs.length - 1], d.getMessage(msgs.length + 100));\n+    }\n+\n+    public void testNestableDelegateGetThrowable()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowable(d, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableDelegateTester1(msgs[0], new NestableDelegateTester2(msgs[1], new NestableDelegateTester1(new NestableDelegateTester2(msgs[3], new Exception(msgs[4])))));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowable(d, throwables, msgs);\n+    }\n+\n+    private void doNestableDelegateGetThrowable(NestableDelegate d, Class[] classes, String[] msgs)\n+    {\n+        Throwable t = null;\n+        String msg = null;\n+        \n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            t = d.getThrowable(i);\n+            assertEquals(\"throwable class\", classes[i], t.getClass());\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+        t = d.getThrowable(-1);\n+        assertEquals(\"throwable(-1)\", classes[0], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[0], msg);\n+        t = d.getThrowable(999);\n+        assertEquals(\"throwable(999)\", classes[classes.length - 1], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[msgs.length - 1], msg);\n+    }\n+\n+    public void testNestableDelegateGetThrowables()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowables(d, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableDelegateTester1(msgs[0], new NestableDelegateTester2(msgs[1], new NestableDelegateTester1(new NestableDelegateTester2(msgs[3], new Exception(msgs[4])))));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowables(d, throwables, msgs);\n+    }\n+    \n+    private void doNestableDelegateGetThrowables(NestableDelegate d, Class[] classes, String[] msgs)\n+    {\n+        Throwable[] throwables = null;\n+        String msg = null;\n+\n+        throwables = d.getThrowables();\n+        assertEquals(\"throwables length\", classes.length, throwables.length);\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            assertEquals(\"throwable class\", classes[i], throwables[i].getClass());\n+            Throwable t = throwables[i];\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+    }\n+\n+    public void testIndexOfThrowable()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = Exception.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableDelegateTester1(msgs[0], new NestableDelegateTester2(msgs[1], new NestableDelegateTester1(new NestableDelegateTester2(msgs[3], new Exception(msgs[4])))));\n+        d = new NestableDelegate(n);\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableDelegateIndexOfThrowable(d, throwables[i], 0, indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester2.class, 2, 3, msgs[3]);\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester1.class, 1, 2, msgs[2]);\n+        doNestableDelegateIndexOfThrowable(d, java.util.Date.class, 0, -1, null);\n+    }\n+\n+    private void doNestableDelegateIndexOfThrowable(NestableDelegate d, Class type, int pos, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = d.indexOfThrowable(pos, type);\n+        assertEquals(\"index of throwable \" + type.getName(), expectedIndex, index);\n+        t = d.getThrowable(index);\n+        if(expectedMsg != null)\n+        {\n+            String msg = null;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+        }\n+    }\n+    \n+    public void testNestableDelegetePrintStackTrace()\n+    {\n+        int lineSepLen = lineSeparator.length();\n+        int partialStackTraceLen = PARTIAL_STACK_TRACE.length();\n+        Nestable ne3 = new ThrowableNestedNestable(new Exception(\"nested exception 3\"));\n+        NestableDelegate nd3 = new NestableDelegate(ne3);\n+\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        nd3.printStackTrace(ps1);\n+        String stack1 = baos1.toString();\n+        assertTrue(\"stack trace startsWith == java.lang.Exception: nested exception 3\",\n+            stack1.startsWith(\"java.lang.Exception: nested exception 3\"));\n+        int start1 = (stack1.length() - lineSepLen) - partialStackTraceLen;\n+        int end1 = stack1.length() - lineSepLen;\n+        assertEquals(\"stack trace substring(\" + start1 + \",\" + end1 + \") == \" +\n+                     PARTIAL_STACK_TRACE,\n+                     PARTIAL_STACK_TRACE,\n+                     stack1.substring(start1, end1));\n+\n+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n+        PrintStream ps2 = new PrintStream(baos2);\n+        System.setErr(ps2);\n+        nd3.printStackTrace();\n+        String stack2 = baos2.toString();\n+        assertTrue(\"stack trace startsWith == java.lang.Exception: nested exception 3\",\n+            stack2.startsWith(\"java.lang.Exception: nested exception 3\"));\n+        int start2 = (stack2.length() - lineSepLen) - partialStackTraceLen;\n+        int end2 = stack2.length() - lineSepLen;\n+        assertTrue(\"stack trace substring(\" + start2 + \",\" + end2 + \") == \" + PARTIAL_STACK_TRACE,\n+            stack2.substring(start2, end2).equals(PARTIAL_STACK_TRACE));\n+    }\n+    \n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n+class NestableDelegateTester1 extends Exception implements Nestable\n+{\n+    private Throwable cause = null;\n+\n+    public NestableDelegateTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableDelegateTester1(String reason, Throwable cause)\n+    {\n+        super(reason);\n+        this.cause = cause;\n+    }\n+    \n+    public NestableDelegateTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableDelegateTester1(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the <code>Throwable</code>s\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the error messages\n+     */\n+    public String[] getMessages()\n+    {\n+        return new String[0];\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type in the chain of <code>Throwable</code>s, or -1 if the\n+     * specified type is not found in the chain. If <code>pos</code> is\n+     * negative, the effect is the same as if it were 0. If <code>pos</code>\n+     * is greater than or equal to the length of the chain, the effect is the\n+     * same as if it were the index of the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s at the specified index, numbererd from 0. If\n+     * <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the last <code>Throwable</code> in the chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the <code>Throwable</code>\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbererd from 0.\n+     * If <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the message of the last <code>Throwable</code> in the\n+     * chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the error message\n+     */\n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified position, or -1 if\n+     * the type is not found. If <code>pos</code> is negative, the effect is the\n+     * same as if it were 0. If <code>pos</code> is greater than or equal to the\n+     * length of the chain, the effect is the same as if it were the index of\n+     * the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos index, numbered from 0, of the starting position in the chain\n+     * to be searched\n+     *\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return -1;\n+    }\n+    \n+}\n+\n+class NestableDelegateTester2 extends Throwable implements Nestable\n+{\n+    private Throwable cause = null;\n+\n+    public NestableDelegateTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableDelegateTester2(String reason, Throwable cause)\n+    {\n+        super(reason);\n+        this.cause = cause;\n+    }\n+    \n+    public NestableDelegateTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableDelegateTester2(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the <code>Throwable</code>s\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     *\n+     * @return the error messages\n+     */\n+    public String[] getMessages()\n+    {\n+        return new String[0];\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type in the chain of <code>Throwable</code>s, or -1 if the\n+     * specified type is not found in the chain. If <code>pos</code> is\n+     * negative, the effect is the same as if it were 0. If <code>pos</code>\n+     * is greater than or equal to the length of the chain, the effect is the\n+     * same as if it were the index of the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s at the specified index, numbererd from 0. If\n+     * <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the last <code>Throwable</code> in the chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the <code>Throwable</code>\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbererd from 0.\n+     * If <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the message of the last <code>Throwable</code> in the\n+     * chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the error message\n+     */\n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+    \n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified position, or -1 if\n+     * the type is not found. If <code>pos</code> is negative, the effect is the\n+     * same as if it were 0. If <code>pos</code> is greater than or equal to the\n+     * length of the chain, the effect is the same as if it were the index of\n+     * the last element in the chain.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos index, numbered from 0, of the starting position in the chain\n+     * to be searched\n+     *\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return -1;\n+    }\n+    \n+}\n+\n+class ThrowableNestable extends Throwable implements Nestable\n+{\n+    private Throwable cause = new Exception(\"ThrowableNestable cause\");\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     */\n+    public int getLength()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested\n+     * <code>Throwable</code>.\n+     *\n+     * @return The error message.\n+     */\n+    public String getMessage()\n+    {\n+        return \"ThrowableNestable exception\";\n+    }\n+\n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbererd from 0.\n+     * If <code>index</code> is negative, the effect is the same as if it\n+     * were 0. If <code>index</code> is greater than or equal to the length\n+     * of the chain, the message of the last <code>Throwable</code> in the\n+     * chain is returned.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the error message\n+     */\n+    public String getMessage(int index)\n+    {\n+        return getMessage();\n+    }\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     */\n+    public String[] getMessages()\n+    {\n+        String msgs[] = new String[1];\n+        msgs[0] = getMessage();\n+        return msgs;\n+    }\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * writer.  Includes inforamation from the exception--if\n+     * any--which caused this exception.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    public Throwable getThrowable(int index)\n+    {\n+        return cause;\n+    }\n+    \n+    public Throwable[] getThrowables()\n+    {\n+        Throwable throwables[] = new Throwable[1];\n+        throwables[0] = cause;\n+        return throwables;\n+    }\n+    \n+    public int indexOfThrowable(Class type)\n+    {\n+        if(Exception.class.isInstance(type))\n+        {\n+            return 0;\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns the index of the first <code>Throwable</code> that matches the\n+     * specified type with an index greater than or equal to the specified\n+     * position, or -1 if the type is not found.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return indexOfThrowable(type);\n+    }\n+    \n+}\n+\n+class ThrowableNestedNestable extends Throwable implements Nestable\n+{\n+    private Throwable cause = null;\n+    \n+    public ThrowableNestedNestable(Throwable cause)\n+    {\n+        this.cause = cause;\n+    }\n+    \n+    public int getLength()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested\n+     * <code>Throwable</code>.\n+     *\n+     * @return The error message.\n+     */\n+    public String getMessage()\n+    {\n+        return \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+    }\n+\n+    public String getMessage(int index)\n+    {\n+        return \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     */\n+    public String[] getMessages()\n+    {\n+        String[] msgs = new String[1];\n+        msgs[0] = \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+        return msgs;\n+    }\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * writer.  Includes inforamation from the exception--if\n+     * any--which caused this exception.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+        out.println(\"ThrowableNestedNestable stack trace place-holder\");\n+    }\n+    \n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+        out.println(\"ThrowableNestedNestable partial stack trace place-holder\");\n+    }\n+    \n+    public Throwable getThrowable(int index)\n+    {\n+        return cause;\n+    }\n+    \n+    public Throwable[] getThrowables()\n+    {\n+        Throwable throwables[] = new Throwable[1];\n+        throwables[0] = cause;\n+        return throwables;\n+    }\n+    \n+    public int indexOfThrowable(Class type)\n+    {\n+        if(Exception.class.isInstance(type))\n+        {\n+            return 0;\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns the index of the first <code>Throwable</code> that matches the\n+     * specified type with an index greater than or equal to the specified\n+     * position, or -1 if the type is not found.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return indexOfThrowable(type);\n+    }\n+    \n+}\n+\n+class NonThrowableNestable implements Nestable\n+{\n+    public int getLength()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested\n+     * <code>Throwable</code>.\n+     *\n+     * @return The error message.\n+     */\n+    public String getMessage()\n+    {\n+        return \"non-throwable\";\n+    }\n+\n+    public String getMessage(int index)\n+    {\n+        return \"non-throwable\";\n+    }\n+    \n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> specified without a message is represented in\n+     * the array by a null.\n+     */\n+    public String[] getMessages()\n+    {\n+        String[] msgs = new String[1];\n+        msgs[0] = \"non-throwable\";\n+        return msgs;\n+    }\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     */\n+    public Throwable getCause()\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * writer.  Includes inforamation from the exception--if\n+     * any--which caused this exception.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by {@link\n+     * org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns the index of the first <code>Throwable</code> that matches the\n+     * specified type with an index greater than or equal to the specified\n+     * position, or -1 if the type is not found.\n+     *\n+     * @param type <code>Class</code> to be found\n+     * @param pos\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(int pos, Class type)\n+    {\n+        return -1;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/exception/NestableExceptionTestCase.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+import junit.framework.*;\n+import junit.textui.TestRunner;\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableException class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: NestableExceptionTestCase.java,v 1.1 2002/07/19 03:35:55 bayard Exp $\n+ */\n+public class NestableExceptionTestCase extends junit.framework.TestCase\n+{\n+    \n+    /**\n+     * Construct a new instance of NestableExceptionTestCase with the specified name\n+     */\n+    public NestableExceptionTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+    }\n+    \n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableExceptionTestCase.class);\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+    }\n+    \n+    /**\n+     * Test the implementation\n+     */\n+    public void testGetCause()\n+    {\n+        NestableException ne1 = new NestableException();\n+        assertNull(\"nestable exception() cause is null\", ne1.getCause()); \n+        \n+        NestableException ne2 = new NestableException(\"ne2\");\n+        assertNull(\"nestable exception(\\\"ne2\\\") cause is null\", ne2.getCause());\n+        \n+        NestableException ne3 = new NestableException(new Exception(\"ne3 exception\"));\n+        assertNotNull(\"nestable exception(new Exception(\\\"ne3 exception\\\") cause is not null\",\n+            ne3.getCause()); \n+        assertTrue(\"nestable exception(new Exception(\\\"ne3 exception\\\") cause message == ne3 exception\",\n+            ne3.getCause().getMessage().equals(\"ne3 exception\")); \n+        \n+        NestableException ne4 = new NestableException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertNotNull(\"nestable exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") cause is not null\", \n+            ne4.getCause()); \n+        \n+        NestableException ne5 = new NestableException(\"ne5\", null);\n+        assertNull(\"nestable exception(\\\"ne5\\\", null) cause is null\", \n+            ne5.getCause()); \n+        \n+        NestableException ne6 = new NestableException(null, new Exception(\"ne6 exception\"));\n+        assertNotNull(\"nestable exception(null, new Exception(\\\"ne6 exception\\\") cause is not null\", \n+            ne6.getCause()); \n+    }\n+\n+    public void testGetLength()\n+    {\n+        NestableException ne1 = new NestableException();\n+        assertEquals(\"ne1 length\", 1, ne1.getLength());\n+\n+        NestableException ne2 = new NestableException(\"ne2\");\n+        assertEquals(\"ne2 length\", 1, ne2.getLength());\n+        \n+        NestableException ne3 = new NestableException(new Exception(\"ne3 exception\"));\n+        assertEquals(\"ne3 length\", 2, ne3.getLength());\n+        \n+        NestableException ne4 = new NestableException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertEquals(\"ne4 length\", 2, ne4.getLength());\n+        \n+        NestableException ne5 = new NestableException(\"ne5\", null);\n+        assertEquals(\"ne 5 length\", 1, ne5.getLength());\n+        \n+        NestableException ne6 = new NestableException(null, new Exception(\"ne6 exception\"));\n+        assertEquals(\"ne 6 length\", 2, ne6.getLength());\n+        \n+        NestableException ne7 = new NestableException(\"ne7o\", new NestableException(\"ne7i\", new Exception(\"ne7 exception\")));\n+        assertEquals(\"ne 7 length\", 3, ne7.getLength());\n+\n+        NestableException ne8 = new NestableException(\"level 1\", new NestableException(\"level 2\", new NestableException(new NestableException(\"level 4\", new Exception(\"level 5\")))));\n+        assertEquals(\"ne 8 length\", 5, ne8.getLength());\n+    }\n+    \n+    public void testGetMessage()\n+    {\n+        NestableException ne1 = new NestableException();\n+        assertNull(\"nestable exception() message is null\", ne1.getMessage()); \n+\n+        NestableException ne2 = new NestableException(\"ne2\");\n+        assertNotNull(\"nestable exception(\\\"ne2\\\") message is not null\", ne2.getMessage());\n+        assertTrue(\"nestable exception(\\\"ne2\\\") message == ne2\", ne2.getMessage().equals(\"ne2\"));\n+        \n+        NestableException ne3 = new NestableException(new Exception(\"ne3 exception\"));\n+        assertNotNull(\"nestable exception(new Exception(\\\"ne3 exception\\\") message is not null\",\n+            ne3.getMessage()); \n+        assertTrue(\"nestable exception(new Exception(\\\"ne3 exception\\\") message == cause message\",\n+            ne3.getMessage().equals(ne3.getCause().getMessage())); \n+        \n+        NestableException ne4 = new NestableException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertNotNull(\"nestable exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") message is not null\", \n+            ne4.getMessage()); \n+        assertTrue(\"nestable exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") message == ne4: ne4 exception\", \n+            ne4.getMessage().equals(\"ne4: ne4 exception\")); \n+        \n+        NestableException ne5 = new NestableException(\"ne5\", null);\n+        assertNotNull(\"nestable exception(\\\"ne5\\\", new Exception(\\\"ne5 exception\\\") message is not null\", \n+            ne5.getMessage()); \n+        assertTrue(\"nestable exception(\\\"ne5\\\", null) message == ne5\", \n+            ne5.getMessage().equals(\"ne5\")); \n+        \n+        NestableException ne6 = new NestableException(null, new Exception(\"ne6 exception\"));\n+        assertTrue(\"nestable exception(null, new Exception(\\\"ne6 exception\\\") cause == ne6 exception\", \n+            ne6.getMessage().equals(\"ne6 exception\")); \n+        \n+        NestableException ne7 = new NestableException(\"ne7o\", new NestableException(\"ne7i\", new Exception(\"ne7 exception\")));\n+        assertTrue(\"nextable exception(\\\"ne7o\\\", new NestableException(\\\"ne7i\\\", new Exception(\\\"ne7 exception\\\"))) message is ne7o: ne7i: ne7 exception\",\n+            ne7.getMessage().equals(\"ne7o: ne7i: ne7 exception\"));\n+\n+    }\n+\n+    public void testGetMessageN()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        NestableException ne = new NestableException(msgs[0], new NestableException(msgs[1], new NestableException(new NestableException(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < msgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], ne.getMessage(i));\n+        }\n+        assertEquals(\"message -1\", msgs[0], ne.getMessage(-1));\n+        assertEquals(\"message 999\", msgs[4], ne.getMessage(999));\n+    }\n+    \n+    public void testGetMessages()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        NestableException ne = new NestableException(msgs[0], new NestableException(msgs[1], new NestableException(new NestableException(msgs[3], new Exception(msgs[4])))));\n+        String[] nMsgs = ne.getMessages();\n+        assertEquals(\"messages length\", msgs.length, nMsgs.length);\n+        for(int i = 0; i < nMsgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], nMsgs[i]);\n+        }\n+    }\n+\n+    public void testGetThrowable()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableExceptionTester1(new Exception(msgs[1]));\n+        doNestableExceptionGetThrowable(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = NestableExceptionTester2.class;\n+        throwables[2] = NestableExceptionTester1.class;\n+        throwables[3] = NestableExceptionTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableExceptionTester1(msgs[0], new NestableExceptionTester2(msgs[1], new NestableExceptionTester1(new NestableExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        doNestableExceptionGetThrowable(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableExceptionGetThrowable(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        Throwable t = null;\n+        String msg = null;\n+\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            t = n.getThrowable(i);\n+            assertEquals(\"throwable class\", classes[i], t.getClass());\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+        t = n.getThrowable(-1);\n+        assertEquals(\"throwable(-1)\", classes[0], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[0], msg);\n+        t = n.getThrowable(999);\n+        assertEquals(\"throwable(999)\", classes[classes.length - 1], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[msgs.length - 1], msg);\n+    }\n+    \n+    public void testGetThrowables()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableExceptionTester1(new Exception(msgs[1]));\n+        doNestableExceptionGetThrowables(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = NestableExceptionTester2.class;\n+        throwables[2] = NestableExceptionTester1.class;\n+        throwables[3] = NestableExceptionTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableExceptionTester1(msgs[0], new NestableExceptionTester2(msgs[1], new NestableExceptionTester1(new NestableExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        doNestableExceptionGetThrowables(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableExceptionGetThrowables(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        String msg = null;\n+\n+        Throwable throwables[] = n.getThrowables();\n+        assertEquals(\"throwables length\", classes.length, throwables.length);\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            assertEquals(\"throwable class\", classes[i], throwables[i].getClass());\n+            Throwable t = throwables[i];\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+    }\n+    \n+    public void testIndexOfThrowable()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = NestableExceptionTester2.class;\n+        throwables[2] = NestableExceptionTester1.class;\n+        throwables[3] = NestableExceptionTester2.class;\n+        throwables[4] = Exception.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableExceptionTester1(msgs[0], new NestableExceptionTester2(msgs[1], new NestableExceptionTester1(new NestableExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableExceptionIndexOfThrowable(n, throwables[i], indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableExceptionIndexOfThrowable(n, java.util.Date.class, -1, null);\n+    }\n+    \n+    private void doNestableExceptionIndexOfThrowable(Nestable n, Class type, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(type);\n+        assertEquals(\"index of throwable \" + type.getName(), expectedIndex, index);\n+        t = n.getThrowable(index);\n+        if(expectedMsg != null)\n+        {\n+            String msg = null;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+        }\n+    }\n+    \n+    public void testIndexOfThrowableN()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableExceptionTester1.class;\n+        throwables[1] = NestableExceptionTester2.class;\n+        throwables[2] = NestableExceptionTester1.class;\n+        throwables[3] = NestableExceptionTester2.class;\n+        throwables[4] = Exception.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableExceptionTester1(msgs[0], new NestableExceptionTester2(msgs[1], new NestableExceptionTester1(new NestableExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableExceptionIndexOfThrowableN(n, throwables[i], 0, indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableExceptionIndexOfThrowableN(n, NestableExceptionTester2.class, 2, 3, msgs[3]);\n+        doNestableExceptionIndexOfThrowableN(n, NestableExceptionTester1.class, 1, 2, msgs[2]);\n+        doNestableExceptionIndexOfThrowableN(n, java.util.Date.class, 0, -1, null);\n+    }\n+\n+    private void doNestableExceptionIndexOfThrowableN(Nestable n, Class type, int pos, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(pos, type);\n+        assertEquals(\"index of throwable \" + type.getName(), expectedIndex, index);\n+        t = n.getThrowable(index);\n+        if(expectedMsg != null)\n+        {\n+            String msg = null;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+        }\n+    }\n+    \n+    public void testPrintPartialStackTrace()\n+    {\n+        NestableException ne9 = new NestableException(\"ne9\", new Exception(\"ne9 exception\"));\n+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n+        PrintStream ps2 = new PrintStream(baos2);\n+        PrintWriter pw2 = new PrintWriter(ps2, true);\n+        ne9.printPartialStackTrace(pw2);\n+        String stack2 = baos2.toString();\n+        assertTrue(\"stack trace startsWith == org.apache.commons.lang.exception.NestableException: ne9: ne9 exception\",\n+            stack2.startsWith(\"org.apache.commons.lang.exception.NestableException: ne9: ne9 exception\"));\n+        assertEquals(\"stack trace indexOf rethrown == -1\",\n+            stack2.indexOf(\"rethrown\"), -1);\n+    }\n+    \n+    public void testPrintStackTrace()\n+    {\n+        NestableException ne8 = new NestableException(\"ne8\", new Exception(\"ne8 exception\"));\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        PrintWriter pw1 = new PrintWriter(ps1, true);\n+        ne8.printStackTrace(ps1);\n+        String stack1 = baos1.toString();\n+        assertTrue(\"stack trace startsWith == java.lang.Exception: ne8 exception\",\n+            stack1.startsWith(\"java.lang.Exception: ne8 exception\")); \n+        assertTrue(\"stack trace indexOf org.apache.commons.lang.exception.NestableException: ne8: ne8 exception > -1\",\n+            stack1.indexOf(\"org.apache.commons.lang.exception.NestableException: ne8: ne8 exception\") > -1); \n+    }\n+\n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n+class NestableExceptionTester1 extends NestableException\n+{\n+    public NestableExceptionTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableExceptionTester1(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableExceptionTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableExceptionTester1(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n+class NestableExceptionTester2 extends NestableException\n+{\n+    public NestableExceptionTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableExceptionTester2(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableExceptionTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableExceptionTester2(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/exception/NestableRuntimeExceptionTestCase.java\n+package org.apache.commons.lang.exception;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+import junit.framework.*;\n+import junit.textui.TestRunner;\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableRuntimeException class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id: NestableRuntimeExceptionTestCase.java,v 1.1 2002/07/19 03:35:56 bayard Exp $\n+ */\n+public class NestableRuntimeExceptionTestCase extends junit.framework.TestCase\n+{\n+    /**\n+     * Construct a new instance of NestableRuntimeExceptionTestCase with the specified name\n+     */\n+    public NestableRuntimeExceptionTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+    }\n+    \n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableRuntimeExceptionTestCase.class);\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+    }\n+    \n+    /**\n+     * Test the implementation\n+     */\n+    public void testGetCause()\n+    {\n+        NestableRuntimeException ne1 = new NestableRuntimeException();\n+        assertNull(\"nestable runtime exception() cause is null\", ne1.getCause()); \n+        \n+        NestableRuntimeException ne2 = new NestableRuntimeException(\"ne2\");\n+        assertNull(\"nestable runtime exception(\\\"ne2\\\") cause is null\", ne2.getCause());\n+\n+        NestableRuntimeException ne3 = new NestableRuntimeException(new Exception(\"ne3 exception\"));\n+        assertNotNull(\"nestable runtime exception(new Exception(\\\"ne3 exception\\\") cause is not null\",\n+            ne3.getCause()); \n+        assertTrue(\"nestable runtime exception(new Exception(\\\"ne3 exception\\\") cause message == ne3 exception\",\n+            ne3.getCause().getMessage().equals(\"ne3 exception\")); \n+\n+        NestableRuntimeException ne4 = new NestableRuntimeException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertNotNull(\"nestable runtime exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") cause is not null\", \n+            ne4.getCause()); \n+\n+        NestableRuntimeException ne5 = new NestableRuntimeException(\"ne5\", null);\n+        assertNull(\"nestable runtime exception(\\\"ne5\\\", null) cause is null\", \n+            ne5.getCause());\n+\n+        NestableRuntimeException ne6 = new NestableRuntimeException(null, new Exception(\"ne6 exception\"));\n+        assertNotNull(\"nestable runtime exception(null, new Exception(\\\"ne6 exception\\\") cause is not null\", \n+            ne6.getCause()); \n+    }\n+    \n+    public void testGetLength()\n+    {\n+        NestableRuntimeException ne1 = new NestableRuntimeException();\n+        assertEquals(\"ne1 length\", 1, ne1.getLength());\n+\n+        NestableRuntimeException ne2 = new NestableRuntimeException(\"ne2\");\n+        assertEquals(\"ne2 length\", 1, ne2.getLength());\n+        \n+        NestableRuntimeException ne3 = new NestableRuntimeException(new Exception(\"ne3 exception\"));\n+        assertEquals(\"ne3 length\", 2, ne3.getLength());\n+        \n+        NestableRuntimeException ne4 = new NestableRuntimeException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertEquals(\"ne4 length\", 2, ne4.getLength());\n+        \n+        NestableRuntimeException ne5 = new NestableRuntimeException(\"ne5\", null);\n+        assertEquals(\"ne 5 length\", 1, ne5.getLength());\n+        \n+        NestableRuntimeException ne6 = new NestableRuntimeException(null, new Exception(\"ne6 exception\"));\n+        assertEquals(\"ne 6 length\", 2, ne6.getLength());\n+        \n+        NestableRuntimeException ne7 = new NestableRuntimeException(\"ne7o\", new NestableRuntimeException(\"ne7i\", new Exception(\"ne7 exception\")));\n+        assertEquals(\"ne 7 length\", 3, ne7.getLength());\n+\n+        NestableRuntimeException ne8 = new NestableRuntimeException(\"level 1\", new NestableRuntimeException(\"level 2\", new NestableRuntimeException(new NestableRuntimeException(\"level 4\", new Exception(\"level 5\")))));\n+        assertEquals(\"ne 8 length\", 5, ne8.getLength());\n+    }\n+    \n+    public void testGetMessage()\n+    {\n+        NestableRuntimeException ne1 = new NestableRuntimeException();\n+        assertNull(\"nestable runtime exception() message is null\", ne1.getMessage()); \n+        \n+        NestableRuntimeException ne2 = new NestableRuntimeException(\"ne2\");\n+        assertNotNull(\"nestable runtime exception(\\\"ne2\\\") message is not null\", ne2.getMessage()); \n+        assertTrue(\"nestable runtime exception(\\\"ne2\\\") message == ne2\", ne2.getMessage().equals(\"ne2\")); \n+\n+        NestableRuntimeException ne3 = new NestableRuntimeException(new Exception(\"ne3 exception\"));\n+        assertNotNull(\"nestable runtime exception(new Exception(\\\"ne3 exception\\\") message is not null\",\n+            ne3.getMessage());\n+        assertTrue(\"nestable runtime exception(new Exception(\\\"ne3 exception\\\") message == cause message\",\n+            ne3.getMessage().equals(ne3.getCause().getMessage())); \n+\n+        NestableRuntimeException ne4 = new NestableRuntimeException(\"ne4\", new Exception(\"ne4 exception\"));\n+        assertNotNull(\"nestable runtime exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") message is not null\", \n+            ne4.getMessage()); \n+        assertTrue(\"nestable runtime exception(\\\"ne4\\\", new Exception(\\\"ne4 exception\\\") message == ne4: ne4 exception\", \n+            ne4.getMessage().equals(\"ne4: ne4 exception\")); \n+\n+        NestableRuntimeException ne5 = new NestableRuntimeException(\"ne5\", null);\n+        assertNotNull(\"nestable runtime exception(\\\"ne5\\\", new Exception(\\\"ne5 exception\\\") message is not null\", \n+            ne5.getMessage()); \n+        assertTrue(\"nestable runtime exception(\\\"ne5\\\", null) message == ne5\", \n+            ne5.getMessage().equals(\"ne5\")); \n+\n+        NestableRuntimeException ne6 = new NestableRuntimeException(null, new Exception(\"ne6 exception\"));\n+        assertTrue(\"nestable runtime exception(null, new Exception(\\\"ne6 exception\\\") cause == ne6 exception\", \n+            ne6.getMessage().equals(\"ne6 exception\")); \n+\n+        NestableRuntimeException ne7 = new NestableRuntimeException(\"ne7o\", new NestableRuntimeException(\"ne7i\", new Exception(\"ne7 exception\")));\n+        assertTrue(\"nextable exception(\\\"ne7o\\\", new NestableRuntimeException(\\\"ne7i\\\", new Exception(\\\"ne7 exception\\\"))) message is ne7o: ne7i: ne7 exception\",\n+            ne7.getMessage().equals(\"ne7o: ne7i: ne7 exception\")); \n+    }\n+    \n+    public void testGetMessageN()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        NestableRuntimeException ne = new NestableRuntimeException(msgs[0], new NestableRuntimeException(msgs[1], new NestableRuntimeException(new NestableRuntimeException(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < msgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], ne.getMessage(i));\n+        }\n+        assertEquals(\"message -1\", msgs[0], ne.getMessage(-1));\n+        assertEquals(\"message 999\", msgs[4], ne.getMessage(999));\n+    }\n+    \n+    public void testGetMessages()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        NestableRuntimeException ne = new NestableRuntimeException(msgs[0], new NestableRuntimeException(msgs[1], new NestableRuntimeException(new NestableRuntimeException(msgs[3], new Exception(msgs[4])))));\n+        String[] nMsgs = ne.getMessages();\n+        assertEquals(\"messages length\", msgs.length, nMsgs.length);\n+        for(int i = 0; i < nMsgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], nMsgs[i]);\n+        }\n+    }\n+\n+    public void testGetThrowable()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableRuntimeExceptionTester1(new Exception(msgs[1]));\n+        doNestableRuntimeExceptionGetThrowable(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = NestableRuntimeExceptionTester2.class;\n+        throwables[2] = NestableRuntimeExceptionTester1.class;\n+        throwables[3] = NestableRuntimeExceptionTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableRuntimeExceptionTester1(msgs[0], new NestableRuntimeExceptionTester2(msgs[1], new NestableRuntimeExceptionTester1(new NestableRuntimeExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        doNestableRuntimeExceptionGetThrowable(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableRuntimeExceptionGetThrowable(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        Throwable t = null;\n+        String msg = null;\n+\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            t = n.getThrowable(i);\n+            assertEquals(\"throwable class\", classes[i], t.getClass());\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+        t = n.getThrowable(-1);\n+        assertEquals(\"throwable(-1)\", classes[0], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[0], msg);\n+        t = n.getThrowable(999);\n+        assertEquals(\"throwable(999)\", classes[classes.length - 1], t.getClass());\n+        if(Nestable.class.isInstance(t))\n+        {\n+            msg = ((Nestable) t).getMessage(0);\n+        }\n+        else\n+        {\n+            msg = t.getMessage();\n+        }\n+        assertEquals(\"throwable message\", msgs[msgs.length - 1], msg);\n+    }\n+    \n+    public void testGetThrowables()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableRuntimeExceptionTester1(new Exception(msgs[1]));\n+        doNestableRuntimeExceptionGetThrowables(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = NestableRuntimeExceptionTester2.class;\n+        throwables[2] = NestableRuntimeExceptionTester1.class;\n+        throwables[3] = NestableRuntimeExceptionTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableRuntimeExceptionTester1(msgs[0], new NestableRuntimeExceptionTester2(msgs[1], new NestableRuntimeExceptionTester1(new NestableRuntimeExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        doNestableRuntimeExceptionGetThrowables(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableRuntimeExceptionGetThrowables(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        String msg = null;\n+\n+        Throwable throwables[] = n.getThrowables();\n+        assertEquals(\"throwables length\", classes.length, throwables.length);\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            assertEquals(\"throwable class\", classes[i], throwables[i].getClass());\n+            Throwable t = throwables[i];\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+    }\n+    \n+    public void testIndexOfThrowable()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = NestableRuntimeExceptionTester2.class;\n+        throwables[2] = NestableRuntimeExceptionTester1.class;\n+        throwables[3] = NestableRuntimeExceptionTester2.class;\n+        throwables[4] = Exception.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableRuntimeExceptionTester1(msgs[0], new NestableRuntimeExceptionTester2(msgs[1], new NestableRuntimeExceptionTester1(new NestableRuntimeExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableRuntimeExceptionIndexOfThrowable(n, throwables[i], indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableRuntimeExceptionIndexOfThrowable(n, java.util.Date.class, -1, null);\n+    }\n+    \n+    private void doNestableRuntimeExceptionIndexOfThrowable(Nestable n, Class type, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(type);\n+        assertEquals(\"index of throwable \" + type.getName(), expectedIndex, index);\n+        t = n.getThrowable(index);\n+        if(expectedMsg != null)\n+        {\n+            String msg = null;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+        }\n+    }\n+    \n+    public void testIndexOfThrowableN()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableRuntimeExceptionTester1.class;\n+        throwables[1] = NestableRuntimeExceptionTester2.class;\n+        throwables[2] = NestableRuntimeExceptionTester1.class;\n+        throwables[3] = NestableRuntimeExceptionTester2.class;\n+        throwables[4] = Exception.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableRuntimeExceptionTester1(msgs[0], new NestableRuntimeExceptionTester2(msgs[1], new NestableRuntimeExceptionTester1(new NestableRuntimeExceptionTester2(msgs[3], new Exception(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableRuntimeExceptionIndexOfThrowableN(n, throwables[i], 0, indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableRuntimeExceptionIndexOfThrowableN(n, NestableRuntimeExceptionTester2.class, 2, 3, msgs[3]);\n+        doNestableRuntimeExceptionIndexOfThrowableN(n, NestableRuntimeExceptionTester1.class, 1, 2, msgs[2]);\n+        doNestableRuntimeExceptionIndexOfThrowableN(n, java.util.Date.class, 0, -1, null);\n+    }\n+\n+    private void doNestableRuntimeExceptionIndexOfThrowableN(Nestable n, Class type, int pos, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(pos, type);\n+        assertEquals(\"index of throwable \" + type.getName(), expectedIndex, index);\n+        t = n.getThrowable(index);\n+        if(expectedMsg != null)\n+        {\n+            String msg = null;\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+        }\n+    }\n+    \n+    public void testPrintStackTrace()\n+    {\n+        NestableRuntimeException ne8 = new NestableRuntimeException(\"ne8\", new Exception(\"ne8 exception\"));\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        PrintWriter pw1 = new PrintWriter(ps1, true);\n+        ne8.printStackTrace(ps1);\n+        String stack1 = baos1.toString();\n+        assertTrue(\"stack trace startsWith == java.lang.Exception: ne8 exception\",\n+            stack1.startsWith(\"java.lang.Exception: ne8 exception\")); \n+        assertTrue(\"stack trace indexOf org.apache.commons.lang.exception.NestableRuntimeException: ne8: ne8 exception > -1\",\n+            stack1.indexOf(\"org.apache.commons.lang.exception.NestableRuntimeException: ne8: ne8 exception\") > -1); \n+    }\n+\n+    public void testPrintPartialStackTrace()\n+    {\n+        NestableRuntimeException ne9 = new NestableRuntimeException(\"ne9\", new Exception(\"ne9 exception\"));\n+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n+        PrintStream ps2 = new PrintStream(baos2);\n+        PrintWriter pw2 = new PrintWriter(ps2, true);\n+        ne9.printPartialStackTrace(pw2);\n+        String stack2 = baos2.toString();\n+        assertTrue(\"stack trace startsWith == org.apache.commons.lang.exception.NestableRuntimeException: ne9: ne9 exception\",\n+            stack2.startsWith(\"org.apache.commons.lang.exception.NestableRuntimeException: ne9: ne9 exception\"));\n+        assertEquals(\"stack trace indexOf rethrown == -1\",\n+            stack2.indexOf(\"rethrown\"), -1);\n+    }\n+\n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n+class NestableRuntimeExceptionTester1 extends NestableRuntimeException\n+{\n+    public NestableRuntimeExceptionTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableRuntimeExceptionTester1(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableRuntimeExceptionTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableRuntimeExceptionTester1(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n+class NestableRuntimeExceptionTester2 extends NestableRuntimeException\n+{\n+    public NestableRuntimeExceptionTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}", "timestamp": 1027049756, "metainfo": ""}