{"sha": "12796537fc6f3d5d3d3df9fa1027f2f377c30a71", "log": "Rework DurationFormatUtils to have clearer API based on two types of formatting Fix millisecond formatting bug   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Henri Yandell\n  * @since 2.1\n- * @version $Id: DurationFormatUtils.java,v 1.20 2004/10/02 01:40:30 bayard Exp $\n+ * @version $Id: DurationFormatUtils.java,v 1.21 2004/10/15 23:11:31 scolebourne Exp $\n  */\n public class DurationFormatUtils {\n \n      * to operate.</p>\n      */\n     public DurationFormatUtils() {\n-    }\n-\n-    /**\n-     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code> for the ISO8601 \n-     * date time extended format used in durations.</p>\n+        super();\n+    }\n+\n+    /**\n+     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n+     * for the ISO8601 period format used in durations.</p>\n      * \n      * @see org.apache.commons.lang.time.FastDateFormat\n      * @see java.text.SimpleDateFormat\n      */\n     public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n \n-    /**\n-     * <p>ISO8601 formatter for the date time extended format used in durations, \n-     * with XML Schema durations particularly in mind.</p>\n-     * \n-     * <p>This format represents the Gregorian year, month, day, hour, minute, and second components defined \n-     * in section 5.5.3.2 of ISO 8601, respectively. These components are ordered in their significance by their order \n-     * of appearance i.e. as year, month, day, hour, minute, and second.</p>\n-     * \n-     * <p>The ISO8601 extended format P<i>n</i>Y<i>n</i>M<i>n</i>DT<i>n</i>H<i>n</i>M<i>n</i>S, where <i>n</i>Y \n-     * represents the number of years, <i>n</i>M the number of months, <i>n</i>D the number of days, \n-     * 'T' is the date/time separator, <i>n</i>H the number of hours, <i>n</i>M the number of minutes and \n-     * <i>n</i>S the number of seconds. The number of seconds can include decimal digits to arbitrary precision.</p>\n-     * \n-     * @see #ISO_EXTENDED_FORMAT_PATTERN\n-     * @see <a href=\"http://www.w3.org/TR/xmlschema-2/#duration\">http://www.w3.org/TR/xmlschema-2/#duration</a>\n-     */\n-//    public static final FastDateFormat ISO_EXTENDED_FORMAT =\n-//        FastDateFormat.getInstance(ISO_EXTENDED_FORMAT_PATTERN);\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * <p>Get the time gap as a string.</p>\n      * \n      * <p>The format used is ISO8601-like:\n      * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n      * \n-     * @param millis  the duration to format\n-     * @return the time as a String\n-     */\n-    public static String formatISO(long millis) {\n-        return format(millis, \"H:mm:ss.SSS\");\n-    }\n-\n-    public static String format(long millis) {\n-        return format(millis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );\n-    }\n-    public static String format(long startMillis, long endMillis) {\n-        return format(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );\n-    }\n-\n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationHMS(long durationMillis) {\n+        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n+    }\n+\n+    /**\n+     * <p>Get the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * ISO format pattern, such as P7D6H5M4.321S.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationISO(long durationMillis) {\n+        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n+    }\n \n     /**\n      * <p>Get the time gap as a string, using the specified format, and padding with zeros and \n      * using the default timezone.</p>\n      * \n-     * @param millis  the duration to format\n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n      * @param format  the way in which to format the duration\n      * @return the time as a String\n      */\n-    public static String format(long millis, String format) {\n-        return format(millis, format, true, TimeZone.getDefault());\n-    }\n+    public static String formatDuration(long durationMillis, String format) {\n+        return formatDuration(durationMillis, format, true);\n+    }\n+\n     /**\n      * <p>Get the time gap as a string, using the specified format.\n      * Padding the left hand side of numbers with zeroes is optional and \n-     * the timezone may be specified. \n-     * \n-     * @param millis  the duration to format\n+     * the timezone may be specified.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n      * @param format  the way in which to format the duration\n-     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n-     * @param timezone the millis are defined in\n-     * @return the time as a String\n-     */\n-    public static String format(long millis, String format, boolean padWithZeros, TimeZone timezone) {\n-\n-        if(millis >= 28 * DateUtils.MILLIS_PER_DAY) {\n-            Calendar c = Calendar.getInstance(timezone);\n-            c.set(1970, 0, 1, 0, 0, 0);\n-            c.set(Calendar.MILLISECOND, 0);\n-            return format(c.getTime().getTime(), millis, format, padWithZeros, timezone);\n-        }\n+     * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n \n         Token[] tokens = lexx(format);\n \n-        int years        = 0;\n-        int months       = 0;\n         int days         = 0;\n         int hours        = 0;\n         int minutes      = 0;\n         int seconds      = 0;\n         int milliseconds = 0;\n-\n-        /*  This will never be evaluated\n-        if(Token.containsTokenWithValue(tokens, y) ) {\n-            years = (int) (millis / DateUtils.MILLIS_PER_YEAR);\n-            millis = millis - (years * DateUtils.MILLIS_PER_YEAR);\n-        }\n-        if(Token.containsTokenWithValue(tokens, M) ) {\n-            months = (int) (millis / DateUtils.MILLIS_PER_MONTH);\n-            millis = millis - (months * DateUtils.MILLIS_PER_MONTH);\n-            // as MONTH * 12 != YEAR, this fixes issues\n-            if(months == 12) {\n-                years++;\n-                months = 0;\n-            }\n-        }\n-        */\n-        if(Token.containsTokenWithValue(tokens, d) ) {\n-            days = (int) (millis / DateUtils.MILLIS_PER_DAY);\n-            millis = millis - (days * DateUtils.MILLIS_PER_DAY);\n-        }\n-        if(Token.containsTokenWithValue(tokens, H) ) {\n-            hours = (int) (millis / DateUtils.MILLIS_PER_HOUR);\n-            millis = millis - (hours * DateUtils.MILLIS_PER_HOUR);\n-        }\n-        if(Token.containsTokenWithValue(tokens, m) ) {\n-            minutes = (int) (millis / DateUtils.MILLIS_PER_MINUTE);\n-            millis = millis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n-        }\n-        if(Token.containsTokenWithValue(tokens, s) ) {\n-            seconds = (int) (millis / DateUtils.MILLIS_PER_SECOND);\n-            millis = millis - (seconds * DateUtils.MILLIS_PER_SECOND);\n-        }\n-        if(Token.containsTokenWithValue(tokens, S) ) {\n-            milliseconds = (int) millis;\n-        }\n-\n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n-    }\n-\n-\n-    static String formatDuration(Token[] tokens, int years, int months, int days, int hours, \n+        \n+        if (Token.containsTokenWithValue(tokens, d) ) {\n+            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n+            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n+        }\n+        if (Token.containsTokenWithValue(tokens, H) ) {\n+            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n+            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n+        }\n+        if (Token.containsTokenWithValue(tokens, m) ) {\n+            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n+            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n+        }\n+        if (Token.containsTokenWithValue(tokens, s) ) {\n+            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n+            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n+        }\n+        if (Token.containsTokenWithValue(tokens, S) ) {\n+            milliseconds = (int) durationMillis;\n+        }\n+\n+        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    /**\n+     * <p>Format an elapsed time into a plurialization correct string.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the elapsed time to report in milliseconds\n+     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n+     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n+     * @return the formatted text in days/hours/minutes/seconds\n+     */\n+    public static String formatDurationWords(\n+        long durationMillis,\n+        boolean suppressLeadingZeroElements,\n+        boolean suppressTrailingZeroElements) {\n+\n+        // This method is generally replacable by the format method, but \n+        // there are a series of tweaks and special cases that require \n+        // trickery to replicate.\n+        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n+        if (suppressLeadingZeroElements) {\n+            // this is a temporary marker on the front. Like ^ in regexp.\n+            duration = \" \" + duration;\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                    duration = tmp;\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n+                    }\n+                }\n+            }\n+            if (duration.length() != 0) {\n+                // strip the space off again\n+                duration = duration.substring(1);\n+            }\n+        }\n+        if (suppressTrailingZeroElements) {\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n+                    }\n+                }\n+            }\n+        }\n+        // handle plurals\n+        duration = StringUtils.replaceOnce(duration, \"1 seconds\", \"1 second\");\n+        duration = StringUtils.replaceOnce(duration, \"1 minutes\", \"1 minute\");\n+        duration = StringUtils.replaceOnce(duration, \"1 hours\", \"1 hour\");\n+        duration = StringUtils.replaceOnce(duration, \"1 days\", \"1 day\");\n+        return duration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Get the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * @param millis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatPeriodISO(long startMillis, long endMillis) {\n+        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );\n+    }\n+\n+    /**\n+     * <p>Get the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional.\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format) {\n+        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Get the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified. \n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n+     * @param timezone the millis are defined in\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+\n+        long millis = endMillis - startMillis;\n+        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n+        }\n+\n+        Token[] tokens = lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start = Calendar.getInstance(timezone);\n+        start.setTime(new Date(startMillis));\n+        Calendar end = Calendar.getInstance(timezone);\n+        end.setTime(new Date(endMillis));\n+\n+        // initial estimates\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        // each initial estimate is adjusted in case it is under 0\n+        while (months < 0) {\n+            months += 12;\n+            years -= 1;\n+        }\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        while (days < 0) {\n+            days += 31; // such overshooting is taken care of later on\n+            months -= 1;\n+        }\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        while (hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        while (minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        while (seconds < 0) {\n+            seconds += 60;\n+            minutes -= 1;\n+        }\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        while (milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n+\n+        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n+\n+        // This next block of code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n+                months += 12 * years;\n+                years = 0;\n+            } else {\n+                // TODO: this is a bit weak, needs work to know about leap years\n+                days += 365 * years;\n+                years = 0;\n+            }\n+        }\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n+            minutes += 60 * hours;\n+            hours = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n+            seconds += 60 * minutes;\n+            minutes = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n+            milliseconds += 1000 * seconds;\n+            seconds = 0;\n+        }\n+\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>The internal method to do the formatting.</p>\n+     * \n+     * @param tokens  the tokens\n+     * @param years  the number of years\n+     * @param months  the number of months\n+     * @param days  the number of days\n+     * @param hours  the number of hours\n+     * @param minutes  the number of minutes\n+     * @param seconds  the number of seconds\n+     * @param milliseconds  the number of millis\n+     * @param padWithZeros  whether to pad\n+     * @return the formetted string\n+     */\n+    static String format(Token[] tokens, int years, int months, int days, int hours, \n                                  int minutes, int seconds, int milliseconds, boolean padWithZeros) \n     { \n         StringBuffer buffer = new StringBuffer();\n+        boolean lastOutputSeconds = false;\n         int sz = tokens.length;\n-        for(int i=0; i<sz; i++) {\n+        for (int i = 0; i < sz; i++) {\n             Token token = tokens[i];\n             Object value = token.getValue();\n             int count = token.getCount();\n             if(value instanceof StringBuffer) {\n                 buffer.append(value.toString());\n             } else {\n-                if(value == y) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+years, count, \"0\") : \"\"+years ); \n-                } else\n-                if(value == M) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+months, count, \"0\") : \"\"+months ); \n-                } else\n-                if(value == d) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+days, count, \"0\") : \"\"+days ); \n-                } else\n-                if(value == H) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+hours, count, \"0\") : \"\"+hours ); \n-                } else\n-                if(value == m) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+minutes, count, \"0\") : \"\"+minutes ); \n-                } else\n-                if(value == s) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+seconds, count, \"0\") : \"\"+seconds ); \n-                } else\n-                if(value == S) {\n-                    buffer.append( padWithZeros ? StringUtils.leftPad(\"\"+milliseconds, count, \"0\") : \"\"+milliseconds ); \n+                if (value == y) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));\n+                    lastOutputSeconds = false;\n+                } else if (value == M) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));\n+                    lastOutputSeconds = false;\n+                } else if (value == d) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));\n+                    lastOutputSeconds = false;\n+                } else if (value == H) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));\n+                    lastOutputSeconds = false;\n+                } else if (value == m) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));\n+                    lastOutputSeconds = false;\n+                } else if (value == s) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));\n+                    lastOutputSeconds = true;\n+                } else if (value == S) {\n+                    if (lastOutputSeconds) {\n+                        milliseconds += 1000;\n+                        String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);\n+                        buffer.append(str.substring(1));\n+                    } else {\n+                        buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));\n+                    }\n+                    lastOutputSeconds = false;\n                 }\n             }\n         }\n     }\n \n     /**\n-     * <p>Get the time gap as a string, using the specified format.\n-     * Padding the left hand side of numbers with zeroes is optional.\n-     * \n-     * @param startMillis  the start of the duration\n-     * @param endMillis  the end of the duration\n-     * @param format  the way in which to format the duration\n-     * @return the time as a String\n-     */\n-    public static String format(long startMillis, long endMillis, String format) {\n-        return format(startMillis, endMillis, format, true, TimeZone.getDefault());\n-    }\n-    /**\n-     * <p>Get the time gap as a string, using the specified format.\n-     * Padding the left hand side of numbers with zeroes is optional and \n-     * the timezone may be specified. \n-     * \n-     * @param startMillis  the start of the duration\n-     * @param endMillis  the end of the duration\n-     * @param format  the way in which to format the duration\n-     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n-     * @param timezone the millis are defined in\n-     * @return the time as a String\n-     */\n-    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n-\n-        long millis = endMillis - startMillis;\n-        if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n-            return format(millis, format, padWithZeros, timezone);\n-        }\n-\n-        Token[] tokens = lexx(format);\n-\n-        // timezones get funky around 0, so normalizing everything to GMT \n-        // stops the hours being off\n-        Calendar start = Calendar.getInstance(timezone);\n-        start.setTime(new Date(startMillis));\n-        Calendar end = Calendar.getInstance(timezone);\n-        end.setTime(new Date(endMillis));\n-\n-        // initial estimates\n-        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n-        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-        // each initial estimate is adjusted in case it is under 0\n-        while(months < 0) {\n-            months += 12;\n-            years -= 1;\n-        }\n-        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-        while(days < 0) {\n-            days += 31;  // such overshooting is taken care of later on\n-            months -= 1;\n-        }\n-        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-        while(hours < 0) {\n-            hours += 24;\n-            days -= 1;\n-        }\n-        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-        while(minutes < 0) {\n-            minutes += 60;\n-            hours -= 1;\n-        }\n-        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-        while(seconds < 0) {\n-            seconds += 60;\n-            minutes -= 1;\n-        }\n-        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-        while(milliseconds < 0) {\n-            milliseconds += 1000;\n-            seconds -= 1;\n-        }\n-\n-        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n-        milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n-        seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n-        minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n-        hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n-        days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n-        months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n-        years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n-\n-        // This next block of code adds in values that \n-        // aren't requested. This allows the user to ask for the \n-        // number of months and get the real count and not just 0->11.\n-        if(!Token.containsTokenWithValue(tokens, y) ) {\n-            if(Token.containsTokenWithValue(tokens, M) ) {\n-                months += 12 * years;\n-                years = 0;\n-            } else {\n-                // TODO: this is a bit weak, needs work to know about leap years\n-                days += 365 * years;\n-                years = 0;\n-            }\n-        }\n-        if(!Token.containsTokenWithValue(tokens, M) ) {\n-            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n-            months = 0;\n-        }\n-        if(!Token.containsTokenWithValue(tokens, d) ) {\n-            hours += 24 * days;\n-            days = 0;\n-        }\n-        if(!Token.containsTokenWithValue(tokens, H) ) {\n-            minutes += 60 * hours;\n-            hours = 0;\n-        }\n-        if(!Token.containsTokenWithValue(tokens, m) ) {\n-            seconds += 60 * minutes;\n-            minutes = 0;\n-        }\n-        if(!Token.containsTokenWithValue(tokens, s) ) {\n-            milliseconds += 1000 * seconds;\n-            seconds = 0;\n-        }\n-\n-        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n-    }\n-\n-    // Reduces by difference, then if it overshot, calculates the overshot amount and \n-    // fixes and returns the amount to change by\n+     * Reduces by difference, then if it overshot, calculates the overshot amount and \n+     * fixes and returns the amount to change by.\n+     */\n     static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n         end.add( field, -1 * difference );\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n-        if(endValue < startValue) {\n+        if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n         } else {\n             return 0;\n         }\n-    }\n-\n-    /**\n-     * <p>Format an elapsed time into a plurialization correct string.</p>\n-     * \n-     * @param millis  the elapsed time to report in milliseconds\n-     * @param suppressLeadingZeroElements suppresses leading 0 elements\n-     * @param suppressTrailingZeroElements suppresses trailing 0 elements\n-     * @return the formatted text in days/hours/minutes/seconds\n-     */\n-    public static String formatWords(\n-        long millis,\n-        boolean suppressLeadingZeroElements,\n-        boolean suppressTrailingZeroElements) {\n-\n-        // This method is generally replacable by the format method, but \n-        // there are a series of tweaks and special cases that require \n-        // trickery to replicate.\n-        String duration = format(millis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n-        if(suppressLeadingZeroElements) {\n-            // this is a temporary marker on the front. Like ^ in regexp.\n-            duration = \" \" + duration;\n-            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n-            if(tmp.length() != duration.length()) {\n-                duration = tmp;\n-                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n-                if(tmp.length() != duration.length()) {\n-                    duration = tmp;\n-                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n-                    duration = tmp;\n-                    if(tmp.length() != duration.length()) {\n-                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n-                    }\n-                }\n-            }\n-            if(duration.length() != 0) {\n-                // strip the space off again\n-                duration = duration.substring(1);\n-            }\n-        }\n-        if(suppressTrailingZeroElements) {\n-            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n-            if(tmp.length() != duration.length()) {\n-                duration = tmp;\n-                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n-                if(tmp.length() != duration.length()) {\n-                    duration = tmp;\n-                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n-                    if(tmp.length() != duration.length()) {\n-                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n-                    }\n-                }\n-            }\n-        }\n-        // handle plurals\n-        duration = StringUtils.replaceOnce(duration, \"1 seconds\", \"1 second\");\n-        duration = StringUtils.replaceOnce(duration, \"1 minutes\", \"1 minute\");\n-        duration = StringUtils.replaceOnce(duration, \"1 hours\", \"1 hour\");\n-        duration = StringUtils.replaceOnce(duration, \"1 days\", \"1 day\");\n-        return duration;\n     }\n \n     static final Object y = \"y\";\n         return (Token[]) list.toArray( new Token[0] );\n     }\n \n+    /**\n+     * Element that is parsed from the format pattern.\n+     */\n+    static class Token {\n+\n+        // will only work for the tokens, not for stringbuffers/numbers\n+        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+            int sz = tokens.length;\n+            for (int i = 0; i < sz; i++) {\n+                if (tokens[i].getValue() == value) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Object value;\n+        private int count;\n+\n+        Token(Object value) {\n+            this.value = value;\n+            this.count = 1;\n+        }\n+\n+        Token(Object value, int count) {\n+            this.value = value;\n+            this.count = count;\n+        }\n+\n+        void increment() { \n+            count++;\n+        }\n+\n+        int getCount() {\n+            return count;\n+        }\n+\n+        Object getValue() {\n+            return value;\n+        }\n+\n+        public boolean equals(Object obj2) {\n+            if (obj2 instanceof Token) {\n+                Token tok2 = (Token) obj2;\n+                if (this.value.getClass() != tok2.value.getClass()) {\n+                    return false;\n+                }\n+                if (this.count != tok2.count) {\n+                    return false;\n+                }\n+                if (this.value instanceof StringBuffer) {\n+                    return this.value.toString().equals(tok2.value.toString());\n+                } else if (this.value instanceof Number) {\n+                    return this.value.equals(tok2.value);\n+                } else {\n+                    return this.value == tok2.value;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public String toString() {\n+            return StringUtils.repeat(this.value.toString(), this.count);\n+        }\n+    }\n+\n }\n-\n-// Represents an element of the format-mini-language.\n-class Token {\n-\n-    // will only work for the tokens, not for stringbuffers/numbers\n-    static boolean containsTokenWithValue(Token[] tokens, Object value) {\n-        int sz = tokens.length;\n-        for(int i=0; i<sz; i++) {\n-            if(tokens[i].getValue() == value) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private Object value;\n-    private int count;\n-\n-    public Token(Object value) {\n-        this.value = value;\n-        this.count = 1;\n-    }\n-\n-    Token(Object value, int count) {\n-        this.value = value;\n-        this.count = count;\n-    }\n-\n-    public void increment() { \n-        count++;\n-    }\n-\n-    public int getCount() {\n-        return count;\n-    }\n-\n-    public Object getValue() {\n-        return value;\n-    }\n-\n-    public boolean equals(Object obj2) {\n-        if(obj2 instanceof Token) {\n-            Token tok2 = (Token) obj2;\n-            if(this.value.getClass() != tok2.value.getClass()) {\n-                return false;\n-            }\n-            if(this.count != tok2.count) {\n-                return false;\n-            }\n-            if(this.value instanceof StringBuffer) {\n-                return this.value.toString().equals(tok2.value.toString());\n-            } else\n-            if(this.value instanceof Number) {\n-                return this.value.equals(tok2.value);\n-            } else {\n-                return this.value == tok2.value;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public String toString() {\n-        return StringUtils.repeat(this.value.toString(), this.count);\n-    }\n-\n-}\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n  * @author Henri Yandell\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: StopWatch.java,v 1.10 2004/10/08 00:09:01 scolebourne Exp $\n+ * @version $Id: StopWatch.java,v 1.11 2004/10/15 23:11:31 scolebourne Exp $\n  */\n public class StopWatch {\n \n      * @return the time as a String\n      */\n     public String toString() {\n-        return DurationFormatUtils.formatISO(getTime());\n+        return DurationFormatUtils.formatDurationHMS(getTime());\n     }\n \n     /**\n      * @since 2.1\n      */\n     public String toSplitString() {\n-        return DurationFormatUtils.formatISO(getSplitTime());\n+        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n     }\n     \n     //-----------------------------------------------------------------------\n-    public void testFormatWords(){\n+    public void testFormatDurationWords(){\n         String text = null;\n         \n-        text = DurationFormatUtils.formatWords(50*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(50*1000, true, false);\n         assertEquals(\"50 seconds\", text);\n-        text = DurationFormatUtils.formatWords(65*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(65*1000, true, false);\n         assertEquals(\"1 minute 5 seconds\", text);\n-        text = DurationFormatUtils.formatWords(120*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(120*1000, true, false);\n         assertEquals(\"2 minutes 0 seconds\", text);\n-        text = DurationFormatUtils.formatWords(121*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(121*1000, true, false);\n         assertEquals(\"2 minutes 1 second\", text);\n-        text = DurationFormatUtils.formatWords(72*60*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(72*60*1000, true, false);\n         assertEquals(\"1 hour 12 minutes 0 seconds\", text);\n-        text = DurationFormatUtils.formatWords(24*60*60*1000, true, false);\n+        text = DurationFormatUtils.formatDurationWords(24*60*60*1000, true, false);\n         assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n         \n-        text = DurationFormatUtils.formatWords(50*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(50*1000, true, true);\n         assertEquals(\"50 seconds\", text);\n-        text = DurationFormatUtils.formatWords(65*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(65*1000, true, true);\n         assertEquals(\"1 minute 5 seconds\", text);\n-        text = DurationFormatUtils.formatWords(120*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(120*1000, true, true);\n         assertEquals(\"2 minutes\", text);\n-        text = DurationFormatUtils.formatWords(121*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(121*1000, true, true);\n         assertEquals(\"2 minutes 1 second\", text);\n-        text = DurationFormatUtils.formatWords(72*60*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(72*60*1000, true, true);\n         assertEquals(\"1 hour 12 minutes\", text);\n-        text = DurationFormatUtils.formatWords(24*60*60*1000, true, true);\n+        text = DurationFormatUtils.formatDurationWords(24*60*60*1000, true, true);\n         assertEquals(\"1 day\", text);\n         \n-        text = DurationFormatUtils.formatWords(50*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(50*1000, false, true);\n         assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n-        text = DurationFormatUtils.formatWords(65*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(65*1000, false, true);\n         assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n-        text = DurationFormatUtils.formatWords(120*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(120*1000, false, true);\n         assertEquals(\"0 days 0 hours 2 minutes\", text);\n-        text = DurationFormatUtils.formatWords(121*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(121*1000, false, true);\n         assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n-        text = DurationFormatUtils.formatWords(72*60*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(72*60*1000, false, true);\n         assertEquals(\"0 days 1 hour 12 minutes\", text);\n-        text = DurationFormatUtils.formatWords(24*60*60*1000, false, true);\n+        text = DurationFormatUtils.formatDurationWords(24*60*60*1000, false, true);\n         assertEquals(\"1 day\", text);\n         \n-        text = DurationFormatUtils.formatWords(50*1000, false, false);\n+        text = DurationFormatUtils.formatDurationWords(50*1000, false, false);\n         assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n-        text = DurationFormatUtils.formatWords(65*1000, false, false);\n+        text = DurationFormatUtils.formatDurationWords(65*1000, false, false);\n         assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n-        text = DurationFormatUtils.formatWords(120*1000, false, false);\n+        text = DurationFormatUtils.formatDurationWords(120*1000, false, false);\n         assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n-        text = DurationFormatUtils.formatWords(121*1000, false, false);\n+        text = DurationFormatUtils.formatDurationWords(121*1000, false, false);\n         assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n-        text = DurationFormatUtils.formatWords(72*60*1000, false, false);\n+        text = DurationFormatUtils.formatDurationWords(72*60*1000, false, false);\n         assertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n-        text = DurationFormatUtils.formatWords(48*60*60*1000 + 72*60*1000 , false, false);\n+        text = DurationFormatUtils.formatDurationWords(48*60*60*1000 + 72*60*1000 , false, false);\n         assertEquals(\"2 days 1 hour 12 minutes 0 seconds\", text);\n     }\n \n-    public void testFormatISOStyle(){\n+    public void testFormatDurationHMS(){\n         long time = 0;\n-        assertEquals(\"0:00:00.000\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:00.000\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 1;\n-        assertEquals(\"0:00:00.001\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:00.001\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 15;\n-        assertEquals(\"0:00:00.015\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:00.015\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 165;\n-        assertEquals(\"0:00:00.165\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:00.165\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 1675;\n-        assertEquals(\"0:00:01.675\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:01.675\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 13465;\n-        assertEquals(\"0:00:13.465\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:00:13.465\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 72789;\n-        assertEquals(\"0:01:12.789\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:01:12.789\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 12789 + 32 * 60000;\n-        assertEquals(\"0:32:12.789\", DurationFormatUtils.formatISO(time));\n+        assertEquals(\"0:32:12.789\", DurationFormatUtils.formatDurationHMS(time));\n         \n         time = 12789 + 62 * 60000;\n-        assertEquals(\"1:02:12.789\", DurationFormatUtils.formatISO(time));\n-    }\n-\n-    public void testISODurationFormat(){\n+        assertEquals(\"1:02:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+    }\n+\n+    public void testFormatDurationISO() {\n+        assertEquals(\"P0Y0M0DT0H0M0.000S\", DurationFormatUtils.formatDurationISO(0L));\n+        assertEquals(\"P0Y0M0DT0H0M0.001S\", DurationFormatUtils.formatDurationISO(1L));\n+        assertEquals(\"P0Y0M0DT0H0M0.010S\", DurationFormatUtils.formatDurationISO(10L));\n+        assertEquals(\"P0Y0M0DT0H0M0.100S\", DurationFormatUtils.formatDurationISO(100L));\n+        assertEquals(\"P0Y0M0DT0H1M15.321S\", DurationFormatUtils.formatDurationISO(75321L));\n+    }\n+\n+    public void testFormatDuration() {\n+        long duration = 0;\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"y\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"M\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"d\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"H\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"m\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"s\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"S\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatDuration(duration, \"SSSS\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatDuration(duration, \"yyyy\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatDuration(duration, \"yyMM\") );\n+\n+        duration = 60 * 1000;\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"y\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"M\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"d\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatDuration(duration, \"H\") );\n+        assertEquals( \"1\", DurationFormatUtils.formatDuration(duration, \"m\") );\n+        assertEquals( \"60\", DurationFormatUtils.formatDuration(duration, \"s\") );\n+        assertEquals( \"60000\", DurationFormatUtils.formatDuration(duration, \"S\") );\n+        assertEquals( \"01:00\", DurationFormatUtils.formatDuration(duration, \"mm:ss\") );\n+\n+        Calendar base = Calendar.getInstance();\n+        base.set(2000, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+        \n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2003, 1, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal\n+        // don't use 1970 in test as time zones were less reliable in 1970 than now\n+        // remember that duration formatting ignores time zones, working on strict hour lengths\n+        int days = 366 + 365 + 365 + 31;\n+        assertEquals( \"0 0 \" + days, DurationFormatUtils.formatDuration(duration, \"y M d\") );\n+    }\n+\n+    public void testFormatPeriodISO(){\n         TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar base = Calendar.getInstance(timeZone);\n+        base.set(1970, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+        \n         Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002, 1, 23, 9, 11, 12);\n         cal.set(Calendar.MILLISECOND, 1);\n         text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n         assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n         // test fixture is the same as above, but now with extended format.\n-        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n-        assertEquals(\"P32Y1M22DT9H11M12.1S\", text);\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P32Y1M22DT9H11M12.001S\", text);\n         // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration\n         cal.set(1971, 1, 3, 10, 30, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n-        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n-        assertEquals(\"P1Y1M2DT10H30M0.0S\", text);\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P1Y1M2DT10H30M0.000S\", text);\n         // want a way to say 'don't print the seconds in format()' or other fields for that matter:\n         //assertEquals(\"P1Y2M3DT10H30M\", text);\n     }\n \n-    public void testFormat() {\n-        long time = 0;\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"y\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"M\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"d\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"H\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"m\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"s\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"S\") );\n-        assertEquals( \"0000\", DurationFormatUtils.format(time, \"SSSS\") );\n-        assertEquals( \"0000\", DurationFormatUtils.format(time, \"yyyy\") );\n-        assertEquals( \"0000\", DurationFormatUtils.format(time, \"yyMM\") );\n-\n-        time = 60 * 1000;\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"y\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"M\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"d\") );\n-        assertEquals( \"0\", DurationFormatUtils.format(time, \"H\") );\n-        assertEquals( \"1\", DurationFormatUtils.format(time, \"m\") );\n-        assertEquals( \"60\", DurationFormatUtils.format(time, \"s\") );\n-        assertEquals( \"60000\", DurationFormatUtils.format(time, \"S\") );\n-        assertEquals( \"01:00\", DurationFormatUtils.format(time, \"mm:ss\") );\n+    public void testFormatPeriod() {\n+        Calendar cal1970 = Calendar.getInstance();\n+        cal1970.set(1970, 0, 1, 0, 0, 0);\n+        cal1970.set(Calendar.MILLISECOND, 0);\n+        long time1970 = cal1970.getTime().getTime();\n+        \n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"y\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"M\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"d\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"H\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"m\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"s\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"S\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"SSSS\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyyy\") );\n+        assertEquals( \"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyMM\") );\n+\n+        long time = time1970 + 60 * 1000;\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time, \"y\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time, \"M\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time, \"d\") );\n+        assertEquals( \"0\", DurationFormatUtils.formatPeriod(time1970, time, \"H\") );\n+        assertEquals( \"1\", DurationFormatUtils.formatPeriod(time1970, time, \"m\") );\n+        assertEquals( \"60\", DurationFormatUtils.formatPeriod(time1970, time, \"s\") );\n+        assertEquals( \"60000\", DurationFormatUtils.formatPeriod(time1970, time, \"S\") );\n+        assertEquals( \"01:00\", DurationFormatUtils.formatPeriod(time1970, time, \"mm:ss\") );\n \n         Calendar cal = Calendar.getInstance();\n         cal.set(1973, 6, 1, 0, 0, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         time = cal.getTime().getTime();\n-        assertEquals( \"36\", DurationFormatUtils.format(time, \"yM\") );\n-        assertEquals( \"3 years 6 months\", DurationFormatUtils.format(time, \"y' years 'M' months'\") );\n-        assertEquals( \"03/06\", DurationFormatUtils.format(time, \"yy/MM\") );\n+        assertEquals( \"36\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\") );\n+        assertEquals( \"3 years 6 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\") );\n+        assertEquals( \"03/06\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\") );\n \n         cal.set(1973, 10, 1, 0, 0, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         time = cal.getTime().getTime();\n-        assertEquals( \"310\", DurationFormatUtils.format(time, \"yM\") );\n-        assertEquals( \"3 years 10 months\", DurationFormatUtils.format(time, \"y' years 'M' months'\") );\n-        assertEquals( \"03/10\", DurationFormatUtils.format(time, \"yy/MM\") );\n+        assertEquals( \"310\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\") );\n+        assertEquals( \"3 years 10 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\") );\n+        assertEquals( \"03/10\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\") );\n \n         cal.set(1974, 0, 1, 0, 0, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         time = cal.getTime().getTime();\n-        assertEquals( \"40\", DurationFormatUtils.format(time, \"yM\") );\n-        assertEquals( \"4 years 0 months\", DurationFormatUtils.format(time, \"y' years 'M' months'\") );\n-        assertEquals( \"04/00\", DurationFormatUtils.format(time, \"yy/MM\") );\n-        assertEquals( \"48\", DurationFormatUtils.format(time, \"M\") );\n-        assertEquals( \"48\", DurationFormatUtils.format(time, \"MM\") );\n-        assertEquals( \"048\", DurationFormatUtils.format(time, \"MMM\") );\n+        assertEquals( \"40\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\") );\n+        assertEquals( \"4 years 0 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\") );\n+        assertEquals( \"04/00\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\") );\n+        assertEquals( \"48\", DurationFormatUtils.formatPeriod(time1970, time, \"M\") );\n+        assertEquals( \"48\", DurationFormatUtils.formatPeriod(time1970, time, \"MM\") );\n+        assertEquals( \"048\", DurationFormatUtils.formatPeriod(time1970, time, \"MMM\") );\n     }\n \n     public void testLexx() {\n         // tests each constant\n         assertArrayEquals( \n-          new Token[] { \n-            new Token( DurationFormatUtils.y, 1),\n-            new Token( DurationFormatUtils.M, 1),\n-            new Token( DurationFormatUtils.d, 1),\n-            new Token( DurationFormatUtils.H, 1),\n-            new Token( DurationFormatUtils.m, 1),\n-            new Token( DurationFormatUtils.s, 1),\n-            new Token( DurationFormatUtils.S, 1)\n+          new DurationFormatUtils.Token[] { \n+            new DurationFormatUtils.Token( DurationFormatUtils.y, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.S, 1)\n           }, DurationFormatUtils.lexx(\"yMdHmsS\") \n         );\n \n         // tests the ISO8601-like\n         assertArrayEquals( \n-          new Token[] { \n-            new Token( DurationFormatUtils.H, 1),\n-            new Token( new StringBuffer(\":\"), 1),\n-            new Token( DurationFormatUtils.m, 2),\n-            new Token( new StringBuffer(\":\"), 1),\n-            new Token( DurationFormatUtils.s, 2),\n-            new Token( new StringBuffer(\".\"), 1),\n-            new Token( DurationFormatUtils.S, 3)\n+          new DurationFormatUtils.Token[] { \n+            new DurationFormatUtils.Token( DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.m, 2),\n+            new DurationFormatUtils.Token( new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.s, 2),\n+            new DurationFormatUtils.Token( new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.S, 3)\n           }, DurationFormatUtils.lexx(\"H:mm:ss.SSS\")\n         );\n \n         // test the iso extended format\n         assertArrayEquals( \n-          new Token[] { \n-            new Token( new StringBuffer(\"P\"), 1),\n-            new Token( DurationFormatUtils.y, 4),\n-            new Token( new StringBuffer(\"Y\"), 1),\n-            new Token( DurationFormatUtils.M, 1),\n-            new Token( new StringBuffer(\"M\"), 1),\n-            new Token( DurationFormatUtils.d, 1),\n-            new Token( new StringBuffer(\"DT\"), 1),\n-            new Token( DurationFormatUtils.H, 1),\n-            new Token( new StringBuffer(\"H\"), 1),\n-            new Token( DurationFormatUtils.m, 1),\n-            new Token( new StringBuffer(\"M\"), 1),\n-            new Token( DurationFormatUtils.s, 1),\n-            new Token( new StringBuffer(\".\"), 1),\n-            new Token( DurationFormatUtils.S, 1),\n-            new Token( new StringBuffer(\"S\"), 1)\n+          new DurationFormatUtils.Token[] { \n+            new DurationFormatUtils.Token( new StringBuffer(\"P\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.y, 4),\n+            new DurationFormatUtils.Token( new StringBuffer(\"Y\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\"DT\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\"H\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token( DurationFormatUtils.S, 1),\n+            new DurationFormatUtils.Token( new StringBuffer(\"S\"), 1)\n           }, \n           DurationFormatUtils.lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)\n         );\n     }\n-    private void assertArrayEquals(Token[] obj1, Token[] obj2) {\n+    private void assertArrayEquals(DurationFormatUtils.Token[] obj1, DurationFormatUtils.Token[] obj2) {\n         assertEquals( \"Arrays are unequal length. \", obj1.length, obj2.length );\n         for(int i=0; i<obj1.length; i++) {\n             assertTrue( \"Index \" + i + \" not equal, \" + obj1[i] + \" vs \" + obj2, obj1[i].equals(obj2[i]));\n         }\n     }\n \n-    \n }", "timestamp": 1097881891, "metainfo": ""}