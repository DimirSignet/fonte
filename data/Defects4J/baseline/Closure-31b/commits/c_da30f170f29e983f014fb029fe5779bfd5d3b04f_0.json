{"sha": "da30f170f29e983f014fb029fe5779bfd5d3b04f", "log": "Fix assorted type system bugs and crashes. Fixes issue 124. (Nick) R=andrew DELTA=161  (122 added, 9 deleted, 30 changed)  Fix unique name inverter  to prevent masking needed global names. (John) R=nick DELTA=315  (225 added, 46 deleted, 44 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n import com.google.common.collect.HashMultiset;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multiset;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  *  Find all Functions, VARs, and Exception names and make them\n class MakeDeclaredNamesUnique\n     implements NodeTraversal.ScopedCallback {\n \n+  public static final String ARGUMENTS = \"arguments\";\n   private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n   private final Renamer rootRenamer;\n \n   /**\n    * Inverts the transformation by {@link ContextualRenamer}, when possible.\n    */\n-  static class ContextualRenameInverter extends AbstractPostOrderCallback\n-      implements CompilerPass {\n+  static class ContextualRenameInverter\n+      implements ScopedCallback, CompilerPass {\n     private final AbstractCompiler compiler;\n \n-    // A mapping from long names to short ones.\n-    private Map<Var, String> nameMap = Maps.newHashMap();\n+    // The set of names referenced in the current scope.\n+    private Set<String> referencedNames = ImmutableSet.of();\n+\n+    // Stack reference sets.\n+    private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>();\n+\n+    // Name are globally unique initially, so we don't need a per-scope map.\n+    private Map<String, List<Node>> nameMap = Maps.newHashMap();\n \n     private ContextualRenameInverter(AbstractCompiler compiler) {\n       this.compiler = compiler;\n       return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);\n     }\n \n-    private static String getOrginalNameInternal(String name, int index) {\n-      return name.substring(0, index);\n-    }\n-\n-    private static String getNameSuffix(String name, int index) {\n-      return name.substring(\n-          index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),\n-          name.length());\n+    private boolean containsSeparator(String name) {\n+      return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;\n+    }\n+\n+    /**\n+     * Prepare a set for the new scope.\n+     */\n+    public void enterScope(NodeTraversal t) {\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      referenceStack.push(referencedNames);\n+      referencedNames = Sets.newHashSet();\n+    }\n+\n+    /**\n+     * Rename vars for the current scope, and merge any referenced \n+     * names into the parent scope reference set.\n+     */\n+    public void exitScope(NodeTraversal t) {\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n+        Var v = it.next();\n+        handleScopeVar(v);\n+      }\n+\n+      // Merge any names that were referenced but not declared in the current\n+      // scope.\n+      Set<String> current = referencedNames;\n+      referencedNames = referenceStack.pop();\n+      // If there isn't anything left in the stack we will be going into the\n+      // global scope: don't try to build a set of referenced names for the\n+      // global scope.\n+      if (!referenceStack.isEmpty()) {\n+        referencedNames.addAll(current);\n+      }\n+    }\n+\n+    /**\n+     * For the Var declared in the current scope determine if it is possible\n+     * to revert the name to its orginal form without conflicting with other\n+     * values.\n+     */\n+    void handleScopeVar(Var v) {\n+      String name  = v.getName();\n+      if (containsSeparator(name)) {\n+        String newName = getOrginalName(name);\n+        // Check if the new name is valid and if it would cause conflicts.\n+        if (TokenStream.isJSIdentifier(newName) &&\n+            !referencedNames.contains(newName) && \n+            !newName.equals(ARGUMENTS)) {\n+          referencedNames.remove(name);\n+          // Adding a reference to the new name to prevent either the parent\n+          // scopes or the current scope renaming another var to this new name.\n+          referencedNames.add(newName);\n+          List<Node> references = nameMap.get(name);\n+          Preconditions.checkState(references != null);\n+          for (Node n : references) {\n+            Preconditions.checkState(n.getType() == Token.NAME);\n+            n.setString(newName);\n+          }\n+          compiler.reportCodeChange();\n+        }\n+        nameMap.remove(name);\n+      }\n+    }\n+\n+    @Override\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      return true;\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node node, Node parent) {\n-      if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (oldName.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1) {\n-          Scope scope = t.getScope();\n-          Var var = t.getScope().getVar(oldName);\n-          if (var == null || var.isGlobal()) {\n-            return;\n-          }\n-\n-          if (nameMap.containsKey(var)) {\n-            node.setString(nameMap.get(var));\n-          } else {\n-            int index = indexOfSeparator(oldName);\n-            String newName = getOrginalNameInternal(oldName, index);\n-            String suffix = getNameSuffix(oldName, index);\n-\n-            // The convention we are using here is that names of the form:\n-            //    a$$1  ($$ followed by a digit are allowed to mask a global)\n-            //    a$$inline_1 ($$ followed by anything that isn't a digit isn't\n-            //       allowed to mask a global.\n-            // This preserves existing behavior while allowing simpler diffs\n-            // when inlining is enabled.\n-            // TODO(johnlenz): Remove this distiction when scoping is properly\n-            // checked.\n-            boolean recurseScopes = false;\n-            if (!suffix.matches(\"\\\\d+\")) {\n-              // Non-contextual renamed value.\n-              recurseScopes = true;\n-            }\n-\n-            // Before we change the name of this variable, double-check to\n-            // make sure we're not declaring a duplicate name in the\n-            // same scope as the var declaration.\n-            // TODO(johnlenz): This test isn't sufficient; specifically,\n-            // a reference to a global may have been introduced. Shortening\n-            // the name without checking for such a reference may mask the\n-            // global causing the wrong value to be referenced.\n-            if (var.scope.isDeclared(newName, recurseScopes) ||\n-                !TokenStream.isJSIdentifier(newName)) {\n-              newName = oldName;\n-            } else {\n-              var.scope.declare(newName, var.nameNode, null, null);\n-\n-              // Handle bleeding functions.\n-              Node parentNode = var.getParentNode();\n-              if (parentNode.getType() == Token.FUNCTION &&\n-                  parentNode == var.scope.getRootNode()) {\n-                var.getNameNode().setString(newName);\n-              }\n-\n-              node.setString(newName);\n-              compiler.reportCodeChange();\n-            }\n-\n-            nameMap.put(var, newName);\n-          }\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      if (NodeUtil.isReferenceName(node)) {\n+        String name = node.getString();\n+        // Add all referenced names to the set so it is possible to check for\n+        // conflicts.\n+        referencedNames.add(name);\n+        // Store only references to candidate names in the node map.\n+        if (containsSeparator(name)) {\n+          addCandidateNameReference(name, node);\n         }\n       }\n+    }\n+\n+    private void addCandidateNameReference(String name, Node n) {\n+      List<Node> nodes = nameMap.get(name);\n+      if (null == nodes) {\n+        nodes = Lists.newLinkedList();\n+        nameMap.put(name, nodes);\n+      }\n+      nodes.add(n);\n     }\n   }\n \n      */\n     @Override\n     public void addDeclaredName(String name) {\n-      if (global) {\n-        reserveName(name);\n-      } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-          int id = incrementNameCount(name);\n-          String newName = null;\n-          if (id != 0) {\n-            newName = getUniqueName(name, id);\n+      if (!name.equals(ARGUMENTS)) {\n+        if (global) {\n+          reserveName(name);\n+        } else {\n+          // It hasn't been declared locally yet, so increment the count.\n+          if (!declarations.containsKey(name)) {\n+            int id = incrementNameCount(name);\n+            String newName = null;\n+            if (id != 0) {\n+              newName = getUniqueName(name, id);\n+            }\n+            declarations.put(name, newName);\n           }\n-          declarations.put(name, newName);\n         }\n       }\n     }\n \n     @Override\n     public void addDeclaredName(String name) {\n+      Preconditions.checkState(!name.equals(ARGUMENTS));\n       if (!declarations.containsKey(name)) {\n         declarations.put(name, getUniqueName(name));\n       }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     return n.getType() == Token.CASE || n.getType() == Token.DEFAULT;\n   }\n \n+  /**\n+   * @return Whether the name is a reference to a variable, function or\n+   *       function parameter (not a label or a empty anonymous function name).\n+   */\n+  static boolean isReferenceName(Node n) {\n+    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);\n+  }\n+\n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\n     if (n != null && n.getType() == Token.NAME) {\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root,\n         new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function \n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes. \n+    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n     testSameWithInversion(\"\", original);\n   }\n \n-  public void testMakeLocalNamesUniqueWithContext0() {\n-    // Set the test type\n-    this.useDefaultRenamer = true;\n-\n-    // Local names are made unique.\n+  private String wrapInFunction(String s) {\n+    return \"function f(){\" + s + \"}\";\n+  }\n+  \n+  public void testInFunction(String original, String expected) {\n+    test(wrapInFunction(original), wrapInFunction(expected));\n+  }\n+  \n+  public void testSameInFunction(String original) {\n+    testSame(wrapInFunction(original));\n+  }  \n+  \n+  public void testMakeLocalNamesUniqueWithContext1() {\n+    // Set the test type\n+    this.useDefaultRenamer = true;\n+\n     invert = true;\n     test(\n         \"var a;function foo(){var a$$inline_1; a = 1}\",\n         \"var a;function foo(){var a$$inline_1; a = 1}\");\n-  }\n-\n-  public void testMakeLocalNamesUniqueWithContext() {\n+    test(\n+        \"var a;function foo(){var a$$inline_1;}\",\n+        \"var a;function foo(){var a;}\");\n+  }\n+\n+  public void testMakeLocalNamesUniqueWithContext2() {\n     // Set the test type\n     this.useDefaultRenamer = true;\n \n         \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n   }\n \n-  public void testMakeLocalNamesUniqueWithContext2() {\n+  public void testMakeLocalNamesUniqueWithContext3() {\n     // Set the test type\n     this.useDefaultRenamer = true;\n \n \n     // Verify global names are untouched.\n     testSame(externs, \"var extern1 = extern1 || {};\", null);\n+  }\n+\n+\n+\n+  public void testMakeLocalNamesUniqueWithContext4() {\n+    // Set the test type\n+    this.useDefaultRenamer = true;\n+\n+    // Inversion does not handle exceptions correctly.\n+    testInFunction(\n+        \"var e; try { } catch(e) {e;}; try { } catch(e) {e;}\",\n+        \"var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}\");\n+    testInFunction(\n+        \"var e; try { } catch(e) {e; try { } catch(e) {e;}}\",\n+        \"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} }\");\n+    testInFunction(\n+        \"try { } catch(e) {e;}; try { } catch(e) {e;} var e;\",\n+        \"try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;} var e;\");\n+    testInFunction(\n+        \"try { } catch(e) {e; try { } catch(e) {e;}} var e;\",\n+        \"try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} } var e;\");\n+\n+    invert = true;\n+\n+    testSameInFunction(\n+        \"var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}\");\n+    testSameInFunction(\n+        \"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };\");\n+    testSameInFunction(\n+        \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;\");\n+    testSameInFunction(\n+        \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2\");\n+  }\n+\n+  public void testArguments() {\n+    // Set the test type\n+    this.useDefaultRenamer = true;\n+\n+    invert = true;\n+    // Don't distinguish between \"arguments\", it can't be made unique.\n+    testSameWithInversion(\n+        \"function foo(){var arguments;function bar(){var arguments;}}\");\n+    // Don't introduce new references to arguments, it is special.\n+    testSameWithInversion(\n+        \"function foo(){var arguments$$1;}\");\n   }\n \n   public void testMakeLocalNamesUniqueWithoutContext() {\n          \"function() {var CONST = 3; var ACONST = 2;}\");\n   }\n \n+  public void testOnlyInversion2() {\n+    invert = true;\n+    testSame(\"function () {\" +\n+        \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}\");\n+  }\n+\n+  public void testOnlyInversion3() {\n+    invert = true;\n+    test(\n+        \"function x1() {\" +\n+        \"  var a$$1;\" +\n+        \"  function x2() {\" +\n+        \"    var a$$2;\" +\n+        \"  }\" +\n+        \"  function x3() {\" +\n+        \"    var a$$3;\" +\n+        \"  }\" +\n+        \"}\",\n+        \"function x1() {\" +\n+        \"  var a$$1;\" +\n+        \"  function x2() {\" +\n+        \"    var a;\" +\n+        \"  }\" +\n+        \"  function x3() {\" +\n+        \"    var a;\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n+  public void testOnlyInversion4() {\n+    invert = true;\n+    test(\n+        \"function x1() {\" +\n+        \"  var a$$1;\" +\n+        \"  function x2() {\" +\n+        \"    var a;a$$1++\" +\n+        \"  }\" +\n+        \"}\",\n+        \"function x1() {\" +\n+        \"  var a$$1;\" +\n+        \"  function x2() {\" +\n+        \"    var a;a$$1++\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n   public void testConstRemovingRename1() {\n     removeConst = true;\n     test(\"function() {var CONST = 3; var ACONST$$1 = 2;}\",\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"function f() {var window$$1}\");\n   }\n \n-  public void testRemoveDuplicateVarDeclarations() {\n+  public void testRemoveDuplicateVarDeclarations1() {\n     test(\"function f() { var a; var a }\",\n          \"function f() { var a; }\");\n     test(\"function f() { var a = 1; var a = 2 }\",\n          \"function f() { var a = 1; for(a in b); }\");\n   }\n \n+  public void testRemoveDuplicateVarDeclarations2() {\n+    test(\"var e = 1; function f(){ try {} catch (e) {} var e = 2 }\",\n+         \"var e = 1; function f(){ try {} catch (e$$2) {} var e$$1 = 2 }\");\n+  }\n+  \n   public void testRenamingConstants() {\n     test(\"var ACONST = 4;var b = ACONST;\",\n          \"var ACONST = 4; var b = ACONST;\");", "timestamp": 1268952663, "metainfo": ""}