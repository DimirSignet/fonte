{"sha": "6fcb0080b198186d44552a5996ed81c3aa4a04f8", "log": "inline a method from common libraries.  Add some debugging tools for AmbiguateProperties.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Join;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.TypeValidator.TypeMismatch;\n import com.google.javascript.jscomp.graph.AdjacencyGraph;\n import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.SubGraph;\n-import com.google.javascript.jscomp.graph.GraphColoring;\n-import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import java.util.Set;\n import java.util.TreeSet;\n import java.util.logging.Logger;\n-\n \n /**\n  * Renames unrelated properties to the same name, using type information.\n       };\n \n   /** A map from JSType to a unique representative Integer. */\n-  private Map<JSType, Integer> intForType = Maps.newHashMap();\n-\n-  /** A map from JSType to BitSet representing the types related to the type. */\n-  private Map<JSType, BitSet> relatedBitsets = Maps.newHashMap();\n+  private BiMap<JSType, Integer> intForType = HashBiMap.create();\n+\n+  /**\n+   * A map from JSType to JSTypeBitSet representing the types related\n+   * to the type.\n+   */\n+  private Map<JSType, JSTypeBitSet> relatedBitsets = Maps.newHashMap();\n \n   /** A set of types that invalidate properties from ambiguation. */\n   private final Set<JSType> invalidatingTypes;\n                 + numSkippedPropertyNames + \" properties.\");\n   }\n \n-  /** Add supertypes of the type to its BitSet of related types. */\n+  /** Add supertypes of the type to its JSTypeBitSet of related types. */\n   private void computeRelatedTypes(JSType type) {\n     if (type instanceof UnionType) {\n       type = type.restrictByNotNullOrUndefined();\n       }\n     }\n \n-    BitSet related = relatedBitsets.get(type);\n-    if (related == null) {\n-      related = new BitSet(intForType.size());\n-      relatedBitsets.put(type, related);\n-    }\n+    if (relatedBitsets.containsKey(type)) {\n+      // We only need to generate the bit set once.\n+      return;\n+    }\n+\n+    JSTypeBitSet related = new JSTypeBitSet(intForType.size());\n+    relatedBitsets.put(type, related);\n \n     ObjectType parentType = type.toObjectType();\n     while (parentType != null) {\n    */\n   class PropertySubGraph implements SubGraph<Property, Void> {\n     /** Types from which properties in this subgraph are referenced. */\n-    BitSet typesInSet = new BitSet(intForType.size());\n+    JSTypeBitSet typesInSet = new JSTypeBitSet(intForType.size());\n \n     /** Types related to types in {@code typesInSet}. */\n-    BitSet typesRelatedToSet = new BitSet(intForType.size());\n+    JSTypeBitSet typesRelatedToSet = new JSTypeBitSet(intForType.size());\n \n     /**\n      * Returns true if prop is in an independent set from all properties in\n      * Finds all types related to the provided type and returns a BitSet with\n      * their bits to true.\n      */\n-    private BitSet getRelated(JSType type) {\n-      BitSet relatedTypes = new BitSet(intForType.size());\n+    private JSTypeBitSet getRelated(JSType type) {\n+      JSTypeBitSet relatedTypes = new JSTypeBitSet(intForType.size());\n       if (type instanceof UnionType) {\n         for (JSType alt : ((UnionType) type).getAlternates()) {\n           getRelatedTypesOnNonUnion(alt, relatedTypes);\n      * Finds all types related to the provided type and returns a BitSet with\n      * their bits to true.  Expects a non-union type.\n      */\n-    private void getRelatedTypesOnNonUnion(JSType type, BitSet relatedTypes) {\n+    private void getRelatedTypesOnNonUnion(\n+        JSType type, JSTypeBitSet relatedTypes) {\n       // All of the types we encounter should have been added to the\n       // relatedBitsets via computeRelatedTypes.\n       if (relatedBitsets.containsKey(type)) {\n     String newName;\n     int numOccurrences;\n     boolean skipAmbiguating;\n-    BitSet typesSet = new BitSet(intForType.size());\n+    JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size());\n \n     Property(String name) {\n       this.oldName = name;\n       if (type == null) {\n         type = newType;\n       } else {\n+        // TODO(nicksantos): This line doesn't make sense. It only works if\n+        // we assume that the type hierarchy is a tree (and thus has a\n+        // single root). It doesn't work with an arbitrary lattice.\n+        //\n+        // Consider a class Chimay that extends Beer and implements Expensive.\n+        // supremum(Chimay, Expensive) == Expensive\n+        // according to the lattice's supremum op (getLeastSupertype).\n+        //\n+        // And since related types are computed from this result, this\n+        // means that we will treat Beer as unrelated to Chimay, which is\n+        // clearly not correct.\n         type = type.getLeastSupertype(newType);\n       }\n \n       typesSet.set(getIntForType(newType));\n     }\n   }\n+\n+  // A BitSet that stores type info. Adds pretty-print routines.\n+  private class JSTypeBitSet extends BitSet {\n+\n+    private JSTypeBitSet(int size) {\n+      super(size);\n+    }\n+\n+    private JSTypeBitSet() {\n+      super();\n+    }\n+\n+    /**\n+     * Pretty-printing, for diagnostic purposes.\n+     */\n+    @Override\n+    public String toString() {\n+      int from = 0;\n+      int current = 0;\n+      List<String> types = Lists.newArrayList();\n+      while (-1 != (current = nextSetBit(from))) {\n+        types.add(intForType.inverse().get(current).toString());\n+        from = current + 1;\n+      }\n+      return Join.join(\" && \", types);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.StringUtil;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n \n+import java.io.IOException;\n import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n \n *\n  */\n class CodeGenerator {\n+  \n+  private static final char[] HEX_CHARS\n+      = { '0', '1', '2', '3', '4', '5', '6', '7',\n+          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n \n   private final CodeConsumer cc;\n \n               sb.append(c);\n             } else {\n               // Unicode-escape the character.\n-              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+              appendHexJavaScriptRepresentation(sb, c);\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n-              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+              appendHexJavaScriptRepresentation(sb, c);\n             }\n           }\n       }\n       if (c > 0x1F && c < 0x7F) {\n         sb.append(c);\n       } else {\n-        StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+        appendHexJavaScriptRepresentation(sb, c);\n       }\n     }\n     return sb.toString();\n     return (context == Context.IN_FOR_INIT_CLAUSE\n         ? Context.OTHER : context);\n   }\n+\n+  /**\n+   * @see #appendHexJavaScriptRepresentation(int, Appendable)\n+   */\n+  private static void appendHexJavaScriptRepresentation(\n+      StringBuilder sb, char c) {\n+    try {\n+      appendHexJavaScriptRepresentation(c, sb);\n+    } catch (IOException ex) {\n+      // StringBuilder does not throw IOException.\n+      throw new RuntimeException(ex);\n+    }\n+  }\n+\n+  /**\n+   * Returns a javascript representation of the character in a hex escaped\n+   * format.\n+   *\n+   * @param codePoint The codepoint to append.\n+   * @param out The buffer to which the hex representation should be appended.\n+   */\n+  private static void appendHexJavaScriptRepresentation(\n+      int codePoint, Appendable out)\n+      throws IOException {\n+    if (Character.isSupplementaryCodePoint(codePoint)) {\n+      // Handle supplementary unicode values which are not representable in\n+      // javascript.  We deal with these by escaping them as two 4B sequences\n+      // so that they will round-trip properly when sent from java to javascript\n+      // and back.\n+      char[] surrogates = Character.toChars(codePoint);\n+      appendHexJavaScriptRepresentation(surrogates[0], out);\n+      appendHexJavaScriptRepresentation(surrogates[1], out);\n+      return;\n+    }\n+    out.append(\"\\\\u\")\n+        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n+        .append(HEX_CHARS[codePoint & 0xf]);\n+  }\n }", "timestamp": 1262749483, "metainfo": ""}