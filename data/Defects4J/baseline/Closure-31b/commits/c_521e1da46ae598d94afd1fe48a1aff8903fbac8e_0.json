{"sha": "521e1da46ae598d94afd1fe48a1aff8903fbac8e", "log": "Add FieldCleanupPass Implementatation and supporting class changes.  R=nicksantos,bashir DELTA=280  (219 added, 57 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2916   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FieldCleanupPass.java\n+++ b/src/com/google/javascript/jscomp/FieldCleanupPass.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n \n /**\n  * A CleanupPass implementation that will remove all field declarations on\n  */\n public class FieldCleanupPass implements HotSwapCompilerPass {\n \n+  private final AbstractCompiler compiler;\n+\n   public FieldCleanupPass(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n   }\n \n   @Override\n   public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+    String srcName = originalRoot.getSourceFileName();\n+    Callback cb =\n+        new QualifiedNameSearchTraversal(compiler.getTypeRegistry(), srcName);\n+    new NodeTraversal(compiler, cb).traverse(originalRoot);\n   }\n \n   @Override\n     // FieldCleanupPass should not do work during process.\n   }\n \n+  /**\n+   * Search for fields to cleanup by looking for nodes in the tree which are\n+   * root nodes of qualified names and getting the final token of the qualified\n+   * name as a candidate field.\n+   * <p>\n+   * Once a candidate field is found, ask the {@code JSTypeRegistry} for all\n+   * JSTypes that have a field with the same name, and check if the field on\n+   * that type is defined in the file the compiler is cleaning up. If so, remove\n+   * the field, and update the {@code JSTypeRegistry} to no longer associate the\n+   * type with the field.\n+   * <p>\n+   * This algorithm was chosen for simplicity and is less than optimally\n+   * efficient in two ways:\n+   * <p>\n+   * 1) All types with a matching field name are iterated over (when only types\n+   * that extend or implement the JSType indicated by the containing object in\n+   * the found Qualified Name need to be checked).\n+   * <p>\n+   * 2) All Qualified Names are checked, even those which are not L-Values or\n+   * single declarations of an Type Expression. In general field should only be\n+   * declared as part of an assignment ('ns.Type.a = 3;') or stand alone name\n+   * declaration ('ns.Type.a;').\n+   */\n+  static class QualifiedNameSearchTraversal extends AbstractShallowCallback {\n+\n+    private final JSTypeRegistry typeRegistry;\n+    private final String srcName;\n+\n+    public QualifiedNameSearchTraversal(\n+        JSTypeRegistry typeRegistry, String srcName) {\n+      this.typeRegistry = typeRegistry;\n+      this.srcName = srcName;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node p) {\n+      // We are a root GetProp\n+      if (NodeUtil.isGetProp(n) && !NodeUtil.isGetProp(p)) {\n+        String propName = getFieldName(n);\n+        Iterable<ObjectType> types =\n+            typeRegistry.getEachReferenceTypeWithProperty(propName);\n+        for (ObjectType type : types) {\n+          Node pNode = type.getPropertyNode(propName);\n+          if (srcName.equals(pNode.getSourceFileName())) {\n+            typeRegistry.unregisterPropertyOnType(propName, type);\n+            type.removeProperty(propName);\n+          }\n+        }\n+      }\n+    }\n+\n+    private String getFieldName(Node n) {\n+      return n.getLastChild().getString();\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   }\n \n   /**\n+   * Removes the index's reference to a property on the given type (if it is\n+   * currently registered). If the property is not registered on the type yet,\n+   * this method will not change internal state.\n+   *\n+   * @param propertyName the name of the property to unregister\n+   * @param type the type to unregister the property on.\n+   */\n+  public void unregisterPropertyOnType(String propertyName, JSType type) {\n+    Map<String, ObjectType> typeSet =\n+        eachRefTypeIndexedByProperty.get(propertyName);\n+    if (typeSet != null) {\n+      typeSet.remove(type.toObjectType().getReferenceName());\n+    }\n+  }\n+\n+  /**\n    * Gets the greatest subtype of the {@code type} that has a property\n    * {@code propertyName} defined on it.\n    */\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n+  public boolean removeProperty(String name) {\n+    return false;\n+  }\n+\n+  @Override\n   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n     return null;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    * @return true if the property was removed successfully. False if the\n    *         property did not exist, or could not be removed.\n    */\n-  boolean removeProperty(String propertyName) {\n+  public boolean removeProperty(String propertyName) {\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   @Override\n+  public boolean removeProperty(String name) {\n+    return properties.remove(name) != null;\n+  }\n+\n+  @Override\n   public Node getPropertyNode(String propertyName) {\n     Property p = properties.get(propertyName);\n     if (p != null) {\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n+  public boolean removeProperty(String name) {\n+    return referencedObjType == null ? false :\n+        referencedObjType.removeProperty(name);\n+  }\n+\n+  @Override\n   public boolean isPropertyTypeDeclared(String propertyName) {\n     return referencedObjType == null ? false :\n         referencedObjType.isPropertyTypeDeclared(propertyName);", "timestamp": 1312556376, "metainfo": ""}