{"sha": "a2f9d4f043be0fac4d868061fbc5d088ed31823b", "log": "Make debugging function inlining issues a little bit easier. (John) R=alan DELTA=3  (2 added, 0 deleted, 1 changed)  Pretty-print anonymous object types, so that it's easier to see what's in them. (Nick) R=alan  Add externs for new methods of HTML5 History class. (Naoki) R=alan DELTA=19  (19 added, 0 deleted, 0 changed)   Handle classes that have been renamed by the normalizer pass by reading the NAME from the AST instead of just using the reference name. (Andrew) R=nada DELTA=50  (33 added, 1 deleted, 16 changed)  Fix runtime type check to check the global this object instead of window since not all javascript will have a DOM. (Andrew) R=nada DELTA=21  (19 added, 0 deleted, 2 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=rvhacw   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (parent != null && parent.getType() == Token.SCRIPT &&\n           n.getType() == Token.FUNCTION) {\n-        String functionName = NodeUtil.getFunctionName(n, parent);\n+        String functionName = NodeUtil.getFunctionName(n);\n         if (isTestFunction(n, functionName) && t.inGlobalScope()) {\n           exportTestFunction(functionName, n, parent);\n         }\n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n       switch (n.getType()) {\n         case Token.FUNCTION:\n           if (parent.getType() == Token.SCRIPT) {\n-            export = NodeUtil.getFunctionName(n, parent);\n+            export = NodeUtil.getFunctionName(n);\n             context = new GenerateNodeContext(n, parent, n);\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n   void verifyAllReferencesInlined(FunctionState fs) {\n     for (Reference ref : fs.getReferences()) {\n       if (!ref.inlined) {\n-        throw new IllegalStateException(\"Call site missed.\");\n+        throw new IllegalStateException(\"Call site missed.\\n call: \"\n+            + ref.callNode.toStringTree() + \"\\n parent:  \" \n+            + ref.callNode.getParent().toStringTree());\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n         // TODO(user): A global function foo() is treated as the same\n         // function as a inner function named foo(). We should use some clever\n         // naming scheme to avoid this lost of precision.\n-        String name = NodeUtil.getFunctionName(root, parent);\n+        String name = NodeUtil.getFunctionName(root);\n \n         if (name == null) {\n           // When the name is null, we have a function that is presumably not\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * returned (the variable of qualified name).\n    *\n    * @param n a node whose type is {@link Token#FUNCTION}\n-   * @param parent {@code n}'s parent (never {@code null})\n    * @return the function's name, or {@code null} if it has no name\n    */\n-  static String getFunctionName(Node n, Node parent) {\n+  static String getFunctionName(Node n) {\n+    Node parent = n.getParent();\n     String name = n.getFirstChild().getString();\n     switch (parent.getType()) {\n       case Token.NAME:\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n             Node nodeToInsertAfter,\n             @Nullable ObjectType interfaceType) {\n \n-      String className = funType.getInstanceType().getReferenceName();\n+      if (funType.getSource() == null) {\n+        return nodeToInsertAfter;\n+      }\n+\n+      String className = NodeUtil.getFunctionName(funType.getSource());\n \n       // This can happen with anonymous classes declared with the type\n       // {@code Function}.\n     String boilerplateCode = getBoilerplateCode(logFunction);\n \n     Node js = compiler.parseSyntheticCode(boilerplateCode);\n+    NodeTraversal.traverse(compiler, js,\n+        new Normalize.NormalizeStatements(compiler, false));\n \n     compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n         js.removeChildren());\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n         if (diff != null) {\n           return \"Node tree inequality:\" +\n               \"\\nTree1:\\n\" + toStringTree() +\n-              \"\\n\\nTree2:\\n\" + node2.toStringTree();\n+              \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n+              \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n+              \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n         }\n         return null;\n     }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  protected void collectPropertyNames(Set<String> props) {\n+  void collectPropertyNames(Set<String> props) {\n     if (primitiveObjectType != null) {\n       primitiveObjectType.collectPropertyNames(props);\n     }\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n   @Override\n   public String toString() {\n-    return constructor.getReferenceName();\n+    if (constructor.hasReferenceName()) {\n+      return constructor.getReferenceName();\n+    } else {\n+      return super.toString();\n+    }\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n    * Create an anonymous object type.\n    */\n   public ObjectType createAnonymousObjectType() {\n-    return createObjectType(null, null, null);\n+    PrototypeObjectType type =\n+        new PrototypeObjectType(this, null, null);\n+    type.setPrettyPrint(true);\n+    return type;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n import static com.google.common.base.Preconditions.checkState;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n   private final Map<String, Property> properties;\n   private ObjectType implicitPrototype;\n   private final boolean nativeType;\n+\n+  // Whether the toString representation of this should be pretty-printed,\n+  // by printing all properties.\n+  private boolean prettyPrint = false;\n+\n+  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n \n   /**\n    * Creates an object type.\n   }\n \n   @Override\n-  protected void collectPropertyNames(Set<String> props) {\n+  void collectPropertyNames(Set<String> props) {\n     for (String prop : properties.keySet()) {\n       props.add(prop);\n     }\n \n   @Override\n   public String toString() {\n-    return getReferenceName();\n+    if (hasReferenceName()) {\n+      return getReferenceName();\n+    } else if (prettyPrint) {\n+      // Use a tree set so that the properties are sorted.\n+      Set<String> propertyNames = Sets.newTreeSet();\n+      for (ObjectType current = this;\n+           current != null && !current.isNativeObjectType() &&\n+               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n+           current = current.getImplicitPrototype()) {\n+        propertyNames.addAll(current.getOwnPropertyNames());\n+      }\n+\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+\n+      int i = 0;\n+      for (String property : propertyNames) {\n+        if (i > 0) {\n+          sb.append(\", \");\n+        }\n+\n+        sb.append(property);\n+        sb.append(\": \");\n+        sb.append(getPropertyType(property).toString());\n+\n+        ++i;\n+        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n+          sb.append(\", ...\");\n+          break;\n+        }\n+      }\n+\n+      sb.append(\"}\");\n+      return sb.toString();\n+    } else {\n+      return \"{...}\";\n+    }\n+  }\n+\n+  void setPrettyPrint(boolean prettyPrint) {\n+    this.prettyPrint = prettyPrint;\n   }\n \n   @Override\n     if (className != null) {\n       return className;\n     } else {\n-      return \"{...}\";\n+      return null;\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n   }\n \n   @Override\n-  protected void collectPropertyNames(Set<String> props) {\n+  void collectPropertyNames(Set<String> props) {\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     Compiler compiler = new Compiler();\n     Node parent = compiler.parseTestCode(\"function name(){}\");\n \n-    testGetFunctionName(parent.getFirstChild(), parent, \"name\");\n+    testGetFunctionName(parent.getFirstChild(), \"name\");\n   }\n \n   public void testGetFunctionName2() throws Exception {\n     Node parent = compiler.parseTestCode(\"var name = function(){}\")\n         .getFirstChild().getFirstChild();\n \n-    testGetFunctionName(parent.getFirstChild(), parent, \"name\");\n+    testGetFunctionName(parent.getFirstChild(), \"name\");\n   }\n \n   public void testGetFunctionName3() throws Exception {\n     Node parent = compiler.parseTestCode(\"qualified.name = function(){}\")\n         .getFirstChild().getFirstChild();\n \n-    testGetFunctionName(parent.getLastChild(), parent, \"qualified.name\");\n+    testGetFunctionName(parent.getLastChild(), \"qualified.name\");\n   }\n \n   public void testGetFunctionName4() throws Exception {\n     Node parent = compiler.parseTestCode(\"var name2 = function name1(){}\")\n         .getFirstChild().getFirstChild();\n \n-    testGetFunctionName(parent.getFirstChild(), parent, \"name2\");\n+    testGetFunctionName(parent.getFirstChild(), \"name2\");\n   }\n \n   public void testGetFunctionName5() throws Exception {\n     Node n = compiler.parseTestCode(\"qualified.name2 = function name1(){}\");\n     Node parent = n.getFirstChild().getFirstChild();\n \n-    testGetFunctionName(parent.getLastChild(), parent, \"qualified.name2\");\n-  }\n-\n-  private void testGetFunctionName(Node function, Node parent, String name) {\n+    testGetFunctionName(parent.getLastChild(), \"qualified.name2\");\n+  }\n+\n+  private void testGetFunctionName(Node function, String name) {\n     assertEquals(Token.FUNCTION, function.getType());\n-    assertEquals(name, NodeUtil.getFunctionName(function, parent));\n+    assertEquals(name, NodeUtil.getFunctionName(function));\n   }\n \n   public void testContainsFunctionDeclaration() {\n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n  */\n \n package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n \n /**\n  * Tests for {@link RuntimeTypeCheck}.\n         \"}\");\n   }\n \n+  public void testInnerClasses() {\n+    enableNormalize(false);\n+    testChecks(\n+        \"function f() { /** @constructor */ function inner() {} }\" +\n+        \"function g() { /** @constructor */ function inner() {} }\",\n+        \"function f() {\" +\n+        \"  /** @constructor */ function inner() {}\" +\n+        \"  inner.prototype['instance_of__inner'] = true;\" +\n+        \"}\" +\n+        \"function g() {\" +\n+        \"  /** @constructor */ function inner$$1() {}\" +\n+        \"  inner$$1.prototype['instance_of__inner$$1'] = true;\" +\n+        \"}\");\n+  }\n+\n   public void testInterface() {\n     testChecks(\"/** @interface */function I() {}\" +\n         \"/** @param {!I} i */function f(i) {}\",\n \n   private void testChecks(String js, String expected) {\n     String boilerplateCode = RuntimeTypeCheck.getBoilerplateCode(null);\n-    test(js, boilerplateCode + expected);\n+    Compiler compiler = new Compiler();\n+    compiler.init(new JSSourceFile[0], new JSSourceFile[0],\n+        new CompilerOptions());\n+    Node ast = compiler.parseSyntheticCode(boilerplateCode + expected);\n+    NodeTraversal.traverse(compiler, ast,\n+        new Normalize.NormalizeStatements(compiler, false));\n+\n+    test(js, compiler.toSource(ast));\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     testTypes(\"/** @return {number} */\" +\n         \"function f() { var x = x || {}; return x; }\",\n         \"inconsistent return type\\n\" +\n-        \"found   : {...}\\n\" +\n+        \"found   : {}\\n\" +\n         \"required: number\");\n   }\n \n   public void testBitOperation9() throws Exception {\n     testTypes(\"var x = void 0; x |= {};\",\n         \"bad right operand to bitwise operator\\n\" +\n-        \"found   : {...}\\n\" +\n+        \"found   : {}\\n\" +\n         \"required: (boolean|null|number|string|undefined)\");\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     // anonymous\n     ObjectType anonymous = registry.createAnonymousObjectType();\n     assertEquals(OBJECT_TYPE, anonymous.getImplicitPrototype());\n-    assertEquals(\"{...}\", anonymous.getReferenceName());\n+    assertNull(anonymous.getReferenceName());\n+    assertEquals(\"{}\", anonymous.toString());\n+  }\n+\n+  /**\n+   * Tests the factory method\n+   * {@link JSTypeRegistry#createAnonymousObjectType()}} and adds\n+   * some properties to it.\n+   */\n+  public void testCreateAnonymousObjectType2() throws Exception {\n+    // anonymous\n+    ObjectType anonymous = registry.createAnonymousObjectType();\n+    anonymous.defineDeclaredProperty(\n+        \"a\", NUMBER_TYPE, false);\n+    anonymous.defineDeclaredProperty(\n+        \"b\", NUMBER_TYPE, false);\n+    anonymous.defineDeclaredProperty(\n+        \"c\", NUMBER_TYPE, false);\n+    anonymous.defineDeclaredProperty(\n+        \"d\", NUMBER_TYPE, false);\n+    anonymous.defineDeclaredProperty(\n+        \"e\", NUMBER_TYPE, false);\n+    anonymous.defineDeclaredProperty(\n+        \"f\", NUMBER_TYPE, false);\n+    assertEquals(\"{a: number, b: number, c: number, d: number, ...}\",\n+        anonymous.toString());\n   }\n \n   /**\n         registry.createObjectType(DATE_TYPE.getImplicitPrototype());\n     assertEquals(DATE_TYPE.getImplicitPrototype(),\n         subDate.getImplicitPrototype());\n-    assertEquals(\"{...}\", subDate.getReferenceName());\n+    assertNull(subDate.getReferenceName());\n+    assertEquals(\"{...}\", subDate.toString());\n \n     // name, node, prototype\n     ObjectType subError = registry.createObjectType(\"Foo\", null,", "timestamp": 1270136046, "metainfo": ""}