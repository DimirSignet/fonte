{"sha": "938f48a60c544f6b7bdb5d49006f654a51ca9a22", "log": "The MethodCompilerPass was being a little too smart for itself, leading to incorrect behavior by the InlineGetter pass (inlining extern definitions of functions which it thought were empty functions). This results in slight worse behavior by the depreciated \"MethodCheck\" pass, but most projects have moved on to \"check_types\" which is on by default. (John) R=Alan DELTA=77  (44 added, 28 deleted, 5 changed)  Issue 103: Fix inappropriate renaming of local \"$super\" when the coding convention declares it to be \"exported\". (John) Fixes issue 103. R=Alan DELTA=86  (77 added, 3 deleted, 6 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n       NodeTraversal.traverse(compiler, js, this);\n     }\n \n+    public static String getOrginalName(String name) {\n+      int index = indexOfSeparator(name);\n+      return (index == -1) ? name : name.substring(0, index);\n+    }\n+\n+    private static int indexOfSeparator(String name) {\n+      return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR);\n+    }\n+\n+    private static String getOrginalNameInternal(String name, int index) {\n+      return name.substring(0, index);\n+    }\n+\n+    private static String getNameSuffix(String name, int index) {\n+      return name.substring(\n+          index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),\n+          name.length());\n+    }\n+\n     @Override\n     public void visit(NodeTraversal t, Node node, Node parent) {\n       if (node.getType() == Token.NAME) {\n           if (nameMap.containsKey(var)) {\n             node.setString(nameMap.get(var));\n           } else {\n-            String newName = oldName.substring(\n-                0, oldName.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR));\n-            String suffix = oldName.substring(\n-                oldName.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR)\n-                    + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),\n-                oldName.length());\n-            \n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+\n             // The convention we are using here is that names of the form:\n             //    a$$1  ($$ followed by a digit are allowed to mask a global)\n-            //    a$$inline_1 ($$ followed by anything that isn't a digit isn't \n+            //    a$$inline_1 ($$ followed by anything that isn't a digit isn't\n             //       allowed to mask a global.\n             // This preserves existing behavior while allowing simpler diffs\n             // when inlining is enabled.\n               // Non-contextual renamed value.\n               recurseScopes = true;\n             }\n-            \n+\n             // Before we change the name of this variable, double-check to\n             // make sure we're not declaring a duplicate name in the\n             // same scope as the var declaration.\n             // TODO(johnlenz): This test isn't sufficient; specifically,\n-            // a reference to a global may have been introduced. Shortening \n+            // a reference to a global may have been introduced. Shortening\n             // the name without checking for such a reference may mask the\n             // global causing the wrong value to be referenced.\n             if (var.scope.isDeclared(newName, recurseScopes) ||\n         String idPrefix,\n         boolean removeConstness) {\n       this.uniqueIdSupplier = uniqueIdSupplier;\n-      // To ensure that the id does not conflict with the id from the \n+      // To ensure that the id does not conflict with the id from the\n       // ContextualRenamer some prefix is needed.\n       Preconditions.checkArgument(!idPrefix.isEmpty());\n       this.idPrefix = idPrefix;\n               0, name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR));\n       }\n \n-      // By using the same separator the id will be stripped if it isn't \n+      // By using the same separator the id will be stripped if it isn't\n       // needed when variable renaming is turned off.\n       return name + ContextualRenamer.UNIQUE_ID_SEPARATOR\n           + idPrefix + uniqueIdSupplier.get();\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n    * itself or the name of a function).\n    */\n   private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n-    boolean signatureAdded = false;\n-\n     if (node.getType() == Token.FUNCTION) {\n       // The node we're looking at is a function, so we can add it directly\n       addSignature(name, node, t.getSourceName());\n-      signatureAdded = true;\n-    } else if (node.getType() == Token.NAME) {\n-      // The one we're looking at is the name of a function, so look it up in\n-      // the current scope\n-      String functionName = node.getString();\n-      Scope.Var v = t.getScope().getVar(functionName);\n-\n-      if (v == null) {\n-        if (compiler.isIdeMode()) {\n-          return;\n-        } else {\n-          throw new IllegalStateException(\n-              \"VarCheck should have caught this undefined function\");\n-        }\n-      }\n-\n-      Node function = v.getInitialValue();\n-      if (function != null &&\n-          function.getType() == Token.FUNCTION) {\n-        addSignature(name, function, v.getInputName());\n-        signatureAdded = true;\n-      }\n-    }\n-\n-    if (!signatureAdded) {\n+    } else {\n       nonMethodProperties.add(name);\n     }\n   }\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n \n       // Check if we can rename this.\n       if (!okToRenameVar(name, local)) {\n+        if (local) {\n+          // Blindly de-uniquify for the Prototype library for issue 103.\n+          String newName =\n+            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n+                name);\n+          if (!newName.equals(name)) {\n+            n.setString(newName);\n+          }\n+        }\n         return;\n       }\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   /** Whether the Normalize pass runs before pass being tested. */\n   private boolean normalizeEnabled = false;\n \n+  /** Whether the expected js strings should be normalized. */\n+  private boolean normalizeExpected = false;\n+\n   /** Whether to check that all line number information is preserved. */\n   private boolean checkLineNumbers = false;\n \n    * @see Normalize\n    */\n   protected void enableNormalize() {\n-    normalizeEnabled  = true;\n+    enableNormalize(true);\n+  }\n+\n+  /**\n+   * Perform AST normalization before running the test pass, and anti-normalize\n+   * after running it.\n+   *\n+   * @param normalizeExpected Whether to perform normalization on the\n+   * expected js result.\n+   * @see Normalize\n+   */\n+  protected void enableNormalize(boolean normalizeExpected) {\n+    normalizeEnabled = true;\n+    this.normalizeExpected = normalizeExpected;\n+  }\n+\n+  /**\n+   * Don't perform AST normalization before running the test pass.\n+   * @see Normalize\n+   */\n+  protected void disableNormalize() {\n+    normalizeEnabled = false;\n   }\n \n   /**\n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = externsRoot.getNext();\n     // Only run the normalize pass, if asked.\n-    if (normalizeEnabled && !compiler.hasErrors()) {\n+    if (normalizeEnabled && normalizeExpected && !compiler.hasErrors()) {\n       Normalize normalize = new Normalize(compiler, false);\n       normalize.process(externsRoot, mainRoot);\n       compiler.setNormalized();\n--- a/test/com/google/javascript/jscomp/InlineGettersTest.java\n+++ b/test/com/google/javascript/jscomp/InlineGettersTest.java\n         \"function Foo(){this.empty=emptyFunction}\" +\n         \"(new Foo).empty()\", null);\n   }\n+\n+  public void testIssue2508576_1() {\n+    // Method defined by an extern should be left alone.\n+    String externs = \"function alert(a) {}\";\n+    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n+  }\n+\n+  public void testIssue2508576_2() {\n+    // Anonymous object definition with a side-effect should be left alone.\n+    testSame(\"({a:function(){},b:x()}).a(\\\"a\\\")\");\n+  }  \n+\n+  public void testIssue2508576_3() {\n+    // Anonymous object definition without side-effect should be removed.\n+    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n+  }  \n }\n--- a/test/com/google/javascript/jscomp/MethodCheckTest.java\n+++ b/test/com/google/javascript/jscomp/MethodCheckTest.java\n     testSame(\"Boz.staticMethod1(1);\");\n     testSame(\"Boz.staticMethod2(1, 2);\");\n \n-    testErr(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\",\n-            FunctionCheck.WRONG_ARGUMENT_COUNT_ERROR);\n-    testErr(\"Boz.staticMethod1(1, 2);\",\n-            FunctionCheck.WRONG_ARGUMENT_COUNT_ERROR);\n-    testErr(\"Boz.staticMethod2(1);\",\n-            FunctionCheck.WRONG_ARGUMENT_COUNT_ERROR);\n+    // Can't detect these incorrect usuages as they are defined indirectly.\n+    testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n+    testSame(\"Boz.staticMethod1(1, 2);\");\n+    testSame(\"Boz.staticMethod2(1);\");\n   }\n \n   public void testNoDefinition() {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n       return new DefaultCodingConvention();\n     }\n   }\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     if (withClosurePass) {\n     localRenamingOnly = false;\n     preserveAnonymousFunctionNames = false;\n     generatePseudoNames = false;\n+\n+    // TODO(johnlenz): Enable Normalize during these tests.\n   }\n \n   public void testRenameSimple() {\n     test(\"var goog, a, b; goog.exportSymbol(a, b);\",\n          \"var a, b, c; a.exportSymbol(b, c);\");\n   }\n-  \n-  public void testDollarSignSuperExport() {\n+\n+  public void testDollarSignSuperExport1() {\n     useGoogleCodingConvention = false;\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n     test(\"var x = function($super,duper,$fantastic){}\",\n          \"var c = function($super,    a,        b){}\");\n-    \n+\n     localRenamingOnly = false;\n     test(\"var $super = 1\", \"var a = 1\");\n \n     useGoogleCodingConvention = true;\n     test(\"var x = function($super,duper,$fantastic){}\",\n          \"var d = function(a,     b,    c        ){}\");\n+  }\n+\n+  public void testDollarSignSuperExport2() {\n+    boolean normalizedExpectedJs = false;\n+    super.enableNormalize(false);\n+\n+    useGoogleCodingConvention = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var x = function($super,duper,$fantastic){};\" +\n+            \"var y = function($super,duper){};\",\n+         \"var c = function($super,    a,         b){};\" +\n+            \"var d = function($super,    a){};\");\n+\n+    localRenamingOnly = false;\n+    test(\"var $super = 1\", \"var a = 1\");\n+\n+    useGoogleCodingConvention = true;\n+    test(\"var x = function($super,duper,$fantastic){};\" +\n+            \"var y = function($super,duper){};\",\n+         \"var d = function(a,     b,    c         ){};\" +\n+            \"var e = function(     a,    b){};\");\n+\n+    super.disableNormalize();\n   }\n \n   public void testPseudoNames() {\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n     test(\"var foo = function(a, b, c){}\",\n          \"var d = function(a, b, c){}\");\n-    \n+\n     generatePseudoNames = true;\n     test(\"var foo = function(a, b, c){}\",\n          \"var $foo$$ = function($a$$, $b$$, $c$$){}\");\n-  }  \n-  \n+  }\n+\n   private void testRenameMapUsingOldMap(String input, String expected,\n                                         VariableMap expectedMap) {\n     previouslyUsedMap = renameVars.getVariableMap();\n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n     testSame(\"var foo = function(var_args) {}; foo(1, 2);\");\n   }\n \n+  public void testMethodCalls() {\n+    final String METHOD_DEFS =\n+      \"/** @constructor */\\n\" +\n+      \"function Foo() {}\" +\n+      // Methods defined in a separate functions and then added via assignment\n+      \"function twoArg(arg1, arg2) {};\" +\n+      \"Foo.prototype.prototypeMethod = twoArg;\" +\n+      \"Foo.staticMethod = twoArg;\";\n+    \n+    // Prototype method with too many arguments.\n+    testSame(METHOD_DEFS +\n+        \"var f = new Foo();f.prototypeMethod(1, 2, 3);\",\n+        TypeCheck.WRONG_ARGUMENT_COUNT);\n+    // Prototype method with too few arguments.\n+    testSame(METHOD_DEFS +\n+        \"var f = new Foo();f.prototypeMethod(1);\",\n+        TypeCheck.WRONG_ARGUMENT_COUNT);\n+\n+    // Static method with too many arguments.\n+    testSame(METHOD_DEFS +\n+        \"Foo.staticMethod(1, 2, 3);\",\n+        TypeCheck.WRONG_ARGUMENT_COUNT);\n+    // Static method with too few arguments.\n+    testSame(METHOD_DEFS +\n+        \"Foo.staticMethod(1);\",\n+        TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n   public void assertOk(String params, String arguments) {\n     assertWarning(params, arguments, null);\n   }", "timestamp": 1268779984, "metainfo": ""}