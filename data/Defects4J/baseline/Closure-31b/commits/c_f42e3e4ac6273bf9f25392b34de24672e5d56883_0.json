{"sha": "f42e3e4ac6273bf9f25392b34de24672e5d56883", "log": "Automated g4 rollback.  *** Reason for rollback ***  Fixes tests.  *** Original change description ***  Automated g4 rollback5.  *** Reason for rollback ***  <enter reason for rollback>  *** Original change description ***  Allow the removal of unused parameters from call sites.  R=acleung DELTA=491  (456 added, 1 deleted, 34 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=68   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Remove unused return values.\n    */\n   public boolean optimizeReturns;\n+\n+  /**\n+   * Remove unused parameters from call sites.\n+   */\n+  public boolean optimizeCalls;\n \n   /**\n    * Provide formal names for elements of arguments array.\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // optimizations based on global names (like cross module code motion\n     // and inline functions).  Smart Name Removal does better if run before\n     // this pass.\n-    if (options.devirtualizePrototypeMethods\n-        || options.optimizeReturns\n-        || options.optimizeParameters) {\n+    if (options.devirtualizePrototypeMethods) {\n+      passes.add(devirtualizePrototypeMethods);\n+    }\n+\n+    // Running \"optimizeCalls\" after devirtualization is useful for removing\n+    // unneeded \"this\" values.\n+    if (options.optimizeCalls\n+        || options.optimizeParameters\n+        || options.optimizeReturns) {\n       passes.add(optimizeCalls);\n     }\n \n         passes.addPass(new OptimizeParameters(compiler));\n       }\n \n-      if (options.devirtualizePrototypeMethods) {\n-        passes.addPass(new DevirtualizePrototypeMethods(compiler));\n+      if (options.optimizeCalls) {\n+        passes.addPass(new RemoveUnusedVars(compiler, false, true, true));\n       }\n       return passes;\n     }\n       return new RemoveUnusedVars(\n           compiler,\n           !removeOnlyLocals,\n-          preserveAnonymousFunctionNames);\n+          preserveAnonymousFunctionNames,\n+          false);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n \n   /**\n    * @return Whether the callNode represents an expression in the form of:\n+   *    x.apply(...)\n+   *    x['apply'](...)\n+   *  or\n+   *    x.call(...)\n+   *    x['call'](...)\n+   */\n+  static boolean isFunctionObjectCallOrApply(Node callNode) {\n+    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);\n+  }\n+\n+  /**\n+   * @return Whether the callNode represents an expression in the form of:\n    *    x.call(...)\n    *    x['call'](...)\n    * where x is a NAME node.\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.*;\n-import java.util.Map;\n \n /**\n  * Garbage collection for variable and function definitions. Basically performs\n  * used across scopes.\n  *\n  */\n-class RemoveUnusedVars implements CompilerPass {\n+class RemoveUnusedVars\n+    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n \n   private final AbstractCompiler compiler;\n \n    */\n   private final Multimap<Var, Continuation> continuations =\n       ArrayListMultimap.create();\n+\n+  private boolean modifyCallSites;\n+\n+  private CallSiteOptimizer callSiteOptimizer;\n \n   RemoveUnusedVars(\n       AbstractCompiler compiler,\n       boolean removeGlobals,\n-      boolean preserveFunctionExpressionNames) {\n+      boolean preserveFunctionExpressionNames,\n+      boolean modifyCallSites) {\n     this.compiler = compiler;\n     this.removeGlobals = removeGlobals;\n     this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n+    this.modifyCallSites = modifyCallSites;\n   }\n \n   /**\n    * may occur to ensure all unused variables are removed.\n    */\n   public void process(Node externs, Node root) {\n+    SimpleDefinitionFinder defFinder = null;\n+    if (modifyCallSites) {\n+      // For testing, allow the SimpleDefinitionFinder to be build now.\n+      defFinder = new SimpleDefinitionFinder(compiler);\n+      defFinder.process(externs, root);\n+    }\n+    process(externs, root, defFinder);\n+  }\n+\n+  @Override\n+  public void process(\n+      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n+    if (modifyCallSites) {\n+      Preconditions.checkNotNull(defFinder);\n+      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n+    }\n     traverseAndRemoveUnusedReferences(root);\n   }\n \n   }\n \n   /**\n-   * Removes unreferenced arguments from a function declaration.\n+   * Removes unreferenced arguments from a function declaration and when\n+   * possible the function's callSites.\n    *\n    * @param fnScope The scope inside the function\n    */\n   private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Strip unreferenced args off the end of the function declaration.\n+    // TODO(johnlenz): Update type registry for function signature changes.\n+\n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.getType() == Token.FUNCTION);\n-\n-    Node argList = function.getFirstChild().getNext();\n-    Node lastArg;\n-    while ((lastArg = argList.getLastChild()) != null) {\n-      Var var = fnScope.getVar(lastArg.getString());\n-      if (!referenced.contains(var)) {\n-        if (var == null) {\n-          throw new IllegalStateException(\n-              \"Function parameter not declared in scope: \"\n-              + lastArg.getString());\n-        }\n-        argList.removeChild(lastArg);\n-        compiler.reportCodeChange();\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      // Strip unreferenced args off the end of the function declaration.\n+      Node lastArg;\n+      while ((lastArg = argList.getLastChild()) != null) {\n+        Var var = fnScope.getVar(lastArg.getString());\n+        if (!referenced.contains(var)) {\n+          Preconditions.checkNotNull(var == null);\n+          argList.removeChild(lastArg);\n+          compiler.reportCodeChange();\n+        } else {\n+          break;\n+        }\n+      }\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n+  }\n+\n+\n+  /**\n+   * @return the LP node containing the function parameters.\n+   */\n+  private static Node getFunctionArgList(Node function) {\n+    return function.getFirstChild().getNext();\n+  }\n+\n+  private static class CallSiteOptimizer {\n+    private final AbstractCompiler compiler;\n+    private final SimpleDefinitionFinder defFinder;\n+\n+    CallSiteOptimizer(\n+        AbstractCompiler compiler,\n+        SimpleDefinitionFinder defFinder) {\n+      this.compiler = compiler;\n+      this.defFinder = defFinder;\n+    }\n+\n+    public void optimize(Scope fnScope, Set<Var> referenced) {\n+      Node function = fnScope.getRootNode();\n+      Preconditions.checkState(function.getType() == Token.FUNCTION);\n+      Node argList = getFunctionArgList(function);\n+\n+      // In this path we try to modify all the call sites to remove unused\n+      // function parameters.\n+      boolean changeCallSignature = canChangeSignature(function);\n+      removeUnreferencedFunctionArgs(\n+          fnScope, function, referenced,\n+          argList.getFirstChild(), 0, changeCallSignature);\n+    }\n+\n+    /**\n+     * For each unused function parameter, determine if it can be removed\n+     * from all the call sites, if so, remove it from the function signature\n+     * and the call sites otherwise replace the unused value where possible\n+     * with a constant (0).\n+     *\n+     * @param scope The function scope\n+     * @param function The function\n+     * @param param The current parameter node in the parameter list.\n+     * @param paramIndex The index of the current parameter\n+     * @param canChangeSignature Whether function signature can be change.\n+     * @return Whether there is a following function parameter.\n+     */\n+    private boolean removeUnreferencedFunctionArgs(\n+        Scope scope, Node function, Set<Var> referenced,\n+        Node param, int paramIndex,\n+        boolean canChangeSignature) {\n+      if (param != null) {\n+        // Take care of the following siblings first.\n+        boolean hasFollowing = removeUnreferencedFunctionArgs(\n+            scope, function, referenced, param.getNext(), paramIndex+1,\n+            canChangeSignature);\n+\n+        Var var = scope.getVar(param.getString());\n+        if (!referenced.contains(var)) {\n+          Preconditions.checkNotNull(var);\n+\n+          // Remove call parameter if we can generally change the signature\n+          // or if it is the last parameter in the parameter list.\n+          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n+          if (modifyAllCallSites) {\n+            modifyAllCallSites = canRemoveArgFromCallSites(\n+                function, paramIndex);\n+          }\n+\n+          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n+\n+          // Remove an unused function parameter if all the call sites can\n+          // be modified to remove it, or if it is the last parameter.\n+          if (modifyAllCallSites || !hasFollowing) {\n+            getFunctionArgList(function).removeChild(param);\n+            compiler.reportCodeChange();\n+            return hasFollowing;\n+          }\n+        }\n+        return true;\n       } else {\n-        break;\n-      }\n-    }\n-  }\n+        // Anything past the last formal parameter can be removed from the call\n+        // sites.\n+        tryRemoveAllFollowingArgs(function, paramIndex-1);\n+        return false;\n+      }\n+    }\n+\n+    /**\n+     * Remove all references to a parameter, otherwise simplify the known\n+     * references.\n+     * @return Whether all the references were removed.\n+     */\n+    private boolean canRemoveArgFromCallSites(Node function, int argIndex) {\n+      Definition definition = getFunctionDefinition(function);\n+\n+      // Check all the call sites.\n+      for (UseSite site : defFinder.getUseSites(definition)) {\n+        if (isModifableCallSite(site)) {\n+          Node arg = NodeUtil.getArgumentForCallOrNew(\n+              site.node.getParent(), argIndex);\n+          // TODO(johnlenz): try to remove parameters with side-effects by\n+          // decomposing the call expression.\n+          if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n+            return false;\n+          }\n+        } else {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * Remove all references to a parameter if possible otherwise simplify the\n+     * side-effect free parameters.\n+     */\n+    private void tryRemoveArgFromCallSites(\n+        Node function, int argIndex, boolean canModifyAllSites) {\n+      Definition definition = getFunctionDefinition(function);\n+\n+      for (UseSite site : defFinder.getUseSites(definition)) {\n+        if (isModifableCallSite(site)) {\n+          Node arg = NodeUtil.getArgumentForCallOrNew(\n+              site.node.getParent(), argIndex);\n+          if (arg != null) {\n+            Node argParent = arg.getParent();\n+            // Even if we can't change the signature in general we can always\n+            // remove an unused value off the end of the parameter list.\n+            if (canModifyAllSites\n+                || (arg.getNext() == null\n+                    && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n+              // Remove the arg completely\n+              argParent.removeChild(arg);\n+              compiler.reportCodeChange();\n+            } else {\n+              // replace the node in the arg with 0\n+              if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n+                  && (arg.getType() != Token.NUMBER || arg.getDouble() != 0)) {\n+                argParent.replaceChild(\n+                    arg, Node.newNumber(0).copyInformationFrom(arg));\n+                compiler.reportCodeChange();\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Remove all the following parameters without side-effects\n+     */\n+    private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n+      Definition definition = getFunctionDefinition(function);\n+      for (UseSite site : defFinder.getUseSites(definition)) {\n+        if (!isModifableCallSite(site)) {\n+          continue;\n+        }\n+\n+        Node arg = NodeUtil.getArgumentForCallOrNew(\n+            site.node.getParent(), argIndex);\n+        while (arg != null) {\n+          Node next = arg.getNext();\n+          if (next != null && !NodeUtil.mayHaveSideEffects(next)) {\n+            arg.getParent().removeChildAfter(arg);\n+            compiler.reportCodeChange();\n+          } else {\n+            arg = next;\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * @param function\n+     * @return Whether the callers to this function can be modified in any way.\n+     */\n+    boolean canModifyCallers(Node function) {\n+      if (NodeUtil.isVarArgsFunction(function)) {\n+        return false;\n+      }\n+\n+      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n+      if (defSite == null) {\n+        return false;\n+      }\n+\n+      Definition definition = defSite.definition;\n+\n+      // Be conservative, don't try to optimize any declaration that isn't as\n+      // simple function declaration or assignment.\n+      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n+        return false;\n+      }\n+\n+      // Assume an exported method result is used, and the definition might be\n+      // changed.\n+      if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n+        return false;\n+      }\n+\n+      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+      for (UseSite site : useSites) {\n+        // Multiple definitions prevent rewrite.\n+        // TODO(johnlenz): Allow rewrite all definitions are valid.\n+        Node nameNode = site.node;\n+        Collection<Definition> singleSiteDefinitions =\n+            defFinder.getDefinitionsReferencedAt(nameNode);\n+        if (singleSiteDefinitions.size() > 1) {\n+          return false;\n+        }\n+        Preconditions.checkState(!singleSiteDefinitions.isEmpty());\n+        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * @param site The site to inspect\n+     * @return Whether the call site is suitable for modification\n+     */\n+    private static boolean isModifableCallSite(UseSite site) {\n+      return SimpleDefinitionFinder.isCallOrNewSite(site)\n+          && !NodeUtil.isFunctionObjectCallOrApply(site.node.getParent());\n+    }\n+\n+    /**\n+     * @return Whether the definitionSite represents a function whose call\n+     *      signature can be modified.\n+     */\n+    private boolean canChangeSignature(Node function) {\n+      Definition definition = getFunctionDefinition(function);\n+\n+      Preconditions.checkState(!definition.isExtern());\n+\n+      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+      for (UseSite site : useSites) {\n+        // Accessing the property directly prevents rewrite.\n+        if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n+          return false;\n+        }\n+\n+        // TODO(johnlenz): support .call signature changes.\n+        if (NodeUtil.isFunctionObjectCallOrApply(site.node.getParent())) {\n+          return false;\n+        }\n+\n+        // TODO(johnlenz): support specialization\n+\n+        // Multiple definitions prevent rewrite.\n+        // Attempt to validate the state of the simple definition finder.\n+        Node nameNode = site.node;\n+        Collection<Definition> singleSiteDefinitions =\n+            defFinder.getDefinitionsReferencedAt(nameNode);\n+        Preconditions.checkState(singleSiteDefinitions.size() == 1);\n+        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * @param function\n+     * @return the Definition object for the function.\n+     */\n+    private Definition getFunctionDefinition(Node function) {\n+      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n+          function);\n+      Preconditions.checkNotNull(definitionSite);\n+      Definition definition = definitionSite.definition;\n+      Preconditions.checkState(!definitionSite.inExterns);\n+      Preconditions.checkState(definition.getRValue() == function);\n+      return definition;\n+    }\n+  }\n+\n \n   /**\n    * Look at all the property assigns to all variables.\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n     // rather than simply having an extern definition.  Don't mess with it.\n     Node nameNode = SimpleDefinitionFinder.getNameNodeFromFunctionNode(fn);\n     if (nameNode != null\n-        && NodeUtil.isName(nameNode)\n-        && nameNode.getString().equals(NodeUtil.JSC_PROPERTY_NAME_FN)) {\n-      return false;\n+        && NodeUtil.isName(nameNode)) {\n+      String name = nameNode.getString();\n+      if (name.equals(NodeUtil.JSC_PROPERTY_NAME_FN) ||\n+             name.equals(\n+                ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) {\n+        return false;\n+      }\n     }\n \n     // example: function a(){};\n--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n \n   public void testRegexesCanBeInlined() {\n     test(\"function foo(a) {}; foo(/abc/);\",\n-        \"function foo() {var a = /abc/}; foo();\");\n+         \"function foo() {var a = /abc/}; foo();\");\n   }\n \n   public void testConstructorUsedAsFunctionCanBeOptimized() {\n          \"function foo(a) {var b = 1}; foo(arguments)\");\n \n     test(\"function foo(a, b) {}; foo(arguments)\",\n-    \"function foo(a) {var b}; foo(arguments)\");\n+         \"function foo(a) {var b}; foo(arguments)\");\n   }\n \n   public void testDoNotOptimizeGoogExportFunctions() {\n     testSame(\"function foo(a, b) {}; foo(); goog.export_function(foo);\");\n   }\n+\n+  public void testDoNotOptimizeJSCompiler_renameProperty() {\n+    testSame(\"function JSCompiler_renameProperty(a) {return a};\" +\n+             \"JSCompiler_renameProperty('a');\");\n+  }\n+\n+  public void testDoNotOptimizeJSCompiler_ObjectPropertyString() {\n+    testSame(\"function JSCompiler_ObjectPropertyString(a, b) {return a[b]};\" +\n+             \"JSCompiler_renameProperty(window,'b');\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n \n   private boolean removeGlobal = true;\n   private boolean preserveFunctionExpressionNames = false;\n+  private boolean modifyCallSites = false;\n \n   public RemoveUnusedVarsTest() {\n     super(\"function alert() {}\");\n   public void setUp() {\n     removeGlobal = true;\n     preserveFunctionExpressionNames = false;\n+    modifyCallSites = true;\n   }\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     return new RemoveUnusedVars(\n-        compiler, removeGlobal, preserveFunctionExpressionNames);\n+        compiler, removeGlobal, preserveFunctionExpressionNames,\n+        modifyCallSites);\n   }\n \n   public void testRemoveUnusedVars() {\n   }\n \n   public void testFunctionArgRemoval() {\n+    this.modifyCallSites = false;\n     // remove all function arguments\n     test(\"var b=function(c,d){return};b(1,2)\",\n          \"var b=function(){return};b(1,2)\");\n          \"var b=function(c,d){return c+d};b(1,2)\");\n     test(\"var b=function(e,c,f,d,g){return c+d};b(1,2)\",\n          \"var b=function(e,c,f,d){return c+d};b(1,2)\");\n+  }\n+\n+  public void testFunctionArgRemovalFromCallSites() {\n+    this.modifyCallSites = true;\n+\n+    // remove all function arguments\n+    test(\"var b=function(c,d){return};b(1,2)\",\n+         \"var b=function(){return};b()\");\n+\n+    // remove no function arguments\n+    testSame(\"var b=function(c,d){return c+d};b(1,2)\");\n+    test(\"var b=function(e,f,c,d){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b()\");\n+\n+    // remove some function arguments\n+    test(\"var b=function(c,d,e,f){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b(1,2)\");\n+    test(\"var b=function(e,c,f,d,g){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b(2)\");\n   }\n \n   public void testVarInControlStructure() {\n \n   public void testUnusedAssign2() {\n     test(\"function f(a) { a = 3; } this.x = f;\",\n-        \"function f(){}this.x=f\");\n+         \"function f(){} this.x=f\");\n   }\n \n   public void testUnusedAssign3() {\n   }\n \n   public void testLocalVarReferencesGlobalVar2() {\n+    this.modifyCallSites = false;\n     test(\"var a=3;function f(b, c){b=a; alert(c);} f();\",\n          \"function f(b, c) { alert(c); } f();\");\n+    this.modifyCallSites = true;\n+    test(\"var a=3;function f(b, c){b=a; alert(c);} f();\",\n+         \"function f(c) { alert(c); } f();\");\n   }\n \n   public void testNestedAssign1() {\n     test(\"var b = 0; var z; z = z = b = 1; alert(b);\",\n          \"var b = 0; b = 1; alert(b);\");\n   }\n+\n+  public void testCallSiteInteraction() {\n+    this.modifyCallSites = true;\n+\n+    testSame(\"var b=function(){return};b()\");\n+    testSame(\"var b=function(c){return c};b(1)\");\n+    test(\"var b=function(c){};b.call(null, x)\",\n+         \"var b=function(){};b.call(null, x)\");\n+    test(\"var b=function(c){};b.apply(null, x)\",\n+         \"var b=function(){};b.apply(null, x)\");\n+\n+    test(\"var b=function(c){return};b(1)\",\n+         \"var b=function(){return};b()\");\n+    test(\"var b=function(c){return};b(1,2)\",\n+         \"var b=function(){return};b()\");\n+    test(\"var b=function(c){return};b(1,2);b(3,4)\",\n+         \"var b=function(){return};b();b()\");\n+\n+    // Here there is a unknown reference to the function so we can't\n+    // change the signature.\n+    test(\"var b=function(c,d){return d};b(1,2);b(3,4);b.length\",\n+         \"var b=function(c,d){return d};b(0,2);b(0,4);b.length\");\n+\n+    test(\"var b=function(c){return};b(1,2);b(3,new x())\",\n+         \"var b=function(){return};b();b(new x())\");\n+\n+    test(\"var b=function(c){return};b(1,2);b(new x(),4)\",\n+         \"var b=function(){return};b();b(new x())\");\n+\n+    test(\"var b=function(c,d){return d};b(1,2);b(new x(),4)\",\n+         \"var b=function(c,d){return d};b(0,2);b(new x(),4)\");\n+    test(\"var b=function(c,d,e){return d};b(1,2,3);b(new x(),4,new x())\",\n+         \"var b=function(c,d){return d};b(0,2);b(new x(),4,new x())\");\n+\n+    // Recursive calls are ok.\n+    test(\"var b=function(c,d){b(1,2);return d};b(3,4);b(5,6)\",\n+         \"var b=function(d){b(2);return d};b(4);b(6)\");\n+\n+    test(\"var b=function(c){return arguments};b(1,2);b(3,4)\",\n+         \"var b=function(){return arguments};b(1,2);b(3,4)\");\n+\n+    // remove all function arguments\n+    test(\"var b=function(c,d){return};b(1,2)\",\n+         \"var b=function(){return};b()\");\n+\n+    // remove no function arguments\n+    testSame(\"var b=function(c,d){return c+d};b(1,2)\");\n+\n+    // remove some function arguments\n+    test(\"var b=function(e,f,c,d){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b()\");\n+    test(\"var b=function(c,d,e,f){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b(1,2)\");\n+    test(\"var b=function(e,c,f,d,g){return c+d};b(1,2)\",\n+         \"var b=function(c,d){return c+d};b(2)\");\n+    \n+    // multiple definitions of \"b\", the parameters can be removed but\n+    // the call sites are left unmodified for now.\n+    test(\"var b=function(c,d){};var b=function(e,f){};b(1,2)\",\n+         \"var b=function(){};var b=function(){};b(1,2)\");  \n+  }\n+  \n+  public void testDoNotOptimizeJSCompiler_renameProperty() {\n+    this.modifyCallSites = true;\n+    \n+    // Only the function definition can be modified, none of the call sites.\n+    test(\"function JSCompiler_renameProperty(a) {};\" +\n+         \"JSCompiler_renameProperty('a');\",\n+         \"function JSCompiler_renameProperty() {};\" +\n+         \"JSCompiler_renameProperty('a');\");\n+  }\n+  \n+  public void testDoNotOptimizeJSCompiler_ObjectPropertyString() {\n+    this.modifyCallSites = true;\n+    test(\"function JSCompiler_ObjectPropertyString(a, b) {};\" +\n+         \"JSCompiler_ObjectPropertyString(window,'b');\",\n+         \"function JSCompiler_ObjectPropertyString() {};\" +\n+         \"JSCompiler_ObjectPropertyString(window,'b');\");\n+  }  \n }", "timestamp": 1291668184, "metainfo": ""}