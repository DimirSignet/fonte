{"sha": "cf5fd88f13f0b11625ac407f85cb58b36862e173", "log": "Change on 2010/05/25 by nicksantos          start moving away from using Object#equals for type equality.          R=johnlenz         DELTA=445  (98 added, 3 deleted, 344 changed)  Change on 2010/05/25 by acleung          Fix bug with resolving a member function of a resolved constructor.          R=johnlenz         DELTA=48  (48 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=12002   ", "commit": "\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     if (type == node2.getType()\n         && getChildCount() == node2.getChildCount()\n         && getClass() == node2.getClass()\n-        && Objects.equal(jsType, node2.getJSType())) {\n+        && JSType.isEquivalent(jsType, node2.getJSType())) {\n \n       eq = this.isEquivalentTo(node2);\n     }\n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n   /**\n    * The All type is the greatest type (top) and is never a subtype of\n    * another except itself or the Unknown type.\n-   * @return {@code this.equals(that)}\n+   * @return {@code this.isEquivalentTo(that)}\n    */\n   @Override\n   public boolean isSubtype(JSType that) {\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n       if (thisParamType != null) {\n         // Both parameter lists give a type for this param, it should be equal\n         if (otherParamType != null &&\n-            !thisParamType.equals(otherParamType)) {\n+            !thisParamType.isEquivalentTo(otherParamType)) {\n           return false;\n         }\n       } else {\n   }\n \n   @Override\n-  public boolean equals(Object object) {\n+  public boolean isEquivalentTo(JSType object) {\n     // Please keep this method in sync with the hashCode() method below.\n     if (!(object instanceof ArrowType)) {\n       return false;\n     }\n     ArrowType that = (ArrowType) object;\n-    if (!returnType.equals(that.returnType) ||\n+    if (!returnType.isEquivalentTo(that.returnType) ||\n         returnTypeInferred != that.returnTypeInferred) {\n       return false;\n     }\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  public boolean equals(Object that) {\n+  public boolean isEquivalentTo(JSType that) {\n     if (this == that) {\n       return true;\n-    } else if (that instanceof JSType && this.isNominalType()) {\n-      ObjectType thatObj = ObjectType.cast((JSType) that);\n+    } else if (this.isNominalType()) {\n+      ObjectType thatObj = ObjectType.cast(that);\n       if (thatObj != null && thatObj.isNominalType()) {\n         return getReferenceName().equals(thatObj.getReferenceName());\n       }\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n     if (result != null) {\n       return result;\n     }\n-    return this.equals(that) ? TRUE : FALSE;\n+    return this.isEquivalentTo(that) ? TRUE : FALSE;\n   }\n \n   @Override\n   public boolean isSubtype(JSType that) {\n-    return that.equals(getNativeType(JSTypeNative.OBJECT_TYPE)) ||\n-        that.equals(getNativeType(JSTypeNative.OBJECT_PROTOTYPE)) ||\n+    return that.isEquivalentTo(getNativeType(JSTypeNative.OBJECT_TYPE)) ||\n+        that.isEquivalentTo(getNativeType(JSTypeNative.OBJECT_PROTOTYPE)) ||\n         JSType.isSubtype(this, that);\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   @Override\n   public boolean isInstanceType() {\n     // The universal constructor is its own instance, bizarrely.\n-    return equals(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n+    return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n   }\n \n   @Override\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n-        if (objType.equals(prototype)) {\n+        if (objType.isEquivalentTo(prototype)) {\n           return true;\n         }\n         return setPrototype(\n     // approach of using the universal constructor and the AnyObject as\n     // the supremum and infinum of all function types.\n     if (isFunctionType() && that.isFunctionType()) {\n-      if (equals(that)) {\n+      if (isEquivalentTo(that)) {\n         return this;\n       }\n \n           that instanceof FunctionType) {\n         FunctionType other = (FunctionType) that;\n         if (call.hasEqualParameters(other.call) &&\n-            Objects.equal(typeOfThis, other.typeOfThis)) {\n+            isEquivalent(typeOfThis, other.typeOfThis)) {\n           JSType newReturnType = leastSuper ?\n               call.returnType.getLeastSupertype(other.call.returnType) :\n               call.returnType.getGreatestSubtype(other.call.returnType);\n \n       JSType functionInstance = registry.getNativeType(\n           JSTypeNative.FUNCTION_INSTANCE_TYPE);\n-      if (functionInstance.equals(that)) {\n+      if (functionInstance.isEquivalentTo(that)) {\n         return leastSuper ? that : this;\n-      } else if (functionInstance.equals(this)) {\n+      } else if (functionInstance.isEquivalentTo(this)) {\n         return leastSuper ? this : that;\n       }\n \n    * have signatures, two interfaces are equal if their names match.\n    */\n   @Override\n-  public boolean equals(Object otherType) {\n+  public boolean isEquivalentTo(JSType otherType) {\n     if (!(otherType instanceof FunctionType)) {\n       return false;\n     }\n     if (that.isInterface()) {\n       return false;\n     }\n-    return this.typeOfThis.equals(that.typeOfThis) &&\n-        this.call.equals(that.call);\n+    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n+        this.call.isEquivalentTo(that.call);\n   }\n \n   @Override\n   }\n \n   public boolean hasEqualCallType(FunctionType otherType) {\n-    return this.call.equals(otherType.call);\n+    return this.call.isEquivalentTo(otherType.call);\n   }\n \n   /**\n    */\n   @Override\n   public boolean isSubtype(JSType that) {\n-    if (this.equals(that)) {\n+    if (this.isEquivalentTo(that)) {\n       return true;\n     }\n     if (that.isFunctionType()) {\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   }\n \n   @Override\n-  public boolean equals(Object that) {\n+  public boolean isEquivalentTo(JSType that) {\n     if (this == that) {\n       return true;\n-    } else if (that instanceof JSType && this.isNominalType()) {\n-      ObjectType thatObj = ObjectType.cast((JSType) that);\n+    } else if (this.isNominalType()) {\n+      ObjectType thatObj = ObjectType.cast(that);\n       if (thatObj != null && thatObj.isNominalType()) {\n         return getReferenceName().equals(thatObj.getReferenceName());\n       }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n-   * This method relies on the fact that for the base {@link JSType}, only one\n-   * instance of each sub-type will ever be created in a given registry, so\n-   * there is no need to verify members. If the object pointers are not\n-   * identical, then the type member must be different.\n-   */\n-  @Override public boolean equals(Object jsType) {\n+   * Checks if two types are equivalent.\n+   */\n+  public boolean isEquivalentTo(JSType jsType) {\n     if (jsType instanceof ProxyObjectType) {\n-      return jsType.equals(this);\n-    }\n+      return jsType.isEquivalentTo(this);\n+    }\n+    // Relies on the fact that for the base {@link JSType}, only one\n+    // instance of each sub-type will ever be created in a given registry, so\n+    // there is no need to verify members. If the object pointers are not\n+    // identical, then the type member must be different.\n     return this == jsType;\n+  }\n+\n+  public static boolean isEquivalent(JSType typeA, JSType typeB) {\n+    return (typeA == null || typeB == null) ?\n+        typeA == typeB : typeA.isEquivalentTo(typeB);\n+  }\n+\n+  @Override\n+  public boolean equals(Object jsType) {\n+    return (jsType instanceof JSType) ?\n+        isEquivalentTo((JSType) jsType) : false;\n   }\n \n   @Override\n     } else if (thisType.isUnknownType() || thatType.isUnknownType()) {\n       // The greatest subtype with any unknown type is the universal\n       // unknown type, unless the two types are equal.\n-      return thisType.equals(thatType) ? thisType :\n+      return thisType.isEquivalentTo(thatType) ? thisType :\n           thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n     } else if (thisType.isSubtype(thatType)) {\n       return thisType;\n   public boolean differsFrom(JSType that) {\n     // if there are no unknowns, just use normal equality.\n     if (!this.isUnknownType() && !that.isUnknownType()) {\n-      return !this.equals(that);\n+      return !this.isEquivalentTo(that);\n     }\n     // otherwise, they're different iff one is unknown and the other is not.\n     return this.isUnknownType() ^ that.isUnknownType();\n       return true;\n     }\n     // equality\n-    if (thisType.equals(thatType)) {\n+    if (thisType.isEquivalentTo(thatType)) {\n       return true;\n     }\n     // all type\n    * Resolve this type in the given scope.\n    *\n    * The returned value must be equal to {@code this}, as defined by\n-   * {@link Object#equals}. It may or may not be the same object. This method\n+   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n    * may modify the internal state of {@code this}, as long as it does\n    * so in a way that preserves Object equality.\n    *\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   }\n \n   /**\n-   * Two named types are equal if they are the same {@code ObjectType} object.\n-   * This is complicated by the fact that equals is sometimes called before we\n-   * have a chance to resolve the type names.\n+   * Two named types are equivalent if they are the same {@code\n+   * ObjectType} object.  This is complicated by the fact that isEquivalent\n+   * is sometimes called before we have a chance to resolve the type\n+   * names.\n    *\n    * @return {@code true} iff {@code that} == {@code this} or {@code that}\n    *         is a {@link NamedType} whose reference is the same as ours,\n    *         or {@code that} is the type we reference.\n    */\n   @Override\n-  public boolean equals(Object that) {\n+  public boolean isEquivalentTo(JSType that) {\n     if (this == that) {\n       return true;\n-    } else if (that instanceof JSType) {\n-      ObjectType objType = ObjectType.cast((JSType) that);\n-      if (objType != null) {\n-        return objType.isNominalType() &&\n-            reference.equals(objType.getReferenceName());\n-      }\n+    }\n+\n+    ObjectType objType = ObjectType.cast(that);\n+    if (objType != null) {\n+      return objType.isNominalType() &&\n+          reference.equals(objType.getReferenceName());\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public boolean equals(Object that) {\n+  public boolean isEquivalentTo(JSType that) {\n     return this == that;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n     for (ObjectType current = this;\n          current != null;\n          current = current.getImplicitPrototype()) {\n-      if (current.equals(prototype)) {\n+      if (current.isEquivalentTo(prototype)) {\n         return true;\n       }\n     }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean equals(Object that) {\n+  public boolean isEquivalentTo(JSType that) {\n     if (this == that) {\n       return true;\n     }\n-    return referencedType.equals(that);\n+    return referencedType.isEquivalentTo(that);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n \n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * A record (structural) type.\n   }\n \n   @Override\n-  public boolean equals(Object other) {\n+  public boolean isEquivalentTo(JSType other) {\n     if (!(other instanceof RecordType)) {\n       return false;\n     }\n \n     // Compare properties.\n     RecordType otherRecord = (RecordType) other;\n-    return otherRecord.properties.equals(properties);\n+    Set<String> keySet = properties.keySet();\n+    Map<String, JSType> otherProps = otherRecord.properties;\n+    if (!otherProps.keySet().equals(keySet)) {\n+      return false;\n+    }\n+    for (String key : keySet) {\n+      if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n+        return false;\n+      }\n+    }\n+    return true;\n   }\n \n   @Override\n     // type of the properties themselves.\n     for (String property : properties.keySet()) {\n       if (thatRecord.hasProperty(property) &&\n-          thatRecord.getPropertyType(property).equals(\n+          thatRecord.getPropertyType(property).isEquivalentTo(\n               getPropertyType(property))) {\n         builder.addProperty(property, getPropertyType(property));\n       }\n       // is returned.\n       for (String property : properties.keySet()) {\n         if (thatRecord.hasProperty(property) &&\n-            !thatRecord.getPropertyType(property).equals(\n+            !thatRecord.getPropertyType(property).isEquivalentTo(\n                 getPropertyType(property))) {\n           return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n         }\n         UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n         for (ObjectType alt : registry.getTypesWithProperty(propName)) {\n           JSType altPropType = alt.getPropertyType(propName);\n-          if (altPropType != null && !alt.equals(this) &&\n+          if (altPropType != null && !alt.isEquivalentTo(this) &&\n               alt.isSubtype(that) &&\n               (propType.isUnknownType() || altPropType.isUnknownType() ||\n-               altPropType.equals(propType))) {\n+               altPropType.isEquivalentTo(propType))) {\n             builder.addAlternate(alt);\n           }\n         }\n       JSType propB = typeB.getPropertyType(property);\n       if (!propA.isUnknownType() && !propB.isUnknownType()) {\n         if (typeA.isPropertyTypeDeclared(property)) {\n-          if (!propA.equals(propB)) {\n+          if (!propA.isEquivalentTo(propB)) {\n             return false;\n           }\n         } else {\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n \n+import java.util.Collection;\n import java.util.List;\n-import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n \n public class UnionType extends JSType {\n   private static final long serialVersionUID = 1L;\n \n-  Set<JSType> alternates;\n+  Collection<JSType> alternates;\n   private final int hashcode;\n \n   /**\n    *\n    * @param alternates the alternates of the union\n    */\n-  UnionType(JSTypeRegistry registry, Set<JSType> alternates) {\n+  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n     super(registry);\n     this.alternates = alternates;\n     this.hashcode = this.alternates.hashCode();\n    * and all alternates are equal.\n    */\n   @Override\n-  public boolean equals(Object object) {\n+  public boolean isEquivalentTo(JSType object) {\n     if (object instanceof UnionType) {\n       UnionType that = (UnionType) object;\n-      return alternates.equals(that.alternates);\n+      return this.isSubtype(that) && that.isSubtype(this);\n     } else {\n       return false;\n     }\n       resolvedTypes.add(alternate);\n     }\n     if (changed) {\n-      Set<JSType> newAlternates = resolvedTypes.build();\n+      Collection<JSType> newAlternates = resolvedTypes.build();\n       Preconditions.checkState(newAlternates.hashCode() == this.hashcode);\n       alternates = newAlternates;\n     }\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n       JSType type, StaticScope<JSType> scope) {\n     ErrorReporter t = TestErrorReporter.forNoExpectedReports();\n     JSType resolvedType = type.resolve(t, scope);\n-    Assert.assertEquals(\"JSType#resolve should not affect object equality\",\n+    assertTypeEquals(\"JSType#resolve should not affect object equality\",\n         type, resolvedType);\n     Assert.assertEquals(\"JSType#resolve should not affect hash codes\",\n         type.hashCode(), resolvedType.hashCode());\n     return resolvedType;\n   }\n+\n+  public static void assertTypeEquals(JSType a, JSType b) {\n+    assertTypeEquals(\"\", a, b);\n+  }\n+\n+  public static void assertTypeEquals(String message, JSType a, JSType b) {\n+    Assert.assertTrue(\n+        message +\n+        (message.isEmpty() ? \"\" : \"\\n\") +\n+        \"Expected: \" + b + \"\\n\" +\n+        \"Actual  : \" + a,\n+        a.isEquivalentTo(b));\n+  }\n }\n--- a/test/com/google/javascript/rhino/JSDocInfoTest.java\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n \n import junit.framework.TestCase;\n     assertNull(info.getEnumParameterType());\n     assertEquals(0, info.getParameterCount());\n     assertNull(info.getReturnType());\n-    assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));\n+    assertTypeEquals(STRING_TYPE, resolve(info.getType()));\n     assertNull(info.getVisibility());\n     assertTrue(info.hasType());\n     assertFalse(info.isConstant());\n     assertNull(info.getEnumParameterType());\n     assertEquals(0, info.getParameterCount());\n     assertNull(info.getReturnType());\n-    assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));\n+    assertTypeEquals(STRING_TYPE, resolve(info.getType()));\n     assertEquals(PROTECTED, info.getVisibility());\n     assertTrue(info.hasType());\n     assertFalse(info.isConstant());\n     assertNull(info.getDescription());\n     assertNull(info.getEnumParameterType());\n     assertEquals(0, info.getParameterCount());\n-    assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));\n+    assertTypeEquals(STRING_TYPE, resolve(info.getReturnType()));\n     assertNull(info.getType());\n     assertNull(info.getVisibility());\n     assertFalse(info.hasType());\n             new Node(Token.BANG, Node.newString(\"Number\")), \"\"));\n     info.setReturnType(fromString(\"string\"));\n \n-    assertEquals(getNativeType(NUMBER_OBJECT_TYPE),\n+    assertTypeEquals(NUMBER_OBJECT_TYPE,\n         resolve(info.getBaseType()));\n     assertNull(info.getDescription());\n     assertNull(info.getEnumParameterType());\n     assertEquals(0, info.getParameterCount());\n-    assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));\n+    assertTypeEquals(STRING_TYPE, resolve(info.getReturnType()));\n     assertNull(info.getType());\n     assertNull(info.getVisibility());\n     assertFalse(info.hasType());\n \n     assertNull(info.getBaseType());\n     assertNull(info.getDescription());\n-    assertEquals(getNativeType(STRING_TYPE),\n+    assertTypeEquals(STRING_TYPE,\n         resolve(info.getEnumParameterType()));\n     assertEquals(0, info.getParameterCount());\n     assertNull(info.getReturnType());\n       fail(\"Expected exception\");\n     } catch (IllegalStateException e) {}\n \n-    assertEquals(getNativeType(NUMBER_TYPE), resolve(info.getType()));\n+    assertTypeEquals(NUMBER_TYPE, resolve(info.getType()));\n     assertNull(info.getReturnType());\n     assertNull(info.getEnumParameterType());\n     assertNull(info.getTypedefType());\n       fail(\"Expected exception\");\n     } catch (IllegalStateException e) {}\n \n-    assertEquals(getNativeType(BOOLEAN_TYPE),\n+    assertTypeEquals(BOOLEAN_TYPE,\n         resolve(info.getReturnType()));\n     assertNull(info.getEnumParameterType());\n     assertNull(info.getType());\n     assertNull(info.getType());\n     assertNull(info.getTypedefType());\n     assertNull(info.getReturnType());\n-    assertEquals(getNativeType(BOOLEAN_TYPE),\n+    assertTypeEquals(BOOLEAN_TYPE,\n         resolve(info.getEnumParameterType()));\n   }\n \n     JSDocInfo info = new JSDocInfo();\n     info.setTypedefType(fromString(\"boolean\"));\n \n-    assertEquals(getNativeType(BOOLEAN_TYPE),\n+    assertTypeEquals(BOOLEAN_TYPE,\n         resolve(info.getTypedefType()));\n     assertTrue(info.hasTypedefType());\n     assertFalse(info.hasType());\n     errorReporter.setWarnings(warnings);\n     return n.evaluate(null, registry);\n   }\n+\n+  private void assertTypeEquals(JSTypeNative a, JSType b) {\n+    assertTypeEquals(getNativeType(a), b);\n+  }\n+\n+  private void assertTypeEquals(JSType a, JSType b) {\n+    Asserts.assertTypeEquals(a, b);\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n \n     assertTrue(builder.addVarArgs(STRING_TYPE));\n \n     Node params = builder.build();\n-    assertEquals(NUMBER_TYPE, params.getFirstChild().getJSType());\n-    assertEquals(registry.createOptionalType(BOOLEAN_TYPE),\n+    assertTypeEquals(NUMBER_TYPE, params.getFirstChild().getJSType());\n+    assertTypeEquals(registry.createOptionalType(BOOLEAN_TYPE),\n         params.getFirstChild().getNext().getJSType());\n-    assertEquals(registry.createOptionalType(STRING_TYPE),\n+    assertTypeEquals(registry.createOptionalType(STRING_TYPE),\n         params.getLastChild().getJSType());\n \n     assertTrue(params.getFirstChild().getNext().isOptionalArg());\n     assertTrue(params.getLastChild().isVarArgs());\n   }\n \n+  private void assertTypeEquals(JSType a, JSType b) {\n+    Asserts.assertTypeEquals(a, b);\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n import com.google.javascript.rhino.SimpleErrorReporter;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n+import com.google.javascript.rhino.testing.Asserts;\n \n import junit.framework.TestCase;\n \n   // now much larger\n   public void testGetBuiltInType() {\n     JSTypeRegistry typeRegistry = new JSTypeRegistry(null);\n-    assertEquals(typeRegistry.getNativeType(JSTypeNative.BOOLEAN_TYPE),\n+    assertTypeEquals(typeRegistry.getNativeType(JSTypeNative.BOOLEAN_TYPE),\n         typeRegistry.getType(\"boolean\"));\n   }\n \n     JSType type = typeRegistry.createAnonymousObjectType();\n     String name = \"Foo\";\n     typeRegistry.declareType(name, type);\n-    assertEquals(type, typeRegistry.getType(name));\n+    assertTypeEquals(type, typeRegistry.getType(name));\n \n     // Ensure different instances are independent.\n     JSTypeRegistry typeRegistry2 = new JSTypeRegistry(null);\n     assertEquals(null, typeRegistry2.getType(name));\n-    assertEquals(type, typeRegistry.getType(name));\n+    assertTypeEquals(type, typeRegistry.getType(name));\n   }\n \n   public void testGetDeclaredTypeInNamespace() {\n     JSType type = typeRegistry.createAnonymousObjectType();\n     String name = \"a.b.Foo\";\n     typeRegistry.declareType(name, type);\n-    assertEquals(type, typeRegistry.getType(name));\n+    assertTypeEquals(type, typeRegistry.getType(name));\n     assertTrue(typeRegistry.hasNamespace(\"a\"));\n     assertTrue(typeRegistry.hasNamespace(\"a.b\"));\n   }\n     JSType type = typeRegistry.createAnonymousObjectType();\n     String name = \"a.b.Foo\";\n     typeRegistry.declareType(name, type);\n-    assertEquals(type, typeRegistry.getType(name));\n+    assertTypeEquals(type, typeRegistry.getType(name));\n \n     type = typeRegistry.createAnonymousObjectType();\n     name = \"a.b.Foo.Bar\";\n     typeRegistry.declareType(name, type);\n-    assertEquals(type, typeRegistry.getType(name));\n+    assertTypeEquals(type, typeRegistry.getType(name));\n \n     assertTrue(typeRegistry.hasNamespace(\"a\"));\n     assertTrue(typeRegistry.hasNamespace(\"a.b\"));\n     assertTrue(type instanceof AllType);\n   }\n \n+  private void assertTypeEquals(JSType a, JSType b) {\n+    Asserts.assertTypeEquals(a, b);\n+  }\n+\n   private static class EmptyScope implements StaticScope<JSType> {\n     public StaticSlot<JSType> getSlot(final String name) { return null; }\n     public StaticSlot<JSType> getOwnSlot(String name) { return null; }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         U2U_CONSTRUCTOR_TYPE.toString());\n \n     // getPropertyType\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         U2U_CONSTRUCTOR_TYPE.getPropertyType(\"anyProperty\"));\n \n     assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());\n     assertEquals(\"NoObject\", NO_OBJECT_TYPE.toString());\n \n     // getPropertyType\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NO_OBJECT_TYPE.getPropertyType(\"anyProperty\"));\n \n     Asserts.assertResolvesToSame(NO_OBJECT_TYPE);\n     assertEquals(\"None\", NO_TYPE.toString());\n \n     // getPropertyType\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NO_TYPE.getPropertyType(\"anyProperty\"));\n \n     Asserts.assertResolvesToSame(NO_TYPE);\n     assertTrue(ARRAY_TYPE.isObject());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ARRAY_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE),\n+    assertTypeEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE),\n         ARRAY_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE),\n         ARRAY_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createUnionType(ARRAY_TYPE, functionType),\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, functionType),\n         ARRAY_TYPE.getLeastSupertype(functionType));\n-    assertEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, ARRAY_TYPE),\n+    assertTypeEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertTypeEquals(createUnionType(DATE_TYPE, ARRAY_TYPE),\n         ARRAY_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE),\n+    assertTypeEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE),\n         ARRAY_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // getPropertyType\n     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"sort\"));\n     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"splice\"));\n     assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"unshift\"));\n-    assertEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"length\"));\n \n     // isPropertyType*\n     assertPropertyTypeDeclared(ARRAY_TYPE, \"pop\");\n     assertTrue(UNKNOWN_TYPE.isNullable());\n \n     // getGreatestCommonType\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(UNKNOWN_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(STRING_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(functionType));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // matchesXxx\n     assertFalse(ALL_TYPE.isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(functionType));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // matchesXxx\n    */\n   public void testTheObjectType() throws Exception {\n     // implicit prototype\n-    assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n+    assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n \n     // isXxx\n     assertFalse(OBJECT_TYPE.isNoObjectType());\n     assertFalse(OBJECT_TYPE.isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         OBJECT_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE),\n         OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         OBJECT_TYPE.getLeastSupertype(functionType));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         OBJECT_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // getPropertyType\n     assertFalse(OBJECT_TYPE.matchesUint32Context());\n \n     // implicit prototype\n-    assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n+    assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n \n     // toString\n     assertEquals(\"Object\", OBJECT_TYPE.toString());\n     assertTrue(NUMBER_OBJECT_TYPE.isInstanceType());\n \n     // autoboxesTo\n-    assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n+    assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n \n     // unboxesTo\n-    assertEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo());\n+    assertTypeEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo());\n \n     // canAssignTo\n     assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n     assertFalse(NUMBER_OBJECT_TYPE.isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         NUMBER_OBJECT_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE),\n         NUMBER_OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE),\n         NUMBER_OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType),\n+    assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType),\n         NUMBER_OBJECT_TYPE.getLeastSupertype(functionType));\n-    assertEquals(OBJECT_TYPE,\n+    assertTypeEquals(OBJECT_TYPE,\n         NUMBER_OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE),\n         NUMBER_OBJECT_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE),\n         NUMBER_OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // matchesXxx\n     assertFalse(NUMBER_TYPE.isInstanceType());\n \n     // autoboxesTo\n-    assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n+    assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n \n     // canAssignTo\n     assertTrue(NUMBER_TYPE.canAssignTo(ALL_TYPE));\n     assertFalse(NUMBER_TYPE.isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         NUMBER_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE),\n         NUMBER_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(NUMBER_TYPE,\n+    assertTypeEquals(NUMBER_TYPE,\n         NUMBER_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createUnionType(NUMBER_TYPE, functionType),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, functionType),\n         NUMBER_TYPE.getLeastSupertype(functionType));\n-    assertEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE),\n         NUMBER_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(createUnionType(NUMBER_TYPE, DATE_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, DATE_TYPE),\n         NUMBER_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE),\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE),\n         NUMBER_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // matchesXxx\n             createNullableType(STRING_OBJECT_TYPE)));\n \n     // getLeastSupertype\n-    assertEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE));\n-    assertEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createNullableType(STRING_OBJECT_TYPE),\n+    assertTypeEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE));\n+    assertTypeEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertTypeEquals(createNullableType(STRING_OBJECT_TYPE),\n         NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createNullableType(NUMBER_TYPE),\n+    assertTypeEquals(createNullableType(NUMBER_TYPE),\n         NULL_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createNullableType(functionType),\n+    assertTypeEquals(createNullableType(functionType),\n         NULL_TYPE.getLeastSupertype(functionType));\n-    assertEquals(createNullableType(OBJECT_TYPE),\n+    assertTypeEquals(createNullableType(OBJECT_TYPE),\n         NULL_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(createNullableType(DATE_TYPE),\n+    assertTypeEquals(createNullableType(DATE_TYPE),\n         NULL_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(createNullableType(REGEXP_TYPE),\n+    assertTypeEquals(createNullableType(REGEXP_TYPE),\n         NULL_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // matchesXxx\n     assertTrue(createNullableType(DATE_TYPE).isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         DATE_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE),\n+    assertTypeEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE),\n         DATE_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(DATE_TYPE, NUMBER_TYPE),\n         DATE_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, functionType),\n+    assertTypeEquals(createUnionType(DATE_TYPE, functionType),\n         DATE_TYPE.getLeastSupertype(functionType));\n-    assertEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n+    assertTypeEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertTypeEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n         DATE_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // getPropertyType\n     assertTrue(createNullableType(REGEXP_TYPE).isNullable());\n \n     // getLeastSupertype\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         REGEXP_TYPE.getLeastSupertype(ALL_TYPE));\n-    assertEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE),\n+    assertTypeEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE),\n         REGEXP_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n-    assertEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE),\n         REGEXP_TYPE.getLeastSupertype(NUMBER_TYPE));\n-    assertEquals(createUnionType(REGEXP_TYPE, functionType),\n+    assertTypeEquals(createUnionType(REGEXP_TYPE, functionType),\n         REGEXP_TYPE.getLeastSupertype(functionType));\n-    assertEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE));\n-    assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n+    assertTypeEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n         REGEXP_TYPE.getLeastSupertype(DATE_TYPE));\n-    assertEquals(REGEXP_TYPE,\n+    assertTypeEquals(REGEXP_TYPE,\n         REGEXP_TYPE.getLeastSupertype(REGEXP_TYPE));\n \n     // getPropertyType\n         REGEXP_TYPE.getPropertyType(\"test\"));\n     assertReturnTypeEquals(STRING_TYPE,\n         REGEXP_TYPE.getPropertyType(\"toString\"));\n-    assertEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType(\"source\"));\n-    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"global\"));\n-    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"ignoreCase\"));\n-    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"multiline\"));\n-    assertEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType(\"lastIndex\"));\n+    assertTypeEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType(\"source\"));\n+    assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"global\"));\n+    assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"ignoreCase\"));\n+    assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"multiline\"));\n+    assertTypeEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType(\"lastIndex\"));\n \n     // matchesXxx\n     assertFalse(REGEXP_TYPE.matchesInt32Context());\n     assertTrue(STRING_OBJECT_TYPE.isInstanceType());\n \n     // autoboxesTo\n-    assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n+    assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n \n     // unboxesTo\n-    assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n+    assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n \n     // canAssignTo\n     assertTrue(STRING_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n         STRING_OBJECT_TYPE.getPropertyType(\"toUpperCase\"));\n     assertReturnTypeEquals(STRING_TYPE,\n         STRING_OBJECT_TYPE.getPropertyType(\"toLocaleUpperCase\"));\n-    assertEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType(\"length\"));\n \n     // matchesXxx\n     assertTrue(STRING_OBJECT_TYPE.matchesInt32Context());\n     assertFalse(STRING_TYPE.isInstanceType());\n \n     // autoboxesTo\n-    assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n+    assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n \n     // unboxesTo\n-    assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n+    assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n \n     // canAssignTo\n     assertTrue(STRING_TYPE.canAssignTo(ALL_TYPE));\n     assertEquals(\"string\", STRING_TYPE.toString());\n \n     // findPropertyType\n-    assertEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType(\"length\"));\n     assertEquals(null, STRING_TYPE.findPropertyType(\"unknownProperty\"));\n \n     Asserts.assertResolvesToSame(STRING_TYPE);\n   private void assertReturnTypeEquals(JSType expectedReturnType,\n       JSType function) {\n     assertTrue(function instanceof FunctionType);\n-    assertEquals(expectedReturnType, ((FunctionType) function).getReturnType());\n+    assertTypeEquals(expectedReturnType,\n+        ((FunctionType) function).getReturnType());\n   }\n \n \n     assertPropertyTypeInferred(functionInst, \"prototype\");\n \n     // misc\n-    assertEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor());\n-    assertEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype());\n-    assertEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType());\n+    assertTypeEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor());\n+    assertTypeEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype());\n+    assertTypeEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType());\n \n     Asserts.assertResolvesToSame(functionInst);\n   }\n     JSType subRecordType = builder.build();\n \n     JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n-    assertEquals(leastSupertype, recordType);\n+    assertTypeEquals(leastSupertype, recordType);\n   }\n \n   public void testRecordTypeLeastSuperType2() {\n     builder = new RecordTypeBuilder(registry);\n     builder.addProperty(\"b\", STRING_TYPE);\n \n-    assertEquals(leastSupertype, builder.build());\n+    assertTypeEquals(leastSupertype, builder.build());\n   }\n \n   public void testRecordTypeLeastSuperType3() {\n     JSType subRecordType = builder.build();\n \n     JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n-    assertEquals(leastSupertype, OBJECT_TYPE);\n+    assertTypeEquals(leastSupertype, OBJECT_TYPE);\n   }\n \n   public void testRecordTypeLeastSuperType4() {\n     JSType leastSupertype = recordType.getLeastSupertype(OBJECT_TYPE);\n-    assertEquals(leastSupertype, OBJECT_TYPE);\n+    assertTypeEquals(leastSupertype, OBJECT_TYPE);\n   }\n \n   /**\n     builder.addProperty(\"a\", NUMBER_TYPE);\n     builder.addProperty(\"b\", STRING_TYPE);\n \n-    assertEquals(subtype, builder.build());\n+    assertTypeEquals(subtype, builder.build());\n   }\n \n   public void testRecordTypeGreatestSubType2() {\n     builder.addProperty(\"a\", NUMBER_TYPE);\n     builder.addProperty(\"b\", STRING_TYPE);\n \n-    assertEquals(subtype, builder.build());\n+    assertTypeEquals(subtype, builder.build());\n   }\n \n   public void testRecordTypeGreatestSubType3() {\n     builder.addProperty(\"b\", STRING_TYPE);\n     builder.addProperty(\"c\", STRING_TYPE);\n \n-    assertEquals(subtype, builder.build());\n+    assertTypeEquals(subtype, builder.build());\n   }\n \n   public void testRecordTypeGreatestSubType4() {\n     JSType subRecordType = builder.build();\n \n     JSType subtype = recordType.getGreatestSubtype(subRecordType);\n-    assertEquals(subtype, NO_TYPE);\n+    assertTypeEquals(subtype, NO_TYPE);\n   }\n \n   public void testRecordTypeGreatestSubType5() {\n \n     JSType recordType = builder.build();\n \n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n \n     // if Function is given a property \"a\" of type \"string\", then it's\n     // a subtype of the record type {a: string}.\n     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, false);\n-    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+    assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n-    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+    assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n   }\n \n \n     JSType recordType = builder.build();\n \n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n-    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+    assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n-    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+    assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n   }\n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // not a subtype of the record type {x: number}.\n     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n   }\n   public void testRecordTypeGreatestSubType8() {\n \n     JSType recordType = builder.build();\n \n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n \n     // if goog.Bar is given a property \"xyz\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n     googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, false);\n \n-    assertEquals(googBar,\n+    assertTypeEquals(googBar,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n-    assertEquals(googBar,\n+    assertTypeEquals(googBar,\n                  U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n \n     ObjectType googBarInst = googBar.getInstanceType();\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(googBarInst));\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n                  googBarInst.getGreatestSubtype(recordType));\n   }\n \n         applyType instanceof FunctionType);\n \n     FunctionType applyFn = (FunctionType) applyType;\n-    assertEquals(\"apply should have the same return type as its function\",\n+    assertTypeEquals(\"apply should have the same return type as its function\",\n         NUMBER_TYPE, applyFn.getReturnType());\n \n     Node params = applyFn.getParametersNode();\n     assertEquals(\"apply takes two args\",\n         2, params.getChildCount());\n-    assertEquals(\"apply's first arg is the @this type\",\n+    assertTypeEquals(\"apply's first arg is the @this type\",\n         registry.createOptionalNullableType(DATE_TYPE),\n         params.getFirstChild().getJSType());\n-    assertEquals(\"apply's second arg is an Array\",\n+    assertTypeEquals(\"apply's second arg is an Array\",\n         registry.createOptionalNullableType(OBJECT_TYPE),\n         params.getLastChild().getJSType());\n     assertTrue(\"apply's args must be optional\",\n         callType instanceof FunctionType);\n \n     FunctionType callFn = (FunctionType) callType;\n-    assertEquals(\"call should have the same return type as its function\",\n+    assertTypeEquals(\"call should have the same return type as its function\",\n         NUMBER_TYPE, callFn.getReturnType());\n \n     Node params = callFn.getParametersNode();\n     assertEquals(\"call takes one argument in this case\",\n         1, params.getChildCount());\n-    assertEquals(\"call's first arg is the @this type\",\n+    assertTypeEquals(\"call's first arg is the @this type\",\n         registry.createOptionalNullableType(DATE_TYPE),\n         params.getFirstChild().getJSType());\n     assertTrue(\"call's args must be optional\",\n         FunctionType typeA = allFunctions.get(i);\n         FunctionType typeB = allFunctions.get(j);\n         assertEquals(String.format(\"equals(%s, %s)\", typeA, typeB),\n-            i == j, typeA.equals(typeB));\n+            i == j, typeA.isEquivalentTo(typeB));\n \n         // For this particular set of functions, the functions are subtypes\n         // of each other iff they have the same \"this\" type.\n         assertEquals(String.format(\"isSubtype(%s, %s)\", typeA, typeB),\n-            typeA.getTypeOfThis().equals(typeB.getTypeOfThis()),\n+            typeA.getTypeOfThis().isEquivalentTo(typeB.getTypeOfThis()),\n             typeA.isSubtype(typeB));\n \n         if (i == j) {\n-          assertEquals(typeA, typeA.getLeastSupertype(typeB));\n-          assertEquals(typeA, typeA.getGreatestSubtype(typeB));\n+          assertTypeEquals(typeA, typeA.getLeastSupertype(typeB));\n+          assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB));\n         } else {\n-          assertEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n+          assertTypeEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n               U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n-          assertEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n+          assertTypeEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n               NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n         }\n       }\n         FunctionType typeA = allFunctions.get(i);\n         FunctionType typeB = allFunctions.get(j);\n         assertEquals(String.format(\"equals(%s, %s)\", typeA, typeB),\n-            i == j, typeA.equals(typeB));\n+            i == j, typeA.isEquivalentTo(typeB));\n \n         // TODO(nicksantos): This formulation of least subtype and greatest\n         // supertype is a bit loose. We might want to tighten it up later.\n         if (i == j) {\n-          assertEquals(typeA, typeA.getLeastSupertype(typeB));\n-          assertEquals(typeA, typeA.getGreatestSubtype(typeB));\n+          assertTypeEquals(typeA, typeA.getLeastSupertype(typeB));\n+          assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB));\n         } else {\n-          assertEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n+          assertTypeEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n               U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n-          assertEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n+          assertTypeEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n               NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n         }\n       }\n     assertFalse(BOOLEAN_TYPE.isInstanceType());\n \n     // autoboxesTo\n-    assertEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo());\n+    assertTypeEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo());\n \n     // unboxesTo\n-    assertEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo());\n+    assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo());\n \n     // canAssignTo\n     assertTrue(BOOLEAN_TYPE.canAssignTo(ALL_TYPE));\n     EnumElementType stringEnum =\n         new EnumType(registry, \"Enum\", STRING_TYPE).getElementsType();\n \n-    assertEquals(UNKNOWN_TYPE, stringEnum.getPropertyType(\"length\"));\n-    assertEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n+    assertTypeEquals(UNKNOWN_TYPE, stringEnum.getPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n     assertEquals(false, stringEnum.hasProperty(\"length\"));\n-    assertEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo());\n+    assertTypeEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo());\n     assertNull(stringEnum.getConstructor());\n \n     Asserts.assertResolvesToSame(stringEnum);\n     EnumElementType stringEnum =\n         new EnumType(registry, \"Enum\", STRING_OBJECT_TYPE).getElementsType();\n \n-    assertEquals(NUMBER_TYPE, stringEnum.getPropertyType(\"length\"));\n-    assertEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, stringEnum.getPropertyType(\"length\"));\n+    assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n     assertEquals(true, stringEnum.hasProperty(\"length\"));\n-    assertEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor());\n+    assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor());\n   }\n \n \n     assertTypeCanAssignToItself(namedGoogBar);\n     googBar.canAssignTo(namedGoogBar);\n     namedGoogBar.canAssignTo(googBar);\n-    assertTrue(googBar.equals(googBar));\n-    assertFalse(googBar.equals(googSubBar));\n+    assertTrue(googBar.isEquivalentTo(googBar));\n+    assertFalse(googBar.isEquivalentTo(googSubBar));\n \n     Asserts.assertResolvesToSame(googBar);\n     Asserts.assertResolvesToSame(googSubBar);\n     ObjectType prototype = googBar.getPrototype();\n     ObjectType instance = googBar.getInstanceType();\n \n-    assertEquals(instance.getImplicitPrototype(), prototype);\n+    assertTypeEquals(instance.getImplicitPrototype(), prototype);\n \n     // Test declarations.\n     assertTrue(\n         prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n     assertFalse(\n         instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n-    assertEquals(NUMBER_TYPE, instance.getPropertyType(\"declared\"));\n+    assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"declared\"));\n \n     // Test inferring different types.\n     assertTrue(\n         prototype.defineInferredProperty(\"inferred1\", STRING_TYPE, false));\n     assertTrue(\n         prototype.defineInferredProperty(\"inferred1\", NUMBER_TYPE, false));\n-    assertEquals(\n+    assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred1\"));\n \n         prototype.defineInferredProperty(\"inferred2\", STRING_TYPE, false));\n     assertTrue(\n         instance.defineInferredProperty(\"inferred2\", NUMBER_TYPE, false));\n-    assertEquals(\n+    assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred2\"));\n \n         prototype.defineInferredProperty(\"prop\", STRING_TYPE, false));\n     assertTrue(\n         instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, false));\n-    assertEquals(NUMBER_TYPE, instance.getPropertyType(\"prop\"));\n-    assertEquals(STRING_TYPE, prototype.getPropertyType(\"prop\"));\n+    assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"prop\"));\n+    assertTypeEquals(STRING_TYPE, prototype.getPropertyType(\"prop\"));\n   }\n \n   /**\n     assertNull(namedGoogBar.autoboxesTo());\n \n     // properties\n-    assertEquals(DATE_TYPE, namedGoogBar.getPropertyType(\"date\"));\n+    assertTypeEquals(DATE_TYPE, namedGoogBar.getPropertyType(\"date\"));\n \n     assertFalse(namedGoogBar.isNativeObjectType());\n     assertFalse(namedGoogBar.getImplicitPrototype().isNativeObjectType());\n    */\n   public void testPrototypeChaining() throws Exception {\n     // equals\n-    assertEquals(ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         OBJECT_TYPE);\n-    assertEquals(BOOLEAN_OBJECT_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        BOOLEAN_OBJECT_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), OBJECT_TYPE);\n-    assertEquals(DATE_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        DATE_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         OBJECT_TYPE);\n-    assertEquals(ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         OBJECT_TYPE);\n-    assertEquals(EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         ERROR_TYPE);\n-    assertEquals(NUMBER_OBJECT_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        NUMBER_OBJECT_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), OBJECT_TYPE);\n-    assertEquals(URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         ERROR_TYPE);\n-    assertEquals(RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         ERROR_TYPE);\n-    assertEquals(REFERENCE_ERROR_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        REFERENCE_ERROR_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), ERROR_TYPE);\n-    assertEquals(STRING_OBJECT_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        STRING_OBJECT_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), OBJECT_TYPE);\n-    assertEquals(REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+    assertTypeEquals(\n+        REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(),\n         OBJECT_TYPE);\n-    assertEquals(SYNTAX_ERROR_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        SYNTAX_ERROR_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), ERROR_TYPE);\n-    assertEquals(TYPE_ERROR_TYPE.getImplicitPrototype().\n+    assertTypeEquals(\n+        TYPE_ERROR_TYPE.getImplicitPrototype().\n         getImplicitPrototype(), ERROR_TYPE);\n \n     // not same\n    */\n   public void testInstanceFunctionChaining() throws Exception {\n     // Array\n-    assertEquals(ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor());\n+    assertTypeEquals(\n+        ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor());\n \n     // Boolean\n-    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(\n+        BOOLEAN_OBJECT_FUNCTION_TYPE,\n         BOOLEAN_OBJECT_TYPE.getConstructor());\n \n     // Date\n-    assertEquals(DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor());\n+    assertTypeEquals(\n+        DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor());\n \n     // Error\n-    assertEquals(ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor());\n+    assertTypeEquals(\n+        ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor());\n \n     // EvalError\n-    assertEquals(EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor());\n+    assertTypeEquals(\n+        EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor());\n \n     // Number\n-    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(\n+        NUMBER_OBJECT_FUNCTION_TYPE,\n         NUMBER_OBJECT_TYPE.getConstructor());\n \n     // Object\n-    assertEquals(OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor());\n+    assertTypeEquals(\n+        OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor());\n \n     // RangeError\n-    assertEquals(RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor());\n+    assertTypeEquals(\n+        RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor());\n \n     // ReferenceError\n-    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(\n+        REFERENCE_ERROR_FUNCTION_TYPE,\n         REFERENCE_ERROR_TYPE.getConstructor());\n \n     // RegExp\n-    assertEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor());\n+    assertTypeEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor());\n \n     // String\n-    assertEquals(STRING_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(\n+        STRING_OBJECT_FUNCTION_TYPE,\n         STRING_OBJECT_TYPE.getConstructor());\n \n     // SyntaxError\n-    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(\n+        SYNTAX_ERROR_FUNCTION_TYPE,\n         SYNTAX_ERROR_TYPE.getConstructor());\n \n     // TypeError\n-    assertEquals(TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor());\n+    assertTypeEquals(\n+        TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor());\n \n     // URIError\n-    assertEquals(URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor());\n+    assertTypeEquals(\n+        URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor());\n   }\n \n   /**\n         JSType aOnB = typeA.getLeastSupertype(typeB);\n         JSType bOnA = typeB.getLeastSupertype(typeA);\n \n-        // Use a custom assert message instead of the normal assertEquals,\n+        // Use a custom assert message instead of the normal assertTypeEquals,\n         // to make it more helpful.\n         assertTrue(\n             String.format(\"getLeastSupertype not symmetrical:\\n\" +\n                 \"a.getLeastSupertype(b): %s\\n\" +\n                 \"b.getLeastSupertype(a): %s\\n\",\n                 typeA, typeB, aOnB, bOnA),\n-            aOnB.equals(bOnA));\n+            aOnB.isEquivalentTo(bOnA));\n       }\n     }\n   }\n \n   public void testWeirdBug() {\n-    assertFalse(googBar.equals(googBar.getInstanceType()));\n-    assertFalse(googBar.getInstanceType().equals(googBar));\n+    assertFalse(googBar.isEquivalentTo(googBar.getInstanceType()));\n+    assertFalse(googBar.getInstanceType().isEquivalentTo(googBar));\n     assertFalse(googBar.isSubtype(googBar.getInstanceType()));\n     assertFalse(googBar.getInstanceType().isSubtype(googBar));\n   }\n         JSType aOnB = typeA.getGreatestSubtype(typeB);\n         JSType bOnA = typeB.getGreatestSubtype(typeA);\n \n-        // Use a custom assert message instead of the normal assertEquals,\n+        // Use a custom assert message instead of the normal assertTypeEquals,\n         // to make it more helpful.\n         assertTrue(\n             String.format(\"getGreatestSubtype not symmetrical:\\n\" +\n                 \"a.getGreatestSubtype(b): %s\\n\" +\n                 \"b.getGreatestSubtype(a): %s\\n\",\n                 typeA, typeB, aOnB, bOnA),\n-            aOnB.equals(bOnA));\n+            aOnB.isEquivalentTo(bOnA));\n       }\n     }\n   }\n   public void testReflexivityOfLeastSupertype() {\n     List<JSType> list = getTypesToTestForSymmetry();\n     for (JSType type : list) {\n-      assertEquals(\"getLeastSupertype not reflexive\",\n+      assertTypeEquals(\"getLeastSupertype not reflexive\",\n           type, type.getLeastSupertype(type));\n     }\n   }\n   public void testReflexivityOfGreatestSubtype() {\n     List<JSType> list = getTypesToTestForSymmetry();\n     for (JSType type : list) {\n-      assertEquals(\"getGreatestSubtype not reflexive\",\n+      assertTypeEquals(\"getGreatestSubtype not reflexive\",\n           type, type.getGreatestSubtype(type));\n     }\n   }\n     // (undefined,function(?):?) and ? unresolved named type\n     JSType expected = registry.createUnionType(\n         unresolvedNamedType, U2U_FUNCTION_TYPE);\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         unresolvedNamedType.getLeastSupertype(U2U_FUNCTION_TYPE));\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         U2U_FUNCTION_TYPE.getLeastSupertype(unresolvedNamedType));\n     assertEquals(\"(function (...[?]): ?|not.resolved.named.type)\",\n         expected.toString());\n   public void testLeastSupertypeUnresolvedNamedType2() {\n     JSType expected = registry.createUnionType(\n         unresolvedNamedType, UNKNOWN_TYPE);\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         unresolvedNamedType.getLeastSupertype(UNKNOWN_TYPE));\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType));\n-    assertEquals(UNKNOWN_TYPE, expected);\n+    assertTypeEquals(UNKNOWN_TYPE, expected);\n   }\n \n   public void testLeastSupertypeUnresolvedNamedType3() {\n     JSType expected = registry.createUnionType(\n         unresolvedNamedType, CHECKED_UNKNOWN_TYPE);\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         unresolvedNamedType.getLeastSupertype(CHECKED_UNKNOWN_TYPE));\n-    assertEquals(expected,\n+    assertTypeEquals(expected,\n         CHECKED_UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType));\n-    assertEquals(CHECKED_UNKNOWN_TYPE, expected);\n+    assertTypeEquals(CHECKED_UNKNOWN_TYPE, expected);\n   }\n \n   /** Tests the subclass of an unresolve named type */\n     // test == if references are equal\n     NamedType a = new NamedType(jst, \"type1\", \"source\", 1, 0);\n     NamedType b = new NamedType(jst, \"type1\", \"source\", 1, 0);\n-    assertTrue(a.equals(b));\n+    assertTrue(a.isEquivalentTo(b));\n \n     // test != to non-NamedType\n     assertFalse(a.equals(\"type1\"));\n \n     // test == instance of referenced type\n-    assertTrue(namedGoogBar.equals(googBar.getInstanceType()));\n-    assertTrue(googBar.getInstanceType().equals(namedGoogBar));\n+    assertTrue(namedGoogBar.isEquivalentTo(googBar.getInstanceType()));\n+    assertTrue(googBar.getInstanceType().isEquivalentTo(namedGoogBar));\n   }\n \n   /**\n     registry.declareType(\"typeB\", realB);\n \n     assertEquals(a.hashCode(), realA.hashCode());\n-    assertEquals(a, realA);\n+    assertTypeEquals(a, realA);\n     assertEquals(b.hashCode(), realB.hashCode());\n-    assertEquals(b, realB);\n+    assertTypeEquals(b, realB);\n \n     a.resolve(null, null);\n     b.resolve(null, null);\n     assertTrue(a.isResolved());\n     assertTrue(b.isResolved());\n     assertEquals(a.hashCode(), realA.hashCode());\n-    assertEquals(a, realA);\n+    assertTypeEquals(a, realA);\n     assertEquals(b.hashCode(), realB.hashCode());\n-    assertEquals(b, realB);\n+    assertTypeEquals(b, realB);\n \n     JSType resolvedA = Asserts.assertValidResolve(a);\n     assertNotSame(resolvedA, a);\n     registry.forwardDeclareType(\"typeA\");\n \n     assertEquals(a.hashCode(), b.hashCode());\n-    assertEquals(a, b);\n+    assertTypeEquals(a, b);\n \n     a.resolve(null, EMPTY_SCOPE);\n \n     assertFalse(b.isResolved());\n \n     assertEquals(a.hashCode(), b.hashCode());\n-    assertEquals(a, b);\n-\n-    assertFalse(a.equals(UNKNOWN_TYPE));\n-    assertFalse(b.equals(UNKNOWN_TYPE));\n+    assertTypeEquals(a, b);\n+\n+    assertFalse(a.isEquivalentTo(UNKNOWN_TYPE));\n+    assertFalse(b.isEquivalentTo(UNKNOWN_TYPE));\n   }\n \n   public void testForwardDeclaredNamedType() {\n     NamedType a = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n     registry.forwardDeclareType(\"typeA\");\n \n-    assertEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE));\n-    assertEquals(CHECKED_UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE));\n+    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n         a.getLeastSupertype(CHECKED_UNKNOWN_TYPE));\n-    assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a));\n-    assertEquals(CHECKED_UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a));\n+    assertTypeEquals(CHECKED_UNKNOWN_TYPE,\n         CHECKED_UNKNOWN_TYPE.getLeastSupertype(a));\n   }\n \n    * Tests {@link JSType#getGreatestSubtype(JSType)} on simple types.\n    */\n   public void testGreatestSubtypeSimpleTypes() {\n-    assertEquals(ARRAY_TYPE,\n+    assertTypeEquals(ARRAY_TYPE,\n         ARRAY_TYPE.getGreatestSubtype(ALL_TYPE));\n-    assertEquals(ARRAY_TYPE,\n+    assertTypeEquals(ARRAY_TYPE,\n         ALL_TYPE.getGreatestSubtype(ARRAY_TYPE));\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n         REGEXP_TYPE.getGreatestSubtype(NO_OBJECT_TYPE));\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n         NO_OBJECT_TYPE.getGreatestSubtype(REGEXP_TYPE));\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n         ARRAY_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE));\n-    assertEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE));\n-    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(functionType));\n-    assertEquals(STRING_OBJECT_TYPE,\n+    assertTypeEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE));\n+    assertTypeEquals(NO_OBJECT_TYPE,\n+        ARRAY_TYPE.getGreatestSubtype(functionType));\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n         STRING_OBJECT_TYPE.getGreatestSubtype(OBJECT_TYPE));\n-    assertEquals(STRING_OBJECT_TYPE,\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n         OBJECT_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE));\n-    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(DATE_TYPE));\n-    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE));\n-    assertEquals(EVAL_ERROR_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n+        ARRAY_TYPE.getGreatestSubtype(DATE_TYPE));\n+    assertTypeEquals(NO_OBJECT_TYPE,\n+        ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE));\n+    assertTypeEquals(EVAL_ERROR_TYPE,\n         ERROR_TYPE.getGreatestSubtype(EVAL_ERROR_TYPE));\n-    assertEquals(EVAL_ERROR_TYPE,\n+    assertTypeEquals(EVAL_ERROR_TYPE,\n         EVAL_ERROR_TYPE.getGreatestSubtype(ERROR_TYPE));\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NULL_TYPE.getGreatestSubtype(ERROR_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         NUMBER_TYPE.getGreatestSubtype(UNKNOWN_TYPE));\n   }\n \n         JSType typeJ = typeChain.get(j);\n \n         if (i == j) {\n-          assertTrue(typeI + \" should equal itself\", typeI.equals(typeI));\n+          assertTrue(typeI + \" should equal itself\",\n+              typeI.isEquivalentTo(typeI));\n         } else {\n           assertFalse(typeI + \" should not equal \" + typeJ,\n-              typeI.equals(typeJ));\n+              typeI.isEquivalentTo(typeJ));\n         }\n \n         if (checkSubtyping) {\n \n           JSType expectedSupremum = i < j ? typeI : typeJ;\n           JSType expectedInfimum = i > j ? typeI : typeJ;\n-          assertEquals(\n+          assertTypeEquals(\n               expectedSupremum + \" should be the least supertype of \" + typeI +\n               \" and \" + typeJ,\n               expectedSupremum, typeI.getLeastSupertype(typeJ));\n-          assertEquals(\n+          assertTypeEquals(\n               expectedInfimum + \" should be the greatest subtype of \" + typeI +\n               \" and \" + typeJ,\n               expectedInfimum, typeI.getGreatestSubtype(typeJ));\n   @SuppressWarnings(\"checked\")\n       public void testRestrictedTypeGivenToBoolean() {\n     // simple cases\n-    assertEquals(BOOLEAN_TYPE,\n+    assertTypeEquals(BOOLEAN_TYPE,\n         BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(BOOLEAN_TYPE,\n+    assertTypeEquals(BOOLEAN_TYPE,\n         BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NULL_TYPE,\n+    assertTypeEquals(NULL_TYPE,\n         NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(NUMBER_TYPE,\n+    assertTypeEquals(NUMBER_TYPE,\n         NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NUMBER_TYPE,\n+    assertTypeEquals(NUMBER_TYPE,\n         NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(STRING_TYPE,\n+    assertTypeEquals(STRING_TYPE,\n         STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(STRING_TYPE,\n+    assertTypeEquals(STRING_TYPE,\n         STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(STRING_OBJECT_TYPE,\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n         STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(VOID_TYPE,\n+    assertTypeEquals(VOID_TYPE,\n         VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n         NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NO_TYPE,\n+    assertTypeEquals(NO_TYPE,\n         NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(ALL_TYPE,\n+    assertTypeEquals(ALL_TYPE,\n         ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n \n     // unions\n     UnionType nullableStringValue =\n         (UnionType) createNullableType(STRING_TYPE);\n-    assertEquals(STRING_TYPE,\n+    assertTypeEquals(STRING_TYPE,\n         nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(nullableStringValue,\n+    assertTypeEquals(nullableStringValue,\n         nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));\n \n     UnionType nullableStringObject =\n         (UnionType) createNullableType(STRING_OBJECT_TYPE);\n-    assertEquals(STRING_OBJECT_TYPE,\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n         nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));\n-    assertEquals(NULL_TYPE,\n+    assertTypeEquals(NULL_TYPE,\n         nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));\n   }\n \n         ObjectType objType = (ObjectType) type;\n         objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false);\n         objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false);\n-        assertEquals(type,\n+        assertTypeEquals(type,\n             registry.getGreatestSubtypeWithProperty(type, propName));\n         assertEquals(Sets.newHashSet(type),\n             registry.getTypesWithProperty(propName));\n-        assertEquals(NO_TYPE,\n+        assertTypeEquals(NO_TYPE,\n             registry.getGreatestSubtypeWithProperty(type, \"GRRR\"));\n         allObjects.add(type);\n       }\n \n     derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n \n-    assertEquals(derived1,\n+    assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n-    assertEquals(NO_OBJECT_TYPE,\n+    assertTypeEquals(NO_OBJECT_TYPE,\n         registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n \n     derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n \n-    assertEquals(derived1,\n+    assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n-    assertEquals(derived2,\n+    assertTypeEquals(derived2,\n         registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n   }\n \n     foo.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n     bar.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n \n-    assertEquals(bar,\n+    assertTypeEquals(bar,\n         registry.getGreatestSubtypeWithProperty(namedGoogBar, \"propz\"));\n   }\n \n     TypePair p21 = t2.getTypesUnderEquality(t1);\n \n     // t1Eq\n-    assertEquals(t1Eq, p12.typeA);\n-    assertEquals(t1Eq, p21.typeB);\n+    assertTypeEquals(t1Eq, p12.typeA);\n+    assertTypeEquals(t1Eq, p21.typeB);\n \n     // t2Eq\n-    assertEquals(t2Eq, p12.typeB);\n-    assertEquals(t2Eq, p21.typeA);\n+    assertTypeEquals(t2Eq, p12.typeB);\n+    assertTypeEquals(t2Eq, p21.typeA);\n   }\n \n   @SuppressWarnings(\"checked\")\n     TypePair p21 = t2.getTypesUnderInequality(t1);\n \n     // t1Eq\n-    assertEquals(t1Eq, p12.typeA);\n-    assertEquals(t1Eq, p21.typeB);\n+    assertTypeEquals(t1Eq, p12.typeA);\n+    assertTypeEquals(t1Eq, p21.typeB);\n \n     // t2Eq\n-    assertEquals(t2Eq, p12.typeB);\n-    assertEquals(t2Eq, p21.typeA);\n+    assertTypeEquals(t2Eq, p12.typeB);\n+    assertTypeEquals(t2Eq, p21.typeA);\n   }\n \n \n   public void testCreateAnonymousObjectType() throws Exception {\n     // anonymous\n     ObjectType anonymous = registry.createAnonymousObjectType();\n-    assertEquals(OBJECT_TYPE, anonymous.getImplicitPrototype());\n+    assertTypeEquals(OBJECT_TYPE, anonymous.getImplicitPrototype());\n     assertNull(anonymous.getReferenceName());\n     assertEquals(\"{}\", anonymous.toString());\n   }\n     // simple\n     ObjectType subDate =\n         registry.createObjectType(DATE_TYPE.getImplicitPrototype());\n-    assertEquals(DATE_TYPE.getImplicitPrototype(),\n+    assertTypeEquals(DATE_TYPE.getImplicitPrototype(),\n         subDate.getImplicitPrototype());\n     assertNull(subDate.getReferenceName());\n     assertEquals(\"{...}\", subDate.toString());\n     // name, node, prototype\n     ObjectType subError = registry.createObjectType(\"Foo\", null,\n         ERROR_TYPE.getImplicitPrototype());\n-    assertEquals(ERROR_TYPE.getImplicitPrototype(),\n+    assertTypeEquals(ERROR_TYPE.getImplicitPrototype(),\n         subError.getImplicitPrototype());\n     assertEquals(\"Foo\", subError.getReferenceName());\n   }\n     namedGoogBar.setPropertyJSDocInfo(\"X\", info, false);\n     assertTrue(namedGoogBar.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n     assertPropertyTypeInferred(namedGoogBar, \"X\");\n-    assertEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType(\"X\"));\n+    assertTypeEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType(\"X\"));\n   }\n \n   public void testGetAndSetJSDocInfoWithObjectTypes() throws Exception {\n     assertFalse(sup.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n     assertEquals(Visibility.PRIVATE,\n         sup.getOwnPropertyJSDocInfo(\"X\").getVisibility());\n-    assertEquals(NUMBER_TYPE, sup.getPropertyType(\"X\"));\n+    assertTypeEquals(NUMBER_TYPE, sup.getPropertyType(\"X\"));\n     assertTrue(sub.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n     assertNull(sub.getOwnPropertyJSDocInfo(\"X\").getVisibility());\n-    assertEquals(NUMBER_TYPE, sub.getPropertyType(\"X\"));\n+    assertTypeEquals(NUMBER_TYPE, sub.getPropertyType(\"X\"));\n   }\n \n   public void testGetAndSetJSDocInfoWithNoType() throws Exception {\n   private ArrowType createArrowType(Node params, JSType retType) {\n     return registry.createArrowType(params, retType);\n   }\n+\n+  private void assertTypeEquals(JSType a, JSType b) {\n+    Asserts.assertTypeEquals(a, b);\n+  }\n+\n+  private void assertTypeEquals(String msg, JSType a, JSType b) {\n+    Asserts.assertTypeEquals(msg, a, b);\n+  }\n }", "timestamp": 1274887612, "metainfo": ""}