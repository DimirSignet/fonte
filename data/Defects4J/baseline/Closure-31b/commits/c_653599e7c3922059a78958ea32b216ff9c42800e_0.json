{"sha": "653599e7c3922059a78958ea32b216ff9c42800e", "log": "Fixup sparse array handling. - Replace sparse array annotation with EMPTY nodes. - Fix handling of arrays ending with an EMPTY node - Fix handling of arrays that are completely empty - Support PeepFoldConstant folding of arrays containing EMPTY nodes.  R=acleung DELTA=163  (53 added, 92 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=879   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n     if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n         n.getChildCount() >= 3) {\n       Node typeArray = callName.getNext().getNext();\n-      if (typeArray.getType() == Token.ARRAYLIT\n-          && !NodeUtil.isSparseArray(typeArray)) {\n+      if (typeArray.getType() == Token.ARRAYLIT) {\n         List<String> typeNames = Lists.newArrayList();\n         for (Node name = typeArray.getFirstChild(); name != null;\n              name = name.getNext()) {\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n       case Token.ARRAYLIT:\n         add(\"[\");\n-        addArrayList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n+        addArrayList(first);\n         add(\"]\");\n         break;\n \n    * slot.\n    * @param firstInList The first in the node list (chained through the next\n    * property).\n-   * @param skipIndexes If not null, then the array of skipped entries in the\n-   * array.\n-   */\n-  void addArrayList(Node firstInList, int[] skipIndexes) {\n-    int nextSlot = 0;\n-    int nextSkipSlot = 0;\n+   */\n+  void addArrayList(Node firstInList) {\n+    boolean lastWasEmpty = false;\n     for (Node n = firstInList; n != null; n = n.getNext()) {\n-      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {\n-        if (nextSlot == skipIndexes[nextSkipSlot]) {\n-          cc.listSeparator();\n-          nextSlot++;\n-          nextSkipSlot++;\n-        } else {\n-          break;\n-        }\n-      }\n       if (n != firstInList) {\n         cc.listSeparator();\n       }\n       addExpr(n, 1);\n-      nextSlot++;\n+      lastWasEmpty = n.getType() == Token.EMPTY;\n+    }\n+\n+    if (lastWasEmpty) {\n+      cc.listSeparator();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @return The string representation.\n    */\n   static String getArrayElementStringValue(Node n) {\n-    return NodeUtil.isNullOrUndefined(n) ? \"\" : getStringValue(n);\n+    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)\n+        ? \"\" : getStringValue(n);\n   }\n \n   static String arrayToString(Node literal) {\n     Node first = literal.getFirstChild();\n-    int[] skipIndexes = (int[]) literal.getProp(Node.SKIP_INDEXES_PROP);\n     StringBuilder result = new StringBuilder();\n     int nextSlot = 0;\n     int nextSkipSlot = 0;\n     for (Node n = first; n != null; n = n.getNext()) {\n-      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {\n-        if (nextSlot == skipIndexes[nextSkipSlot]) {\n-          result.append(',');\n-          nextSlot++;\n-          nextSkipSlot++;\n-        } else {\n-          break;\n-        }\n-      }\n       String childValue = getArrayElementStringValue(n);\n       if (childValue == null) {\n         return null;\n   static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n       case Token.ARRAYLIT:\n+        for (Node child = n.getFirstChild(); child != null;\n+             child = child.getNext()) {\n+          if (child.getType() != Token.EMPTY\n+              && !isLiteralValue(child, includeFunctions)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+\n       case Token.REGEXP:\n         // Return true only if all children are const.\n         for (Node child = n.getFirstChild(); child != null;\n   }\n \n   /**\n-   * Is this an sparse ARRAYLIT node\n-   */\n-  static boolean isSparseArray(Node node) {\n-    Preconditions.checkArgument(isArrayLiteral(node));\n-    int[] skipList = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n-    return skipList != null && skipList.length > 0;\n-  }\n-\n-  /**\n    * Is this node or any of its children a CALL?\n    */\n   static boolean containsCall(Node n) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     Node functionName = arrayNode.getNext();\n \n     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n-        NodeUtil.isSparseArray(arrayNode) ||\n         !functionName.getString().equals(\"join\")) {\n       return n;\n     }\n-\n-    // TODO(johnlenz): handle sparse arrays\n \n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n+      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n         if (sb == null) {\n           sb = new StringBuilder();\n         } else {\n   private Node tryFoldGetElem(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETELEM);\n \n-    if (left.getType() == Token.ARRAYLIT && !NodeUtil.isSparseArray(left)) {\n-      // TODO(johnlenz): handle sparse arrays\n-\n+    if (left.getType() == Token.ARRAYLIT) {\n       if (right.getType() != Token.NUMBER) {\n         // Sometimes people like to use complex expressions to index into\n         // arrays, or strings to index into array methods.\n         return n;\n       }\n \n+      if (elem.getType() == Token.EMPTY) {\n+        elem = NodeUtil.newUndefinedNode(elem);\n+      } else {\n+        left.removeChild(elem);\n+      }\n+\n       // Replace the entire GETELEM with the value\n-      left.removeChild(elem);\n       n.getParent().replaceChild(n, elem);\n       reportCodeChange();\n       return elem;\n       int knownLength = -1;\n       switch (left.getType()) {\n         case Token.ARRAYLIT:\n-          // TODO(johnlenz): handle sparse arrays\n-          if (NodeUtil.isSparseArray(left) || mayHaveSideEffects(left)) {\n+          if (mayHaveSideEffects(left)) {\n             // Nope, can't fold this, without handling the side-effects.\n             return n;\n           }\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n     parent.addChildToBack(node);\n \n     // iterate through all the children and look for empty elements\n-    int skipCount = 0;\n     for (JsonML child : element.getChildren()) {\n-      if (child.getType() == TagType.Empty) {\n-        skipCount++;\n-      }\n       transformElement(child, node);\n-    }\n-\n-    // if at least one empty element occurs, set up SKIP_INDEXES_PROP\n-    if (skipCount > 0) {\n-      int [] skipIndexes = new int[skipCount];\n-      int i = 0;\n-      int j = 0;\n-      for (JsonML child : element.getChildren()) {\n-        if (child.getType() == TagType.Empty) {\n-          skipIndexes[i] = j;\n-          ++i;\n-        }\n-        ++j;\n-      }\n-      node.putProp(Node.SKIP_INDEXES_PROP, skipIndexes);\n     }\n   }\n \n   private void transformEmpty(JsonML element, Node parent) {\n     switch (parent.getType()) {\n       case Token.ARRAYLIT:\n-        // nothing happens, but we make sure that the elements are\n-        // taken into account by nodeIndex\n+        parent.addChildToBack(new Node(Token.EMPTY));\n         break;\n       case Token.FUNCTION:\n         parent.addChildToBack(Node.newString(Token.NAME, \"\"));\n--- a/src/com/google/javascript/jscomp/jsonml/Writer.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Writer.java\n     JsonML element = new JsonML(TagType.ArrayExpr);\n     currentParent.appendChild(element);\n     Iterator<Node> it = node.children().iterator();\n-    int[] skipIndexes = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n-    int i = 0;  // next index in new array to process\n-    int j = 0;  // next index in skip array\n-    int nextToSkip = 0;\n     while (it.hasNext()) {\n-      while (skipIndexes != null && j < skipIndexes.length) {\n-        if (i == skipIndexes[j]) {\n-          element.appendChild(new JsonML(TagType.Empty));\n-          ++i;\n-          ++j;\n-        } else {\n-          break;\n-        }\n-      }\n       processNode(it.next(), element);\n-      ++i;\n     }\n   }\n \n   }\n \n   private void processEmpty(Node node, JsonML currentParent) {\n-    currentParent.appendChild(new JsonML(TagType.EmptyStmt));\n+    if (currentParent.getType() == TagType.ArrayExpr) {\n+      // Empty expression are only found in Array literals\n+      currentParent.appendChild(new JsonML(TagType.Empty));\n+    } else {\n+      currentParent.appendChild(new JsonML(TagType.EmptyStmt));\n+    }\n   }\n \n   private void processExprResult(Node node, JsonML currentParent) {\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       }\n \n       Node node = newNode(Token.ARRAYLIT);\n-      int skipCount = 0;\n       for (AstNode child : literalNode.getElements()) {\n         Node c = transform(child);\n-        if (c.getType() == Token.EMPTY) {\n-          skipCount++;\n-        }\n         node.addChildToBack(c);\n-\n-      }\n-      if (skipCount > 0) {\n-        int[] skipIndexes = new int[skipCount];\n-        int i = 0;\n-        int j = 0;\n-        for (Node child : node.children()) {\n-          if (child.getType() == Token.EMPTY) {\n-            node.removeChild(child);\n-            skipIndexes[j] = i;\n-            j++;\n-          }\n-          i++;\n-        }\n-        node.putProp(Node.SKIP_INDEXES_PROP, skipIndexes);\n       }\n       return node;\n     }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     String result = parsePrint(\"var x\", false, false, 0, false, true);\n     assertEquals(\"'use strict';var x\", result);\n   }\n+\n+  public void testArrayLiteral() {\n+    assertPrint(\"var x = [,];\",\"var x=[,]\");\n+    assertPrint(\"var x = [,,];\",\"var x=[,,]\");\n+    assertPrint(\"var x = [,s,,];\",\"var x=[,s,,]\");\n+    assertPrint(\"var x = [,s];\",\"var x=[,s]\");\n+    assertPrint(\"var x = [s,];\",\"var x=[s]\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n   }\n \n   public void testStringJoinAddSparse() {\n-    foldSame(\"x = [,,'a'].join(',')\"); // Could be: x = ',,a'\n+    fold(\"x = [,,'a'].join(',')\", \"x = ',,a'\");\n   }\n \n   public void testStringJoinAdd() {\n   }\n \n   public void testFoldGetElem() {\n-    foldSame(\"x = [,10][0]\"); // Should be \"x = void 0\";\n+    fold(\"x = [,10][0]\", \"x = void 0\");\n     fold(\"x = [10, 20][0]\", \"x = 10\");\n     fold(\"x = [10, 20][1]\", \"x = 20\");\n     fold(\"x = [10, 20][0.5]\", \"\",\n     fold(\"x = [a,b].length\", \"x = 2\");\n \n     // Not handled yet\n-    foldSame(\"x = [,,1].length\"); // Should be \"x = 3\"\n+    fold(\"x = [,,1].length\", \"x = 3\");\n \n     // Cannot fold\n     fold(\"x = [foo(), 0].length\", \"x = [foo(),0].length\");\n--- a/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n \n     String explanation = resultAstRoot.checkTreeEquals(astRoot);\n     assertNull(\"JsonML -> AST converter returned incorect result for \" + js\n-        + \"\\n\" + explanation, explanation);\n+       + \"\\n\" + explanation, explanation);\n   }\n \n   private void testAstToJsonMLConverstion(Node astRoot, JsonML jsonmlRoot,\n   }\n \n   public void testArray() throws Exception {\n+    testConversion(\"[,]\");\n     testConversion(\"[]\");\n     testConversion(\"[function (x) {}]\");\n     testConversion(\"[[], [a, [], [[[]], 1], f([a])], 1];\");\n     testConversion(\"var x = [1, 2, 3]\");\n     testConversion(\"[, 1, Object(), , , 2]\");\n     testConversion(\"[{x: 'abc', y: 1}]\");\n+  }\n+\n+  public void testArray1() throws Exception {\n+    testConversion(\"[,]\");\n   }\n \n   public void testAssignOperators() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   }\n \n   public void testArrayLiteral2() throws Exception {\n-    parse(\"[a, , b]\");\n+    testNewParser(\"[a, , b]\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        ARRAYLIT 0\\n\" +\n+      \"            NAME a 0\\n\" +\n+      \"            EMPTY 0\\n\" +\n+      \"            NAME b 0\\n\");\n   }\n \n   public void testArrayLiteral3() throws Exception {\n   }\n \n   public void testArrayLiteral4() throws Exception {\n-    parse(\"[,,,a,,b]\");\n+    testNewParser(\"[,,,a,,b]\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        ARRAYLIT 0\\n\" +\n+      \"            EMPTY 0\\n\" +\n+      \"            EMPTY 0\\n\" +\n+      \"            EMPTY 0\\n\" +\n+      \"            NAME a 0\\n\" +\n+      \"            EMPTY 0\\n\" +\n+      \"            NAME b 0\\n\");\n   }\n \n   public void testAssignment() throws Exception {", "timestamp": 1300217609, "metainfo": ""}