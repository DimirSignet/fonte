{"sha": "cd9777586aa21be337ebcc6f20de6301c66c780f", "log": "Look into goog.provide-d strings to get accurate line number info  R=johnlenz DELTA=91  (81 added, 3 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1289   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       }\n \n       Preconditions.checkState(isNamespacePlaceholder(decl));\n-      decl.copyInformationFromForTree(getSourceInfoNode());\n+      setSourceInfo(decl);\n       return decl;\n     }\n \n      * (e.g. <code>foo.bar = {};</code>).\n      */\n     private Node makeAssignmentExprNode() {\n-      Node sourceInfoNode = getSourceInfoNode();\n       Node decl = new Node(Token.EXPR_RESULT,\n           new Node(Token.ASSIGN,\n               NodeUtil.newQualifiedNameNode(\n                   compiler.getCodingConvention(), namespace,\n-                  sourceInfoNode, namespace),\n+                  firstNode /* real source info will be filled in below */,\n+                  namespace),\n               createNamespaceLiteral()));\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n       Preconditions.checkState(isNamespacePlaceholder(decl));\n-      decl.copyInformationFromForTree(sourceInfoNode);\n+      setSourceInfo(decl);\n       return decl;\n     }\n \n     /**\n-     * Get the node to pull source info from.\n-     * On incremental compiles, this may not be the original goog.provde node.\n-     * It may be a node that's in the process of being modified.\n+     * Copy source info to the new node.\n      */\n-    private Node getSourceInfoNode() {\n+    private void setSourceInfo(Node newNode) {\n+      Node provideStringNode = getProvideStringNode();\n+      int offset = getSourceInfoOffset(provideStringNode);\n+      Node sourceInfoNode = provideStringNode == null\n+          ? firstNode : provideStringNode;\n+      newNode.copyInformationFromForTree(sourceInfoNode);\n+      if (offset != 0) {\n+        newNode.setSourcePositionForTree(\n+            newNode.getSourcePosition() + offset);\n+      }\n+    }\n+\n+    /**\n+     * Get the offset into the provide node where the symbol appears.\n+     */\n+    private int getSourceInfoOffset(Node provideStringNode) {\n+      if (provideStringNode == null) {\n+        return 0;\n+      }\n+\n+      int indexOfLastDot = namespace.lastIndexOf('.');\n+\n+      // +1 for the opening quote\n+      // +1 for the dot\n+      // if there's no dot, then the -1 index cancels it out\n+      // so elegant!\n+      return 2 + indexOfLastDot;\n+    }\n+\n+    private Node getProvideStringNode() {\n       return (firstNode.getFirstChild() != null &&\n               NodeUtil.isExprCall(firstNode)) ?\n           firstNode.getFirstChild().getLastChild() :\n-          firstNode;\n+          null;\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n   public int getCharno() {\n     return extractCharno(sourcePosition);\n+  }\n+\n+  public int getSourcePosition() {\n+    return sourcePosition;\n   }\n \n   /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n \n   public void setCharno(int charno) {\n       sourcePosition = mergeLineCharNo(getLineno(), charno);\n+  }\n+\n+  public void setSourcePositionForTree(int sourcePosition) {\n+    this.sourcePosition = sourcePosition;\n+\n+    for (Node child = getFirstChild();\n+         child != null; child = child.getNext()) {\n+      child.setSourcePositionForTree(sourcePosition);\n+    }\n   }\n \n   /**\n \n     if (getProp(SOURCENAME_PROP) == null) {\n         putProp(SOURCENAME_PROP, other.getProp(SOURCENAME_PROP));\n-        sourcePosition = other.sourcePosition;\n+      sourcePosition = other.sourcePosition;\n     }\n \n     return this;\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n   protected void setExpectedSymbolTableError(DiagnosticType type) {\n     this.expectedSymbolTableError = type;\n   }\n+\n+  /** Finds the first matching qualified name node in post-traversal order. */\n+  protected final Node findQualifiedNameNode(final String name, Node root) {\n+    final List<Node> matches = Lists.newArrayList();\n+    NodeUtil.visitPostOrder(root,\n+        new NodeUtil.Visitor() {\n+          @Override public void visit(Node n) {\n+            if (name.equals(n.getQualifiedName())) {\n+              matches.add(n);\n+            }\n+          }\n+        },\n+        Predicates.<Node>alwaysTrue());\n+    return matches.get(0);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n     test(\"goog.require('goog');\",\n          \"\", MISSING_PROVIDE_ERROR);\n   }\n+\n+  public void testSourcePositionPreservation() {\n+    test(\"goog.provide('foo.bar.baz');\",\n+         \"var foo = {};\" +\n+         \"foo.bar = {};\" +\n+         \"foo.bar.baz = {};\");\n+\n+    Node root = getLastCompiler().getRoot();\n+\n+    Node fooDecl = findQualifiedNameNode(\"foo\", root);\n+    Node fooBarDecl = findQualifiedNameNode(\"foo.bar\", root);\n+    Node fooBarBazDecl = findQualifiedNameNode(\"foo.bar.baz\", root);\n+\n+    assertEquals(1, fooDecl.getLineno());\n+    assertEquals(14, fooDecl.getCharno());\n+\n+    assertEquals(1, fooBarDecl.getLineno());\n+    assertEquals(18, fooBarDecl.getCharno());\n+\n+    assertEquals(1, fooBarBazDecl.getLineno());\n+    assertEquals(22, fooBarBazDecl.getCharno());\n+  }\n }", "timestamp": 1302132684, "metainfo": ""}