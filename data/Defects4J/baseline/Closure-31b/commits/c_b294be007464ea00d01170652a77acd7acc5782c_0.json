{"sha": "b294be007464ea00d01170652a77acd7acc5782c", "log": "Add a way to record references to things that are removed during preprocessing  R=acleung DELTA=291  (234 added, 27 deleted, 30 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2918   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     NodeTraversal.traverse(this, getRoot(), refCollector);\n     symbolTable.addSymbolsFrom(refCollector);\n \n+    PreprocessorSymbolTable preprocessorSymbolTable =\n+        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n+    if (preprocessorSymbolTable != null) {\n+      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n+    }\n+\n     symbolTable.fillNamespaceReferences();\n \n     return symbolTable;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   private GlobalNamespace namespaceForChecks = null;\n \n   /**\n+   * A symbol table for registering references that get removed during\n+   * preprocessing.\n+   */\n+  private PreprocessorSymbolTable preprocessorSymbolTable = null;\n+\n+  /**\n    * A type-tightener to share across optimization passes.\n    */\n   private TightenTypes tightenTypes = null;\n     return namespaceForChecks;\n   }\n \n+  PreprocessorSymbolTable getPreprocessorSymbolTable() {\n+    return preprocessorSymbolTable;\n+  }\n+\n   @Override\n   protected List<PassFactory> getChecks() {\n     List<PassFactory> checks = Lists.newArrayList();\n       new HotSwapPassFactory(\"processGoogScopeAliases\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+      if (options.ideMode) {\n+        preprocessorSymbolTable =\n+            new PreprocessorSymbolTable(compiler.getRoot());\n+      }\n+\n       return new ScopedAliases(\n-              compiler, options.getAliasTransformationHandler());\n+          compiler,\n+          preprocessorSymbolTable,\n+          options.getAliasTransformationHandler());\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PreprocessorSymbolTable.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.SimpleReference;\n+import com.google.javascript.rhino.jstype.SimpleSlot;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * A symbol table for references that are removed by preprocessor passes\n+ * (like {@code ProcessClosurePrimitives}).\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+final class PreprocessorSymbolTable\n+    implements StaticScope<JSType>,\n+               StaticSymbolTable<SimpleSlot,\n+                                 PreprocessorSymbolTable.Reference> {\n+\n+  /**\n+   * All preprocessor symbols are globals.\n+   */\n+  private final Map<String, SimpleSlot> symbols = Maps.newHashMap();\n+\n+  private final Multimap<String, Reference> refs =\n+      ArrayListMultimap.create();\n+\n+  private final Node root;\n+\n+  PreprocessorSymbolTable(Node root) {\n+    this.root = root;\n+  }\n+\n+  @Override\n+  public Node getRootNode() { return root; }\n+\n+  @Override\n+  public JSType getTypeOfThis() { return null; }\n+\n+  @Override\n+  public StaticScope<JSType> getParentScope() { return null; }\n+\n+  @Override\n+  public SimpleSlot getSlot(String name) {\n+    return symbols.get(name);\n+  }\n+\n+  @Override\n+  public SimpleSlot getOwnSlot(String name) {\n+    return getSlot(name);\n+  }\n+\n+  @Override\n+  public Iterable<Reference> getReferences(SimpleSlot symbol) {\n+    return Collections.unmodifiableCollection(refs.get(symbol.getName()));\n+  }\n+\n+  @Override\n+  public Iterable<SimpleSlot> getAllSymbols() {\n+    return Collections.unmodifiableCollection(symbols.values());\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getScope(SimpleSlot slot) {\n+    return this;\n+  }\n+\n+  void addReference(Node node) {\n+    String name = node.getQualifiedName();\n+    Preconditions.checkNotNull(name);\n+\n+    if (!symbols.containsKey(name)) {\n+      symbols.put(name, new SimpleSlot(name, null, true));\n+    }\n+\n+    refs.put(name, new Reference(symbols.get(name), node));\n+  }\n+\n+  static final class Reference extends SimpleReference<SimpleSlot> {\n+    Reference(SimpleSlot symbol, Node node) {\n+      super(symbol, node);\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n import java.util.List;\n import java.util.Map;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Process aliases in goog.scope blocks.\n  *\n   static final String SCOPING_METHOD_NAME = \"goog.scope\";\n \n   private final AbstractCompiler compiler;\n+  private final PreprocessorSymbolTable preprocessorSymbolTable;\n   private final AliasTransformationHandler transformationHandler;\n \n   // Errors\n       \"The local variable {0} is in a goog.scope and is not an alias.\");\n \n   ScopedAliases(AbstractCompiler compiler,\n+      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n       AliasTransformationHandler transformationHandler) {\n     this.compiler = compiler;\n+    this.preprocessorSymbolTable = preprocessorSymbolTable;\n     this.transformationHandler = transformationHandler;\n   }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (isCallToScopeMethod(n)) {\n+        if (preprocessorSymbolTable != null) {\n+          preprocessorSymbolTable.addReference(n.getFirstChild());\n+        }\n         if (!NodeUtil.isExpressionNode(parent)) {\n           report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n         }\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.SimpleReference;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n-import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.jstype.StaticSymbolTable;\n \n import java.util.Collections;\n           otherSymbolTable.getScope(otherSymbol));\n \n       StaticReference<JSType> decl = otherSymbol.getDeclaration();\n-      if (decl == null) {\n-        continue;\n-      }\n-\n-      Node declNode = decl.getNode();\n-      if (declNode == null || declNode.getStaticSourceFile() == null) {\n-        continue;\n-      }\n-\n-      Symbol mySymbol = symbols.get(declNode);\n-      if (mySymbol == null) {\n-        mySymbol = new Symbol(\n-            otherSymbol.getName(),\n-            otherSymbol.getType(),\n-            otherSymbol.isTypeInferred(),\n-            myScope);\n-        symbols.put(declNode, mySymbol);\n-        myScope.ownSymbols.put(mySymbol.getName(), mySymbol);\n-\n-        mySymbol.setDeclaration(new Reference(mySymbol, declNode));\n-      }\n-\n-      for (R otherRef : otherSymbolTable.getReferences(otherSymbol)) {\n-        mySymbol.defineReferenceAt(otherRef.getNode());\n+      Node declNode = decl == null ? null : decl.getNode();\n+      Symbol mySymbol = null;\n+      if (declNode != null && declNode.getStaticSourceFile() != null) {\n+        // If we have a declaration node, we can ensure the symbol is declared.\n+        mySymbol = symbols.get(declNode);\n+        if (mySymbol == null) {\n+          mySymbol = new Symbol(\n+              otherSymbol.getName(),\n+              otherSymbol.getType(),\n+              otherSymbol.isTypeInferred(),\n+              myScope);\n+          symbols.put(declNode, mySymbol);\n+          myScope.ownSymbols.put(mySymbol.getName(), mySymbol);\n+\n+          mySymbol.setDeclaration(new Reference(mySymbol, declNode));\n+        }\n+      } else {\n+        // If we don't have a declaration node, we won't be able to declare\n+        // a symbol in this symbol table. But we may be able to salvage the\n+        // references if we already have a symbol.\n+        mySymbol = myScope.getOwnSlot(otherSymbol.getName());\n+      }\n+\n+      if (mySymbol != null) {\n+        for (R otherRef : otherSymbolTable.getReferences(otherSymbol)) {\n+          mySymbol.defineReferenceAt(otherRef.getNode());\n+        }\n       }\n     }\n   }\n \n       if (otherScopeParent == null) {\n         // The global scope must be created before any local scopes.\n-        Preconditions.checkState(scopes.isEmpty());\n+        Preconditions.checkState(\n+            scopes.isEmpty(), \"Global scopes found at different roots\");\n       }\n \n       myScope = new SymbolScope(\n     }\n   }\n \n-  public static final class Reference implements StaticReference<JSType> {\n-    private final Symbol symbol;\n-    private final Node node;\n-\n+  public static final class Reference extends SimpleReference<Symbol> {\n     Reference(Symbol symbol, Node node) {\n-      this.symbol = symbol;\n-      this.node = node;\n-    }\n-\n-    @Override\n-    public Symbol getSymbol() {\n-      return symbol;\n-    }\n-\n-    @Override\n-    public Node getNode() {\n-      return node;\n-    }\n-\n-    @Override\n-    public StaticSourceFile getSourceFile() {\n-      return node.getStaticSourceFile();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      String sourceName = node == null ? null : node.getSourceFileName();\n-      int lineNo = node == null ? -1 : node.getLineno();\n-      return node.getQualifiedName() + \"@\" + sourceName + \":\" + lineNo;\n+      super(symbol, node);\n     }\n   }\n \n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/SimpleReference.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A simple immutable reference.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class SimpleReference<T extends StaticSlot<JSType>>\n+    implements StaticReference<JSType> {\n+  private final T symbol;\n+  private final Node node;\n+\n+  public SimpleReference(T symbol, Node node) {\n+    this.symbol = symbol;\n+    this.node = node;\n+  }\n+\n+  @Override\n+  final public T getSymbol() {\n+    return symbol;\n+  }\n+\n+  @Override\n+  final public Node getNode() {\n+    return node;\n+  }\n+\n+  @Override\n+  final public StaticSourceFile getSourceFile() {\n+    return node.getStaticSourceFile();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String sourceName = node == null ? null : node.getSourceFileName();\n+    int lineNo = node == null ? -1 : node.getLineno();\n+    return node.getQualifiedName() + \"@\" + sourceName + \":\" + lineNo;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n \n   @Override\n   protected ScopedAliases getProcessor(Compiler compiler) {\n-    return new ScopedAliases(compiler, transformationHandler);\n+    return new ScopedAliases(compiler, null, transformationHandler);\n   }\n \n   private static class TransformationHandlerSpy\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(1, Iterables.size(table.getReferences(googDomHelper)));\n   }\n \n+  public void testGoogScopeReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {};\" +\n+        \"goog.scope = function() {};\" +\n+        \"goog.scope(function() {});\");\n+    Symbol googScope = getGlobalVar(table, \"goog.scope\");\n+    assertNotNull(googScope);\n+    assertEquals(2, Iterables.size(table.getReferences(googScope)));\n+  }\n+\n   public void testGlobalVarInExterns() throws Exception {\n     SymbolTable table = createSymbolTable(\"customExternFn(1);\");\n     Symbol fn = getGlobalVar(table, \"customExternFn\");", "timestamp": 1312581644, "metainfo": ""}