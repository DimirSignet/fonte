{"sha": "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42", "log": "Add a pass for collecting symbols exported like window['x'] = ...  Fix for issue #70.  Assorted minor bug fixes.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n     return new ObjectLiteralCast(typeNode.getQualifiedName(),\n                                  typeNode.getNext());\n   }\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public boolean isOptionalParameter(Node parameter) {\n+    return false;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public boolean isVarArgsParameter(Node parameter) {\n+    return false;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public boolean isPrivate(String name) {\n+    return false;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n   private final CharsetEncoder outputCharsetEncoder;\n \n-  CodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n+  /** Whether to perform basic checks for obviously incorrect AST structure. */\n+  // NOTE: This exists to support a few extern legacy parsers that don't \n+  // properly normalize the AST (JsMinimizer).\n+  private final boolean validation;\n+\n+  CodeGenerator(\n+      CodeConsumer consumer, Charset outputCharset, boolean validation) {\n+    this.validation = validation;\n     cc = consumer;\n     if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n       // If we want our default (pretending to be UTF-8, but escaping anything\n     }\n   }\n \n+  CodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n+    this(consumer, outputCharset, true);\n+  }\n+\n   CodeGenerator(CodeConsumer consumer) {\n-    this(consumer, null);\n+    this(consumer, null, false);\n   }\n \n   void add(String str) {\n         break;\n \n       case Token.EXPR_VOID:\n-        // TODO(johnlenz): Enable this exception once the external users of\n-        //     CodePrinter have been corrected.\n-        // throw new Error(\"EXPR_VOID should not be used in this codebase.\");\n       case Token.EXPR_RESULT:\n+        if (type == Token.EXPR_VOID && validation) {\n+          throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n+        }\n         Preconditions.checkState(childCount == 1);\n         add(first, Context.START_OF_EXPR);\n         cc.endStatement();\n     Node nodeToProcess = n;\n \n     if (!allowNonBlockChild && n.getType() != Token.BLOCK) {\n-      // TODO(johnlenz) : Enable this when the JsMinifier is corrected.\n-      // throw new Error(\"Missing BLOCK child.\");\n+      if (validation) {\n+        throw new Error(\"Missing BLOCK child.\");\n+      }\n     }\n \n     // Strip unneeded blocks, that is blocks with <2 children.\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n     // Specify a charset to use when outputting source code.  If null,\n     // then just output ASCII.\n     private Charset outputCharset = null;\n+    private boolean validation = true;\n \n     /**\n      * Sets the root node from which to generate the source code.\n       return this;\n     }\n \n+    /**\n+     * Set the charset to use when determining what characters need to be\n+     * escaped in the output.\n+     */\n     Builder setOutputCharset(Charset outCharset) {\n       this.outputCharset = outCharset;\n+      return this;\n+    }\n+\n+    /**\n+     * Whether the input AST guaranteed to be properly formed, fail if it isn't.\n+     */\n+    Builder setValidation(boolean validation) {\n+      this.validation = validation;\n       return this;\n     }\n \n               : Format.COMPACT;\n \n       return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n-          sourceMap, outputCharset);\n+          sourceMap, outputCharset, validation);\n     }\n   }\n \n   private static String toSource(Node root, Format outputFormat,\n                                  boolean lineBreak,  int lineLengthThreshold,\n                                  SourceMap sourceMap,\n-                                 Charset outputCharset) {\n+                                 Charset outputCharset,\n+                                 boolean validation) {\n     boolean createSourceMap = (sourceMap != null);\n     CodeConsumer cp =\n         outputFormat == Format.COMPACT\n     CodeGenerator cg =\n         outputFormat == Format.TYPED\n         ? new TypedCodeGenerator(cp, outputCharset)\n-        : new CodeGenerator(cp, outputCharset);\n+        : new CodeGenerator(cp, outputCharset, validation);\n     cg.add(root);\n \n     String code = ((HasGetCode) cp).getCode();\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   void normalizeNodeTypes(Node root) {\n     Tracer tracer = newTracer(\"normalizeNodeTypes\");\n \n-    // TODO(johnlenz): Move the Node type normalizer into the general\n-    // Normalization pass once we force everybody to turn it on. It's\n-    // confusing to have a mandatory normalization pass and an optional\n-    // one.\n+    // TODO(johnlenz): Merge the NodeTypeNormalizer into the AST creator\n+    // it doesn't need to be done separately.\n     CompilerPass pass = new NodeTypeNormalizer();\n     pass.process(null, root);\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Controls label renaming. */\n   public boolean labelRenaming;\n+\n+  /** Reserve property names on the global this object. */\n+  public boolean reserveRawExports;\n \n   /**\n    * Generate pseudo names for variables and properties for debugging purposes.\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n   @Override\n   protected CompilerOptions createOptions() {\n     CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new ClosureCodingConvention());\n     CompilationLevel level = FLAG_compilation_level.get();\n     level.setOptionsForCompilationLevel(options);\n     WarningLevel wLevel = FLAG_warning_level.get();\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(renameProperties);\n     }\n \n+    // Reserve global names added to the \"windows\" object.\n+    if (options.reserveRawExports) {\n+      passes.add(gatherRawExports);\n+    }\n+\n     // This comes after property renaming because quoted property names must\n     // not be renamed.\n     if (options.convertToDottedProperties) {\n       } else {\n         return new ErrorPass(compiler, GENERATE_EXPORTS_ERROR);\n       }\n+    }\n+  };\n+\n+  /** Raw exports processing pass. */\n+  final PassFactory gatherRawExports =\n+      new PassFactory(\"gatherRawExports\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      final GatherRawExports pass = new GatherRawExports(\n+          compiler);\n+\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node root) {\n+          pass.process(externs, root);\n+          if (exportedNames == null) {\n+            exportedNames = Sets.newHashSet();\n+          }\n+          exportedNames.addAll(pass.getExportedVariableNames());\n+        }\n+      };\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Set;\n+\n+/**\n+ * External references of the form: \"window['xx']\" indicate names that must\n+ * be reserved when variable renaming to avoid conflicts.\n+ *\n+*\n+ */\n+class GatherRawExports extends AbstractPostOrderCallback\n+    implements CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+\n+  private static final String GLOBAL_THIS_NAME = \"window\";\n+\n+  private final Set<String> exportedVariables = Sets.newHashSet();\n+\n+  GatherRawExports(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    Preconditions.checkState(compiler.isNormalized());\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    Node sibling = n.getNext();\n+    if (sibling != null\n+        && sibling.getType() == Token.STRING\n+        && NodeUtil.isGet(parent)) {\n+      // TODO(johnlenz): Should we warn if we see a property name that\n+      // hasn't been exported?\n+      if (isGlobalThisObject(t, n)) {\n+        exportedVariables.add(sibling.getString());\n+      }\n+    }\n+  }\n+\n+  private boolean isGlobalThisObject(NodeTraversal t, Node n) {\n+    if (n.getType() == Token.THIS) {\n+      return t.inGlobalScope();\n+    } else if (n.getType() == Token.NAME && !NodeUtil.isLabelName(n)) {\n+      String varName = n.getString();\n+      if (varName.equals(GLOBAL_THIS_NAME)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public Set<String> getExportedVariableNames() {\n+    return exportedVariables;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n       compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n     }\n \n-    if (root == null) {\n+    if (root == null || compiler.hasHaltingErrors()) {\n       // There was a parse error or IOException, so use a dummy block.\n       root = new Node(Token.BLOCK);\n     } else {\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n     NodeTraversal.traverse(compiler, root, this);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-      NodeTraversal.traverse(compiler, root, renamer);\n+      NodeTraversal t = new NodeTraversal(compiler, renamer);\n+      t.traverseRoots(externs, root);\n     }\n     removeDuplicateDeclarations(root);\n   }\n   // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n   // fixed.\n   /**\n-   * Limit the number of special cases where LABELs need to be handled. Only \n-   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in \n+   * Limit the number of special cases where LABELs need to be handled. Only\n+   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n    * place as the named continues are not allowed for labeled blocks.\n    */\n   private void normalizeLabels(Node n) {\n     Preconditions.checkArgument(n.getType() == Token.LABEL);\n-    \n+\n     Node last = n.getLastChild();\n     switch (last.getType()) {\n       case Token.LABEL:\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n  */\n class TypedCodeGenerator extends CodeGenerator {\n   TypedCodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n-    super(consumer, outputCharset);\n+    super(consumer, outputCharset, true);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n     token = next();\n     if (token == JsDocToken.ELLIPSIS) {\n       token = next();\n+      if (token == JsDocToken.RC) {\n+        // EMPTY represents the UNKNOWN type in the Type AST.\n+        return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));\n+      }\n       restArg = true;\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n \n   @Override\n   public boolean matchesStringContext() {\n-    // TODO(user): Change this to false once UnionType's implementation is\n-    // correct instead of generous.\n+    // Be lenient.\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean matchesObjectContext() {\n+    // Be lenient.\n     return true;\n   }\n \n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n         Node.newString(Token.NAME, \"opt_b\"));\n \n     assertFalse(conv.isVarArgsParameter(args.getFirstChild()));\n-    assertTrue(conv.isVarArgsParameter(args.getLastChild()));\n+    assertFalse(conv.isVarArgsParameter(args.getLastChild()));\n     assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild()));\n-    assertTrue(conv.isVarArgsParameter(optArgs.getLastChild()));\n+    assertFalse(conv.isVarArgsParameter(optArgs.getLastChild()));\n \n-    assertTrue(conv.isOptionalParameter(args.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(args.getFirstChild()));\n     assertFalse(conv.isOptionalParameter(args.getLastChild()));\n-    assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(optArgs.getFirstChild()));\n     assertFalse(conv.isOptionalParameter(optArgs.getLastChild()));\n   }\n \n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n     test(\"function f() {'use strict';}\", \"function f() {}\");\n     test(\"function f() {'no use strict';}\",\n          CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n+  //////////////////////////////////////////////////////////////////////////////\n+  // Integration tests\n+\n+  public void testIssue70() {\n+    test(\"function foo({}) {}\", RhinoErrorReporter.PARSE_ERROR);\n   }\n \n   /* Helper functions */\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = root.getLastChild();\n-    Node mainRootClone = mainRoot.cloneTree();\n+\n+    // Save the tree for later comparison.\n+    Node rootClone = root.cloneTree();\n+    Node externsRootClone = rootClone.getFirstChild();\n+    Node mainRootClone = rootClone.getLastChild();\n \n     int numRepetitions = getNumRepetitions();\n     ErrorManager[] errorManagers = new ErrorManager[numRepetitions];\n \n       if (normalizeEnabled) {\n         Normalize normalize = new Normalize(compiler, false);\n-        normalize.process(externsRoot, mainRootClone);\n+        normalize.process(externsRootClone, mainRootClone);\n       }\n \n       if (mainRootClone.checkTreeEqualsSilent(mainRoot)) {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@link DefaultCodingConvention}.\n+ */\n+public class DefaultCodingConventionTest extends TestCase {\n+  private DefaultCodingConvention conv = new DefaultCodingConvention();\n+\n+  public void testVarAndOptionalParams() {\n+    Node args = new Node(Token.LP,\n+        Node.newString(Token.NAME, \"a\"),\n+        Node.newString(Token.NAME, \"b\"));\n+    Node optArgs = new Node(Token.LP,\n+        Node.newString(Token.NAME, \"opt_a\"),\n+        Node.newString(Token.NAME, \"opt_b\"));\n+\n+    assertFalse(conv.isVarArgsParameter(args.getFirstChild()));\n+    assertTrue(conv.isVarArgsParameter(args.getLastChild()));\n+    assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild()));\n+    assertTrue(conv.isVarArgsParameter(optArgs.getLastChild()));\n+\n+    assertTrue(conv.isOptionalParameter(args.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(args.getLastChild()));\n+    assertTrue(conv.isOptionalParameter(optArgs.getFirstChild()));\n+    assertFalse(conv.isOptionalParameter(optArgs.getLastChild()));\n+  }\n+\n+  public void testInlineName() {\n+    assertFalse(conv.isConstant(\"a\"));\n+    assertFalse(conv.isConstant(\"XYZ123_\"));\n+    assertFalse(conv.isConstant(\"ABC\"));\n+    assertFalse(conv.isConstant(\"ABCdef\"));\n+    assertFalse(conv.isConstant(\"aBC\"));\n+    assertFalse(conv.isConstant(\"A\"));\n+    assertFalse(conv.isConstant(\"_XYZ123\"));\n+    assertFalse(conv.isConstant(\"a$b$XYZ123_\"));\n+    assertFalse(conv.isConstant(\"a$b$ABC_DEF\"));\n+    assertFalse(conv.isConstant(\"a$b$A\"));\n+    assertFalse(conv.isConstant(\"a$b$a\"));\n+    assertFalse(conv.isConstant(\"a$b$ABCdef\"));\n+    assertFalse(conv.isConstant(\"a$b$aBC\"));\n+    assertFalse(conv.isConstant(\"a$b$\"));\n+    assertFalse(conv.isConstant(\"$\"));\n+  }\n+\n+  public void testExportedName() {\n+    assertFalse(conv.isExported(\"_a\"));\n+    assertFalse(conv.isExported(\"_a_\"));\n+    assertFalse(conv.isExported(\"a\"));\n+  }\n+\n+  public void testPrivateName() {\n+    assertFalse(conv.isPrivate(\"a_\"));\n+    assertFalse(conv.isPrivate(\"a\"));\n+    assertFalse(conv.isPrivate(\"_a_\"));\n+  }\n+\n+  public void testEnumKey() {\n+    assertTrue(conv.isValidEnumKey(\"A\"));\n+    assertTrue(conv.isValidEnumKey(\"123\"));\n+    assertTrue(conv.isValidEnumKey(\"FOO_BAR\"));\n+\n+    assertTrue(conv.isValidEnumKey(\"a\"));\n+    assertTrue(conv.isValidEnumKey(\"someKeyInCamelCase\"));\n+    assertTrue(conv.isValidEnumKey(\"_FOO_BAR\"));\n+  }\n+\n+  public void testInheritanceDetection1() {\n+    assertNotClassDefining(\"goog.foo(A, B);\");\n+  }\n+\n+  public void testInheritanceDetection2() {\n+    assertNotClassDefining(\"goog.inherits(A, B);\");\n+  }\n+\n+  public void testInheritanceDetection3() {\n+    assertNotClassDefining(\"A.inherits(B);\");\n+  }\n+\n+  public void testInheritanceDetection4() {\n+    assertNotClassDefining(\"goog.inherits(goog.A, goog.B);\");\n+  }\n+\n+  public void testInheritanceDetection5() {\n+    assertNotClassDefining(\"goog.A.inherits(goog.B);\");\n+  }\n+\n+  public void testInheritanceDetection6() {\n+    assertNotClassDefining(\"A.inherits(this.B);\");\n+  }\n+\n+  public void testInheritanceDetection7() {\n+    assertNotClassDefining(\"this.A.inherits(B);\");\n+  }\n+\n+  public void testInheritanceDetection8() {\n+    assertNotClassDefining(\"goog.inherits(A, B, C);\");\n+  }\n+\n+  public void testInheritanceDetection9() {\n+    assertNotClassDefining(\"A.mixin(B.prototype);\");\n+  }\n+\n+  public void testInheritanceDetection10() {\n+    assertNotClassDefining(\"goog.mixin(A.prototype, B.prototype);\");\n+  }\n+\n+  public void testInheritanceDetectionPostCollapseProperties() {\n+    assertNotClassDefining(\"goog$inherits(A, B);\");\n+    assertNotClassDefining(\"goog$inherits(A);\");\n+  }\n+\n+  private void assertNotClassDefining(String code) {\n+    Node n = parseTestCode(code);\n+    assertNull(conv.getClassesDefinedByCall(n.getFirstChild()));\n+  }\n+\n+  private Node parseTestCode(String code) {\n+    Compiler compiler = new Compiler();\n+    return compiler.parseTestCode(code).getFirstChild();\n+  }\n+}\n+\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GatherRawExportsTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Set;\n+\n+/**\n+ * Tests for {@link GatherRawExports}.\n+ *\n+*\n+ */\n+public class GatherRawExportsTest extends CompilerTestCase {\n+\n+  private static final String EXTERNS = \"var window;\";\n+  private GatherRawExports last;\n+\n+  public GatherRawExportsTest() {\n+    super(EXTERNS);\n+    super.enableNormalize();\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    last = new GatherRawExports(compiler);\n+    return last;\n+  }\n+\n+  public void testExportsFound1() {\n+    assertExported(\"var a\");\n+  }\n+\n+  public void testExportsFound2() {\n+    assertExported(\"window['a']\", \"a\");\n+  }\n+\n+  public void testExportsFound3() {\n+    assertExported(\"window.a\", \"a\");\n+  }\n+\n+  public void testExportsFound4() {\n+    assertExported(\"this['a']\", \"a\");\n+  }\n+\n+  public void testExportsFound5() {\n+    assertExported(\"this.a\", \"a\");\n+  }\n+\n+  public void testExportsFound6() {\n+    assertExported(\"function f() { this['a'] }\");\n+  }\n+\n+  public void testExportsFound7() {\n+    assertExported(\"function f() { this.a }\");\n+  }\n+\n+  public void testExportsFound8() {\n+    assertExported(\"window['foo']\", \"foo\");\n+  }\n+\n+  public void testExportsFound9() {\n+    assertExported(\"window['a'] = 1;\", \"a\");\n+  }\n+\n+  public void testExportsFound10() {\n+    assertExported(\"window['a']['b']['c'] = 1;\", \"a\");\n+  }\n+\n+  public void testExportsFound11() {\n+    assertExported(\"if (window['a'] = 1) alert(x);\", \"a\");\n+  }\n+\n+  public void testExportsFound12() {\n+    assertExported(\"function foo() { window['a'] = 1; }\", \"a\");\n+  }\n+\n+  public void testExportsFound13() {\n+    assertExported(\"function foo() {var window; window['a'] = 1; }\");\n+  }\n+\n+  public void testExportsFound14() {\n+    assertExported(\"var a={window:{}}; a.window['b']\");\n+  }\n+\n+  public void testExportsFound15() {\n+    assertExported(\"window.window['b']\", \"window\");\n+  }\n+\n+  public void testExportsFound16() {\n+    // It would be nice to handle this case, hopefully inlining will take care\n+    // of it for us.\n+    assertExported(\"var a = window; a['b']\");\n+  }\n+\n+  private void assertExported(String js, String ... names) {\n+    Set<String> setNames = Sets.newHashSet(names);\n+    testSame(js);\n+    assertTrue(last.getExportedVariableNames().equals(setNames));\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n  *\n  */\n public class NormalizeTest extends CompilerTestCase {\n+\n+  private static final String EXTERNS = \"var window;\";\n+\n+  public NormalizeTest() {\n+    super(EXTERNS);\n+  }\n+\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new Normalize(compiler, false);\n          \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}\");\n     test(\"try { } catch(e) {e; try { } catch(e) {e;}};\",\n          \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n+\n+    // Verify global redefinition of extern definition is left alone.\n+    testSame(\"var window\");\n+\n+    // Verify local masking extern made unique.\n+    test(\"function f() {var window}\",\n+         \"function f() {var window$$1}\");\n   }\n \n   public void testRemoveDuplicateVarDeclarations() {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     assertTypeEquals(\n         registry.createOptionalType(STRING_TYPE),\n         info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam19() throws Exception {\n+    JSDocInfo info = parse(\"@param {...} [index] */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        registry.createOptionalType(UNKNOWN_TYPE),\n+        info.getParameterType(\"index\"));\n+    assertTrue(info.getParameterType(\"index\").isVarArgs());\n   }\n \n   public void testParseThrows1() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     // matchesXxx\n     assertFalse(ALL_TYPE.matchesInt32Context());\n     assertFalse(ALL_TYPE.matchesNumberContext());\n-    assertFalse(ALL_TYPE.matchesObjectContext());\n+    assertTrue(ALL_TYPE.matchesObjectContext());\n     assertTrue(ALL_TYPE.matchesStringContext());\n     assertFalse(ALL_TYPE.matchesUint32Context());\n ", "timestamp": 1260574169, "metainfo": ""}