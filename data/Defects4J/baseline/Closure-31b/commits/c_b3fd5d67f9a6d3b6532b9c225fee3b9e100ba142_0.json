{"sha": "b3fd5d67f9a6d3b6532b9c225fee3b9e100ba142", "log": "Make GlobalNamespace implement StaticScope/StaticSlot  R=acleung DELTA=49  (40 added, 0 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2284   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     checkNamespaces();\n \n     for (Name n : globalNames) {\n-      flattenReferencesToCollapsibleDescendantNames(n, n.name);\n+      flattenReferencesToCollapsibleDescendantNames(n, n.getName());\n     }\n \n     // We collapse property definitions after collapsing property references\n     // because this step can alter the parse tree above property references,\n     // invalidating the node ancestry stored with each reference.\n     for (Name n : globalNames) {\n-      collapseDeclarationOfNameAndDescendants(n, n.name);\n+      collapseDeclarationOfNameAndDescendants(n, n.getName());\n     }\n   }\n \n     if (n.props == null) return;\n \n     for (Name p : n.props) {\n-      String propAlias = appendPropForAlias(alias, p.name);\n+      String propAlias = appendPropForAlias(alias, p.getName());\n \n       if (p.canCollapse()) {\n         flattenReferencesTo(p, propAlias);\n       for (Name p : n.props) {\n         // Recurse first so that saved node ancestries are intact when needed.\n         collapseDeclarationOfNameAndDescendants(\n-            p, appendPropForAlias(alias, p.name));\n+            p, appendPropForAlias(alias, p.getName()));\n \n         if (!p.inExterns && canCollapseChildNames &&\n             p.declaration != null &&\n             p.declaration.node.getParent() != null &&\n             p.declaration.node.getParent().getType() == Token.ASSIGN) {\n           updateSimpleDeclaration(\n-              appendPropForAlias(alias, p.name), p, p.declaration);\n+              appendPropForAlias(alias, p.getName()), p, p.declaration);\n         }\n       }\n     }\n     if (n.props != null) {\n       for (Name p : n.props) {\n         if (p.needsToBeStubbed()) {\n-          String propAlias = appendPropForAlias(alias, p.name);\n+          String propAlias = appendPropForAlias(alias, p.getName());\n           Node nameNode = Node.newString(Token.NAME, propAlias);\n           Node newVar = new Node(Token.VAR, nameNode)\n               .copyInformationFromForTree(addAfter);\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n \n import java.util.ArrayList;\n import java.util.HashMap;\n  * the global scope. Also builds an index of all the references to those names.\n  *\n  */\n-class GlobalNamespace {\n+class GlobalNamespace implements StaticScope<JSType> {\n \n   private AbstractCompiler compiler;\n   private final Node root;\n     this.compiler = compiler;\n     this.externsRoot = externsRoot;\n     this.root = root;\n+  }\n+\n+  @Override\n+  public StaticScope<JSType> getParentScope() {\n+    return null;\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getSlot(String name) {\n+    return getOwnSlot(name);\n+  }\n+\n+  @Override\n+  public StaticSlot<JSType> getOwnSlot(String name) {\n+    return nameMap.get(name);\n+  }\n+\n+  @Override\n+  public JSType getTypeOfThis() {\n+    return compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n   }\n \n   /**\n    * correspond to JavaScript objects whose properties we should consider\n    * collapsing.\n    */\n-  static class Name {\n+  static class Name implements StaticSlot<JSType> {\n     enum Type {\n       OBJECTLIT,\n       FUNCTION,\n       OTHER,\n     }\n \n-    final String name;\n+    private final String name;\n     final Name parent;\n     List<Name> props;\n \n       Name node = new Name(name, this, inExterns);\n       props.add(node);\n       return node;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public boolean isTypeInferred() {\n+      return false;\n+    }\n+\n+    @Override\n+    public JSType getType() {\n+      return null;\n     }\n \n     void addRef(Ref ref) {", "timestamp": 1308180970, "metainfo": ""}