{"sha": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73", "log": "Fix if-folding compiler crash (issue 43) Fix property-collapsing compiler crash (issue 34) Fix labeled VAR compiler crash (issue 41) Make [paramName] syntax denote optionality (issue #26) Better function inlining.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n       + \"opt_parameter.\")\n   public static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n \n-  @FlagSpec(help = \"Check types for validity.\")\n-  public static final Flag<Boolean> FLAG_check_types = Flag.value(false);\n \n   @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n       + \" 0 (never print summary), 1 (print summary only if there are \"\n           VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n     }\n \n-    if (FLAG_check_types.get()) {\n-      options.checkTypes = true;\n-    }\n-\n     if (!options.jsOutputFile.equals(\"\")) {\n       out = new PrintStream(options.jsOutputFile);\n     }\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     if (n.props == null) return;\n \n     for (Name p : n.props) {\n-      String propAlias = alias + '$' + p.name;\n+      String propAlias = appendPropForAlias(alias, p.name);\n \n       if (p.canCollapse()) {\n         flattenReferencesTo(p, propAlias);\n     if (n.props != null) {\n       for (Name p : n.props) {\n         // Recurse first so that saved node ancestries are intact when needed.\n-        collapseDeclarationOfNameAndDescendants(p, alias + '$' + p.name);\n+        collapseDeclarationOfNameAndDescendants(\n+            p, appendPropForAlias(alias, p.name));\n \n         if (!p.inExterns && canCollapseChildNames && p.declaration != null &&\n             p.declaration.node != null &&\n             p.declaration.node.getParent() != null &&\n             p.declaration.node.getParent().getType() == Token.ASSIGN) {\n-          updateSimpleDeclaration(alias + '$' + p.name, p.declaration);\n+          updateSimpleDeclaration(\n+              appendPropForAlias(alias, p.name), p, p.declaration);\n         }\n       }\n     }\n    * function whose properties aren't collapsible.\n    *\n    * @param alias The flattened property name (e.g. \"a$b\")\n+   * @param refName The name for the reference being updated.\n    * @param ref An object containing information about the assignment getting\n    *     updated\n    */\n-  private void updateSimpleDeclaration(String alias, Ref ref) {\n+  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node rvalue = ref.node.getNext();\n     Node parent = ref.node.getParent();\n     Node gramps = parent.getParent();\n \n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),\n-        alias.replace(\"$\", \".\"));\n+        refName.fullName());\n     if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n     if (isObjLit) {\n       boolean discardKeys = n.aliasingGets == 0;\n       declareVarsForObjLitValues(\n-          alias, rvalue,\n+          n, alias, rvalue,\n           varNode, varParent.getChildBefore(varNode), varParent,\n           discardKeys);\n     }\n     if (isObjLit) {\n       boolean discardKeys = n.aliasingGets == 0;\n       numChanges += declareVarsForObjLitValues(\n-          name, rvalue, varNode, gramps.getChildBefore(varNode),\n+          n, name, rvalue, varNode, gramps.getChildBefore(varNode),\n           gramps, discardKeys);\n     }\n \n    * @return The number of variables added\n    */\n   private int declareVarsForObjLitValues(\n-      String alias, Node objlit, Node varNode, Node nameToAddAfter,\n-      Node varParent, boolean discardKeys) {\n+      Name objlitName, String alias, Node objlit, Node varNode,\n+      Node nameToAddAfter, Node varParent, boolean discardKeys) {\n     int numVars = 0;\n     int arbitraryNameCounter = 0;\n \n       // their values are expressions that have side effects.\n       boolean isJsIdentifier = key.getType() != Token.NUMBER &&\n                                TokenStream.isJSIdentifier(key.getString());\n-      String propAlias = alias + '$' +\n-          (isJsIdentifier ? key.getString()\n-              : String.valueOf(++arbitraryNameCounter));\n-      String qName = propAlias.replace('$', '.');\n+      String propName = isJsIdentifier ?\n+          key.getString() : String.valueOf(++arbitraryNameCounter);\n+      String propAlias = appendPropForAlias(alias, propName);\n+      String qName = objlitName.fullName() + '.' + propName;\n \n       Node refNode = null;\n       if (discardKeys) {\n     if (n.props != null) {\n       for (Name p : n.props) {\n         if (p.needsToBeStubbed()) {\n-          String propAlias = alias + '$' + p.name;\n+          String propAlias = appendPropForAlias(alias, p.name);\n           Node nameNode = Node.newString(Token.NAME, propAlias);\n           Node newVar = new Node(Token.VAR, nameNode);\n           if (addAfter == null) {\n     }\n     return numStubs;\n   }\n+\n+  private static String appendPropForAlias(String root, String prop) {\n+    if (prop.indexOf('$') != -1) {\n+      // Encode '$' in a property as '$0'. Because '0' cannot be the\n+      // start of an identifier, this will never conflict with our\n+      // encoding from '.' -> '$'.\n+      prop = prop.replaceAll(\"\\\\$\", \"\\\\$0\");\n+    }\n+    return root + '$' + prop;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Enhanced function inlining */\n   public boolean inlineAnonymousFunctionExpressions;\n+\n+  /** Enhanced function inlining */\n+  public boolean inlineLocalFunctions;\n \n   /** Move code to a deeper module */\n   public boolean crossModuleCodeMotion;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     passes.addAll(getCodeRemovingPasses(false));\n \n-    if (options.inlineFunctions) {\n+    if (options.inlineFunctions || options.inlineLocalFunctions) {\n       passes.add(inlineFunctions);\n     }\n \n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       boolean enableBlockInlining = !isInliningForbidden();\n       return new InlineFunctions(\n-          compiler, compiler.getUniqueNameIdSupplier(),\n-          enableBlockInlining, options.decomposeExpressions,\n-          options.inlineAnonymousFunctionExpressions);\n+          compiler, \n+          compiler.getUniqueNameIdSupplier(),\n+          options.inlineFunctions,\n+          options.inlineLocalFunctions, \n+          options.inlineAnonymousFunctionExpressions,\n+          enableBlockInlining,\n+          options.decomposeExpressions);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n       tryMinimizeCondition(t, left, n);\n       return;\n     }\n-    \n+\n     if (type == Token.RETURN) {\n       tryReduceReturn(t, n);\n       return;\n       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n \n       Node name1 = var.getFirstChild();\n-      Node name2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren() && name1.getString().equals(name2.getString())) {\n+      Node maybeName2 = elseAssign.getFirstChild();\n+\n+      if (name1.hasChildren()\n+          && maybeName2.getType() == Token.NAME\n+          && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n         cond.detachFromParent();\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;\n import com.google.javascript.jscomp.FunctionInjector.InliningMode;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n \n   private final boolean blockFunctionInliningEnabled;\n   private final boolean inlineAnonymousFunctionExpressions;\n+  private final boolean inlineGlobalFunctions;\n+  private final boolean inlineLocalFunctions;\n \n   InlineFunctions(AbstractCompiler compiler,\n       Supplier<String> safeNameIdSupplier,\n+      boolean inlineGlobalFunctions,\n+      boolean inlineLocalFunctions,\n+      boolean inlineAnonymousFunctionExpressions,\n       boolean blockFunctionInliningEnabled,\n-      boolean enableExpressionDecomposition,\n-      boolean inlineAnonymousFunctionExpressions) {\n+      boolean enableExpressionDecomposition) {\n     Preconditions.checkArgument(compiler != null);\n     Preconditions.checkArgument(safeNameIdSupplier != null);\n     this.compiler = compiler;\n+\n+    this.inlineGlobalFunctions = inlineGlobalFunctions;\n+    this.inlineLocalFunctions = inlineLocalFunctions;\n+    this.inlineAnonymousFunctionExpressions =\n+      inlineAnonymousFunctionExpressions;\n     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n-    this.inlineAnonymousFunctionExpressions =\n-        inlineAnonymousFunctionExpressions;\n+\n     this.injector = new FunctionInjector(\n         compiler, safeNameIdSupplier, enableExpressionDecomposition);\n   }\n     Preconditions.checkState(compiler.isNormalized());\n \n     NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n-    // TODO(johnlenz): Merge FindAnonymousFunctionCalls with\n-    // FindCandidateFunctions.\n-    if (inlineAnonymousFunctionExpressions) {\n-      NodeTraversal.traverse(compiler, root, new FindAnonymousFunctionCalls());\n-    }\n     if (fns.isEmpty()) {\n       return;  // Nothing left to do.\n     }\n   /**\n    * Find functions that might be inlined.\n    */\n-  private class FindCandidateFunctions\n-      extends AbstractShallowStatementCallback {\n+  private class FindCandidateFunctions implements Callback {\n+    private int callsSeen = 0;\n+\n+    @Override\n+    public boolean shouldTraverse(\n+        NodeTraversal nodeTraversal, Node n, Node parent) {\n+      // Don't traverse into function bodies\n+      // if we aren't inlining local functions.\n+      return inlineLocalFunctions || inlineAnonymousFunctionExpressions\n+         || parent == null || NodeUtil.isControlStructure(parent)\n+         || NodeUtil.isStatementBlock(parent);\n+    }\n+\n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      if ((t.inGlobalScope() && inlineGlobalFunctions)\n+          || (!t.inGlobalScope() && inlineLocalFunctions)) {\n+        findNamedFunctions(t, n, parent);\n+      } \n+      \n+      if (inlineAnonymousFunctionExpressions) {\n+        findAnonymousFunctionExpressions(t, n);\n+      }\n+    }\n+\n+    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n+      if (!NodeUtil.isStatement(n)) {\n+        // There aren't any interesting functions here.\n+        return;\n+      }\n+\n       switch (n.getType()) {\n-\n         // Anonymous functions in the form of:\n         //   var fooFn = function(x) { return ... }\n         case Token.VAR:\n           break;\n       }\n     }\n-  }\n-\n-  /**\n-   * Find anonymous functions that are called directly in the form of\n-   *   (function(a,b,...){...})(a,b,...)\n-   * or\n-   *   (function(a,b,...){...}).call(this,a,b, ...)\n-   */\n-  private class FindAnonymousFunctionCalls\n-      extends AbstractPostOrderCallback {\n-    private int callsSeen = 0;\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n+\n+    /**\n+     * Find anonymous functions that are called directly in the form of\n+     *   (function(a,b,...){...})(a,b,...)\n+     * or\n+     *   (function(a,b,...){...}).call(this,a,b, ...)\n+     */\n+    public void findAnonymousFunctionExpressions(NodeTraversal t, Node n) {\n       switch (n.getType()) {\n         // Anonymous functions in the form of:\n         //   (function(){})();\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n    * Do normalizations that introduce new siblings or parents.\n    */\n   private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n+    if (n.getType() == Token.LABEL) {\n+      normalizeLabels(n);\n+    }\n+\n     // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n     // are the only legal place for VARs and FOR statements.\n     if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n       extractForInitializer(n, null, null);\n+    }\n+\n+    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n+    // are the only legal place for VARs.\n+    if (NodeUtil.isStatementBlock(n)) {\n       splitVarDeclarations(n);\n     }\n \n     if (n.getType() == Token.FUNCTION) {\n       moveNamedFunctions(n.getLastChild());\n+    }\n+  }\n+\n+  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n+  // fixed.\n+  /**\n+   * Limit the number of special cases where LABELs need to be handled. Only \n+   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in \n+   * place as the named continues are not allowed for labeled blocks.\n+   */\n+  private void normalizeLabels(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.LABEL);\n+    \n+    Node last = n.getLastChild();\n+    switch (last.getType()) {\n+      case Token.LABEL:\n+      case Token.BLOCK:\n+      case Token.FOR:\n+      case Token.WHILE:\n+      case Token.DO:\n+        return;\n+      default:\n+        Node block = new Node(Token.BLOCK);\n+        n.replaceChild(last, block);\n+        block.addChildToFront(last);\n+        reportCodeChange(\"LABEL normalization\");\n+        return;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                       token = next();\n                       if (JsDocToken.RB != token) {\n                         reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                      } else if (type != null) {\n+                        // Make the type expression optional, if it isn't\n+                        // already.\n+                        type = JSTypeExpression.makeOptionalArg(type);\n                       }\n                     }\n \n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n   }\n \n   /**\n+   * Make the given type expression into an optional type expression,\n+   * if possible.\n+   */\n+  public static JSTypeExpression makeOptionalArg(JSTypeExpression expr) {\n+    if (expr.isOptionalArg() || expr.isVarArgs()) {\n+      return expr;\n+    } else {\n+      return new JSTypeExpression(\n+          new Node(Token.EQUALS, expr.root), expr.sourceName, expr.registry);\n+    }\n+  }\n+\n+  /**\n    * @return Whether this expression denotes an optional {@code @param}.\n    */\n   public boolean isOptionalArg() {\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n     test(\"var a = {}; if (a.b = function() {}) { a.b.c = 3; a.b(a.b.c); }\",\n          \"var a$b; if (a$b = function() {}) { a$b.c = 3; a$b(a$b.c); }\");\n   }\n+\n+  public void testPropWithDollarSign() {\n+    test(\"var a = {$: 3}\", \"var a$$0 = 3;\");\n+  }\n+\n+  public void testPropWithDollarSign2() {\n+    test(\"var a = {$: function(){}}\", \"var a$$0 = function(){};\");\n+  }\n+\n+  public void testPropWithDollarSign3() {\n+    test(\"var a = {b: {c: 3}, b$c: function(){}}\",\n+         \"var a$b$c = 3; var a$b$0c = function(){};\");\n+  }\n+\n+  public void testPropWithDollarSign4() {\n+    test(\"var a = {$$: {$$$: 3}};\", \"var a$$0$0$$0$0$0 = 3;\");\n+  }\n+\n+  public void testPropWithDollarSign5() {\n+    test(\"var a = {b: {$0c: true}, b$0c: false};\",\n+         \"var a$b$$00c = true; var a$b$00c = false;\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     fold(\"function(){if(a()){return undefined;}}\",\n          \"function(){if(a()){return}}\");\n   }\n-  \n+\n   public void testBugIssue3() {\n     foldSame(\"function foo() {\" +\n              \"  if(sections.length != 1) children[i] = 0;\" +\n              \"  else var selectedid = children[i]\" +\n              \"}\");\n   }\n+\n+  public void testBugIssue43() {\n+    foldSame(\"function foo() {\" +\n+             \"  if (a) { var b = 1; } else { a.b = 1; }\" +\n+             \"}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"function foo(a){return true;}; \" +\n         \"function x() {a:foo(1)?0:1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n+        \"function x() { a:{{var JSCompiler_inline_result_0; \" +\n         \"JSCompiler_inline_result_0=true;}\" +\n-        \"a:JSCompiler_inline_result_0?0:1 }\",\n+        \"JSCompiler_inline_result_0?0:1 }}\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n *\n  */\n public class InlineFunctionsTest extends CompilerTestCase {\n+  boolean allowGlobalFunctionInlining = true;\n   boolean allowBlockInlining = true;\n   boolean allowExpressionDecomposition = true;\n   boolean allowAnonymousFunctionExpressionInlining = true;\n+  boolean allowLocalFunctionInlining = true;\n \n   public InlineFunctionsTest() {\n     this.enableNormalize();\n   protected CompilerPass getProcessor(Compiler compiler) {\n     compiler.resetUniqueNameId();\n     return new InlineFunctions(\n-        compiler, compiler.getUniqueNameIdSupplier(),\n+        compiler, \n+        compiler.getUniqueNameIdSupplier(),\n+        allowGlobalFunctionInlining,\n+        allowLocalFunctionInlining,\n+        allowAnonymousFunctionExpressionInlining,\n         allowBlockInlining,\n-        allowExpressionDecomposition,\n-        allowAnonymousFunctionExpressionInlining);\n+        allowExpressionDecomposition);\n   }\n \n   /**\n   }\n \n   public void testNoInlineOfNonGlobalFunction1() {\n-    testSame(\"function _f(){function g(){return 0}}\" +\n-             \"function _h(){return g()}\");\n+    test(\"var g;function _f(){function g(){return 0}}\" +\n+         \"function _h(){return g()}\",\n+         \"var g;function _f(){}\" +\n+         \"function _h(){return g()}\");\n   }\n \n   public void testNoInlineOfNonGlobalFunction2() {\n-    testSame(\"function _f(){var g=function(){return 0}}\" +\n-             \"function _h(){return g()}\");\n+    test(\"var g;function _f(){var g=function(){return 0}}\" +\n+         \"function _h(){return g()}\",\n+         \"var g;function _f(){}\" +\n+         \"function _h(){return g()}\");\n   }\n \n   public void testNoInlineOfNonGlobalFunction3() {\n-    testSame(\"var g=3;function _f(){var g=function(){return 0}}\" +\n-             \"function _h(){return g()}\");\n+    test(\"var g;function _f(){var g=function(){return 0}}\" +\n+         \"function _h(){return g()}\",\n+         \"var g;function _f(){}\" +\n+         \"function _h(){return g()}\");\n   }\n \n   public void testNoInlineOfNonGlobalFunction4() {\n-    testSame(\"var g=3;function _f(){function g(){return 0}}\" +\n-             \"function _h(){return g()}\");\n+    test(\"var g;function _f(){function g(){return 0}}\" +\n+         \"function _h(){return g()}\",\n+         \"var g;function _f(){}\" +\n+         \"function _h(){return g()}\");\n+\n   }\n \n   public void testNoInlineMaskedFunction() {\n           \"{{JSCompiler_inline_f_1(JSCompiler_inline_f_1)}}}\");\n   }\n \n+  public void testLocalFunctionInlining1() {\n+    test(\"function _f(){ function g() {} g() }\",\n+         \"function _f(){ void 0 }\");\n+  }\n+\n+  public void testLocalFunctionInlining2() {\n+    test(\"function _f(){ function g() {foo(); bar();} g() }\",\n+         \"function _f(){ {foo(); bar();} }\");\n+  }\n+\n+  public void testLocalFunctionInlining3() {\n+    test(\"function _f(){ function g() {foo(); bar();} g() }\",\n+         \"function _f(){ {foo(); bar();} }\");\n+  }\n+\n+  public void testLocalFunctionInlining4() {\n+    test(\"function _f(){ function g() {return 1} return g() }\",\n+         \"function _f(){ return 1 }\");\n+  }\n+\n+  public void testLocalFunctionInlining5() {\n+    testSame(\"function _f(){ function g() {this;} g() }\");\n+  }\n+\n+  public void testLocalFunctionInlining6() {\n+    testSame(\"function _f(){ function g() {this;} return g; }\");\n+  }\n+\n   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator\n   public void testAnonymousFunctionYCombinator() {\n     testSame(\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n \n     test(\"do var a = foo(1), b; while(false);\",\n          \"do{var a = foo(1); var b} while(false);\");\n+    test(\"a:var a,b,c;\",\n+         \"a:{ var a;var b; var c; }\");\n+    test(\"a:for(var a,b,c;;);\",\n+         \"var a;var b; var c;a:for(;;);\");\n+    test(\"if (true) a:var a,b;\",\n+         \"if (true)a:{ var a; var b; }\");\n   }\n \n   public void testUnhandled() {\n \n   public void testMoveFunctions2() throws Exception {\n     testSame(\"function f() { function foo() {} }\");\n-    testSame(\"function f() { f(); a:function bar() {} }\");\n+    test(\"function f() { f(); a:function bar() {} }\",\n+         \"function f() { f(); a:{function bar() {}}}\");\n     testSame(\"function f() { f(); {function bar() {}}}\");\n     testSame(\"function f() { f(); if (true) {function bar() {}}}\");\n   }\n     test(\"var a = 1; function f(){ var a = 2 }\",\n          \"var a = 1; function f(){ var a$$1 = 2 }\");\n     test(\"function f() { var a = 1; lable1:var a = 2 }\",\n-         \"function f() { var a = 1; lable1:a = 2 }\");\n+         \"function f() { var a = 1; lable1:{a = 2}}\");\n     test(\"function f() { var a = 1; lable1:var a }\",\n-         \"function f() { var a = 1; lable1:; }\");\n+         \"function f() { var a = 1; lable1:{} }\");\n     test(\"function f() { var a = 1; for(var a in b); }\",\n          \"function f() { var a = 1; for(a in b); }\");\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n              WRONG_ARGUMENT_COUNT);\n   }\n \n+  public void testFunctionsWithJsDoc7() {\n+    String fooDfn = \"/** @param {*} [b] */ var foo = function(b) {};\";\n+    testSame(fooDfn + \"foo();\");\n+    testSame(fooDfn + \"foo(1);\");\n+    testSame(fooDfn + \"foo(1, 2);\", WRONG_ARGUMENT_COUNT);\n+  }\n+\n   public void testFunctionWithDefaultCodingConvention() {\n     convention = new DefaultCodingConvention();\n     testSame(\"var foo = function(x) {}; foo(1, 2);\");", "timestamp": 1258416241, "metainfo": ""}