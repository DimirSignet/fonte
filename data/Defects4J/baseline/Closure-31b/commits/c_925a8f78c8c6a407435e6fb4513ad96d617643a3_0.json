{"sha": "925a8f78c8c6a407435e6fb4513ad96d617643a3", "log": "Replace some straggler \"n.isType() == Token.XX\" calls.  R=nicksantos DELTA=70  (36 added, 6 deleted, 28 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3725   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n       Node getprop) {\n     // Check whether the property is modified\n     Node parent = getprop.getParent();\n-    boolean isDelete = parent.getType() == Token.DELPROP;\n+    boolean isDelete = parent.isDelProp();\n     if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n         && !parent.isInc() && !parent.isDec()\n         && !isDelete) {\n--- a/src/com/google/javascript/jscomp/CheckDebuggerStatement.java\n+++ b/src/com/google/javascript/jscomp/CheckDebuggerStatement.java\n import com.google.javascript.jscomp.DiagnosticType;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * {@link CheckDebuggerStatement} checks for the presence of the \"debugger\"\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.DEBUGGER) {\n+    if (n.isDebugger()) {\n       t.report(n, DEBUGGER_STATEMENT_PRESENT);\n     }\n   }\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n       }\n \n     // Check the syntax of regular expression patterns.\n-    } else if (n.getType() == Token.REGEXP) {\n+    } else if (n.isRegExp()) {\n       String pattern = n.getFirstChild().getString();\n       String flags = n.getChildCount() == 2\n           ? n.getLastChild().getString() : \"\";\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.ObjectType;\n     if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n         n.getChildCount() >= 3) {\n       Node typeArray = callName.getNext().getNext();\n-      if (typeArray.getType() == Token.ARRAYLIT) {\n+      if (typeArray.isArrayLit()) {\n         List<String> typeNames = Lists.newArrayList();\n         for (Node name = typeArray.getFirstChild(); name != null;\n              name = name.getNext()) {\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n   private void addExpr(Node n, int minPrecedence, Context context) {\n     if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n         ((context == Context.IN_FOR_INIT_CLAUSE) &&\n-        (n.getType() == Token.IN))){\n+        (n.isIn()))){\n       add(\"(\");\n       add(n, clearContextForNoInOperator(context));\n       add(\")\");\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n               CrossModuleMethodMotion.STUB_METHOD_NAME) ||\n            functionName.getString().equals(\n               CrossModuleMethodMotion.UNSTUB_METHOD_NAME));\n-    } else if (n.getType() == Token.ARRAYLIT ||\n-        n.isObjectLit()) {\n+    } else if (n.isArrayLit() || n.isObjectLit()) {\n       boolean isObjectLit = n.isObjectLit();\n       for (Node child = n.getFirstChild(); child != null;\n            child = child.getNext()) {\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n     InstanceOfCheckNode(JsName name, Node node, Node parent, Node gramps) {\n       super(name, node, parent, gramps);\n       Preconditions.checkState(node.isQualifiedName());\n-      Preconditions.checkState(parent.getType() == Token.INSTANCEOF);\n+      Preconditions.checkState(parent.isInstanceOf());\n     }\n \n     @Override\n       }\n \n       if ((parent.isIf() ||\n-           parent.getType() == Token.WHILE ||\n-           parent.getType() == Token.WITH ||\n+           parent.isWhile() ||\n+           parent.isWith() ||\n            parent.isSwitch() ||\n            parent.isCase()) &&\n           parent.getFirstChild() == n) {\n         return;\n       }\n \n-      if (parent.getType() == Token.INSTANCEOF &&\n+      if (parent.isInstanceOf() &&\n           parent.getLastChild() == n &&\n           // Don't cover GETELEMs with a global root node.\n           n.isQualifiedName()) {\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n   }\n \n   boolean isInterestingValue(Node n) {\n-    return n.isObjectLit() || n.getType() == Token.ARRAYLIT;\n+    return n.isObjectLit() || n.isArrayLit();\n   }\n \n   private boolean isPropertyAssignmentToName(Node propertyCandidate) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n    * typeof(6) --> \"number\"\n    */\n   private Node tryFoldTypeof(Node originalTypeofNode) {\n-    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n+    Preconditions.checkArgument(originalTypeofNode.isTypeOf());\n \n     Node argumentNode = originalTypeofNode.getFirstChild();\n     if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) {\n    * or {@code false}.\n    */\n   private Node tryFoldInstanceof(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);\n+    Preconditions.checkArgument(n.isInstanceOf());\n \n     // TODO(johnlenz) Use type information if available to fold\n     // instanceof.\n       return tryFoldObjectPropAccess(n, left, right);\n     }\n \n-    if (left.getType() == Token.ARRAYLIT) {\n+    if (left.isArrayLit()) {\n       return tryFoldArrayAccess(n, left, right);\n     }\n     return n;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n    * PeepholeFoldConstants.\n    */\n   private Node tryFoldTypeof(Node typeofNode) {\n-    Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);\n+    Preconditions.checkArgument(typeofNode.isTypeOf());\n     Preconditions.checkArgument(typeofNode.getFirstChild() != null);\n \n     Node argumentNode = typeofNode.getFirstChild();\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n    * Removes WHILEs that always evaluate to false.\n    */\n   Node tryFoldWhile(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.WHILE);\n+    Preconditions.checkArgument(n.isWhile());\n     Node cond = NodeUtil.getConditionExpression(n);\n     if (NodeUtil.getPureBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n--- a/src/com/google/javascript/jscomp/PeepholeSimplifyRegExp.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSimplifyRegExp.java\n \n import com.google.javascript.jscomp.regex.RegExpTree;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Simplifies regular expression patterns and flags.\n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n-    if (subtree.getType() == Token.REGEXP) {\n+    if (subtree.isRegExp()) {\n       // Split regexp into pattern and flags.\n       String pattern = subtree.getFirstChild().getString();\n       String flags = subtree.getChildCount() == 2\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n     Node block = n.getLastChild();\n     Node maybeIf = block.getFirstChild();\n-    if (maybeIf != null && maybeIf.getType() == Token.IF) {\n+    if (maybeIf != null && maybeIf.isIf()) {\n       Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild();\n-      if (maybeBreak != null && maybeBreak.getType() == Token.BREAK\n+      if (maybeBreak != null && maybeBreak.isBreak()\n           && !maybeBreak.hasChildren()) {\n \n         // Preserve the IF ELSE expression is there is one.\n \n         // Ok, join the IF expression with the FOR expression\n         Node forCondition = NodeUtil.getConditionExpression(n);\n-        if (forCondition.getType() == Token.EMPTY) {\n+        if (forCondition.isEmpty()) {\n           n.replaceChild(forCondition, fixedIfCondition);\n         } else {\n           Node replacement = new Node(Token.AND);\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n           // value (x++ results in a number, for instance)\n           Preconditions.checkState(\n               NodeUtil.isAssignmentOp(op)\n-              || isIncDec(op) || op.getType() == Token.DELPROP);\n+              || isIncDec(op) || op.isDelProp());\n           if (rhs != null\n               && op.isAssign()\n               && !NodeUtil.evaluatesToLocalValue(rhs)) {\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n \n         Node typeOfNode = null;\n         Node stringNode = null;\n-        if (left.getType() == Token.TYPEOF && right.isString()) {\n+        if (left.isTypeOf() && right.isString()) {\n           typeOfNode = left;\n           stringNode = right;\n-        } else if (right.getType() == Token.TYPEOF &&\n+        } else if (right.isTypeOf() &&\n                    left.isString()) {\n           typeOfNode = right;\n           stringNode = left;\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n       }\n     } else if (n.isAssign()) {\n       checkAssignment(t, n);\n-    } else if (n.getType() == Token.DELPROP) {\n+    } else if (n.isDelProp()) {\n       checkDelete(t, n);\n     } else if (n.isObjectLit()) {\n       checkObjectLiteral(t, n);\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.javascript.rhino.JSDocInfo.Marker;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.EnumType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n         }\n \n         maybeDefineTypedReference(n, n.getLastChild().getString(), owner);\n-      } else if (NodeUtil.isObjectLitKey(n, parent) &&\n-          n.getType() == Token.STRING) {\n+      } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString()) {\n         JSType owner = parent.getJSType();\n         if (owner == null || owner.isUnknownType()) {\n           tryDefineLexicalPropRef(NodeUtil.getBestLValueName(n), n);\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         TernaryValue result =\n             leftTypeRestricted.testForEquality(rightTypeRestricted);\n         if (result != TernaryValue.UNKNOWN) {\n-          if (n.getType() == Token.NE) {\n+          if (n.isNE()) {\n             result = result.not();\n           }\n           report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     }\n     n.setJSType(type);\n \n-    if (n.getType() == Token.ASSIGN_ADD) {\n+    if (n.isAssignAdd()) {\n       updateScopeForTypeChange(scope, left, leftType, type);\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     return this.getType() == Token.ASSIGN;\n   }\n \n+  public boolean isAssignAdd() {\n+    return this.getType() == Token.ASSIGN_ADD;\n+  }\n+\n   public boolean isBlock() {\n     return this.getType() == Token.BLOCK;\n   }\n     return this.getType() == Token.CONTINUE;\n   }\n \n+  public boolean isDebugger() {\n+    return this.getType() == Token.DEBUGGER;\n+  }\n+\n   public boolean isDec() {\n     return this.getType() == Token.DEC;\n   }\n     return this.getType() == Token.DEFAULT_CASE;\n   }\n \n+  public boolean isDelProp() {\n+    return this.getType() == Token.DELPROP;\n+  }\n+\n   public boolean isDo() {\n     return this.getType() == Token.DO;\n   }\n     return this.getType() == Token.IF;\n   }\n \n+  public boolean isIn() {\n+    return this.getType() == Token.IN;\n+  }\n+\n   public boolean isInc() {\n     return this.getType() == Token.INC;\n   }\n \n+  public boolean isInstanceOf() {\n+    return this.getType() == Token.INSTANCEOF;\n+  }\n+\n   public boolean isLabel() {\n     return this.getType() == Token.LABEL;\n   }\n     return this.getType() == Token.NAME;\n   }\n \n+  public boolean isNE() {\n+    return this.getType() == Token.NE;\n+  }\n+\n   public boolean isNew() {\n     return this.getType() == Token.NEW;\n   }\n     return this.getType() == Token.TRY;\n   }\n \n+  public boolean isTypeOf() {\n+    return this.getType() == Token.TYPEOF;\n+  }\n+\n   public boolean isVar() {\n     return this.getType() == Token.VAR;\n   }\n   public boolean isVoid() {\n     return this.getType() == Token.VOID;\n   }\n+\n+  public boolean isWhile() {\n+    return this.getType() == Token.WHILE;\n+  }\n+\n+  public boolean isWith() {\n+    return this.getType() == Token.WITH;\n+  }\n }", "timestamp": 1321407343, "metainfo": ""}