{"sha": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c", "log": "Replace the bulk of the Node.getType() == Token.XXX calls with Node.isXXX calls.  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=3677   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n       if (n != null && n.getType() != Token.SCRIPT\n           && (n.getType() != Token.BLOCK || !n.isSyntheticBlock())) {\n         for (Node parent : n.getAncestors()) {\n-          if (parent.getType() == Token.SCRIPT) {\n+          if (parent.isScript()) {\n             break done;\n           }\n         }\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n   @Override\n   public void process(Node externs, Node root) {\n     defaultRoot = root.getFirstChild();\n-    Preconditions.checkState(defaultRoot.getType() == Token.SCRIPT);\n+    Preconditions.checkState(defaultRoot.isScript());\n \n     aliasProperties(externs, root);\n     aliasGlobals(externs, root);\n         case Token.GETPROP:\n         case Token.GETELEM:\n           Node dest = n.getFirstChild().getNext();\n-          if (dest.getType() == Token.STRING &&\n+          if (dest.isString() &&\n               (whitelist.isEmpty() || whitelist.contains(dest.getString()))) {\n             props.put(dest.getString(), newSymbolForProperty(dest.getString()));\n           }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         Node propNameNode = n.getLastChild();\n \n         if (canReplaceWithGetProp(propNameNode, n, parent)) {\n      */\n     private boolean canReplaceWithGetProp(Node propNameNode, Node getPropNode,\n           Node parent) {\n-      boolean isCallTarget = (parent.getType() == Token.CALL)\n+      boolean isCallTarget = (parent.isCall())\n           && (parent.getFirstChild() == getPropNode);\n       boolean isAssignTarget = NodeUtil.isAssignmentOp(parent)\n           && (parent.getFirstChild() == getPropNode);\n-      boolean isIncOrDec = (parent.getType() == Token.INC) ||\n-          (parent.getType() == Token.DEC);\n-      return (propNameNode.getType() == Token.STRING) && !isAssignTarget\n+      boolean isIncOrDec = (parent.isInc()) ||\n+          (parent.isDec());\n+      return (propNameNode.isString()) && !isAssignTarget\n           && (!isCallTarget || !\"eval\".equals(propNameNode.getString()))\n           && !isIncOrDec\n           && props.containsKey(propNameNode.getString());\n      */\n     private boolean canReplaceWithSetProp(Node propNameNode, Node getPropNode,\n         Node parent) {\n-      boolean isAssignTarget = (parent.getType() == Token.ASSIGN)\n+      boolean isAssignTarget = (parent.isAssign())\n           && (parent.getFirstChild() == getPropNode);\n-      return (propNameNode.getType() == Token.STRING) && isAssignTarget\n+      return (propNameNode.isString()) && isAssignTarget\n           && props.containsKey(propNameNode.getString());\n     }\n   }\n    */\n   private class GetGlobals extends NodeTraversal.AbstractShallowCallback {\n     private void getGlobalName(NodeTraversal t, Node dest, Node parent) {\n-      if (dest.getType() == Token.NAME) {\n+      if (dest.isName()) {\n \n         JSDocInfo docInfo = dest.getJSDocInfo() == null ?\n             parent.getJSDocInfo() : dest.getJSDocInfo();\n   private final class GlobalGatherer extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         String name = n.getString();\n         Scope.Var var = t.getScope().getVar(name);\n \n         if (global != null) {\n           // If a variable is declared in both externs and normal source,\n           // don't alias it.\n-          if (n.getParent().getType() == Token.VAR ||\n-              n.getParent().getType() == Token.FUNCTION) {\n+          if (n.getParent().isVar() ||\n+              n.getParent().isFunction()) {\n             globals.remove(name);\n           }\n \n           // something that we want to avoid when aliasing, since we may be\n           // dealing with external objects (e.g. ActiveXObject in MSIE)\n           if ((NodeUtil.isAssignmentOp(parent) && isFirst) ||\n-              (parent.getType() == Token.NEW && isFirst) ||\n-              parent.getType() == Token.INC ||\n-              parent.getType() == Token.DEC) {\n+              (parent.isNew() && isFirst) ||\n+              parent.isInc() ||\n+              parent.isDec()) {\n             global.recordMutator(t);\n           } else {\n             global.recordAccessor(t);\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n     @Override\n     public void visit(Node n, Node parent) {\n       Node value = n.getFirstChild();\n-      if (value.getType() == Token.NUMBER && value.getDouble() == 0) {\n+      if (value.isNumber() && value.getDouble() == 0) {\n         super.visit(n, parent);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.STRING &&\n+    if (n.isString() &&\n         parent.getType() != Token.GETPROP &&\n         parent.getType() != Token.REGEXP &&\n         !NodeUtil.isObjectLitKey(n, parent)) {\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n           // ensure that we never rename some other property in a way that\n           // could conflict with this quoted name.\n           Node child = n.getLastChild();\n-          if (child.getType() == Token.STRING) {\n+          if (child.isString()) {\n             quotedNames.add(child.getString());\n           }\n           break;\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n         symbolStack.push(new NameContext(getNameInfoForName(\n                 n.getFirstChild().getLastChild().getString(), PROPERTY)));\n       } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.getType() == Token.NAME ?\n+        String name = parent.isName() ?\n             parent.getString() /* VAR */ :\n             n.getFirstChild().getString() /* named function */;\n         symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         String propName = n.getFirstChild().getNext().getString();\n         if (propName.equals(\"prototype\")) {\n           processPrototypeParent(t, parent);\n         } else {\n           addSymbolUse(propName, t.getModule(), PROPERTY);\n         }\n-      } else if (n.getType() == Token.OBJECTLIT &&\n+      } else if (n.isObjectLit() &&\n           // Make sure that we're not handling object literals being\n           // assigned to a prototype, as in:\n           // Foo.prototype = {bar: 3, baz: 5};\n-          !(parent.getType() == Token.ASSIGN &&\n-            parent.getFirstChild().getType() == Token.GETPROP &&\n+          !(parent.isAssign() &&\n+            parent.getFirstChild().isGetProp() &&\n             parent.getFirstChild().getLastChild().getString().equals(\n                 \"prototype\"))) {\n         // var x = {a: 1, b: 2}\n             addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n           }\n         }\n-      } else if (n.getType() == Token.NAME) {\n+      } else if (n.isName()) {\n         String name = n.getString();\n \n         Var var = t.getScope().getVar(name);\n           // Only process global functions.\n           if (var.isGlobal()) {\n             if (var.getInitialValue() != null &&\n-                var.getInitialValue().getType() == Token.FUNCTION) {\n+                var.getInitialValue().isFunction()) {\n               if (t.inGlobalScope()) {\n                 if (!processGlobalFunctionDeclaration(t, n, parent,\n                         parent.getParent())) {\n     private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n       return t.inGlobalScope() &&\n           (NodeUtil.isFunctionDeclaration(n) ||\n-           n.getType() == Token.FUNCTION &&\n-           n.getParent().getType() == Token.NAME);\n+           n.isFunction() &&\n+           n.getParent().isName());\n     }\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n-          && n.getType() == Token.GETPROP\n-          && assign.getParent().getType() == Token.EXPR_RESULT) {\n+          && n.isGetProp()\n+          && assign.getParent().isExprResult()) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n-            n.getFirstChild().getType() == Token.GETPROP;\n+            n.getFirstChild().isGetProp();\n \n         if (isChainedProperty) {\n           Node child = n.getFirstChild().getFirstChild().getNext();\n \n-          if (child.getType() == Token.STRING &&\n+          if (child.isString() &&\n               child.getString().equals(\"prototype\")) {\n             return true;\n           }\n           Node parent = n.getParent();\n           Node grandParent = parent.getParent();\n \n-          if (dest.getType() == Token.STRING &&\n+          if (dest.isString() &&\n               NodeUtil.isExprAssign(grandParent) &&\n               NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n             String name = dest.getString();\n         // Foo.prototype = { \"getBar\" : function() { ... } }\n         case Token.ASSIGN:\n           Node map = n.getFirstChild().getNext();\n-          if (map.getType() == Token.OBJECTLIT) {\n+          if (map.isObjectLit()) {\n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n               // May be STRING, GET, or SET,\n   private class ProcessExternProperties extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         symbolGraph.connect(externNode, firstModule,\n             getNameInfoForName(n.getLastChild().getString(), PROPERTY));\n       }\n \n     GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n       Preconditions.checkState(\n-          parent.getType() == Token.VAR ||\n+          parent.isVar() ||\n           NodeUtil.isFunctionDeclaration(parent));\n       this.nameNode = nameNode;\n       this.module = module;\n     @Override\n     public void remove() {\n       Node parent = nameNode.getParent();\n-      if (parent.getType() == Token.FUNCTION || parent.hasOneChild()) {\n+      if (parent.isFunction() || parent.hasOneChild()) {\n         NodeUtil.removeChild(parent.getParent(), parent);\n       } else {\n-        Preconditions.checkState(parent.getType() == Token.VAR);\n+        Preconditions.checkState(parent.isVar());\n         parent.removeChild(nameNode);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n         Node functionNameNode = n.getFirstChild();\n         String functionName = functionNameNode.getString();\n         if (functionName.length() == 0) {\n-          if (parent.getType() == Token.ASSIGN) {\n+          if (parent.isAssign()) {\n             // this is an assignment to a property, generally either a\n             // static function or a prototype function\n             // e.g. goog.string.htmlEscape = function() { } or\n             Node lhs = parent.getFirstChild();\n             String name = namer.getName(lhs);\n             namer.setFunctionName(name, n);\n-          } else if (parent.getType() == Token.NAME) {\n+          } else if (parent.isName()) {\n             // this is an assignment to a variable\n             // e.g. var handler = function() {}\n             String name = namer.getName(parent);\n         //      }\n         Node lhs = n.getFirstChild();\n         Node rhs = lhs.getNext();\n-        if (rhs.getType() == Token.OBJECTLIT) {\n+        if (rhs.isObjectLit()) {\n           nameObjectLiteralMethods(rhs, namer.getName(lhs));\n         }\n     }\n \n       // Object literal keys may be STRING, GET, SET. Get and Set\n       // are skipped because they can not be named.\n-      if (keyNode.getType() == Token.STRING) {\n+      if (keyNode.isString()) {\n         // concatenate the context and key name to get a new qualified name.\n         String name = namer.getCombinedName(context, namer.getName(keyNode));\n \n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n     Predicate<Node> shouldTraverse = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node n) {\n-        return n.getType() == Token.BLOCK;\n+        return n.isBlock();\n       }\n     };\n     return new AstParallelizer(\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n   }\n \n   private void validateVarOrOptionalExpression(Node n) {\n-    if (n.getType() == Token.VAR) {\n+    if (n.isVar()) {\n       validateVar(n);\n     } else {\n       validateOptionalExpression(n);\n   }\n \n   private void validateVarOrAssignmentTarget(Node n) {\n-    if (n.getType() == Token.VAR) {\n+    if (n.isVar()) {\n       // Only one NAME can be declared for FOR-IN expressions.\n       this.validateChildCount(n, 1);\n       validateVar(n);\n     int defaults = 0;\n     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n       validateSwitchMember(n.getLastChild());\n-      if (c.getType() == Token.DEFAULT) {\n+      if (c.isDefault()) {\n         defaults++;\n       }\n     }\n   }\n \n   private void validateOptionalExpression(Node n) {\n-    if (n.getType() == Token.EMPTY) {\n+    if (n.isEmpty()) {\n       validateChildless(n);\n     } else {\n       validateExpression(n);\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n    * AST Token.CALL or Token.NEW node, or null if no such object exists.\n    */\n   public Callsite getCallsiteForAstNode(Node callsiteNode) {\n-    Preconditions.checkArgument(callsiteNode.getType() == Token.CALL ||\n-        callsiteNode.getType() == Token.NEW);\n+    Preconditions.checkArgument(callsiteNode.isCall() ||\n+        callsiteNode.isNew());\n \n     return callsitesByNode.get(callsiteNode);\n   }\n    */\n   private Collection<Definition> lookupDefinitionsForTargetsOfCall(\n       Node callsite, DefinitionProvider definitionProvider) {\n-    Preconditions.checkArgument(callsite.getType() == Token.CALL\n-        || callsite.getType() == Token.NEW);\n+    Preconditions.checkArgument(callsite.isCall()\n+        || callsite.isNew());\n \n     Node targetExpression = callsite.getFirstChild();\n \n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n    * we know that its un-owned.\n    */\n   private JSType getClassOfMethod(Node n, Node parent) {\n-    if (parent.getType() == Token.ASSIGN) {\n+    if (parent.isAssign()) {\n       Node lValue = parent.getFirstChild();\n       if (NodeUtil.isGet(lValue)) {\n         // We have an assignment of the form \"a.b = ...\".\n         return normalizeClassType(lValue.getJSType());\n       }\n     } else if (NodeUtil.isFunctionDeclaration(n) ||\n-               parent.getType() == Token.NAME) {\n+               parent.isName()) {\n       return normalizeClassType(n.getJSType());\n     }\n \n    */\n   private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n     // Don't bother checking definitions or constructors.\n-    if (parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||\n-        parent.getType() == Token.NEW) {\n+    if (parent.isFunction() || parent.isVar() ||\n+        parent.isNew()) {\n       return;\n     }\n \n    */\n   private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n     // Don't bother checking constructors.\n-    if (parent.getType() == Token.NEW) {\n+    if (parent.isNew()) {\n       return;\n     }\n \n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n       boolean isOverride = parent.getJSDocInfo() != null &&\n-          parent.getType() == Token.ASSIGN &&\n+          parent.isAssign() &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n     // 2) Instantiations of deprecated classes.\n     // For now, we just let everything else by.\n     if (t.inGlobalScope()) {\n-      if (!((parent.getType() == Token.CALL && parent.getFirstChild() == n) ||\n-              n.getType() == Token.NEW)) {\n+      if (!((parent.isCall() && parent.getFirstChild() == n) ||\n+              n.isNew())) {\n         return false;\n       }\n     }\n \n     // We can always assign to a deprecated property, to keep it up to date.\n-    if (n.getType() == Token.GETPROP && n == parent.getFirstChild() &&\n+    if (n.isGetProp() && n == parent.getFirstChild() &&\n         NodeUtil.isAssignmentOp(parent)) {\n       return false;\n     }\n       // Case #2\n       (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) ||\n         // Case #3\n-      (scopeRootParent != null && scopeRootParent.getType() == Token.ASSIGN &&\n+      (scopeRootParent != null && scopeRootParent.isAssign() &&\n        getTypeDeprecationInfo(\n            getClassOfMethod(scopeRoot, scopeRootParent)) != null);\n   }\n    * Returns whether this is a function node annotated as deprecated.\n    */\n   private static boolean isDeprecatedFunction(Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       JSType type = n.getJSType();\n       if (type != null) {\n         return getTypeDeprecationInfo(type) != null;\n--- a/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n     // semicolons cause VOID children. Empty blocks are allowed because\n     // that's usually intentional, especially with loops.\n     for (; child != null; child = child.getNext()) {\n-      if ((child.getType() == Token.BLOCK) && (!child.hasChildren())) {\n+      if ((child.isBlock()) && (!child.hasChildren())) {\n         // Only warn on empty blocks that replaced EMPTY nodes.  BLOCKs with no\n         // children are considered OK.\n         if (child.wasEmptyNode()) {\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Checks references to undefined properties of global variables.\n   private boolean isTypedef(Ref ref) {\n     // If this is an annotated EXPR-GET, don't do anything.\n     Node parent = ref.node.getParent();\n-    if (parent.getType() == Token.EXPR_RESULT) {\n+    if (parent.isExprResult()) {\n       JSDocInfo info = ref.node.getJSDocInfo();\n       if (info != null && info.hasTypedefType()) {\n         return true;\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n   @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n \n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       // Don't traverse functions that are constructors or have the @this\n       // or @override annotation.\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       }\n     }\n \n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n       Node lhs = parent.getFirstChild();\n       Node rhs = lhs.getNext();\n \n         // Only traverse the right side if it's not an assignment to a prototype\n         // property or subproperty.\n         if (NodeUtil.isGet(lhs)) {\n-          if (lhs.getType() == Token.GETPROP &&\n+          if (lhs.isGetProp() &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n           Node llhs = lhs.getFirstChild();\n-          if (llhs.getType() == Token.GETPROP &&\n+          if (llhs.isGetProp() &&\n               llhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n+    if (n.isThis() && shouldReportThis(n, parent)) {\n       compiler.report(t.makeError(n, GLOBAL_THIS));\n     }\n     if (n == assignLhsChild) {\n         jsDoc = parent.getJSDocInfo();\n         if (jsDoc == null && parentType == Token.NAME) {\n           Node gramps = parent.getParent();\n-          if (gramps.getType() == Token.VAR) {\n+          if (gramps.isVar()) {\n             jsDoc = gramps.getJSDocInfo();\n           }\n         }\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.STRING &&\n+    if (n.isString() &&\n         parent.getType() != Token.GETPROP &&\n         parent.getType() != Token.REGEXP &&\n         !NodeUtil.isObjectLitKey(n, parent)) {\n \n   /** Returns whether the node is an argument of a goog.getCssName call. */\n   private boolean insideGetCssNameCall(Node n, Node parent) {\n-    return parent.getType() == Token.CALL &&\n+    return parent.isCall() &&\n         GET_CSS_NAME_FUNCTION.equals(\n             parent.getFirstChild().getQualifiedName());\n   }\n    * GET_UNIQUE_ID_FUNCTION).\n    */\n   private boolean insideGetUniqueIdCall(Node n, Node parent) {\n-    String name = parent.getType() == Token.CALL ?\n+    String name = parent.isCall() ?\n         parent.getFirstChild().getQualifiedName() : null;\n \n     return name != null && name.endsWith(GET_UNIQUE_ID_FUNCTION);\n    * initialization of a variable named *_ID of *_ID_.\n    */\n   private boolean insideAssignmentToIdConstant(Node n, Node parent) {\n-    if (parent.getType() == Token.ASSIGN) {\n+    if (parent.isAssign()) {\n       String qname = parent.getFirstChild().getQualifiedName();\n       return qname != null && isIdName(qname);\n-    } else if (parent.getType() == Token.NAME) {\n+    } else if (parent.isName()) {\n       Node grandParent = parent.getParent();\n-      if (grandParent != null && grandParent.getType() == Token.VAR) {\n+      if (grandParent != null && grandParent.isVar()) {\n         String name = parent.getString();\n         return isIdName(name);\n       } else {\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n     public boolean apply(Node input) {\n       // Check for null because the control flow graph's implicit return node is\n       // represented by null, so this value might be input.\n-      return input != null && input.getType() == Token.RETURN;\n+      return input != null && input.isReturn();\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n+++ b/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n         case Token.ASSIGN:\n           // If the left hand side is \"this.x\", then add x to the lists.\n           Node lhs = node.getFirstChild(), rhs = lhs.getNext();\n-          if (lhs.getType() == Token.GETPROP) {\n+          if (lhs.isGetProp()) {\n             Node llhs = lhs.getFirstChild(), lrhs = llhs.getNext();\n-            if ((llhs.getType() == Token.THIS)\n-                && (lrhs.getType() == Token.STRING)\n+            if ((llhs.isThis())\n+                && (lrhs.isString())\n                 && (lrhs.getNext() == null)) {\n               return flowThrough(rhs, input.copyAndAdd(lrhs.getString()));\n             }\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n           break;\n         case Token.FUNCTION:\n           if (NodeUtil.isFunctionExpression(n)) {\n-            if (parent.getType() == Token.NAME) {\n+            if (parent.isName()) {\n               String functionName = parent.getString();\n               info = (JSDocInfo) parent.getProp(Node.JSDOC_INFO_PROP);\n               if (info != null && info.isConstructor()) {\n               } else {\n                 Node gramps = parent.getParent();\n                 Preconditions.checkState(\n-                    gramps != null && gramps.getType() == Token.VAR);\n+                    gramps != null && gramps.isVar());\n                 info = (JSDocInfo) gramps.getProp(Node.JSDOC_INFO_PROP);\n                 if (info != null && info.isConstructor()) {\n                   constructors.add(functionName);\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n     // I've been unable to think of any cases where this indicates a bug,\n     // and apparently some people like keeping these semicolons around,\n     // so we'll allow it.\n-    if (n.getType() == Token.EMPTY ||\n-        n.getType() == Token.COMMA) {\n+    if (n.isEmpty() ||\n+        n.isComma()) {\n       return;\n     }\n \n     int pt = parent.getType();\n     if (pt == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.getType() == Token.CALL &&\n+      if (gramps.isCall() &&\n           parent == gramps.getFirstChild()) {\n         // Semantically, a direct call to eval is different from an indirect\n         // call to an eval. See Ecma-262 S15.1.2.1. So it's ok for the first\n         // an eval.\n         if (n == parent.getFirstChild() &&\n             parent.getChildCount() == 2 &&\n-            n.getNext().getType() == Token.NAME &&\n+            n.getNext().isName() &&\n             \"eval\".equals(n.getNext().getString())) {\n           return;\n         }\n       }\n \n       String msg = \"This code lacks side-effects. Is there a bug?\";\n-      if (n.getType() == Token.STRING) {\n+      if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Node.tokenToName(n.getType()) +\n--- a/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n import java.util.Set;\n \n       do {\n         ancestor = ancestor.getParent();\n         assignAncestors.add(ancestor);\n-      } while (ancestor.getType() == Token.ASSIGN &&\n+      } while (ancestor.isAssign() &&\n                ancestor.getFirstChild().isQualifiedName());\n       lastAncestor = ancestor.getParent();\n     }\n   private class FindAbstractMethods extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.ASSIGN) {\n+      if (n.isAssign()) {\n         Node nameNode = n.getFirstChild();\n         Node valueNode = n.getLastChild();\n \n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         String fnName = n.getFirstChild().getQualifiedName();\n         if (assertionNames.contains(fnName)) {\n           assertionCalls.add(n);\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       // goog.mixin(SubClass.prototype, SuperClass.prototype)\n       // goog$mixin(SubClass.prototype, SuperClass.prototype)\n       boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n-          callName.getType() == Token.GETPROP;\n+          callName.isGetProp();\n       if (isDeprecatedCall) {\n         // SubClass.inherits(SuperClass)\n         subclass = callName.getFirstChild();\n   private SubclassType typeofClassDefiningName(Node callName) {\n     // Check if the method name matches one of the class-defining methods.\n     String methodName = null;\n-    if (callName.getType() == Token.GETPROP) {\n+    if (callName.isGetProp()) {\n       methodName = callName.getLastChild().getString();\n-    } else if (callName.getType() == Token.NAME) {\n+    } else if (callName.isName()) {\n       String name = callName.getString();\n       int dollarIndex = name.lastIndexOf('$');\n       if (dollarIndex != -1) {\n    * a.b.c.prototype => true\n    */\n   private boolean endsWithPrototype(Node qualifiedName) {\n-    return qualifiedName.getType() == Token.GETPROP &&\n+    return qualifiedName.isGetProp() &&\n         qualifiedName.getLastChild().getString().equals(\"prototype\");\n   }\n \n     String className = null;\n     if (NodeUtil.isExprCall(parent)) {\n       Node callee = node.getFirstChild();\n-      if (callee != null && callee.getType() == Token.GETPROP) {\n+      if (callee != null && callee.isGetProp()) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null && target.getType() == Token.STRING) {\n+          if (target != null && target.isString()) {\n             className = target.getString();\n           }\n         }\n         List<String> typeNames = Lists.newArrayList();\n         for (Node name = typeArray.getFirstChild(); name != null;\n              name = name.getNext()) {\n-          if (name.getType() == Token.STRING) {\n+          if (name.isString()) {\n             typeNames.add(name.getString());\n           }\n         }\n \n   @Override\n   public boolean isPropertyTestFunction(Node call) {\n-    Preconditions.checkArgument(call.getType() == Token.CALL);\n+    Preconditions.checkArgument(call.isCall());\n     return propertyTestFunctions.contains(\n         call.getFirstChild().getQualifiedName());\n   }\n   @Override\n   public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n       Node callNode) {\n-    Preconditions.checkArgument(callNode.getType() == Token.CALL);\n+    Preconditions.checkArgument(callNode.isCall());\n     Node callName = callNode.getFirstChild();\n     if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n         callNode.getChildCount() != 3) {\n--- a/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         String fnName = n.getFirstChild().getQualifiedName();\n         if (\"goog$object$create\".equals(fnName) ||\n             \"goog.object.create\".equals(fnName)) {\n--- a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n \n package com.google.javascript.jscomp;\n \n-import static com.google.javascript.rhino.Token.CALL;\n-import static com.google.javascript.rhino.Token.GETPROP;\n-import static com.google.javascript.rhino.Token.NAME;\n-import static com.google.javascript.rhino.Token.STRING;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n   @Override\n   public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n       FlowScope blindScope, boolean outcome) {\n-    if (condition.getType() == CALL && condition.getChildCount() == 2) {\n+    if (condition.isCall() && condition.getChildCount() == 2) {\n       Node callee = condition.getFirstChild();\n       Node param = condition.getLastChild();\n-      if (callee.getType() == GETPROP && param.isQualifiedName()) {\n+      if (callee.isGetProp() && param.isQualifiedName()) {\n         JSType paramType =  getTypeIfRefinable(param, blindScope);\n         Node left = callee.getFirstChild();\n         Node right = callee.getLastChild();\n-        if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n-            right.getType() == STRING) {\n+        if (left.isName() && \"goog\".equals(left.getString()) &&\n+            right.isString()) {\n           Function<TypeRestriction, JSType> restricter =\n               restricters.get(right.getString());\n           if (restricter != null) {\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n           continue NEXT_VAR_PAIR;\n         }\n \n-        if (v1.getParentNode().getType() == Token.LP &&\n-            v2.getParentNode().getType() == Token.LP) {\n+        if (v1.getParentNode().isLP() &&\n+            v2.getParentNode().isLP()) {\n           interferenceGraph.connectIfNotFound(v1, null, v2);\n           continue NEXT_VAR_PAIR;\n         }\n     private static boolean isAssignTo(Var var, Node n, Node parent) {\n       if (n.isName() && var.getName().equals(n.getString()) &&\n           parent != null) {\n-        if (parent.getType() == Token.LP) {\n+        if (parent.isLP()) {\n           // In a function declaration, the formal parameters are assigned.\n           return true;\n         } else if (parent.isVar()) {\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n     switch (type) {\n       case Token.TRY: {\n-        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n+        Preconditions.checkState(first.getNext().isBlock() &&\n                 !first.getNext().hasMoreThanOneChild());\n         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n \n         break;\n \n       case Token.NAME:\n-        if (first == null || first.getType() == Token.EMPTY) {\n+        if (first == null || first.isEmpty()) {\n           addIdentifier(n.getString());\n         } else {\n           Preconditions.checkState(childCount == 1);\n           addIdentifier(n.getString());\n           cc.addOp(\"=\", true);\n-          if (first.getType() == Token.COMMA) {\n+          if (first.isComma()) {\n             addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n           } else {\n             // Add expression, consider nearby code at lowest level of\n         // It's important to our sanity checker that the code\n         // we print produces the same AST as the code we parse back.\n         // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n-        if (n.getFirstChild().getType() == Token.NUMBER) {\n+        if (n.getFirstChild().isNumber()) {\n           cc.addNumber(-n.getFirstChild().getDouble());\n         } else {\n           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n \n       case Token.GET:\n       case Token.SET:\n-        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n+        Preconditions.checkState(n.getParent().isObjectLit());\n         Preconditions.checkState(childCount == 1);\n-        Preconditions.checkState(first.getType() == Token.FUNCTION);\n+        Preconditions.checkState(first.isFunction());\n \n         // Get methods are unnamed\n         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             (type == Token.BLOCK &&\n                 !preserveBlock &&\n                 n.getParent() != null &&\n-                n.getParent().getType() == Token.SCRIPT);\n+                n.getParent().isScript());\n         for (Node c = first; c != null; c = c.getNext()) {\n           add(c, Context.STATEMENT);\n \n           // VAR doesn't include ';' since it gets used in expressions\n-          if (c.getType() == Token.VAR) {\n+          if (c.isVar()) {\n             cc.endStatement();\n           }\n \n-          if (c.getType() == Token.FUNCTION) {\n+          if (c.isFunction()) {\n             cc.maybeLineBreak();\n           }\n \n       case Token.FOR:\n         if (childCount == 4) {\n           add(\"for(\");\n-          if (first.getType() == Token.VAR) {\n+          if (first.isVar()) {\n             add(first, Context.IN_FOR_INIT_CLAUSE);\n           } else {\n             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n             childCount == 2,\n             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n         Preconditions.checkState(\n-            last.getType() == Token.STRING,\n+            last.isString(),\n             \"Bad GETPROP: RHS should be STRING\");\n-        boolean needsParens = (first.getType() == Token.NUMBER);\n+        boolean needsParens = (first.isNumber());\n         if (needsParens) {\n           add(\"(\");\n         }\n       case Token.STRING:\n         if (childCount !=\n             ((n.getParent() != null &&\n-              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n+              n.getParent().isObjectLit()) ? 1 : 0)) {\n           throw new IllegalStateException(\n               \"Unexpected String children: \" + n.getParent().toStringTree());\n         }\n             cc.listSeparator();\n           }\n \n-          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n+          if (c.isGet() || c.isSet()) {\n             add(c);\n           } else {\n-            Preconditions.checkState(c.getType() == Token.STRING);\n+            Preconditions.checkState(c.isString());\n             String key = c.getString();\n             // Object literal property names don't have to be quoted if they\n             // are not JavaScript keywords\n    * @return Whether the name is an indirect eval.\n    */\n   private boolean isIndirectEval(Node n) {\n-    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n+    return n.isName() && \"eval\".equals(n.getString()) &&\n         !n.getBooleanProp(Node.DIRECT_EVAL);\n   }\n \n \n     // Strip unneeded blocks, that is blocks with <2 children unless\n     // the CodePrinter specifically wants to keep them.\n-    if (n.getType() == Token.BLOCK) {\n+    if (n.isBlock()) {\n       int count = getNonEmptyChildCount(n, 2);\n       if (count == 0) {\n         if (cc.shouldPreserveExtraBlocks()) {\n       }\n     }\n \n-    if (nodeToProcess.getType() == Token.EMPTY) {\n+    if (nodeToProcess.isEmpty()) {\n       cc.endStatement(true);\n     } else {\n       add(nodeToProcess, context);\n \n       // VAR doesn't include ';' since it gets used in expressions - so any\n       // VAR in a statement context needs a call to endStatement() here.\n-      if (nodeToProcess.getType() == Token.VAR) {\n+      if (nodeToProcess.isVar()) {\n         cc.endStatement();\n       }\n     }\n    * labels).\n    */\n   private boolean isOneExactlyFunctionOrDo(Node n) {\n-    if (n.getType() == Token.LABEL) {\n+    if (n.isLabel()) {\n       Node labeledStatement = n.getLastChild();\n       if (labeledStatement.getType() != Token.BLOCK) {\n         return isOneExactlyFunctionOrDo(labeledStatement);\n         }\n       }\n     } else {\n-      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n+      return (n.isFunction() || n.isDo());\n     }\n   }\n \n         cc.listSeparator();\n       }\n       addExpr(n, 1);\n-      lastWasEmpty = n.getType() == Token.EMPTY;\n+      lastWasEmpty = n.isEmpty();\n     }\n \n     if (lastWasEmpty) {\n     int i = 0;\n     Node c = n.getFirstChild();\n     for (; c != null && i < maxCount; c = c.getNext()) {\n-      if (c.getType() == Token.BLOCK) {\n+      if (c.isBlock()) {\n         i += getNonEmptyChildCount(c, maxCount-i);\n       } else if (c.getType() != Token.EMPTY) {\n         i++;\n   /** Gets the first non-empty child of the given node. */\n   private static Node getFirstNonEmptyChild(Node n) {\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (c.getType() == Token.BLOCK) {\n+      if (c.isBlock()) {\n         Node result = getFirstNonEmptyChild(c);\n         if (result != null) {\n           return result;\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n      */\n     @Override\n     boolean breakAfterBlockFor(Node n,  boolean isStatementContext) {\n-      Preconditions.checkState(n.getType() == Token.BLOCK);\n+      Preconditions.checkState(n.isBlock());\n       Node parent = n.getParent();\n       if (parent != null) {\n         int type = parent.getType();\n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n         }\n       }\n \n-      if (callTarget.getType() == Token.GETPROP\n+      if (callTarget.isGetProp()\n           && callTarget.getLastChild().getString().equals(\"bind\")\n-          && callTarget.getFirstChild().getType() == Token.FUNCTION) {\n+          && callTarget.getFirstChild().isFunction()) {\n         // (function(){}).bind(self, args...);\n         Node fn = callTarget.getFirstChild();\n         Node thisValue = callTarget.getNext();\n--- a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n       // definitions are added to scopes before the start of execution.\n \n       Node grandparent = parent.getParent();\n-      if (!(parent.getType() == Token.SCRIPT ||\n+      if (!(parent.isScript() ||\n             grandparent != null &&\n-            grandparent.getType() == Token.FUNCTION &&\n-            parent.getType() == Token.BLOCK)) {\n+            grandparent.isFunction() &&\n+            parent.isBlock())) {\n         return;\n       }\n \n       Node name = n.getFirstChild();\n       Node value = name.getFirstChild();\n       if (value != null &&\n-          value.getType() == Token.FUNCTION &&\n+          value.isFunction() &&\n           !isRecursiveFunction(value)) {\n         Node fnName = value.getFirstChild();\n         fnName.setString(name.getString());\n     }\n \n     private boolean containsName(Node n, String name) {\n-      if (n.getType() == Token.NAME && n.getString().equals(name)) {\n+      if (n.isName() && n.getString().equals(name)) {\n         return true;\n       }\n \n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     // then the NAME must be the child of a VAR node, and we must\n     // be in a VAR assignment.\n     Node aliasParent = alias.node.getParent();\n-    if (aliasParent.getType() == Token.NAME) {\n+    if (aliasParent.isName()) {\n       // Ensure that the local variable is well defined and never reassigned.\n       Scope scope = alias.scope;\n       Var aliasVar = scope.getVar(aliasParent.getString());\n     Node varNode = new Node(Token.VAR, nameNode).copyInformationFrom(nameNode);\n \n     Preconditions.checkState(\n-        ref.node.getParent().getType() == Token.EXPR_RESULT);\n+        ref.node.getParent().isExprResult());\n     Node parent = ref.node.getParent();\n     Node gramps = parent.getParent();\n     gramps.replaceChild(parent, varNode);\n     String originalName = n.getFullName();\n     Ref decl = n.getDeclaration();\n     if (decl != null && decl.node != null &&\n-        decl.node.getType() == Token.GETPROP) {\n+        decl.node.isGetProp()) {\n       flattenNameRefAtDepth(alias, decl.node, depth, originalName);\n     }\n \n     Node ref = NodeUtil.newName(\n         compiler.getCodingConvention(), alias, n, originalName);\n     NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n-    if (parent.getType() == Token.CALL && n == parent.getFirstChild()) {\n+    if (parent.isCall() && n == parent.getFirstChild()) {\n       // The node was a call target, we are deliberately flatten these as\n       // we node the \"this\" isn't provided by the namespace. Mark it as such:\n       parent.putBooleanProp(Node.FREE_CALL, true);\n             p.canCollapse() &&\n             p.getDeclaration().node != null &&\n             p.getDeclaration().node.getParent() != null &&\n-            p.getDeclaration().node.getParent().getType() == Token.ASSIGN) {\n+            p.getDeclaration().node.getParent().isAssign()) {\n           updateSimpleDeclaration(\n               appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());\n         }\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n \n-    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n+    if (rvalue != null && rvalue.isFunction()) {\n       checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n     }\n \n         refName.getFullName());\n     NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n \n-    if (gramps.getType() == Token.EXPR_RESULT) {\n+    if (gramps.isExprResult()) {\n       // BEFORE: a.b.c = ...;\n       //   exprstmt\n       //     assign\n     Node varNode = new Node(Token.VAR);\n     Node varParent = ref.node.getAncestor(3);\n     Node gramps = ref.node.getAncestor(2);\n-    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n+    boolean isObjLit = rvalue.isObjectLit();\n     boolean insertedVarNode = false;\n \n     if (isObjLit && n.canEliminate()) {\n \n     } else if (!n.isSimpleName()) {\n       // Create a VAR node to declare the name.\n-      if (rvalue.getType() == Token.FUNCTION) {\n+      if (rvalue.isFunction()) {\n         checkForHosedThisReferences(rvalue, n.docInfo, n);\n       }\n \n           new NodeTraversal.AbstractShallowCallback() {\n             @Override\n             public void visit(NodeTraversal t, Node n, Node parent) {\n-              if (n.getType() == Token.THIS) {\n+              if (n.isThis()) {\n                 compiler.report(\n                     JSError.make(name.getDeclaration().getSourceName(), n,\n                         UNSAFE_THIS, name.getFullName()));\n     Node varNode = ref.node.getParent();\n     Node gramps = varNode.getParent();\n \n-    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n+    boolean isObjLit = rvalue.isObjectLit();\n     int numChanges = 0;\n \n     if (isObjLit) {\n       nextKey = key.getNext();\n \n       // A get or a set can not be rewritten as a VAR.\n-      if (key.getType() == Token.GET || key.getType() == Token.SET) {\n+      if (key.isGet() || key.isSet()) {\n         continue;\n       }\n \n \n         p.getDeclaration().node = nameNode;\n \n-        if (value.getType() == Token.FUNCTION) {\n+        if (value.isFunction()) {\n           checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n         }\n       }\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.VAR) {\n+      if (n.isVar()) {\n         blacklistStubVars(t, n);\n       }\n \n \n       // Adjacent VAR children of an IF node are the if and else parts and can't\n       // be collapsed\n-      if (parent.getType() == Token.IF) return;\n+      if (parent.isIf()) return;\n \n       Node varNode = n;\n \n-      boolean hasVar = n.getType() == Token.VAR;\n+      boolean hasVar = n.isVar();\n \n       // Find variable declarations that follow this one (if any)\n       n = n.getNext();\n       boolean hasNodesToCollapse = false;\n \n       while (n != null &&\n-          (n.getType() == Token.VAR || canBeRedeclared(n, t.getScope()))) {\n+          (n.isVar() || canBeRedeclared(n, t.getScope()))) {\n \n         if (n.isVar()) {\n           blacklistStubVars(t, n);\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n           if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n             cb.append(\"\\n\");  // Make sure that the label starts on a new line\n           }\n-          Preconditions.checkState(root.getType() == Token.SCRIPT);\n+          Preconditions.checkState(root.isScript());\n \n           String delimiter = options.inputDelimiter;\n \n   @Override\n   void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n       Node collectionRoot) {\n-    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n-        || collectionRoot.getType() == Token.BLOCK);\n+    Preconditions.checkState(collectionRoot.isScript()\n+        || collectionRoot.isBlock());\n     if (globalRefMap == null) {\n       globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n           getExternsInOrder());\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n     Node root = ast.getAstRoot(compiler);\n     // The root maybe null if the AST can not be created.\n     if (root != null) {\n-      Preconditions.checkState(root.getType() == Token.SCRIPT);\n+      Preconditions.checkState(root.isScript());\n       Preconditions.checkNotNull(root.getInputId());\n     }\n     return root;\n     }\n \n     void visitSubtree(Node n, Node parent) {\n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         String require =\n             codingConvention.extractClassNameIfRequire(n, parent);\n         if (require != null) {\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n       this.declaration = declaration;\n       this.parentScope = parentScope;\n \n-      Preconditions.checkArgument(declaration.getType() == Token.FUNCTION);\n+      Preconditions.checkArgument(declaration.isFunction());\n       Preconditions.checkArgument(declaration.getJSType() != null);\n       Preconditions.checkArgument(declaration.getJSType().isFunctionType());\n     }\n--- a/src/com/google/javascript/jscomp/ConstCheck.java\n+++ b/src/com/google/javascript/jscomp/ConstCheck.java\n     switch (n.getType()) {\n       case Token.NAME:\n         if (parent != null &&\n-            parent.getType() == Token.VAR &&\n+            parent.isVar() &&\n             n.hasChildren()) {\n           String name = n.getString();\n           Scope.Var var = t.getScope().getVar(name);\n       case Token.ASSIGN_DIV:\n       case Token.ASSIGN_MOD: {\n         Node lhs = n.getFirstChild();\n-        if (lhs.getType() == Token.NAME) {\n+        if (lhs.isName()) {\n           String name = lhs.getString();\n           Scope.Var var = t.getScope().getVar(name);\n           if (isConstant(var)) {\n       case Token.INC:\n       case Token.DEC: {\n         Node lhs = n.getFirstChild();\n-        if (lhs.getType() == Token.NAME) {\n+        if (lhs.isName()) {\n           String name = lhs.getString();\n           Scope.Var var = t.getScope().getVar(name);\n           if (isConstant(var)) {\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n       // priority of them too.\n       for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n         Node value = candidate.getValue();\n-        if (value != null && value.getType() == Token.FUNCTION) {\n+        if (value != null && value.isFunction()) {\n           Preconditions.checkState(\n               !nodePriorities.containsKey(candidate) || candidate == entry);\n           prioritizeFromEntryNode(candidate);\n     // Look for the next CASE, skipping over DEFAULT.\n     Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n     if (next != null) { // Found a CASE\n-      Preconditions.checkState(next.getType() == Token.CASE);\n+      Preconditions.checkState(next.isCase());\n       createEdge(node, Branch.ON_FALSE, next);\n     } else { // No more CASE found, go back and search for a DEFAULT.\n       Node parent = node.getParent();\n   private void handleStmtList(Node node) {\n     Node parent = node.getParent();\n     // Special case, don't add a block of empty CATCH block to the graph.\n-    if (node.getType() == Token.BLOCK && parent != null &&\n-        parent.getType() == Token.TRY &&\n+    if (node.isBlock() && parent != null &&\n+        parent.isTry() &&\n         NodeUtil.getCatchBlock(parent) == node &&\n         !NodeUtil.hasCatchHandler(node)) {\n       return;\n \n     // Function declarations are skipped since control doesn't go into that\n     // function (unless it is called)\n-    while (child != null && child.getType() == Token.FUNCTION) {\n+    while (child != null && child.isFunction()) {\n       child = child.getNext();\n     }\n \n         case Token.TRY:\n           break;\n         default:\n-          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n+          if (node.isBlock() && node.isSyntheticBlock()) {\n             createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n           }\n           break;\n     for (cur = node, lastJump = node;\n         !isBreakTarget(cur, label);\n         cur = parent, parent = parent.getParent()) {\n-      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)\n+      if (cur.isTry() && NodeUtil.hasFinally(cur)\n           && cur.getLastChild() != previous) {\n         if (lastJump == node) {\n           createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n     for (cur = node, lastJump = node;\n         !isContinueTarget(cur, parent, label);\n         cur = parent, parent = parent.getParent()) {\n-      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)\n+      if (cur.isTry() && NodeUtil.hasFinally(cur)\n           && cur.getLastChild() != previous) {\n         if (lastJump == node) {\n           createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n      * This will make life easier for DFAs.\n      */\n     Node parent = node.getParent();\n-    if (parent == null || parent.getType() == Token.FUNCTION ||\n+    if (parent == null || parent.isFunction() ||\n         (cfa != null && node == cfa.root)) {\n       return null;\n     }\n         // After the body of a CASE, the control goes to the body of the next\n         // case, without having to go to the case condition.\n         if (parent.getNext() != null) {\n-          if (parent.getNext().getType() == Token.CASE) {\n+          if (parent.getNext().isCase()) {\n             return parent.getNext().getFirstChild().getNext();\n-          } else if (parent.getNext().getType() == Token.DEFAULT) {\n+          } else if (parent.getNext().isDefault()) {\n             return parent.getNext().getFirstChild();\n           } else {\n             Preconditions.checkState(false, \"Not reachable\");\n     Node nextSibling = node.getNext();\n \n     // Skip function declarations because control doesn't get pass into it.\n-    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n+    while (nextSibling != null && nextSibling.isFunction()) {\n       nextSibling = nextSibling.getNext();\n     }\n \n         if (handler.isFunction()) {\n           return;\n         }\n-        Preconditions.checkState(handler.getType() == Token.TRY);\n+        Preconditions.checkState(handler.isTry());\n         Node catchBlock = NodeUtil.getCatchBlock(handler);\n \n         if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n     if (label == null) {\n       return true;\n     }\n-    while (target.getType() == Token.LABEL) {\n+    while (target.isLabel()) {\n       if (target.getFirstChild().getString().equals(label)) {\n         return true;\n       }\n    * @return The CATCH node or null there is no catch handler.\n    */\n   static Node getCatchHandlerForBlock(Node block) {\n-    if (block.getType() == Token.BLOCK &&\n-        block.getParent().getType() == Token.TRY &&\n+    if (block.isBlock() &&\n+        block.getParent().isTry() &&\n         block.getParent().getFirstChild() == block) {\n       for (Node s = block.getNext(); s != null; s = s.getNext()) {\n         if (NodeUtil.hasCatchHandler(s)) {\n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n       case Token.GETELEM:\n         Node left = n.getFirstChild();\n         Node right = left.getNext();\n-        if (right.getType() == Token.STRING &&\n+        if (right.isString() &&\n             NodeUtil.isValidPropertyName(right.getString())) {\n           n.removeChild(left);\n           n.removeChild(right);\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n \n     boolean recursive = false;\n     Node rootNode = t.getScope().getRootNode();\n-    if (rootNode.getType() == Token.FUNCTION) {\n+    if (rootNode.isFunction()) {\n \n       // CASE #1:\n       String scopeFuncName = rootNode.getFirstChild().getString();\n       Node scopeFuncParent = rootNode.getParent();\n       if (scopeFuncName.equals(name)) {\n         recursive = true;\n-      } else if (scopeFuncParent.getType() == Token.NAME &&\n+      } else if (scopeFuncParent.isName() &&\n           scopeFuncParent.getString().equals(name)) {\n         recursive = true;\n       } else {\n         for (Scope s = t.getScope();\n              s.getParent() != null; s = s.getParent()) {\n           Node curRoot = s.getRootNode();\n-          if (curRoot.getParent().getType() == Token.ASSIGN) {\n+          if (curRoot.getParent().isAssign()) {\n             Node owner = curRoot.getParent().getFirstChild();\n-            while (owner.getType() == Token.GETPROP) {\n+            while (owner.isGetProp()) {\n               owner = owner.getFirstChild();\n             }\n-            if (owner.getType() == Token.NAME &&\n+            if (owner.isName() &&\n                 owner.getString().equals(name)) {\n               recursive = true;\n               break;\n         // Look for assignment expressions where the name is the root\n         // of a qualified name on the left hand side of the assignment.\n         for (Node current : name.getAncestors()) {\n-          if (current.getType() == Token.GETPROP) {\n+          if (current.isGetProp()) {\n             // fallthrough\n-          } else if (current.getType() == Token.ASSIGN &&\n+          } else if (current.isAssign() &&\n                      current.getFirstChild() == child) {\n             Node currentParent = current.getParent();\n             if (NodeUtil.isExpressionNode(currentParent) &&\n     // d) an array/object literal of movable values.\n     // e) a function stub generated by CrossModuleMethodMotion.\n     if (n == null || NodeUtil.isLiteralValue(n, true) ||\n-        n.getType() == Token.FUNCTION) {\n+        n.isFunction()) {\n       return true;\n-    } else if (n.getType() == Token.CALL) {\n+    } else if (n.isCall()) {\n       Node functionName = n.getFirstChild();\n-      return functionName.getType() == Token.NAME &&\n+      return functionName.isName() &&\n           (functionName.getString().equals(\n               CrossModuleMethodMotion.STUB_METHOD_NAME) ||\n            functionName.getString().equals(\n               CrossModuleMethodMotion.UNSTUB_METHOD_NAME));\n     } else if (n.getType() == Token.ARRAYLIT ||\n-        n.getType() == Token.OBJECTLIT) {\n-      boolean isObjectLit = n.getType() == Token.OBJECTLIT;\n+        n.isObjectLit()) {\n+      boolean isObjectLit = n.isObjectLit();\n       for (Node child = n.getFirstChild(); child != null;\n            child = child.getNext()) {\n         if (!canMoveValue(isObjectLit ? child.getFirstChild() : child)) {\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         // behavior.\n         Node value = prop.getValue();\n         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n-            value.getType() == Token.FUNCTION) {\n+            value.isFunction()) {\n           Node valueParent = value.getParent();\n-          if (valueParent.getType() == Token.GET\n-              || valueParent.getType() == Token.SET) {\n+          if (valueParent.isGet()\n+              || valueParent.isSet()) {\n             // TODO(johnlenz): a GET or SET can't be deferred like a normal\n             // FUNCTION property definition as a mix-in would get the result\n             // of a GET instead of the function itself.\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n import com.google.javascript.jscomp.graph.Annotation;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.ArrayList;\n import java.util.Comparator;\n import java.util.Iterator;\n     //    begin with.\n     for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n       Var var = i.next();\n-      if (var.getParentNode().getType() == Token.CATCH ||\n+      if (var.getParentNode().isCatch() ||\n           compiler.getCodingConvention().isExported(var.getName())) {\n         escaped.add(var);\n       }\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n     @Override\n     public boolean apply(Node n) {\n       return (NodeUtil.isAssignmentOp(n) &&\n-              n.getFirstChild().getType() == Token.NAME) ||\n-          n.getType() == Token.INC || n.getType() == Token.DEC;\n+              n.getFirstChild().isName()) ||\n+          n.isInc() || n.isDec();\n     }\n   };\n \n     Node parent = n.getParent();\n \n     if (NodeUtil.isAssignmentOp(n) ||\n-        n.getType() == Token.INC || n.getType() == Token.DEC) {\n+        n.isInc() || n.isDec()) {\n \n       Node lhs = n.getFirstChild();\n       Node rhs = lhs.getNext();\n         n.removeChild(lhs);\n         Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);\n         parent.replaceChild(n, op);\n-      } else if (n.getType() == Token.INC || n.getType() == Token.DEC) {\n+      } else if (n.isInc() || n.isDec()) {\n         if (NodeUtil.isExpressionNode(parent)) {\n           parent.replaceChild(n,\n               new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n)));\n-        } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) {\n+        } else if(n.isComma() && n != parent.getLastChild()) {\n           parent.removeChild(n);\n-        } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) &&\n+        } else if (parent.isFor() && !NodeUtil.isForIn(parent) &&\n             NodeUtil.getConditionExpression(parent) != n) {\n           parent.replaceChild(n, new Node(Token.EMPTY));\n         } else {\n \n     if (n.isName() && variable.equals(n.getString())) {\n       if (NodeUtil.isVarOrSimpleAssignLhs(n, n.getParent())) {\n-        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n+        Preconditions.checkState(n.getParent().isAssign());\n         // The expression to which the assignment is made is evaluated before\n         // the RHS is evaluated (normal left to right evaluation) but the KILL\n         // occurs after the RHS is evaluated.\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n           isExtern);\n-    } else if (parent.getType() == Token.LP) {\n+    } else if (parent.isLP()) {\n       Node function = parent.getParent();\n       return new FunctionArgumentDefinition(function, n, isExtern);\n     }\n       return true;\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return true;\n-    } else if (parent.getType() == Token.LP) {\n+    } else if (parent.isLP()) {\n       return true;\n     }\n     return false;\n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n           compiler.reportCodeChange();\n         }\n       }\n-    } else if (nextSibling.getType() == Token.FOR\n-        && nextSibling.getFirstChild().getType() == Token.EMPTY) {\n+    } else if (nextSibling.isFor()\n+        && nextSibling.getFirstChild().isEmpty()) {\n \n       // Does the current node contain an in operator?  If so, embedding\n       // the expression in a for loop can cause some Javascript parsers (such\n \n     @Override\n     public void visit(NodeTraversal t, Node node, Node parent) {\n-      if (node.getType() == Token.NAME || node.getType() == Token.STRING) {\n+      if (node.isName() || node.isString()) {\n         node.removeProp(Node.IS_CONSTANT_NAME);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n       parent.addChildToFront(\n           Node.newString(Token.NAME, newMethodName)\n               .copyInformationFrom(node));\n-      Preconditions.checkState(parent.getType() == Token.CALL);\n+      Preconditions.checkState(parent.isCall());\n       parent.putBooleanProp(Node.FREE_CALL, true);\n       compiler.reportCodeChange();\n \n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n import com.google.javascript.jscomp.graph.StandardUnionFind;\n import com.google.javascript.jscomp.graph.UnionFind;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n   private class FindExternProperties extends AbstractScopingCallback {\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       // TODO(johnlenz): Support object-literal property definitions.\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         String field = n.getLastChild().getString();\n         T type = typeSystem.getType(getScope(), n.getFirstChild(), field);\n         Property prop = getProperty(field);\n   private class FindRenameableProperties extends AbstractScopingCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         handleGetProp(t, n);\n-      } else if (n.getType() == Token.OBJECTLIT) {\n+      } else if (n.isObjectLit()) {\n         handleObjectLit(t, n);\n       }\n     }\n             JSType jsType = (JSType) type;\n             String qName = n.getFirstChild().getQualifiedName();\n             if (jsType.isAllType() || jsType.isUnknownType()) {\n-              if (n.getFirstChild().getType() == Token.THIS) {\n+              if (n.getFirstChild().isThis()) {\n                 suggestion = \"The \\\"this\\\" object is unknown in the function,\"+\n                     \"consider using @this\";\n               } else {\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n-    } else if (rightValue.getType() == Token.ASSIGN) {\n+    } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n     }\n         // they may be implemented  setter functions, and oftentimes\n         // setter functions fail on native objects. This is ok for \"THIS\"\n         // objects, because we assume that they are non-native.\n-        return !isLValue || value.getFirstChild().getType() == Token.THIS;\n+        return !isLValue || value.getFirstChild().isThis();\n \n       case Token.NAME:\n         return true;\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.getType() == Token.NAME ||\n-              leftSide.getType() == Token.GETPROP &&\n-              leftSide.getFirstChild().getType() == Token.THIS) {\n+          if (leftSide.isName() ||\n+              leftSide.isGetProp() &&\n+              leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n     // No checks are needed for simple names.\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.getType() == Token.GETPROP);\n+    Preconditions.checkArgument(node.isGetProp());\n \n     Node name = node.getFirstChild();\n-    if (name.getType() == Token.NAME\n+    if (name.isName()\n         && isNameAssignedTo(name.getString(), replacement)) {\n       return false;\n     }\n       }\n     }\n \n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n       Node parent = node.getParent();\n-      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == node) {\n+      if (parent.isAssign() && parent.getFirstChild() == node) {\n         if (name.equals(node.getString())) {\n           return true;\n         }\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n         return;\n       }\n \n-      if (parent.getType() == Token.SCRIPT) {\n+      if (parent.isScript()) {\n         if (NodeUtil.isFunctionDeclaration(n)) {\n           // Check for a test function statement.\n           String functionName = NodeUtil.getFunctionName(n);\n             n.getLastChild().getType() != Token.ASSIGN) {\n         // Check for a test method assignment.\n         Node grandparent = parent.getParent();\n-        if (grandparent != null && grandparent.getType() == Token.SCRIPT) {\n+        if (grandparent != null && grandparent.isScript()) {\n           String functionName = n.getFirstChild().getQualifiedName();\n           if (isTestFunction(n, functionName)) {\n             exportTestFunctionAsProperty(functionName, parent, n, grandparent);\n         return false;\n       }\n       Node grandchild = node.getFirstChild().getFirstChild();\n-      return grandchild != null && grandchild.getType() == Token.FUNCTION;\n+      return grandchild != null && grandchild.isFunction();\n     }\n   }\n \n         compiler.getCodingConvention(),\n         exportSymbolFunction, node, testFunctionName);\n     Node call = new Node(Token.CALL, exportCallTarget);\n-    if (exportCallTarget.getType() == Token.NAME) {\n+    if (exportCallTarget.isName()) {\n       call.putBooleanProp(Node.FREE_CALL, true);\n     }\n     call.addChildToBack(Node.newString(testFunctionName));\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n     } else {\n       // Only conditionals that are the direct child of an expression statement\n       // don't need results, for those simply replace the expression statement.\n-      Preconditions.checkArgument(parent.getType() == Token.EXPR_RESULT);\n+      Preconditions.checkArgument(parent.isExprResult());\n       Node gramps = parent.getParent();\n       gramps.replaceChild(parent, ifNode);\n     }\n    * @return The replacement node.\n    */\n   private Node rewriteCallExpression(Node call, DecompositionState state) {\n-    Preconditions.checkArgument(call.getType() == Token.CALL);\n+    Preconditions.checkArgument(call.isCall());\n     Node first = call.getFirstChild();\n     Preconditions.checkArgument(NodeUtil.isGet(first));\n \n     Node injectionPoint = expressionRoot;\n \n     Node parent = injectionPoint.getParent();\n-    while (parent.getType() == Token.LABEL) {\n+    while (parent.isLabel()) {\n       injectionPoint = parent;\n       parent = injectionPoint.getParent();\n     }\n           //\n           Node first = parent.getFirstChild();\n           if (requiresDecomposition\n-              && parent.getType() == Token.CALL\n+              && parent.isCall()\n               && NodeUtil.isGet(first)) {\n             if (maybeExternMethod(first)) {\n               return DecompositionType.UNDECOMPOSABLE;\n    * @return Whether the assignment is safe from side-effects.\n    */\n   private boolean isSafeAssign(Node n, boolean seenSideEffects) {\n-    if (n.getType() == Token.ASSIGN) {\n+    if (n.isAssign()) {\n       Node lhs = n.getFirstChild();\n       switch (lhs.getType()) {\n         case Token.NAME:\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n           return;\n         }\n \n-        if (parent.getType() == Token.ASSIGN || parent.getType() == Token.VAR) {\n+        if (parent.isAssign() || parent.isVar()) {\n           definitionMap.put(n.getQualifiedName(), parent);\n         }\n \n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n \n       switch (n.getType()) {\n         case Token.FUNCTION:\n-          if (parent.getType() == Token.SCRIPT) {\n+          if (parent.isScript()) {\n             export = NodeUtil.getFunctionName(n);\n             context = new GenerateNodeContext(n, parent, n);\n           }\n           break;\n         case Token.ASSIGN:\n           Node grandparent = parent.getParent();\n-          if (grandparent != null && grandparent.getType() == Token.SCRIPT &&\n-              parent.getType() == Token.EXPR_RESULT &&\n+          if (grandparent != null && grandparent.isScript() &&\n+              parent.isExprResult() &&\n               n.getLastChild().getType() != Token.ASSIGN) {\n             export = n.getFirstChild().getQualifiedName();\n             context = new GenerateNodeContext(n, grandparent, parent);\n           }\n           break;\n         case Token.VAR:\n-          if (parent.getType() == Token.SCRIPT) {\n+          if (parent.isScript()) {\n             if (n.getFirstChild().hasChildren() &&\n                 n.getFirstChild().getFirstChild().getType() != Token.ASSIGN) {\n               export = n.getFirstChild().getString();\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n \n             // Make sure that the name node is purely a read.\n             if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n-                || parent.isVar() || parent.getType() == Token.INC ||\n-                parent.getType() == Token.DEC || parent.getType() == Token.LP ||\n-                parent.getType() == Token.CATCH) {\n+                || parent.isVar() || parent.isInc() ||\n+                parent.isDec() || parent.isLP() ||\n+                parent.isCatch()) {\n               return;\n             }\n \n         rhs.detachFromParent();\n         // Oh yes! I have grandparent to remove this.\n         Preconditions.checkState(NodeUtil.isExpressionNode(defParent));\n-        while (defParent.getParent().getType() == Token.LABEL) {\n+        while (defParent.getParent().isLabel()) {\n           defParent = defParent.getParent();\n         }\n         defParent.detachFromParent();\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n \n   static Node inject(AbstractCompiler compiler, Node node, Node parent,\n       Map<String, Node> replacements, boolean replaceThis) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n         // This should not be replacing declared names.\n         parent.replaceChild(node, replacement);\n         return replacement;\n       }\n-    } else if (replaceThis && node.getType() == Token.THIS) {\n+    } else if (replaceThis && node.isThis()) {\n       Node replacementTemplate = replacements.get(THIS_MARKER);\n       Preconditions.checkNotNull(replacementTemplate);\n       if (replacementTemplate.getType() != Token.THIS) {\n \n         return replacement;\n       }\n-    } else if (node.getType() == Token.FUNCTION) {\n+    } else if (node.isFunction()) {\n       // Once we enter another scope the \"this\" value changes, don't try\n       // to replace it within an inner scope.\n       replaceThis = false;\n       Node n, Node parent, Set<String> names, Set<String> unsafe,\n       boolean inInnerFunction) {\n     Preconditions.checkArgument(unsafe != null);\n-    if (n.getType() == Token.NAME) {\n+    if (n.isName()) {\n       if (names.contains(n.getString())) {\n         if (inInnerFunction || canNameValueChange(n, parent)) {\n           unsafe.add(n.getString());\n         }\n       }\n-    } else if (n.getType() == Token.FUNCTION) {\n+    } else if (n.isFunction()) {\n       // A function parameter can not be replaced with a direct inlined value\n       // if it is referred to by an inner function. The inner function\n       // can out live the call we are replacing, so inner function must\n       return;\n     }\n \n-    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n+    Preconditions.checkArgument(fnNode.isFunction());\n     Node block = fnNode.getLastChild();\n \n     Set<String> parameters = argMap.keySet();\n       // that are seen.\n       if (inLoop() || sideEffectSeen) {\n         // Record references to parameters.\n-        if (n.getType() == Token.NAME) {\n+        if (n.isName()) {\n           String name = n.getString();\n           if (parameters.contains(name)) {\n             parametersReferenced.add(name);\n           }\n-        } else if (n.getType() == Token.THIS) {\n+        } else if (n.isThis()) {\n           parametersReferenced.add(THIS_MARKER);\n         }\n       }\n    * Gather any names declared in the local scope.\n    */\n   private static void gatherLocalNames(Node n, Set<String> names) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (NodeUtil.isFunctionDeclaration(n)) {\n         names.add(n.getFirstChild().getString());\n       }\n       // Don't traverse into inner function scopes;\n       return;\n-    } else if (n.getType() == Token.NAME) {\n+    } else if (n.isName()) {\n       switch (n.getParent().getType()) {\n         case Token.VAR:\n         case Token.CATCH:\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     Predicate<Node> p = new Predicate<Node>(){\n       @Override\n       public boolean apply(Node n) {\n-        if (n.getType() == Token.NAME) {\n+        if (n.isName()) {\n           return n.getString().equals(\"eval\")\n             || (!fnName.isEmpty()\n                 && n.getString().equals(fnName))\n       newExpression = NodeUtil.newUndefinedNode(srcLocation);\n     } else {\n       Node returnNode = block.getFirstChild();\n-      Preconditions.checkArgument(returnNode.getType() == Token.RETURN);\n+      Preconditions.checkArgument(returnNode.isReturn());\n \n       // Clone the return node first.\n       Node safeReturnNode = returnNode.cloneTree();\n       return CallSiteType.SIMPLE_CALL;\n     } else if (NodeUtil.isExprAssign(grandParent)\n         && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)\n-        && parent.getFirstChild().getType() == Token.NAME\n+        && parent.getFirstChild().isName()\n         && !NodeUtil.isConstantName(parent.getFirstChild())) {\n       // This is a simple assignment.  Example: \"x = foo();\"\n       return CallSiteType.SIMPLE_ASSIGNMENT;\n-    } else if (parent.getType() == Token.NAME\n+    } else if (parent.isName()\n         && !NodeUtil.isConstantName(parent)\n-        && grandParent.getType() == Token.VAR\n+        && grandParent.isVar()\n         && grandParent.hasOneChild()) {\n       // This is a var declaration.  Example: \"var x = foo();\"\n       // TODO(johnlenz): Should we be checking for constants on the\n       return true;\n     } else if (block.hasOneChild()) {\n       // Only inline functions that return something.\n-      if (block.getFirstChild().getType() == Token.RETURN\n+      if (block.getFirstChild().isReturn()\n           && block.getFirstChild().getFirstChild() != null) {\n         return true;\n       }\n       Predicate<Node> match = new Predicate<Node>(){\n         @Override\n         public boolean apply(Node n) {\n-          if (n.getType() == Token.NAME) {\n+          if (n.isName()) {\n             return n.getString().equals(\"eval\");\n           }\n-          if (!assumeMinimumCapture && n.getType() == Token.FUNCTION) {\n+          if (!assumeMinimumCapture && n.isFunction()) {\n             return n != fnNode;\n           }\n           return false;\n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.Serializable;\n import java.util.*;\n \n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.FUNCTION) {\n+      if (n.isFunction()) {\n         Node functionNameNode = n.getFirstChild();\n         String functionName = functionNameNode.getString();\n \n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n       }\n \n       Node statement = body.getFirstChild();\n-      if (statement.getType() == Token.RETURN) {\n+      if (statement.isReturn()) {\n         return statement.getFirstChild();\n       }\n       return null;\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n    * @param n The node to inspect\n    */\n   private void rewriteFunctionDeclarations(Node n) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (NodeUtil.isFunctionDeclaration(n)) {\n         // Rewrite: function f() {} ==> var f = function() {}\n         Node fnNameNode = n.getFirstChild();\n    *   a = (void) 0;\n    */\n   private static void addDummyAssignment(Node node, String resultName) {\n-    Preconditions.checkArgument(node.getType() == Token.BLOCK);\n+    Preconditions.checkArgument(node.isBlock());\n \n     // A result is needed create a dummy value.\n     Node srcLocation = node;\n   private static void convertLastReturnToStatement(\n       Node block, String resultName) {\n     Node ret = block.getLastChild();\n-    Preconditions.checkArgument(ret.getType() == Token.RETURN);\n+    Preconditions.checkArgument(ret.isReturn());\n     Node resultNode = getReplacementReturnStatement(ret, resultName);\n \n     if (resultNode == null) {\n   private static boolean hasReturnAtExit(Node block) {\n     // Only inline functions that return something (empty returns\n     // will be handled by ConstFolding+EmptyFunctionRemoval)\n-    return (block.getLastChild().getType() == Token.RETURN);\n+    return (block.getLastChild().isReturn());\n   }\n \n   /**\n   private static Node replaceReturnWithBreak(Node current, Node parent,\n       String resultName, String labelName) {\n \n-    if (current.getType() == Token.FUNCTION\n-        || current.getType() == Token.EXPR_RESULT) {\n+    if (current.isFunction()\n+        || current.isExprResult()) {\n       // Don't recurse into functions definitions, and expressions can't\n       // contain RETURN nodes.\n       return current;\n     }\n \n-    if (current.getType() == Token.RETURN) {\n+    if (current.isReturn()) {\n       Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n \n       Node resultNode = getReplacementReturnStatement(current, resultName);\n--- a/src/com/google/javascript/jscomp/GatherRawExports.java\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Set;\n \n /**\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     Node sibling = n.getNext();\n     if (sibling != null\n-        && sibling.getType() == Token.STRING\n+        && sibling.isString()\n         && NodeUtil.isGet(parent)) {\n       // TODO(johnlenz): Should we warn if we see a property name that\n       // hasn't been exported?\n   }\n \n   private boolean isGlobalThisObject(NodeTraversal t, Node n) {\n-    if (n.getType() == Token.THIS) {\n+    if (n.isThis()) {\n       return t.inGlobalScope();\n-    } else if (n.getType() == Token.NAME) {\n+    } else if (n.isName()) {\n       String varName = n.getString();\n       if (varName.equals(GLOBAL_THIS_NAME)) {\n         return true;\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n     @Override\n     public void keepSimplifiedShortCircuitExpression(Node original) {\n       Preconditions.checkArgument(\n-          (original.getType() == Token.AND) || (original.getType() == Token.OR),\n+          (original.isAnd()) || (original.isOr()),\n           \"Expected: AND or OR, Got: %s\", Token.name(original.getType()));\n       Node left = original.getFirstChild();\n       Node right = left.getNext();\n     public void keepSimplifiedHookExpression(Node hook,\n                                              boolean thenHasSideEffects,\n                                              boolean elseHasSideEffects) {\n-      Preconditions.checkArgument(hook.getType() == Token.HOOK,\n+      Preconditions.checkArgument(hook.isHook(),\n           \"Expected: HOOK, Got: %s\", Token.name(hook.getType()));\n       Node condition = hook.getFirstChild();\n       Node thenBranch = condition.getNext();\n     }\n \n     // Do not recurse into nested functions.\n-    if (node.getType() == Token.FUNCTION) {\n+    if (node.isFunction()) {\n       return false;\n     }\n \n     // simplify and maybe keep hook expression.\n-    if (node.getType() == Token.HOOK) {\n+    if (node.isHook()) {\n       return processHook(node);\n     }\n \n     // simplify and maybe keep AND/OR expression.\n-    if ((node.getType() == Token.AND) || (node.getType() == Token.OR)) {\n+    if ((node.isAnd()) || (node.isOr())) {\n       return processShortCircuitExpression(node);\n     }\n \n \n       // Node type suggests that the expression has side effects.\n \n-      if (node.getType() == Token.CALL) {\n+      if (node.isCall()) {\n         return processFunctionCall(node);\n-      } else if (node.getType() == Token.NEW) {\n+      } else if (node.isNew()) {\n         return processConstructorCall(node);\n       } else {\n         accumulator.keepSubTree(node);\n    */\n   boolean processShortCircuitExpression(Node node) {\n     Preconditions.checkArgument(\n-        (node.getType() == Token.AND) || (node.getType() == Token.OR),\n+        (node.isAnd()) || (node.isOr()),\n         \"Expected: AND or OR, Got: %s\", Token.name(node.getType()));\n \n     // keep whole expression if rhs of the branching expression\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processHook(Node node) {\n-    Preconditions.checkArgument(node.getType() == Token.HOOK,\n+    Preconditions.checkArgument(node.isHook(),\n         \"Expected: HOOK, Got: %s\", Token.name(node.getType()));\n \n     Node condition = node.getFirstChild();\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processFunctionCall(Node node) {\n-    Preconditions.checkArgument(node.getType() == Token.CALL,\n+    Preconditions.checkArgument(node.isCall(),\n         \"Expected: CALL, Got: %s\", Token.name(node.getType()));\n \n     // Calls to functions that are known to be \"pure\" have no side\n    * @return true to continue traversal, false otherwise\n    */\n   boolean processConstructorCall(Node node) {\n-    Preconditions.checkArgument(node.getType() == Token.NEW,\n+    Preconditions.checkArgument(node.isNew(),\n         \"Expected: NEW, Got: %s\", Token.name(node.getType()));\n \n     // Calls to constructors that are known to be \"pure\" have no\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n       String grandparent = null;\n \n       Node node = context.getNode().getFirstChild();\n-      if (node.getType() == Token.GETPROP) {\n+      if (node.isGetProp()) {\n         parent = node.getFirstChild().getQualifiedName();\n-        if (node.getFirstChild().getType() == Token.GETPROP &&\n+        if (node.getFirstChild().isGetProp() &&\n             getPropertyName(node.getFirstChild()).equals(PROTOTYPE_PROPERTY)) {\n           grandparent = node.getFirstChild().getFirstChild().getQualifiedName();\n         }\n    * @return property name.\n    */\n   private String getPropertyName(Node node) {\n-    Preconditions.checkArgument(node.getType() == Token.GETPROP);\n+    Preconditions.checkArgument(node.isGetProp());\n     return node.getLastChild().getString();\n   }\n }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n \n       Node current;\n       for (current = n;\n-           current.getType() == Token.GETPROP;\n+           current.isGetProp();\n            current = current.getFirstChild()) {\n         if (newNodes.contains(current)) {\n           return true;\n         }\n       }\n \n-      return current.getType() == Token.NAME && newNodes.contains(current);\n+      return current.isName() && newNodes.contains(current);\n     }\n   }\n \n         case Token.STRING:\n           // This may be a key in an object literal declaration.\n           name = null;\n-          if (parent != null && parent.getType() == Token.OBJECTLIT) {\n+          if (parent != null && parent.isObjectLit()) {\n             name = getNameForObjLitKey(n);\n           }\n           if (name == null) return;\n      */\n     String getNameForObjLitKey(Node n) {\n       Node parent = n.getParent();\n-      Preconditions.checkState(parent.getType() == Token.OBJECTLIT);\n+      Preconditions.checkState(parent.isObjectLit());\n \n       Node gramps = parent.getParent();\n       if (gramps == null) {\n           //     OBJLIT (parent)\n           //       STRING (n)\n           if (greatGramps != null &&\n-              greatGramps.getType() == Token.OBJECTLIT) {\n+              greatGramps.isObjectLit()) {\n             name = getNameForObjLitKey(gramps);\n           } else {\n             return null;\n      *     used\n      */\n     boolean isNestedAssign(Node parent) {\n-      return parent.getType() == Token.ASSIGN &&\n+      return parent.isAssign() &&\n              !NodeUtil.isExpressionNode(parent.getParent());\n     }\n \n         Ref ref = refs.get(0);\n         JSDocInfo info = ref.node.getJSDocInfo();\n         if (ref.node.getParent() != null &&\n-            ref.node.getParent().getType() == Token.EXPR_RESULT) {\n+            ref.node.getParent().isExprResult()) {\n           return true;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n     Iterator<Var> scopeVarIter = t.getScope().getVars();\n     while (scopeVarIter.hasNext()) {\n       Node parentNode = scopeVarIter.next().getParentNode();\n-      if (parentNode.getType() == Token.VAR) {\n+      if (parentNode.isVar()) {\n         varNodes.add(parentNode);\n       }\n     }\n       initializedName.removeChild(initializedVal);\n       Node assignmentNode = new Node(Token.ASSIGN, initializedName);\n       assignmentNode.addChildAfter(initializedVal, initializedName);\n-      if (groupVarParent.getType() == Token.FOR) {\n+      if (groupVarParent.isFor()) {\n         // Handle For and For-In Loops specially. For these, we do not need\n         // to construct an EXPR_RESULT node.\n         groupVarParent.replaceChild(groupVar, assignmentNode);\n     } else {\n       // There is no initialized var. But we need to handle FOR and\n       // FOR-IN loops specially\n-      if (groupVarParent.getType() == Token.FOR) {\n+      if (groupVarParent.isFor()) {\n         if (NodeUtil.isForIn(groupVarParent)) {\n           // In For-In loop, we replace the VAR node with a NAME node\n           Node nameNodeClone = groupVar.getFirstChild().cloneNode();\n--- a/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n+++ b/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       // Look for a for..in loop.\n-      if (n.getType() == Token.FOR && n.getChildCount() == 3) {\n+      if (n.isFor() && n.getChildCount() == 3) {\n         Node body = n.getLastChild();\n         n.removeChild(body);\n         Node key = n.getFirstChild();\n         Node ifBody;\n \n         // Construct the body of the if statement.\n-        if (key.getType() == Token.VAR) {\n+        if (key.isVar()) {\n           // for (var key in x) { body; }\n           // =>\n           // for (var tmp in x) {\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n   @Override\n   public void hotSwapScript(Node root, Node originalRoot) {\n     Preconditions.checkNotNull(root);\n-    Preconditions.checkState(root.getType() == Token.SCRIPT);\n+    Preconditions.checkState(root.isScript());\n     inExterns = false;\n     NodeTraversal.traverse(compiler, root, this);\n   }\n         // Only allow JSDoc on VARs, function declarations, and assigns.\n         if (parent.getType() != Token.VAR &&\n             !NodeUtil.isFunctionDeclaration(parent) &&\n-            !(parent.getType() == Token.ASSIGN &&\n+            !(parent.isAssign() &&\n               n == parent.getFirstChild())) {\n           return;\n         }\n         // /** ... */ var x = function() { ... }\n         docInfo = n.getJSDocInfo();\n         if (docInfo == null &&\n-            !(parent.getType() == Token.VAR &&\n+            !(parent.isVar() &&\n                 !parent.hasOneChild())) {\n           docInfo = parent.getJSDocInfo();\n         }\n \n         // Try to find the type of the NAME.\n         JSType varType = n.getJSType();\n-        if (varType == null && parent.getType() == Token.FUNCTION) {\n+        if (varType == null && parent.isFunction()) {\n           varType = parent.getJSType();\n         }\n \n         // /** @deprecated */\n         // obj.prop;\n         if (NodeUtil.isExpressionNode(parent) ||\n-            (parent.getType() == Token.ASSIGN &&\n+            (parent.isAssign() &&\n              parent.getFirstChild() == n)) {\n           docInfo = n.getJSDocInfo();\n           if (docInfo == null) {\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n         case Token.VAR:\n           Preconditions.checkState(n.hasOneChild());\n           Node nameNode = n.getFirstChild();\n-          if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n-              && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n+          if (nameNode.isName() && nameNode.hasChildren()\n+              && nameNode.getFirstChild().isFunction()) {\n             maybeAddFunction(new FunctionVar(n), t.getModule());\n           }\n           break;\n         // function Foo(x) { return ... }\n         case Token.FUNCTION:\n           Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n-              || parent.getType() == Token.LABEL);\n+              || parent.isLabel());\n           if (!NodeUtil.isFunctionExpression(n)) {\n             Function fn = new NamedFunction(n);\n             maybeAddFunction(fn, t.getModule());\n         //   (function(){})();\n         case Token.CALL:\n           Node fnNode = null;\n-          if (n.getFirstChild().getType() == Token.FUNCTION) {\n+          if (n.getFirstChild().isFunction()) {\n             fnNode = n.getFirstChild();\n           } else if (NodeUtil.isFunctionObjectCall(n)) {\n             Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n-            if (fnIdentifingNode.getType() == Token.FUNCTION) {\n+            if (fnIdentifingNode.isFunction()) {\n               fnNode = fnIdentifingNode;\n             }\n           }\n           String name = null;\n           // NOTE: The normalization pass insures that local names do not\n           // collide with global names.\n-          if (child.getType() == Token.NAME) {\n+          if (child.isName()) {\n             name = child.getString();\n-          } else if (child.getType() == Token.FUNCTION) {\n+          } else if (child.isFunction()) {\n             name = anonFunctionMap.get(child);\n           } else if (NodeUtil.isFunctionObjectCall(n)) {\n             Preconditions.checkState(NodeUtil.isGet(child));\n             Node fnIdentifingNode = child.getFirstChild();\n-            if (fnIdentifingNode.getType() == Token.NAME) {\n+            if (fnIdentifingNode.isName()) {\n               name = fnIdentifingNode.getString();\n-            } else if (fnIdentifingNode.getType() == Token.FUNCTION) {\n+            } else if (fnIdentifingNode.isFunction()) {\n               name = anonFunctionMap.get(fnIdentifingNode);\n             }\n           }\n    */\n   static boolean isCandidateUsage(Node name) {\n     Node parent = name.getParent();\n-    Preconditions.checkState(name.getType() == Token.NAME);\n-    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {\n+    Preconditions.checkState(name.isName());\n+    if (parent.isVar() || parent.isFunction()) {\n       // This is a declaration.  Duplicate declarations are handle during\n       // function candidate gathering.\n       return true;\n     }\n \n-    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {\n+    if (parent.isCall() && parent.getFirstChild() == name) {\n       // This is a normal reference to the function.\n       return true;\n     }\n     //     ...\n     if (NodeUtil.isGet(parent)\n          && name == parent.getFirstChild()\n-         && name.getNext().getType() == Token.STRING\n+         && name.getNext().isString()\n          && name.getNext().getString().equals(\"call\")) {\n       Node gramps = name.getAncestor(2);\n-      if (gramps.getType() == Token.CALL\n+      if (gramps.isCall()\n           && gramps.getFirstChild() == parent) {\n         // Yep, a \".call\".\n         return true;\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       super.visit(t, n, parent);\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         checkNameUsage(t, n, parent);\n       }\n     }\n      * Find functions that can be inlined.\n      */\n     private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n-      Preconditions.checkState(n.getType() == Token.NAME);\n+      Preconditions.checkState(n.isName());\n \n       if (isCandidateUsage(n)) {\n         return;\n       // JSCompiler_ObjectPropertyString are not aliases of a value, but\n       // a reference to the name itself, as such the value of the name is\n       // unknown and can not be inlined.\n-      if (parent.getType() == Token.NEW) {\n+      if (parent.isNew()) {\n         Node target = parent.getFirstChild();\n-        if (target.getType() == Token.NAME && target.getString().equals(\n+        if (target.isName() && target.getString().equals(\n             ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) {\n           // This method is going to be replaced so don't inline it anywhere.\n           fs.setInline(false);\n       }\n \n       // If the name is being assigned to it can not be inlined.\n-      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) {\n+      if (parent.isAssign() && parent.getFirstChild() == n) {\n         // e.g. bar = something; <== we can't inline \"bar\"\n         // so mark the function as uninlinable.\n         // TODO(johnlenz): Should we just remove it from fns here?\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n       if (isCandidateUsage(node)) {\n         changed.add(node.getString());\n       }\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n       NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {\n         @Override\n         public void visit(Node node) {\n-          if (node.getType() == Token.NAME) {\n+          if (node.isName()) {\n             staleVars.add(scope.getVar(node.getString()));\n           }\n         }\n         // Ignore indirect references, like x.y (except x.y(), since\n         // the function referenced by y might reference 'this').\n         //\n-        if (parent.getType() == Token.GETPROP) {\n+        if (parent.isGetProp()) {\n           Preconditions.checkState(parent.getFirstChild() == name);\n           // A call target maybe using the object as a 'this' value.\n-          if (gramps.getType() == Token.CALL\n+          if (gramps.isCall()\n               && gramps.getFirstChild() == parent) {\n             return false;\n           }\n         // Also, ES5 getters/setters aren't handled by this pass.\n         for (Node child = val.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          if (child.getType() == Token.GET ||\n-              child.getType() == Token.SET) {\n+          if (child.isGet() ||\n+              child.isSet()) {\n             // ES5 get/set not supported.\n             return false;\n           }\n \n     private boolean isVarOrAssignExprLhs(Node n) {\n       Node parent = n.getParent();\n-      return parent.getType() == Token.VAR ||\n-          (parent.getType() == Token.ASSIGN\n+      return parent.isVar() ||\n+          (parent.isAssign()\n               && parent.getFirstChild() == n\n-              && parent.getParent().getType() == Token.EXPR_RESULT);\n+              && parent.getParent().isExprResult());\n     }\n \n     /**\n         if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n           Node val = ref.getAssignedValue();\n           if (val != null) {\n-            Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n+            Preconditions.checkState(val.isObjectLit());\n             for (Node child = val.getFirstChild(); child != null;\n                  child = child.getNext()) {\n               String varname = child.getString();\n               varmap.put(varname, var);\n             }\n           }\n-        } else if (ref.getParent().getType() == Token.VAR) {\n+        } else if (ref.getParent().isVar()) {\n           // This is the var. There is no value.\n         } else {\n           Node getprop = ref.getParent();\n-          Preconditions.checkState(getprop.getType() == Token.GETPROP);\n+          Preconditions.checkState(getprop.isGetProp());\n \n           // The key being looked up in the original map.\n           String varname = getprop.getLastChild().getString();\n      */\n     private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n       Node object = init.getAssignedValue();\n-      Preconditions.checkState(object.getType() == Token.OBJECTLIT);\n+      Preconditions.checkState(object.isObjectLit());\n       for (Node key = object.getFirstChild(); key != null;\n            key = key.getNext()) {\n         initvals.put(key.getString(), key.removeFirstChild());\n       List<Node> nodes = Lists.newArrayList();\n       Node val = ref.getAssignedValue();\n       blacklistVarReferencesInTree(val, v.scope);\n-      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n+      Preconditions.checkState(val.isObjectLit());\n       Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n       for (Node key = val.getFirstChild(); key != null;\n            key = key.getNext()) {\n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);\n \n-      if (replace.getType() == Token.VAR) {\n+      if (replace.isVar()) {\n         replace.getParent().replaceChild(\n             replace, NodeUtil.newExpr(replacement));\n       } else {\n       // VAR then it should be directly replaced.\n       Node vnode;\n       boolean defined = referenceInfo.isWellDefined() &&\n-          init.getParent().getType() == Token.VAR;\n+          init.getParent().isVar();\n       if (defined) {\n         vnode = init.getParent();\n         fillInitialValues(init, initvals);\n           // Assignments have to be handled specially, since they\n           // expand out into multiple assignments.\n           replaceAssignmentExpression(v, ref, varmap);\n-        } else if (ref.getParent().getType() == Token.VAR) {\n+        } else if (ref.getParent().isVar()) {\n           // The old variable declaration. It didn't have a\n           // value. Remove it entirely as it should now be unused.\n           ref.getGrandparent().removeChild(ref.getParent());\n         } else {\n           // Make sure that the reference is a GETPROP as we expect it to be.\n           Node getprop = ref.getParent();\n-          Preconditions.checkState(getprop.getType() == Token.GETPROP);\n+          Preconditions.checkState(getprop.isGetProp());\n \n           // The key being looked up in the original map.\n           String var = getprop.getChildAtIndex(1).getString();\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n    */\n   private static void replaceThis(Node expectedGetprop, Node replacement) {\n     Node leftChild = expectedGetprop.getFirstChild();\n-    if (leftChild.getType() == Token.THIS) {\n+    if (leftChild.isThis()) {\n       expectedGetprop.replaceChild(leftChild, replacement);\n     } else {\n       replaceThis(leftChild, replacement);\n     }\n \n     Node expectedBlock = fn.getLastChild();\n-    return  expectedBlock.getType() == Token.BLOCK ?\n+    return  expectedBlock.isBlock() ?\n         expectedBlock : null;\n   }\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n               referenceInfo.isAssignedOnceInLifetime()) {\n             Reference init = referenceInfo.getInitializingReference();\n             Node value = init.getAssignedValue();\n-            if (value != null && value.getType() == Token.NAME) {\n+            if (value != null && value.isName()) {\n               aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n             }\n           }\n \n     private boolean isLValue(Node n) {\n       Node parent = n.getParent();\n-      return (parent.getType() == Token.INC\n-          || parent.getType() == Token.DEC\n+      return (parent.isInc()\n+          || parent.isDec()\n           || (NodeUtil.isAssignmentOp(parent)\n           && parent.getFirstChild() == n));\n     }\n         blacklistVarReferencesInTree(c, scope);\n       }\n \n-      if (root.getType() == Token.NAME) {\n+      if (root.isName()) {\n         staleVars.add(scope.getVar(root.getString()));\n       }\n     }\n       inlineValue(v, reference, value.detachFromParent());\n       if (declaration != init) {\n         Node expressRoot = init.getGrandparent();\n-        Preconditions.checkState(expressRoot.getType() == Token.EXPR_RESULT);\n+        Preconditions.checkState(expressRoot.isExprResult());\n         NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n       }\n \n \n       // Remove var node if empty\n       if (!varNode.hasChildren()) {\n-        Preconditions.checkState(varNode.getType() == Token.VAR);\n+        Preconditions.checkState(varNode.isVar());\n         NodeUtil.removeChild(grandparent, varNode);\n       }\n \n       // is ok.\n       Node value = initialization.getAssignedValue();\n       Preconditions.checkState(value != null);\n-      if (value.getType() == Token.GETPROP\n-          && reference.getParent().getType() == Token.CALL\n+      if (value.isGetProp()\n+          && reference.getParent().isCall()\n           && reference.getParent().getFirstChild() == reference.getNode()) {\n         return false;\n       }\n \n       // Bug 2388531: Don't inline subclass definitions into class defining\n       // calls as this confused class removing logic.\n-      if (value.getType() == Token.FUNCTION) {\n+      if (value.isFunction()) {\n         Node callNode = reference.getParent();\n-        if (reference.getParent().getType() == Token.CALL) {\n+        if (reference.getParent().isCall()) {\n           SubclassRelationship relationship =\n               compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n           if (relationship != null) {\n       // Function expressions and other mutable objects can move within\n       // the same basic block.\n       return NodeUtil.isLiteralValue(value, true)\n-          || value.getType() == Token.FUNCTION;\n+          || value.isFunction();\n     }\n \n     /**\n       // Check if declaration can be inlined without passing\n       // any side-effect causing nodes.\n       Iterator<Node> it;\n-      if (initialization.getParent().getType() == Token.VAR) {\n+      if (initialization.getParent().isVar()) {\n         it = NodeIterators.LocalVarMotion.forVar(\n             initialization.getNode(),     // NAME\n             initialization.getParent(),       // VAR\n             initialization.getGrandparent()); // VAR container\n-      } else if (initialization.getParent().getType() == Token.ASSIGN) {\n+      } else if (initialization.getParent().isAssign()) {\n         Preconditions.checkState(\n-            initialization.getGrandparent().getType() == Token.EXPR_RESULT);\n+            initialization.getGrandparent().isExprResult());\n         it = NodeIterators.LocalVarMotion.forAssign(\n             initialization.getNode(),     // NAME\n             initialization.getParent(),       // ASSIGN\n      * @return true if the reference is a normal VAR or FUNCTION declaration.\n      */\n     private boolean isValidDeclaration(Reference declaration) {\n-      return (declaration.getParent().getType() == Token.VAR\n+      return (declaration.getParent().isVar()\n           && declaration.getGrandparent().getType() != Token.FOR)\n           || NodeUtil.isFunctionDeclaration(declaration.getParent());\n     }\n       } else {\n         Node parent = initialization.getParent();\n         Preconditions.checkState(\n-            parent.getType() == Token.ASSIGN\n+            parent.isAssign()\n             && parent.getFirstChild() == initialization.getNode());\n         return true;\n       }\n             (value.getType() != Token.STRING ||\n                 isStringWorthInlining(v, refInfo.references));\n         boolean isInlinableThisAlias =\n-            value.getType() == Token.THIS &&\n+            value.isThis() &&\n             !refInfo.isEscaped();\n         if (!isImmutableValueWorthInlining && !isInlinableThisAlias) {\n           return false;\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n     switch (node.getType()) {\n       case Token.NAME:\n         // var MSG_HELLO = 'Message'\n-        if ((parent != null) && (parent.getType() == Token.VAR)) {\n+        if ((parent != null) && (parent.isVar())) {\n           messageKey = node.getString();\n           isVar = true;\n         } else {\n \n     // Is this a message name?\n     boolean isNewStyleMessage =\n-        msgNode != null && msgNode.getType() == Token.CALL;\n+        msgNode != null && msgNode.isCall();\n     if (!isMessageName(messageKey, isNewStyleMessage)) {\n       return;\n     }\n    */\n   private boolean maybeInitMetaDataFromHelpVar(Builder builder,\n       @Nullable Node sibling) throws MalformedException {\n-    if ((sibling != null) && (sibling.getType() == Token.VAR)) {\n+    if ((sibling != null) && (sibling.isVar())) {\n       Node nameNode = sibling.getFirstChild();\n       String name = nameNode.getString();\n       if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n         case Token.LP:\n           // Parse the placeholder names from the function argument list.\n           for (Node argumentNode : fnChild.children()) {\n-            if (argumentNode.getType() == Token.NAME) {\n+            if (argumentNode.isName()) {\n               String phName = argumentNode.getString();\n               if (phNames.contains(phName)) {\n                 throw new MalformedException(\"Duplicate placeholder name: \"\n--- a/src/com/google/javascript/jscomp/LineNumberCheck.java\n+++ b/src/com/google/javascript/jscomp/LineNumberCheck.java\n \n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * A simple pass to ensure that all AST nodes have line numbers,\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     // Each JavaScript file is rooted in a script node, so we'll only\n     // have line number information inside the script node.\n-    if (n.getType() == Token.SCRIPT) {\n+    if (n.isScript()) {\n       requiresLineNumbers = true;\n     }\n     return true;\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.SCRIPT) {\n+    if (n.isScript()) {\n       requiresLineNumbers = false;\n     } else if (requiresLineNumbers) {\n       if (n.getLineno() == -1) {\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n         List<Node> references = nameMap.get(name);\n         Preconditions.checkState(references != null);\n         for (Node n : references) {\n-          Preconditions.checkState(n.getType() == Token.NAME);\n+          Preconditions.checkState(n.isName());\n           n.setString(newName);\n         }\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n    * itself or the name of a function).\n    */\n   private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n-    if (node.getType() == Token.FUNCTION) {\n+    if (node.isFunction()) {\n       // The node we're looking at is a function, so we can add it directly\n       addSignature(name, node, t.getSourceName());\n     } else {\n           //          name methods\n           //          string setTimeout\n           //      function\n-          if (parent.getType() == Token.ASSIGN &&\n+          if (parent.isAssign() &&\n               parent.getFirstChild() == n &&\n-              n.getNext().getType() == Token.FUNCTION) {\n+              n.getNext().isFunction()) {\n             addSignature(name, n.getNext(), t.getSourceName());\n           } else {\n             getSignatureStore().removeSignature(name);\n           for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n             Node value = key.getFirstChild();\n             String name = key.getString();\n-            if (key.getType() == Token.STRING\n-                && value.getType() == Token.FUNCTION) {\n+            if (key.isString()\n+                && value.isFunction()) {\n               addSignature(name, value, t.getSourceName());\n             } else {\n               getSignatureStore().removeSignature(name);\n         case Token.GETELEM:\n           Node dest = n.getFirstChild().getNext();\n \n-          if (dest.getType() == Token.STRING) {\n+          if (dest.isString()) {\n             if (dest.getString().equals(\"prototype\")) {\n               processPrototypeParent(t, parent);\n             } else {\n               //          name Foo\n               //          string bar\n               //      function or name  <- n.getNext()\n-              if (parent.getType() == Token.ASSIGN &&\n+              if (parent.isAssign() &&\n                   parent.getFirstChild() == n) {\n                 addPossibleSignature(dest.getString(), n.getNext(), t);\n               }\n           Node dest = n.getFirstChild().getNext();\n           Node parent = n.getParent().getParent();\n \n-          if (dest.getType() == Token.STRING &&\n-              parent.getType() == Token.ASSIGN) {\n+          if (dest.isString() &&\n+              parent.isAssign()) {\n             Node assignee = parent.getFirstChild().getNext();\n \n             addPossibleSignature(dest.getString(), assignee, t);\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n     }\n \n     // Just an 'if'.\n-    if (n.getType() == Token.IF) {\n+    if (n.isIf()) {\n       Node ifBlock = n.getFirstChild().getNext();\n       tryMinimizeExits(ifBlock, exitType, labelName);\n       Node elseBlock = ifBlock.getNext();\n     }\n \n     // Just a 'try/catch/finally'.\n-    if (n.getType() == Token.TRY) {\n+    if (n.isTry()) {\n       Node tryBlock = n.getFirstChild();\n       tryMinimizeExits(tryBlock, exitType, labelName);\n       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n     }\n \n     // Just a 'label'.\n-    if (n.getType() == Token.LABEL) {\n+    if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n       tryMinimizeExits(labelBlock, exitType, labelName);\n     }\n     for (Node c : n.children()) {\n \n       // An 'if' block to process below.\n-      if (c.getType() == Token.IF) {\n+      if (c.isIf()) {\n         Node ifTree = c;\n         Node trueBlock, falseBlock;\n \n     Node exitNode = null;\n \n     // Pick an exit node candidate.\n-    if (srcBlock.getType() == Token.BLOCK) {\n+    if (srcBlock.isBlock()) {\n       if (!srcBlock.hasChildren()) {\n         return;\n       }\n       if (destBlock == null) {\n         // Only possible if this is the false block.\n         ifNode.addChildToBack(newDestBlock);\n-      } else if (destBlock.getType() == Token.EMPTY) {\n+      } else if (destBlock.isEmpty()) {\n         // Use the new block.\n         ifNode.replaceChild(destBlock, newDestBlock);\n-      } else if (destBlock.getType() == Token.BLOCK) {\n+      } else if (destBlock.isBlock()) {\n         // Reuse the existing block.\n         newDestBlock = destBlock;\n       } else {\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n         }\n \n         // DEC and INC actually defines the variable.\n-        if (n.getType() == Token.DEC || n.getType() == Token.INC) {\n+        if (n.isDec() || n.isInc()) {\n           Node target = n.getFirstChild();\n           if (target.isName()) {\n             addToDefIfLocal(target.getString(),\n   }\n \n   private boolean isParameter(Var v) {\n-    return v.getParentNode().getType() == Token.LP;\n+    return v.getParentNode().isLP();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n     PrototypeSetNode(JsName name, Node parent) {\n       super(name, parent.getFirstChild());\n \n-      Preconditions.checkState(parent.getType() == Token.ASSIGN);\n+      Preconditions.checkState(parent.isAssign());\n     }\n \n     @Override public void remove() {\n     ClassDefiningFunctionNode(JsName name, Node node, Node parent,\n         Node gramps) {\n       super(name, node, parent, gramps);\n-      Preconditions.checkState(node.getType() == Token.CALL);\n+      Preconditions.checkState(node.isCall());\n     }\n \n     @Override\n     public void remove() {\n-      Preconditions.checkState(node.getType() == Token.CALL);\n+      Preconditions.checkState(node.isCall());\n       if (NodeUtil.isExpressionNode(parent)) {\n         changeProxy.removeChild(gramps, parent);\n       } else {\n         return;\n       }\n \n-      if (n.getType() == Token.ASSIGN) {\n+      if (n.isAssign()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null) {\n-          if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent)) {\n+          if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n             // Patch for assignments that appear in the init,\n             // condition or iteration part of a FOR loop.  Without\n             // this change, all 3 of those parts try to claim the for\n       }\n \n       // Record assignments and call sites\n-      if (n.getType() == Token.ASSIGN) {\n+      if (n.isAssign()) {\n         Node nameNode = n.getFirstChild();\n \n         NameInformation ns = createNameInformation(t, nameNode, n);\n             recordSet(ns.name, nameNode);\n           }\n         }\n-      } else if (n.getType() == Token.CALL) {\n+      } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n \n       // Now, look at all parent names and record that their properties have\n       // been written to.\n-      if (node.getType() == Token.GETELEM) {\n+      if (node.isGetElem()) {\n         recordWriteOnProperties(name);\n       } else if (name.indexOf('.') != -1) {\n         recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));\n       new Predicate<Node>() {\n         @Override\n         public boolean apply(Node input) {\n-          if (input.getType() == Token.CALL) {\n+          if (input.isCall()) {\n             return false;\n           }\n           // TODO(johnlenz): handle NEW calls that record their 'this'\n     }\n \n     private void addSimplifiedExpression(Node n, Node parent) {\n-      if (parent.getType() == Token.VAR) {\n+      if (parent.isVar()) {\n         Node value = n.getFirstChild();\n         if (value != null) {\n           addSimplifiedChildren(value);\n         }\n-      } else if (n.getType() == Token.ASSIGN &&\n-          (parent.getType() == Token.EXPR_RESULT ||\n-           parent.getType() == Token.FOR ||\n-           parent.getType() == Token.RETURN)) {\n+      } else if (n.isAssign() &&\n+          (parent.isExprResult() ||\n+           parent.isFor() ||\n+           parent.isReturn())) {\n         for (Node child : n.children()) {\n           addSimplifiedChildren(child);\n         }\n-      } else if (n.getType() == Token.CALL &&\n-                 parent.getType() == Token.EXPR_RESULT) {\n+      } else if (n.isCall() &&\n+                 parent.isExprResult()) {\n         addSimplifiedChildren(n);\n       } else {\n         addAllChildren(n);\n       // arguments to function calls with side effects or are used in\n       // control structure predicates.  These names are always\n       // referenced when the enclosing function is called.\n-      if (n.getType() == Token.FOR) {\n+      if (n.isFor()) {\n         if (!NodeUtil.isForIn(n)) {\n           Node decl = n.getFirstChild();\n           Node pred = decl.getNext();\n         }\n       }\n \n-      if (parent.getType() == Token.VAR ||\n-          parent.getType() == Token.EXPR_RESULT ||\n-          parent.getType() == Token.RETURN ||\n-          parent.getType() == Token.THROW) {\n+      if (parent.isVar() ||\n+          parent.isExprResult() ||\n+          parent.isReturn() ||\n+          parent.isThrow()) {\n         addSimplifiedExpression(n, parent);\n       }\n \n-      if ((parent.getType() == Token.IF ||\n+      if ((parent.isIf() ||\n            parent.getType() == Token.WHILE ||\n            parent.getType() == Token.WITH ||\n-           parent.getType() == Token.SWITCH ||\n-           parent.getType() == Token.CASE) &&\n+           parent.isSwitch() ||\n+           parent.isCase()) &&\n           parent.getFirstChild() == n) {\n         addAllChildren(n);\n       }\n \n-      if (parent.getType() == Token.DO && parent.getLastChild() == n) {\n+      if (parent.isDo() && parent.getLastChild() == n) {\n         addAllChildren(n);\n       }\n \n     private boolean maybeHiddenAlias(String name, Node n) {\n       Node parent = n.getParent();\n       if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n-        Node rhs = (parent.getType() == Token.VAR)\n+        Node rhs = (parent.isVar())\n             ? n.getFirstChild() : parent.getLastChild();\n         return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n             rhs, NON_LOCAL_RESULT_PREDICATE));\n     private boolean maybeRecordAlias(\n         String name, Node parent,\n         NameInformation referring, String referringName) {\n-      if ((parent.getType() == Token.NAME ||\n-          parent.getType() == Token.ASSIGN) &&\n+      if ((parent.isName() ||\n+          parent.isAssign()) &&\n           referring != null &&\n           scopes.get(parent) == referring) {\n         recordAlias(referringName, name);\n     while (true) {\n       if (NodeUtil.isGet(rootNameNode)) {\n         Node prop = rootNameNode.getLastChild();\n-        if (rootNameNode.getType() == Token.GETPROP) {\n+        if (rootNameNode.isGetProp()) {\n           name = \".\" + prop.getString() + name;\n         } else {\n           // We consider the name to be \"a.b\" in a.b['c'] or a.b[x].d.\n         // Check if this is an object literal assigned to something.\n         Node objLit = rootNameNode.getParent();\n         Node objLitParent = objLit.getParent();\n-        if (objLitParent.getType() == Token.ASSIGN) {\n+        if (objLitParent.isAssign()) {\n           // This must be the right side of the assign.\n           rootNameNode = objLitParent.getFirstChild();\n-        } else if (objLitParent.getType() == Token.NAME) {\n+        } else if (objLitParent.isName()) {\n           // This must be a VAR initialization.\n           rootNameNode = objLitParent;\n-        } else if (objLitParent.getType() == Token.STRING) {\n+        } else if (objLitParent.isString()) {\n           // This must be a object literal key initialization.\n           rootNameNode = objLitParent;\n         } else {\n         // Check whether this is an assignment to a prototype property\n         // of an object defined in the global scope.\n         if (!bNameWasShortened &&\n-            n.getType() == Token.GETPROP &&\n-            parent.getType() == Token.ASSIGN &&\n+            n.isGetProp() &&\n+            parent.isAssign() &&\n             \"prototype\".equals(n.getLastChild().getString())) {\n           if (createNameInformation(t, n.getFirstChild(), n) != null) {\n             name = rootNameNode.getString() + name;\n     if (parent != null) {\n       // Account for functions defined in the form:\n       //   var a = cond ? function a() {} : function b() {};\n-      while (parent.getType() == Token.HOOK) {\n+      while (parent.isHook()) {\n         parent = parent.getParent();\n       }\n \n-      if (parent.getType() == Token.NAME) {\n+      if (parent.isName()) {\n         return scopes.get(parent);\n       }\n \n-      if (parent.getType() == Token.ASSIGN) {\n+      if (parent.isAssign()) {\n         return scopes.get(parent);\n       }\n     }\n       newReplacements.add(valueExpr);\n       changeProxy.replaceWith(\n           parent, n, collapseReplacements(newReplacements));\n-    } else if (n.getType() == Token.ASSIGN && parent.getType() != Token.FOR) {\n+    } else if (n.isAssign() && parent.getType() != Token.FOR) {\n       // assignment appears in a RHS expression.  we have already\n       // considered names in the assignment's RHS as being referenced;\n       // replace the assignment with its RHS.\n       case Token.VAR:\n         break;\n       case Token.ASSIGN:\n-        Preconditions.checkArgument(parent.getType() == Token.FOR,\n+        Preconditions.checkArgument(parent.isFor(),\n             \"Unsupported assignment in replaceWithRhs. parent: %s\", Token.name(parent.getType()));\n         break;\n       default:\n       replacements.addAll(getSideEffectNodes(rhs));\n     }\n \n-    if (parent.getType() == Token.FOR) {\n+    if (parent.isFor()) {\n       // tweak replacements array s.t. it is a single expression node.\n       if (replacements.isEmpty()) {\n         replacements.add(new Node(Token.EMPTY));\n   private Node collapseReplacements(List<Node> replacements) {\n     Node expr = null;\n     for (Node rep : replacements) {\n-      if (rep.getType() == Token.EXPR_RESULT) {\n+      if (rep.isExprResult()) {\n         rep = rep.getFirstChild();\n         rep.detachFromParent();\n       }\n--- a/src/com/google/javascript/jscomp/NodeIterators.java\n+++ b/src/com/google/javascript/jscomp/NodeIterators.java\n       Preconditions.checkArgument(ancestors.length > 0);\n \n       for (Node n : ancestors) {\n-        if (n.getType() == Token.FUNCTION) {\n+        if (n.isFunction()) {\n           break;\n         }\n \n         current = ancestors.peek();\n \n         // If this is a function node, skip it.\n-        if (current.getType() == Token.FUNCTION) {\n+        if (current.isFunction()) {\n           return next();\n         }\n       } else {\n         ancestors.push(current);\n \n         // If this is a function node, skip it.\n-        if (current.getType() == Token.FUNCTION) {\n+        if (current.isFunction()) {\n           return next();\n         }\n \n           ancestors.push(current);\n \n           // If this is a function node, skip it.\n-          if (current.getType() == Token.FUNCTION) {\n+          if (current.isFunction()) {\n             return next();\n           }\n         }\n      */\n     static LocalVarMotion forVar(\n         Node name, Node var, Node block) {\n-      Preconditions.checkArgument(var.getType() == Token.VAR);\n+      Preconditions.checkArgument(var.isVar());\n       Preconditions.checkArgument(NodeUtil.isStatement(var));\n       // The FunctionlessLocalScope must start at \"name\" as this may be used\n       // before the Normalize pass, and thus the VAR node may define multiple\n      */\n     static LocalVarMotion forAssign(\n         Node name, Node assign, Node expr, Node block) {\n-      Preconditions.checkArgument(assign.getType() == Token.ASSIGN);\n-      Preconditions.checkArgument(expr.getType() == Token.EXPR_RESULT);\n+      Preconditions.checkArgument(assign.isAssign());\n+      Preconditions.checkArgument(expr.isExprResult());\n       // The FunctionlessLocalScope must start at \"assign\", to skip the value\n       // assigned to \"name\" (which would be its sibling).\n       return new LocalVarMotion(\n      *     beginning with the deepest ancestor.\n      */\n     private LocalVarMotion(Node nameNode, FunctionlessLocalScope iterator) {\n-      Preconditions.checkArgument(nameNode.getType() == Token.NAME);\n+      Preconditions.checkArgument(nameNode.isName());\n       Node valueNode = NodeUtil.getAssignedValue(nameNode);\n       this.varName = nameNode.getString();\n       this.valueHasSideEffects = valueNode != null &&\n         // Don't advance past a refrence to the variable that we're trying\n         // to inline.\n         Node curNode = iterator.current();\n-        if (curNode.getType() == Token.NAME &&\n+        if (curNode.isName() &&\n             varName.equals(curNode.getString())) {\n           lookAhead = null;\n           return;\n           if (nextParent == null) {\n             blocked = true;\n           } else {\n-            boolean assignsName = (nextParent.getType() == Token.ASSIGN\n+            boolean assignsName = (nextParent.isAssign()\n                     && nextNode == nextParent.getFirstChild());\n-            boolean isVarDeclaration = (nextParent.getType() == Token.VAR);\n+            boolean isVarDeclaration = (nextParent.isVar());\n \n             if (!assignsName && !isVarDeclaration) {\n               blocked = true;\n       //   var b = 3;\n       //   alert(a);\n       if (NodeUtil.nodeTypeMayHaveSideEffects(nextNode) && type != Token.NAME\n-          || type == Token.NAME && nextParent.getType() == Token.CATCH) {\n+          || type == Token.NAME && nextParent.isCatch()) {\n         lookAhead = null;\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n    */\n   void traverseAtScope(Scope s) {\n     Node n = s.getRootNode();\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       // We need to do some extra magic to make sure that the scope doesn't\n       // get re-created when we dive into the function.\n       if (inputId == null) {\n    */\n   private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.getType() == Token.FUNCTION);\n+    Preconditions.checkState(n.isFunction());\n \n     final Node fnName = n.getFirstChild();\n \n \n     // Body\n     Preconditions.checkState(body.getNext() == null &&\n-            body.getType() == Token.BLOCK);\n+            body.isBlock());\n     traverseBranch(body, n);\n \n     popScope();\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       // Note: Constant properties annotations are not propagated.\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         if (n.getString().isEmpty()) {\n           return;\n         }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         String name = n.getString();\n         if (n.getString().isEmpty()) {\n           return;\n      */\n     private void annotateConstantsByConvention(Node n, Node parent) {\n       Preconditions.checkState(\n-          n.getType() == Token.NAME\n-          || n.getType() == Token.STRING\n-          || n.getType() == Token.GET\n-          || n.getType() == Token.SET);\n+          n.isName()\n+          || n.isString()\n+          || n.isGet()\n+          || n.isSet());\n \n       // There are only two cases where a string token\n       // may be a variable reference: The right side of a GETPROP\n       // or an OBJECTLIT key.\n       boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n       boolean isProperty = isObjLitKey ||\n-          (parent.getType() == Token.GETPROP &&\n+          (parent.isGetProp() &&\n            parent.getLastChild() == n);\n-      if (n.getType() == Token.NAME || isProperty) {\n+      if (n.isName() || isProperty) {\n         boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n         if (!isMarkedConstant &&\n             NodeUtil.isConstantByConvention(\n      *    var f = function () {};\n      */\n     private void normalizeFunctionDeclaration(Node n) {\n-      Preconditions.checkState(n.getType() == Token.FUNCTION);\n+      Preconditions.checkState(n.isFunction());\n       if (!NodeUtil.isFunctionExpression(n)\n           && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n         rewriteFunctionDeclaration(n);\n      */\n     private void doStatementNormalizations(\n         NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.LABEL) {\n+      if (n.isLabel()) {\n         normalizeLabels(n);\n       }\n \n       // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n       // are the only legal place for VARs and FOR statements.\n-      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n+      if (NodeUtil.isStatementBlock(n) || n.isLabel()) {\n         extractForInitializer(n, null, null);\n       }\n \n         splitVarDeclarations(n);\n       }\n \n-      if (n.getType() == Token.FUNCTION) {\n+      if (n.isFunction()) {\n         moveNamedFunctions(n.getLastChild());\n       }\n     }\n      * place as the named continues are not allowed for labeled blocks.\n      */\n     private void normalizeLabels(Node n) {\n-      Preconditions.checkArgument(n.getType() == Token.LABEL);\n+      Preconditions.checkArgument(n.isLabel());\n \n       Node last = n.getLastChild();\n       switch (last.getType()) {\n           case Token.FOR:\n             if (NodeUtil.isForIn(c)) {\n               Node first = c.getFirstChild();\n-              if (first.getType() == Token.VAR) {\n+              if (first.isVar()) {\n                 // Transform:\n                 //    for (var a = 1 in b) {}\n                 // to:\n               Node newStatement;\n               // Only VAR statements, and expressions are allowed,\n               // but are handled differently.\n-              if (init.getType() == Token.VAR) {\n+              if (init.isVar()) {\n                 newStatement = init;\n               } else {\n                 newStatement = NodeUtil.newExpr(init);\n     private void splitVarDeclarations(Node n) {\n       for (Node next, c = n.getFirstChild(); c != null; c = next) {\n         next = c.getNext();\n-        if (c.getType() == Token.VAR) {\n+        if (c.isVar()) {\n           if (assertOnChange && !c.hasChildren()) {\n             throw new IllegalStateException(\"Empty VAR node.\");\n           }\n      */\n     private void moveNamedFunctions(Node functionBody) {\n       Preconditions.checkState(\n-          functionBody.getParent().getType() == Token.FUNCTION);\n+          functionBody.getParent().isFunction());\n       Node previous = null;\n       Node current = functionBody.getFirstChild();\n       // Skip any declarations at the beginning of the function body, they\n     @Override\n     public void onRedeclaration(\n         Scope s, String name, Node n, CompilerInput input) {\n-      Preconditions.checkState(n.getType() == Token.NAME);\n+      Preconditions.checkState(n.isName());\n       Node parent = n.getParent();\n       Var v = s.getVar(name);\n \n       }\n \n       // If name is \"arguments\", Var maybe null.\n-      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+      if (v != null && v.getParentNode().isCatch()) {\n         // Redeclaration of a catch expression variable is hard to model\n         // without support for \"with\" expressions.\n         // The EcmaScript spec (section 12.14), declares that a catch\n             JSError.make(\n                 input.getName(), n,\n                 CATCH_BLOCK_VAR_ERROR, name));\n-      } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+      } else if (v != null && parent.isFunction()) {\n+        if (v.getParentNode().isVar()) {\n           s.undeclare(v);\n           s.declare(name, n, n.getJSType(), v.input);\n           replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n               v.getParentNode().getParent());\n         }\n-      } else if (parent.getType() == Token.VAR) {\n+      } else if (parent.isVar()) {\n         Preconditions.checkState(parent.hasOneChild());\n \n         replaceVarWithAssignment(n, parent, parent.getParent());\n         // It is an empty reference remove it.\n         if (NodeUtil.isStatementBlock(gramps)) {\n           gramps.removeChild(parent);\n-        } else if (gramps.getType() == Token.FOR) {\n+        } else if (gramps.isFor()) {\n           // This is the \"for (var a in b)...\" case.  We don't need to worry\n           // about initializers in \"for (var a;;)...\" as those are moved out\n           // as part of the other normalizations.\n           parent.removeChild(n);\n           gramps.replaceChild(parent, n);\n         } else {\n-          Preconditions.checkState(gramps.getType() == Token.LABEL);\n+          Preconditions.checkState(gramps.isLabel());\n           // We should never get here. LABELs with a single VAR statement should\n           // already have been normalized to have a BLOCK.\n           throw new IllegalStateException(\"Unexpected LABEL\");\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n   private boolean tryReplaceArguments(Scope scope) {\n \n     Node parametersList = scope.getRootNode().getFirstChild().getNext();\n-    Preconditions.checkState(parametersList.getType() == Token.LP);\n+    Preconditions.checkState(parametersList.isLP());\n \n     // Keep track of rather this function modified the AST and needs to be\n     // reported back to the compiler later.\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n           // global variable.\n           if (v != null &&\n               (v.isLocal() ||\n-               v.nameNode.getParent().getType() == Token.CATCH)) {\n+               v.nameNode.getParent().isCatch())) {\n             return false;\n           }\n         }\n         \"Node must be a function.\");\n \n     Node block = function.getLastChild();\n-    Preconditions.checkArgument(block.getType() == Token.BLOCK,\n+    Preconditions.checkArgument(block.isBlock(),\n         \"Node must be a block.\");\n \n     Preconditions.checkState(value.getParent() == null);\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n       Node useNodeParent = site.node.getParent();\n       if (isCall(site)) {\n         Node callNode = useNodeParent;\n-        Preconditions.checkState(callNode.getType() == Token.CALL);\n+        Preconditions.checkState(callNode.isCall());\n         if (isValueUsed(callNode)) {\n           return true;\n         }\n       new NodeUtil.Visitor() {\n         @Override\n         public void visit(Node node) {\n-          if (node.getType() == Token.RETURN && node.hasOneChild()) {\n+          if (node.isReturn() && node.hasOneChild()) {\n             boolean keepValue = NodeUtil.mayHaveSideEffects(\n                 node.getFirstChild(), compiler);\n             if (!keepValue) {\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n   }\n \n   private Node getName(Node n) {\n-    if (n.getType() == Token.VAR) {\n+    if (n.isVar()) {\n       return n.getFirstChild();\n     } else if (NodeUtil.isExprAssign(n)) {\n       return n.getFirstChild().getFirstChild();\n   }\n \n   private Node getValue(Node n) {\n-    if (n.getType() == Token.VAR) {\n+    if (n.isVar()) {\n       return n.getFirstChild().getFirstChild();\n     } else if (NodeUtil.isExprAssign(n)) {\n       return n.getFirstChild().getLastChild();\n   }\n \n   boolean isInterestingValue(Node n) {\n-    return n.getType() == Token.OBJECTLIT || n.getType() == Token.ARRAYLIT;\n+    return n.isObjectLit() || n.getType() == Token.ARRAYLIT;\n   }\n \n   private boolean isPropertyAssignmentToName(Node propertyCandidate) {\n     Node property = obj.getNext();\n \n     // The property must be statically known.\n-    if (lhs.getType() == Token.GETELEM\n+    if (lhs.isGetElem()\n         && (property.getType() != Token.STRING\n             && property.getType() != Token.NUMBER)) {\n       return false;\n     }\n \n     String propertyName;\n-    if (property.getType() == Token.NUMBER) {\n+    if (property.isNumber()) {\n       propertyName = NodeUtil.getStringValue(property);\n     } else {\n       propertyName = property.getString();\n     Node newProperty = Node.newString(propertyName)\n         .copyInformationFrom(property);\n     // Preserve the quotedness of a property reference\n-    if (lhs.getType() == Token.GETELEM) {\n+    if (lhs.isGetElem()) {\n       newProperty.setQuotedString();\n     }\n     Node newValue = rhs.detachFromParent();\n \n   private static boolean mightContainForwardReference(\n       Node node, String varName) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n       return varName.equals(node.getString());\n     }\n     for (Node child = node.getFirstChild(); child != null;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     switch (n.getType()) {\n       case Token.NOT:\n         // Don't fold !0 and !1 back to false.\n-        if (late && left.getType() == Token.NUMBER) {\n+        if (late && left.isNumber()) {\n           double numValue = left.getDouble();\n           if (numValue == 0 || numValue == 1) {\n             return n;\n         return n;\n       case Token.NEG:\n         try {\n-          if (left.getType() == Token.NAME) {\n+          if (left.isName()) {\n             if (left.getString().equals(\"Infinity\")) {\n               // \"-Infinity\" is valid and a literal, don't modify it.\n               return n;\n       if (NodeUtil.isImmutableValue(left)) {\n         // Non-object types are never instances.\n         replacementNode = new Node(Token.FALSE);\n-      } else if (right.getType() == Token.NAME\n+      } else if (right.isName()\n           && \"Object\".equals(right.getString())) {\n         replacementNode = new Node(Token.TRUE);\n       }\n   }\n \n   private Node tryFoldAssign(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n+    Preconditions.checkArgument(n.isAssign());\n \n     if (!late) {\n       return n;\n   private Node tryFoldChildAddString(Node n, Node left, Node right) {\n \n     if (NodeUtil.isLiteralValue(right, false) &&\n-        left.getType() == Token.ADD) {\n+        left.isAdd()) {\n \n       Node ll = left.getFirstChild();\n       Node lr = ll.getNext();\n       // Left's right child MUST be a string. We would not want to fold\n       // foo() + 2 + 'a' because we don't know what foo() will return, and\n       // therefore we don't know if left is a string concat, or a numeric add.\n-      if (lr.getType() == Token.STRING) {\n+      if (lr.isString()) {\n         String leftString = NodeUtil.getStringValue(lr);\n         String rightString = NodeUtil.getStringValue(right);\n         if (leftString != null && rightString != null) {\n     }\n \n     if (NodeUtil.isLiteralValue(left, false) &&\n-        right.getType() == Token.ADD) {\n+        right.isAdd()) {\n \n       Node rl = right.getFirstChild();\n       Node rr = right.getLastChild();\n       // Left's right child MUST be a string. We would not want to fold\n       // foo() + 2 + 'a' because we don't know what foo() will return, and\n       // therefore we don't know if left is a string concat, or a numeric add.\n-      if (rl.getType() == Token.STRING) {\n+      if (rl.isString()) {\n         String leftString = NodeUtil.getStringValue(left);\n         String rightString = NodeUtil.getStringValue(rl);\n         if (leftString != null && rightString != null) {\n    * Try to fold an ADD node with constant operands\n    */\n   private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n-    if (left.getType() == Token.STRING ||\n-        right.getType() == Token.STRING) {\n+    if (left.isString() ||\n+        right.isString()) {\n       // Add strings.\n       String leftString = NodeUtil.getStringValue(left);\n       String rightString = NodeUtil.getStringValue(right);\n     int opType = n.getType();\n     Preconditions.checkState(\n         (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n-        || n.getType() == Token.ADD);\n+        || n.isAdd());\n \n     Preconditions.checkState(\n         n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n   }\n \n   private Node tryFoldAdd(Node node, Node left, Node right) {\n-    Preconditions.checkArgument(node.getType() == Token.ADD);\n+    Preconditions.checkArgument(node.isAdd());\n \n     if (NodeUtil.mayBeString(node, true)) {\n       if (NodeUtil.isLiteralValue(left, false) &&\n    * Try to fold shift operations\n    */\n   private Node tryFoldShift(Node n, Node left, Node right) {\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n+    if (left.isNumber() &&\n+        right.isNumber()) {\n \n       double result;\n       double lval = left.getDouble();\n       case Token.SHEQ:\n       case Token.EQ:\n         Preconditions.checkState(\n-            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n+            left.isNumber() && right.isNumber());\n         result = lv == rv;\n         break;\n       case Token.SHNE:\n       case Token.NE:\n         Preconditions.checkState(\n-            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n+            left.isNumber() && right.isNumber());\n         result = lv != rv;\n         break;\n       case Token.LE: result = lv <= rv; break;\n    * e.g. this[new String('eval')] -> this.eval\n    */\n   private Node tryFoldCtorCall(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.NEW);\n+    Preconditions.checkArgument(n.isNew());\n \n     // we can remove this for GETELEM calls (anywhere else?)\n     if (inForcedStringContext(n)) {\n \n   /** Returns whether this node must be coerced to a string. */\n   private boolean inForcedStringContext(Node n) {\n-    if (n.getParent().getType() == Token.GETELEM &&\n+    if (n.getParent().isGetElem() &&\n         n.getParent().getLastChild() == n) {\n       return true;\n     }\n \n     // we can fold in the case \"\" + new String(\"\")\n-    if (n.getParent().getType() == Token.ADD) {\n+    if (n.getParent().isAdd()) {\n       return true;\n     }\n     return false;\n \n   private Node tryFoldInForcedStringContext(Node n) {\n     // For now, we only know how to fold ctors.\n-    Preconditions.checkArgument(n.getType() == Token.NEW);\n+    Preconditions.checkArgument(n.isNew());\n \n     Node objectType = n.getFirstChild();\n     if (objectType.getType() != Token.NAME) {\n    * Try to fold array-element. e.g [1, 2, 3][10];\n    */\n   private Node tryFoldGetElem(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.GETELEM);\n-\n-    if (left.getType() == Token.OBJECTLIT) {\n+    Preconditions.checkArgument(n.isGetElem());\n+\n+    if (left.isObjectLit()) {\n       return tryFoldObjectPropAccess(n, left, right);\n     }\n \n    * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n    */\n   private Node tryFoldGetProp(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.GETPROP);\n-\n-    if (left.getType() == Token.OBJECTLIT) {\n+    Preconditions.checkArgument(n.isGetProp());\n+\n+    if (left.isObjectLit()) {\n       return tryFoldObjectPropAccess(n, left, right);\n     }\n \n-    if (right.getType() == Token.STRING &&\n+    if (right.isString() &&\n         right.getString().equals(\"length\")) {\n       int knownLength = -1;\n       switch (left.getType()) {\n   private boolean isAssignmentTarget(Node n) {\n     Node parent = n.getParent();\n     if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n-        || parent.getType() == Token.INC\n-        || parent.getType() == Token.DEC) {\n+        || parent.isInc()\n+        || parent.isDec()) {\n       // If GETPROP/GETELEM is used as assignment target the object literal is\n       // acting as a temporary we can't fold it here:\n       //    \"{a:x}.a += 1\" is not \"x += 1\"\n       return n;\n     }\n \n-    if (elem.getType() == Token.EMPTY) {\n+    if (elem.isEmpty()) {\n       elem = NodeUtil.newUndefinedNode(elem);\n     } else {\n       left.removeChild(elem);\n       return n;\n     }\n \n-    if (value.getType() == Token.FUNCTION && NodeUtil.referencesThis(value)) {\n+    if (value.isFunction() && NodeUtil.referencesThis(value)) {\n       // 'this' may refer to the object we are trying to remove\n       return n;\n     }\n \n     Node replacement = value.detachFromParent();\n-    if (key.getType() == Token.GET){\n+    if (key.isGet()){\n       replacement = new Node(Token.CALL, replacement);\n       replacement.putBooleanProp(Node.FREE_CALL, true);\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldTry(Node n) {\n-    Preconditions.checkState(n.getType() == Token.TRY);\n+    Preconditions.checkState(n.isTry());\n     Node body = n.getFirstChild();\n     Node catchBlock = body.getNext();\n     Node finallyBlock = catchBlock.getNext();\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldAssignment(Node subtree) {\n-    Preconditions.checkState(subtree.getType() == Token.ASSIGN);\n+    Preconditions.checkState(subtree.isAssign());\n     Node left = subtree.getFirstChild();\n     Node right = subtree.getLastChild();\n     // Only names\n-    if (left.getType() == Token.NAME\n-        && right.getType() == Token.NAME\n+    if (left.isName()\n+        && right.isName()\n         && left.getString().equals(right.getString())) {\n       subtree.getParent().replaceChild(subtree, right.detachFromParent());\n       reportCodeChange();\n     if (result == null) {\n       Node parent = subtree.getParent();\n       // If the EXPR_RESULT no longer has any children, remove it as well.\n-      if (parent.getType() == Token.LABEL) {\n+      if (parent.isLabel()) {\n         Node replacement = new Node(Token.BLOCK).copyInformationFrom(subtree);\n         parent.replaceChild(subtree, replacement);\n         subtree = replacement;\n    * Remove useless switches and cases.\n    */\n   private Node tryOptimizeSwitch(Node n) {\n-    Preconditions.checkState(n.getType() == Token.SWITCH);\n+    Preconditions.checkState(n.isSwitch());\n \n     Node defaultCase = tryOptimizeDefaultCase(n);\n \n    *     if the default case is removed.\n    */\n   private Node tryOptimizeDefaultCase(Node n) {\n-    Preconditions.checkState(n.getType() == Token.SWITCH);\n+    Preconditions.checkState(n.isSwitch());\n \n     Node lastNonRemovable = n.getFirstChild();  // The switch condition\n \n     // The first child is the switch conditions skip it when looking for cases.\n     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n-      if (c.getType() == Token.DEFAULT) {\n+      if (c.isDefault()) {\n         // Remove cases that fall-through to the default case\n         Node caseToRemove = lastNonRemovable.getNext();\n         for (Node next; caseToRemove != c; caseToRemove = next) {\n         }\n         return c;\n       } else {\n-        Preconditions.checkState(c.getType() == Token.CASE);\n+        Preconditions.checkState(c.isCase());\n         if (c.getLastChild().hasChildren()\n             || mayHaveSideEffects(c.getFirstChild())) {\n           lastNonRemovable = c;\n \n     Node executingCase = caseNode;\n     while (executingCase != null) {\n-      Preconditions.checkState(executingCase.getType() == Token.DEFAULT\n-          || executingCase.getType() == Token.CASE);\n+      Preconditions.checkState(executingCase.isDefault()\n+          || executingCase.isCase());\n       // We only expect a DEFAULT case if the case we are checking is the\n       // DEFAULT case.  Otherwise we assume the DEFAULT case has already\n       // been removed.\n       Preconditions.checkState(caseNode == executingCase\n           || executingCase.getType() != Token.DEFAULT);\n       Node block = executingCase.getLastChild();\n-      Preconditions.checkState(block.getType() == Token.BLOCK);\n+      Preconditions.checkState(block.isBlock());\n       if (block.hasChildren()) {\n         for (Node blockChild : block.children()) {\n           // If this is a block with a labelless break, it is useless.\n     if (NodeUtil.isExprAssign(n)\n         && n.getFirstChild().getFirstChild().isName()) {\n       return true;\n-    } else if (n.getType() == Token.VAR && n.hasOneChild() &&\n+    } else if (n.isVar() && n.hasOneChild() &&\n         n.getFirstChild().getFirstChild() != null) {\n       return true;\n     }\n   private boolean isConditionalStatement(Node n) {\n     // We defined a conditional statement to be a IF or EXPR_RESULT rooted with\n     // a HOOK, AND, or OR node.\n-    return n != null && (n.getType() == Token.IF || isExprConditional(n));\n+    return n != null && (n.isIf() || isExprConditional(n));\n   }\n \n   /**\n    * @return Whether the node is a rooted with a HOOK, AND, or OR node.\n    */\n   private boolean isExprConditional(Node n) {\n-    if (n.getType() == Token.EXPR_RESULT) {\n+    if (n.isExprResult()) {\n       switch (n.getFirstChild().getType()) {\n         case Token.HOOK:\n         case Token.AND:\n    * @return The condition of a conditional statement.\n    */\n   private Node getConditionalStatementCondition(Node n) {\n-    if (n.getType() == Token.IF) {\n+    if (n.isIf()) {\n       return NodeUtil.getConditionExpression(n);\n     } else {\n       Preconditions.checkState(isExprConditional(n));\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldIf(Node n) {\n-    Preconditions.checkState(n.getType() == Token.IF);\n+    Preconditions.checkState(n.isIf());\n     Node parent = n.getParent();\n     Preconditions.checkNotNull(parent);\n     int type = n.getType();\n    * @return the replacement node, if changed, or the original if not\n    */\n   private Node tryFoldHook(Node n) {\n-    Preconditions.checkState(n.getType() == Token.HOOK);\n+    Preconditions.checkState(n.isHook());\n     Node parent = n.getParent();\n     Preconditions.checkNotNull(parent);\n     Node cond = n.getFirstChild();\n    * Removes FORs that always evaluate to false.\n    */\n   Node tryFoldFor(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.FOR);\n+    Preconditions.checkArgument(n.isFor());\n     // If this is a FOR-IN loop skip it.\n     if (NodeUtil.isForIn(n)) {\n       return n;\n    * The block will be removed in a later pass, if possible.\n    */\n   Node tryFoldDo(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.DO);\n+    Preconditions.checkArgument(n.isDo());\n \n     Node cond = NodeUtil.getConditionExpression(n);\n     if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) {\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n \n     subtree = tryFoldArrayJoin(subtree);\n \n-    if (subtree.getType() == Token.CALL) {\n+    if (subtree.isCall()) {\n       Node callTarget = subtree.getFirstChild();\n       if (callTarget == null) {\n         return subtree;\n    *    .indexOf(), .substr(), .substring()\n    */\n   private Node tryFoldKnownStringMethods(Node subtree) {\n-    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+    Preconditions.checkArgument(subtree.isCall());\n \n     // check if this is a call on a string method\n     // then dispatch to specific folding method.\n    *    .parseInt(), parseFloat()\n    */\n   private Node tryFoldKnownNumericMethods(Node subtree) {\n-    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+    Preconditions.checkArgument(subtree.isCall());\n \n     if (isASTNormalized()) {\n       // check if this is a call on a string method\n       String functionNameString = callTarget.getString();\n       Node firstArgument = callTarget.getNext();\n       if ((firstArgument != null) &&\n-          (firstArgument.getType() == Token.STRING ||\n-           firstArgument.getType() == Token.NUMBER)) {\n+          (firstArgument.isString() ||\n+           firstArgument.isNumber())) {\n         if (functionNameString.equals(\"parseInt\") ||\n             functionNameString.equals(\"parseFloat\")) {\n           subtree = tryFoldParseNumber(subtree, functionNameString,\n    */\n   private Node tryFoldParseNumber(\n       Node n, String functionName, Node firstArg) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(n.isCall());\n \n     boolean isParseInt = functionName.equals(\"parseInt\");\n     Node secondArg = firstArg.getNext();\n     // stringVal must be a valid string.\n     String stringVal = null;\n     Double checkVal;\n-    if (firstArg.getType() == Token.NUMBER) {\n+    if (firstArg.isNumber()) {\n       checkVal = NodeUtil.getNumberValue(firstArg);\n       if (!(radix == 0 || radix == 10) && isParseInt) {\n         //Convert a numeric first argument to a different base\n    */\n   private Node tryFoldStringIndexOf(\n       Node n, String functionName, Node lstringNode, Node firstArg) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(lstringNode.isString());\n \n     String lstring = NodeUtil.getStringValue(lstringNode);\n     boolean isIndexOf = functionName.equals(\"indexOf\");\n       return n;\n     }\n \n-    if (right != null && right.getType() == Token.STRING\n+    if (right != null && right.isString()\n         && \",\".equals(right.getString())) {\n       // \",\" is the default, it doesn't need to be explicit\n       n.removeChild(right);\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n+      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n         if (sb == null) {\n           sb = new StringBuilder();\n         } else {\n    * Try to fold .substr() calls on strings\n    */\n   private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n \n     int start, length;\n     String stringAsString = stringNode.getString();\n \n     // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n     // function.\n-    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+    if (arg1 != null && arg1.isNumber()) {\n       start = (int) arg1.getDouble();\n     } else {\n       return n;\n \n     Node arg2 = arg1.getNext();\n     if (arg2 != null) {\n-      if (arg2.getType() == Token.NUMBER) {\n+      if (arg2.isNumber()) {\n         length = (int) arg2.getDouble();\n       } else {\n         return n;\n    * Try to fold .substring() calls on strings\n    */\n   private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n \n     int start, end;\n     String stringAsString = stringNode.getString();\n \n-    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+    if (arg1 != null && arg1.isNumber()) {\n       start = (int) arg1.getDouble();\n     } else {\n       return n;\n \n     Node arg2 = arg1.getNext();\n     if (arg2 != null) {\n-      if (arg2.getType() == Token.NUMBER) {\n+      if (arg2.isNumber()) {\n         end = (int) arg2.getDouble();\n       } else {\n         return n;\n    * Try to fold .charAt() calls on strings\n    */\n   private Node tryFoldStringCharAt(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n \n     int index;\n     String stringAsString = stringNode.getString();\n \n-    if (arg1 != null && arg1.getType() == Token.NUMBER\n+    if (arg1 != null && arg1.isNumber()\n         && arg1.getNext() == null) {\n       index = (int) arg1.getDouble();\n     } else {\n    * Try to fold .charCodeAt() calls on strings\n    */\n   private Node tryFoldStringCharCodeAt(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n \n     int index;\n     String stringAsString = stringNode.getString();\n \n-    if (arg1 != null && arg1.getType() == Token.NUMBER\n+    if (arg1 != null && arg1.isNumber()\n         && arg1.getNext() == null) {\n       index = (int) arg1.getDouble();\n     } else {\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   }\n \n   private Node tryFoldSimpleFunctionCall(Node n) {\n-    Preconditions.checkState(n.getType() == Token.CALL);\n+    Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n-    if (callTarget != null && callTarget.getType() == Token.NAME &&\n+    if (callTarget != null && callTarget.isName() &&\n           callTarget.getString().equals(\"String\")) {\n       // Fold String(a) to ''+(a) - which allows further optimizations\n       Node value = callTarget.getNext();\n \n   private Node tryFoldImmediateCallToBoundFunction(Node n) {\n     // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n-    Preconditions.checkState(n.getType() == Token.CALL);\n+    Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n     Bind bind = getCodingConvention().describeFunctionBind(callTarget);\n     if (bind != null) {\n     Node left = n.getFirstChild();\n     Node right = n.getLastChild();\n \n-    if (parent.getType() == Token.EXPR_RESULT\n+    if (parent.isExprResult()\n         && parent.getParent().getType() != Token.LABEL) {\n       // split comma\n       n.detachChildren();\n \n     for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()){\n-      if (child.getType() == Token.IF){\n+      if (child.isIf()){\n \n         Node cond = child.getFirstChild();\n         Node thenBranch = cond.getNext();\n       }\n     }\n \n-    if (follow == null && (n.getType() == Token.THROW || result != null)) {\n+    if (follow == null && (n.isThrow() || result != null)) {\n       // Can't complete remove a throw here or a return with a result.\n       return n;\n     }\n       }\n     }\n \n-    if (follow == null && (n.getType() == Token.THROW || exitExpr != null)) {\n+    if (follow == null && (n.isThrow() || exitExpr != null)) {\n       // Can't complete remove a throw here or a return with a result.\n       return n;\n     }\n \n   boolean isExceptionPossible(Node n) {\n     // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n-    Preconditions.checkState(n.getType() == Token.RETURN\n-        || n.getType() == Token.THROW);\n-    return n.getType() == Token.THROW\n+    Preconditions.checkState(n.isReturn()\n+        || n.isThrow());\n+    return n.isThrow()\n         || (n.hasChildren()\n             && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n   }\n           return n;\n         }\n \n-        if (cond.getType() == Token.NOT) {\n+        if (cond.isNot()) {\n           // if(!x)bar(); -> x||bar();\n           if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n               isLowerPrecedenceInExpression(expr.getFirstChild(),\n             thenBranch.hasOneChild()) {\n           Node innerIf = thenBranch.getFirstChild();\n \n-          if (innerIf.getType() == Token.IF) {\n+          if (innerIf.isIf()) {\n             Node innerCond = innerIf.getFirstChild();\n             Node innerThenBranch = innerCond.getNext();\n             Node innerElseBranch = innerThenBranch.getNext();\n \n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n-    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n+    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n       n.replaceChild(cond, cond.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       Node maybeName2 = elseAssign.getFirstChild();\n \n       if (name1.hasChildren()\n-          && maybeName2.getType() == Token.NAME\n+          && maybeName2.isName()\n           && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n       Node name2 = var.getFirstChild();\n \n       if (name2.hasChildren()\n-          && maybeName1.getType() == Token.NAME\n+          && maybeName1.isName()\n           && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n    * @param n The IF node to examine.\n    */\n   private void tryRemoveRepeatedStatements(Node n) {\n-    Preconditions.checkState(n.getType() == Token.IF);\n+    Preconditions.checkState(n.isIf());\n \n     Node parent = n.getParent();\n     if (!NodeUtil.isStatementBlock(parent)) {\n    *     an expression.\n    */\n   private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n+    if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node maybeExpr = n.getFirstChild();\n-        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n+        if (maybeExpr.isExprResult()) {\n           // IE has a bug where event handlers behave differently when\n           // their return value is used vs. when their return value is in\n           // an EXPR_RESULT. It's pretty freaking weird. See:\n           // http://code.google.com/p/closure-compiler/issues/detail?id=291\n           // We try to detect this case, and not fold EXPR_RESULTs\n           // into other expressions.\n-          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n+          if (maybeExpr.getFirstChild().isCall()) {\n             Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            if (calledFn.getType() == Token.GETELEM) {\n+            if (calledFn.isGetElem()) {\n               return false;\n-            } else if (calledFn.getType() == Token.GETPROP &&\n+            } else if (calledFn.isGetProp() &&\n                        calledFn.getLastChild().getString().startsWith(\"on\")) {\n               return false;\n             }\n    *     an return with or without an expression.\n    */\n   private boolean isReturnBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n+    if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n-        return first.getType() == Token.RETURN;\n+        return first.isReturn();\n       }\n     }\n \n    *     an return.\n    */\n   private boolean isReturnExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n+    if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n-        if (first.getType() == Token.RETURN) {\n+        if (first.isReturn()) {\n           return first.hasOneChild();\n         }\n       }\n    * @return Whether the node is a single return statement.\n    */\n   private boolean isReturnExpression(Node n) {\n-    if (n.getType() == Token.RETURN) {\n+    if (n.isReturn()) {\n       return n.hasOneChild();\n     }\n     return false;\n    *     a VAR declaration of a single variable.\n    */\n   private boolean isVarBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n+    if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n-        if (first.getType() == Token.VAR) {\n+        if (first.isVar()) {\n           return first.hasOneChild();\n         }\n       }\n         new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n-        return (input.getType() == Token.GETPROP &&\n-            input.getParent().getType() == Token.ASSIGN);\n+        return (input.isGetProp() &&\n+            input.getParent().isAssign());\n       }\n     };\n \n                 }\n               }\n \n-              if (leftParent.getType() == Token.NOT) {\n+              if (leftParent.isNot()) {\n                 left = leftParent.removeFirstChild();\n               } else {\n                 leftParent.detachFromParent();\n                 left = new Node(Token.NOT, leftParent)\n                   .copyInformationFrom(leftParent);\n               }\n-              if (rightParent.getType() == Token.NOT) {\n+              if (rightParent.isNot()) {\n                 right = rightParent.removeFirstChild();\n               } else {\n                 rightParent.detachFromParent();\n                   .copyInformationFrom(rightParent);\n               }\n \n-              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n+              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n               Node newRoot = new Node(newOp, left, right);\n               parent.replaceChild(n, newRoot);\n               reportCodeChange();\n    * Fold \"new Object()\" to \"Object()\".\n    */\n   private Node tryFoldStandardConstructors(Node n) {\n-    Preconditions.checkState(n.getType() == Token.NEW);\n+    Preconditions.checkState(n.isNew());\n \n     // If name normalization has been run then we know that\n     // new Object() does in fact refer to what we think it is\n     // and not some custom-defined Object().\n     if (isASTNormalized()) {\n-      if (n.getFirstChild().getType() == Token.NAME) {\n+      if (n.getFirstChild().isName()) {\n         String className = n.getFirstChild().getString();\n         if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n           n.setType(Token.CALL);\n    * call to Array or Object is to a local function with the same name.\n    */\n   private Node tryFoldLiteralConstructor(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL\n-        || n.getType() == Token.NEW);\n+    Preconditions.checkArgument(n.isCall()\n+        || n.isNew());\n \n     Node constructorNameNode = n.getFirstChild();\n \n     }\n \n     if (// is pattern folded\n-        pattern.getType() == Token.STRING\n+        pattern.isString()\n         // make sure empty pattern doesn't fold to //\n         && !\"\".equals(pattern.getString())\n \n         // 100 chars, or it blows up the regexp parser in Opera 9.2.\n         && pattern.getString().length() < 100\n \n-        && (null == flags || flags.getType() == Token.STRING)\n+        && (null == flags || flags.isString())\n         // don't escape patterns with unicode escapes since Safari behaves badly\n         // (read can't parse or crashes) on regex literals with unicode escapes\n         && (isEcmaScript5OrGreater()\n   private Node reduceTrueFalse(Node n) {\n     if (late) {\n       Node not = new Node(Token.NOT,\n-          Node.newNumber(n.getType() == Token.TRUE ? 0 : 1));\n+          Node.newNumber(n.isTrue() ? 0 : 1));\n       not.copyInformationFromForTree(n);\n       n.getParent().replaceChild(n, not);\n       reportCodeChange();\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.OBJECTLIT) {\n+      if (n.isObjectLit()) {\n         normalizeObjectLiteralAnnotations(n);\n       }\n       return true;\n     }\n \n     private void normalizeObjectLiteralAnnotations(Node objlit) {\n-      Preconditions.checkState(objlit.getType() == Token.OBJECTLIT);\n+      Preconditions.checkState(objlit.isObjectLit());\n       for (Node key = objlit.getFirstChild();\n            key != null; key = key.getNext()) {\n         Node value = key.getFirstChild();\n      * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n      */\n     private void annotateCalls(Node n) {\n-      Preconditions.checkState(n.getType() == Token.CALL);\n+      Preconditions.checkState(n.isCall());\n \n       // Keep track of of the \"this\" context of a call.  A call without an\n       // explicit \"this\" is a free call.\n \n       // Keep track of the context in which eval is called. It is important\n       // to distinguish between \"(0, eval)()\" and \"eval()\".\n-      if (first.getType() == Token.NAME &&\n+      if (first.isName() &&\n           \"eval\".equals(first.getString())) {\n         first.putBooleanProp(Node.DIRECT_EVAL, true);\n       }\n      * Translate dispatcher info into the property expected node.\n      */\n     private void annotateDispatchers(Node n, Node parent) {\n-      Preconditions.checkState(n.getType() == Token.FUNCTION);\n+      Preconditions.checkState(n.isFunction());\n       if (parent.getJSDocInfo() != null\n           && parent.getJSDocInfo().isJavaDispatch()) {\n-        if (parent.getType() == Token.ASSIGN) {\n+        if (parent.isAssign()) {\n           Preconditions.checkState(parent.getLastChild() == n);\n           n.putBooleanProp(Node.IS_DISPATCHER, true);\n         }\n      */\n     private void normalizeObjectLiteralKeyAnnotations(\n         Node objlit, Node key, Node value) {\n-      Preconditions.checkState(objlit.getType() == Token.OBJECTLIT);\n+      Preconditions.checkState(objlit.isObjectLit());\n       if (key.getJSDocInfo() != null &&\n-          value.getType() == Token.FUNCTION) {\n+          value.isFunction()) {\n         value.setJSDocInfo(key.getJSDocInfo());\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.CALL:\n-        boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n+        boolean isExpr = parent.isExprResult();\n         Node left = n.getFirstChild();\n-        if (left.getType() == Token.GETPROP) {\n+        if (left.isGetProp()) {\n           Node name = left.getFirstChild();\n-          if (name.getType() == Token.NAME &&\n+          if (name.isName() &&\n               GOOG.equals(name.getString())) {\n             // For the sake of simplicity, we report code changes\n             // when we see a provides/requires, and don't worry about\n               processProvideCall(t, n, parent);\n             } else if (\"exportSymbol\".equals(methodName)) {\n               Node arg = left.getNext();\n-              if (arg.getType() == Token.STRING) {\n+              if (arg.isString()) {\n                 int dot = arg.getString().indexOf('.');\n                 if (dot == -1) {\n                   exportedVariables.add(arg.getString());\n         break;\n \n       case Token.GETPROP:\n-        if (n.getFirstChild().getType() == Token.NAME &&\n+        if (n.getFirstChild().isName() &&\n             parent.getType() != Token.CALL &&\n             parent.getType() != Token.ASSIGN &&\n             \"goog.base\".equals(n.getQualifiedName())) {\n       NodeTraversal t, Node n, Node parent) {\n     if (t.inGlobalScope()) {\n       String name = null;\n-      if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n+      if (n.isName() && parent.isVar()) {\n         name = n.getString();\n-      } else if (n.getType() == Token.ASSIGN &&\n-          parent.getType() == Token.EXPR_RESULT) {\n+      } else if (n.isAssign() &&\n+          parent.isExprResult()) {\n         name = n.getFirstChild().getQualifiedName();\n       }\n \n     if (enclosingQname.indexOf(\".prototype.\") == -1) {\n       // Handle constructors.\n       Node enclosingParent = enclosingFnNameNode.getParent();\n-      Node maybeInheritsExpr = (enclosingParent.getType() == Token.ASSIGN ?\n+      Node maybeInheritsExpr = (enclosingParent.isAssign() ?\n           enclosingParent.getParent() : enclosingParent).getNext();\n       Node baseClassNode = null;\n       if (maybeInheritsExpr != null &&\n-          maybeInheritsExpr.getType() == Token.EXPR_RESULT &&\n-          maybeInheritsExpr.getFirstChild().getType() == Token.CALL) {\n+          maybeInheritsExpr.isExprResult() &&\n+          maybeInheritsExpr.getFirstChild().isCall()) {\n         Node callNode = maybeInheritsExpr.getFirstChild();\n         if (\"goog.inherits\".equals(\n                 callNode.getFirstChild().getQualifiedName()) &&\n     } else {\n       Node parent = scopeRoot.getParent();\n       if (parent != null) {\n-        if (parent.getType() == Token.ASSIGN ||\n+        if (parent.isAssign() ||\n             parent.getLastChild() == scopeRoot &&\n             parent.getFirstChild().isQualifiedName()) {\n           // x.y.z = function() {...};\n           return parent.getFirstChild();\n-        } else if (parent.getType() == Token.NAME) {\n+        } else if (parent.isName()) {\n           // var x = function() {...};\n           return parent;\n         }\n     if (!rewriteNewDateGoogNow) {\n       return;\n     }\n-    Preconditions.checkArgument(n.getType() == Token.NEW);\n+    Preconditions.checkArgument(n.isNew());\n     Node date = n.getFirstChild();\n     if (!date.isName() || !\"Date\".equals(date.getString())) {\n       return;\n           candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n           Node assignNode = candidateDefinition.getFirstChild();\n           Node nameNode = assignNode.getFirstChild();\n-          if (nameNode.getType() == Token.NAME) {\n+          if (nameNode.isName()) {\n             // Need to convert this assign to a var declaration.\n             Node valueNode = nameNode.getNext();\n             assignNode.removeChild(nameNode);\n     }\n \n     Node value = null;\n-    if (n.getType() == Token.EXPR_RESULT) {\n+    if (n.isExprResult()) {\n       Node assign = n.getFirstChild();\n       value = assign.getLastChild();\n-    } else if (n.getType() == Token.VAR) {\n+    } else if (n.isVar()) {\n       Node name = n.getFirstChild();\n       value = name.getFirstChild();\n     }\n \n     return value != null\n-      && value.getType() == Token.OBJECTLIT\n+      && value.isObjectLit()\n       && !value.hasChildren();\n   }\n \n \n     Node current = null;\n     for (current = syntheticRef;\n-         current.getType() == Token.GETPROP;\n+         current.isGetProp();\n          current = current.getFirstChild()) {\n       int fullLen = current.getQualifiedName().length();\n       int namespaceLen = current.getFirstChild().getQualifiedName().length();\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n           Node parent = ref.node.getParent();\n           JSDocInfo info = n.getJSDocInfo();\n           if (info == null &&\n-              parent.getType() == Token.VAR && parent.hasOneChild()) {\n+              parent.isVar() && parent.hasOneChild()) {\n             info = parent.getJSDocInfo();\n           }\n \n           case SET_FROM_LOCAL:\n             Node valParent = getValueParent(ref);\n             Node val = valParent.getLastChild();\n-            if (valParent.getType() == Token.ASSIGN && name.isSimpleName() &&\n+            if (valParent.isAssign() && name.isSimpleName() &&\n                 name.getDeclaration() == ref) {\n               // For defines, it's an error if a simple name is assigned\n               // before it's declared\n \n       if (lvalueToRemoveLater == n) {\n         lvalueToRemoveLater = null;\n-        if (n.getType() == Token.ASSIGN) {\n+        if (n.isAssign()) {\n           Node last = n.getLastChild();\n           n.removeChild(last);\n           parent.replaceChild(n, last);\n         } else {\n-          Preconditions.checkState(n.getType() == Token.NAME);\n+          Preconditions.checkState(n.isName());\n           n.removeChild(n.getFirstChild());\n         }\n         compiler.reportCodeChange();\n       }\n \n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         if (t.inGlobalScope()) {\n           // If there's a function call in the global scope,\n           // we just say it's unsafe and freeze all the defines.\n     private static Node getValueParent(Ref ref) {\n       // there are two types of declarations: VARs and ASSIGNs\n       return ref.node.getParent() != null &&\n-          ref.node.getParent().getType() == Token.VAR ?\n+          ref.node.getParent().isVar() ?\n           ref.node : ref.node.getParent();\n     }\n \n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       }\n \n       return result;\n-    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {\n+    } else if (name.isOr() || name.isHook()) {\n       Node firstVal;\n-      if (name.getType() == Token.HOOK) {\n+      if (name.isHook()) {\n         firstVal = name.getFirstChild().getNext();\n       } else {\n         firstVal = name.getFirstChild();\n         Var v = i.next();\n         boolean localVar = false;\n         // Parameters and catch values come can from other scopes.\n-        if (v.getParentNode().getType() == Token.VAR) {\n+        if (v.getParentNode().isVar()) {\n           // TODO(johnlenz): create a useful parameter list\n           sideEffectInfo.knownLocals.add(v.getName());\n           localVar = true;\n     public boolean traverseEdge(FunctionInformation callee,\n                                 Node callSite,\n                                 FunctionInformation caller) {\n-      Preconditions.checkArgument(callSite.getType() == Token.CALL ||\n-                                  callSite.getType() == Token.NEW);\n+      Preconditions.checkArgument(callSite.isCall() ||\n+                                  callSite.isNew());\n \n       boolean changed = false;\n       if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n    */\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.NAME) {\n+    if (n.isName()) {\n       Var v;\n       if (n.getString().equals(\"arguments\")) {\n         v = t.getScope().getArgumentsVar();\n       }\n     }\n \n-    return n.getType() == Token.CASE;\n+    return n.isCase();\n   }\n \n   private void addReference(NodeTraversal t, Var v, Reference reference) {\n       Node parent = getParent();\n       Node grandparent = parent.getParent();\n       return DECLARATION_PARENTS.contains(parent.getType()) ||\n-          parent.getType() == Token.LP &&\n-          grandparent.getType() == Token.FUNCTION;\n+          parent.isLP() &&\n+          grandparent.isFunction();\n     }\n \n     boolean isVarDeclaration() {\n-      return getParent().getType() == Token.VAR;\n+      return getParent().isVar();\n     }\n \n     boolean isHoistedFunction() {\n     */\n     Node getAssignedValue() {\n       Node parent = getParent();\n-      return (parent.getType() == Token.FUNCTION)\n+      return (parent.isFunction())\n           ? parent : NodeUtil.getAssignedValue(nameNode);\n     }\n \n \n     private static boolean isLhsOfForInExpression(Node n) {\n       Node parent = n.getParent();\n-      if (parent.getType() == Token.VAR) {\n+      if (parent.isVar()) {\n         return isLhsOfForInExpression(parent);\n       }\n       return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;\n \n     boolean isSimpleAssignmentToName() {\n       Node parent = getParent();\n-      return parent.getType() == Token.ASSIGN\n+      return parent.isAssign()\n           && parent.getFirstChild() == nameNode;\n     }\n \n       // only named functions may be hoisted.\n       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n \n-      this.isFunction = root.getType() == Token.FUNCTION;\n+      this.isFunction = root.isFunction();\n \n       if (root.getParent() != null) {\n         int pType = root.getParent().getType();\n--- a/src/com/google/javascript/jscomp/RemoveTryCatch.java\n+++ b/src/com/google/javascript/jscomp/RemoveTryCatch.java\n           for (Node anc = parent;\n                anc != null && anc.getType() != Token.FUNCTION;\n                anc = anc.getParent()) {\n-            if (anc.getType() == Token.TRY) {\n+            if (anc.isTry()) {\n               tryNodesContainingReturnStatements.add(anc);\n               break;\n             }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n       case Token.NAME:\n         var = scope.getVar(n.getString());\n-        if (parent.getType() == Token.VAR) {\n+        if (parent.isVar()) {\n           Node value = n.getFirstChild();\n           if (value != null && var != null && isRemovableVar(var) &&\n               !NodeUtil.mayHaveSideEffects(value)) {\n    */\n   private void traverseFunction(Node n, Scope parentScope) {\n     Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.getType() == Token.FUNCTION);\n+    Preconditions.checkState(n.isFunction());\n \n     final Node body = n.getLastChild();\n     Preconditions.checkState(body.getNext() == null &&\n-            body.getType() == Token.BLOCK);\n+            body.isBlock());\n \n     Scope fnScope =\n         new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n \n     Node function = fnScope.getRootNode();\n \n-    Preconditions.checkState(function.getType() == Token.FUNCTION);\n+    Preconditions.checkState(function.isFunction());\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n       // The parameters object literal setters can not be removed.\n       return;\n \n     public void optimize(Scope fnScope, Set<Var> referenced) {\n       Node function = fnScope.getRootNode();\n-      Preconditions.checkState(function.getType() == Token.FUNCTION);\n+      Preconditions.checkState(function.isFunction());\n       Node argList = getFunctionArgList(function);\n \n       // In this path we try to modify all the call sites to remove unused\n           boolean assignedToUnknownValue = false;\n           boolean hasPropertyAssign = false;\n \n-          if (var.getParentNode().getType() == Token.VAR &&\n+          if (var.getParentNode().isVar() &&\n               !NodeUtil.isForIn(var.getParentNode().getParent())) {\n             Node value = var.getInitialValue();\n             assignedToUnknownValue = value != null &&\n       Node parent = toRemove.getParent();\n \n       Preconditions.checkState(\n-          toRemove.getType() == Token.VAR ||\n-          toRemove.getType() == Token.FUNCTION ||\n-          toRemove.getType() == Token.LP &&\n-          parent.getType() == Token.FUNCTION,\n+          toRemove.isVar() ||\n+          toRemove.isFunction() ||\n+          toRemove.isLP() &&\n+          parent.isFunction(),\n           \"We should only declare vars and functions and function args\");\n \n-      if (toRemove.getType() == Token.LP &&\n-          parent.getType() == Token.FUNCTION) {\n+      if (toRemove.isLP() &&\n+          parent.isFunction()) {\n         // Don't remove function arguments here. That's a special case\n         // that's taken care of in removeUnreferencedFunctionArgs.\n       } else if (NodeUtil.isFunctionExpression(toRemove)) {\n         }\n         // Don't remove bleeding functions.\n       } else if (parent != null &&\n-          parent.getType() == Token.FOR &&\n+          parent.isFor() &&\n           parent.getChildCount() < 4) {\n         // foreach iterations have 3 children. Leave them alone.\n-      } else if (toRemove.getType() == Token.VAR &&\n+      } else if (toRemove.isVar() &&\n           nameNode.hasChildren() &&\n           NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n         // If this is a single var declaration, we can at least remove the\n               new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n           compiler.reportCodeChange();\n         }\n-      } else if (toRemove.getType() == Token.VAR &&\n+      } else if (toRemove.isVar() &&\n           toRemove.getChildCount() > 1) {\n         // For var declarations with multiple names (i.e. var a, b, c),\n         // only remove the unreferenced name\n         current = current.getFirstChild();\n         isPropAssign = true;\n \n-        if (current.getType() == Token.GETPROP &&\n+        if (current.isGetProp() &&\n             current.getLastChild().getString().equals(\"prototype\")) {\n           // Prototype properties sets should be considered like normal\n           // property sets.\n         }\n       }\n \n-      if (current.getType() == Token.NAME) {\n+      if (current.isName()) {\n         return new Assign(assignNode, current, isPropAssign);\n       }\n       return null;\n         for (Node current = assignNode.getFirstChild();\n              current.getType() != Token.NAME;\n              current = current.getFirstChild()) {\n-          if (current.getType() == Token.GETELEM) {\n+          if (current.isGetElem()) {\n             replacement = new Node(Token.COMMA,\n                 current.getLastChild().detachFromParent(), replacement);\n             replacement.copyInformationFrom(current);\n         parent.replaceChild(assignNode, replacement);\n       } else {\n         Node gramps = parent.getParent();\n-        if (parent.getType() == Token.EXPR_RESULT) {\n+        if (parent.isExprResult()) {\n           gramps.removeChild(parent);\n         } else {\n           parent.replaceChild(assignNode,\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n     @Override\n     public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node,\n         Node parent) {\n-      if (node.getType() == Token.LABEL) {\n+      if (node.isLabel()) {\n         // Determine the new name for this label.\n         LabelNamespace current = namespaceStack.peek();\n         int currentDepth = current.renameMap.size() + 1;\n         Node newChild = node.getLastChild();\n         node.removeChild(newChild);\n         parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n+        if (newChild.isBlock()) {\n           NodeUtil.tryMergeBlock(newChild);\n         }\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n       switch (n.getType()) {\n         case Token.GETPROP:\n           Node dest = n.getFirstChild().getNext();\n-          if (dest.getType() == Token.STRING) {\n+          if (dest.isString()) {\n             externedNames.add(dest.getString());\n           }\n           break;\n       switch (n.getType()) {\n         case Token.GETPROP:\n           Node propNode = n.getFirstChild().getNext();\n-          if (propNode.getType() == Token.STRING) {\n+          if (propNode.isString()) {\n             maybeMarkCandidate(propNode);\n           }\n           break;\n           // ensure that we never rename some other property in a way that\n           // could conflict with this quoted name.\n           Node child = n.getLastChild();\n-          if (child != null && child.getType() == Token.STRING) {\n+          if (child != null && child.isString()) {\n             quotedNames.add(child.getString());\n           }\n           break;\n           // We replace a JSCompiler_renameProperty function call with a string\n           // containing the renamed property.\n           Node fnName = n.getFirstChild();\n-          if (fnName.getType() == Token.NAME &&\n+          if (fnName.isName() &&\n               RENAME_PROPERTY_FUNCTION_NAME.equals(fnName.getString())) {\n             callNodeToParentMap.put(n, parent);\n             countCallCandidates(t, n);\n               }\n               compiler.reportCodeChange();\n             }\n-          } else if (parent.getType() == Token.NAME &&\n+          } else if (parent.isName() &&\n                      RENAME_PROPERTY_FUNCTION_NAME.equals(parent.getString())) {\n             Node varNode = parent.getParent();\n-            if (varNode.getType() == Token.VAR) {\n+            if (varNode.isVar()) {\n               varNode.removeChild(parent);\n               if (!varNode.hasChildren()) {\n                 varNode.detachFromParent();\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n         case Token.GETPROP:\n         case Token.GETELEM:\n           Node dest = n.getFirstChild().getNext();\n-          if (dest.getType() == Token.STRING) {\n+          if (dest.isString()) {\n             reservedNames.add(dest.getString());\n           }\n       }\n         case Token.GETPROP:\n         case Token.GETELEM:\n           Node dest = n.getFirstChild().getNext();\n-          if (dest.getType() == Token.STRING) {\n+          if (dest.isString()) {\n             String s = dest.getString();\n             if (s.equals(\"prototype\")) {\n               processPrototypeParent(parent, t.getInput());\n         case Token.GETPROP:\n         case Token.GETELEM:\n           Node dest = n.getFirstChild().getNext();\n-          if (dest.getType() == Token.STRING) {\n+          if (dest.isString()) {\n             markPrototypePropertyCandidate(dest, input);\n           }\n           break;\n         case Token.ASSIGN:\n         case Token.CALL:\n           Node map;\n-          if (n.getType() == Token.ASSIGN) {\n+          if (n.isAssign()) {\n             map = n.getFirstChild().getNext();\n           } else {\n             map = n.getLastChild();\n           }\n-          if (map.getType() == Token.OBJECTLIT) {\n+          if (map.isObjectLit()) {\n             // Remember this node so that we can avoid processing it again when\n             // the traversal reaches it.\n             prototypeObjLits.add(map);\n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.CALL &&\n+      if (n.isCall() &&\n           GET_CSS_NAME_FUNCTION.equals(n.getFirstChild().getQualifiedName())) {\n         int count = n.getChildCount();\n         Node first = n.getFirstChild().getNext();\n         switch (count) {\n           case 2:\n             // Replace the function call with the processed argument.\n-            if (first.getType() == Token.STRING) {\n+            if (first.isString()) {\n               processStringNode(t, first);\n               n.removeChild(first);\n               parent.replaceChild(n, first);\n             if (second.getType() != Token.STRING) {\n               compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                   Token.name(second.getType())));\n-            } else if (first.getType() == Token.STRING) {\n+            } else if (first.isString()) {\n               compiler.report(t.makeError(\n                   n, UNEXPECTED_STRING_LITERAL_ERROR,\n                   first.getString(), second.getString()));\n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n           (JsMessage.PlaceholderReference) part;\n \n       for (Node node : argListNode.children()) {\n-        if (node.getType() == Token.NAME) {\n+        if (node.isName()) {\n           String arg = node.getString();\n \n           // We ignore the case here because the transconsole only supports\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n         // Look for calls to class methods.\n         if (NodeUtil.isGet(calledFn)) {\n           Node rhs = calledFn.getLastChild();\n-          if (rhs.getType() == Token.NAME || rhs.getType() == Token.STRING) {\n+          if (rhs.isName() || rhs.isString()) {\n             String methodName = rhs.getString();\n             Collection<String> classes = methods.get(methodName);\n             if (classes != null) {\n    */\n   private void doSubstitutions(NodeTraversal t, Config config, Node n) {\n     Preconditions.checkState(\n-        n.getType() == Token.NEW || n.getType() == Token.CALL);\n+        n.isNew() || n.isCall());\n \n     if (config.parameter != Config.REPLACE_ALL_VALUE) {\n       // Note: the first child is the function, but the parameter id is 1 based.\n         Scope.Var var = t.getScope().getVar(expr.getString());\n         if (var != null && var.isConst()) {\n           Node value = var.getInitialValue();\n-          if (value != null && value.getType() == Token.STRING) {\n+          if (value != null && value.isString()) {\n             key = value.getString();\n             replacementString = getReplacement(key);\n             replacement = Node.newString(replacementString);\n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n       }\n       String name = n.getString();\n       // Ignore anonymous functions\n-      if (parent.getType() == Token.FUNCTION && name.length() == 0) {\n+      if (parent.isFunction() && name.length() == 0) {\n         return;\n       }\n       Scope.Var var = t.getScope().getVar(name);\n       Node nameNode = var.getNameNode();\n       // The exception variable (e in try{}catch(e){}) should not be rewritten.\n       if (nameNode != null && nameNode.getParent() != null &&\n-          nameNode.getParent().getType() == Token.CATCH) {\n+          nameNode.getParent().isCatch()) {\n         return;\n       }\n       replaceSymbol(n, name);\n       // because the previous traversal in RewriteScopeCallback creates\n       // them.\n       for (Node c : n.children()) {\n-        if (c.getType() == Token.ASSIGN ||\n-            parent.getType() == Token.FOR) {\n+        if (c.isAssign() ||\n+            parent.isFor()) {\n           interestingChildren.add(c);\n         }\n       }\n       for (Node c : interestingChildren) {\n-        if (parent.getType() == Token.FOR && parent.getFirstChild() == n) {\n+        if (parent.isFor() && parent.getFirstChild() == n) {\n           commas.add(c.cloneTree());\n         } else {\n           // Var statement outside of for-loop.\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isFunction()) {\n         visitFunction(t, n);\n-      } else if (n.getType() == Token.RETURN) {\n+      } else if (n.isReturn()) {\n         visitReturn(t, n);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     @Override public boolean apply(Var var) {\n       return var.getParentNode() != null &&\n           var.getType() == null && // no declared type\n-          var.getParentNode().getType() == Token.VAR &&\n+          var.getParentNode().isVar() &&\n           !var.isExtern();\n     }\n   };\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n       // Remove the alias definitions.\n       for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n-        if (aliasDefinition.getParent().getType() == Token.VAR &&\n+        if (aliasDefinition.getParent().isVar() &&\n             aliasDefinition.getParent().hasOneChild()) {\n           aliasDefinition.getParent().detachFromParent();\n         } else {\n     }\n \n     private boolean isCallToScopeMethod(Node n) {\n-      return n.getType() == Token.CALL &&\n+      return n.isCall() &&\n           SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n     }\n \n \n     @Override\n     public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.FUNCTION && t.inGlobalScope()) {\n+      if (n.isFunction() && t.inGlobalScope()) {\n         // Do not traverse in to functions except for goog.scope functions.\n         if (parent == null || !isCallToScopeMethod(parent)) {\n           return false;\n     private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n       Node testNode = n;\n       Node next = null;\n-      for (; next != null || testNode.getType() == Token.SCRIPT;) {\n+      for (; next != null || testNode.isScript();) {\n         next = testNode.getNext();\n         testNode = testNode.getParent();\n       }\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.getType() == Token.VAR) {\n+        if (parent.isVar()) {\n           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n             String name = n.getString();\n             Var aliasVar = scope.getVar(name);\n     }\n \n     private void fixTypeNode(Node typeNode) {\n-      if (typeNode.getType() == Token.STRING) {\n+      if (typeNode.isString()) {\n         String name = typeNode.getString();\n         int endIndex = name.indexOf('.');\n         if (endIndex == -1) {\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n \n         Node typeOfNode = null;\n         Node stringNode = null;\n-        if (left.getType() == Token.TYPEOF && right.getType() == Token.STRING) {\n+        if (left.getType() == Token.TYPEOF && right.isString()) {\n           typeOfNode = left;\n           stringNode = right;\n         } else if (right.getType() == Token.TYPEOF &&\n-                   left.getType() == Token.STRING) {\n+                   left.isString()) {\n           typeOfNode = right;\n           stringNode = left;\n         }\n             outcome);\n \n       case Token.IN:\n-        if (outcome && condition.getFirstChild().getType() == Token.STRING) {\n+        if (outcome && condition.getFirstChild().isString()) {\n           return caseIn(condition.getLastChild(),\n               condition.getFirstChild().getString(), blindScope);\n         }\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n         // For now, we don't allow movement within a CASE.\n         //\n         // TODO(dcc): be less conservative about movement within CASE\n-        if (node2DeepestControlDependentBlock.getType() == Token.CASE) {\n+        if (node2DeepestControlDependentBlock.isCase()) {\n           return false;\n         }\n \n           NodeUtil.isAssignmentOp(parent) && parent.getType() != Token.ASSIGN;\n \n         return (nonSimpleAssign\n-            || parent.getType() == Token.DEC\n-            || parent.getType() == Token.INC);\n+            || parent.isDec()\n+            || parent.isInc());\n       }\n \n       return true;\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n       // Arguments of external functions should not count as name\n       // definitions.  They are placeholder names for documentation\n       // purposes only which are not reachable from anywhere.\n-      if (inExterns && node.isName() && parent.getType() == Token.LP) {\n+      if (inExterns && node.isName() && parent.isLP()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n     // We can just join the new comma expression with another comma but\n     // lets keep all the comma's in a straight line. That way we can use\n     // tree comparison.\n-    if (exp2.getType() == Token.COMMA) {\n+    if (exp2.isComma()) {\n       Node leftMostChild = exp2;\n-      while(leftMostChild.getType() == Token.COMMA) {\n+      while(leftMostChild.isComma()) {\n         leftMostChild = leftMostChild.getFirstChild();\n       }\n       Node parent = leftMostChild.getParent();\n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n   }\n \n   @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.NAME) {\n+    if (n.isName()) {\n       if (!isDeclaration(n)) {\n         checkNameUse(t, n);\n       }\n-    } else if (n.getType() == Token.ASSIGN) {\n+    } else if (n.isAssign()) {\n       checkAssignment(t, n);\n     } else if (n.getType() == Token.DELPROP) {\n       checkDelete(t, n);\n-    } else if (n.getType() == Token.OBJECTLIT) {\n+    } else if (n.isObjectLit()) {\n       checkObjectLiteral(t, n);\n-    } else if (n.getType() == Token.LABEL) {\n+    } else if (n.isLabel()) {\n       checkLabel(t, n);\n     }\n   }\n         return true;\n \n       case Token.LP:\n-        return n.getParent().getParent().getType() == Token.FUNCTION;\n+        return n.getParent().getParent().isFunction();\n \n       default:\n         return false;\n \n   /** Checks that an assignment is not to the \"arguments\" object. */\n   private void checkAssignment(NodeTraversal t, Node n) {\n-    if (n.getFirstChild().getType() == Token.NAME) {\n+    if (n.getFirstChild().isName()) {\n       if (\"arguments\".equals(n.getFirstChild().getString())) {\n         t.report(n, ARGUMENTS_ASSIGNMENT);\n       } else if (\"eval\".equals(n.getFirstChild().getString())) {\n \n   /** Checks that variables, functions, and arguments are not deleted. */\n   private void checkDelete(NodeTraversal t, Node n) {\n-    if (n.getFirstChild().getType() == Token.NAME) {\n+    if (n.getFirstChild().isName()) {\n       Var v = t.getScope().getVar(n.getFirstChild().getString());\n       if (v != null) {\n         t.report(n, DELETE_VARIABLE);\n   /** Checks that are performed on non-extern code only. */\n   private class NonExternChecks extends AbstractPostOrderCallback {\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if ((n.getType() == Token.NAME) && isDeclaration(n)) {\n+      if ((n.isName()) && isDeclaration(n)) {\n         checkDeclaration(t, n);\n-      } else if (n.getType() == Token.GETPROP) {\n+      } else if (n.isGetProp()) {\n         checkProperty(t, n);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n      */\n     boolean isCallWhoseReturnValueShouldBeStripped(@Nullable Node n) {\n       return n != null &&\n-          (n.getType() == Token.CALL ||\n-           n.getType() == Token.NEW) &&\n+          (n.isCall() ||\n+           n.isNew()) &&\n           n.hasChildren() &&\n           (qualifiedNameBeginsWithStripType(n.getFirstChild()) ||\n               nameEndsWithFieldNameToStrip(n.getFirstChild()));\n         return false;\n       }\n \n-      if (parent != null && parent.getType() == Token.NAME) {\n+      if (parent != null && parent.isName()) {\n         Node gramps = parent.getParent();\n-        if (gramps != null && gramps.getType() == Token.VAR) {\n+        if (gramps != null && gramps.isVar()) {\n           // The call's return value is being used to initialize a newly\n           // declared variable. We should leave the call intact for now.\n           // That way, when the traversal reaches the variable declaration,\n      * @return Whether the name ends with a field name that should be stripped\n      */\n     boolean nameEndsWithFieldNameToStrip(@Nullable Node n) {\n-      if (n != null && n.getType() == Token.GETPROP) {\n+      if (n != null && n.isGetProp()) {\n         Node propNode = n.getLastChild();\n-        return propNode != null && propNode.getType() == Token.STRING &&\n+        return propNode != null && propNode.isString() &&\n                isStripName(propNode.getString());\n       }\n       return false;\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n    */\n   public SymbolScope getEnclosingScope(Node n) {\n     Node current = n.getParent();\n-    if (n.getType() == Token.NAME &&\n-        n.getParent().getType() == Token.FUNCTION) {\n+    if (n.isName() &&\n+        n.getParent().isFunction()) {\n       current = current.getParent();\n     }\n \n     for (Symbol symbol : getAllSymbolsSorted()) {\n       for (Reference ref : getReferences(symbol)) {\n         Node currentNode = ref.getNode();\n-        while (currentNode.getType() == Token.GETPROP) {\n+        while (currentNode.isGetProp()) {\n           currentNode = currentNode.getFirstChild();\n \n           String name = currentNode.getQualifiedName();\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.GETPROP) {\n+      if (n.isGetProp()) {\n         JSType owner = n.getFirstChild().getJSType();\n         if (owner == null || owner.isUnknownType()) {\n           // Try to find the symbol by its fully qualified name.\n     }\n \n     public void visitTypeNode(SymbolScope scope, Node n) {\n-      if (n.getType() == Token.STRING) {\n+      if (n.isString()) {\n         Symbol symbol = scope.getSlot(n.getString());\n         if (symbol == null) {\n           // If we can't find this type, it might be a reference to a\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n   }\n \n   private void scanRoot(Node n, Scope parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (inputId == null) {\n         inputId = NodeUtil.getInputId(n);\n         // TODO(johnlenz): inputId maybe null if the FUNCTION node is detached\n       }\n \n       // Args: Declare function variables\n-      Preconditions.checkState(args.getType() == Token.LP);\n+      Preconditions.checkState(args.isLP());\n       for (Node a = args.getFirstChild(); a != null;\n            a = a.getNext()) {\n-        Preconditions.checkState(a.getType() == Token.NAME);\n+        Preconditions.checkState(a.isName());\n         declareVar(a);\n       }\n \n \n       case Token.CATCH:\n         Preconditions.checkState(n.getChildCount() == 2);\n-        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n+        Preconditions.checkState(n.getFirstChild().isName());\n         // the first child is the catch var and the third child\n         // is the code block\n \n       if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH &&\n-            parent.getType() == Token.CATCH) {\n+        if (origParent.isCatch() &&\n+            parent.isCatch()) {\n           // Okay, both are 'catch(x)' variables.\n           return;\n         }\n    * @param n The node corresponding to the variable name.\n    */\n   private void declareVar(Node n) {\n-    Preconditions.checkState(n.getType() == Token.NAME);\n+    Preconditions.checkState(n.isName());\n \n     CompilerInput input = compiler.getInput(inputId);\n     String name = n.getString();\n    *     for the given node.\n    */\n   static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n-    Preconditions.checkState(n.getType() == Token.NAME);\n+    Preconditions.checkState(n.isName());\n     Node parent = n.getParent();\n     Node origParent = origVar.getParentNode();\n \n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n     /** Finds assignments and variables from the function body. */\n     void initForScopeRoot(Node decl) {\n       Preconditions.checkNotNull(decl);\n-      if (decl.getType() == Token.FUNCTION) {\n+      if (decl.isFunction()) {\n         decl = decl.getLastChild();\n       }\n-      Preconditions.checkArgument(decl.getType() == Token.BLOCK);\n+      Preconditions.checkArgument(decl.isBlock());\n \n       NodeTraversal.traverse(compiler, decl, new CreateScope(this, false));\n     }\n     /** Finds assignments and variables from the given externs. */\n     void initForExternRoot(Node decl) {\n       Preconditions.checkNotNull(decl);\n-      Preconditions.checkArgument(decl.getType() == Token.BLOCK);\n+      Preconditions.checkArgument(decl.isBlock());\n \n       NodeTraversal.traverse(compiler, decl, new CreateScope(this, true));\n     }\n           if (inExterns) {\n             // Again, we have to trust the externs.\n             ConcreteScope scope;\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n               ConcreteType type = inferConcreteType(getTopScope(),\n                   lhs.getFirstChild());\n               scope = (ConcreteScope) type.getScope();\n         case Token.NEW:\n         case Token.CALL:\n           Node receiver = n.getFirstChild();\n-          if (receiver.getType() == Token.GETPROP) {\n+          if (receiver.isGetProp()) {\n             Node first = receiver.getFirstChild();\n             // Special case the call() function.\n             if (\"call\".equals(first.getNext().getString())) {\n-              if (first.getType() == Token.GETPROP) {\n+              if (first.isGetProp()) {\n                 // foo.bar.call()\n                 addAction(new FunctionCallBuilder(first, receiver.getNext())\n                     .setPropName(first.getFirstChild().getNext().getString())\n           } else {\n             // foo() or new Foo()\n             addAction(new FunctionCallBuilder(receiver, receiver.getNext())\n-                      .setIsNewCall(n.getType() == Token.NEW)\n+                      .setIsNewCall(n.isNew())\n                       .build());\n           }\n           break;\n \n         case Token.NAME:\n-          if (parent.getType() == Token.CATCH && parent.getFirstChild() == n) {\n+          if (parent.isCatch() && parent.getFirstChild() == n) {\n             // The variable in a catch statement gets defined in the scope of\n             // the catch block. We approximate that, as does the normal type\n             // sytem, by declaring a variable for it in the scope in which the\n           // TODO(user): handle addEventListener for the case of an object\n           //     implementing the EventListener interface.\n           Node receiver = n.getFirstChild();\n-          if (!inExterns && receiver.getType() == Token.GETPROP) {\n+          if (!inExterns && receiver.isGetProp()) {\n             return getImplicitActionsFromCall(n, receiver.getJSType());\n           }\n           break;\n           Node lhs = n.getFirstChild();\n           // Functions assigned to externs properties are considered called.\n           // E.g. element.onclick = function handle(evt) {};\n-          if (!inExterns && lhs.getType() == Token.GETPROP) {\n+          if (!inExterns && lhs.isGetProp()) {\n             return getImplicitActionsFromProp(lhs.getFirstChild().getJSType(),\n                 lhs.getLastChild().getString(), n.getLastChild());\n           }\n   /** Returns a concrete type from the JSType of the given variable. */\n   private ConcreteType createType(Node name, ConcreteScope scope) {\n     Preconditions.checkNotNull(name);\n-    Preconditions.checkArgument(name.getType() == Token.NAME);\n+    Preconditions.checkArgument(name.isName());\n \n     if (name.getJSType() == null) {\n       return ConcreteType.ALL;\n     }\n \n     if ((name.getFirstChild() != null)\n-        && (name.getFirstChild().getType() == Token.FUNCTION)) {\n+        && (name.getFirstChild().isFunction())) {\n       return createConcreteFunction(name.getFirstChild(), scope);\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n \n       case Token.GETPROP:\n         visitGetProp(t, n, parent);\n-        typeable = !(parent.getType() == Token.ASSIGN &&\n+        typeable = !(parent.isAssign() &&\n                      parent.getFirstChild() == n);\n         break;\n \n           ensureTyped(t, n);\n         } else {\n           // If this is an enum, then give that type to the objectlit as well.\n-          if ((n.getType() == Token.OBJECTLIT)\n+          if ((n.isObjectLit())\n               && (parent.getJSType() instanceof EnumType)) {\n             ensureTyped(t, n, parent.getJSType());\n           } else {\n             ensureTyped(t, n);\n           }\n         }\n-        if (n.getType() == Token.OBJECTLIT) {\n+        if (n.isObjectLit()) {\n           for (Node key : n.children()) {\n             visitObjLitKey(t, key, n);\n           }\n    * of the object type it is referring to.\n    * @param t the traversal\n    * @param assign the assign node\n-   * (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant)\n+   * (<code>assign.isAssign()</code> is an implicit invariant)\n    */\n   private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info = assign.getJSDocInfo();\n     Node lvalue = assign.getFirstChild();\n     Node rvalue = assign.getLastChild();\n \n-    if (lvalue.getType() == Token.GETPROP) {\n+    if (lvalue.isGetProp()) {\n       Node object = lvalue.getFirstChild();\n       JSType objectJsType = getJSType(object);\n       String property = lvalue.getLastChild().getString();\n \n       // the first name in this getprop refers to an interface\n       // we perform checks in addition to the ones below\n-      if (object.getType() == Token.GETPROP) {\n+      if (object.isGetProp()) {\n         JSType jsType = getJSType(object.getFirstChild());\n         if (jsType.isInterface() &&\n             object.getLastChild().getString().equals(\"prototype\")) {\n       }\n \n       // object.prototype.property = ...;\n-      if (object.getType() == Token.GETPROP) {\n+      if (object.isGetProp()) {\n         Node object2 = object.getFirstChild();\n         String property2 = NodeUtil.getStringValue(object.getLastChild());\n \n         }\n         return;\n       }\n-    } else if (lvalue.getType() == Token.NAME) {\n+    } else if (lvalue.isName()) {\n       // variable with inferred type case\n       JSType rvalueType = getJSType(assign.getLastChild());\n       Var var = t.getScope().getVar(lvalue.getString());\n               abstractMethodMessage));\n     }\n \n-    if (assign.getLastChild().getType() == Token.FUNCTION\n+    if (assign.getLastChild().isFunction()\n         && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) {\n       compiler.report(\n           t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,\n     // GETPROP nodes have an assigned type on their node by the scope creator\n     // if this is an enum declaration. The only namespaced enum declarations\n     // that we allow are of the form object.name = ...;\n-    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\n+    if (n.getJSType() != null && parent.isAssign()) {\n       return;\n     }\n \n         return parent.getFirstChild() == getProp;\n \n       case Token.NOT:\n-        return parent.getParent().getType() == Token.OR &&\n+        return parent.getParent().isOr() &&\n             parent.getParent().getFirstChild() == parent;\n     }\n     return false;\n       if (functionType.isOrdinaryFunction() &&\n           !functionType.getTypeOfThis().isUnknownType() &&\n           !functionType.getTypeOfThis().isNativeObjectType() &&\n-          !(child.getType() == Token.GETELEM ||\n-            child.getType() == Token.GETPROP)) {\n+          !(child.isGetElem() ||\n+            child.isGetProp())) {\n         report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n       }\n \n       }\n \n       if (info.isImplicitCast() && !inExterns) {\n-        String propName = n.getType() == Token.GETPROP ?\n+        String propName = n.isGetProp() ?\n             n.getLastChild().getString() : \"(missing)\";\n         compiler.report(\n             t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n             FlowScope informed = traverse(obj, output.createChildFlowScope());\n \n-            if (item.getType() == Token.VAR) {\n+            if (item.isVar()) {\n               item = item.getFirstChild();\n             }\n-            if (item.getType() == Token.NAME) {\n+            if (item.isName()) {\n               JSType iterKeyType = getNativeType(STRING_TYPE);\n               ObjectType objType = getJSType(obj).dereference();\n               JSType objIndexType = objType == null ?\n         case ON_FALSE:\n           if (condition == null) {\n             condition = NodeUtil.getConditionExpression(source);\n-            if (condition == null && source.getType() == Token.CASE) {\n+            if (condition == null && source.isCase()) {\n               condition = source;\n \n               // conditionFlowScope is cached from previous iterations\n           }\n \n           if (condition != null) {\n-            if (condition.getType() == Token.AND ||\n-                condition.getType() == Token.OR) {\n+            if (condition.isAnd() ||\n+                condition.isOr()) {\n               // When handling the short-circuiting binary operators,\n               // the outcome scope on true can be different than the outcome\n               // scope on false.\n               // conditionOutcomes is cached from previous iterations\n               // of the loop.\n               if (conditionOutcomes == null) {\n-                conditionOutcomes = condition.getType() == Token.AND ?\n+                conditionOutcomes = condition.isAnd() ?\n                     traverseAnd(condition, output.createChildFlowScope()) :\n                     traverseOr(condition, output.createChildFlowScope());\n               }\n \n       case Token.EXPR_RESULT:\n         scope = traverseChildren(n, scope);\n-        if (n.getFirstChild().getType() == Token.GETPROP) {\n+        if (n.getFirstChild().isGetProp()) {\n           ensurePropertyDeclared(n.getFirstChild());\n         }\n         break;\n         // effect for all subsequent accesses of that name,\n         // so treat it the same as an assign to that name.\n         if (n.isQualifiedName() &&\n-            n.getParent().getType() == Token.EXPR_RESULT) {\n+            n.getParent().isExprResult()) {\n           updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n         }\n \n                 propName, rightType, getprop);\n           }\n         } else {\n-          if (getprop.getFirstChild().getType() == Token.THIS &&\n+          if (getprop.getFirstChild().isThis() &&\n               getJSType(syntacticScope.getRootNode()).isConstructor()) {\n             objectType.defineInferredProperty(\n                 propName, rightType, getprop);\n           scope = narrowScope(scope, assertedNode, narrowed);\n           callNode.setJSType(narrowed);\n         }\n-      } else if (assertedNode.getType() == Token.AND ||\n-                 assertedNode.getType() == Token.OR) {\n+      } else if (assertedNode.isAnd() ||\n+                 assertedNode.isOr()) {\n         BooleanOutcomePair conditionOutcomes =\n             traverseWithinShortCircuitingBinOp(assertedNode, scope);\n         scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n \n   private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n     scope = scope.createChildFlowScope();\n-    if (node.getType() == Token.GETPROP) {\n+    if (node.isGetProp()) {\n       scope.inferQualifiedSlot(\n           node, node.getQualifiedName(), getJSType(node), narrowed);\n     } else {\n       if (iParameterType.isFunctionType()) {\n         FunctionType iParameterFnType = iParameterType.toMaybeFunctionType();\n \n-        if (iArgument.getType() == Token.FUNCTION &&\n+        if (iArgument.isFunction() &&\n             iArgumentType.isFunctionType() &&\n             iArgument.getJSDocInfo() == null) {\n           iArgument.setJSType(iParameterFnType);\n               }\n               Node jArgument = n.getChildAtIndex(j + 1);\n               JSType jArgumentType = getJSType(jArgument);\n-              if (jArgument.getType() == Token.FUNCTION &&\n+              if (jArgument.isFunction() &&\n                   jArgumentType.isFunctionType()) {\n                 if (iArgumentType != null &&\n                     // null and undefined get filtered out above.\n \n   private void redeclareSimpleVar(\n       FlowScope scope, Node nameNode, JSType varType) {\n-    Preconditions.checkState(nameNode.getType() == Token.NAME);\n+    Preconditions.checkState(nameNode.isName());\n     String varName = nameNode.getString();\n     if (varType == null) {\n       varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n       // http://code.google.com/p/closure-compiler/issues/detail?id=109\n       //\n       // We do not do this inference globally.\n-      if (n.getType() == Token.GETPROP &&\n+      if (n.isGetProp() &&\n           !t.inGlobalScope() && type.isNullType()) {\n         return true;\n       }\n    */\n   void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n       JSType indexType) {\n-    Preconditions.checkState(n.getType() == Token.GETELEM);\n+    Preconditions.checkState(n.isGetElem());\n     Node indexNode = n.getLastChild();\n     if (objType.isUnknownType()) {\n       expectStringOrNumber(t, indexNode, indexType, \"property access\");\n   void expectUndeclaredVariable(String sourceName, CompilerInput input,\n       Node n, Node parent, Var var, String variableName, JSType newType) {\n     boolean allowDupe = false;\n-    if (n.getType() == Token.GETPROP ||\n+    if (n.isGetProp() ||\n         NodeUtil.isObjectLitKey(n, parent)) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info == null) {\n         s.declare(variableName, n, varType, input, false);\n \n         n.setJSType(varType);\n-        if (parent.getType() == Token.VAR) {\n+        if (parent.isVar()) {\n           if (n.getFirstChild() != null) {\n             n.getFirstChild().setJSType(varType);\n           }\n         } else {\n-          Preconditions.checkState(parent.getType() == Token.FUNCTION);\n+          Preconditions.checkState(parent.isFunction());\n           parent.setJSType(varType);\n         }\n       } else {\n         // If the types match, suppress the warning iff there was a @suppress\n         // tag, or if the original declaration was a stub.\n         if (!(allowDupe ||\n-              var.getParentNode().getType() == Token.EXPR_RESULT) ||\n+              var.getParentNode().isExprResult()) ||\n             !newType.equals(varType)) {\n           report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n               variableName, newType.toString(), var.getInputName(),\n     // If we're analyzing a GETPROP, the property may be inherited by the\n     // prototype chain. So climb the prototype chain and find out where\n     // the property was originally defined.\n-    if (n.getType() == Token.GETPROP) {\n+    if (n.isGetProp()) {\n       ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n       if (objectType != null) {\n         String propName = n.getLastChild().getString();\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n   void add(Node n, Context context) {\n     Node parent = n.getParent();\n     if (parent != null\n-        && (parent.getType() == Token.BLOCK\n-            || parent.getType() == Token.SCRIPT)) {\n-      if (n.getType() == Token.FUNCTION) {\n+        && (parent.isBlock()\n+            || parent.isScript())) {\n+      if (n.isFunction()) {\n         add(getFunctionAnnotation(n));\n-      } else if (n.getType() == Token.EXPR_RESULT\n-          && n.getFirstChild().getType() == Token.ASSIGN) {\n+      } else if (n.isExprResult()\n+          && n.getFirstChild().isAssign()) {\n         Node rhs = n.getFirstChild().getLastChild();\n         add(getTypeAnnotation(rhs));\n-      } else if (n.getType() == Token.VAR\n+      } else if (n.isVar()\n           && n.getFirstChild().getFirstChild() != null\n-          && n.getFirstChild().getFirstChild().getType() == Token.FUNCTION) {\n+          && n.getFirstChild().getFirstChild().isFunction()) {\n         add(getFunctionAnnotation(n.getFirstChild().getFirstChild()));\n       }\n     }\n    * @param fnNode A node for a function for which to generate a type annotation\n    */\n   private String getFunctionAnnotation(Node fnNode) {\n-    Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n+    Preconditions.checkState(fnNode.isFunction());\n     StringBuilder sb = new StringBuilder(\"/**\\n\");\n \n     JSType type = fnNode.getJSType();\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   void patchGlobalScope(Scope globalScope, Node scriptRoot) {\n     // Preconditions: This is supposed to be called only on (named) SCRIPT nodes\n     // and a global typed scope should have been generated already.\n-    Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n+    Preconditions.checkState(scriptRoot.isScript());\n     Preconditions.checkNotNull(globalScope);\n     Preconditions.checkState(globalScope.isGlobal());\n \n           break;\n         case Token.EXPR_RESULT:\n           Node firstChild = node.getFirstChild();\n-          if (firstChild.getType() == Token.ASSIGN) {\n+          if (firstChild.isAssign()) {\n             identifyNameNode(\n                 firstChild.getFirstChild(), firstChild.getLastChild(),\n                 firstChild.getJSDocInfo());\n     public final boolean shouldTraverse(NodeTraversal t, Node n,\n         Node parent) {\n       inputId = t.getInputId();\n-      if (n.getType() == Token.FUNCTION ||\n-          n.getType() == Token.SCRIPT) {\n+      if (n.isFunction() ||\n+          n.isScript()) {\n         Preconditions.checkNotNull(inputId);\n         sourceName = NodeUtil.getSourceName(n);\n       }\n         case Token.ASSIGN:\n           // Handle initialization of properties.\n           Node firstChild = n.getFirstChild();\n-          if (firstChild.getType() == Token.GETPROP &&\n+          if (firstChild.isGetProp() &&\n               firstChild.isQualifiedName()) {\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                 firstChild, n, firstChild.getNext());\n \n         case Token.GETPROP:\n           // Handle stubbed properties.\n-          if (parent.getType() == Token.EXPR_RESULT &&\n+          if (parent.isExprResult() &&\n               n.isQualifiedName()) {\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n           }\n         Node node, JSDocInfo info) {\n       JSType jsType = null;\n       Node objNode =\n-          node.getType() == Token.GETPROP ? node.getFirstChild() :\n+          node.isGetProp() ? node.getFirstChild() :\n           NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n           null;\n       if (info != null) {\n       if (functionType == null) {\n         Node errorRoot = rValue == null ? lvalueNode : rValue;\n         boolean isFnLiteral =\n-            rValue != null && rValue.getType() == Token.FUNCTION;\n+            rValue != null && rValue.isFunction();\n         Node fnRoot = isFnLiteral ? rValue : null;\n         Node parametersNode = isFnLiteral ?\n             rValue.getFirstChild().getNext() : null;\n             builder.inferThisType(\n                 info, ownerType.getOwnerFunction().getInstanceType());\n             searchedForThisType = true;\n-          } else if (ownerNode != null && ownerNode.getType() == Token.THIS) {\n+          } else if (ownerNode != null && ownerNode.isThis()) {\n             builder.inferThisType(info, ownerNode.getJSType());\n             searchedForThisType = true;\n           }\n             info.getEnumParameterType().evaluate(scope, typeRegistry);\n         enumType = typeRegistry.createEnumType(name, rValue, elementsType);\n \n-        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n+        if (rValue != null && rValue.isObjectLit()) {\n           // collect enum elements\n           Node key = rValue.getFirstChild();\n           while (key != null) {\n \n       // Only allow declarations of NAMEs and qualfied names.\n       // Object literal keys will have to compute their names themselves.\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         Preconditions.checkArgument(\n-            parent.getType() == Token.FUNCTION ||\n-            parent.getType() == Token.VAR ||\n-            parent.getType() == Token.LP ||\n-            parent.getType() == Token.CATCH);\n+            parent.isFunction() ||\n+            parent.isVar() ||\n+            parent.isLP() ||\n+            parent.isCatch());\n       } else {\n         Preconditions.checkArgument(\n-            n.getType() == Token.GETPROP &&\n-            (parent.getType() == Token.ASSIGN ||\n-             parent.getType() == Token.EXPR_RESULT));\n+            n.isGetProp() &&\n+            (parent.isAssign() ||\n+             parent.isExprResult()));\n       }\n       defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n     }\n         JSType type, boolean inferred) {\n       Preconditions.checkArgument(!variableName.isEmpty());\n \n-      boolean isGlobalVar = n.getType() == Token.NAME && scope.isGlobal();\n+      boolean isGlobalVar = n.isName() && scope.isGlobal();\n       boolean shouldDeclareOnGlobalThis =\n           isGlobalVar &&\n-          (parent.getType() == Token.VAR ||\n-           parent.getType() == Token.FUNCTION);\n+          (parent.isVar() ||\n+           parent.isFunction());\n \n       // If n is a property, then we should really declare it in the\n       // scope where the root object appears. This helps out people\n       // who declare \"global\" names in an anonymous namespace.\n       Scope scopeToDeclareIn = scope;\n-      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n+      if (n.isGetProp() && !scope.isGlobal() &&\n           isQnameRootedInGlobalScope(n)) {\n         Scope globalScope = scope.getGlobalScope();\n \n         if (type instanceof EnumType) {\n           Node initialValue = newVar.getInitialValue();\n           boolean isValidValue = initialValue != null &&\n-              (initialValue.getType() == Token.OBJECTLIT ||\n+              (initialValue.isObjectLit() ||\n                initialValue.isQualifiedName());\n           if (!isValidValue) {\n             compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n      */\n     private boolean isQnameRootedInGlobalScope(Node n) {\n       Node root = NodeUtil.getRootOfQualifiedName(n);\n-      if (root.getType() == Token.NAME) {\n+      if (root.isName()) {\n         Var var = scope.getVar(root.getString());\n         if (var != null) {\n           return var.isGlobal();\n         Node lValue, @Nullable Node rValue) {\n       if (info != null && info.hasType()) {\n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n-      } else if (rValue != null && rValue.getType() == Token.FUNCTION &&\n+      } else if (rValue != null && rValue.isFunction() &&\n           shouldUseFunctionLiteralType(\n               JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n         return rValue.getJSType();\n       } else if (info != null) {\n         if (info.hasEnumParameterType()) {\n-          if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n+          if (rValue != null && rValue.isObjectLit()) {\n             return rValue.getJSType();\n           } else {\n             return createEnumTypeFromNodes(\n               if (rValue.getJSType() != null\n                   && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();\n-              } else if (rValue.getType() == Token.OR) {\n+              } else if (rValue.isOr()) {\n                 // Check for a very specific JS idiom:\n                 // var x = x || TYPE;\n                 // This is used by Closure's base namespace for esoteric\n                 // reasons.\n                 Node firstClause = rValue.getFirstChild();\n                 Node secondClause = firstClause.getNext();\n-                boolean namesMatch = firstClause.getType() == Token.NAME\n-                    && lValue.getType() == Token.NAME\n+                boolean namesMatch = firstClause.isName()\n+                    && lValue.isName()\n                     && firstClause.getString().equals(lValue.getString());\n                 if (namesMatch && secondClause.getJSType() != null\n                     && !secondClause.getJSType().isUnknownType()) {\n           ObjectType qVarType = ObjectType.cast(qVar.getType());\n           if (qVarType != null &&\n               rhsValue != null &&\n-              rhsValue.getType() == Token.OBJECTLIT) {\n+              rhsValue.isObjectLit()) {\n             typeRegistry.resetImplicitPrototype(\n                 rhsValue.getJSType(), qVarType.getImplicitPrototype());\n           } else if (!qVar.isTypeInferred()) {\n       }\n \n       if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n+        if (parent.isExprResult()) {\n           stubDeclarations.add(new StubDeclaration(\n               n,\n               t.getInput() != null && t.getInput().isExtern(),\n       if (inferred) {\n         // Determining declaration for #2\n         inferred = !(rhsValue != null &&\n-            rhsValue.getType() == Token.FUNCTION &&\n+            rhsValue.isFunction() &&\n             (info != null || !scope.isDeclared(qName, false)));\n       }\n \n         // caught when we try to declare it in the current scope.\n         defineSlot(n, parent, valueType, inferred);\n       } else if (rhsValue != null &&\n-          rhsValue.getType() == Token.TRUE) {\n+          rhsValue.isTrue()) {\n         // We declare these for delegate proxy method properties.\n         FunctionType ownerType =\n             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n \n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.getType() == Token.EXPR_RESULT) {\n+        if (n.isExprResult()) {\n           Node child = n.getFirstChild();\n           switch (child.getType()) {\n             case Token.ASSIGN:\n         JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);\n         Node name = member.getLastChild();\n         if (jsType != null &&\n-            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n+            (name.isName() || name.isString())) {\n           thisType.defineDeclaredProperty(\n               name.getString(),\n               jsType,\n       }\n \n       typeRegistry.overwriteDeclaredType(typedef, realType);\n-      if (candidate.getType() == Token.GETPROP) {\n+      if (candidate.isGetProp()) {\n         defineSlot(candidate, candidate.getParent(),\n             getNativeType(NO_TYPE), false);\n       }\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n == scope.getRootNode()) return;\n \n-      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n+      if (n.isLP() && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n         return;\n       }\n \n-      if (n.getType() == Token.RETURN && n.getFirstChild() != null) {\n+      if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n-      } else if (n.getType() == Token.NAME && NodeUtil.isLValue(n)) {\n+      } else if (n.isName() && NodeUtil.isLValue(n)) {\n         String name = n.getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n--- a/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n+++ b/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n     switch (node.getType()) {\n       case Token.INC:\n       case Token.DEC:\n-        unfoldIncrDecr(node, node.getType() == Token.INC);\n+        unfoldIncrDecr(node, node.isInc());\n         break;\n       case Token.ASSIGN_BITOR:  // |=\n       case Token.ASSIGN_BITXOR: // ^=\n    */\n   private boolean isPrefix(Node node) {\n     Preconditions.checkArgument(\n-        node.getType() == Token.INC || node.getType() == Token.DEC,\n+        node.isInc() || node.isDec(),\n         \"isPrefix can only be called on INC and DEC nodes\");\n     // According to CodeGenerator:\n     // A non-zero post-prop value indicates a post inc/dec, default of zero is a\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     if (parent == null) {\n       return;\n     }\n-    if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) {\n+    if (n.isFunction() || n.isScript()) {\n       return;\n     }\n \n         List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n         if (outEdges.size() == 1 &&\n             // If there is a next node, there is no chance this jump is useless.\n-            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n+            (n.getNext() == null || n.getNext().isFunction())) {\n \n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n           Node fallThrough = computeFollowing(n);\n \n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n-    while (next != null && next.getType() == Token.BLOCK) {\n+    while (next != null && next.isBlock()) {\n       if (next.hasChildren()) {\n         next = next.getFirstChild();\n       } else {\n \n   private void removeDeadExprStatementSafely(Node n) {\n     Node parent = n.getParent();\n-    if (n.getType() == Token.EMPTY ||\n-        (n.getType() == Token.BLOCK && !n.hasChildren())) {\n+    if (n.isEmpty() ||\n+        (n.isBlock() && !n.hasChildren())) {\n       // Not always trivial to remove, let FoldContants work its magic later.\n       return;\n     }\n       case Token.BLOCK:\n         // BLOCKs are used in several ways including wrapping CATCH\n         // blocks in TRYs\n-        if (parent.getType() == Token.TRY) {\n+        if (parent.isTry()) {\n           if (NodeUtil.isTryCatchNodeContainer(n)) {\n             return;\n           }\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n   @Override\n   public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n-    Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n+    Preconditions.checkState(scriptRoot.isScript());\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n     // variables that are defined in other js files.\n \n     // Check if this is a declaration for a var that has been declared\n     // elsewhere. If so, mark it as a duplicate.\n-    if ((parent.getType() == Token.VAR ||\n+    if ((parent.isVar() ||\n          NodeUtil.isFunctionDeclaration(parent)) &&\n         varsToDeclareInExterns.contains(varName)) {\n       createSynthesizedExternVar(varName);\n   private class NameRefInExternsCheck extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         switch (parent.getType()) {\n           case Token.VAR:\n           case Token.FUNCTION:\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n           if (!reference.getNode().isFromExterns()) {\n             // Special case to deal with var goog = goog || {}\n             Node grandparent = reference.getGrandparent();\n-            if (grandparent.getType() == Token.NAME\n+            if (grandparent.isName()\n                 && grandparent.getString() == v.name) {\n               continue;\n             }\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Map;\n \n /**\n \n     Preconditions.checkArgument(parent.isVar()\n         || parent.isFunction()\n-        || parent.getType() == Token.LP);\n+        || parent.isLP());\n \n     return visibilityByDeclaringNameNode.get(declaringNameNode);\n   }\n   private static boolean variableIsParameter(Var variable) {\n     Node variableParent = variable.getParentNode();\n \n-    return variableParent != null && variableParent.getType() == Token.LP;\n+    return variableParent != null && variableParent.isLP();\n   }\n }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n   private Node transformBlock(AstNode node) {\n     Node irNode = transform(node);\n-    if (irNode.getType() != Token.BLOCK) {\n-      if (irNode.getType() == Token.EMPTY) {\n+    if (!irNode.isBlock()) {\n+      if (irNode.isEmpty()) {\n         irNode.setType(Token.BLOCK);\n         irNode.setWasEmptyNode(true);\n       } else {\n         ret = transform(n);\n         ret.putBooleanProp(Node.QUOTED_PROP, true);\n       }\n-      Preconditions.checkState(ret.getType() == Token.STRING);\n+      Preconditions.checkState(ret.isString());\n       return ret;\n     }\n \n \n       int nType = n.getType();\n       return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().getType() == Token.STRING &&\n+          n.getFirstChild().isString() &&\n           ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n         Node value = transform(el.getRight());\n         if (el.isGetter()) {\n           key.setType(Token.GET);\n-          Preconditions.checkState(value.getType() == Token.FUNCTION);\n+          Preconditions.checkState(value.isFunction());\n           if (getFnParamNode(value).hasChildren()) {\n             reportGetterParam(el.getLeft());\n           }\n         } else if (el.isSetter()) {\n           key.setType(Token.SET);\n-          Preconditions.checkState(value.getType() == Token.FUNCTION);\n+          Preconditions.checkState(value.isFunction());\n           if (!getFnParamNode(value).hasOneChild()) {\n             reportSetterParam(el.getLeft());\n           }\n      */\n    Node getFnParamNode(Node fnNode) {\n      // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n-     Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n+     Preconditions.checkArgument(fnNode.isFunction());\n      return fnNode.getFirstChild().getNext();\n    }\n \n     Node processUnaryExpression(UnaryExpression exprNode) {\n       int type = transformTokenType(exprNode.getType());\n       Node operand = transform(exprNode.getOperand());\n-      if (type == Token.NEG && operand.getType() == Token.NUMBER) {\n+      if (type == Token.NEG && operand.isNumber()) {\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n         if (type == Token.DELPROP &&\n-            !(operand.getType() == Token.GETPROP ||\n-              operand.getType() == Token.GETELEM ||\n-              operand.getType() == Token.NAME)) {\n+            !(operand.isGetProp() ||\n+              operand.isGetElem() ||\n+              operand.isName())) {\n           String msg =\n               \"Invalid delete operand. Only properties can be deleted.\";\n           errorReporter.error(\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n   /*** AST type check methods ***/\n \n+  public boolean isAdd() {\n+    return this.getType() == Token.ADD;\n+  }\n+\n+  public boolean isAnd() {\n+    return this.getType() == Token.AND;\n+  }\n+\n   public boolean isArrayLit() {\n     return this.getType() == Token.ARRAYLIT;\n   }\n     return this.getType() == Token.CATCH;\n   }\n \n+  public boolean isComma() {\n+    return this.getType() == Token.COMMA;\n+  }\n+\n   public boolean isDec() {\n     return this.getType() == Token.DEC;\n   }\n     return this.getType() == Token.EXPR_RESULT;\n   }\n \n+  public boolean isFalse() {\n+    return this.getType() == Token.FALSE;\n+  }\n+\n   public boolean isFor() {\n     return this.getType() == Token.FOR;\n   }\n     return this.getType() == Token.GETPROP;\n   }\n \n+  public boolean isHook() {\n+    return this.getType() == Token.HOOK;\n+  }\n+\n   public boolean isIf() {\n     return this.getType() == Token.IF;\n   }\n     return this.getType() == Token.NEW;\n   }\n \n+  public boolean isNot() {\n+    return this.getType() == Token.NOT;\n+  }\n+\n   public boolean isNull() {\n     return this.getType() == Token.NULL;\n   }\n \n+  public boolean isNumber() {\n+    return this.getType() == Token.NUMBER;\n+  }\n+\n   public boolean isObjectLit() {\n     return this.getType() == Token.OBJECTLIT;\n   }\n \n+  public boolean isOr() {\n+    return this.getType() == Token.OR;\n+  }\n+\n   public boolean isRegExp() {\n     return this.getType() == Token.REGEXP;\n   }\n \n+  public boolean isReturn() {\n+    return this.getType() == Token.RETURN;\n+  }\n+\n   public boolean isScript() {\n     return this.getType() == Token.SCRIPT;\n   }\n     return this.getType() == Token.STRING;\n   }\n \n+  public boolean isSwitch() {\n+    return this.getType() == Token.SWITCH;\n+  }\n+\n   public boolean isThis() {\n     return this.getType() == Token.THIS;\n   }\n \n+  public boolean isThrow() {\n+    return this.getType() == Token.THROW;\n+  }\n+\n+  public boolean isTrue() {\n+    return this.getType() == Token.TRUE;\n+  }\n+\n   public boolean isTry() {\n     return this.getType() == Token.TRY;\n   }\n--- a/test/com/google/javascript/jscomp/CallGraphTest.java\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n \n     assertTrue(mainFunction.isMain());\n     assertNotNull(mainFunction.getBodyNode());\n-    assertTrue(mainFunction.getBodyNode().getType() == Token.BLOCK);\n+    assertTrue(mainFunction.getBodyNode().isBlock());\n \n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n \n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n \n     // Main function's AST node should be the global block\n-    assertTrue(mainFunction.getAstNode().getType() == Token.BLOCK);\n+    assertTrue(mainFunction.getAstNode().isBlock());\n \n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n \n     // Regular function's AST node should be the function for A\n-    assertTrue(functionA.getAstNode().getType() == Token.FUNCTION);\n+    assertTrue(functionA.getAstNode().isFunction());\n     assertEquals(\"A\", NodeUtil.getFunctionName(functionA.getAstNode()));\n   }\n \n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n \n     // Regular function's body node should be the block for A\n-    assertTrue(functionA.getBodyNode().getType() == Token.BLOCK);\n+    assertTrue(functionA.getBodyNode().isBlock());\n     assertEquals(NodeUtil.getFunctionBody(functionA.getAstNode()),\n         functionA.getBodyNode());\n   }\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Callsite callToB = functionA.getCallsitesInFunction().iterator().next();\n \n-    assertTrue(callToB.getAstNode().getType() == Token.CALL);\n+    assertTrue(callToB.getAstNode().isCall());\n   }\n \n   public void testCallsiteGetContainingFunction() {\n \n     for (Callsite callsite : callsites) {\n       Node targetExpressionNode = callsite.getAstNode().getFirstChild();\n-      if (targetExpressionNode.getType() == Token.NAME) {\n+      if (targetExpressionNode.isName()) {\n         result.add(targetExpressionNode.getString());\n       } else {\n         throw new IllegalStateException(\"Called getCallsiteTargetNames() on \" +\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     Node n = parse(\"foo(a);\");\n     assertPrintNode(\"foo(a)\", n);\n     Node call =  n.getFirstChild().getFirstChild();\n-    assertTrue(call.getType() == Token.CALL);\n+    assertTrue(call.isCall());\n     call.putBooleanProp(Node.FREE_CALL, true);\n     assertPrintNode(\"foo(a)\", n);\n   }\n     Node n = parse(\"x.foo(a);\");\n     assertPrintNode(\"x.foo(a)\", n);\n     Node call =  n.getFirstChild().getFirstChild();\n-    assertTrue(call.getType() == Token.CALL);\n+    assertTrue(call.isCall());\n     call.putBooleanProp(Node.FREE_CALL, true);\n     assertPrintNode(\"(0,x.foo)(a)\", n);\n   }\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n     class Find {\n       int found = 0;\n       Node find(Node n) {\n-        if (n.getType() == Token.CALL) {\n+        if (n.isCall()) {\n           Node callee = n.getFirstChild();\n-          if (name == null || (callee.getType() == Token.NAME\n+          if (name == null || (callee.isName()\n               && callee.getString().equals(name))) {\n             found++;\n             if (found == call) {\n--- a/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n import com.google.common.base.Supplier;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import junit.framework.TestCase;\n \n import java.util.Collections;\n   }\n \n   private static Node findCall(Node n, String name) {\n-    if (n.getType() == Token.CALL) {\n+    if (n.isCall()) {\n       Node callee;\n       if (NodeUtil.isGet(n.getFirstChild())) {\n         callee = n.getFirstChild().getFirstChild();\n         Node prop = callee.getNext();\n         // Only \"call\" is support at this point.\n-        Preconditions.checkArgument(prop.getType() == Token.STRING &&\n+        Preconditions.checkArgument(prop.isString() &&\n             prop.getString().equals(\"call\"));\n       } else {\n         callee = n.getFirstChild();\n       }\n \n-      if (callee.getType() == Token.NAME\n+      if (callee.isName()\n           && callee.getString().equals(name)) {\n         return n;\n       }\n   }\n \n   private static Node findFunction(Node n, String name) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (n.getFirstChild().getString().equals(name)) {\n         return n;\n       }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         Node callee;\n         if (NodeUtil.isGet(n.getFirstChild())) {\n           callee = n.getFirstChild().getFirstChild();\n           callee = n.getFirstChild();\n         }\n \n-        if (callee.getType() == Token.NAME &&\n+        if (callee.isName() &&\n             callee.getString().equals(callname)) {\n           complete = method.call(t, n, parent);\n         }\n   }\n \n   private static Node findFunction(Node n, String name) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (n.getFirstChild().getString().equals(name)) {\n         return n;\n       }\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.CALL) {\n+      if (n.isCall()) {\n         Node first = n.getFirstChild();\n-        if (first.getType() == Token.NAME &&\n+        if (first.isName() &&\n             first.getString().equals(callname)) {\n           complete = method.call(t, n, parent);\n         }\n   }\n \n   private static Node findFunction(Node n, String name) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       if (n.getFirstChild().getString().equals(name)) {\n         return n;\n       }\n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n \n   private FlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX(\n       Node node, ControlFlowGraph<Node> cfg) {\n-    if (node.getType() == Token.LABEL) {\n+    if (node.isLabel()) {\n       if (node.getFirstChild().getString().equals(\"X\")) {\n         return cfg.getNode(node.getLastChild()).getAnnotation();\n       }\n--- a/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n+++ b/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import static com.google.javascript.jscomp.MarkNoSideEffectCalls.INVALID_NO_SIDE_EFFECT_ANNOTATION;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Collections;\n import java.util.List;\n \n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NEW) {\n+      if (n.isNew()) {\n         if (!NodeUtil.constructorCallHasSideEffects(n)) {\n           noSideEffectCalls.add(n.getFirstChild().getQualifiedName());\n         }\n-      } else if (n.getType() == Token.CALL) {\n+      } else if (n.isCall()) {\n         if (!NodeUtil.functionCallHasSideEffects(n)) {\n           noSideEffectCalls.add(n.getFirstChild().getQualifiedName());\n         }\n--- a/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n+++ b/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import junit.framework.TestCase;\n \n import java.util.Collection;\n   private class LabelFinder extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.LABEL) {\n+      if (n.isLabel()) {\n         if (n.getFirstChild().getString().equals(\"D\")) {\n           def = n.getLastChild();\n         } else if (n.getFirstChild().getString().startsWith(\"U\")) {\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import junit.framework.TestCase;\n \n /**\n   private class LabelFinder extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.LABEL) {\n+      if (n.isLabel()) {\n         if (n.getFirstChild().getString().equals(\"D\")) {\n           def = n.getLastChild();\n         } else if (n.getFirstChild().getString().equals(\"U\")) {\n--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java\n     boolean found = false;\n     while (searchIt.hasNext()) {\n       Node n = searchIt.next();\n-      if (n.getType() == Token.NAME &&\n-          searchIt.currentParent().getType() == Token.VAR &&\n+      if (n.isName() &&\n+          searchIt.currentParent().isVar() &&\n           n.getString().equals(\"X\")) {\n         found = true;\n         break;\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n   private Node findParentOfFuncDescendant(Node n) {\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (c.getType() == Token.FUNCTION) {\n+      if (c.isFunction()) {\n         return n;\n       }\n       Node result = findParentOfFuncDescendant(c);\n \n   private Node getFuncChild(Node n) {\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (c.getType() == Token.FUNCTION) {\n+      if (c.isFunction()) {\n         return c;\n       }\n     }\n     Node newExpr = getNode(\"new x()\");\n     assertFalse(NodeUtil.evaluatesToLocalValue(newExpr));\n \n-    Preconditions.checkState(newExpr.getType() == Token.NEW);\n+    Preconditions.checkState(newExpr.isNew());\n     Node.SideEffectFlags flags = new Node.SideEffectFlags();\n \n     flags.clearAllFlags();\n     assertTrue(NodeUtil.functionCallHasSideEffects(callExpr));\n \n     Node newExpr = callExpr.getFirstChild().getFirstChild();\n-    Preconditions.checkState(newExpr.getType() == Token.NEW);\n+    Preconditions.checkState(newExpr.isNew());\n     Node.SideEffectFlags flags = new Node.SideEffectFlags();\n \n     // No side effects, local result\n   }\n \n   static Node getFunctionNode(Node n) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n       return n;\n     }\n     for (Node c : n.children()) {\n--- a/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n         new AbstractPeepholeOptimization() {\n       @Override\n       public Node optimizeSubtree(Node node) {\n-        if (node.getType() == Token.NAME) {\n+        if (node.isName()) {\n           visitationLog.add(node.getString() + \"1\");\n         }\n \n         new AbstractPeepholeOptimization() {\n       @Override\n       public Node optimizeSubtree(Node node) {\n-        if (node.getType() == Token.NAME) {\n+        if (node.isName()) {\n           visitationLog.add(node.getString() + \"2\");\n         }\n \n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n-      if (node.getType() == Token.VAR) {\n+      if (node.isVar()) {\n         Set<Node> nodesToRemove = Sets.newHashSet();\n \n         for (Node child : node.children()) {\n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n-      if (node.getType() == Token.NAME && \"x\".equals(node.getString())) {\n+      if (node.isName() && \"x\".equals(node.getString())) {\n         node.getParent().removeChild(node);\n         reportCodeChange();\n \n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n-      if (node.getType() == Token.NAME && \"x\".equals(node.getString())) {\n+      if (node.isName() && \"x\".equals(node.getString())) {\n         Node parent = node.getParent();\n-        if (parent.getType() == Token.VAR) {\n+        if (parent.isVar()) {\n           parent.getParent().removeChild(parent);\n           reportCodeChange();\n           return null;\n   private static class RenameYToX extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n-      if (node.getType() == Token.NAME && \"y\".equals(node.getString())) {\n+      if (node.isName() && \"y\".equals(node.getString())) {\n         Node replacement = Node.newString(Token.NAME, \"x\");\n \n         node.getParent().replaceChild(node, replacement);\n--- a/test/com/google/javascript/jscomp/PrepareAstTest.java\n+++ b/test/com/google/javascript/jscomp/PrepareAstTest.java\n   public void testFreeCall1() throws Exception {\n     Node root = parseExpectedJs(\"foo();\");\n     Node script = root.getFirstChild();\n-    Preconditions.checkState(script.getType() == Token.SCRIPT);\n+    Preconditions.checkState(script.isScript());\n     Node firstExpr = script.getFirstChild();\n     Node call = firstExpr.getFirstChild();\n-    Preconditions.checkState(call.getType() == Token.CALL);\n+    Preconditions.checkState(call.isCall());\n \n     assertTrue(call.getBooleanProp(Node.FREE_CALL));\n   }\n   public void testFreeCall2() throws Exception {\n     Node root = parseExpectedJs(\"x.foo();\");\n     Node script = root.getFirstChild();\n-    Preconditions.checkState(script.getType() == Token.SCRIPT);\n+    Preconditions.checkState(script.isScript());\n     Node firstExpr = script.getFirstChild();\n     Node call = firstExpr.getFirstChild();\n-    Preconditions.checkState(call.getType() == Token.CALL);\n+    Preconditions.checkState(call.isCall());\n \n     assertFalse(call.getBooleanProp(Node.FREE_CALL));\n   }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import static com.google.javascript.jscomp.PureFunctionIdentifier.INVALID_NO_SIDE_EFFECT_ANNOTATION;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n \n /**\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NEW) {\n+      if (n.isNew()) {\n         if (!NodeUtil.constructorCallHasSideEffects(n)) {\n           noSideEffectCalls.add(generateNameString(n.getFirstChild()));\n         }\n-      } else if (n.getType() == Token.CALL) {\n+      } else if (n.isCall()) {\n         if (!NodeUtil.functionCallHasSideEffects(n)) {\n           noSideEffectCalls.add(generateNameString(n.getFirstChild()));\n         }\n     }\n \n     private String generateNameString(Node node) {\n-      if (node.getType() == Token.OR) {\n+      if (node.isOr()) {\n         return \"(\" + generateNameString(node.getFirstChild()) +\n             \" || \" + generateNameString(node.getLastChild()) + \")\";\n-      } else if (node.getType() == Token.HOOK) {\n+      } else if (node.isHook()) {\n         return \"(\" + generateNameString(node.getFirstChild().getNext()) +\n             \" : \" + generateNameString(node.getLastChild()) + \")\";\n       } else {\n         String result = node.getQualifiedName();\n         if (result == null) {\n-          if (node.getType() == Token.FUNCTION) {\n+          if (node.isFunction()) {\n             result = node.toString(false, false, false).trim();\n           } else {\n             result = node.getFirstChild().toString(false, false, false);\n--- a/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.SideEffectsAnalysis.LocationAbstractionMode;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Tests for {@link SideEffectsAnalysis}.\n     }\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.LABEL &&\n+      if (n.isLabel() &&\n           target.equals(n.getFirstChild().getString())) {\n \n         found = n.getLastChild();\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n     testSetupPass = new CompilerPass() {\n \n       void visit(Node n) {\n-        if (n.getType() == Token.NAME\n+        if (n.isName()\n             && !n.getString().isEmpty()\n-            && n.getParent().getType() == Token.FUNCTION) {\n+            && n.getParent().isFunction()) {\n           n.setString(\"\");\n           testcase.getLastCompiler().reportCodeChange();\n         }\n--- a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.VariableVisibilityAnalysis.VariableVisibility;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Tests of {@link VariableVisibilityAnalysis}.\n \n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.getParent().getType() == Token.LP\n+        if (n.getParent().isLP()\n             && parameterName.equals(n.getString())) {\n \n           foundNode[0] = n;\n     }\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.LABEL &&\n+      if (n.isLabel() &&\n           target.equals(n.getFirstChild().getString())) {\n \n         // LABEL\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n       boolean hasBrackets) {\n \n     assertTrue(marker.getType() != null);\n-    assertTrue(marker.getType().getItem().getType() == Token.STRING);\n+    assertTrue(marker.getType().getItem().isString());\n \n     // Match the name and brackets information.\n     String foundName = marker.getType().getItem().getString();", "timestamp": 1320942986, "metainfo": ""}