{"sha": "4d09ce45270187fa65a891e56081960a0ae449e5", "log": "Change on 2010/07/14 14:52:38 by nicksantos          Automated g4 rollback.          *** Reason for rollback ***          breaks contentads          *** Original change description ***          Replace direct references to stripped types with 'void 0'.          R=dcc         DELTA=107  (0 added, 100 deleted, 7 changed)  Change on 2010/07/14 17:36:48 by acleung          Fix GraphColoringTest for future JDK changes.          R=nicksantos         DELTA=7  (0 added, 6 deleted, 1 changed)  Change on 2010/07/14 18:11:13 by johnlenz          Minor cleanup of the CodeConsumer interface.          R=acleung         DELTA=180  (14 added, 128 deleted, 38 changed)  Change on 2010/07/14 18:13:53 by johnlenz          Minor performance improvement for quoted strings that may need to be         escaped.          R=nicksantos         DELTA=1  (0 added, 0 deleted, 1 changed)  Change on 2010/07/14 18:34:27 by pkeslin          Move the Image constructor from deprecated.js to html5 since it seems that         it has been formalized as a part of that spec and is the constructor for         the HTMLImageElement.          R=acleung         DELTA=27  (7 added, 18 deleted, 2 changed)  Change on 2010/07/14 19:11:18 by pkeslin          Automated g4 rollback of changelist 16438831.          *** Reason for rollback ***            Original change breaks the closure build.          *** Original change description ***          Move the Image constructor from deprecated.js to html5 since it seems that         it has been formalized as a part of that spec and is the constructor for         the HTMLImageElement.          R=acleung         DELTA=27  (18 added, 7 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=52001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n    */\n   void endSourceMapping(Node node) {\n   }\n-\n-\n-  /**\n-   * Generates the source map from the given code consumer,\n-   * appending the information it saved to the SourceMap\n-   * object given.\n-   */\n-  void generateSourceMap(SourceMap map){\n-  }\n-\n-  /**\n-   * Returns the current length of the buffer in which\n-   * the generated code is being placed.\n-   */\n-  abstract int getCurrentBufferLength();\n-\n-  /**\n-   * Returns the current character position on the current\n-   * line in the generated code.\n-   */\n-  abstract int getCurrentCharIndex();\n-\n-  /**\n-   * Returns the current line in the generated code.\n-   */\n-  abstract int getCurrentLineIndex();\n \n   /**\n    * Provides a means of interrupting the CodeGenerator. Derived classes should\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n                           String singlequoteEscape,\n                           String backslashEscape,\n                           CharsetEncoder outputCharsetEncoder) {\n-    StringBuilder sb = new StringBuilder();\n+    StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n import com.google.javascript.rhino.Token;\n \n import java.nio.charset.Charset;\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Deque;\n import java.util.List;\n-import java.util.Stack;\n \n /**\n  * CodePrinter prints out js code in either pretty format or compact format.\n \n \n   // There are two separate CodeConsumers, one for pretty-printing and\n-  // another for compact printing.  Both implement the interface\n-  // HasGetCode as CodeConsumer does not have a method for getting the\n-  // formatted string.\n+  // another for compact printing.\n \n   // There are two implementations because the CompactCodePrinter\n   // potentially has a very different implementation to the pretty\n   // version.\n \n-  private interface HasGetCode {\n-    String getCode();\n-  }\n-\n   private abstract static class MappedCodePrinter extends CodeConsumer {\n-    final private Stack<Mapping> mappings;\n+    final private Deque<Mapping> mappings;\n     final private List<Mapping> allMappings;\n     final private boolean createSrcMap;\n-\n-    MappedCodePrinter(boolean createSrcMap) {\n+    protected final StringBuilder code = new StringBuilder(1024);\n+    protected final int lineLengthThreshold;\n+    protected int lineLength = 0;\n+    protected int lineIndex = 0;\n+\n+    MappedCodePrinter(int lineLengthThreshold, boolean createSrcMap) {\n+      this.lineLengthThreshold = lineLengthThreshold;\n       this.createSrcMap = createSrcMap;\n-      this.mappings = createSrcMap ? new Stack<Mapping>() : null;\n+      this.mappings = createSrcMap ? new ArrayDeque<Mapping>() : null;\n       this.allMappings = createSrcMap ? new ArrayList<Mapping>() : null;\n     }\n \n         // If the index is -1, we are not performing any mapping.\n         if (index >= 0) {\n           Preconditions.checkState(\n-              !mappings.empty(), \"Mismatch in start and end of mapping\");\n+              !mappings.isEmpty(), \"Mismatch in start and end of mapping\");\n \n           Mapping mapping = mappings.pop();\n           mapping.end = new Position(line, index);\n      * appending the information it saved to the SourceMap\n      * object given.\n      */\n-    @Override\n     void generateSourceMap(SourceMap map){\n       if (createSrcMap) {\n         for (Mapping mapping : allMappings) {\n      * given position (i.e. a \\n has been inserted there). All mappings in\n      * the source maps after that position will be renormalized as needed.\n      */\n-    void reportLineCut(int lineIndex, int characterPosition) {\n+    void reportLineCut(int lineIndex, int charIndex) {\n       if (createSrcMap) {\n         for (Mapping mapping : allMappings) {\n-          mapping.start = convertPosition(mapping.start, lineIndex,\n-                                          characterPosition);\n+          mapping.start = convertPosition(mapping.start, lineIndex, charIndex);\n \n           if (mapping.end != null) {\n-            mapping.end = convertPosition(mapping.end, lineIndex,\n-                                          characterPosition);\n+            mapping.end = convertPosition(mapping.end, lineIndex, charIndex);\n           }\n         }\n       }\n      */\n     private Position convertPosition(Position position, int lineIndex,\n                                      int characterPosition) {\n-      int pLine = position.getLineNumber();\n-      int pChar = position.getCharacterIndex();\n-\n-      // If the position falls on the line itself, then normalize it\n-      // if it falls at or after the place the newline was inserted.\n-      if (position.getLineNumber() == lineIndex) {\n-        if (position.getCharacterIndex() >= characterPosition) {\n-          pLine++;\n-          pChar -= characterPosition;\n-        }\n-      }\n-\n-      // If the position falls on a line after the newline, increment its\n-      // line index.\n-      if (position.getLineNumber() > lineIndex) {\n-        pLine++;\n-      }\n-\n-      return new Position(pLine, pChar);\n+      int originalLine = position.getLineNumber();\n+      int originalChar = position.getCharacterIndex();\n+      if (originalLine == lineIndex && originalChar >= characterPosition) {\n+        // If the position falls on the line itself, then normalize it\n+        // if it falls at or after the place the newline was inserted.\n+        return new Position(originalLine + 1, originalChar - characterPosition);\n+      } else {\n+        return position;\n+      }\n+    }\n+\n+    public String getCode() {\n+      return code.toString();\n+    }\n+\n+    @Override\n+    char getLastChar() {\n+      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n+    }\n+\n+    protected final int getCurrentCharIndex() {\n+      return lineLength;\n+    }\n+\n+    protected final int getCurrentLineIndex() {\n+      return lineIndex;\n     }\n   }\n \n-  private static class PrettyCodePrinter\n-      extends MappedCodePrinter\n-      implements HasGetCode {\n+  static class PrettyCodePrinter\n+      extends MappedCodePrinter {\n     // The number of characters after which we insert a line break in the code\n     static final String INDENT = \"  \";\n \n-    private final StringBuilder code = new StringBuilder(1024);\n-    private final int lineLengthThreshold;\n     private int indent = 0;\n-    private int lineLength = 0;\n-    private int lineIndex = 0;\n \n     /**\n      * @param lineLengthThreshold The length of a line after which we force\n      */\n     private PrettyCodePrinter(\n         int lineLengthThreshold, boolean createSourceMap) {\n-      super(createSourceMap);\n-      this.lineLengthThreshold = lineLengthThreshold;\n-    }\n-\n-    public String getCode() {\n-      return code.toString();\n-    }\n-\n-    @Override\n-    char getLastChar() {\n-      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n-    }\n-\n-    @Override\n-    int getCurrentBufferLength() {\n-      return code.length();\n-    }\n-\n-    @Override\n-    int getCurrentCharIndex() {\n-      return lineLength;\n-    }\n-\n-    @Override\n-    int getCurrentLineIndex() {\n-      return lineIndex;\n+      super(lineLengthThreshold, createSourceMap);\n     }\n \n     /**\n \n \n   static class CompactCodePrinter\n-      extends MappedCodePrinter\n-      implements HasGetCode {\n+      extends MappedCodePrinter {\n \n     // The CompactCodePrinter tries to emit just enough newlines to stop there\n     // being lines longer than the threshold.  Since the output is going to be\n     // be more uniform than arbitary legal contexts.  Better compression would\n     // probably require explicit modelling of the gzip algorithm.\n \n-    private final StringBuilder code = new StringBuilder(1024);\n-\n     private final boolean lineBreak;\n-    private final int lineLengthThreshold;\n-\n-    private int lineIndex = 0;\n-    private int lineLength = 0;\n     private int lineStartPosition = 0;\n     private int preferredBreakPosition = 0;\n \n    */\n     private CompactCodePrinter(boolean lineBreak, int lineLengthThreshold,\n         boolean createSrcMap) {\n-      super(createSrcMap);\n+      super(lineLengthThreshold, createSrcMap);\n       this.lineBreak = lineBreak;\n-      this.lineLengthThreshold = lineLengthThreshold;\n-    }\n-\n-    public String getCode() {\n-      return code.toString();\n-    }\n-\n-    @Override\n-    char getLastChar() {\n-      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n-    }\n-\n-    @Override\n-    int getCurrentBufferLength() {\n-      return code.length();\n-    }\n-\n-    @Override\n-    int getCurrentCharIndex() {\n-      return lineLength;\n-    }\n-\n-    @Override\n-    int getCurrentLineIndex() {\n-      return lineIndex;\n     }\n \n     /**\n                                  SourceMap sourceMap,\n                                  Charset outputCharset) {\n     boolean createSourceMap = (sourceMap != null);\n-    CodeConsumer cp =\n+    MappedCodePrinter mcp =\n         outputFormat == Format.COMPACT\n         ? new CompactCodePrinter(\n             lineBreak, lineLengthThreshold, createSourceMap)\n         : new PrettyCodePrinter(lineLengthThreshold, createSourceMap);\n     CodeGenerator cg =\n         outputFormat == Format.TYPED\n-        ? new TypedCodeGenerator(cp, outputCharset)\n-        : new CodeGenerator(cp, outputCharset);\n+        ? new TypedCodeGenerator(mcp, outputCharset)\n+        : new CodeGenerator(mcp, outputCharset);\n     cg.add(root);\n \n-    String code = ((HasGetCode) cp).getCode();\n+    String code = mcp.getCode();\n \n     if (createSourceMap) {\n-      cp.generateSourceMap(sourceMap);\n+      mcp.generateSourceMap(sourceMap);\n     }\n \n     return code;\n--- a/src/com/google/javascript/jscomp/InlineCostEstimator.java\n+++ b/src/com/google/javascript/jscomp/InlineCostEstimator.java\n     void addIdentifier(String identifier) {\n       add(ESTIMATED_IDENTIFIER);\n     }\n-\n-    @Override\n-    int getCurrentBufferLength() {\n-      return -1;\n-    }\n-\n-    @Override\n-    int getCurrentCharIndex() {\n-      return -1;\n-    }\n-\n-    @Override\n-    int getCurrentLineIndex() {\n-      return -1;\n-    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n         return -1;\n       }\n     }\n-\n-    @Override\n-    int getCurrentBufferLength() {\n-      return -1;\n-    }\n-\n-    @Override\n-    int getCurrentCharIndex() {\n-      return -1;\n-    }\n-\n-    @Override\n-    int getCurrentLineIndex() {\n-      return -1;\n-    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       \"JSC_STRIP_TYPE_INHERIT_ERROR\",\n       \"Non-strip type {0} cannot inherit from strip type {1}\");\n \n-  static final DiagnosticType STRIP_ASSIGNMENT_ERROR = DiagnosticType.error(\n-      \"JSC_STRIP_ASSIGNMENT_ERROR\",\n-      \"Unable to strip assignment to {0}\");\n   /**\n    * Creates an instance.\n    *\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      // Any additional types added to this switch statement should\n-      // also be added to the guard in\n-      // maybeReplaceDirectReferenceToStrippedType() to prevent\n-      // interference.\n-\n       switch (n.getType()) {\n         case Token.VAR:\n           removeVarDeclarationsByNameOrRvalue(t, n, parent);\n           break;\n \n         case Token.NAME:\n-          if (qualifiedNameBeginsWithStripType(n)) {\n-            maybeReplaceDirectReferenceToStrippedType(t, n);\n-          } else {\n-            maybeRemoveReferenceToRemovedVariable(t, n, parent);\n-          }\n-          break;\n-\n-        case Token.GETPROP:\n-          maybeReplaceDirectReferenceToStrippedType(t, n);\n+          maybeRemoveReferenceToRemovedVariable(t, n, parent);\n           break;\n \n         case Token.ASSIGN:\n       Node lvalue = n.getFirstChild();\n       if (nameEndsWithFieldNameToStrip(lvalue) ||\n           qualifiedNameBeginsWithStripType(lvalue)) {\n-\n-        // Limit to EXPR_RESULT because it is not\n-        // safe to eliminate assignment in complex expressions,\n-        // e.g. in ((x = 7) + 8)\n         if (NodeUtil.isExpressionNode(parent)) {\n           Node gramps = parent.getParent();\n           replaceWithEmpty(parent, gramps);\n-          compiler.reportCodeChange();\n-        }  else {\n-          t.report(n, STRIP_ASSIGNMENT_ERROR, lvalue.getQualifiedName());\n-        }\n+        } else {\n+          replaceWithEmpty(n, parent);\n+        }\n+        compiler.reportCodeChange();\n       }\n     }\n \n           ancestor = ancestor.getParent();\n         }\n         compiler.reportCodeChange();\n-      }\n-    }\n-\n-    /**\n-     * Replaces a reference to a stripped type with 'void 0' when it is safe\n-     * to do so. In particular, we want to avoid stepping on the toes of other\n-     * StripCode methods.\n-     *\n-     * @param t The traversal\n-     * @param n A GETPROP node or NAME node\n-     */\n-    void maybeReplaceDirectReferenceToStrippedType(NodeTraversal t, Node n) {\n-      if (stripTypes.contains(n.getQualifiedName())) {\n-        Node parent = n.getParent();\n-\n-        // Other methods already handle these cases\n-        // and we don't want to interfere with them.\n-        // This guard may need to be updated if additional\n-        // functionality is added to StripCode.\n-        if (NodeUtil.isGet(parent)\n-            || NodeUtil.isCall(parent)\n-            || NodeUtil.isNew(parent)\n-            || NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\n-          return;\n-        }\n-\n-        int parentType = parent.getType();\n-\n-        // Report error if stripping type would result in (void 0)++.\n-        if (parentType == Token.INC || parentType == Token.DEC) {\n-          t.report(n, STRIP_ASSIGNMENT_ERROR, n.getQualifiedName());\n-          return;\n-        }\n-\n-        n.getParent().replaceChild(n, NodeUtil.newUndefinedNode(n));\n-        t.getCompiler().reportCodeChange();\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/StripCodeTest.java\n+++ b/test/com/google/javascript/jscomp/StripCodeTest.java\n   private static final String EXTERNS = \"\";\n \n   public StripCodeTest() {\n-    super(EXTERNS);\n+    super(EXTERNS, false);\n   }\n \n   /**\n         \"goog.debug.Logger\",\n         \"goog.debug.LogManager\",\n         \"goog.debug.LogRecord\",\n-        \"goog.net.BrowserChannel.LogSaver\",\n-        \"TypeWithoutNamespace\");\n+        \"goog.net.BrowserChannel.LogSaver\");\n \n     Set<String> stripNames = Sets.newHashSet(\n         \"logger\",\n          \"  var one = this.logger_(); if (one) foo() }\",\n           \"a=function(){};a.prototype.b=function(){if(null)foo()}\");\n   }\n-\n-  public void testReplaceDirectStrippedTypeReferences() {\n-\n-    // Replace direct references with undefined\n-    test(\"if (goog.debug.Logger != null){foo()}\",\n-         \"if (void 0 != null){foo()}\");\n-\n-    // Test replacement with non-namespaced type\n-    test(\"if (TypeWithoutNamespace != null){foo()}\",\n-         \"if (void 0 != null){foo()}\");\n-\n-    // Replace is fine in RHS of assignment\n-    test(\"if ((x = goog.debug.Logger) != null) {foo()}\",\n-         \"if ((x = void 0) != null) {foo()}\");\n-    test(\"if ((x += goog.debug.Logger) != null) {foo()}\",\n-         \"if ((x += void 0) != null) {foo()}\");\n-  }\n-\n-  public void testReportErrorOnStripTypeInNestedAssignment() {\n-    // Don't replace if stripped type is LHS of assignment\n-    test(\"if ((goog.debug.Logger = bar()) != null) {foo()}\",\n-         \"if ((goog.debug.Logger = bar()) != null) {foo()}\",\n-         StripCode.STRIP_ASSIGNMENT_ERROR);\n-\n-    test(\"if ((goog.debug.Logger += bar()) != null) {foo()}\",\n-         \"if ((goog.debug.Logger += bar()) != null) {foo()}\",\n-         StripCode.STRIP_ASSIGNMENT_ERROR);\n-\n-    // Don't replace if stripped type is in increment/decrement\n-    test(\"if ((goog.debug.Logger++) != null) {foo()}\",\n-         \"if ((goog.debug.Logger++) != null) {foo()}\",\n-         StripCode.STRIP_ASSIGNMENT_ERROR);\n-\n-    test(\"if ((goog.debug.Logger--) != null) {foo()}\",\n-         \"if ((goog.debug.Logger--) != null) {foo()}\",\n-         StripCode.STRIP_ASSIGNMENT_ERROR);\n-  }\n-\n-  public void testReportErrorOnStripNameInNestedAssignment() {\n-    test(\"(foo.logger_ = 7) + 8\",\n-         \"(foo.logger_ = 7) + 8\",\n-         StripCode.STRIP_ASSIGNMENT_ERROR);\n-  }\n }\n--- a/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n \n     Comparator<String> biasD = new Comparator<String>() {\n       public int compare(String o1, String o2) {\n-        if (o1.equals(\"D\")) {\n-          return -1;\n-        } else if (o2.equals(\"D\")) {\n-          return 1;\n-        } else {\n-          return o1.toString().compareTo(o2.toString());\n-        }\n+        return o1.replaceAll(\"D\", \"@\").compareTo(o2.replaceAll(\"D\", \"@\"));\n       }\n     };\n ", "timestamp": 1279224202, "metainfo": ""}