{"sha": "68f2755b2649ad5695cc0739d39aad47c760d3fb", "log": "Added progress reporting capability to JSCompiler. For now it only takes into account parsing and check passes which are the pieces that we care about.  R=nicksantos DELTA=95  (90 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4192   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    * definitions;\n    */\n   abstract CompilerInput getSynthesizedExternsInput();\n+\n+  /**\n+   * @return a number in [0,1] range indicating an approximate progress of the\n+   * last compile. Note this should only be used as a hint and no assumptions\n+   * should be made on accuracy, even a completed compile may choose not to set\n+   * this to 1.0 at the end.\n+   */\n+  public abstract double getProgress();\n+\n+  /** Sets the progress to a certain value in [0,1] range. */\n+  abstract void setProgress(double progress);\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n   private GlobalVarReferenceMap globalRefMap = null;\n \n+  private volatile double progress = 0.0;\n+\n   /**\n    * Creates a Compiler that reports errors and warnings to its logger.\n    */\n   }\n \n   private void compileInternal() {\n+    setProgress(0.0);\n     parse();\n+    // 15 percent of the work is assumed to be for parsing (based on some\n+    // minimal analysis on big JS projects, of course this depends on options)\n+    setProgress(0.15);\n     if (hasErrors()) {\n       return;\n     }\n     if (options.devMode == DevMode.START_AND_END) {\n       runSanityCheck();\n     }\n+    setProgress(1.0);\n   }\n \n   public void parse() {\n   public void check() {\n     runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n \n-    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n+    // We are currently only interested in check-passes for progress reporting\n+    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n+    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n+        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     // unmodified local names.\n     normalize();\n \n-    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n+    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     return synthesizedExternsInput;\n   }\n \n+  @Override\n+  public double getProgress() {\n+    return progress;\n+  }\n+\n+  @Override\n+  void setProgress(double newProgress) {\n+    if (newProgress > 1.0) {\n+      progress = 1.0;\n+    } else if (newProgress < 0.0) {\n+      progress = 0.0;\n+    } else {\n+      progress = newProgress;\n+    }\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   private static final Logger logger =\n       Logger.getLogger(PhaseOptimizer.class.getName());\n \n-  private List<CompilerPass> passes = Lists.newArrayList();\n+  private final List<CompilerPass> passes = Lists.newArrayList();\n \n   private final AbstractCompiler compiler;\n   private final PerformanceTracker tracker;\n   private static boolean randomizeLoops = false;\n   private static List<List<String>> loopsRun = Lists.newArrayList();\n \n-  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker) {\n+  private final ProgressRange progressRange;\n+\n+  /**\n+   * @param compiler the compiler that owns/creates this.\n+   * @param tracker an optional performance tracker\n+   * @param progressRange the progress range for the process function or null\n+   * if progress should not be reported.\n+   */\n+  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker,\n+      ProgressRange progressRange) {\n     this.compiler = compiler;\n     this.tracker = tracker;\n+    this.progressRange = progressRange;\n     compiler.addChangeHandler(recentChange);\n   }\n \n    */\n   @Override\n   public void process(Node externs, Node root) {\n+    double progress = 0.0;\n+    double progressStep = 0.0;\n+    if (progressRange != null) {\n+      progressStep = (progressRange.maxValue - progressRange.initialValue)\n+          / passes.size();\n+      progress = progressRange.initialValue;\n+    }\n     for (CompilerPass pass : passes) {\n       pass.process(externs, root);\n+      if (progressRange != null) {\n+        progress += progressStep;\n+        compiler.setProgress(progress);\n+      }\n       if (hasHaltingErrors()) {\n         return;\n       }\n       myPasses.addAll(optimalPasses);\n     }\n   }\n+\n+  static class ProgressRange {\n+    public final double initialValue;\n+    public final double maxValue;\n+\n+    public ProgressRange(double initialValue, double maxValue) {\n+      this.initialValue = initialValue;\n+      this.maxValue = maxValue;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n     compiler = new Compiler();\n     compiler.initCompilerOptionsIfTesting();\n     tracker = new PerformanceTracker(new Node(Token.BLOCK), false);\n-    optimizer = new PhaseOptimizer(compiler, tracker);\n+    optimizer = new PhaseOptimizer(compiler, tracker, null);\n   }\n \n   public void testOneRun() {\n     }\n     optimizer.process(null, null);\n     assertEquals(PhaseOptimizer.OPTIMAL_ORDER, passesRun);\n+  }\n+\n+  public void testProgress() {\n+    final List<Double> progressList = Lists.newArrayList();\n+    compiler = new Compiler() {\n+      @Override void setProgress(double p) {\n+        progressList.add(p);\n+      }\n+    };\n+    compiler.initCompilerOptionsIfTesting();\n+    optimizer = new PhaseOptimizer(compiler, null,\n+        new PhaseOptimizer.ProgressRange(0, 100));\n+    addOneTimePass(\"x1\");\n+    addOneTimePass(\"x2\");\n+    addOneTimePass(\"x3\");\n+    addOneTimePass(\"x4\");\n+    optimizer.process(null, null);\n+    assertEquals(4, progressList.size());\n+    assertEquals(25, Math.round(progressList.get(0)));\n+    assertEquals(50, Math.round(progressList.get(1)));\n+    assertEquals(75, Math.round(progressList.get(2)));\n+    assertEquals(100, Math.round(progressList.get(3)));\n   }\n \n   public void assertPasses(String ... names) {", "timestamp": 1328721957, "metainfo": ""}