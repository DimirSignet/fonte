{"sha": "9b27f9c5576f0132875c45dbdef55d22f64d5dcb", "log": "Fold simple reference to object literals: {a:1}.a ==> 1  R=acleung DELTA=132  (127 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1255   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Returns true if the shallow scope contains references to 'this' keyword\n    */\n   static boolean referencesThis(Node n) {\n-    return containsType(n, Token.THIS, new MatchNotFunction());\n+    Node start = (isFunction(n)) ? n.getLastChild() : n;\n+    return containsType(start, Token.THIS, new MatchNotFunction());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   private Node tryFoldGetElem(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETELEM);\n \n+    if (left.getType() == Token.OBJECTLIT) {\n+      return tryFoldObjectPropAccess(n, left, right);\n+    }\n+\n     if (left.getType() == Token.ARRAYLIT) {\n       if (right.getType() != Token.NUMBER) {\n         // Sometimes people like to use complex expressions to index into\n    */\n   private Node tryFoldGetProp(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETPROP);\n+\n+    if (left.getType() == Token.OBJECTLIT) {\n+      return tryFoldObjectPropAccess(n, left, right);\n+    }\n \n     if (right.getType() == Token.STRING &&\n         right.getString().equals(\"length\")) {\n \n     return n;\n   }\n+\n+  private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(NodeUtil.isGet(n));\n+\n+    if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) {\n+      return n;\n+    }\n+\n+    Node parent = n.getParent();\n+    if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n+        || parent.getType() == Token.INC\n+        || parent.getType() == Token.DEC) {\n+      // If GETPROP/GETELEM is used as assignment target the object literal is\n+      // acting as a temporary we can't fold it here:\n+      //    \"{a:x}.a += 1\" is not \"x += 1\"\n+      return n;\n+    }\n+\n+    // find the last definition in the object literal\n+    Node key = null;\n+    Node value = null;\n+    for (Node c = left.getFirstChild(); c != null; c = c.getNext()) {\n+      if (c.getString().equals(right.getString())) {\n+        switch (c.getType()) {\n+          case Token.SET:\n+            continue;\n+          case Token.GET:\n+          case Token.STRING:\n+            if (value != null && mayHaveSideEffects(value)) {\n+              // The previously found value had side-effects\n+              return n;\n+            }\n+            key = c;\n+            value = key.getFirstChild();\n+            break;\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      } else if (mayHaveSideEffects(c.getFirstChild())) {\n+        // We don't handle the side-effects here as they might need a temporary\n+        // or need to be reordered.\n+        return n;\n+      }\n+    }\n+\n+    // Didn't find a definition of the name in the object literal, it might\n+    // be coming from the Object prototype\n+    if (value == null) {\n+      return n;\n+    }\n+\n+    if (value.getType() == Token.FUNCTION && NodeUtil.referencesThis(value)) {\n+      // 'this' may refer to the object we are trying to remove\n+      return n;\n+    }\n+\n+    Node replacement = value.detachFromParent();\n+    if (key.getType() == Token.GET){\n+      replacement = new Node(Token.CALL, replacement);\n+    }\n+\n+    n.getParent().replaceChild(n, replacement);\n+    reportCodeChange();\n+    return n;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   public void testReferencesThis() {\n     assertTrue(NodeUtil.referencesThis(\n         parse(\"this\")));\n-    assertTrue(NodeUtil.referencesThis(\n-        parse(\"function foo(){}(this)\")));\n+    // Don't descend into functions (starts at the script node)\n+    assertFalse(NodeUtil.referencesThis(\n+        parse(\"function foo(){this}\")));\n+    // But starting with a function properly check for 'this'\n+    Node n = parse(\"function foo(){this}\").getFirstChild();\n+    assertEquals(n.getType(), Token.FUNCTION);\n+    assertTrue(NodeUtil.referencesThis(n));\n     assertTrue(NodeUtil.referencesThis(\n         parse(\"b?this:null\")));\n \n     assertFalse(NodeUtil.referencesThis(\n         parse(\"a\")));\n-    assertFalse(NodeUtil.referencesThis(\n-        parse(\"function foo(){}\")));\n+    n = parse(\"function foo(){}\").getFirstChild();\n+    assertEquals(n.getType(), Token.FUNCTION);\n+    assertFalse(NodeUtil.referencesThis(n));\n     assertFalse(NodeUtil.referencesThis(\n         parse(\"(b?foo():null)\")));\n   }\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     test(\"(![1])\", \"false\");\n     test(\"(![a])\", \"false\");\n     testSame(\"(![foo()])\");\n+  }\n+\n+  public void testFoldObjectLiteralRef() {\n+    // Leave extra side-effects in place\n+    testSame(\"var x = ({a:foo(),b:bar()}).a\");\n+    testSame(\"var x = ({a:1,b:bar()}).a\");\n+    testSame(\"function f() { return {b:foo(), a:2}.a; }\");\n+\n+    // on the LHS the object act as a temporary leave it in place.\n+    testSame(\"({a:x}).a = 1\");\n+    testSame(\"({a:x}).a += 1\");\n+    testSame(\"({a:x}).a ++\");\n+    testSame(\"({a:x}).a --\");\n+\n+    // functions can't reference the object through 'this'.\n+    testSame(\"({a:function(){return this}}).a\");\n+    testSame(\"({get a() {return this}}).a\");\n+    testSame(\"({set a(b) {return this}}).a\");\n+\n+    // Leave unknown props alone, the might be on the prototype\n+    testSame(\"({}).a\");\n+\n+    // setters by themselves don't provide a definition\n+    testSame(\"({}).a\");\n+    testSame(\"({set a(b) {}}).a\");\n+    // sets don't hide other definitions.\n+    test(\"({a:1,set a(b) {}}).a\", \"1\");\n+\n+    // get is transformed to a call (gets don't have self referential names)\n+    test(\"({get a() {}}).a\", \"(function (){})()\");\n+    // sets don't hide other definitions.\n+    test(\"({get a() {},set a(b) {}}).a\", \"(function (){})()\");\n+\n+    // a function remains a function not a call.\n+    test(\"var x = ({a:function(){return 1}}).a\",\n+         \"var x = function(){return 1}\");\n+\n+    test(\"var x = ({a:1}).a\", \"var x = 1\");\n+    test(\"var x = ({a:1, a:2}).a\", \"var x = 2\");\n+    test(\"var x = ({a:1, a:foo()}).a\", \"var x = foo()\");\n+    test(\"var x = ({a:foo()}).a\", \"var x = foo()\");\n+\n+    test(\"function f() { return {a:1, b:2}.a; }\",\n+         \"function f() { return 1; }\");\n+\n+    // GETELEM is handled the same way.\n+    test(\"var x = ({'a':1})['a']\", \"var x = 1\");\n   }\n \n   public void testIEString() {", "timestamp": 1301954263, "metainfo": ""}