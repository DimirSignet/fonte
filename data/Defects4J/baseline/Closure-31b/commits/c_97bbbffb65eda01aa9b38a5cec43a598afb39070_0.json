{"sha": "97bbbffb65eda01aa9b38a5cec43a598afb39070", "log": "Change on 2010/05/12 by nick          simplify how we build source map paths.          R=joey         DELTA=111  (76 added, 4 deleted, 31 changed)  Change on 2010/05/12 by nick          Use generics magic to clean up the graph code a bit.         These changes don't give the performance improvements that I hoped,         but i think they're good changes anyway.          R=alan         DELTA=253  (69 added, 121 deleted, 63 changed)  Change on 2010/05/12 by nick          API clean-up: don't store null return types or parameter-list types.          R=robert         DELTA=195  (89 added, 54 deleted, 52 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=dzaoho   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n             config.outputWrapperMarker);\n \n         // Output the source map if requested.\n-        outputSourceMap(options, options.jsOutputFile);\n+        outputSourceMap(options);\n       } else {\n         String moduleFilePrefix = config.moduleOutputPathPrefix;\n         maybeCreateDirsForPath(moduleFilePrefix);\n         PrintStream mapOut = null;\n \n         if (!shouldGenerateMapPerModule(options)) {\n-          mapOut = openSourceMapStream(options, moduleFilePrefix);\n+          mapOut = toPrintStream(expandSourceMapPath(options, null));\n         }\n \n         for (JSModule m : modules) {\n           if (shouldGenerateMapPerModule(options)) {\n-            mapOut = openSourceMapStream(\n-                options, moduleFilePrefix + m.getName() + \".js\");\n+            mapOut = toPrintStream(expandSourceMapPath(options, m));\n           }\n \n           PrintStream ps =\n   }\n \n   /**\n-   * Returns a stream to give to an instance of the SourceMap class to which it\n-   * can append the source map. If no source mapping was specified in the\n-   * options, this method returns null.\n-   *\n-   * @param options The options to the Compiler.\n-   * @param path The directory or a file in the directory in which to place the\n-   *        source map.\n-   */\n-  private PrintStream openSourceMapStream(B options, String path)\n-      throws IOException {\n-    if (options.sourceMapOutputPath == null) {\n+   * Expand a file path specified on the command-line.\n+   *\n+   * Most file paths on the command-line allow an %outname% placeholder.\n+   * The placeholder will expand to a different value depending on\n+   * the current output mode. There are three scenarios:\n+   *\n+   * 1) Single js output, single extra output: sub in jsOutputPath.\n+   * 2) Multiple js output, single extra output: sub in the base module name.\n+   * 3) Multiple js output, multiple extra output: sub in the module output file.\n+   *\n+   * Passing a JSModule to this function automatically triggers case #3.\n+   * Otherwise, we'll use strategy #1 or #2 based on the current output mode.\n+   */\n+  private String expandCommandLinePath(\n+      String path, JSModule forModule) {\n+    String sub;\n+    if (forModule != null) {\n+      sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\";\n+    } else if (!config.module.isEmpty()) {\n+      sub = config.moduleOutputPathPrefix;\n+    } else {\n+      sub = config.jsOutputFile;\n+    }\n+    return path.replace(\"%outname%\", sub);\n+  }\n+\n+  /** Expansion function for source map. */\n+  @VisibleForTesting\n+  String expandSourceMapPath(B options, JSModule forModule) {\n+    if (Strings.isEmpty(options.sourceMapOutputPath)) {\n       return null;\n     }\n-\n-    String sourceMapPath = options.sourceMapOutputPath;\n-    sourceMapPath = sourceMapPath.replace(\"%outname%\", path);\n-\n-    String mapPath = null;\n-\n-    if (sourceMapPath.contains(\"/\") || sourceMapPath.contains(\"\\\\\")) {\n-      mapPath = sourceMapPath;\n-    } else {\n-      File outputFile = new File(path);\n-      mapPath = outputFile.getParent() + File.separatorChar + sourceMapPath;\n-    }\n-\n-    return new PrintStream(new FileOutputStream(mapPath));\n+    return expandCommandLinePath(options.sourceMapOutputPath, forModule);\n+  }\n+\n+  /**\n+   * Coverts a file name into a print stream.\n+   * Returns null if the file name is null.\n+   */\n+  private PrintStream toPrintStream(String fileName) throws IOException {\n+    if (fileName == null) {\n+      return null;\n+    }\n+    return new PrintStream(new FileOutputStream(fileName));\n   }\n \n   /**\n    * @param path The path of the generated file for which the source map was\n    *        created.\n    */\n-  private void outputSourceMap(B options, String path)\n+  private void outputSourceMap(B options)\n       throws IOException {\n-    if (options.sourceMapOutputPath == null) {\n+    if (Strings.isEmpty(options.sourceMapOutputPath)) {\n       return;\n     }\n \n-    File outputFile = new File(path);\n-    PrintStream out = openSourceMapStream(options, path);\n-    compiler.getSourceMap().appendTo(out, outputFile.getName());\n+    String outName = expandSourceMapPath(options, null);\n+    PrintStream out = toPrintStream(outName);\n+    compiler.getSourceMap().appendTo(out, outName);\n     out.close();\n   }\n \n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n     // careful when something is exported. Liveness uses bit-vector for live\n     // sets so I don't see compilation time will be a problem for running this\n     // pass in the global scope.\n+    if (t.inGlobalScope()) {\n+      return;\n+    }\n     Scope scope = t.getScope();\n-    if (scope.isGlobal()) {\n-      return;\n-    }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n \n     LiveVariablesAnalysis liveness =\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.Annotation;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     protected void initialize() {\n       orderedWorkSet.clear();\n       for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n-        List<DiGraphEdge<N, Branch>> edgeList =\n-          getCfg().getOutEdges(node.getValue());\n-        int outEdgeCount = edgeList.size();\n+        int outEdgeCount = getCfg().getOutEdges(node.getValue()).size();\n         List<L> outLattices = Lists.newArrayList();\n         for (int i = 0; i < outEdgeCount; i++) {\n           outLattices.add(createInitialEstimateLattice());\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.List;\n \n /**\n  * Removes local variable assignments that are useless based on information from\n    */\n   private void tryRemoveDeadAssignments(NodeTraversal t,\n       ControlFlowGraph<Node> cfg) {\n-    List<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();\n+    Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();\n \n     for (DiGraphNode<Node, Branch> cfgNode : nodes) {\n       FlowState<LiveVariableLattice> state =\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n \n   // This is the key result of the name graph. Given a node in the AST, this map\n   // will give us the Reference edges. For example a CALL node will map to a\n-  // list of possible call edge.\n-  private final Multimap<Node, DiGraphEdge<Name, Reference>>\n+  // list of possible call edge destinations.\n+  private final Multimap<Node, Name>\n       referenceMap = HashMultimap.create();\n \n   // Given a qualified name, provides the Name object.\n     Preconditions.checkArgument(\n         NodeUtil.isGetProp(site) || NodeUtil.isName(site));\n     List<Name> result = new ArrayList<Name>();\n-    for (DiGraphEdge<Name, Reference> edge : referenceMap.get(site)) {\n-      Name target = edge.getDestination().getValue();\n+    for (Name target : referenceMap.get(site)) {\n       result.add(target);\n     }\n     return result;\n   }\n \n   @Override\n-  public GraphEdge<Name, Reference> connect(Name src, Reference ref,\n-      Name dest) {\n-    GraphEdge<Name, Reference> edge = super.connect(src, ref, dest);\n-    referenceMap.put(ref.site, (DiGraphEdge<Name, Reference>) edge);\n-    return edge;\n+  public void connect(Name src, Reference ref, Name dest) {\n+    super.connect(src, ref, dest);\n+    referenceMap.put(ref.site, dest);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/graph/AdjacencyGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/AdjacencyGraph.java\n \n package com.google.javascript.jscomp.graph;\n \n-import java.util.List;\n+import java.util.Collection;\n \n /**\n  * A minimal graph interface.  Provided is add nodes to the graph, adjacency\n  * @see Graph\n  */\n public interface AdjacencyGraph<N, E> {\n-  /** Gets a mutable list of all nodes. */\n-  List<GraphNode<N, E>> getNodes();\n+  /** Gets an immutable list of all nodes. */\n+  Collection<GraphNode<N, E>> getNodes();\n \n   /**\n    * Gets a node from the graph given a value. Values equality are compared\n--- a/src/com/google/javascript/jscomp/graph/DiGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/DiGraph.java\n  */\n public abstract class DiGraph<N, E> extends Graph<N, E> {\n \n-  public abstract List<DiGraphNode<N, E>> getDirectedGraphNodes();\n+  /**\n+   * Gets an immutable iterable over all the nodes in the graph.\n+   */\n+  public abstract Iterable<DiGraphNode<N, E>> getDirectedGraphNodes();\n \n+  /**\n+   * Gets an immutable list of out edges of the given node.\n+   */\n   public abstract List<DiGraphEdge<N, E>> getOutEdges(N nodeValue);\n \n+  /**\n+   * Gets an immutable list of in edges of the given node.\n+   */\n   public abstract List<DiGraphEdge<N, E>> getInEdges(N nodeValue);\n \n   public abstract List<DiGraphNode<N, E>> getDirectedPredNodes(\n    */\n   public abstract boolean isConnectedInDirection(N n1, E edgeValue, N n2);\n \n+  @Override\n+  public boolean isConnected(N n1, N n2) {\n+    return isConnectedInDirection(n1, n2) || isConnectedInDirection(n2, n1);\n+  }\n+\n+  @Override\n+  public boolean isConnected(N n1, E e, N n2) {\n+    return isConnectedInDirection(n1, e, n2) ||\n+        isConnectedInDirection(n2, e, n1);\n+  }\n \n   /**\n    * A generic directed graph node.\n--- a/src/com/google/javascript/jscomp/graph/Graph.java\n+++ b/src/com/google/javascript/jscomp/graph/Graph.java\n    * @param n1 First node.\n    * @param edge The edge.\n    * @param n2 Second node.\n-   * @return The newly created graph edge.\n-   */\n-  public abstract GraphEdge<N, E> connect(N n1, E edge, N n2);\n+   */\n+  public abstract void connect(N n1, E edge, N n2);\n \n   /**\n    * Disconnects two nodes in the graph by removing all edges between them.\n    * @param n2 Second node.\n    */\n   public final void connectIfNotFound(N n1, E edge, N n2) {\n-    GraphNode<N, E> node1 = getNode(n1);\n-    GraphNode<N, E> node2 = getNode(n2);\n-    if (node1 == null) {\n-      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n-    }\n-    if (node2 == null) {\n-      throw new IllegalArgumentException(n2 + \" does not exist in graph\");\n-    }\n-    List<GraphEdge<N, E>> edgeList = getEdges(n1, n2);\n-    for (GraphEdge<N, E> e : edgeList) {\n-      // Check == first to short circuit nulls.\n-      if (e.getValue() == edge || e.getValue().equals(edge)) {\n-        return;\n-      }\n-    }\n-    connect(n1, edge, n2);\n+    if (!isConnected(n1, edge, n2)) {\n+      connect(n1, edge, n2);\n+    }\n   }\n \n   /**\n    */\n   public abstract GraphNode<N, E> createNode(N value);\n \n-  /** Gets a mutable list of all nodes. */\n-  public abstract List<GraphNode<N, E>> getNodes();\n-\n-  /** Gets a mutable list of all edges. */\n+  /** Gets an immutable list of all nodes. */\n+  public abstract Collection<GraphNode<N, E>> getNodes();\n+\n+  /** Gets an immutable list of all edges. */\n   public abstract List<GraphEdge<N, E>> getEdges();\n \n   /**\n    * @return <code>true</code> if the two nodes are connected.\n    */\n   public abstract boolean isConnected(N n1, N n2);\n+\n+  /**\n+   * Checks whether two nodes in the graph are connected by the given\n+   * edge type.\n+   *\n+   * @param n1 Node 1.\n+   * @param e The edge type.\n+   * @param n2 Node 2.\n+   */\n+  public abstract boolean isConnected(N n1, E e, N n2);\n+\n+  /**\n+   * Gets the node of the specified type, or throws an\n+   * IllegalArgumentException.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n+    T node = (T) getNode(val);\n+    if (node == null) {\n+      throw new IllegalArgumentException(val + \" does not exist in graph\");\n+    }\n+    return node;\n+  }\n \n   public final void clearNodeAnnotations() {\n     for (GraphNode<N, E> n : getNodes()) {\n     }\n \n     public void addNode(N value) {\n-      if (!graph.hasNode(value)) {\n-        throw new IllegalArgumentException(value + \" does not exist in graph\");\n-      }\n-      nodes.add(graph.getNode(value));\n+      nodes.add(graph.getNodeOrFail(value));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/graph/GraphColoring.java\n+++ b/src/com/google/javascript/jscomp/graph/GraphColoring.java\n     @Override\n     public int color() {\n       graph.clearNodeAnnotations();\n-      List<GraphNode<N, E>> worklist = graph.getNodes();\n+      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n \n       // Sort nodes by degree.\n       Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n               tieBreaker.compare(o1.getValue(), o2.getValue()) : result;\n         }\n       });\n-      worklist = Lists.newLinkedList(worklist);\n \n       // Idea: From the highest to lowest degree, assign any uncolored node with\n       // a unique color if none of its neighbor has been assigned that color.\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n   }\n \n   @Override\n-  public GraphEdge<N, E> connect(N srcValue, E edgeValue, N destValue) {\n-    DiGraphNode<N, E> node = getDirectedGraphNode(srcValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          srcValue + \" does not exist in graph\");\n-    }\n-    LinkedDirectedGraphNode<N, E> src = (LinkedDirectedGraphNode<N, E>) node;\n-    node = getDirectedGraphNode(destValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          destValue + \" does not exist in graph\");\n-    }\n-    LinkedDirectedGraphNode<N, E> dest = (LinkedDirectedGraphNode<N, E>) node;\n+  public void connect(N srcValue, E edgeValue, N destValue) {\n+    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n+    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n     LinkedDirectedGraphEdge<N, E> edge =\n         new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n     src.getOutEdges().add(edge);\n     dest.getInEdges().add(edge);\n-    return edge;\n   }\n \n   @Override\n     disconnectInDirection(n1, n2);\n     disconnectInDirection(n2, n1);\n   }\n-  \n+\n   @Override\n   public void disconnectInDirection(N srcValue, N destValue) {\n-    DiGraphNode<N, E> node = getDirectedGraphNode(srcValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          srcValue + \" does not exist in graph\");\n-    }\n-    LinkedDirectedGraphNode<N, E> src = (LinkedDirectedGraphNode<N, E>) node;\n-    node = getDirectedGraphNode(destValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          destValue + \" does not exist in graph\");\n-    }\n-    LinkedDirectedGraphNode<N, E> dest = (LinkedDirectedGraphNode<N, E>) node;\n+    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n+    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n     for (DiGraphEdge<?, E> edge : getDirectedGraphEdges(srcValue, destValue)) {\n       src.getOutEdges().remove(edge);\n       dest.getInEdges().remove(edge);\n   }\n \n   @Override\n-  public List<DiGraphNode<N, E>> getDirectedGraphNodes() {\n-    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n-    nodeList.addAll(nodes.values());\n-    return nodeList;\n+  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n+    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n+        nodes.values());\n   }\n \n   @Override\n \n   @Override\n   public List<DiGraphEdge<N, E>> getInEdges(N nodeValue) {\n-    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          nodeValue + \" does not exist in graph\");\n-    }\n-    List<DiGraphEdge<N, E>> edgeList = Lists.newArrayList();\n-    for (DiGraphEdge<N, E> edge : node.getInEdges()) {\n-      edgeList.add(edge);\n-    }\n-\n-    return edgeList;\n+    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n+    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getInEdges());\n   }\n \n   @Override\n   public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n-    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          nodeValue + \" does not exist in graph\");\n-    }\n-    List<DiGraphEdge<N, E>> edgeList = Lists.newArrayList();\n-    for (DiGraphEdge<N, E> edge : node.getOutEdges()) {\n-      edgeList.add(edge);\n-    }\n-    return edgeList;\n+    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n+    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n   }\n \n   @Override\n \n   @Override\n   public List<DiGraphEdge<N, E>> getDirectedGraphEdges(N n1, N n2) {\n-    DiGraphNode<N, E> dNode1 = nodes.get(n1);\n-    if (dNode1 == null) {\n-      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n-    }\n-    DiGraphNode<N, E> dNode2 = nodes.get(n2);\n-    if (dNode2 == null) {\n-      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n-    }\n+    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n+    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n     List<DiGraphEdge<N, E>> edges = Lists.newArrayList();\n     for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n       if (outEdge.getDestination() == dNode2) {\n \n   private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n     // Verify the nodes.\n-    DiGraphNode<N, E> dNode1 = nodes.get(n1);\n-    if (dNode1 == null) {\n-      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n-    }\n-    DiGraphNode<N, E> dNode2 = nodes.get(n2);\n-    if (dNode2 == null) {\n-      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n-    }\n-\n+    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n+    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n     for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n       if (outEdge.getDestination() == dNode2 &&\n           edgeMatcher.apply(outEdge.getValue())) {\n       nodeList.add(edge.getDestination());\n     }\n     return nodeList;\n-  }\n-\n-  @Override\n-  public boolean isConnected(N n1, N n2) {\n-    return isConnectedInDirection(n1, n2) || isConnectedInDirection(n2, n1);\n   }\n \n   @Override\n   }\n \n   @Override\n-  public List<GraphNode<N, E>> getNodes() {\n-    List<GraphNode<N, E>> list = Lists.newArrayList();\n-    list.addAll(nodes.values());\n-    return list;\n+  public Collection<GraphNode<N, E>> getNodes() {\n+    return Collections.<GraphNode<N, E>>unmodifiableCollection(nodes.values());\n   }\n \n   @Override\n     Preconditions.checkNotNull(node);\n     return node.neighborIterator();\n   }\n-  \n+\n   @Override\n   public List<GraphEdge<N, E>> getEdges() {\n     List<GraphEdge<N, E>> result = Lists.newArrayList();\n         result.add(edge);\n       }\n     }\n-    return result;\n+    return Collections.unmodifiableList(result);\n   }\n \n   @Override\n   public int getNodeDegree(N value) {\n-    DiGraphNode<N, E> node = getDirectedGraphNode(value);\n-    if (node == null) {\n-      throw new IllegalArgumentException(value + \" not found in graph\");\n-    }\n+    DiGraphNode<N, E> node = getNodeOrFail(value);\n     return node.getInEdges().size() + node.getOutEdges().size();\n   }\n \n   static class LinkedDirectedGraphNode<N, E> implements DiGraphNode<N, E>,\n       GraphvizNode {\n \n-    protected List<DiGraphEdge<N, E>> inEdgeList = Lists.newArrayList();\n-    protected List<DiGraphEdge<N, E>> outEdgeList =\n+    List<DiGraphEdge<N, E>> inEdgeList = Lists.newArrayList();\n+    List<DiGraphEdge<N, E>> outEdgeList =\n         Lists.newArrayList();\n \n     protected final N value;\n      *\n      * @param nodeValue Node's value.\n      */\n-    public LinkedDirectedGraphNode(N nodeValue) {\n+    LinkedDirectedGraphNode(N nodeValue) {\n       this.value = nodeValue;\n       this.id = totalNodes++;\n     }\n     public List<DiGraphEdge<N, E>> getOutEdges() {\n       return outEdgeList;\n     }\n-    \n+\n     private Iterator<GraphNode<N, E>> neighborIterator() {\n       return new NeighborIterator();\n     }\n-    \n+\n     private class NeighborIterator implements Iterator<GraphNode<N, E>> {\n-      \n+\n       private final Iterator<DiGraphEdge<N, E>> in = inEdgeList.iterator();\n       private final Iterator<DiGraphEdge<N, E>> out = outEdgeList.iterator();\n \n      *\n      * @param edgeValue Edge Value.\n      */\n-    public LinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n+    LinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n         E edgeValue, DiGraphNode<N, E> destNode) {\n       this.value = edgeValue;\n       this.sourceNode = sourceNode;\n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n package com.google.javascript.jscomp.graph;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n   }\n \n   @Override\n-  public GraphEdge<N, E> connect(N srcValue, E edgeValue, N destValue) {\n-    UndiGraphNode<N, E> node = getUndirectedGraphNode(srcValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          srcValue + \" does not exist in graph\");\n-    }\n-    LinkedUndirectedGraphNode<N, E> src =\n-        (LinkedUndirectedGraphNode<N, E>) node;\n-    node = getUndirectedGraphNode(destValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          destValue + \" does not exist in graph\");\n-    }\n-    LinkedUndirectedGraphNode<N, E> dest =\n-        (LinkedUndirectedGraphNode<N, E>) node;\n+  public void connect(N srcValue, E edgeValue, N destValue) {\n+    LinkedUndirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n+    LinkedUndirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n     LinkedUndirectedGraphEdge<N, E> edge =\n         new LinkedUndirectedGraphEdge<N, E>(src, edgeValue, dest);\n     src.getNeighborEdges().add(edge);\n     dest.getNeighborEdges().add(edge);\n-    return edge;\n   }\n \n   @Override\n   public void disconnect(N srcValue, N destValue) {\n-    UndiGraphNode<N, E> node = getUndirectedGraphNode(srcValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          srcValue + \" does not exist in graph\");\n-    }\n-    LinkedUndirectedGraphNode<N, E> src = \n-      (LinkedUndirectedGraphNode<N, E>) node;\n-    node = getUndirectedGraphNode(destValue);\n-    if (node == null) {\n-      throw new IllegalArgumentException(\n-          destValue + \" does not exist in graph\");\n-    }\n-    LinkedUndirectedGraphNode<N, E> dest = \n-      (LinkedUndirectedGraphNode<N, E>) node;\n-\n-    for (UndiGraphEdge<N, E> edge : \n+    LinkedUndirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n+    LinkedUndirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n+    for (UndiGraphEdge<N, E> edge :\n       getUndirectedGraphEdges(srcValue, destValue)) {\n       src.getNeighborEdges().remove(edge);\n       dest.getNeighborEdges().remove(edge);\n     }\n     return nodeList;\n   }\n-  \n+\n   @Override\n   public Iterator<GraphNode<N, E>> getNeighborNodesIterator(N value) {\n     UndiGraphNode<N, E> uNode = getUndirectedGraphNode(value);\n   }\n \n   @Override\n-  public List<UndiGraphNode<N, E>> getUndirectedGraphNodes() {\n-    List<UndiGraphNode<N, E>> nodeList = Lists.newArrayList();\n-    nodeList.addAll(nodes.values());\n-    return nodeList;\n+  public Collection<UndiGraphNode<N, E>> getUndirectedGraphNodes() {\n+    return Collections.<UndiGraphNode<N, E>>unmodifiableCollection(\n+        nodes.values());\n   }\n \n   @Override\n \n   @Override\n   public List<GraphEdge<N, E>> getEdges(N n1, N n2) {\n-    List<GraphEdge<N, E>> result = Lists.newArrayList();\n-    result.addAll(getUndirectedGraphEdges(n1, n2));\n-    return result;\n+    return Collections.<GraphEdge<N, E>>unmodifiableList(\n+        getUndirectedGraphEdges(n1, n2));\n   }\n \n   @Override\n \n   @Override\n   public boolean isConnected(N n1, N n2) {\n+    return isConnected(n1, Predicates.<E>alwaysTrue(), n2);\n+  }\n+\n+  @Override\n+  public boolean isConnected(N n1, E e, N n2) {\n+    return isConnected(n1, Predicates.<E>equalTo(e), n2);\n+  }\n+\n+  private boolean isConnected(N n1, Predicate<E> edgePredicate, N n2) {\n     UndiGraphNode<N, E> dNode1 = nodes.get(n1);\n     if (dNode1 == null) {\n       return false;\n     for (UndiGraphEdge<N, E> outEdge : dNode1.getNeighborEdges()) {\n       if ((outEdge.getNodeA() == dNode1 && outEdge.getNodeB() == dNode2) ||\n           (outEdge.getNodeA() == dNode2 && outEdge.getNodeB() == dNode1)) {\n-        return true;\n+        if (edgePredicate.apply(outEdge.getValue())) {\n+          return true;\n+        }\n       }\n     }\n     return false;\n   }\n \n   @Override\n-  public List<GraphNode<N, E>> getNodes() {\n-    List<GraphNode<N, E>> list = Lists.newArrayList();\n-    list.addAll(nodes.values());\n-    return list;\n+  public Collection<GraphNode<N, E>> getNodes() {\n+    return Collections.<GraphNode<N, E>> unmodifiableCollection(nodes.values());\n   }\n \n   @SuppressWarnings(\"unchecked\")\n     }\n     return uNode.getNeighborEdges().size();\n   }\n-  \n+\n   /**\n    * An undirected graph node that stores outgoing edges and incoming edges as\n    * an list within the node itself.\n     public String getLabel() {\n       return value != null ? value.toString() : \"null\";\n     }\n-    \n+\n     public Iterator<GraphNode<N, E>> neighborIterator() {\n       return new NeighborIterator();\n     }\n \n     private class NeighborIterator implements Iterator<GraphNode<N, E>> {\n-      \n+\n       private final Iterator<UndiGraphEdge<N, E>> edgeIterator =\n           neighborList.iterator();\n \n       }\n     }\n   }\n-  \n+\n   /**\n    * An undirected graph edge that stores two nodes at each edge.\n    */\n     }\n   }\n }\n-\n--- a/src/com/google/javascript/jscomp/graph/UndiGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/UndiGraph.java\n \n package com.google.javascript.jscomp.graph;\n \n+import java.util.Collection;\n import java.util.List;\n \n /**\n  */\n public abstract class UndiGraph<N, E> extends Graph<N, E> {\n \n-  abstract List<UndiGraphNode<N, E>> getUndirectedGraphNodes();\n+  /**\n+   * Gets an immutable collection of all the nodes in this graph.\n+   */\n+  abstract Collection<UndiGraphNode<N, E>> getUndirectedGraphNodes();\n \n   abstract UndiGraphNode<N, E> createUndirectedGraphNode(N nodeValue);\n \n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n  * ***** END LICENSE BLOCK ***** */\n \n package com.google.javascript.rhino.jstype;\n+\n+import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n   ArrowType(JSTypeRegistry registry, Node parameters,\n       JSType returnType) {\n     super(registry);\n-    this.parameters = parameters;\n-    this.returnType = returnType;\n+\n+    this.parameters = parameters == null ?\n+        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n+        parameters;\n+    this.returnType = returnType == null ?\n+        getNativeType(UNKNOWN_TYPE) : returnType;\n   }\n \n   @Override\n     ArrowType that = (ArrowType) other;\n \n     // this.returnType <: that.returnType (covariant)\n-    // If the return type is null, this is equivalent to unknown so we do not\n-    // base our decision on that.\n-    if (this.returnType != null &&\n-        that.returnType != null &&\n-        !this.returnType.isSubtype(that.returnType)) {\n+    if (!this.returnType.isSubtype(that.returnType)) {\n       return false;\n     }\n     // that.paramType[i] <: this.paramType[i] (contravariant)\n     // TODO(nicksantos): This is incorrect. It should be invariant.\n     // Follow up with closure team on how to fix this without everyone\n     // hating on us.\n+    Node thisParam = parameters.getFirstChild();\n+    Node thatParam = that.parameters.getFirstChild();\n+    while (thisParam != null && thatParam != null) {\n+      JSType thisParamType = thisParam.getJSType();\n+      if (thisParamType != null) {\n+        JSType thatParamType = thatParam.getJSType();\n+        if (thatParamType == null ||\n+            !thatParamType.isSubtype(thisParamType)) {\n+          return false;\n+        }\n+      }\n+      boolean thisIsVarArgs = thisParam.isVarArgs();\n+      boolean thatIsVarArgs = thatParam.isVarArgs();\n+      // don't advance if we have variable arguments\n+      if (!thisIsVarArgs) {\n+        thisParam = thisParam.getNext();\n+      }\n+      if (!thatIsVarArgs) {\n+        thatParam = thatParam.getNext();\n+      }\n+      // both var_args indicates the end\n+      if (thisIsVarArgs && thatIsVarArgs) {\n+        thisParam = null;\n+        thatParam = null;\n+      }\n+    }\n+\n+    // Right now, the parser's type system doesn't have a good way\n+    // to model optional arguments.\n     //\n-    // If the parameter list is null, this is equivalent of ?... so we do not\n-    // base our decision on that.\n-    if (this.parameters != null && that.parameters != null) {\n-      Node thisParam = parameters.getFirstChild();\n-      Node thatParam = that.parameters.getFirstChild();\n-      while (thisParam != null && thatParam != null) {\n-        JSType thisParamType = thisParam.getJSType();\n-        if (thisParamType != null) {\n-          JSType thatParamType = thatParam.getJSType();\n-          if (thatParamType == null ||\n-              !thatParamType.isSubtype(thisParamType)) {\n-            return false;\n-          }\n-        }\n-        boolean thisIsVarArgs = thisParam.isVarArgs();\n-        boolean thatIsVarArgs = thatParam.isVarArgs();\n-        // don't advance if we have variable arguments\n-        if (!thisIsVarArgs) {\n-          thisParam = thisParam.getNext();\n-        }\n-        if (!thatIsVarArgs) {\n-          thatParam = thatParam.getNext();\n-        }\n-        // both var_args indicates the end\n-        if (thisIsVarArgs && thatIsVarArgs) {\n-          thisParam = null;\n-          thatParam = null;\n-        }\n-      }\n-\n-      // Right now, the parser's type system doesn't have a good way\n-      // to model optional arguments.\n-      //\n-      // Suppose we have\n-      // function f(number, number) {}\n-      // function g(number) {}\n-      // If the second arg of f is optional, then f is a subtype of g,\n-      // but g is not a subtype of f.\n-      // If the second arg of f is required, then g is a subtype of f,\n-      // but f is not a subtype of g.\n-      //\n-      // Until we model optional params, let's just punt on this.\n-      // If one type has more arguments than the other, we won't check them.\n-      //\n-      // NOTE(nicksantos): This is described in Draft 2 of the ES4 spec,\n-      // Section 3.4.6: Subtyping Function Types. It seems really\n-      // strange but I haven't thought a lot about the implementation.\n-    }\n-\n+    // Suppose we have\n+    // function f(number, number) {}\n+    // function g(number) {}\n+    // If the second arg of f is optional, then f is a subtype of g,\n+    // but g is not a subtype of f.\n+    // If the second arg of f is required, then g is a subtype of f,\n+    // but f is not a subtype of g.\n+    //\n+    // Until we model optional params, let's just punt on this.\n+    // If one type has more arguments than the other, we won't check them.\n+    //\n+    // NOTE(nicksantos): This is described in Draft 2 of the ES4 spec,\n+    // Section 3.4.6: Subtyping Function Types. It seems really\n+    // strange but I haven't thought a lot about the implementation.\n     return true;\n   }\n \n       return false;\n     }\n     ArrowType that = (ArrowType) object;\n-    // if both return types are specified, then they should be equal\n-    if (returnType == null) {\n-      if (that.returnType != null) {\n-        return false;\n-      }\n-    } else {\n-      if (that.returnType == null) {\n-        return false;\n-      }\n-      if (!returnType.equals(that.returnType)) {\n-        return false;\n-      }\n-    }\n-    // if both types include parameters, the lists should be the same\n-    if (parameters == null) {\n-      return that.parameters == null;\n-    } else if (that.parameters == null) {\n-      return false;\n-    }\n+    if (!returnType.equals(that.returnType)) {\n+      return false;\n+    }\n+\n     Node thisParam = parameters.getFirstChild();\n     Node otherParam = that.parameters.getFirstChild();\n     while (thisParam != null && otherParam != null) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n public class CommandLineRunnerTest extends TestCase {\n \n   private Compiler lastCompiler = null;\n+  private CommandLineRunner lastCommandLineRunner = null;\n \n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n            \"\"\n          },\n          RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n+  public void testSourceMapExpansion1() {\n+    args.add(\"--create_source_map=%outname%.map\");\n+    testSame(\"var x = 3;\");\n+    assertEquals(\"/path/to/out.js.map\",\n+        lastCommandLineRunner.expandSourceMapPath(\n+            lastCompiler.getOptions(), null));\n+  }\n+\n+  public void testSourceMapExpansion2() {\n+    useModules = true;\n+    args.add(\"--create_source_map=%outname%.map\");\n+    args.add(\"--module_output_path_prefix=foo\");\n+    testSame(new String[] {\"var x = 3;\", \"var y = 5;\"});\n+    assertEquals(\"foo.map\",\n+        lastCommandLineRunner.expandSourceMapPath(\n+            lastCompiler.getOptions(), null));\n+  }\n+\n+  public void testSourceMapExpansion3() {\n+    useModules = true;\n+    args.add(\"--create_source_map=%outname%.map\");\n+    args.add(\"--module_output_path_prefix=foo_\");\n+    testSame(new String[] {\"var x = 3;\", \"var y = 5;\"});\n+    assertEquals(\"foo_m0.js.map\",\n+        lastCommandLineRunner.expandSourceMapPath(\n+            lastCompiler.getOptions(),\n+            lastCompiler.getModuleGraph().getRootModule()));\n   }\n \n   /* Helper functions */\n   }\n \n   private Compiler compile(String[] original) {\n+    args.add(\"--js_output_file\");\n+    args.add(\"/path/to/out.js\");\n+\n+    for (int i = 0; i < original.length; i++) {\n+      args.add(\"--js\");\n+      args.add(\"/path/to/input\" + i + \".js\");\n+      if (useModules) {\n+        args.add(\"--module\");\n+        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n+      }\n+    }\n+\n     String[] argStrings = args.toArray(new String[] {});\n     CommandLineRunner runner = new CommandLineRunner(argStrings);\n     Compiler compiler = runner.createCompiler();\n+    lastCommandLineRunner = runner;\n     lastCompiler = compiler;\n     CompilerOptions options = runner.createOptions();\n     try {\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n    */\n   private void assertNodeOrder(ControlFlowGraph<Node> cfg,\n       List<Integer> nodeTypes) {\n-    List<DiGraphNode<Node, Branch>> cfgNodes = cfg.getDirectedGraphNodes();\n+    List<DiGraphNode<Node, Branch>> cfgNodes =\n+        Lists.newArrayList(cfg.getDirectedGraphNodes());\n     Collections.sort(cfgNodes, cfg.getOptionalNodeComparator(true));\n \n     // IMPLICIT RETURN must always be last.\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+\n+/**\n+ * Tests for FunctionTypes.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class FunctionTypeTest extends BaseJSTypeTestCase {\n+  public void testDefaultReturnType() {\n+    FunctionType f = new FunctionBuilder(registry).build();\n+    assertEquals(UNKNOWN_TYPE, f.getReturnType());\n+  }\n+}", "timestamp": 1273772777, "metainfo": ""}