{"sha": "56ba368f5c6a20cb31654f75ac8bda63d24f4842", "log": "Fixed generation of long random numbers between two bounds.  We now directly use discrete raw values to build the int/double instead of relying on floating point arithmetic.  JIRA: MATH-936  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n     }\n \n     /**\n+     * Returns a pseudorandom, uniformly distributed <tt>long</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.\n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>long</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    public long nextLong(long n) throws IllegalArgumentException {\n+        if (n > 0) {\n+            long bits;\n+            long val;\n+            do {\n+                bits = ((long) next(31)) << 32;\n+                bits = bits | (((long) next(32)) & 0xffffffffL);\n+                val  = bits % n;\n+            } while (bits - val + (n - 1) < 0);\n+            return val;\n+        }\n+        throw new NotStrictlyPositiveException(n);\n+    }\n+\n+    /**\n      * Clears the cache used by the default implementation of\n      * {@link #nextGaussian}.\n      */\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n     }\n \n     /** {@inheritDoc} */\n-    public int nextInt(int lower, int upper) throws NumberIsTooLargeException {\n+    public int nextInt(final int lower, final int upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n-        double r = getRan().nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (int) FastMath.floor(scaled);\n+        final int max = (upper - lower) + 1;\n+        if (max <= 0) {\n+            // the range is too wide to fit in a positive int (larger than 2^31); as it covers\n+            // more than half the integer range, we use directly a simple rejection method\n+            final RandomGenerator rng = getRan();\n+            while (true) {\n+                final int r = rng.nextInt();\n+                if (r >= lower && r <= upper) {\n+                    return r;\n+                }\n+            }\n+        } else {\n+            // we can shift the range and generate directly a positive int\n+            return lower + getRan().nextInt(max);\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    public long nextLong(long lower, long upper) throws NumberIsTooLargeException {\n+    public long nextLong(final long lower, final long upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n-        double r = getRan().nextDouble();\n-        double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (long)FastMath.floor(scaled);\n+        final long max = (upper - lower) + 1;\n+        if (max <= 0) {\n+            // the range is too wide to fit in a positive long (larger than 2^63); as it covers\n+            // more than half the long range, we use directly a simple rejection method\n+            final RandomGenerator rng = getRan();\n+            while (true) {\n+                final long r = rng.nextLong();\n+                if (r >= lower && r <= upper) {\n+                    return r;\n+                }\n+            }\n+        } else if (max < Integer.MAX_VALUE){\n+            // we can shift the range and generate directly a positive int\n+            return lower + getRan().nextInt((int) max);\n+        } else {\n+            // we can shift the range and generate directly a positive long\n+            return lower + nextLong(getRan(), max);\n+        }\n+    }\n+\n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>long</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.\n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>long</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    private static long nextLong(final RandomGenerator rng, final long n) throws IllegalArgumentException {\n+        if (n > 0) {\n+            final byte[] byteArray = new byte[8];\n+            long bits;\n+            long val;\n+            do {\n+                rng.nextBytes(byteArray);\n+                bits = 0;\n+                for (final byte b : byteArray) {\n+                    bits = (bits << 8) | (((long) b) & 0xffL);\n+                }\n+                bits = bits & 0x7fffffffffffffffL;\n+                val  = bits % n;\n+            } while (bits - val + (n - 1) < 0);\n+            return val;\n+        }\n+        throw new NotStrictlyPositiveException(n);\n     }\n \n     /**\n     }\n \n     /**  {@inheritDoc} */\n-    public int nextSecureInt(int lower, int upper) throws NumberIsTooLargeException {\n+    public int nextSecureInt(final int lower, final int upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n-        SecureRandom sec = getSecRan();\n-        final double r = sec.nextDouble();\n-        final double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (int)FastMath.floor(scaled);\n+        final int max = (upper - lower) + 1;\n+        if (max <= 0) {\n+            // the range is too wide to fit in a positive int (larger than 2^31); as it covers\n+            // more than half the integer range, we use directly a simple rejection method\n+            final SecureRandom rng = getSecRan();\n+            while (true) {\n+                final int r = rng.nextInt();\n+                if (r >= lower && r <= upper) {\n+                    return r;\n+                }\n+            }\n+        } else {\n+            // we can shift the range and generate directly a positive int\n+            return lower + getSecRan().nextInt(max);\n+        }\n     }\n \n     /** {@inheritDoc} */\n-    public long nextSecureLong(long lower, long upper) throws NumberIsTooLargeException {\n+    public long nextSecureLong(final long lower, final long upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n-        SecureRandom sec = getSecRan();\n-        final double r = sec.nextDouble();\n-        final double scaled = r * upper + (1.0 - r) * lower + r;\n-        return (long)FastMath.floor(scaled);\n+        final long max = (upper - lower) + 1;\n+        if (max <= 0) {\n+            // the range is too wide to fit in a positive long (larger than 2^63); as it covers\n+            // more than half the long range, we use directly a simple rejection method\n+            final SecureRandom rng = getSecRan();\n+            while (true) {\n+                final long r = rng.nextLong();\n+                if (r >= lower && r <= upper) {\n+                    return r;\n+                }\n+            }\n+        } else if (max < Integer.MAX_VALUE){\n+            // we can shift the range and generate directly a positive int\n+            return lower + getSecRan().nextInt((int) max);\n+        } else {\n+            // we can shift the range and generate directly a positive long\n+            return lower + nextLong(getSecRan(), max);\n+        }\n+    }\n+\n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>long</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.\n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>long</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    private static long nextLong(final SecureRandom rng, final long n) throws IllegalArgumentException {\n+        if (n > 0) {\n+            final byte[] byteArray = new byte[8];\n+            long bits;\n+            long val;\n+            do {\n+                rng.nextBytes(byteArray);\n+                bits = 0;\n+                for (final byte b : byteArray) {\n+                    bits = (bits << 8) | (((long) b) & 0xffL);\n+                }\n+                bits = bits & 0x7fffffffffffffffL;\n+                val  = bits % n;\n+            } while (bits - val + (n - 1) < 0);\n+            return val;\n+        }\n+        throw new NotStrictlyPositiveException(n);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math3/stat/ranking/NaturalRanking.java\n \n import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NotANumberException;\n-import org.apache.commons.math3.random.RandomData;\n-import org.apache.commons.math3.random.RandomDataImpl;\n+import org.apache.commons.math3.random.RandomDataGenerator;\n import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.util.FastMath;\n \n     private final TiesStrategy tiesStrategy;\n \n     /** Source of random data - used only when ties strategy is RANDOM */\n-    private final RandomData randomData;\n+    private final RandomDataGenerator randomData;\n \n     /**\n      * Create a NaturalRanking with default strategies for handling ties and NaNs.\n         super();\n         this.tiesStrategy = tiesStrategy;\n         nanStrategy = DEFAULT_NAN_STRATEGY;\n-        randomData = new RandomDataImpl();\n+        randomData = new RandomDataGenerator();\n     }\n \n     /**\n         super();\n         this.nanStrategy = nanStrategy;\n         this.tiesStrategy = tiesStrategy;\n-        randomData = new RandomDataImpl();\n+        randomData = new RandomDataGenerator();\n     }\n \n     /**\n         super();\n         this.tiesStrategy = TiesStrategy.RANDOM;\n         nanStrategy = DEFAULT_NAN_STRATEGY;\n-        randomData = new RandomDataImpl(randomGenerator);\n+        randomData = new RandomDataGenerator(randomGenerator);\n     }\n \n \n         super();\n         this.nanStrategy = nanStrategy;\n         this.tiesStrategy = TiesStrategy.RANDOM;\n-        randomData = new RandomDataImpl(randomGenerator);\n+        randomData = new RandomDataGenerator(randomGenerator);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math3/random/MersenneTwisterTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/MersenneTwisterTest.java\n \n     @Override\n     protected RandomGenerator makeGenerator() {\n-        return new MersenneTwister(100);\n+        return new MersenneTwister(111);\n     }\n     \n     // TODO: Some of the tests moved up to RandomGeneratorAbstractTest tested alternative seeding / constructors\n--- a/src/test/java/org/apache/commons/math3/random/RandomDataGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/RandomDataGeneratorTest.java\n             checkNextIntUniform(-3, 6);\n         }\n     }\n-    \n+\n     @Test \n     public void testNextIntNegativeRange() {\n         for (int i = 0; i < 5; i++) {\n             checkNextIntUniform(-7, -4);\n             checkNextIntUniform(-15, -2);\n-        }\n-    }\n-    \n+            checkNextIntUniform(Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 12);\n+        }\n+    }\n+\n     @Test \n     public void testNextIntPositiveRange() {\n         for (int i = 0; i < 5; i++) {\n             checkNextIntUniform(0, 3);\n             checkNextIntUniform(2, 12);\n             checkNextIntUniform(1,2);\n-        }\n-    }\n-    \n-    \n+            checkNextIntUniform(Integer.MAX_VALUE - 12, Integer.MAX_VALUE - 1);\n+        }\n+    }\n+\n     private void checkNextIntUniform(int min, int max) {\n         final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n     }\n \n     @Test\n+    public void testNextIntWideRange() {\n+        int lower = -0x6543210F;\n+        int upper =  0x456789AB;\n+        int max   = Integer.MIN_VALUE;\n+        int min   = Integer.MAX_VALUE;\n+        for (int i = 0; i < 1000000; ++i) {\n+            int r = randomData.nextInt(lower, upper);\n+            max = FastMath.max(max, r);\n+            min = FastMath.min(min, r);\n+            Assert.assertTrue(r >= lower);\n+            Assert.assertTrue(r <= upper);\n+        }\n+        double ratio = (((double) max)   - ((double) min)) /\n+                       (((double) upper) - ((double) lower));\n+        Assert.assertTrue(ratio > 0.99999);\n+    }\n+    \n+    @Test\n     public void testNextLongIAE() {\n         try {\n             randomData.nextLong(4, 3);\n             // ignored\n         }\n     }\n-    \n+\n     @Test\n     public void testNextLongNegativeToPositiveRange() {\n         for (int i = 0; i < 5; i++) {\n             checkNextLongUniform(-3, 6);\n         }\n     }\n-    \n+\n     @Test \n     public void testNextLongNegativeRange() {\n         for (int i = 0; i < 5; i++) {\n             checkNextLongUniform(-7, -4);\n             checkNextLongUniform(-15, -2);\n-        }\n-    }\n-    \n+            checkNextLongUniform(Long.MIN_VALUE + 1, Long.MIN_VALUE + 12);\n+        }\n+    }\n+\n     @Test \n     public void testNextLongPositiveRange() {\n         for (int i = 0; i < 5; i++) {\n             checkNextLongUniform(0, 3);\n             checkNextLongUniform(2, 12);\n-        }\n-    }\n-    \n-    private void checkNextLongUniform(int min, int max) {\n+            checkNextLongUniform(Long.MAX_VALUE - 12, Long.MAX_VALUE - 1);\n+        }\n+    }\n+\n+    private void checkNextLongUniform(long min, long max) {\n         final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n             final long value = randomData.nextLong(min, max);\n-            Assert.assertTrue(\"nextLong range\", (value >= min) && (value <= max));\n+            Assert.assertTrue(\"nextLong range: \" + value + \" \" + min + \" \" + max,\n+                              (value >= min) && (value <= max));\n             freq.addValue(value);\n         }\n-        final int len = max - min + 1;\n+        final int len = ((int) (max - min)) + 1;\n         final long[] observed = new long[len];\n         for (int i = 0; i < len; i++) {\n             observed[i] = freq.getCount(min + i);\n         TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n     }\n \n+    @Test\n+    public void testNextLongWideRange() {\n+        long lower = -0x6543210FEDCBA987L;\n+        long upper =  0x456789ABCDEF0123L;\n+        long max = Long.MIN_VALUE;\n+        long min = Long.MAX_VALUE;\n+        for (int i = 0; i < 10000000; ++i) {\n+            long r = randomData.nextLong(lower, upper);\n+            max = FastMath.max(max, r);\n+            min = FastMath.min(min, r);\n+            Assert.assertTrue(r >= lower);\n+            Assert.assertTrue(r <= upper);\n+        }\n+        double ratio = (((double) max)   - ((double) min)) /\n+                       (((double) upper) - ((double) lower));\n+        Assert.assertTrue(ratio > 0.99999);\n+    }\n+    \n     @Test\n     public void testNextSecureLongIAE() {\n         try {\n--- a/src/test/java/org/apache/commons/math3/random/Well512aTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/Well512aTest.java\n     \n     @Override\n     public RandomGenerator makeGenerator() {\n-        return new Well512a(100);\n+        return new Well512a(101);\n     }\n     @Test\n     public void testReferenceCode() {\n--- a/src/test/java/org/apache/commons/math3/stat/ranking/NaturalRankingTest.java\n+++ b/src/test/java/org/apache/commons/math3/stat/ranking/NaturalRankingTest.java\n         NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,\n                 randomGenerator);\n         double[] ranks = ranking.rank(exampleData);\n-        double[] correctRanks = { 5, 4, 6, 7, 3, 8, Double.NaN, 1, 4 };\n-        TestUtils.assertEquals(correctRanks, ranks, 0d);\n-        ranks = ranking.rank(tiesFirst);\n-        correctRanks = new double[] { 1, 1, 4, 3, 5 };\n-        TestUtils.assertEquals(correctRanks, ranks, 0d);\n-        ranks = ranking.rank(tiesLast);\n-        correctRanks = new double[] { 3, 4, 2, 1 };\n+        double[] correctRanks = { 5, 3, 6, 7, 3, 8, Double.NaN, 1, 2 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesFirst);\n+        correctRanks = new double[] { 1, 2, 4, 3, 5 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(tiesLast);\n+        correctRanks = new double[] { 3, 3, 2, 1 };\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n         ranks = ranking.rank(multipleNaNs);\n         correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n         ranks = ranking.rank(multipleTies);\n-        correctRanks = new double[] { 3, 2, 5, 5, 7, 6, 1 };\n-        TestUtils.assertEquals(correctRanks, ranks, 0d);\n-        ranks = ranking.rank(allSame);\n-        correctRanks = new double[] { 1, 3, 4, 4 };\n+        correctRanks = new double[] { 3, 2, 4, 4, 6, 7, 1 };\n+        TestUtils.assertEquals(correctRanks, ranks, 0d);\n+        ranks = ranking.rank(allSame);\n+        correctRanks = new double[] { 2, 3, 3, 3 };\n         TestUtils.assertEquals(correctRanks, ranks, 0d);\n     }\n ", "timestamp": 1362942174, "metainfo": ""}