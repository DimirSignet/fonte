{"sha": "3f96c7ac9dafc82265a6dd3e145a21448af14282", "log": "Added the L\u00e9vy distribution.  The patch from Andrew Waterman has been added, with several fixes and extensions.  JIRA: MATH-460  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/LevyDistribution.java\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.special.Erf;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * This class implements the <a href=\"http://en.wikipedia.org/wiki/L%C3%A9vy_distribution\">\n+ * L&eacute;vy distribution</a>.\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class LevyDistribution extends AbstractRealDistribution {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130314L;\n+\n+    /** Location parameter. */\n+    private final double mu;\n+\n+    /** Scale parameter. */\n+    private final double c;  // Setting this to 1 returns a cumProb of 1.0\n+\n+    /** Half of c (for calculations). */\n+    private final double halfC;\n+\n+    /**\n+     * Creates a LevyDistribution.\n+     * @param rng random generator to be used for sampling\n+     * @param mu location\n+     * @param c scale parameter\n+     */\n+    public LevyDistribution(final RandomGenerator rng, final double mu, final double c) {\n+        super(rng);\n+        this.mu    = mu;\n+        this.c     = c;\n+        this.halfC = 0.5 * c;\n+    }\n+\n+    /** {@inheritDoc}\n+    * <p>\n+    * From Wikipedia: The probability density function of the L&eacute;vy distribution\n+    * over the domain is\n+    * </p>\n+    * <pre>\n+    * f(x; &mu;, c) = &radic;(c / 2&pi;) * e<sup>-c / 2 (x - &mu;)</sup> / (x - &mu;)<sup>3/2</sup>\n+    * </pre>\n+    * <p>\n+    * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+    * If {@code x} is less than location parameter &mu;, {@code Double.NaN} is\n+    * returned, as in these cases the distribution is not defined.\n+    * </p>\n+    */\n+    public double density(final double x) {\n+        if (x < mu) {\n+            return Double.NaN;\n+        }\n+\n+        final double delta = x - mu;\n+        final double f     = halfC / delta;\n+        return FastMath.sqrt(f / FastMath.PI) * FastMath.exp(-f) /delta;\n+    }\n+\n+    /** {@inheritDoc}\n+     * <p>\n+     * From Wikipedia: the cumulative distribution function is\n+     * </p>\n+     * <pre>\n+     * f(x; u, c) = erfc (&radic; (c / 2 (x - u )))\n+     * </pre>\n+     */\n+    public double cumulativeProbability(final double x) {\n+        if (x < mu) {\n+            return Double.NaN;\n+        }\n+        return Erf.erfc(FastMath.sqrt(halfC / (x - mu)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+        final double t = Erf.erfcInv(p);\n+        return mu + halfC / (t * t);\n+    }\n+\n+    /** Get the scale parameter of the distribution.\n+     * @return scale parameter of the distribution\n+     */\n+    public double getScale() {\n+        return c;\n+    }\n+\n+    /** Get the location parameter of the distribution.\n+     * @return location parameter of the distribution\n+     */\n+    public double getLocation() {\n+        return mu;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNumericalMean() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNumericalVariance() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSupportLowerBound() {\n+        return mu;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        // there is a division by x-mu in the computation, so density\n+        // is not finite at lower bound, bound must be excluded\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        // upper bound is infinite, so it must be excluded\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/LevyDistributionTest.java\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.random.Well19937a;\n+import org.apache.commons.math3.util.Precision;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class LevyDistributionTest extends RealDistributionAbstractTest {\n+\n+    @Test\n+    public void testParameters() {\n+        LevyDistribution d = makeDistribution();\n+        Assert.assertEquals(1.2, d.getLocation(), Precision.EPSILON);\n+        Assert.assertEquals(0.4,   d.getScale(),  Precision.EPSILON);\n+    }\n+\n+    @Test\n+    public void testSupport() {\n+        LevyDistribution d = makeDistribution();\n+        Assert.assertEquals(d.getLocation(), d.getSupportLowerBound(), Precision.EPSILON);\n+        Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound()));\n+        Assert.assertTrue(d.isSupportConnected());\n+    }\n+\n+    public LevyDistribution makeDistribution() {\n+        return new LevyDistribution(new Well19937a(0xc5a5506bbb17e57al), 1.2, 0.4);\n+    }\n+\n+    public double[] makeCumulativeTestPoints() {\n+        return new double[] {\n+            1.2001, 1.21, 1.225, 1.25, 1.3, 1.9, 3.4, 5.6\n+        };\n+    }\n+\n+    public double[] makeCumulativeTestValues() {\n+        // values computed with R and function plevy from rmutil package\n+        return new double[] {\n+            0, 2.53962850749e-10, 6.33424836662e-05, 0.00467773498105,\n+            0.0455002638964, 0.449691797969, 0.669815357599, 0.763024600553\n+        };\n+    }\n+\n+    public double[] makeDensityTestValues() {\n+        // values computed with R and function dlevy from rmutil package\n+        return new double[] {\n+            0, 5.20056373765e-07, 0.0214128361224, 0.413339707082, 1.07981933026,\n+            0.323749319161, 0.0706032550094, 0.026122839884\n+        };\n+    }\n+\n+}", "timestamp": 1363347554, "metainfo": ""}