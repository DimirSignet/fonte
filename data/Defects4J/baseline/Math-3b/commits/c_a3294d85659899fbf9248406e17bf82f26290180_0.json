{"sha": "a3294d85659899fbf9248406e17bf82f26290180", "log": "Fixed inconsistency preventing use of secondary states in ODE events.  JIRA: MATH-965  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n         evaluations.resetCount();\n \n         for (final EventState state : eventsStates) {\n+            state.setExpandable(expandable);\n             state.getEventHandler().init(t0, y0, t);\n         }\n \n \n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n-                final double[] eventYPrimary  = interpolator.getInterpolatedState().clone();\n                 final double[] eventYComplete = new double[y.length];\n                 expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                  eventYComplete);\n \n                 // advance all event states to current time\n                 for (final EventState state : eventsStates) {\n-                    state.stepAccepted(eventT, eventYPrimary);\n+                    state.stepAccepted(eventT, eventYComplete);\n                     isLastStep = isLastStep || state.stop();\n                 }\n \n \n             // last part of the step, after the last event\n             interpolator.setInterpolatedTime(currentT);\n-            final double[] currentY = interpolator.getInterpolatedState();\n+            final double[] currentY = new double[y.length];\n+            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n+                                                             currentY);\n+            int index = 0;\n+            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n+                                             currentY);\n+            }\n             for (final EventState state : eventsStates) {\n                 state.stepAccepted(currentT, currentY);\n                 isLastStep = isLastStep || state.stop();\n--- a/src/main/java/org/apache/commons/math3/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math3/ode/events/EventState.java\n import org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.ode.EquationsMapper;\n+import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.sampling.StepInterpolator;\n import org.apache.commons.math3.util.FastMath;\n \n     /** Upper limit in the iteration count for event localization. */\n     private final int maxIterationCount;\n \n+    /** Equation being integrated. */\n+    private ExpandableStatefulODE expandable;\n+\n     /** Time at the beginning of the step. */\n     private double t0;\n \n         this.solver            = solver;\n \n         // some dummy values ...\n+        expandable        = null;\n         t0                = Double.NaN;\n         g0                = Double.NaN;\n         g0Positive        = true;\n         return handler;\n     }\n \n+    /** Set the equation.\n+     * @param expandable equation being integrated\n+     */\n+    public void setExpandable(final ExpandableStatefulODE expandable) {\n+        this.expandable = expandable;\n+    }\n+\n     /** Get the maximal time interval between events handler checks.\n      * @return maximal time interval between events handler checks\n      */\n \n         t0 = interpolator.getPreviousTime();\n         interpolator.setInterpolatedTime(t0);\n-        g0 = handler.g(t0, interpolator.getInterpolatedState());\n+        g0 = handler.g(t0, getCompleteState(interpolator));\n         if (g0 == 0) {\n             // excerpt from MATH-421 issue:\n             // If an ODE solver is setup with an EventHandler that return STOP\n                                                 FastMath.abs(solver.getRelativeAccuracy() * t0));\n             final double tStart = t0 + 0.5 * epsilon;\n             interpolator.setInterpolatedTime(tStart);\n-            g0 = handler.g(tStart, interpolator.getInterpolatedState());\n+            g0 = handler.g(tStart, getCompleteState(interpolator));\n         }\n         g0Positive = g0 >= 0;\n+\n+    }\n+\n+    /** Get the complete state (primary and secondary).\n+     * @param interpolator interpolator to use\n+     * @return complete state\n+     */\n+    private double[] getCompleteState(final StepInterpolator interpolator) {\n+\n+        final double[] complete = new double[expandable.getTotalDimension()];\n+\n+        expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n+                                                         complete);\n+        int index = 0;\n+        for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+            secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n+                                         complete);\n+        }\n+\n+        return complete;\n \n     }\n \n                 public double value(final double t) throws LocalMaxCountExceededException {\n                     try {\n                         interpolator.setInterpolatedTime(t);\n-                        return handler.g(t, interpolator.getInterpolatedState());\n+                        return handler.g(t, getCompleteState(interpolator));\n                     } catch (MaxCountExceededException mcee) {\n                         throw new LocalMaxCountExceededException(mcee);\n                     }\n                 // evaluate handler value at the end of the substep\n                 final double tb = t0 + (i + 1) * h;\n                 interpolator.setInterpolatedTime(tb);\n-                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n+                final double gb = handler.g(tb, getCompleteState(interpolator));\n \n                 // check events occurrence\n                 if (g0Positive ^ (gb >= 0)) {\n--- a/src/test/java/org/apache/commons/math3/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/events/EventStateTest.java\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math3.ode.SecondaryEquations;\n import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math3.ode.sampling.DummyStepInterpolator;\n         EventState es = new EventState(closeEventsGenerator, 1.5 * gap,\n                                        tolerance, 100,\n                                        new BrentSolver(tolerance));\n+        es.setExpandable(new ExpandableStatefulODE(new FirstOrderDifferentialEquations() {\n+            public int getDimension() {\n+                return 0;\n+            }\n+            public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            }\n+        }));\n \n         AbstractStepInterpolator interpolator =\n             new DummyStepInterpolator(new double[0], new double[0], true);\n \n     }\n \n+    // Jira: MATH-965\n+    @Test\n+    public void testIssue965()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n+\n+        ExpandableStatefulODE equation =\n+                new ExpandableStatefulODE(new FirstOrderDifferentialEquations() {\n+            \n+            public int getDimension() {\n+                return 1;\n+            }\n+            \n+            public void computeDerivatives(double t, double[] y, double[] yDot) {\n+                yDot[0] = 2.0;\n+            }\n+        });\n+        equation.setTime(0.0);\n+        equation.setPrimaryState(new double[1]);\n+        equation.addSecondaryEquations(new SecondaryEquations() {\n+            \n+            public int getDimension() {\n+                return 1;\n+            }\n+            \n+            public void computeDerivatives(double t, double[] primary,\n+                                           double[] primaryDot, double[] secondary,\n+                                           double[] secondaryDot) {\n+                secondaryDot[0] = -3.0;\n+            }\n+        });\n+        int index = equation.getSecondaryMappers()[0].getFirstIndex();\n+\n+        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n+        integrator.addEventHandler(new SecondaryStateEvent(index, -3.0), 0.1, 1.0e-9, 1000);\n+        integrator.setInitialStepSize(3.0);\n+\n+        integrator.integrate(equation, 30.0);\n+        Assert.assertEquals( 1.0, equation.getTime(), 1.0e-10);\n+        Assert.assertEquals( 2.0, equation.getPrimaryState()[0], 1.0e-10);\n+        Assert.assertEquals(-3.0, equation.getSecondaryState(0)[0], 1.0e-10);\n+\n+    }\n+\n+    private static class SecondaryStateEvent implements EventHandler {\n+\n+        private int index;\n+        private final double target;\n+\n+        public SecondaryStateEvent(final int index, final double target) {\n+            this.index  = index;\n+            this.target = target;\n+        }\n+\n+        public void init(double t0, double[] y0, double t) {\n+        }\n+\n+        public double g(double t, double[] y) {\n+            return y[index] - target;\n+        }\n+\n+        public Action eventOccurred(double t, double[] y, boolean increasing) {\n+            return Action.STOP;\n+        }\n+\n+        public void resetState(double t, double[] y) {\n+        }\n+\n+    }\n \n }", "timestamp": 1365432092, "metainfo": ""}