{"sha": "c5a4a4f0e6e2d19487c50179a5a33af937ce9a0d", "log": "Renamed ExtendedFieldElement into RealFieldElement.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/RealFieldElement.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+\n+/**\n+ * Interface representing a <a href=\"http://mathworld.wolfram.com/RealNumber.html\">real</a>\n+ * <a href=\"http://mathworld.wolfram.com/Field.html\">field</a>.\n+ * <p>\n+ * Classes implementing this interface will often be singletons.\n+ * </p>\n+ * @param <T> the type of the field elements\n+ * @see FieldElement\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public interface RealFieldElement<T> extends FieldElement<T> {\n+\n+    /** Get the real value of the number.\n+     * @return real value\n+     */\n+    double getReal();\n+\n+    /** '+' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this+a\n+     */\n+    T add(double a);\n+\n+    /** '-' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this-a\n+     */\n+    T subtract(double a);\n+\n+    /** '&times;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&times;a\n+     */\n+    T multiply(double a);\n+\n+    /** '&divides;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&divides;a\n+     */\n+    T divide(double a);\n+\n+    /** IEEE remainder operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this - n &times; a where n is the closest integer to this/a\n+     * (the even integer is chosen for n if this/a is halfway between two integers)\n+     */\n+    T remainder(double a);\n+\n+    /** IEEE remainder operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this - n &times; a where n is the closest integer to this/a\n+     * (the even integer is chosen for n if this/a is halfway between two integers)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T remainder(T a)\n+        throws DimensionMismatchException;\n+\n+    /** absolute value.\n+     * @return abs(this)\n+     */\n+    T abs();\n+\n+    /** Get the smallest whole number larger than instance.\n+     * @return ceil(this)\n+     */\n+    T ceil();\n+\n+    /** Get the largest whole number smaller than instance.\n+     * @return floor(this)\n+     */\n+    T floor();\n+\n+    /** Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.\n+     * @return a double number r such that r is an integer r - 0.5 <= this <= r + 0.5\n+     */\n+    T rint();\n+\n+    /** Get the closest long to instance value.\n+     * @return closest long to {@link #getReal()}\n+     */\n+    long round();\n+\n+    /** Compute the signum of the instance.\n+     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n+     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n+     */\n+    T signum();\n+\n+    /**\n+     * Returns the instance with the sign of the argument.\n+     * A NaN {@code sign} argument is treated as positive.\n+     *\n+     * @param sign the sign for the returned value\n+     * @return the instance with the same sign as the {@code sign} argument\n+     */\n+    T copySign(T sign);\n+\n+    /**\n+     * Returns the instance with the sign of the argument.\n+     * A NaN {@code sign} argument is treated as positive.\n+     *\n+     * @param sign the sign for the returned value\n+     * @return the instance with the same sign as the {@code sign} argument\n+     */\n+    T copySign(double sign);\n+\n+    /**\n+     * Multiply the instance by a power of 2.\n+     * @param n power of 2\n+     * @return this &times; 2<sup>n</sup>\n+     */\n+    T scalb(int n);\n+\n+    /**\n+     * Returns the hypotenuse of a triangle with sides {@code this} and {@code y}\n+     * - sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n+     * avoiding intermediate overflow or underflow.\n+     *\n+     * <ul>\n+     * <li> If either argument is infinite, then the result is positive infinity.</li>\n+     * <li> else, if either argument is NaN then the result is NaN.</li>\n+     * </ul>\n+     *\n+     * @param y a value\n+     * @return sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T hypot(T y)\n+        throws DimensionMismatchException;\n+\n+    /** {@inheritDoc} */\n+    T reciprocal();\n+\n+    /** Square root.\n+     * @return square root of the instance\n+     */\n+    T sqrt();\n+\n+    /** Cubic root.\n+     * @return cubic root of the instance\n+     */\n+    T cbrt();\n+\n+    /** N<sup>th</sup> root.\n+     * @param n order of the root\n+     * @return n<sup>th</sup> root of the instance\n+     */\n+    T rootN(int n);\n+\n+    /** Power operation.\n+     * @param p power to apply\n+     * @return this<sup>p</sup>\n+     */\n+    T pow(double p);\n+\n+    /** Integer power operation.\n+     * @param n power to apply\n+     * @return this<sup>n</sup>\n+     */\n+    T pow(int n);\n+\n+    /** Power operation.\n+     * @param e exponent\n+     * @return this<sup>e</sup>\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T pow(T e)\n+        throws DimensionMismatchException;\n+\n+    /** Exponential.\n+     * @return exponential of the instance\n+     */\n+    T exp();\n+\n+    /** Exponential minus 1.\n+     * @return exponential minus one of the instance\n+     */\n+    T expm1();\n+\n+    /** Natural logarithm.\n+     * @return logarithm of the instance\n+     */\n+    T log();\n+\n+    /** Shifted natural logarithm.\n+     * @return logarithm of one plus the instance\n+     */\n+    T log1p();\n+\n+    /** Base 10 logarithm.\n+     * @return base 10 logarithm of the instance\n+     */\n+    T log10();\n+\n+    /** Cosine operation.\n+     * @return cos(this)\n+     */\n+    T cos();\n+\n+    /** Sine operation.\n+     * @return sin(this)\n+     */\n+    T sin();\n+\n+    /** Tangent operation.\n+     * @return tan(this)\n+     */\n+    T tan();\n+\n+    /** Arc cosine operation.\n+     * @return acos(this)\n+     */\n+    T acos();\n+\n+    /** Arc sine operation.\n+     * @return asin(this)\n+     */\n+    T asin();\n+\n+    /** Arc tangent operation.\n+     * @return atan(this)\n+     */\n+    T atan();\n+\n+    /** Two arguments arc tangent operation.\n+     * @param x second argument of the arc tangent\n+     * @return atan2(this, x)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    T atan2(T x)\n+        throws DimensionMismatchException;\n+\n+    /** Hyperbolic cosine operation.\n+     * @return cosh(this)\n+     */\n+    T cosh();\n+\n+    /** Hyperbolic sine operation.\n+     * @return sinh(this)\n+     */\n+    T sinh();\n+\n+    /** Hyperbolic tangent operation.\n+     * @return tanh(this)\n+     */\n+    T tanh();\n+\n+    /** Inverse hyperbolic cosine operation.\n+     * @return acosh(this)\n+     */\n+    T acosh();\n+\n+    /** Inverse hyperbolic sine operation.\n+     * @return asin(this)\n+     */\n+    T asinh();\n+\n+    /** Inverse hyperbolic  tangent operation.\n+     * @return atanh(this)\n+     */\n+    T atanh();\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     * @since 3.2\n+     */\n+    T linearCombination(T[] a, T[] b)\n+        throws DimensionMismatchException;\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * This method computes the sum of the products\n+     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n+     * It does so by using specific multiplication and addition algorithms to\n+     * preserve accuracy and reduce cancellation effects.\n+     * <br/>\n+     * It is based on the 2005 paper\n+     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n+     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a Factors.\n+     * @param b Factors.\n+     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n+     * @throws DimensionMismatchException if arrays dimensions don't match\n+     * @since 3.2\n+     */\n+    T linearCombination(double[] a, T[] b)\n+        throws DimensionMismatchException;\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object, Object, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(T a1, T b1, T a2, T b2);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub>\n+     * @see #linearCombination(double, Object, double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object, double, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(double a1, T b1, double a2, T b2);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object, Object, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n+     * @see #linearCombination(double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object, double, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(double a1, T b1,  double a2, T b2, double a3, T b3);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3, T a4, T b4);\n+\n+    /**\n+     * Compute a linear combination accurately.\n+     * <p>\n+     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * to high accuracy. It does so by using specific multiplication and\n+     * addition algorithms to preserve accuracy and reduce cancellation effects.\n+     * It is based on the 2005 paper <a\n+     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n+     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n+     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n+     * </p>\n+     * <p>\n+     * Note that the instance is only used as a prototype to get proper elements dimensions.\n+     * Its value is not used, only the parameters values are used.\n+     * </p>\n+     * @param a1 first factor of the first term\n+     * @param b1 second factor of the first term\n+     * @param a2 first factor of the second term\n+     * @param b2 second factor of the second term\n+     * @param a3 first factor of the third term\n+     * @param b3 second factor of the third term\n+     * @param a4 first factor of the third term\n+     * @param b4 second factor of the third term\n+     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n+     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n+     * a<sub>4</sub>&times;b<sub>4</sub>\n+     * @see #linearCombination(double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object)\n+     * @since 3.2\n+     */\n+    T linearCombination(double a1, T b1, double a2, T b2, double a3, T b3, double a4, T b4);\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.RealFieldElement;\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n  * @version $Id$\n  * @since 3.1\n  */\n-public class DerivativeStructure implements ExtendedFieldElement<DerivativeStructure>, Serializable {\n+public class DerivativeStructure implements RealFieldElement<DerivativeStructure>, Serializable {\n \n     /** Serializable UID. */\n     private static final long serialVersionUID = 20120730L;\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.RealFieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.util.FastMath;\n \n  * @version $Id$\n  * @since 2.2\n  */\n-public class Dfp implements ExtendedFieldElement<Dfp> {\n+public class Dfp implements RealFieldElement<Dfp> {\n \n     /** The radix, or base of this system.  Set to 10000 */\n     public static final int RADIX = 10000;\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.RealFieldElement;\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.util.MathArrays;\n \n /**\n- * This class is a re-implementation of {@link Rotation} using {@link ExtendedFieldElement}.\n+ * This class is a re-implementation of {@link Rotation} using {@link RealFieldElement}.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n  *\n  * @param <T> the type of the field elements\n  * @since 3.2\n  */\n \n-public class FieldRotation<T extends ExtendedFieldElement<T>> implements Serializable {\n+public class FieldRotation<T extends RealFieldElement<T>> implements Serializable {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 20130224l;\n \n     /** Get the normalized axis of the rotation.\n      * @return normalized axis of the rotation\n-     * @see #FieldRotation(FieldVector3D, ExtendedFieldElement)\n+     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n      */\n     public FieldVector3D<T> getAxis() {\n         final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n \n     /** Get the angle of the rotation.\n      * @return angle of the rotation (between 0 and &pi;)\n-     * @see #FieldRotation(FieldVector3D, ExtendedFieldElement)\n+     * @see #FieldRotation(FieldVector3D, RealFieldElement)\n      */\n     public T getAngle() {\n         if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n      * @param <T> the type of the field elements\n      * @return a new vector which is the image of u by the rotation\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n+    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n \n         final T x = u.getX();\n         final T y = u.getY();\n      * @param <T> the type of the field elements\n      * @return a new vector which such that u is its image by the rotation\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n+    public static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n \n         final T x = u.getX();\n         final T y = u.getY();\n      * @param <T> the type of the field elements\n      * @return a new rotation which is the composition of r by the instance\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n+    public static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n         return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))),\n                                     rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))),\n                                     rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))),\n      * @return a new rotation which is the composition of r by the inverse\n      * of the instance\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n+    public static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n         return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(),\n                                     rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())),\n                                     rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())),\n      * @param <T> the type of the field elements\n      * @return <i>distance</i> between r1 and r2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n+    public static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n         return r1.applyInverseTo(r2).getAngle();\n     }\n \n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n import java.io.Serializable;\n import java.text.NumberFormat;\n \n-import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.RealFieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.MathArrays;\n \n /**\n- * This class is a re-implementation of {@link Vector3D} using {@link ExtendedFieldElement}.\n+ * This class is a re-implementation of {@link Vector3D} using {@link RealFieldElement}.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n  * @param <T> the type of the field elements\n  * @version $Id$\n  * @since 3.2\n  */\n-public class FieldVector3D<T extends ExtendedFieldElement<T>> implements Serializable {\n+public class FieldVector3D<T extends RealFieldElement<T>> implements Serializable {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20130224L;\n \n     /** Get the abscissa of the vector.\n      * @return abscissa of the vector\n-     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n+     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)\n      */\n     public T getX() {\n         return x;\n \n     /** Get the ordinate of the vector.\n      * @return ordinate of the vector\n-     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n+     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)\n      */\n     public T getY() {\n         return y;\n \n     /** Get the height of the vector.\n      * @return height of the vector\n-     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n+     * @see #FieldVector3D(RealFieldElement, RealFieldElement, RealFieldElement)\n      */\n     public T getZ() {\n         return z;\n \n     /** Get the vector coordinates as a dimension 3 array.\n      * @return vector coordinates\n-     * @see #FieldVector3D(ExtendedFieldElement[])\n+     * @see #FieldVector3D(RealFieldElement[])\n      */\n     public T[] toArray() {\n         final T[] array = MathArrays.buildArray(x.getField(), 3);\n \n     /** Get the azimuth of the vector.\n      * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n-     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement)\n+     * @see #FieldVector3D(RealFieldElement, RealFieldElement)\n      */\n     public T getAlpha() {\n         return y.atan2(x);\n \n     /** Get the elevation of the vector.\n      * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n-     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement)\n+     * @see #FieldVector3D(RealFieldElement, RealFieldElement)\n      */\n     public T getDelta() {\n         return z.divide(getNorm()).asin();\n      * @return angular separation between v1 and v2\n      * @exception MathArithmeticException if either vector has a null norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2)\n+    public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2)\n         throws MathArithmeticException {\n \n         final T normProduct = v1.getNorm().multiply(v2.getNorm());\n      * @return angular separation between v1 and v2\n      * @exception MathArithmeticException if either vector has a null norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2)\n+    public static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2)\n         throws MathArithmeticException {\n \n         final T normProduct = v1.getNorm().multiply(v2.getNorm());\n      * @return angular separation between v1 and v2\n      * @exception MathArithmeticException if either vector has a null norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2)\n+    public static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2)\n         throws MathArithmeticException {\n         return angle(v2, v1);\n     }\n      * Test for the equality of two 3D vectors.\n      * <p>\n      * If all coordinates of two 3D vectors are exactly the same, and none of their\n-     * {@link ExtendedFieldElement#getReal() real part} are <code>NaN</code>, the\n+     * {@link RealFieldElement#getReal() real part} are <code>NaN</code>, the\n      * two 3D vectors are considered to be equal.\n      * </p>\n      * <p>\n      * @param <T> the type of the field elements\n      * @return the dot product v1.v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n                                                                    final FieldVector3D<T> v2) {\n         return v1.dotProduct(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the dot product v1.v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1,\n                                                                    final Vector3D v2) {\n         return v1.dotProduct(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the dot product v1.v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T dotProduct(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1,\n                                                                    final FieldVector3D<T> v2) {\n         return v2.dotProduct(v1);\n     }\n      * @param <T> the type of the field elements\n      * @return the cross product v1 ^ v2 as a new Vector\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n                                                                                     final FieldVector3D<T> v2) {\n         return v1.crossProduct(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the cross product v1 ^ v2 as a new Vector\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1,\n                                                                                     final Vector3D v2) {\n         return v1.crossProduct(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the cross product v1 ^ v2 as a new Vector\n      */\n-    public static <T extends ExtendedFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1,\n                                                                                     final FieldVector3D<T> v2) {\n         return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y),\n                                     v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z),\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n                                                                   final FieldVector3D<T> v2) {\n         return v1.distance1(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1,\n                                                                   final Vector3D v2) {\n         return v1.distance1(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance1(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> T distance1(final Vector3D v1,\n                                                                   final FieldVector3D<T> v2) {\n         return v2.distance1(v1);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1,\n                                                                  final FieldVector3D<T> v2) {\n         return v1.distance(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1,\n                                                                  final Vector3D v2) {\n         return v1.distance(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distance(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> T distance(final Vector3D v1,\n                                                                  final FieldVector3D<T> v2) {\n         return v2.distance(v1);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n                                                                     final FieldVector3D<T> v2) {\n         return v1.distanceInf(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1,\n                                                                     final Vector3D v2) {\n         return v1.distanceInf(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceInf(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1,\n                                                                     final FieldVector3D<T> v2) {\n         return v2.distanceInf(v1);\n     }\n      * @param <T> the type of the field elements\n      * @return the square of the distance between v1 and v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n                                                                    final FieldVector3D<T> v2) {\n         return v1.distanceSq(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the square of the distance between v1 and v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n+    public static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1,\n                                                                    final Vector3D v2) {\n         return v1.distanceSq(v2);\n     }\n      * @param <T> the type of the field elements\n      * @return the square of the distance between v1 and v2\n      */\n-    public static <T extends ExtendedFieldElement<T>> T distanceSq(final Vector3D v1,\n+    public static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1,\n                                                                    final FieldVector3D<T> v2) {\n         return v2.distanceSq(v1);\n     }\n--- a/src/main/java/org/apache/commons/math3/util/Decimal64.java\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64.java\n  */\n package org.apache.commons.math3.util;\n \n-import org.apache.commons.math3.ExtendedFieldElement;\n+import org.apache.commons.math3.RealFieldElement;\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n \n /**\n  * This class wraps a {@code double} value in an object. It is similar to the\n  * standard class {@link Double}, while also implementing the\n- * {@link ExtendedFieldElement} interface.\n+ * {@link RealFieldElement} interface.\n  *\n  * @since 3.1\n  * @version $Id$\n  */\n public class Decimal64 extends Number\n-                       implements ExtendedFieldElement<Decimal64>, Comparable<Decimal64> {\n+                       implements RealFieldElement<Decimal64>, Comparable<Decimal64> {\n \n     /** The constant value of {@code 0d} as a {@code Decimal64}. */\n     public static final Decimal64 ZERO;\n--- a/src/test/java/org/apache/commons/math3/ExtendedFieldElementAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/ExtendedFieldElementAbstractTest.java\n import org.junit.Assert;\n import org.junit.Test;\n \n-public abstract class ExtendedFieldElementAbstractTest<T extends ExtendedFieldElement<T>> {\n+public abstract class ExtendedFieldElementAbstractTest<T extends RealFieldElement<T>> {\n \n     protected abstract T build(double x);\n ", "timestamp": 1362944671, "metainfo": ""}