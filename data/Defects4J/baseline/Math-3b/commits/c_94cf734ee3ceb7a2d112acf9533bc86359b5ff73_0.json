{"sha": "94cf734ee3ceb7a2d112acf9533bc86359b5ff73", "log": "Formatting, replace <, > with html entities.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/primes/PollardRho.java\n+++ b/src/main/java/org/apache/commons/math3/primes/PollardRho.java\n class PollardRho {\n \n     /**\n-     * Only static methods in this class\n+     * Hide utility class.\n      */\n     private PollardRho() {\n     }\n \n     /**\n      * Factorization using Pollard's rho algorithm.\n-     * @param n number to factors, must be >0\n+     * @param n number to factors, must be &gt; 0\n      * @return the list of prime factors of n.\n      */\n     public static List<Integer> primeFactors(int n) {\n     }\n \n     /**\n-     *  Implementation of the Pollard's rho factorization algorithm.\n-     *  This implementation follows the paper \"An improved Monte Carlo factorization algorithm\" by Richard P. Brent.\n-     *  This avoid the triple computation of f(x) typically found in Pollard's rho implementations. It also batch several gcd computation into 1.\n-     *  The backtracking is not implemented as we deal only with semi-prime.\n+     * Implementation of the Pollard's rho factorization algorithm.\n+     * <p>\n+     * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n+     * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n+     * rho implementations. It also batch several gcd computation into 1.\n+     * <p>\n+     * The backtracking is not implemented as we deal only with semi-prime.\n+     *\n      * @param n number to factor, must be semi-prime.\n      * @return a prime factor of n.\n      */\n-    static int rhoBrent(final int n){\n+    static int rhoBrent(final int n) {\n         final int x0 = 2;\n         final int m = 25;\n         int cst = SmallPrimes.PRIMES_LAST;\n     }\n \n     /**\n-     * Gcd between two positive numbers\n+     * Gcd between two positive numbers.\n      * <p>\n-     * Gets the greatest common divisor of two numbers,\n-     * using the \"binary gcd\" method which avoids division and modulo\n-     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n-     * Stein (1961).\n+     * Gets the greatest common divisor of two numbers, using the \"binary gcd\" method,\n+     * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).\n      * </p>\n      * Special cases:\n      * <ul>\n-     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n-     * {@code gcd(x, 0)} is the value of {@code x}.\n-     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n-     * {@code 0}.</li>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>\n+     * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>\n      * </ul>\n-     * @param a first number, must be >=0\n-     * @param b second number, must be >=0\n+     *\n+     * @param a first number, must be &ge; 0\n+     * @param b second number, must be &ge; 0\n      * @return gcd(a,b)\n      */\n     static int gcdPositive(int a, int b){\n         // both a and b must be positive, it is not checked here\n-        //gdc(a,0) = a\n+        // gdc(a,0) = a\n         if (a == 0) {\n             return b;\n         } else if (b == 0) {\n             return a;\n         }\n \n-        //make a and b odd, keep in mind the common power of twos\n+        // make a and b odd, keep in mind the common power of twos\n         final int aTwos = Integer.numberOfTrailingZeros(a);\n         a >>= aTwos;\n         final int bTwos = Integer.numberOfTrailingZeros(b);\n         b >>= bTwos;\n         final int shift = FastMath.min(aTwos, bTwos);\n \n-        //a and b >0\n-        //if a > b then gdc(a,b) = gcd(a-b,b)\n-        //if a < b then gcd(a,b) = gcd(b-a,a)\n-        //so next a is the absolute difference and next b is the minimum of current values\n+        // a and b >0\n+        // if a > b then gdc(a,b) = gcd(a-b,b)\n+        // if a < b then gcd(a,b) = gcd(b-a,a)\n+        // so next a is the absolute difference and next b is the minimum of current values\n         while (a != b) {\n             final int delta = a - b;\n             b = FastMath.min(a, b);\n             a = FastMath.abs(delta);\n-            //for speed optimization:\n-            //remove any power of two in a as b is guaranteed to be odd throughout all iterations\n+            // for speed optimization:\n+            // remove any power of two in a as b is guaranteed to be odd throughout all iterations\n             a >>= Integer.numberOfTrailingZeros(a);\n         }\n \n-        //gcd(a,a) = a, just \"add\" the common power of twos\n+        // gcd(a,a) = a, just \"add\" the common power of twos\n         return a << shift;\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/primes/Primes.java\n+++ b/src/main/java/org/apache/commons/math3/primes/Primes.java\n  * <li>prime number generation</li>\n  * <li>factorization</li>\n  * </ul>\n- * {@link Math}.\n  *\n  * @version $Id$\n  * @since 3.2\n  */\n public class Primes {\n+\n     /**\n-     * Only static methods in this class\n+     * Hide utility class.\n      */\n     private Primes() {\n     }\n \n     /**\n-     * Primality test: tells if the argument is a (provable) prime or not.</p>\n-     * It uses the Miller-Rabin probabilistic test in such a way that result is always guaranteed: it uses the firsts prime numbers as successive base\n-     * (see Handbook of applied cryptography by Menezes, table 4.1)\n+     * Primality test: tells if the argument is a (provable) prime or not.\n+     * <p>\n+     * It uses the Miller-Rabin probabilistic test in such a way that result is always guaranteed:\n+     * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n+     * by Menezes, table 4.1).\n      *\n      * @param n number to test.\n-     * @return true if n is prime. (All numbers <2 return false).\n+     * @return true if n is prime. (All numbers &lt; 2 return false).\n      */\n     public static boolean isPrime(int n) {\n         if (n < 2) {\n      *\n      * @param n a positive number.\n      * @return the smallest prime superior or equal to n.\n-     * @throws MathIllegalArgumentException if n <0.\n+     * @throws MathIllegalArgumentException if n &lt; 0.\n      */\n     public static int nextPrime(int n) {\n         if (n < 0) {\n             return n;\n         }\n \n-        //prepare entry in the +2, +4 loop:\n-        //n should not be a multiple of 3\n+        // prepare entry in the +2, +4 loop:\n+        // n should not be a multiple of 3\n         final int rem = n % 3;\n-        if (0 == rem) {// if n%3==0\n-            n += 2;//n%3==2\n-        } else if (1 == rem) {//if n%3==1\n-            //if (isPrime(n)) return n;\n-            n += 4;//n%3==2\n+        if (0 == rem) { // if n % 3 == 0\n+            n += 2; // n % 3 == 2\n+        } else if (1 == rem) { // if n % 3 == 1\n+            // if (isPrime(n)) return n;\n+            n += 4; // n % 3 == 2\n         }\n-        while (true) { //this loop skips all multiple of 3\n+        while (true) { // this loop skips all multiple of 3\n             if (isPrime(n)) {\n                 return n;\n             }\n-            n += 2;//n%3==1\n+            n += 2; // n % 3 == 1\n             if (isPrime(n)) {\n                 return n;\n             }\n-            n += 4;//n%3==2\n+            n += 4; // n % 3 == 2\n         }\n     }\n \n     /**\n      * Prime factors decomposition\n      *\n-     * @param n number to factorize: must be >=2\n+     * @param n number to factorize: must be &ge; 2\n      * @return list of prime factors of n\n-     * @throws MathIllegalArgumentException if n <2.\n+     * @throws MathIllegalArgumentException if n &lt; 2.\n      */\n     public static List<Integer> primeFactors(int n) {\n \n         if (n < 2) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n         }\n-        //slower than trial div unless we do an awful lot of computation (then it finally gets JIT-compiled efficiently\n-        //List<Integer> out = PollardRho.primeFactors(n);\n+        // slower than trial div unless we do an awful lot of computation\n+        // (then it finally gets JIT-compiled efficiently\n+        // List<Integer> out = PollardRho.primeFactors(n);\n         return SmallPrimes.trialDivision(n);\n \n     }\n--- a/src/main/java/org/apache/commons/math3/primes/SmallPrimes.java\n+++ b/src/main/java/org/apache/commons/math3/primes/SmallPrimes.java\n class SmallPrimes {\n \n     /**\n-     * The 512 firsts prime numbers\n+     * The 512 firsts prime numbers.\n+     * <p>\n      * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n-     * As a result, <code>int</code> numbers which are not reduced by those primes are garanteed to be either prime or semi prime.\n+     * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n+     * to be either prime or semi prime.\n      */\n     public static final int[] PRIMES = {2,\n             3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n             3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433,\n             3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581,\n             3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671};\n-    /**\n-     * The last number in PRIMES\n-     */\n+\n+    /** The last number in PRIMES. */\n     public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];\n \n     /**\n-     * Only static methods in this class\n+     * Hide utility class.\n      */\n     private SmallPrimes() {\n     }\n \n     /**\n      * Extract small factors.\n-     * @param n the number to factor, must be >0.\n+     * @param n the number to factor, must be &gt; 0.\n      * @param factors the list where to add the factors.\n      * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n      */\n     }\n \n     /**\n-     * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>\n+     * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n      * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n      * @param maxFactor the upper bound of trial division: if it is reach, the methods gives up and return n.\n      * @param factors the list where to add the factors.\n     }\n \n     /**\n-     * Factorization by trial division\n+     * Factorization by trial division.\n      * @param n the number to factorize\n      * @return the list of prime factors of n\n      */\n \n     /**\n      * Miller-Rabin probabilistic primality test for int type, used in such a way that result is always guaranteed.\n-     * It uses the prime numbers as successive base therefore it is garanteed to be always correct. (see Handbook of applied cryptography by Menezes, table 4.1)\n+     * <p>\n+     * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n+     * (see Handbook of applied cryptography by Menezes, table 4.1)\n      *\n-     * @param n number to test: an odd integer >= 3\n+     * @param n number to test: an odd integer &ge; 3\n      * @return true if n is prime. false if n is definitely composite.\n      */\n     public static boolean millerRabinPrimeTest(final int n) {\n                     y = (int) (square % n);\n                     if (1 == y) {\n                         return false;\n-                    } //definitely composite\n+                    } // definitely composite\n                     j++;\n                 }\n                 if (nMinus1 != y) {\n                     return false;\n-                } //definitely composite\n+                } // definitely composite\n             }\n         }\n-        return true; //definitely prime\n+        return true; // definitely prime\n     }\n }\n ", "timestamp": 1363123926, "metainfo": ""}