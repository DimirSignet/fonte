{"sha": "53e990d4e008f16d6fba238001ba2ddf33d71b8f", "log": "Javadoc fixes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/primes/PollardRho.java\n+++ b/src/main/java/org/apache/commons/math3/primes/PollardRho.java\n      * <p>\n      * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n      * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n-     * rho implementations. It also batch several gcd computation into 1.\n+     * rho implementations. It also batches several gcd computation into 1.\n      * <p>\n-     * The backtracking is not implemented as we deal only with semi-prime.\n+     * The backtracking is not implemented as we deal only with semi-primes.\n      *\n      * @param n number to factor, must be semi-prime.\n      * @return a prime factor of n.\n--- a/src/main/java/org/apache/commons/math3/primes/Primes.java\n+++ b/src/main/java/org/apache/commons/math3/primes/Primes.java\n     /**\n      * Primality test: tells if the argument is a (provable) prime or not.\n      * <p>\n-     * It uses the Miller-Rabin probabilistic test in such a way that result is always guaranteed:\n+     * It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed:\n      * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n      * by Menezes, table 4.1).\n      *\n     }\n \n     /**\n-     * Return the smallest prime superior or equal to n.\n+     * Return the smallest prime greater than or equal to n.\n      *\n      * @param n a positive number.\n-     * @return the smallest prime superior or equal to n.\n+     * @return the smallest prime greater than or equal to n.\n      * @throws MathIllegalArgumentException if n &lt; 0.\n      */\n     public static int nextPrime(int n) {\n--- a/src/main/java/org/apache/commons/math3/primes/SmallPrimes.java\n+++ b/src/main/java/org/apache/commons/math3/primes/SmallPrimes.java\n class SmallPrimes {\n \n     /**\n-     * The 512 firsts prime numbers.\n+     * The first 512 prime numbers.\n      * <p>\n      * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n      * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n     /**\n      * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n      * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n-     * @param maxFactor the upper bound of trial division: if it is reach, the methods gives up and return n.\n+     * @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.\n      * @param factors the list where to add the factors.\n      * @return  n or 1 if factorization is completed.\n      */\n \n     /**\n      * Factorization by trial division.\n-     * @param n the number to factorize\n+     * @param n the number to factor\n      * @return the list of prime factors of n\n      */\n     public static List<Integer> trialDivision(int n){\n     }\n \n     /**\n-     * Miller-Rabin probabilistic primality test for int type, used in such a way that result is always guaranteed.\n+     * Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.\n      * <p>\n      * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n      * (see Handbook of applied cryptography by Menezes, table 4.1)", "timestamp": 1364618752, "metainfo": ""}