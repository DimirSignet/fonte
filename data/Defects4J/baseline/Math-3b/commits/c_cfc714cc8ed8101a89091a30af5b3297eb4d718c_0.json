{"sha": "cfc714cc8ed8101a89091a30af5b3297eb4d718c", "log": "Improved speed of several FastMath methods.  Double.doubleToLongBits replaced with Double.doubleToRawLongBits at several places.  JIRA: MATH-953  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n         if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n             return d; // These are un-normalised - don't try to convert\n         }\n-        long xl = Double.doubleToLongBits(d);\n+        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back\n         xl = xl & MASK_30BITS; // Drop low order bits\n         return Double.longBitsToDouble(xl);\n     }\n         if (x==0) { // Handle special case of +0/-0\n             return Double.NEGATIVE_INFINITY;\n         }\n-        long bits = Double.doubleToLongBits(x);\n+        long bits = Double.doubleToRawLongBits(x);\n \n         /* Handle special cases of negative input, and NaN */\n         if ((bits & 0x8000000000000000L) != 0 || x != x) {\n \n \n         if (x == 0) {\n-            long bits = Double.doubleToLongBits(x);\n+            long bits = Double.doubleToRawLongBits(x);\n             if ((bits & 0x8000000000000000L) != 0) {\n                 // -zero\n                 long yi = (long) y;\n     private static void reducePayneHanek(double x, double result[])\n     {\n         /* Convert input double to bits */\n-        long inbits = Double.doubleToLongBits(x);\n+        long inbits = Double.doubleToRawLongBits(x);\n         int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n \n         /* Convert to fixed point representation */\n \n         /* Check for zero and negative zero */\n         if (xa == 0.0) {\n-            long bits = Double.doubleToLongBits(x);\n+            long bits = Double.doubleToRawLongBits(x);\n             if (bits < 0) {\n                 return -0.0;\n             }\n \n         /* Check for zero and negative zero */\n         if (xa == 0.0) {\n-            long bits = Double.doubleToLongBits(x);\n+            long bits = Double.doubleToRawLongBits(x);\n             if (bits < 0) {\n                 return -0.0;\n             }\n      */\n     public static double cbrt(double x) {\n       /* Convert input double to bits */\n-      long inbits = Double.doubleToLongBits(x);\n+      long inbits = Double.doubleToRawLongBits(x);\n       int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n       boolean subnormal = false;\n \n           /* Subnormal, so normalize */\n           subnormal = true;\n           x *= 1.8014398509481984E16;  // 2^54\n-          inbits = Double.doubleToLongBits(x);\n+          inbits = Double.doubleToRawLongBits(x);\n           exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n       }\n \n         if (Double.isInfinite(x)) {\n             return Double.POSITIVE_INFINITY;\n         }\n-        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n+        return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n     }\n \n     /**\n         }\n \n         // decompose d\n-        final long bits = Double.doubleToLongBits(d);\n+        final long bits = Double.doubleToRawLongBits(d);\n         final long sign = bits & 0x8000000000000000L;\n         int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n         long mantissa   = bits & 0x000fffffffffffffL;\n         }\n         // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n         // are handled just as normal numbers\n-\n-        final long bits = Double.doubleToLongBits(d);\n+        // can use raw bits since already dealt with infinity and NaN\n+        final long bits = Double.doubleToRawLongBits(d);\n         final long sign = bits & 0x8000000000000000L;\n         if ((direction < d) ^ (sign == 0L)) {\n             return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n         // highest order bit of m and s is the same and one otherwise.\n         // So (m^s) will be positive if both m and s have the same sign\n         // and negative otherwise.\n-        final long m = Double.doubleToLongBits(magnitude);\n-        final long s = Double.doubleToLongBits(sign);\n+        final long m = Double.doubleToRawLongBits(magnitude); // don't care about NaN\n+        final long s = Double.doubleToRawLongBits(sign);\n         if ((m^s) >= 0) {\n             return magnitude;\n         }\n         // highest order bit of m and s is the same and one otherwise.\n         // So (m^s) will be positive if both m and s have the same sign\n         // and negative otherwise.\n-        final int m = Float.floatToIntBits(magnitude);\n-        final int s = Float.floatToIntBits(sign);\n+        final int m = Float.floatToRawIntBits(magnitude);\n+        final int s = Float.floatToRawIntBits(sign);\n         if ((m^s) >= 0) {\n             return magnitude;\n         }\n      * @return exponent for d in IEEE754 representation, without bias\n      */\n     public static int getExponent(final double d) {\n-        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n+        // NaN and Infinite will return 1024 anywho so can use raw bits\n+        return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n     }\n \n     /**\n      * @return exponent for d in IEEE754 representation, without bias\n      */\n     public static int getExponent(final float f) {\n-        return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n+        // NaN and Infinite will return the same exponent anywho so can use raw bits\n+        return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127;\n     }\n \n     /**", "timestamp": 1364206791, "metainfo": ""}