{"sha": "6c9d06a658d87c01fb02d1efce15bf6b74eb7aab", "log": "Added a way to trigger only increasing or decreasing events in ODE.  The method used is completely different from what was suggested in the request report. It is fully compatible with previous versions and most importantly has no side effects on users that do not need this feature, as it is based on an upstream filtering of the event definition function. The events detection logic is not modified and it fact it does not even know events are filtered before they are detected.  JIRA: MATH-811  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ode/events/EventFilter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ode.events;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math3.ode.FirstOrderIntegrator;\n+\n+\n+/** Wrapper used to detect only increasing or decreasing events.\n+ *\n+ * <p>General {@link EventHandler events} are defined implicitely\n+ * by a {@link EventHandler#g(double, double[]) g function} crossing\n+ * zero. This function needs to be continuous in the event neighborhood,\n+ * and its sign must remain consistent between events. This implies that\n+ * during an ODE integration, events triggered are alternately events\n+ * for which the function increases from negative to positive values,\n+ * and events for which the function decreases from positive to\n+ * negative values.\n+ * </p>\n+ *\n+ * <p>Sometimes, users are only interested in one type of event (say\n+ * increasing events for example) and not in the other type. In these\n+ * cases, looking precisely for all events location and triggering\n+ * events that will later be ignored is a waste of computing time.</p>\n+ *\n+ * <p>Users can wrap a regular {@link EventHandler event handler} in\n+ * an instance of this class and provide this wrapping instance to\n+ * the {@link FirstOrderIntegrator ODE solver} in order to avoid wasting\n+ * time looking for uninteresting events. The wrapper will intercept\n+ * the calls to the {@link EventHandler#g(double, double[]) g function}\n+ * and to the {@link EventHandler#eventOccurred(double, double[], boolean)\n+ * eventOccurred} method in order to ignore uninteresting events. The\n+ * wrapped regular {@link EventHandler event handler} will the see only\n+ * the interesting events, i.e. either only {@code increasing} events or\n+ * {@code decreasing} events. the number of calls to the {@link\n+ * EventHandler#g(double, double[]) g function} will also be reduced.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+\n+public class EventFilter implements EventHandler {\n+\n+    /** Number of past transformers updates stored. */\n+    private static final int HISTORY_SIZE = 100;\n+\n+    /** Wrapped event handler. */\n+    private final EventHandler rawHandler;\n+\n+    /** Filter to use. */\n+    private final FilterType filter;\n+\n+    /** Transformers of the g function. */\n+    private final Transformer[] transformers;\n+\n+    /** Update time of the transformers. */\n+    private final double[] updates;\n+\n+    /** Indicator for forward integration. */\n+    private boolean forward;\n+\n+    /** Extreme time encountered so far. */\n+    private double extremeT;\n+\n+    /** Wrap an {@link EventHandler event handler}.\n+     * @param rawHandler event handler to wrap\n+     * @param filter filter to use\n+     */\n+    public EventFilter(final EventHandler rawHandler, final FilterType filter) {\n+        this.rawHandler   = rawHandler;\n+        this.filter       = filter;\n+        this.transformers = new Transformer[HISTORY_SIZE];\n+        this.updates      = new double[HISTORY_SIZE];\n+    }\n+\n+    /**  {@inheritDoc} */\n+    public void init(double t0, double[] y0, double t) {\n+\n+        // delegate to raw handler\n+        rawHandler.init(t0, y0, t);\n+\n+        // initialize events triggering logic\n+        forward  = t >= t0;\n+        extremeT = forward ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+        Arrays.fill(transformers, Transformer.UNINITIALIZED);\n+        Arrays.fill(updates, extremeT);\n+\n+    }\n+\n+    /**  {@inheritDoc} */\n+    public double g(double t, double[] y) {\n+\n+        final double rawG = rawHandler.g(t, y);\n+\n+        // search which transformer should be applied to g\n+        if (forward) {\n+            final int last = transformers.length - 1;\n+            if (extremeT < t) {\n+                // we are at the forward end of the history\n+\n+                // check if a new rough root has been crossed\n+                final Transformer previous = transformers[last];\n+                final Transformer next     = filter.selectTransformer(previous, rawG, forward);\n+                if (next != previous) {\n+                    // there is a root somewhere between extremeT end t\n+                    // the new transformer, which is valid on both sides of the root,\n+                    // so it is valid for t (this is how we have just computed it above),\n+                    // but it was already valid before, so we store the switch at extremeT\n+                    // for safety, to ensure the previous transformer is not applied too\n+                    // close of the root\n+                    System.arraycopy(updates,      1, updates,      0, last);\n+                    System.arraycopy(transformers, 1, transformers, 0, last);\n+                    updates[last]      = extremeT;\n+                    transformers[last] = next;\n+                }\n+\n+                extremeT = t;\n+\n+                // apply the transform\n+                return next.transformed(rawG);\n+\n+            } else {\n+                // we are in the middle of the history\n+\n+                // select the transformer\n+                for (int i = last; i > 0; --i) {\n+                    if (updates[i] <= t) {\n+                        // apply the transform\n+                        return transformers[i].transformed(rawG);\n+                    }\n+                }\n+\n+                return transformers[0].transformed(rawG);\n+\n+            }\n+        } else {\n+            if (t < extremeT) {\n+                // we are at the backward end of the history\n+\n+                // check if a new rough root has been crossed\n+                final Transformer previous = transformers[0];\n+                final Transformer next     = filter.selectTransformer(previous, rawG, forward);\n+                if (next != previous) {\n+                    // there is a root somewhere between extremeT end t\n+                    // the new transformer, which is valid on both sides of the root,\n+                    // so it is valid for t (this is how we have just computed it above),\n+                    // but it was already valid before, so we store the switch at extremeT\n+                    // for safety, to ensure the previous transformer is not applied too\n+                    // close of the root\n+                    System.arraycopy(updates,      0, updates,      1, updates.length - 1);\n+                    System.arraycopy(transformers, 0, transformers, 1, transformers.length - 1);\n+                    updates[0]      = extremeT;\n+                    transformers[0] = next;\n+                }\n+\n+                extremeT = t;\n+\n+                // apply the transform\n+                return next.transformed(rawG);\n+\n+            } else {\n+                // we are in the middle of the history\n+\n+                // select the transformer\n+                for (int i = 0; i < updates.length - 1; ++i) {\n+                    if (t <= updates[i]) {\n+                        // apply the transform\n+                        return transformers[i].transformed(rawG);\n+                    }\n+                }\n+\n+                return transformers[updates.length - 1].transformed(rawG);\n+\n+            }\n+       }\n+\n+    }\n+\n+    /**  {@inheritDoc} */\n+    public Action eventOccurred(double t, double[] y, boolean increasing) {\n+        // delegate to raw handler, fixing increasing status on the fly\n+        return rawHandler.eventOccurred(t, y, filter.getTriggeredIncreasing());\n+    }\n+\n+    /**  {@inheritDoc} */\n+    public void resetState(double t, double[] y) {\n+        // delegate to raw handler\n+        rawHandler.resetState(t, y);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ode/events/FilterType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ode.events;\n+\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.util.Precision;\n+\n+\n+/** Enumerate for {@link EventFilter filtering events}.\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+\n+public enum FilterType {\n+\n+    /** Constant for triggering only decreasing events.\n+     * <p>When this filter is used, the wrapped {@link EventHandler\n+     * event handler} {@link EventHandler#eventOccurred(double, double[],\n+     * boolean) eventOccurred} method will be called <em>only</em> with\n+     * its {@code increasing} argument set to false.</p>\n+     */\n+    TRIGGER_ONLY_DECREASING_EVENTS {\n+\n+        /**  {@inheritDoc} */\n+        protected boolean getTriggeredIncreasing() {\n+            return false;\n+        }\n+\n+        /** {@inheritDoc}\n+         * <p>\n+         * states scheduling for computing h(t,y) as an altered version of g(t, y)\n+         * <ul>\n+         * <li>0 are triggered events for which a zero is produced (here decreasing events)</li>\n+         * <li>X are ignored events for which zero is masked (here increasing events)</li>\n+         * </ul>\n+         * </p>\n+         * <pre>\n+         *  g(t)\n+         *             ___                     ___                     ___\n+         *            /   \\                   /   \\                   /   \\\n+         *           /     \\                 /     \\                 /     \\\n+         *          /  g>0  \\               /  g>0  \\               /  g>0  \\\n+         *         /         \\             /         \\             /         \\\n+         *  ----- X --------- 0 --------- X --------- 0 --------- X --------- 0 ---\n+         *       /             \\         /             \\         /             \\\n+         *      /               \\ g<0   /               \\  g<0  /               \\ g<0\n+         *     /                 \\     /                 \\     /                 \\     /\n+         * ___/                   \\___/                   \\___/                   \\___/\n+         * </pre>\n+         * <pre>\n+         *  h(t,y)) as an alteration of g(t,y)\n+         *             ___                                 ___         ___\n+         *    \\       /   \\                               /   \\       /   \\\n+         *     \\     /     \\ h=+g                        /     \\     /     \\\n+         *      \\   /       \\      h=min(-s,-g,+g)      /       \\   /       \\\n+         *       \\_/         \\                         /         \\_/         \\\n+         *  ------ ---------- 0 ----------_---------- 0 --------------------- 0 ---\n+         *                     \\         / \\         /                         \\\n+         *   h=max(+s,-g,+g)    \\       /   \\       /       h=max(+s,-g,+g)     \\    \n+         *                       \\     /     \\     / h=-g                        \\     /\n+         *                        \\___/       \\___/                               \\___/\n+         * </pre>\n+         * <p>\n+         * As shown by the figure above, several expressions are used to compute h,\n+         * depending on the current state:\n+         * <ul>\n+         *   <li>h = max(+s,-g,+g)</li>\n+         *   <li>h = +g</li>\n+         *   <li>h = min(-s,-g,+g)</li>\n+         *   <li>h = -g</li>\n+         * </ul>\n+         * where s is a tiny positive value: {@link Precision#SAFE_MIN}.\n+         * </p>\n+         */\n+        protected  Transformer selectTransformer(final Transformer previous,\n+                                                 final double g, final boolean forward) {\n+            if (forward) {\n+                switch (previous) {\n+                    case UNINITIALIZED :\n+                        // we are initializing the first point\n+                        if (g > 0) {\n+                            // initialize as if previous root (i.e. backward one) was an ignored increasing event\n+                            return Transformer.MAX;\n+                        } else if (g < 0) {\n+                            // initialize as if previous root (i.e. backward one) was a triggered decreasing event\n+                            return Transformer.PLUS;\n+                        } else {\n+                            // we are exactly at a root, we don't know if it is an increasing\n+                            // or a decreasing event, we remain in uninitialized state\n+                            return Transformer.UNINITIALIZED;\n+                        }\n+                    case PLUS  :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on an ignored increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MINUS :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on an ignored increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MAX;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MIN   :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on a triggered decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MINUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MAX   :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on a triggered decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.PLUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    default    :\n+                        // this should never happen\n+                        throw new MathInternalError();\n+                }\n+            } else {\n+                switch (previous) {\n+                    case UNINITIALIZED :\n+                        // we are initializing the first point\n+                        if (g > 0) {\n+                            // initialize as if previous root (i.e. forward one) was a triggered decreasing event\n+                            return Transformer.MINUS;\n+                        } else if (g < 0) {\n+                            // initialize as if previous root (i.e. forward one) was an ignored increasing event\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are exactly at a root, we don't know if it is an increasing\n+                            // or a decreasing event, we remain in uninitialized state\n+                            return Transformer.UNINITIALIZED;\n+                        }\n+                    case PLUS  :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on an ignored increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MAX;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MINUS :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on an ignored increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MIN   :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on a triggered decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.PLUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MAX   :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on a triggered decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MINUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    default    :\n+                        // this should never happen\n+                        throw new MathInternalError();\n+                }\n+            }\n+        }\n+\n+    },\n+\n+    /** Constant for triggering only increasing events.\n+     * <p>When this filter is used, the wrapped {@link EventHandler\n+     * event handler} {@link EventHandler#eventOccurred(double, double[],\n+     * boolean) eventOccurred} method will be called <em>only</em> with\n+     * its {@code increasing} argument set to true.</p>\n+     */\n+    TRIGGER_ONLY_INCREASING_EVENTS {\n+\n+        /**  {@inheritDoc} */\n+        protected boolean getTriggeredIncreasing() {\n+            return true;\n+        }\n+\n+        /** {@inheritDoc}\n+         * <p>\n+         * states scheduling for computing h(t,y) as an altered version of g(t, y)\n+         * <ul>\n+         * <li>0 are triggered events for which a zero is produced (here increasing events)</li>\n+         * <li>X are ignored events for which zero is masked (here decreasing events)</li>\n+         * </ul>\n+         * </p>\n+         * <pre>\n+         *  g(t)\n+         *             ___                     ___                     ___\n+         *            /   \\                   /   \\                   /   \\\n+         *           /     \\                 /     \\                 /     \\\n+         *          /  g>0  \\               /  g>0  \\               /  g>0  \\\n+         *         /         \\             /         \\             /         \\\n+         *  ----- 0 --------- X --------- 0 --------- X --------- 0 --------- X ---\n+         *       /             \\         /             \\         /             \\\n+         *      /               \\ g<0   /               \\  g<0  /               \\ g<0\n+         *     /                 \\     /                 \\     /                 \\     /\n+         * ___/                   \\___/                   \\___/                   \\___/\n+         * </pre>\n+         * <pre>\n+         *  h(t,y)) as an alteration of g(t,y)\n+         *                                     ___         ___\n+         *    \\                               /   \\       /   \\\n+         *     \\ h=-g                        /     \\     /     \\ h=-g\n+         *      \\      h=min(-s,-g,+g)      /       \\   /       \\      h=min(-s,-g,+g)\n+         *       \\                         /         \\_/         \\\n+         *  ------0 ----------_---------- 0 --------------------- 0 --------- _ ---\n+         *         \\         / \\         /                         \\         / \\\n+         *          \\       /   \\       /       h=max(+s,-g,+g)     \\       /   \\\n+         *           \\     /     \\     / h=+g                        \\     /     \\     /\n+         *            \\___/       \\___/                               \\___/       \\___/\n+         * </pre>\n+         * <p>\n+         * As shown by the figure above, several expressions are used to compute h,\n+         * depending on the current state:\n+         * <ul>\n+         *   <li>h = max(+s,-g,+g)</li>\n+         *   <li>h = +g</li>\n+         *   <li>h = min(-s,-g,+g)</li>\n+         *   <li>h = -g</li>\n+         * </ul>\n+         * where s is a tiny positive value: {@link Precision#SAFE_MIN}.\n+         * </p>\n+         */\n+        protected  Transformer selectTransformer(final Transformer previous,\n+                                                 final double g, final boolean forward) {\n+            if (forward) {\n+                switch (previous) {\n+                    case UNINITIALIZED :\n+                        // we are initializing the first point\n+                        if (g > 0) {\n+                            // initialize as if previous root (i.e. backward one) was a triggered increasing event\n+                            return Transformer.PLUS;\n+                        } else if (g < 0) {\n+                            // initialize as if previous root (i.e. backward one) was an ignored decreasing event\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are exactly at a root, we don't know if it is an increasing\n+                            // or a decreasing event, we remain in uninitialized state\n+                            return Transformer.UNINITIALIZED;\n+                        }\n+                    case PLUS  :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on an ignored decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MAX;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MINUS :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on an ignored decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MIN   :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on a triggered increasing event,\n+                            // we must change the transformer\n+                            return Transformer.PLUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MAX   :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on a triggered increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MINUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    default    :\n+                        // this should never happen\n+                        throw new MathInternalError();\n+                }\n+            } else {\n+                switch (previous) {\n+                    case UNINITIALIZED :\n+                        // we are initializing the first point\n+                        if (g > 0) {\n+                            // initialize as if previous root (i.e. forward one) was an ignored decreasing event\n+                            return Transformer.MAX;\n+                        } else if (g < 0) {\n+                            // initialize as if previous root (i.e. forward one) was a triggered increasing event\n+                            return Transformer.MINUS;\n+                        } else {\n+                            // we are exactly at a root, we don't know if it is an increasing\n+                            // or a decreasing event, we remain in uninitialized state\n+                            return Transformer.UNINITIALIZED;\n+                        }\n+                    case PLUS  :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on an ignored decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MIN;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MINUS :\n+                        if (g >= 0) {\n+                            // we have crossed the zero line on an ignored decreasing event,\n+                            // we must change the transformer\n+                            return Transformer.MAX;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MIN   :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on a triggered increasing event,\n+                            // we must change the transformer\n+                            return Transformer.MINUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    case MAX   :\n+                        if (g <= 0) {\n+                            // we have crossed the zero line on a triggered increasing event,\n+                            // we must change the transformer\n+                            return Transformer.PLUS;\n+                        } else {\n+                            // we are still in the same status\n+                            return previous;\n+                        }\n+                    default    :\n+                        // this should never happen\n+                        throw new MathInternalError();\n+                }\n+            }\n+        }\n+\n+    };\n+\n+    /** Get the increasing status of triggered events.\n+     * @return true if triggered events are increasing events\n+     */\n+    protected abstract boolean getTriggeredIncreasing();\n+\n+    /** Get next function transformer in the specified direction.\n+     * @param previous transformer active on the previous point with respect\n+     * to integration direction (may be null if no previous point is known)\n+     * @param g current value of the g function\n+     * @param forward true if integration goes forward\n+     * @return next transformer transformer\n+     */\n+    protected abstract Transformer selectTransformer(Transformer previous,\n+                                                     double g, boolean forward);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ode/events/Transformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ode.events;\n+\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+\n+\n+/** Transformer for {@link EventHandler#g(double, double[]) g functions}.\n+ * @see EventFilter\n+ * @see FilterType\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+enum Transformer {\n+\n+    /** Transformer computing transformed = 0.\n+     * <p>\n+     * This transformer is used when we initialize the filter, until we get at\n+     * least one non-zero value to select the proper transformer.\n+     * </p>\n+     */\n+    UNINITIALIZED {\n+        /**  {@inheritDoc} */\n+        protected double transformed(final double g) {\n+            return 0;\n+        }\n+    },\n+\n+    /** Transformer computing transformed = g.\n+     * <p>\n+     * When this transformer is applied, the roots of the original function\n+     * are preserved, with the same {@code increasing/decreasing} status.\n+     * </p>\n+     */\n+    PLUS {\n+        /**  {@inheritDoc} */\n+        protected double transformed(final double g) {\n+            return g;\n+        }\n+    },\n+\n+    /** Transformer computing transformed = -g.\n+     * <p>\n+     * When this transformer is applied, the roots of the original function\n+     * are preserved, with reversed {@code increasing/decreasing} status.\n+     * </p>\n+     */\n+    MINUS {\n+        /**  {@inheritDoc} */\n+        protected double transformed(final double g) {\n+            return -g;\n+        }\n+    },\n+\n+    /** Transformer computing transformed = min(-{@link Precision#SAFE_MIN}, -g, +g).\n+     * <p>\n+     * When this transformer is applied, the transformed function is\n+     * guaranteed to be always strictly negative (i.e. there are no roots).\n+     * </p>\n+     */\n+    MIN {\n+        /**  {@inheritDoc} */\n+        protected double transformed(final double g) {\n+            return FastMath.min(-Precision.SAFE_MIN, FastMath.min(-g, +g));\n+        }\n+    },\n+\n+    /** Transformer computing transformed = max(+{@link Precision#SAFE_MIN}, -g, +g).\n+     * <p>\n+     * When this transformer is applied, the transformed function is\n+     * guaranteed to be always strictly positive (i.e. there are no roots).\n+     * </p>\n+     */\n+    MAX {\n+        /**  {@inheritDoc} */\n+        protected double transformed(final double g) {\n+            return FastMath.max(+Precision.SAFE_MIN, FastMath.max(-g, +g));\n+        }\n+    };\n+\n+    /** Transform value of function g.\n+     * @param g raw value of function g\n+     * @return transformed value of function g\n+     */\n+    protected abstract double transformed(double g);\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/ode/events/EventFilterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.ode.events;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+\n+import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math3.ode.FirstOrderIntegrator;\n+import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937a;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class EventFilterTest {\n+\n+    @Test\n+    public void testHistoryIncreasingForward() {\n+\n+        // start point: g > 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    0.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, -1);\n+\n+        // start point: g = 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    0, 30.5 * FastMath.PI, FastMath.PI, -1);\n+\n+        // start point: g < 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    1.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, +1);\n+\n+    }\n+\n+    @Test\n+    public void testHistoryIncreasingBackward() {\n+\n+        // start point: g > 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    0.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1);\n+\n+        // start point: g = 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    0, -30.5 * FastMath.PI, FastMath.PI, +1);\n+\n+        // start point: g < 0\n+        testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS,\n+                    1.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1);\n+\n+    }\n+\n+    @Test\n+    public void testHistoryDecreasingForward() {\n+\n+        // start point: g > 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    0.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1);\n+\n+        // start point: g = 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    0, 30.5 * FastMath.PI, 0, +1);\n+\n+        // start point: g < 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    1.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1);\n+\n+    }\n+\n+    @Test\n+    public void testHistoryDecreasingBackward() {\n+\n+        // start point: g > 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    0.5 * FastMath.PI, -30.5 * FastMath.PI, 0, -1);\n+\n+        // start point: g = 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    0, -30.5 * FastMath.PI, 0, -1);\n+\n+        // start point: g < 0\n+        testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS,\n+                    1.5 * FastMath.PI, -30.5 * FastMath.PI, 0, +1);\n+\n+    }\n+\n+    public void testHistory(FilterType type, double t0, double t1, double refSwitch, double signEven) {\n+        Event onlyIncreasing = new Event(false, true);\n+        EventFilter eventFilter =\n+                new EventFilter(onlyIncreasing, type);\n+        eventFilter.init(t0, new double[] {1.0,  0.0}, t1);\n+\n+        // first pass to set up switches history for a long period\n+        double h = FastMath.copySign(0.05, t1 - t0);\n+        double n = (int) FastMath.floor((t1 - t0) / h);\n+        for (int i = 0; i < n; ++i) {\n+            double t = t0 + i * h;\n+            eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) });\n+        }\n+\n+        // verify old events are preserved, even if randomly accessed\n+        RandomGenerator rng = new Well19937a(0xb0e7401265af8cd3l);\n+        try {\n+            PrintStream out = new PrintStream(\"/home/luc/x.dat\");\n+        for (int i = 0; i < 5000; i++) {\n+            double t = t0 + (t1 - t0) * rng.nextDouble();\n+            double g = eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) });\n+            int turn = (int) FastMath.floor((t - refSwitch) / (2 * FastMath.PI));\n+            out.println(t + \" \" + g);\n+            if (turn % 2 == 0) {\n+                Assert.assertEquals( signEven * FastMath.sin(t), g, 1.0e-10);\n+            } else {\n+                Assert.assertEquals(-signEven * FastMath.sin(t), g, 1.0e-10);\n+            }\n+        }\n+        out.close();\n+        } catch (IOException ioe) {\n+            Assert.fail(ioe.getLocalizedMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testIncreasingOnly()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n+        double e = 1e-15;\n+        FirstOrderIntegrator integrator;\n+        integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);\n+        Event allEvents = new Event(true, true);\n+        integrator.addEventHandler(allEvents, 0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        Event onlyIncreasing = new Event(false, true);\n+        integrator.addEventHandler(new EventFilter(onlyIncreasing,\n+                                                   FilterType.TRIGGER_ONLY_INCREASING_EVENTS),\n+                                   0.1, e, 100,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        double t0 = 0.5 * FastMath.PI;\n+        double tEnd = 5.5 * FastMath.PI;\n+        double[] y = { 0.0, 1.0 };\n+        Assert.assertEquals(tEnd,\n+                            integrator.integrate(new SineCosine(), t0, y, tEnd, y),\n+                            1.0e-7);\n+\n+        Assert.assertEquals(5, allEvents.getEventCount());\n+        Assert.assertEquals(2, onlyIncreasing.getEventCount());\n+\n+    }\n+\n+    @Test\n+    public void testDecreasingOnly()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n+        double e = 1e-15;\n+        FirstOrderIntegrator integrator;\n+        integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);\n+        Event allEvents = new Event(true, true);\n+        integrator.addEventHandler(allEvents, 0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        Event onlyDecreasing = new Event(true, false);\n+        integrator.addEventHandler(new EventFilter(onlyDecreasing,\n+                                                   FilterType.TRIGGER_ONLY_DECREASING_EVENTS),\n+                                   0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        double t0 = 0.5 * FastMath.PI;\n+        double tEnd = 5.5 * FastMath.PI;\n+        double[] y = { 0.0, 1.0 };\n+        Assert.assertEquals(tEnd,\n+                            integrator.integrate(new SineCosine(), t0, y, tEnd, y),\n+                            1.0e-7);\n+\n+        Assert.assertEquals(5, allEvents.getEventCount());\n+        Assert.assertEquals(3, onlyDecreasing.getEventCount());\n+\n+    }\n+\n+    @Test\n+    public void testTwoOppositeFilters()\n+        throws DimensionMismatchException, NumberIsTooSmallException,\n+               MaxCountExceededException, NoBracketingException {\n+        double e = 1e-15;\n+        FirstOrderIntegrator integrator;\n+        integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7);\n+        Event allEvents = new Event(true, true);\n+        integrator.addEventHandler(allEvents, 0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        Event onlyIncreasing = new Event(false, true);\n+        integrator.addEventHandler(new EventFilter(onlyIncreasing,\n+                                                   FilterType.TRIGGER_ONLY_INCREASING_EVENTS),\n+                                   0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        Event onlyDecreasing = new Event(true, false);\n+        integrator.addEventHandler(new EventFilter(onlyDecreasing,\n+                                                   FilterType.TRIGGER_ONLY_DECREASING_EVENTS),\n+                                   0.1, e, 1000,\n+                                   new BracketingNthOrderBrentSolver(1.0e-7, 5));\n+        double t0 = 0.5 * FastMath.PI;\n+        double tEnd = 5.5 * FastMath.PI;\n+        double[] y = { 0.0, 1.0 };\n+        Assert.assertEquals(tEnd,\n+                            integrator.integrate(new SineCosine(), t0, y, tEnd, y),\n+                            1.0e-7);\n+\n+        Assert.assertEquals(5, allEvents.getEventCount());\n+        Assert.assertEquals(2, onlyIncreasing.getEventCount());\n+        Assert.assertEquals(3, onlyDecreasing.getEventCount());\n+\n+    }\n+\n+    private static class SineCosine implements FirstOrderDifferentialEquations {\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            yDot[0] =  y[1];\n+            yDot[1] = -y[0];\n+        }\n+    }\n+\n+    /** State events for this unit test. */\n+    protected static class Event implements EventHandler {\n+\n+        private final boolean expectDecreasing;\n+        private final boolean expectIncreasing;\n+        private int eventCount;\n+\n+        public Event(boolean expectDecreasing, boolean expectIncreasing) {\n+            this.expectDecreasing = expectDecreasing;\n+            this.expectIncreasing = expectIncreasing;\n+        }\n+\n+        public int getEventCount() {\n+            return eventCount;\n+        }\n+\n+        public void init(double t0, double[] y0, double t) {\n+            eventCount = 0;\n+        }\n+\n+        public double g(double t, double[] y) {\n+            return y[0];\n+        }\n+\n+        public Action eventOccurred(double t, double[] y, boolean increasing) {\n+            if (increasing) {\n+                Assert.assertTrue(expectIncreasing);\n+            } else {\n+                Assert.assertTrue(expectDecreasing);\n+            }\n+            eventCount++;\n+            return Action.RESET_STATE;\n+        }\n+\n+        public void resetState(double t, double[] y) {\n+            // in fact, we don't really reset anything for this test\n+        }\n+\n+    }\n+}", "timestamp": 1363702198, "metainfo": ""}