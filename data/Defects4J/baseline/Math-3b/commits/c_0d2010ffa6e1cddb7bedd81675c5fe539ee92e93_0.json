{"sha": "0d2010ffa6e1cddb7bedd81675c5fe539ee92e93", "log": "Added missing @since 3.2.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n         return compiler.getOrder();\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public double getReal() {\n         return data[0];\n     }\n         return data.clone();\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure add(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         ds.data[0] += a;\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure subtract(final double a) {\n         return add(-a);\n     }\n         return multiply((double) n);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure multiply(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         for (int i = 0; i < ds.data.length; ++i) {\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure divide(final double a) {\n         final DerivativeStructure ds = new DerivativeStructure(this);\n         for (int i = 0; i < ds.data.length; ++i) {\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure remainder(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure abs() {\n         if (Double.doubleToLongBits(data[0]) < 0) {\n             // we use the bits representation to also handle -0.0\n         }\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure ceil() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.ceil(data[0]));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure floor() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.floor(data[0]));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure rint() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n         return FastMath.round(data[0]);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure signum() {\n         return new DerivativeStructure(compiler.getFreeParameters(),\n                                        compiler.getOrder(),\n                                        FastMath.signum(data[0]));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure copySign(final DerivativeStructure sign){\n         long m = Double.doubleToLongBits(data[0]);\n         long s = Double.doubleToLongBits(sign.data[0]);\n         return negate(); // flip sign\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure copySign(final double sign) {\n         long m = Double.doubleToLongBits(data[0]);\n         long s = Double.doubleToLongBits(sign);\n         return FastMath.getExponent(data[0]);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure scalb(final int n) {\n         final DerivativeStructure ds = new DerivativeStructure(compiler);\n         for (int i = 0; i < ds.data.length; ++i) {\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure hypot(final DerivativeStructure y)\n         throws DimensionMismatchException {\n      * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)\n         throws DimensionMismatchException {\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure sqrt() {\n         return rootN(2);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure cbrt() {\n         return rootN(3);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure rootN(final int n) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.rootN(data, 0, n, result.data, 0);\n         };\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure pow(final double p) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.pow(data, 0, p, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure pow(final int n) {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.pow(data, 0, n, result.data, 0);\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure pow(final DerivativeStructure e)\n         throws DimensionMismatchException {\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure exp() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.exp(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure expm1() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.expm1(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure log() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure log1p() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.log1p(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure cos() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.cos(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure sin() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.sin(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure tan() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.tan(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure acos() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.acos(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure asin() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.asin(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure atan() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.atan(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure atan2(final DerivativeStructure x)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(x.compiler);\n      * @return atan2(y, x)\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\n         throws DimensionMismatchException {\n         return y.atan2(x);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure cosh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.cosh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure sinh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.sinh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure tanh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.tanh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure acosh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.acosh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure asinh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.asinh(data, 0, result.data, 0);\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public DerivativeStructure atanh() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         compiler.atanh(data, 0, result.data, 0);\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n         throws DimensionMismatchException {\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n         throws DimensionMismatchException {\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n                                                  final DerivativeStructure a2, final DerivativeStructure b2)\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n                                                  final double a2, final DerivativeStructure b2)\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n                                                  final DerivativeStructure a2, final DerivativeStructure b2,\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n                                                  final double a2, final DerivativeStructure b2,\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n                                                  final DerivativeStructure a2, final DerivativeStructure b2,\n     /** {@inheritDoc}\n      * @exception DimensionMismatchException if number of free parameters\n      * or orders do not match\n+     * @since 3.2\n      */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n                                                  final double a2, final DerivativeStructure b2,\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n \n     /** Get the absolute value of instance.\n      * @return absolute value of instance\n+     * @since 3.2\n      */\n     public Dfp abs() {\n         Dfp result = newInstance(this);\n      *  That is round to nearest integer unless both are equidistant.\n      *  In which case round to the even one.\n      *  @return rounded value\n+     * @since 3.2\n      */\n     public Dfp rint() {\n         return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n     /** Round to an integer using the round floor mode.\n      * That is, round toward -Infinity\n      *  @return rounded value\n+     * @since 3.2\n      */\n     public Dfp floor() {\n         return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n     /** Round to an integer using the round ceil mode.\n      * That is, round toward +Infinity\n      *  @return rounded value\n+     * @since 3.2\n      */\n     public Dfp ceil() {\n         return trunc(DfpField.RoundingMode.ROUND_CEIL);\n     /** Returns the IEEE remainder.\n      * @param d divisor\n      * @return this less n &times; d, where n is the integer closest to this/d\n+     * @since 3.2\n      */\n     public Dfp remainder(final Dfp d) {\n \n \n     /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n      *  @return integer base 10 logarithm\n+     * @since 3.2\n      */\n     public int intLog10()  {\n         if (mant[mant.length-1] > 1000) {\n \n     /** Compute the square root.\n      * @return square root of the instance\n+     * @since 3.2\n      */\n     public Dfp sqrt() {\n \n--- a/src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java\n         return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     @Override\n     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n         if (p < 0.0 || p > 1.0) {\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n      * @param v2 Second vector (will be put at back of the new vector).\n      * @throws NullArgumentException if {@code v1} or {@code v2} is\n      * {@code null}.\n+     * @since 3.2\n      */\n     public ArrayFieldVector(FieldVector<T> v1, T[] v2)\n             throws NullArgumentException {\n      * @param v2 Second vector (will be put at back of the new vector).\n      * @throws NullArgumentException if {@code v1} or {@code v2} is\n      * {@code null}.\n+     * @since 3.2\n      */\n     public ArrayFieldVector(T[] v1, FieldVector<T> v2)\n             throws NullArgumentException {\n--- a/src/main/java/org/apache/commons/math3/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/QRDecomposition.java\n \n     /** Decompose matrix.\n      * @param matrix transposed matrix\n+     * @since 3.2\n      */\n     protected void decompose(double[][] matrix) {\n         for (int minor = 0; minor < FastMath.min(qrt.length, qrt[0].length); minor++) {\n     /** Perform Householder reflection for a minor A(minor, minor) of A.\n      * @param minor minor index\n      * @param matrix transposed matrix\n+     * @since 3.2\n      */\n     protected void performHouseholderReflection(int minor, double[][] matrix) {\n \n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n      * </p>\n      *\n      * @return the Random used to generate random data\n+     * @since 3.2\n      */\n     public RandomGenerator getRandomGenerator() {\n         if (rand == null) {\n--- a/src/main/java/org/apache/commons/math3/stat/inference/OneWayAnova.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/OneWayAnova.java\n      * at least two values\n      * @throws ConvergenceException if the p-value can not be computed due to a convergence error\n      * @throws MaxCountExceededException if the maximum number of iterations is exceeded\n+     * @since 3.2\n      */\n     public double anovaPValue(final Collection<SummaryStatistics> categoryData,\n                               final boolean allowOneElementData)\n--- a/src/main/java/org/apache/commons/math3/util/Decimal64.java\n+++ b/src/main/java/org/apache/commons/math3/util/Decimal64.java\n         return Double.isNaN(value);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public double getReal() {\n         return value;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 add(final double a) {\n         return new Decimal64(value + a);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 subtract(final double a) {\n         return new Decimal64(value - a);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 multiply(final double a) {\n         return new Decimal64(value * a);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 divide(final double a) {\n         return new Decimal64(value / a);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 remainder(final double a) {\n         return new Decimal64(FastMath.IEEEremainder(value, a));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 remainder(final Decimal64 a) {\n         return new Decimal64(FastMath.IEEEremainder(value, a.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 abs() {\n         return new Decimal64(FastMath.abs(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 ceil() {\n         return new Decimal64(FastMath.ceil(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 floor() {\n         return new Decimal64(FastMath.floor(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 rint() {\n         return new Decimal64(FastMath.rint(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public long round() {\n         return FastMath.round(value);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 signum() {\n         return new Decimal64(FastMath.signum(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 copySign(final Decimal64 sign) {\n         return new Decimal64(FastMath.copySign(value, sign.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 copySign(final double sign) {\n         return new Decimal64(FastMath.copySign(value, sign));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 scalb(final int n) {\n         return new Decimal64(FastMath.scalb(value, n));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 hypot(final Decimal64 y) {\n         return new Decimal64(FastMath.hypot(value, y.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 sqrt() {\n         return new Decimal64(FastMath.sqrt(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 cbrt() {\n         return new Decimal64(FastMath.cbrt(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 rootN(final int n) {\n         if (value < 0) {\n             return new Decimal64(-FastMath.pow(-value, 1.0 / n));\n         }\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 pow(final double p) {\n         return new Decimal64(FastMath.pow(value, p));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 pow(final int n) {\n         return new Decimal64(FastMath.pow(value, n));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 pow(final Decimal64 e) {\n         return new Decimal64(FastMath.pow(value, e.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 exp() {\n         return new Decimal64(FastMath.exp(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 expm1() {\n         return new Decimal64(FastMath.expm1(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 log() {\n         return new Decimal64(FastMath.log(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 log1p() {\n         return new Decimal64(FastMath.log1p(value));\n     }\n \n     /** Base 10 logarithm.\n      * @return base 10 logarithm of the instance\n+     * @since 3.2\n      */\n     public Decimal64 log10() {\n         return new Decimal64(FastMath.log10(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 cos() {\n         return new Decimal64(FastMath.cos(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 sin() {\n         return new Decimal64(FastMath.sin(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 tan() {\n         return new Decimal64(FastMath.tan(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 acos() {\n         return new Decimal64(FastMath.acos(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 asin() {\n         return new Decimal64(FastMath.asin(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 atan() {\n         return new Decimal64(FastMath.atan(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 atan2(final Decimal64 x) {\n         return new Decimal64(FastMath.atan2(value, x.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 cosh() {\n         return new Decimal64(FastMath.cosh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 sinh() {\n         return new Decimal64(FastMath.sinh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 tanh() {\n         return new Decimal64(FastMath.tanh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 acosh() {\n         return new Decimal64(FastMath.acosh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 asinh() {\n         return new Decimal64(FastMath.asinh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 atanh() {\n         return new Decimal64(FastMath.atanh(value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final Decimal64[] a, final Decimal64[] b)\n         throws DimensionMismatchException {\n         if (a.length != b.length) {\n         return new Decimal64(MathArrays.linearCombination(aDouble, bDouble));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final double[] a, final Decimal64[] b)\n         throws DimensionMismatchException {\n         if (a.length != b.length) {\n         return new Decimal64(MathArrays.linearCombination(a, bDouble));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n                                        final Decimal64 a2, final Decimal64 b2) {\n         return new Decimal64(MathArrays.linearCombination(a1.value, b1.value,\n                                                           a2.value, b2.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n                                        final double a2, final Decimal64 b2) {\n         return new Decimal64(MathArrays.linearCombination(a1, b1.value,\n                                                           a2, b2.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n                                        final Decimal64 a2, final Decimal64 b2,\n                                        final Decimal64 a3, final Decimal64 b3) {\n                                                           a3.value, b3.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n                                        final double a2, final Decimal64 b2,\n                                        final double a3, final Decimal64 b3) {\n                                                           a3, b3.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final Decimal64 a1, final Decimal64 b1,\n                                        final Decimal64 a2, final Decimal64 b2,\n                                        final Decimal64 a3, final Decimal64 b3,\n                                                           a4.value, b4.value));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @since 3.2\n+     */\n     public Decimal64 linearCombination(final double a1, final Decimal64 b1,\n                                        final double a2, final Decimal64 b2,\n                                        final double a3, final Decimal64 b3,\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n      * @param arr Array to scale.\n      * @param val Scalar.\n      * @return scaled copy of array with each entry multiplied by val.\n+     * @since 3.2\n      */\n     public static double[] scale(double val, final double[] arr) {\n         double[] newArr = new double[arr.length];\n      *\n      * @param arr Array to scale\n      * @param val Scalar\n+     * @since 3.2\n      */\n     public static void scaleInPlace(double val, final double[] arr) {\n         for (int i = 0; i < arr.length; i++) {\n       * @param field field to which array elements belong\n       * @param length of the array\n       * @return a new array\n+      * @since 3.2\n       */\n      public static <T> T[] buildArray(final Field<T> field, final int length) {\n          @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n       * @param <T> the type of the field elements\n       * @param field field to which array elements belong\n       * @param rows number of rows in the array\n-     * @param columns number of columns (may be negative to build partial\n-     * arrays in the same way <code>new Field[rows][]</code> works)\n+      * @param columns number of columns (may be negative to build partial\n+      * arrays in the same way <code>new Field[rows][]</code> works)\n       * @return a new array\n+      * @since 3.2\n       */\n      @SuppressWarnings(\"unchecked\")\n     public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {", "timestamp": 1364541918, "metainfo": ""}