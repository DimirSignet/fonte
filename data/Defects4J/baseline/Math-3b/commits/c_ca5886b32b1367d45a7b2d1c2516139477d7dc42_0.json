{"sha": "ca5886b32b1367d45a7b2d1c2516139477d7dc42", "log": "Renamed Discrete*Distribution to Enumerated*Distribution, improved javadoc, made some exceptions more precise. JIRA: MATH-942.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * <p>A generic implementation of a\n+ * <a href=\"http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution\">\n+ * discrete probability distribution (Wikipedia)</a> over a finite sample space,\n+ * based on an enumerated list of &lt;value, probability&gt; pairs.  Input probabilities must all be non-negative,\n+ * but zero values are allowed and their sum does not have to equal one. Constructors will normalize input\n+ * probabilities to make them sum to one.</p>\n+ *\n+ * <p>The list of <value, probability> pairs does not, strictly speaking, have to be a function and it can\n+ * contain null values.  The pmf created by the constructor will combine probabilities of equal values and\n+ * will treat null values as equal.  For example, if the list of pairs &lt;\"dog\", 0.2&gt;, &lt;null, 0.1&gt;,\n+ * &lt;\"pig\", 0.2&gt;, &lt;\"dog\", 0.1&gt;, &lt;null, 0.4&gt; is provided to the constructor, the resulting\n+ * pmf will assign mass of 0.5 to null, 0.3 to \"dog\" and 0.2 to null.</p>\n+ *\n+ * @param <T> type of the elements in the sample space.\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class EnumeratedDistribution<T> implements Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20123308L;\n+\n+    /**\n+     * RNG instance used to generate samples from the distribution.\n+     */\n+    protected final RandomGenerator random;\n+\n+    /**\n+     * List of random variable values.\n+     */\n+    private final List<T> singletons;\n+    /**\n+     * Probabilities of respective random variable values. For i = 0, ..., singletons.size() - 1,\n+     * probability[i] is the probability that a random variable following this distribution takes\n+     * the value singletons[i].\n+     */\n+    private final double[] probabilities;\n+\n+    /**\n+     * Create an enumerated distribution using the given probability mass function\n+     * enumeration.\n+     *\n+     * @param pmf probability mass function enumerated as a list of <T, probability>\n+     * pairs.\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedDistribution(final List<Pair<T, Double>> pmf)\n+        throws NotPositiveException, MathArithmeticException, NotFiniteNumberException, NotANumberException {\n+        this(new Well19937c(), pmf);\n+    }\n+\n+    /**\n+     * Create an enumerated distribution using the given random number generator\n+     * and probability mass function enumeration.\n+     *\n+     * @param rng random number generator.\n+     * @param pmf probability mass function enumerated as a list of <T, probability>\n+     * pairs.\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedDistribution(final RandomGenerator rng, final List<Pair<T, Double>> pmf)\n+        throws NotPositiveException, MathArithmeticException, NotFiniteNumberException, NotANumberException {\n+        random = rng;\n+\n+        singletons = new ArrayList<T>(pmf.size());\n+        final double[] probs = new double[pmf.size()];\n+\n+        for (int i = 0; i < pmf.size(); i++) {\n+            final Pair<T, Double> sample = pmf.get(i);\n+            singletons.add(sample.getKey());\n+            final double p = sample.getValue();\n+            if (p < 0) {\n+                throw new NotPositiveException(sample.getValue());\n+            }\n+            if (Double.isInfinite(p)) {\n+                throw new NotFiniteNumberException(p);\n+            }\n+            if (Double.isNaN(p)) {\n+                throw new NotANumberException();\n+            }\n+            probs[i] = p;\n+        }\n+\n+        probabilities = MathArrays.normalizeArray(probs, 1.0);\n+    }\n+\n+    /**\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed the new seed\n+     */\n+    public void reseedRandomGenerator(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * <p>For a random variable {@code X} whose values are distributed according to\n+     * this distribution, this method returns {@code P(X = x)}. In other words,\n+     * this method represents the probability mass function (PMF) for the\n+     * distribution.</p>\n+     *\n+     * <p>Note that if {@code x1} and {@code x2} satisfy {@code x1.equals(x2)},\n+     * or both are null, then {@code probability(x1) = probability(x2)}.</p>\n+     *\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at {@code x}\n+     */\n+    double probability(final T x) {\n+        double probability = 0;\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            if ((x == null && singletons.get(i) == null) ||\n+                (x != null && x.equals(singletons.get(i)))) {\n+                probability += probabilities[i];\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * <p>Return the probability mass function as a list of <value, probability> pairs.</p>\n+     *\n+     * <p>Note that if duplicate and / or null values were provided to the constructor\n+     * when creating this EnumeratedDistribution, the returned list will contain these\n+     * values.  If duplicates values exist, what is returned will not represent\n+     * a pmf (i.e., it is up to the caller to consolidate duplicate mass points).</p>\n+     *\n+     * @return the probability mass function.\n+     */\n+    public List<Pair<T, Double>> getPmf() {\n+        final List<Pair<T, Double>> samples = new ArrayList<Pair<T, Double>>(probabilities.length);\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            samples.add(new Pair<T, Double>(singletons.get(i), probabilities[i]));\n+        }\n+\n+        return samples;\n+    }\n+\n+    /**\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n+     */\n+    public T sample() {\n+        final double randomValue = random.nextDouble();\n+        double sum = 0;\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            sum += probabilities[i];\n+            if (randomValue < sum) {\n+                return singletons.get(i);\n+            }\n+        }\n+\n+        /* This should never happen, but it ensures we will return a correct\n+         * object in case the loop above has some floating point inequality\n+         * problem on the final iteration. */\n+        return singletons.get(singletons.size() - 1);\n+    }\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     *\n+     * @param sampleSize the number of random values to generate.\n+     * @return an array representing the random sample.\n+     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n+     * positive.\n+     */\n+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+        if (sampleSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                    sampleSize);\n+        }\n+\n+        final Object[] out = new Object[sampleSize];\n+\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     * <p>\n+     * If the requested samples fit in the specified array, it is returned\n+     * therein. Otherwise, a new array is allocated with the runtime type of\n+     * the specified array and the size of this collection.\n+     *\n+     * @param sampleSize the number of random values to generate.\n+     * @param array the array to populate.\n+     * @return an array representing the random sample.\n+     * @throws NotStrictlyPositiveException if {@code sampleSize} is not positive.\n+     * @throws NullArgumentException if {@code array} is null\n+     */\n+    public T[] sample(int sampleSize, final T[] array) throws NotStrictlyPositiveException {\n+        if (sampleSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n+        }\n+\n+        if (array == null) {\n+            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+        }\n+\n+        T[] out;\n+        if (array.length < sampleSize) {\n+            @SuppressWarnings(\"unchecked\") // safe as both are of type T\n+            final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), sampleSize);\n+            out = unchecked;\n+        } else {\n+            out = array;\n+        }\n+\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+\n+        return out;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * <p>Implementation of an integer-valued {@link EnumeratedDistribution}.</p>\n+ *\n+ * <p>Values with zero-probability are allowed but they do not extend the\n+ * support.<br/>\n+ * Duplicate values are allowed. Probabilities of duplicate values are combined\n+ * when computing cumulative probabilities and statistics.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class EnumeratedIntegerDistribution extends AbstractIntegerDistribution {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130308L;\n+\n+    /**\n+     * {@link EnumeratedDistribution} instance (using the {@link Integer} wrapper)\n+     * used to generate the pmf.\n+     */\n+    protected final EnumeratedDistribution<Integer> innerDistribution;\n+\n+    /**\n+     * Create a discrete distribution using the given probability mass function\n+     * definition.\n+     *\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedIntegerDistribution(final int[] singletons, final double[] probabilities)\n+    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,\n+           NotFiniteNumberException, NotANumberException{\n+        this(new Well19937c(), singletons, probabilities);\n+    }\n+\n+    /**\n+     * Create a discrete distribution using the given random number generator\n+     * and probability mass function definition.\n+     *\n+     * @param rng random number generator.\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedIntegerDistribution(final RandomGenerator rng,\n+                                       final int[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException,\n+                NotFiniteNumberException, NotANumberException {\n+        super(rng);\n+        if (singletons.length != probabilities.length) {\n+            throw new DimensionMismatchException(probabilities.length, singletons.length);\n+        }\n+\n+        final List<Pair<Integer, Double>> samples = new ArrayList<Pair<Integer, Double>>(singletons.length);\n+\n+        for (int i = 0; i < singletons.length; i++) {\n+            samples.add(new Pair<Integer, Double>(singletons[i], probabilities[i]));\n+        }\n+\n+        innerDistribution = new EnumeratedDistribution<Integer>(rng, samples);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double probability(final int x) {\n+        return innerDistribution.probability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double cumulativeProbability(final int x) {\n+        double probability = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() <= x) {\n+                probability += sample.getValue();\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum(singletons[i] * probabilities[i])}\n+     */\n+    public double getNumericalMean() {\n+        double mean = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {\n+            mean += sample.getValue() * sample.getKey();\n+        }\n+\n+        return mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}\n+     */\n+    public double getNumericalVariance() {\n+        double mean = 0;\n+        double meanOfSquares = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {\n+            mean += sample.getValue() * sample.getKey();\n+            meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();\n+        }\n+\n+        return meanOfSquares - mean * mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the lowest value with non-zero probability.\n+     *\n+     * @return the lowest value with non-zero probability.\n+     */\n+    public int getSupportLowerBound() {\n+        int min = Integer.MAX_VALUE;\n+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() < min && sample.getValue() > 0) {\n+                min = sample.getKey();\n+            }\n+        }\n+\n+        return min;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the highest value with non-zero probability.\n+     *\n+     * @return the highest value with non-zero probability.\n+     */\n+    public int getSupportUpperBound() {\n+        int max = Integer.MIN_VALUE;\n+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() > max && sample.getValue() > 0) {\n+                max = sample.getKey();\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int sample() {\n+        return innerDistribution.sample();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * <p>Implementation of a real-valued {@link EnumeratedDistribution}.\n+ *\n+ * <p>Values with zero-probability are allowed but they do not extend the\n+ * support.<br/>\n+ * Duplicate values are allowed. Probabilities of duplicate values are combined\n+ * when computing cumulative probabilities and statistics.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class EnumeratedRealDistribution extends AbstractRealDistribution {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130308L;\n+\n+    /**\n+     * {@link EnumeratedDistribution} (using the {@link Double} wrapper)\n+     * used to generate the pmf.\n+     */\n+    protected final EnumeratedDistribution<Double> innerDistribution;\n+\n+    /**\n+     * Create a discrete distribution using the given probability mass function\n+     * enumeration.\n+     *\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedRealDistribution(final double[] singletons, final double[] probabilities)\n+    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,\n+           NotFiniteNumberException, NotANumberException {\n+        this(new Well19937c(), singletons, probabilities);\n+    }\n+\n+    /**\n+     * Create a discrete distribution using the given random number generator\n+     * and probability mass function enumeration.\n+     *\n+     * @param rng random number generator.\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if any of the probabilities are negative.\n+     * @throws NotFiniteNumberException if any of the probabilities are infinite.\n+     * @throws NotANumberException if any of the probabilities are NaN.\n+     * @throws MathArithmeticException all of the probabilities are 0.\n+     */\n+    public EnumeratedRealDistribution(final RandomGenerator rng,\n+                                    final double[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException,\n+               NotFiniteNumberException, NotANumberException {\n+        super(rng);\n+        if (singletons.length != probabilities.length) {\n+            throw new DimensionMismatchException(probabilities.length, singletons.length);\n+        }\n+\n+        List<Pair<Double, Double>> samples = new ArrayList<Pair<Double, Double>>(singletons.length);\n+\n+        for (int i = 0; i < singletons.length; i++) {\n+            samples.add(new Pair<Double, Double>(singletons[i], probabilities[i]));\n+        }\n+\n+        innerDistribution = new EnumeratedDistribution<Double>(rng, samples);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double probability(final double x) {\n+        return innerDistribution.probability(x);\n+    }\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according to\n+     * this distribution, this method returns {@code P(X = x)}. In other words,\n+     * this method represents the probability mass function (PMF) for the\n+     * distribution.\n+     *\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at point {@code x}\n+     */\n+    public double density(final double x) {\n+        return probability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double cumulativeProbability(final double x) {\n+        double probability = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() <= x) {\n+                probability += sample.getValue();\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum(singletons[i] * probabilities[i])}\n+     */\n+    public double getNumericalMean() {\n+        double mean = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            mean += sample.getValue() * sample.getKey();\n+        }\n+\n+        return mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}\n+     */\n+    public double getNumericalVariance() {\n+        double mean = 0;\n+        double meanOfSquares = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            mean += sample.getValue() * sample.getKey();\n+            meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();\n+        }\n+\n+        return meanOfSquares - mean * mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the lowest value with non-zero probability.\n+     *\n+     * @return the lowest value with non-zero probability.\n+     */\n+    public double getSupportLowerBound() {\n+        double min = Double.POSITIVE_INFINITY;\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() < min && sample.getValue() > 0) {\n+                min = sample.getKey();\n+            }\n+        }\n+\n+        return min;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the highest value with non-zero probability.\n+     *\n+     * @return the highest value with non-zero probability.\n+     */\n+    public double getSupportUpperBound() {\n+        double max = Double.NEGATIVE_INFINITY;\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getKey() > max && sample.getValue() > 0) {\n+                max = sample.getKey();\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution includes the lower bound.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution includes the upper bound.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double sample() {\n+        return innerDistribution.sample();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link EnumeratedIntegerDistribution}.\n+ *\n+ * @version $Id$\n+ */\n+public class EnumeratedIntegerDistributionTest {\n+\n+    /**\n+     * The distribution object used for testing.\n+     */\n+    private final EnumeratedIntegerDistribution testDistribution;\n+\n+    /**\n+     * Creates the default distribution object used for testing.\n+     */\n+    public EnumeratedIntegerDistributionTest() {\n+        // Non-sorted singleton array with duplicates should be allowed.\n+        // Values with zero-probability do not extend the support.\n+        testDistribution = new EnumeratedIntegerDistribution(\n+                new int[]{3, -1, 3, 7, -2, 8},\n+                new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});\n+    }\n+\n+    /**\n+     * Tests if the EnumeratedIntegerDistribution constructor throws\n+     * exceptions for invalid data.\n+     */\n+    @Test\n+    public void testExceptions() {\n+        EnumeratedIntegerDistribution invalid = null;\n+        try {\n+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0});\n+            Assert.fail(\"Expected DimensionMismatchException\");\n+        } catch (DimensionMismatchException e) {\n+        }\n+        try {\n+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0});\n+            Assert.fail(\"Expected NotPositiveException\");\n+        } catch (NotPositiveException e) {\n+        }\n+        try {\n+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+          new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN});\n+            Assert.fail(\"Expected NotANumberException\");\n+        } catch (NotANumberException e) {\n+        }\n+        try {\n+        new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY});\n+            Assert.fail(\"Expected NotFiniteNumberException\");\n+        } catch (NotFiniteNumberException e) {\n+        }\n+        Assert.assertNull(\"Expected non-initialized DiscreteRealDistribution\", invalid);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper probability values.\n+     */\n+    @Test\n+    public void testProbability() {\n+        int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.probability(points[p]);\n+            Assert.assertEquals(results[p], probability, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper cumulative probability values.\n+     */\n+    @Test\n+    public void testCumulativeProbability() {\n+        int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n+        double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.cumulativeProbability(points[p]);\n+            Assert.assertEquals(results[p], probability, 1e-10);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper mean value.\n+     */\n+    @Test\n+    public void testGetNumericalMean() {\n+        Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper variance.\n+     */\n+    @Test\n+    public void testGetNumericalVariance() {\n+        Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper lower bound.\n+     */\n+    @Test\n+    public void testGetSupportLowerBound() {\n+        Assert.assertEquals(-1, testDistribution.getSupportLowerBound());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper upper bound.\n+     */\n+    @Test\n+    public void testGetSupportUpperBound() {\n+        Assert.assertEquals(7, testDistribution.getSupportUpperBound());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support is connected.\n+     */\n+    @Test\n+    public void testIsSupportConnected() {\n+        Assert.assertTrue(testDistribution.isSupportConnected());\n+    }\n+\n+    /**\n+     * Tests sampling.\n+     */\n+    @Test\n+    public void testSample() {\n+        final int n = 1000000;\n+        testDistribution.reseedRandomGenerator(-334759360); // fixed seed\n+        final int[] samples = testDistribution.sample(n);\n+        Assert.assertEquals(n, samples.length);\n+        double sum = 0;\n+        double sumOfSquares = 0;\n+        for (int i = 0; i < samples.length; i++) {\n+            sum += samples[i];\n+            sumOfSquares += samples[i] * samples[i];\n+        }\n+        Assert.assertEquals(testDistribution.getNumericalMean(),\n+                sum / n, 1e-2);\n+        Assert.assertEquals(testDistribution.getNumericalVariance(),\n+                sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/EnumeratedRealDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link EnumeratedRealDistribution}.\n+ * \n+ * @version $Id$\n+ */\n+public class EnumeratedRealDistributionTest {\n+\n+    /**\n+     * The distribution object used for testing.\n+     */\n+    private final EnumeratedRealDistribution testDistribution;\n+\n+    /**\n+     * Creates the default distribution object used for testing.\n+     */\n+    public EnumeratedRealDistributionTest() {\n+        // Non-sorted singleton array with duplicates should be allowed.\n+        // Values with zero-probability do not extend the support.\n+        testDistribution = new EnumeratedRealDistribution(\n+                new double[]{3.0, -1.0, 3.0, 7.0, -2.0, 8.0},\n+                new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});\n+    }\n+\n+    /**\n+     * Tests if the {@link EnumeratedRealDistribution} constructor throws\n+     * exceptions for invalid data.\n+     */\n+    @Test\n+    public void testExceptions() {\n+        EnumeratedRealDistribution invalid = null;\n+        try {\n+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0});\n+            Assert.fail(\"Expected DimensionMismatchException\");\n+        } catch (DimensionMismatchException e) {\n+        }\n+        try{\n+        invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0});\n+            Assert.fail(\"Expected NotPositiveException\");\n+        } catch (NotPositiveException e) {\n+        }\n+        try {\n+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN});\n+            Assert.fail(\"Expected NotANumberException\");\n+        } catch (NotANumberException e) {\n+        }\n+        try {\n+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY});\n+            Assert.fail(\"Expected NotFiniteNumberException\");\n+        } catch (NotFiniteNumberException e) {\n+        }\n+        Assert.assertNull(\"Expected non-initialized DiscreteRealDistribution\", invalid);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper probability values.\n+     */\n+    @Test\n+    public void testProbability() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double density = testDistribution.probability(points[p]);\n+            Assert.assertEquals(results[p], density, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper density values.\n+     */\n+    @Test\n+    public void testDensity() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double density = testDistribution.density(points[p]);\n+            Assert.assertEquals(results[p], density, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper cumulative probability values.\n+     */\n+    @Test\n+    public void testCumulativeProbability() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.cumulativeProbability(points[p]);\n+            Assert.assertEquals(results[p], probability, 1e-10);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper mean value.\n+     */\n+    @Test\n+    public void testGetNumericalMean() {\n+        Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper variance.\n+     */\n+    @Test\n+    public void testGetNumericalVariance() {\n+        Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper lower bound.\n+     */\n+    @Test\n+    public void testGetSupportLowerBound() {\n+        Assert.assertEquals(-1, testDistribution.getSupportLowerBound(), 0);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper upper bound.\n+     */\n+    @Test\n+    public void testGetSupportUpperBound() {\n+        Assert.assertEquals(7, testDistribution.getSupportUpperBound(), 0);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support includes the\n+     * lower bound.\n+     */\n+    @Test\n+    public void testIsSupportLowerBoundInclusive() {\n+        Assert.assertTrue(testDistribution.isSupportLowerBoundInclusive());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support includes the\n+     * upper bound.\n+     */\n+    @Test\n+    public void testIsSupportUpperBoundInclusive() {\n+        Assert.assertTrue(testDistribution.isSupportUpperBoundInclusive());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support is connected.\n+     */\n+    @Test\n+    public void testIsSupportConnected() {\n+        Assert.assertTrue(testDistribution.isSupportConnected());\n+    }\n+\n+    /**\n+     * Tests sampling.\n+     */\n+    @Test\n+    public void testSample() {\n+        final int n = 1000000;\n+        testDistribution.reseedRandomGenerator(-334759360); // fixed seed\n+        final double[] samples = testDistribution.sample(n);\n+        Assert.assertEquals(n, samples.length);\n+        double sum = 0;\n+        double sumOfSquares = 0;\n+        for (int i = 0; i < samples.length; i++) {\n+            sum += samples[i];\n+            sumOfSquares += samples[i] * samples[i];\n+        }\n+        Assert.assertEquals(testDistribution.getNumericalMean(),\n+                sum / n, 1e-2);\n+        Assert.assertEquals(testDistribution.getNumericalVariance(),\n+                sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);\n+    }\n+\n+    @Test\n+    public void testIssue942() {\n+        List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();\n+        list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));\n+        list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));\n+        Assert.assertEquals(1, new EnumeratedDistribution<Object>(list).sample(1).length);\n+    }\n+\n+}", "timestamp": 1363323094, "metainfo": ""}