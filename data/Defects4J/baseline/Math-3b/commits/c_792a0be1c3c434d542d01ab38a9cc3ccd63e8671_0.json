{"sha": "792a0be1c3c434d542d01ab38a9cc3ccd63e8671", "log": "Made EmpiricalDistribution smoothing kernel pluggable. To enable subclasses to provide the enclosing distribution's underlying RandomGenerator to distribution constructors, two more changes were required: * In EmpiricalDistribution, the RandomDataGenerator field (randomData) was changed   from private to protected. * The private getRan() method in RandomDataGenerator returning the underlying   RandomGenerator was renamed getRandomGenerator and made public. JIRA: MATH-671  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 5729073523949762654L;\n \n+    /** RandomDataGenerator instance to use in repeated calls to getNext() */\n+    protected final RandomDataGenerator randomData;\n+\n     /** List of SummaryStatistics objects characterizing the bins */\n     private final List<SummaryStatistics> binStats;\n \n \n     /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n     private double[] upperBounds = null;\n-\n-    /** RandomDataGenerator instance to use in repeated calls to getNext() */\n-    private final RandomDataGenerator randomData;\n \n     /**\n      * Creates a new EmpiricalDistribution with the default bin count.\n                SummaryStatistics stats = binStats.get(i);\n                if (stats.getN() > 0) {\n                    if (stats.getStandardDeviation() > 0) {  // more than one obs\n-                       return randomData.nextGaussian(stats.getMean(),\n-                                                      stats.getStandardDeviation());\n+                       return getKernel(stats).sample();\n                    } else {\n                        return stats.getMean(); // only one obs in bin\n                    }\n      * @param bStats summary statistics for the bin\n      * @return within-bin kernel parameterized by bStats\n      */\n-    private RealDistribution getKernel(SummaryStatistics bStats) {\n-        // For now, hard-code Gaussian (only kernel supported)\n-        return new NormalDistribution(\n-                bStats.getMean(), bStats.getStandardDeviation());\n+    protected RealDistribution getKernel(SummaryStatistics bStats) {\n+        // Default to Gaussian\n+        return new NormalDistribution(randomData.getRandomGenerator(),\n+                bStats.getMean(), bStats.getStandardDeviation(),\n+                NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n         }\n \n         // Get a random number generator\n-        RandomGenerator ran = getRan();\n+        RandomGenerator ran = getRandomGenerator();\n \n         // Initialize output buffer\n         StringBuilder outBuffer = new StringBuilder();\n         if (max <= 0) {\n             // the range is too wide to fit in a positive int (larger than 2^31); as it covers\n             // more than half the integer range, we use directly a simple rejection method\n-            final RandomGenerator rng = getRan();\n+            final RandomGenerator rng = getRandomGenerator();\n             while (true) {\n                 final int r = rng.nextInt();\n                 if (r >= lower && r <= upper) {\n             }\n         } else {\n             // we can shift the range and generate directly a positive int\n-            return lower + getRan().nextInt(max);\n+            return lower + getRandomGenerator().nextInt(max);\n         }\n     }\n \n         if (max <= 0) {\n             // the range is too wide to fit in a positive long (larger than 2^63); as it covers\n             // more than half the long range, we use directly a simple rejection method\n-            final RandomGenerator rng = getRan();\n+            final RandomGenerator rng = getRandomGenerator();\n             while (true) {\n                 final long r = rng.nextLong();\n                 if (r >= lower && r <= upper) {\n             }\n         } else if (max < Integer.MAX_VALUE){\n             // we can shift the range and generate directly a positive int\n-            return lower + getRan().nextInt((int) max);\n+            return lower + getRandomGenerator().nextInt((int) max);\n         } else {\n             // we can shift the range and generate directly a positive long\n-            return lower + nextLong(getRan(), max);\n+            return lower + nextLong(getRandomGenerator(), max);\n         }\n     }\n \n      * @throws NotStrictlyPositiveException if {@code len <= 0}\n      */\n     public long nextPoisson(double mean) throws NotStrictlyPositiveException {\n-        return new PoissonDistribution(getRan(), mean,\n+        return new PoissonDistribution(getRandomGenerator(), mean,\n                 PoissonDistribution.DEFAULT_EPSILON,\n                 PoissonDistribution.DEFAULT_MAX_ITERATIONS).sample();\n     }\n         if (sigma <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n         }\n-        return sigma * getRan().nextGaussian() + mu;\n+        return sigma * getRandomGenerator().nextGaussian() + mu;\n     }\n \n     /**\n      * </p>\n      */\n     public double nextExponential(double mean) throws NotStrictlyPositiveException {\n-        return new ExponentialDistribution(getRan(), mean,\n+        return new ExponentialDistribution(getRandomGenerator(), mean,\n                 ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * {@code scale <= 0}.\n      */\n     public double nextGamma(double shape, double scale) throws NotStrictlyPositiveException {\n-        return new GammaDistribution(getRan(),shape, scale,\n+        return new GammaDistribution(getRandomGenerator(),shape, scale,\n                 GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * @throws NotPositiveException  if {@code numberOfSuccesses < 0}.\n      */\n     public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n-        return new HypergeometricDistribution(getRan(),populationSize,\n+        return new HypergeometricDistribution(getRandomGenerator(),populationSize,\n                 numberOfSuccesses, sampleSize).sample();\n     }\n \n      * range {@code [0, 1]}.\n      */\n     public int nextPascal(int r, double p) throws NotStrictlyPositiveException, OutOfRangeException {\n-        return new PascalDistribution(getRan(), r, p).sample();\n+        return new PascalDistribution(getRandomGenerator(), r, p).sample();\n     }\n \n     /**\n      * @throws NotStrictlyPositiveException if {@code df <= 0}\n      */\n     public double nextT(double df) throws NotStrictlyPositiveException {\n-        return new TDistribution(getRan(), df,\n+        return new TDistribution(getRandomGenerator(), df,\n                 TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * {@code scale <= 0}.\n      */\n     public double nextWeibull(double shape, double scale) throws NotStrictlyPositiveException {\n-        return new WeibullDistribution(getRan(), shape, scale,\n+        return new WeibullDistribution(getRandomGenerator(), shape, scale,\n                 WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * or {@code exponent <= 0}.\n      */\n     public int nextZipf(int numberOfElements, double exponent) throws NotStrictlyPositiveException {\n-        return new ZipfDistribution(getRan(), numberOfElements, exponent).sample();\n+        return new ZipfDistribution(getRandomGenerator(), numberOfElements, exponent).sample();\n     }\n \n     /**\n      * @return random value sampled from the beta(alpha, beta) distribution\n      */\n     public double nextBeta(double alpha, double beta) {\n-        return new BetaDistribution(getRan(), alpha, beta,\n+        return new BetaDistribution(getRandomGenerator(), alpha, beta,\n                 BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n      */\n     public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n-        return new BinomialDistribution(getRan(), numberOfTrials, probabilityOfSuccess).sample();\n+        return new BinomialDistribution(getRandomGenerator(), numberOfTrials, probabilityOfSuccess).sample();\n     }\n \n     /**\n      * @return random value sampled from the Cauchy(median, scale) distribution\n      */\n     public double nextCauchy(double median, double scale) {\n-        return new CauchyDistribution(getRan(), median, scale,\n+        return new CauchyDistribution(getRandomGenerator(), median, scale,\n                 CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * @return random value sampled from the ChiSquare(df) distribution\n      */\n     public double nextChiSquare(double df) {\n-        return new ChiSquaredDistribution(getRan(), df,\n+        return new ChiSquaredDistribution(getRandomGenerator(), df,\n                 ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n      * {@code numeratorDf <= 0} or {@code denominatorDf <= 0}.\n      */\n     public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {\n-        return new FDistribution(getRan(), numeratorDf, denominatorDf,\n+        return new FDistribution(getRandomGenerator(), numeratorDf, denominatorDf,\n                 FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n \n             throw new NotANumberException();\n         }\n \n-        final RandomGenerator generator = getRan();\n+        final RandomGenerator generator = getRandomGenerator();\n \n         // ensure nextDouble() isn't 0.0\n         double u = generator.nextDouble();\n      * @param seed the seed value to use\n      */\n     public void reSeed(long seed) {\n-       getRan().setSeed(seed);\n+       getRandomGenerator().setSeed(seed);\n     }\n \n     /**\n      * {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n      */\n     public void reSeed() {\n-        getRan().setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n+        getRandomGenerator().setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n     }\n \n     /**\n      *\n      * @return the Random used to generate random data\n      */\n-    private RandomGenerator getRan() {\n+    public RandomGenerator getRandomGenerator() {\n         if (rand == null) {\n             initRan();\n         }\n--- a/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n import java.io.InputStreamReader;\n import java.net.URL;\n import java.util.ArrayList;\n+import java.util.Arrays;\n \n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.analysis.integration.BaseAbstractUnivariateIntegrator;\n import org.apache.commons.math3.analysis.integration.IterativeLegendreGaussIntegrator;\n+import org.apache.commons.math3.distribution.AbstractRealDistribution;\n import org.apache.commons.math3.distribution.NormalDistribution;\n import org.apache.commons.math3.distribution.RealDistribution;\n import org.apache.commons.math3.distribution.RealDistributionAbstractTest;\n+import org.apache.commons.math3.distribution.UniformRealDistribution;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.junit.Assert;\n import org.junit.Before;\n             return new NormalDistribution((upper + lower + 1) / 2d, 3.0276503540974917); \n         }\n     }\n+    \n+    @Test\n+    public void testKernelOverrideConstant() {\n+        final EmpiricalDistribution dist = new ConstantKernelEmpiricalDistribution(5);\n+        final double[] data = {1d,2d,3d, 4d,5d,6d, 7d,8d,9d, 10d,11d,12d, 13d,14d,15d};\n+        dist.load(data);\n+        // Bin masses concentrated on 2, 5, 8, 11, 14 <- effectively discrete uniform distribution over these\n+        double[] values = {2d, 5d, 8d, 11d, 14d};\n+        for (int i = 0; i < 20; i++) {\n+            Assert.assertTrue(Arrays.binarySearch(values, dist.sample()) >= 0);\n+        }\n+        final double tol = 10E-12;\n+        Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol);\n+        Assert.assertEquals(0.2, dist.cumulativeProbability(2), tol);\n+        Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol);\n+        Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol);\n+        Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol);\n+        Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol);\n+\n+        Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol);\n+        Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.2), tol);\n+        Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol);\n+        Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.4), tol);\n+        Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol);\n+        Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.6), tol);\n+    }\n+    \n+    @Test\n+    public void testKernelOverrideUniform() {\n+        final EmpiricalDistribution dist = new UniformKernelEmpiricalDistribution(5);\n+        final double[] data = {1d,2d,3d, 4d,5d,6d, 7d,8d,9d, 10d,11d,12d, 13d,14d,15d};\n+        dist.load(data);\n+        // Kernels are uniform distributions on [1,3], [4,6], [7,9], [10,12], [13,15]\n+        final double bounds[] = {3d, 6d, 9d, 12d};\n+        final double tol = 10E-12; \n+        for (int i = 0; i < 20; i++) {\n+            final double v = dist.sample();\n+            // Make sure v is not in the excluded range between bins - that is (bounds[i], bounds[i] + 1)\n+            for (int j = 0; j < bounds.length; j++) {\n+                Assert.assertFalse(v > bounds[j] + tol && v < bounds[j] + 1 - tol);\n+            }\n+        }   \n+        Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol);\n+        Assert.assertEquals(0.1, dist.cumulativeProbability(2), tol);\n+        Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol);\n+        Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol);\n+        Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol);\n+        Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol);\n+\n+        Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol);\n+        Assert.assertEquals(3.0, dist.inverseCumulativeProbability(0.2), tol);\n+        Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol);\n+        Assert.assertEquals(6.0, dist.inverseCumulativeProbability(0.4), tol);\n+        Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol);\n+        Assert.assertEquals(9.0, dist.inverseCumulativeProbability(0.6), tol);\n+    }\n+    \n+    \n+    /**\n+     * Empirical distribution using a constant smoothing kernel.\n+     */\n+    private class ConstantKernelEmpiricalDistribution extends EmpiricalDistribution {\n+        private static final long serialVersionUID = 1L;\n+        public ConstantKernelEmpiricalDistribution(int i) {\n+            super(i);\n+        }\n+        // Use constant distribution equal to bin mean within bin\n+        protected RealDistribution getKernel(SummaryStatistics bStats) {\n+            return new ConstantDistribution(bStats.getMean());\n+        }\n+    }\n+    \n+    /**\n+     * Empirical distribution using a uniform smoothing kernel.\n+     */\n+    private class UniformKernelEmpiricalDistribution extends EmpiricalDistribution {\n+        public UniformKernelEmpiricalDistribution(int i) {\n+            super(i);\n+        }\n+        protected RealDistribution getKernel(SummaryStatistics bStats) {\n+            return new UniformRealDistribution(randomData.getRandomGenerator(), bStats.getMin(), bStats.getMax(),\n+                    UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+        }\n+    }\n+    \n+    /**\n+     * Distribution that takes just one value.\n+     */\n+    private class ConstantDistribution extends AbstractRealDistribution {\n+        private static final long serialVersionUID = 1L;\n+        \n+        /** Singleton value in the sample space */\n+        private final double c;\n+        \n+        public ConstantDistribution(double c) {\n+            this.c = c;\n+        }\n+        \n+        public double density(double x) {\n+            return 0;\n+        }\n+\n+        public double cumulativeProbability(double x) {\n+            return x < c ? 0 : 1;\n+        }\n+        \n+        @Override\n+        public double inverseCumulativeProbability(double p) {\n+            if (p < 0.0 || p > 1.0) {\n+                throw new OutOfRangeException(p, 0, 1);\n+            }\n+            return c;\n+        }\n+\n+        public double getNumericalMean() {\n+            return c;\n+        }\n+\n+        public double getNumericalVariance() {\n+            return 0;\n+        }\n+\n+        public double getSupportLowerBound() {\n+            return c;\n+        }\n+\n+        public double getSupportUpperBound() {\n+            return c;\n+        }\n+\n+        public boolean isSupportLowerBoundInclusive() {\n+            return false;\n+        }\n+\n+        public boolean isSupportUpperBoundInclusive() {\n+            return true;\n+        }\n+\n+        public boolean isSupportConnected() {\n+            return true;\n+        }\n+        \n+        @Override\n+        public double sample() {\n+            return c;\n+        }\n+        \n+    }\n }", "timestamp": 1363494484, "metainfo": ""}