{"sha": "26c817f4c808a4e2d0d0af7fb8feb9cdebbb1446", "log": "Fixed javadoc errors.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ExtendedFieldElement.java\n+++ b/src/main/java/org/apache/commons/math3/ExtendedFieldElement.java\n     T rint();\n \n     /** Get the closest long to instance value.\n-     * @return closest long to {@link #getValue()}\n+     * @return closest long to {@link #getReal()}\n      */\n     long round();\n \n      * @param b Factors.\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n+     * @since 3.2\n      */\n     T linearCombination(double[] a, T[] b)\n         throws DimensionMismatchException;\n      * @param b2 second factor of the second term\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub>\n-     * @see #linearCombination(T, T, T, T, T, T)\n-     * @see #linearCombination(T, T, T, T, T, T, T, T)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object, Object, Object)\n      * @since 3.2\n      */\n     T linearCombination(T a1, T b1, T a2, T b2);\n      * @param b2 second factor of the second term\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub>\n-     * @see #linearCombination(double, T, double, T, double, T)\n-     * @see #linearCombination(double, T, double, T, double, T, double, T)\n+     * @see #linearCombination(double, Object, double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object, double, Object)\n      * @since 3.2\n      */\n     T linearCombination(double a1, T b1, double a2, T b2);\n      * @param b3 second factor of the third term\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * @see #linearCombination(T, T, T, T)\n-     * @see #linearCombination(T, T, T, T, T, T, T, T)\n+     * @see #linearCombination(Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object, Object, Object)\n      * @since 3.2\n      */\n     T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3);\n      * @param b3 second factor of the third term\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n-     * @see #linearCombination(double, T, double, T)\n-     * @see #linearCombination(double, T, double, T, double, T, double, T)\n+     * @see #linearCombination(double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object, double, Object)\n      * @since 3.2\n      */\n     T linearCombination(double a1, T b1,  double a2, T b2, double a3, T b3);\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n      * a<sub>4</sub>&times;b<sub>4</sub>\n-     * @see #linearCombination(T, T, T, T)\n-     * @see #linearCombination(T, T, T, T, T, T)\n+     * @see #linearCombination(Object, Object, Object, Object)\n+     * @see #linearCombination(Object, Object, Object, Object, Object, Object)\n      * @since 3.2\n      */\n     T linearCombination(T a1, T b1, T a2, T b2, T a3, T b3, T a4, T b4);\n      * @return a<sub>1</sub>&times;b<sub>1</sub> +\n      * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n      * a<sub>4</sub>&times;b<sub>4</sub>\n-     * @see #linearCombination(double, T, double, T)\n-     * @see #linearCombination(double, T, double, T, double, T)\n+     * @see #linearCombination(double, Object, double, Object)\n+     * @see #linearCombination(double, Object, double, Object, double, Object)\n      * @since 3.2\n      */\n     T linearCombination(double a1, T b1, double a2, T b2, double a3, T b3, double a4, T b4);\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldRotation.java\n  *\n  * @param <T> the type of the field elements\n  * @version $Id$\n- * @see Vector3DDSDS\n+ * @see FieldVector3D\n  * @see RotationOrder\n  * @since 3.2\n  */\n \n     /** Get the normalized axis of the rotation.\n      * @return normalized axis of the rotation\n-     * @see #Rotation(FieldVector3D, T)\n+     * @see #FieldRotation(FieldVector3D, ExtendedFieldElement)\n      */\n     public FieldVector3D<T> getAxis() {\n         final T squaredSine = q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));\n \n     /** Get the angle of the rotation.\n      * @return angle of the rotation (between 0 and &pi;)\n-     * @see #Rotation(FieldVector3D, T)\n+     * @see #FieldRotation(FieldVector3D, ExtendedFieldElement)\n      */\n     public T getAngle() {\n         if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/FieldVector3D.java\n \n     /** Get the abscissa of the vector.\n      * @return abscissa of the vector\n-     * @see #Vector3D(T, T, T)\n+     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n      */\n     public T getX() {\n         return x;\n \n     /** Get the ordinate of the vector.\n      * @return ordinate of the vector\n-     * @see #Vector3D(T, T, T)\n+     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n      */\n     public T getY() {\n         return y;\n \n     /** Get the height of the vector.\n      * @return height of the vector\n-     * @see #Vector3D(T, T, T)\n+     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement, ExtendedFieldElement)\n      */\n     public T getZ() {\n         return z;\n \n     /** Get the vector coordinates as a dimension 3 array.\n      * @return vector coordinates\n-     * @see #Vector3D(T[])\n+     * @see #FieldVector3D(ExtendedFieldElement[])\n      */\n     public T[] toArray() {\n         final T[] array = MathArrays.buildArray(x.getField(), 3);\n \n     /** Get the azimuth of the vector.\n      * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n-     * @see #Vector3D(T, T)\n+     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement)\n      */\n     public T getAlpha() {\n         return y.atan2(x);\n \n     /** Get the elevation of the vector.\n      * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n-     * @see #Vector3D(T, T)\n+     * @see #FieldVector3D(ExtendedFieldElement, ExtendedFieldElement)\n      */\n     public T getDelta() {\n         return z.divide(getNorm()).asin();\n     /**\n      * Test for the equality of two 3D vectors.\n      * <p>\n-     * If all coordinates of two 3D vectors are exactly the same, and none are\n-     * <code>T.NaN</code>, the two 3D vectors are considered to be equal.\n+     * If all coordinates of two 3D vectors are exactly the same, and none of their\n+     * {@link ExtendedFieldElement#getReal() real part} are <code>NaN</code>, the\n+     * two 3D vectors are considered to be equal.\n      * </p>\n      * <p>\n      * <code>NaN</code> coordinates are considered to affect globally the vector\n-     * and be equals to each other - i.e, if either (or all) coordinates of the\n-     * 3D vector are equal to <code>T.NaN</code>, the 3D vector is equal to\n-     * {@link #NaN}.\n+     * and be equals to each other - i.e, if either (or all) real part of the\n+     * coordinates of the 3D vector are <code>NaN</code>, the 3D vector is <code>NaN</code>.\n      * </p>\n      *\n      * @param other Object to test for equality to this\n         return Vector3DFormat.getInstance().format(toVector3D());\n     }\n \n-    /** {@inheritDoc} */\n+    /** Get a string representation of this vector.\n+     * @param format the custom format for components\n+     * @return a string representation of this vector\n+     */\n     public String toString(final NumberFormat format) {\n         return new Vector3DFormat(format).format(toVector3D());\n     }\n--- a/src/main/java/org/apache/commons/math3/optim/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optim/linear/SimplexSolver.java\n  * default cut-off value may be too small, thus it is advised to increase it to a larger value,\n  * in accordance with the chosen epsilon.\n  * <p>\n- * It may also be counter-productive to provide a too large value for {@link MaxIter}\n- * as parameter in the call of {@link #optimize(org.apache.commons.math3.optim.OptimizationData...)},\n+ * It may also be counter-productive to provide a too large value for {@link\n+ * org.apache.commons.math3.optim.MaxIter MaxIter} as parameter in the call of {@link\n+ * #optimize(org.apache.commons.math3.optim.OptimizationData...) optimize(OptimizationData...)},\n  * as the {@link SimplexSolver} will use different strategies depending on the current iteration\n  * count. After half of the allowed max iterations has already been reached, the strategy to select\n  * pivot rows will change in order to break possible cycles due to degenerate problems.\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n      * @param optData Optimization data.\n      * The following data will be looked for:\n      * <ul>\n-     *  <li>{@link InitialStep}</li>\n+     *  <li>{@link BracketingStep}</li>\n      * </ul>\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java\n      * {@inheritDoc}\n      *\n      * @param optData Optimization data. In addition to those documented in\n-     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n+     * {@link MultivariateVectorOptimizer#optimize(OptimizationData...)}\n      * MultivariateOptimizer}, this method will register the following data:\n      * <ul>\n      *  <li>{@link ModelFunctionJacobian}</li>", "timestamp": 1362761890, "metainfo": ""}