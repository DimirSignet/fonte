{"sha": "9aeffe4d3d4057e3bb0531c5c4ec273625df6308", "log": "Added utilities for prime numbers.  Thanks to S\u00e9bastien Riou.  JIRA: MATH-845  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/primes/PollardRho.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.primes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Implementation of the Pollard's rho factorization algorithm.\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+class PollardRho {\n+\n+    /**\n+     * Only static methods in this class\n+     */\n+    private PollardRho() {\n+    }\n+\n+    /**\n+     * Factorization using Pollard's rho algorithm.\n+     * @param n number to factors, must be >0\n+     * @return the list of prime factors of n.\n+     */\n+    public static List<Integer> primeFactors(int n) {\n+        final List<Integer> factors = new ArrayList<Integer>();\n+\n+        n = SmallPrimes.smallTrialDivision(n, factors);\n+        if (1 == n) {\n+            return factors;\n+        }\n+\n+        if (SmallPrimes.millerRabinPrimeTest(n)) {\n+            factors.add(n);\n+            return factors;\n+        }\n+\n+        int divisor = rhoBrent(n);\n+        factors.add(divisor);\n+        factors.add(n / divisor);\n+        return factors;\n+    }\n+\n+    /**\n+     *  Implementation of the Pollard's rho factorization algorithm.\n+     *  This implementation follows the paper \"An improved Monte Carlo factorization algorithm\" by Richard P. Brent.\n+     *  This avoid the triple computation of f(x) typically found in Pollard's rho implementations. It also batch several gcd computation into 1.\n+     *  The backtracking is not implemented as we deal only with semi-prime.\n+     * @param n number to factor, must be semi-prime.\n+     * @return a prime factor of n.\n+     */\n+    static int rhoBrent(final int n){\n+        final int x0 = 2;\n+        final int m = 25;\n+        int cst = SmallPrimes.PRIMES_LAST;\n+        int y = x0;\n+        int r = 1;\n+        do {\n+            int x = y;\n+            for (int i = 0; i < r; i++) {\n+                final long y2 = ((long) y) * y;\n+                y = (int) ((y2 + cst) % n);\n+            }\n+            int k = 0;\n+            do {\n+                final int bound = FastMath.min(m, r - k);\n+                int q = 1;\n+                for (int i = -3; i < bound; i++) { //start at -3 to ensure we enter this loop at least 3 times\n+                    final long y2 = ((long) y) * y;\n+                    y = (int) ((y2 + cst) % n);\n+                    final long divisor = FastMath.abs(x - y);\n+                    if (0 == divisor) {\n+                        cst += SmallPrimes.PRIMES_LAST;\n+                        k = -m;\n+                        y = x0;\n+                        r = 1;\n+                        break;\n+                    }\n+                    final long prod = divisor * q;\n+                    q = (int) (prod % n);\n+                    if (0 == q) {\n+                        return gcdPositive(FastMath.abs((int) divisor), n);\n+                    }\n+                }\n+                final int out = gcdPositive(FastMath.abs(q), n);\n+                if (1 != out) {\n+                    return out;\n+                }\n+                k = k + m;\n+            } while (k < r);\n+            r = 2 * r;\n+        } while (true);\n+    }\n+\n+    /**\n+     * Gcd between two positive numbers\n+     * <p>\n+     * Gets the greatest common divisor of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     * {@code gcd(x, 0)} is the value of {@code x}.\n+     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     * {@code 0}.</li>\n+     * </ul>\n+     * @param a first number, must be >=0\n+     * @param b second number, must be >=0\n+     * @return gcd(a,b)\n+     */\n+    static int gcdPositive(int a, int b){\n+        // both a and b must be positive, it is not checked here\n+        //gdc(a,0) = a\n+        if (a == 0) {\n+            return b;\n+        } else if (b == 0) {\n+            return a;\n+        }\n+\n+        //make a and b odd, keep in mind the common power of twos\n+        final int aTwos = Integer.numberOfTrailingZeros(a);\n+        a >>= aTwos;\n+        final int bTwos = Integer.numberOfTrailingZeros(b);\n+        b >>= bTwos;\n+        final int shift = FastMath.min(aTwos, bTwos);\n+\n+        //a and b >0\n+        //if a > b then gdc(a,b) = gcd(a-b,b)\n+        //if a < b then gcd(a,b) = gcd(b-a,a)\n+        //so next a is the absolute difference and next b is the minimum of current values\n+        while (a != b) {\n+            final int delta = a - b;\n+            b = FastMath.min(a, b);\n+            a = FastMath.abs(delta);\n+            //for speed optimization:\n+            //remove any power of two in a as b is guaranteed to be odd throughout all iterations\n+            a >>= Integer.numberOfTrailingZeros(a);\n+        }\n+\n+        //gcd(a,a) = a, just \"add\" the common power of twos\n+        return a << shift;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/primes/Primes.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.primes;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+\n+import java.util.List;\n+\n+\n+/**\n+ * Methods related to prime numbers in the range of <code>int</code>:\n+ * <ul>\n+ * <li>primality test</li>\n+ * <li>prime number generation</li>\n+ * <li>factorization</li>\n+ * </ul>\n+ * {@link Math}.\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class Primes {\n+    /**\n+     * Only static methods in this class\n+     */\n+    private Primes() {\n+    }\n+\n+    /**\n+     * Primality test: tells if the argument is a (provable) prime or not.</p>\n+     * It uses the Miller-Rabin probabilistic test in such a way that result is always guaranteed: it uses the firsts prime numbers as successive base\n+     * (see Handbook of applied cryptography by Menezes, table 4.1)\n+     *\n+     * @param n number to test.\n+     * @return true if n is prime. (All numbers <2 return false).\n+     */\n+    public static boolean isPrime(int n) {\n+        if (n < 2) {\n+            return false;\n+        }\n+\n+        for (int p : SmallPrimes.PRIMES) {\n+            if (0 == (n % p)) {\n+                return n == p;\n+            }\n+        }\n+        return SmallPrimes.millerRabinPrimeTest(n);\n+    }\n+\n+    /**\n+     * Return the smallest prime superior or equal to n.\n+     *\n+     * @param n a positive number.\n+     * @return the smallest prime superior or equal to n.\n+     * @throws MathIllegalArgumentException if n <0.\n+     */\n+    public static int nextPrime(int n) {\n+        if (n < 0) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 0);\n+        }\n+        if (n == 2) {\n+            return 2;\n+        }\n+        n = n | 1;//make sur n is odd\n+        if (n == 1) {\n+            return 2;\n+        }\n+\n+        if (isPrime(n)) {\n+            return n;\n+        }\n+\n+        //prepare entry in the +2, +4 loop:\n+        //n should not be a multiple of 3\n+        final int rem = n % 3;\n+        if (0 == rem) {// if n%3==0\n+            n += 2;//n%3==2\n+        } else if (1 == rem) {//if n%3==1\n+            //if (isPrime(n)) return n;\n+            n += 4;//n%3==2\n+        }\n+        while (true) { //this loop skips all multiple of 3\n+            if (isPrime(n)) {\n+                return n;\n+            }\n+            n += 2;//n%3==1\n+            if (isPrime(n)) {\n+                return n;\n+            }\n+            n += 4;//n%3==2\n+        }\n+    }\n+\n+    /**\n+     * Prime factors decomposition\n+     *\n+     * @param n number to factorize: must be >=2\n+     * @return list of prime factors of n\n+     * @throws MathIllegalArgumentException if n <2.\n+     */\n+    public static List<Integer> primeFactors(int n) {\n+\n+        if (n < 2) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n+        }\n+        //slower than trial div unless we do an awful lot of computation (then it finally gets JIT-compiled efficiently\n+        //List<Integer> out = PollardRho.primeFactors(n);\n+        return SmallPrimes.trialDivision(n);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/primes/SmallPrimes.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.primes;\n+\n+\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Utility methods to work on primes within the <code>int</code> range.\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+class SmallPrimes {\n+\n+    /**\n+     * The 512 firsts prime numbers\n+     * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n+     * As a result, <code>int</code> numbers which are not reduced by those primes are garanteed to be either prime or semi prime.\n+     */\n+    public static final int[] PRIMES = {2,\n+            3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n+            79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179,\n+            181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\n+            293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\n+            421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\n+            557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,\n+            673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\n+            821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\n+            953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087,\n+            1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229,\n+            1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381,\n+            1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523,\n+            1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663,\n+            1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823,\n+            1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993,\n+            1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131,\n+            2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293,\n+            2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437,\n+            2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621,\n+            2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749,\n+            2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909,\n+            2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083,\n+            3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259,\n+            3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433,\n+            3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581,\n+            3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671};\n+    /**\n+     * The last number in PRIMES\n+     */\n+    public static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];\n+\n+    /**\n+     * Only static methods in this class\n+     */\n+    private SmallPrimes() {\n+    }\n+\n+    /**\n+     * Extract small factors.\n+     * @param n the number to factor, must be >0.\n+     * @param factors the list where to add the factors.\n+     * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n+     */\n+    public static int smallTrialDivision(int n, final List<Integer> factors) {\n+        for (int p : PRIMES) {\n+            while (0 == n % p) {\n+                n = n / p;\n+                factors.add(p);\n+            }\n+        }\n+        return n;\n+    }\n+\n+    /**\n+     * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>\n+     * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n+     * @param maxFactor the upper bound of trial division: if it is reach, the methods gives up and return n.\n+     * @param factors the list where to add the factors.\n+     * @return  n or 1 if factorization is completed.\n+     */\n+    public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) {\n+        int f = PRIMES_LAST + 2;\n+        // no check is done about n >= f\n+        while (f <= maxFactor) {\n+            if (0 == n % f) {\n+                n = n / f;\n+                factors.add(f);\n+                break;\n+            }\n+            f += 4;\n+            if (0 == n % f) {\n+                n = n / f;\n+                factors.add(f);\n+                break;\n+            }\n+            f += 2;\n+        }\n+        if (n != 1) {\n+            factors.add(n);\n+        }\n+        return n;\n+    }\n+\n+    /**\n+     * Factorization by trial division\n+     * @param n the number to factorize\n+     * @return the list of prime factors of n\n+     */\n+    public static List<Integer> trialDivision(int n){\n+        final List<Integer> factors = new ArrayList<Integer>(32);\n+        n = smallTrialDivision(n, factors);\n+        if (1 == n) {\n+            return factors;\n+        }\n+        // here we are sure that n is either a prime or a semi prime\n+        final int bound = (int) FastMath.sqrt(n);\n+        boundedTrialDivision(n, bound, factors);\n+        return factors;\n+    }\n+\n+    /**\n+     * Miller-Rabin probabilistic primality test for int type, used in such a way that result is always guaranteed.\n+     * It uses the prime numbers as successive base therefore it is garanteed to be always correct. (see Handbook of applied cryptography by Menezes, table 4.1)\n+     *\n+     * @param n number to test: an odd integer >= 3\n+     * @return true if n is prime. false if n is definitely composite.\n+     */\n+    public static boolean millerRabinPrimeTest(final int n) {\n+        final int nMinus1 = n - 1;\n+        final int s = Integer.numberOfTrailingZeros(nMinus1);\n+        final int r = nMinus1 >> s;\n+        //r must be odd, it is not checked here\n+        int t = 1;\n+        if (n >= 2047) {\n+            t = 2;\n+        }\n+        if (n >= 1373653) {\n+            t = 3;\n+        }\n+        if (n >= 25326001) {\n+            t = 4;\n+        } // works up to 3.2 billion, int range stops at 2.7 so we are safe :-)\n+        BigInteger br = BigInteger.valueOf(r);\n+        BigInteger bn = BigInteger.valueOf(n);\n+\n+        for (int i = 0; i < t; i++) {\n+            BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]);\n+            BigInteger bPow = a.modPow(br, bn);\n+            int y = bPow.intValue();\n+            if ((1 != y) && (y != nMinus1)) {\n+                int j = 1;\n+                while ((j <= s - 1) && (nMinus1 != y)) {\n+                    long square = ((long) y) * y;\n+                    y = (int) (square % n);\n+                    if (1 == y) {\n+                        return false;\n+                    } //definitely composite\n+                    j++;\n+                }\n+                if (nMinus1 != y) {\n+                    return false;\n+                } //definitely composite\n+            }\n+        }\n+        return true; //definitely prime\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/primes/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Methods related to prime numbers like primality test, factor decomposition.\n+ */\n+package org.apache.commons.math3.primes;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/primes/PrimesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.primes;\n+\n+\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PrimesTest {\n+\n+    public static final int[] PRIMES = {//primes here have been verified one by one using Dario Alejandro Alpern's tool, see http://www.alpertron.com.ar/ECM.HTM\n+            2,3,5,7,11,13,17,19,23,29,31,43,47,53,71,73,79,89,97,\n+            107,137,151,157,271,293,331,409,607,617,683,829,\n+            1049,1103,1229,1657,\n+            2039,2053,//around first boundary in miller-rabin\n+            2251,2389,2473,2699,3271,3389,3449,5653,6449,6869,9067,9091,\n+            11251,12433,12959,22961,41047,46337,65413,80803,91577,92693,\n+            118423,656519,795659,\n+            1373639,1373677,//around second boundary in miller-rabin\n+            588977,952381,\n+            1013041,1205999,2814001,\n+            22605091,\n+            25325981,25326023,//around third boundary in miller-rabin\n+            100000007,715827881,\n+            2147483647//Integer.MAX_VALUE\n+            };\n+\n+    public static final int[] NOT_PRIMES = {//composite chosen at random + particular values used in algorithms such as boundaries for millerRabin\n+            4,6,8,9,10,12,14,15,16,18,20,21,22,24,25,\n+            275,\n+            2037,2041,2045,2046,2047,2048,2049,2051,2055,//around first boundary in miller-rabin\n+            9095,\n+            463465,\n+            1373637,1373641,1373651,1373652,1373653,1373654,1373655,1373673,1373675,1373679,//around second boundary in miller-rabin\n+            25325979,25325983,25325993,25325997,25325999,25326001,25326003,25326007,25326009,25326011,25326021,25326025,//around third boundary in miller-rabin\n+            100000005,\n+            1073741341,1073741823,2147473649,2147483641,2147483643,2147483645,2147483646};\n+\n+    public static final int[] BELOW_2 = {\n+            Integer.MIN_VALUE,-1,0,1};\n+\n+    void assertPrimeFactorsException(int n, Throwable expected) {\n+        try {\n+            Primes.primeFactors(n);\n+            Assert.fail(\"Exception not thrown\");\n+        } catch (Throwable e) {\n+            Assert.assertEquals(expected.getClass(), e.getClass());\n+            if (expected.getMessage() != null) {\n+                Assert.assertEquals(expected.getMessage(), e.getMessage());\n+            }\n+        }\n+    }\n+    void assertNextPrimeException(int n, Throwable expected){\n+        try {\n+            Primes.nextPrime(n);\n+            Assert.fail(\"Exception not thrown\");\n+        } catch(Throwable e) {\n+            Assert.assertEquals(expected.getClass(), e.getClass());\n+            if (expected.getMessage() != null) {\n+                Assert.assertEquals(expected.getMessage(), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNextPrime() {\n+\n+        Assert.assertEquals(2, Primes.nextPrime(0));\n+        Assert.assertEquals(2, Primes.nextPrime(1));\n+        Assert.assertEquals(2, Primes.nextPrime(2));\n+        Assert.assertEquals(3, Primes.nextPrime(3));\n+        Assert.assertEquals(5, Primes.nextPrime(4));\n+        Assert.assertEquals(5, Primes.nextPrime(5));\n+\n+        for (int i = 0; i < SmallPrimes.PRIMES.length - 1; i++) {\n+            for (int j = SmallPrimes.PRIMES[i] + 1; j <= SmallPrimes.PRIMES[i + 1]; j++) {\n+                Assert.assertEquals(SmallPrimes.PRIMES[i+1], Primes.nextPrime(j));\n+            }\n+        }\n+\n+        Assert.assertEquals(25325981, Primes.nextPrime(25325981));\n+        for (int i = 25325981 + 1; i <= 25326023; i++) {\n+            Assert.assertEquals(25326023, Primes.nextPrime(i));\n+        }\n+\n+        Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE - 10));\n+        Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE - 1));\n+        Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE));\n+\n+        assertNextPrimeException(Integer.MIN_VALUE, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,Integer.MIN_VALUE,0));\n+        assertNextPrimeException(-1, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,-1,0));\n+        assertNextPrimeException(-13, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,-13,0));\n+    }\n+\n+    @Test\n+    public void testIsPrime() throws Exception {\n+        for (int i : BELOW_2) {\n+            Assert.assertEquals(false,Primes.isPrime(i));\n+        }\n+        for (int i:NOT_PRIMES) {\n+            Assert.assertEquals(false,Primes.isPrime(i));\n+        }\n+        for (int i:PRIMES) {\n+            Assert.assertEquals(true,Primes.isPrime(i));\n+        }\n+    }\n+\n+    static int sum(List<Integer> numbers){\n+        int out = 0;\n+        for (int i:numbers) {\n+            out += i;\n+        }\n+        return out;\n+    }\n+    static int product(List<Integer> numbers) {\n+        int out = 1;\n+        for (int i : numbers) {\n+            out *= i;\n+        }\n+        return out;\n+    }\n+    static final HashSet<Integer> PRIMES_SET = new HashSet<Integer>();\n+    static {\n+        for (int p : PRIMES) {\n+            PRIMES_SET.add(p);\n+        }\n+    }\n+    static void checkPrimeFactors(List<Integer> factors){\n+        for (int p : factors) {\n+            if (!PRIMES_SET.contains(p)) {\n+                Assert.fail(\"Not found in primes list: \" + p);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPrimeFactors() throws Exception {\n+        for (int i : BELOW_2) {\n+            assertPrimeFactorsException(i, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,i,2));\n+        }\n+        for (int i : NOT_PRIMES) {\n+            List<Integer> factors = Primes.primeFactors(i);\n+            checkPrimeFactors(factors);\n+            int prod = product(factors);\n+            Assert.assertEquals(i, prod);\n+        }\n+        for (int i : PRIMES) {\n+            List<Integer> factors = Primes.primeFactors(i);\n+            Assert.assertEquals(i, (int)factors.get(0));\n+            Assert.assertEquals(1, factors.size());\n+        }\n+    }\n+}", "timestamp": 1362949520, "metainfo": ""}