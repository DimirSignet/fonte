{"sha": "9dc18c6bdccdcc8dddef1a74620542de66d1039d", "log": "[MATH-851] Added method MathArrays.convolve, thanks to Clemens Novak for the patch.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n          return array;\n      }\n \n+     /**\n+      * Calculates the convolution between two sequences.\n+      * <p>\n+      * The solution is obtained via straightforward computation of the convolution sum (and not via FFT; for longer sequences,\n+      * the performance of this method might be inferior to an FFT-based implementation).\n+      *\n+      * @param x the first sequence (double array of length {@code N}); the sequence is assumed to be zero elsewhere\n+      *   (i.e. {x[i]}=0 for i<0 and i>={@code N}). Typically, this sequence will represent an input signal to a system.\n+      * @param h the second sequence (double array of length {@code M}); the sequence is assumed to be zero elsewhere\n+      *   (i.e. {h[i]}=0 for i<0 and i>={@code M}). Typically, this sequence will represent the impulse response of the system.\n+      * @return the convolution of {@code x} and {@code h} (double array of length {@code N} + {@code M} -1)\n+      * @throws NullArgumentException if either {@code x} or {@code h} is null\n+      * @throws NoDataException if either {@code x} or {@code h} is empty\n+      *\n+      * @see <a href=\"http://en.wikipedia.org/wiki/Convolution\">Convolution (Wikipedia)</a>\n+      * @since 4.0\n+      */\n+     public static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n+         MathUtils.checkNotNull(x);\n+         MathUtils.checkNotNull(h);\n+\n+         final int N = x.length;\n+         final int M = h.length;\n+\n+         if (N == 0 || M == 0) {\n+             throw new NoDataException();\n+         }\n+\n+         // initialize the output array\n+         final int totalLength = N + M - 1;\n+         final double[] y = new double[totalLength];\n+\n+         // straightforward implementation of the convolution sum\n+         for (int n = 0; n < totalLength; n++) {\n+             double yn = 0;\n+             for (int k = 0; k < M; k++) {\n+                 final int j = n - k;\n+                 if ((j > -1) && (j < N) ) {\n+                     yn = yn + x[j] * h[k];\n+                 }\n+             }\n+             y[n] = yn;\n+         }\n+\n+         return y;\n+     }\n+\n }\n--- a/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/MathArraysTest.java\n  */\n package org.apache.commons.math3.util;\n \n+import static org.junit.Assert.fail;\n+\n import java.util.Arrays;\n \n import org.apache.commons.math3.TestUtils;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n             Assert.fail(\"expecting MathIllegalArgumentException\");\n         } catch (MathIllegalArgumentException ex) {}\n     }\n+    \n+    @Test\n+    public void testConvolve() {\n+        /* Test Case (obtained via SciPy)\n+         * x=[1.2,-1.8,1.4]\n+         * h=[1,0.8,0.5,0.3]\n+         * convolve(x,h) -> array([ 1.2 , -0.84,  0.56,  0.58,  0.16,  0.42])\n+         */\n+        double[] x1 = { 1.2, -1.8, 1.4 };\n+        double[] h1 = { 1, 0.8, 0.5, 0.3 };\n+        double[] y1 = { 1.2, -0.84, 0.56, 0.58, 0.16, 0.42 };\n+        double tolerance = 1e-13;\n+\n+        double[] yActual = MathArrays.convolve(x1, h1);\n+        Assert.assertArrayEquals(y1, yActual, tolerance);\n+\n+        double[] x2 = { 1, 2, 3 };\n+        double[] h2 = { 0, 1, 0.5 };\n+        double[] y2 = { 0, 1, 2.5, 4, 1.5 };\n+        \n+        yActual = MathArrays.convolve(x2, h2);\n+        Assert.assertArrayEquals(y2, yActual, tolerance);\n+                \n+        try {\n+            MathArrays.convolve(new double[]{1, 2}, null);\n+            fail(\"an exception should have been thrown\");\n+        } catch (NullArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            MathArrays.convolve(null, new double[]{1, 2});\n+            fail(\"an exception should have been thrown\");\n+        } catch (NullArgumentException e) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            MathArrays.convolve(new double[]{1, 2}, new double[]{});\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoDataException e) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            MathArrays.convolve(new double[]{}, new double[]{1, 2});\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoDataException e) {\n+            // expected behavior\n+        }\n+\n+        try {\n+            MathArrays.convolve(new double[]{}, new double[]{});\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoDataException e) {\n+            // expected behavior\n+        }\n+    }\n }", "timestamp": 1369757072, "metainfo": ""}