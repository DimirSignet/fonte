{"sha": "4b8cf0ca5877a0c1b0b22d728ec70318c2cfd92b", "log": "Fixed wrong array dimensions in secondary equations handling.  JIRA: MATH-961  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n      */\n     protected void setEquations(final ExpandableStatefulODE equations) {\n         this.expandable = equations;\n+    }\n+\n+    /** Get the differential equations to integrate.\n+     * @return differential equations to integrate\n+     * @since 3.2\n+     */\n+    protected ExpandableStatefulODE getExpandable() {\n+        return expandable;\n+    }\n+\n+    /** Get the evaluations counter.\n+     * @return evaluations counter\n+     * @since 3.2\n+     */\n+    protected Incrementor getEvaluationsCounter() {\n+        return evaluations;\n     }\n \n     /** {@inheritDoc} */\n \n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+                final double[] eventYPrimary  = interpolator.getInterpolatedState().clone();\n+                final double[] eventYComplete = new double[y.length];\n+                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n+                                                                 eventYComplete);\n+                int index = 0;\n+                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n+                                                 eventYComplete);\n+                }\n \n                 // advance all event states to current time\n                 for (final EventState state : eventsStates) {\n-                    state.stepAccepted(eventT, eventY);\n+                    state.stepAccepted(eventT, eventYPrimary);\n                     isLastStep = isLastStep || state.stop();\n                 }\n \n \n                 if (isLastStep) {\n                     // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n+                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                     return eventT;\n                 }\n \n                 boolean needReset = false;\n                 for (final EventState state : eventsStates) {\n-                    needReset =  needReset || state.reset(eventT, eventY);\n+                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                 }\n                 if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n+                    interpolator.setInterpolatedTime(eventT);\n+                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n--- a/src/main/java/org/apache/commons/math3/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math3/ode/ContinuousOutputModel.java\n    * Get the state vector of the interpolated point.\n    * @return state vector at time {@link #getInterpolatedTime}\n    * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   * @see #getInterpolatedSecondaryState(int)\n    */\n   public double[] getInterpolatedState() throws MaxCountExceededException {\n     return steps.get(index).getInterpolatedState();\n+  }\n+\n+  /** Get the interpolated secondary state corresponding to the secondary equations.\n+   * @param secondaryStateIndex index of the secondary set, as returned by {@link\n+   * org.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\n+   * org.apache.commons.math3.ode.SecondaryEquations)\n+   * ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}\n+   * @return interpolated secondary state at the current interpolation date\n+   * @see #getInterpolatedState()\n+   * @since 3.2\n+   * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n+   */\n+  public double[] getInterpolatedSecondaryState(final int secondaryStateIndex)\n+    throws MaxCountExceededException {\n+    return steps.get(index).getInterpolatedSecondaryState(secondaryStateIndex);\n   }\n \n   /** Compare a step interval and a double.\n--- a/src/main/java/org/apache/commons/math3/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/MultistepIntegrator.java\n \n         // start integration, expecting a InitializationCompletedMarkerException\n         try {\n-            starter.integrate(new CountingDifferentialEquations(y0.length),\n-                              t0, y0, t, new double[y0.length]);\n+\n+            if (starter instanceof AbstractIntegrator) {\n+                ((AbstractIntegrator) starter).integrate(getExpandable(), t);\n+            } else {\n+                starter.integrate(new FirstOrderDifferentialEquations() {\n+\n+                    /** {@inheritDoc} */\n+                    public int getDimension() {\n+                        return getExpandable().getTotalDimension();\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+                        getExpandable().computeDerivatives(t, y, yDot);\n+                    }\n+\n+                }, t0, y0, t, new double[y0.length]);\n+            }\n+\n         } catch (InitializationCompletedMarkerException icme) { // NOPMD\n             // this is the expected nominal interruption of the start integrator\n+\n+            // count the evaluations used by the starter\n+            getEvaluationsCounter().incrementCount(starter.getEvaluations());\n+\n         }\n \n         // remove the specific step handler\n                 // first step, we need to store also the beginning of the step\n                 interpolator.setInterpolatedTime(prev);\n                 t[0] = prev;\n-                System.arraycopy(interpolator.getInterpolatedState(), 0,\n-                                 y[0],    0, y[0].length);\n-                System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n-                                 yDot[0], 0, yDot[0].length);\n+                final ExpandableStatefulODE expandable = getExpandable();\n+                final EquationsMapper primary = expandable.getPrimaryMapper();\n+                primary.insertEquationData(interpolator.getInterpolatedState(), y[count]);\n+                primary.insertEquationData(interpolator.getInterpolatedDerivatives(), yDot[count]);\n+                int index = 0;\n+                for (final EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), y[count]);\n+                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryDerivatives(index), yDot[count]);\n+                    ++index;\n+                }\n             }\n \n             // store the end of the step\n             ++count;\n             interpolator.setInterpolatedTime(curr);\n             t[count] = curr;\n-            System.arraycopy(interpolator.getInterpolatedState(), 0,\n-                             y[count],    0, y[count].length);\n-            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n-                             yDot[count], 0, yDot[count].length);\n+\n+            final ExpandableStatefulODE expandable = getExpandable();\n+            final EquationsMapper primary = expandable.getPrimaryMapper();\n+            primary.insertEquationData(interpolator.getInterpolatedState(), y[count]);\n+            primary.insertEquationData(interpolator.getInterpolatedDerivatives(), yDot[count]);\n+            int index = 0;\n+            for (final EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), y[count]);\n+                secondary.insertEquationData(interpolator.getInterpolatedSecondaryDerivatives(index), yDot[count]);\n+                ++index;\n+            }\n \n             if (count == t.length - 1) {\n \n \n     }\n \n-    /** Wrapper for differential equations, ensuring start evaluations are counted. */\n-    private class CountingDifferentialEquations implements FirstOrderDifferentialEquations {\n-\n-        /** Dimension of the problem. */\n-        private final int dimension;\n-\n-        /** Simple constructor.\n-         * @param dimension dimension of the problem\n-         */\n-        public CountingDifferentialEquations(final int dimension) {\n-            this.dimension = dimension;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void computeDerivatives(double t, double[] y, double[] dot)\n-            throws MaxCountExceededException, DimensionMismatchException {\n-            MultistepIntegrator.this.computeDerivatives(t, y, dot);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public int getDimension() {\n-            return dimension;\n-        }\n-\n-    }\n-\n }\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math3.exception.NoBracketingException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.ode.EquationsMapper;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math3.util.FastMath;\n             final double stepEnd = stepStart + stepSize;\n             interpolator.shift();\n             interpolator.setInterpolatedTime(stepEnd);\n-            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+            final ExpandableStatefulODE expandable = getExpandable();\n+            final EquationsMapper primary = expandable.getPrimaryMapper();\n+            primary.insertEquationData(interpolator.getInterpolatedState(), y);\n+            int index = 0;\n+            for (final EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), y);\n+                ++index;\n+            }\n \n             // evaluate the derivative\n             computeDerivatives(stepEnd, y, yDot);\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.RealMatrixPreservingVisitor;\n+import org.apache.commons.math3.ode.EquationsMapper;\n import org.apache.commons.math3.ode.ExpandableStatefulODE;\n import org.apache.commons.math3.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math3.util.FastMath;\n                 // predict a first estimate of the state at step end (P in the PECE sequence)\n                 final double stepEnd = stepStart + stepSize;\n                 interpolator.setInterpolatedTime(stepEnd);\n-                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n+                final ExpandableStatefulODE expandable = getExpandable();\n+                final EquationsMapper primary = expandable.getPrimaryMapper();\n+                primary.insertEquationData(interpolator.getInterpolatedState(), yTmp);\n+                int index = 0;\n+                for (final EquationsMapper secondary : expandable.getSecondaryMappers()) {\n+                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), yTmp);\n+                    ++index;\n+                }\n \n                 // evaluate a first estimate of the derivative (first E in the PECE sequence)\n                 computeDerivatives(stepEnd, yTmp, yDot);", "timestamp": 1364929453, "metainfo": ""}