{"sha": "c6c8aea4a0252e6dc805329d7d1f021adff99a04", "log": "Rename userguide examples.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/userguide/ClusterAlgorithmComparison.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.userguide;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.awt.geom.Ellipse2D;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n+import org.apache.commons.math3.ml.clustering.CentroidCluster;\n+import org.apache.commons.math3.ml.clustering.Cluster;\n+import org.apache.commons.math3.ml.clustering.Clusterable;\n+import org.apache.commons.math3.ml.clustering.Clusterer;\n+import org.apache.commons.math3.ml.clustering.DBSCANClusterer;\n+import org.apache.commons.math3.ml.clustering.DoublePoint;\n+import org.apache.commons.math3.ml.clustering.FuzzyKMeansClusterer;\n+import org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer;\n+import org.apache.commons.math3.random.RandomAdaptor;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.SobolSequenceGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Plots clustering results for various algorithms and datasets.\n+ * Based on\n+ * <a href=\"http://scikit-learn.org/stable/auto_examples/cluster/plot_cluster_comparison.html\">scikit learn</a>.\n+ */\n+public class ClusterAlgorithmComparison {\n+\n+    public static List<Vector2D> makeCircles(int samples, boolean shuffle, double noise, double factor, final RandomGenerator random) {\n+        if (factor < 0 || factor > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+        \n+        NormalDistribution dist = new NormalDistribution(random, 0.0, noise, 1e-9);\n+\n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        double range = 2.0 * FastMath.PI;\n+        double step = range / (samples / 2.0 + 1);\n+        for (double angle = 0; angle < range; angle += step) {\n+            Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle));\n+            Vector2D innerCircle = outerCircle.scalarMultiply(factor);\n+            \n+            points.add(outerCircle.add(generateNoiseVector(dist)));\n+            points.add(innerCircle.add(generateNoiseVector(dist)));\n+        }\n+        \n+        if (shuffle) {\n+            Collections.shuffle(points, new RandomAdaptor(random));\n+        }\n+\n+        return points;\n+    }\n+\n+    public static List<Vector2D> makeMoons(int samples, boolean shuffle, double noise, RandomGenerator random) {\n+        NormalDistribution dist = new NormalDistribution(random, 0.0, noise, 1e-9);\n+\n+        int nSamplesOut = samples / 2;\n+        int nSamplesIn = samples - nSamplesOut;\n+        \n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        double range = FastMath.PI;\n+        double step = range / (nSamplesOut / 2.0);\n+        for (double angle = 0; angle < range; angle += step) {\n+            Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle));\n+            points.add(outerCircle.add(generateNoiseVector(dist)));\n+        }\n+\n+        step = range / (nSamplesIn / 2.0);\n+        for (double angle = 0; angle < range; angle += step) {\n+            Vector2D innerCircle = new Vector2D(1 - FastMath.cos(angle), 1 - FastMath.sin(angle) - 0.5);\n+            points.add(innerCircle.add(generateNoiseVector(dist)));\n+        }\n+        \n+        if (shuffle) {\n+            Collections.shuffle(points, new RandomAdaptor(random));\n+        }\n+\n+        return points;\n+    }\n+\n+    public static List<Vector2D> makeBlobs(int samples, int centers, double clusterStd,\n+                                           double min, double max, boolean shuffle, RandomGenerator random) {\n+\n+        NormalDistribution dist = new NormalDistribution(random, 0.0, clusterStd, 1e-9);\n+\n+        double range = max - min;\n+        Vector2D[] centerPoints = new Vector2D[centers];\n+        for (int i = 0; i < centers; i++) {\n+            double x = random.nextDouble() * range + min;\n+            double y = random.nextDouble() * range + min;\n+            centerPoints[i] = new Vector2D(x, y);\n+        }\n+        \n+        int[] nSamplesPerCenter = new int[centers];\n+        int count = samples / centers;\n+        Arrays.fill(nSamplesPerCenter, count);\n+        \n+        for (int i = 0; i < samples % centers; i++) {\n+            nSamplesPerCenter[i]++;\n+        }\n+        \n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        for (int i = 0; i < centers; i++) {\n+            for (int j = 0; j < nSamplesPerCenter[i]; j++) {\n+                Vector2D point = new Vector2D(dist.sample(), dist.sample());\n+                points.add(point.add(centerPoints[i]));\n+            }\n+        }\n+        \n+        if (shuffle) {\n+            Collections.shuffle(points, new RandomAdaptor(random));\n+        }\n+\n+        return points;\n+    }\n+    \n+    public static List<Vector2D> makeRandom(int samples) {\n+        SobolSequenceGenerator generator = new SobolSequenceGenerator(2);\n+        generator.skipTo(999999);\n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        for (double i = 0; i < samples; i++) {\n+            double[] vector = generator.nextVector();\n+            vector[0] = vector[0] * 2 - 1;\n+            vector[1] = vector[1] * 2 - 1;\n+            Vector2D point = new Vector2D(vector);\n+            points.add(point);\n+        }\n+        \n+        return points;\n+    }\n+\n+    public static Vector2D generateNoiseVector(NormalDistribution distribution) {\n+        return new Vector2D(distribution.sample(), distribution.sample());\n+    }\n+    \n+    public static List<DoublePoint> normalize(final List<Vector2D> input, double minX, double maxX, double minY, double maxY) {\n+        double rangeX = maxX - minX;\n+        double rangeY = maxY - minY;\n+        List<DoublePoint> points = new ArrayList<DoublePoint>();\n+        for (Vector2D p : input) {\n+            double[] arr = p.toArray();\n+            arr[0] = (arr[0] - minX) / rangeX * 2 - 1;\n+            arr[1] = (arr[1] - minY) / rangeY * 2 - 1;\n+            points.add(new DoublePoint(arr));\n+        }\n+        return points;\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    public static class Display extends JFrame {\n+        \n+        public Display() {\n+            setTitle(\"Clustering examples\");\n+            setSize(800, 800);\n+            \n+            setLayout(new GridBagLayout());\n+            \n+            int nSamples = 1500;\n+            \n+            RandomGenerator rng = new Well19937c(0);\n+            List<List<DoublePoint>> datasets = new ArrayList<List<DoublePoint>>();\n+\n+            datasets.add(normalize(makeCircles(nSamples, true, 0.04, 0.5, rng), -1, 1, -1, 1));\n+            datasets.add(normalize(makeMoons(nSamples, true, 0.04, rng), -1, 2, -1, 1));\n+            datasets.add(normalize(makeBlobs(nSamples, 3, 1.0, -10, 10, true, rng), -12, 12, -12, 12));\n+            datasets.add(normalize(makeRandom(nSamples), -1, 1, -1, 1));\n+\n+            List<Pair<String, Clusterer<DoublePoint>>> algorithms = new ArrayList<Pair<String, Clusterer<DoublePoint>>>();\n+            \n+            algorithms.add(new Pair<String, Clusterer<DoublePoint>>(\"KMeans\\n(k=2)\", new KMeansPlusPlusClusterer<DoublePoint>(2)));            \n+            algorithms.add(new Pair<String, Clusterer<DoublePoint>>(\"KMeans\\n(k=3)\", new KMeansPlusPlusClusterer<DoublePoint>(3)));\n+            algorithms.add(new Pair<String, Clusterer<DoublePoint>>(\"FuzzyKMeans\\n(k=3, fuzzy=2)\", new FuzzyKMeansClusterer<DoublePoint>(3, 2)));\n+            algorithms.add(new Pair<String, Clusterer<DoublePoint>>(\"FuzzyKMeans\\n(k=3, fuzzy=10)\", new FuzzyKMeansClusterer<DoublePoint>(3, 10)));\n+            algorithms.add(new Pair<String, Clusterer<DoublePoint>>(\"DBSCAN\\n(eps=.1, min=3)\", new DBSCANClusterer<DoublePoint>(0.1, 3)));\n+            \n+            GridBagConstraints c = new GridBagConstraints();\n+            c.fill = GridBagConstraints.VERTICAL;\n+            c.gridx = 0;\n+            c.gridy = 0;\n+            c.insets = new Insets(2, 2, 2, 2);\n+\n+            for (Pair<String, Clusterer<DoublePoint>> pair : algorithms) {\n+                JLabel text = new JLabel(\"<html><body>\" + pair.getFirst().replace(\"\\n\", \"<br>\"));\n+                add(text, c);\n+                c.gridx++;\n+            }\n+            c.gridy++;\n+\n+            for (List<DoublePoint> dataset : datasets) {\n+                c.gridx = 0;\n+                for (Pair<String, Clusterer<DoublePoint>> pair : algorithms) {\n+                    long start = System.currentTimeMillis();\n+                    List<? extends Cluster<DoublePoint>> clusters = pair.getSecond().cluster(dataset);\n+                    long end = System.currentTimeMillis();\n+                    add(new ClusterPlot(clusters, end - start), c);\n+                    c.gridx++;\n+                }\n+                c.gridy++;\n+            }            \n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class ClusterPlot extends JComponent {\n+\n+        private static double PAD = 10;\n+\n+        private List<? extends Cluster<DoublePoint>> clusters;\n+        private long duration;\n+\n+        public ClusterPlot(final List<? extends Cluster<DoublePoint>> clusters, long duration) {\n+            this.clusters = clusters;\n+            this.duration = duration;\n+        }\n+        \n+        protected void paintComponent(Graphics g) {\n+            super.paintComponent(g);\n+            Graphics2D g2 = (Graphics2D)g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                                RenderingHints.VALUE_ANTIALIAS_ON);\n+\n+            int w = getWidth();\n+            int h = getHeight();\n+\n+            g2.clearRect(0, 0, w, h);\n+            \n+            g2.setPaint(Color.black);\n+            g2.drawRect(0, 0, w - 1, h - 1);\n+            \n+            int index = 0;\n+            Color[] colors = new Color[] { Color.red, Color.blue, Color.green.darker() };\n+            for (Cluster<DoublePoint> cluster : clusters) {\n+                g2.setPaint(colors[index++]);\n+                for (DoublePoint point : cluster.getPoints()) {\n+                    Clusterable p = transform(point, w, h);\n+                    double[] arr = p.getPoint();\n+                    g2.fill(new Ellipse2D.Double(arr[0] - 1, arr[1] - 1, 3, 3));\n+                }\n+                \n+                if (cluster instanceof CentroidCluster) {\n+                    Clusterable p = transform(((CentroidCluster<?>) cluster).getCenter(), w, h);\n+                    double[] arr = p.getPoint();\n+                    Shape s = new Ellipse2D.Double(arr[0] - 4, arr[1] - 4, 8, 8); \n+                    g2.fill(s);\n+                    g2.setPaint(Color.black);\n+                    g2.draw(s);\n+                }\n+            }\n+            \n+            g2.setPaint(Color.black);\n+            g2.drawString(String.format(\"%.2f s\", duration / 1e3), w - 40, h - 5);\n+        }        \n+        \n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(150, 150);\n+        }\n+\n+        private Clusterable transform(Clusterable point, int width, int height) {\n+            double[] arr = point.getPoint();\n+            return new DoublePoint(new double[] { PAD + (arr[0] + 1) / 2.0 * (width - 2 * PAD),\n+                                                  height - PAD - (arr[1] + 1) / 2.0 * (height - 2 * PAD) });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        ExampleUtils.showExampleFrame(new Display());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/userguide/LowDiscrepancyGeneratorComparison.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.userguide;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.RenderingHints;\n+import java.awt.geom.Rectangle2D;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JTextArea;\n+\n+import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n+import org.apache.commons.math3.random.HaltonSequenceGenerator;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.MersenneTwister;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.RandomVectorGenerator;\n+import org.apache.commons.math3.random.SobolSequenceGenerator;\n+import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator;\n+import org.apache.commons.math3.random.UniformRandomGenerator;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Plots 2D samples drawn from various pseudo / quasi-random generators.\n+ */\n+public class LowDiscrepancyGeneratorComparison {\n+\n+    public static List<Vector2D> makeCircle(int samples, final RandomVectorGenerator generator) {\n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        for (double i = 0; i < samples; i++) {\n+            double[] vector = generator.nextVector();\n+            Vector2D point = new Vector2D(vector);\n+            points.add(point);\n+        }\n+\n+        // normalize points first\n+        points = normalize(points);\n+        \n+        // now test if the sample is within the unit circle\n+        List<Vector2D> circlePoints = new ArrayList<Vector2D>();\n+        for (Vector2D p : points) {\n+            double criteria = FastMath.pow(p.getX(), 2) + FastMath.pow(p.getY(), 2);\n+            if (criteria < 1.0) {\n+                circlePoints.add(p);\n+            }\n+        }\n+\n+        return circlePoints;\n+    }\n+\n+    public static List<Vector2D> makeRandom(int samples, RandomVectorGenerator generator) {\n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        for (double i = 0; i < samples; i++) {\n+            double[] vector = generator.nextVector();\n+            Vector2D point = new Vector2D(vector);\n+            points.add(point);\n+        }\n+        \n+        return normalize(points);\n+    }\n+\n+    public static List<Vector2D> normalize(final List<Vector2D> input) {\n+        // find the mininum and maximum x value in the dataset\n+        double minX = Double.MAX_VALUE;\n+        double maxX = Double.MIN_VALUE;\n+        for (Vector2D p : input) {\n+            minX = FastMath.min(minX, p.getX());\n+            maxX = FastMath.max(maxX, p.getX());\n+        }\n+        \n+        double minY, maxY;\n+        \n+        // use the minimum to detect if we either have input values in the range [0, 1] or [-sqrt(3), sqrt(3)]\n+        if (FastMath.abs(minX) < 0.1) {\n+            minX = minY = 0.0;\n+            maxX = maxY = 1.0;\n+        } else {\n+            minX = minY = -FastMath.sqrt(3);\n+            maxX = maxY = FastMath.sqrt(3);            \n+        }\n+\n+        double rangeX = maxX - minX;\n+        double rangeY = maxY - minY;\n+        List<Vector2D> points = new ArrayList<Vector2D>();\n+        for (Vector2D p : input) {\n+            double[] arr = p.toArray();\n+            // normalize to the range [-1, 1]\n+            arr[0] = (arr[0] - minX) / rangeX * 2 - 1;\n+            arr[1] = (arr[1] - minY) / rangeY * 2 - 1;\n+            points.add(new Vector2D(arr));\n+        }\n+        return points;\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    public static class Display extends JFrame {\n+        \n+        public Display() {\n+            setTitle(\"Pseudo/Quasi-random examples\");\n+            setSize(800, 800);\n+            \n+            setLayout(new GridBagLayout());\n+            \n+            int[] datasets = new int[] { 256, 1000, 2500, 1000 };\n+            List<Pair<String, RandomVectorGenerator>> generators = new ArrayList<Pair<String, RandomVectorGenerator>>();\n+\n+            generators.add(new Pair<String, RandomVectorGenerator>(\"Uncorrelated\\nUniform(JDK)\",\n+                    new UncorrelatedRandomVectorGenerator(2, new UniformRandomGenerator(new JDKRandomGenerator()))));\n+            generators.add(new Pair<String, RandomVectorGenerator>(\"Independent\\nRandom(MT)\", new RandomVectorGenerator() {\n+\n+                RandomGenerator[] rngs = new RandomGenerator[] {\n+                    new MersenneTwister(0),\n+                    new MersenneTwister(1)\n+                };\n+                \n+                public double[] nextVector() {\n+                    final double[] vector = new double[2];\n+                    vector[0] = rngs[0].nextDouble();\n+                    vector[1] = rngs[1].nextDouble();\n+                    return vector;\n+                }\n+                \n+            }));            \n+            generators.add(new Pair<String, RandomVectorGenerator>(\"HaltonSequence\", new HaltonSequenceGenerator(2)));            \n+            generators.add(new Pair<String, RandomVectorGenerator>(\"SobolSequence\", new SobolSequenceGenerator(2)));            \n+            \n+            GridBagConstraints c = new GridBagConstraints();\n+            c.fill = GridBagConstraints.VERTICAL;\n+            c.gridx = 1;\n+            c.gridy = 0;\n+            c.insets = new Insets(2, 2, 2, 2);\n+\n+            for (Pair<String, RandomVectorGenerator> pair : generators) {\n+                JTextArea text = new JTextArea(pair.getFirst());\n+                text.setEditable(false);\n+                text.setOpaque(false);\n+                add(text, c);\n+                c.gridx++;\n+            }\n+            int saveY = ++c.gridy;\n+            \n+            c.gridx = 0;\n+            for (int type = 0; type < 4; type++) {\n+                JLabel text = new JLabel(\"n=\" + String.valueOf(datasets[type]));\n+                text.setOpaque(false);\n+                add(text, c);\n+                c.gridy++;\n+            }\n+\n+            c.gridy = saveY;\n+            for (int type = 0; type < 4; type++) {\n+                c.gridx = 1;\n+\n+                for (Pair<String, RandomVectorGenerator> pair : generators) {\n+                    List<Vector2D> points = null;\n+                    int samples = datasets[type];\n+                    switch (type) {\n+                        case 0:\n+                            points = makeRandom(samples, pair.getValue());\n+                            break;\n+                        case 1:\n+                            points = makeRandom(samples, pair.getValue());\n+                            break;\n+                        case 2:\n+                            points = makeRandom(samples, pair.getValue());\n+                            break;\n+                        case 3:\n+                            points = makeCircle(samples, pair.getValue());\n+                            break;\n+                    }\n+                    add(new Plot(points), c);\n+                    c.gridx++;\n+                }\n+\n+                c.gridy++;\n+            }            \n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class Plot extends JComponent {\n+\n+        private static double PAD = 10;\n+\n+        private List<Vector2D> points;\n+\n+        public Plot(final List<Vector2D> points) {\n+            this.points = points;\n+        }\n+        \n+        protected void paintComponent(Graphics g) {\n+            super.paintComponent(g);\n+            Graphics2D g2 = (Graphics2D)g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                                RenderingHints.VALUE_ANTIALIAS_ON);\n+\n+            int w = getWidth();\n+            int h = getHeight();\n+\n+            g2.clearRect(0, 0, w, h);\n+            \n+            g2.setPaint(Color.black);\n+            g2.drawRect(0, 0, w - 1, h - 1);\n+            \n+            for (Vector2D point : points) {\n+                Vector2D p = transform(point, w, h);\n+                double[] arr = p.toArray();\n+                g2.draw(new Rectangle2D.Double(arr[0] - 1, arr[1] - 1, 2, 2));\n+            }\n+        }        \n+        \n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(140, 140);\n+        }\n+\n+        private Vector2D transform(Vector2D point, int width, int height) {\n+            double[] arr = point.toArray();\n+            return new Vector2D(new double[] { PAD + (arr[0] + 1) / 2.0 * (width - 2 * PAD),\n+                                                  height - PAD - (arr[1] + 1) / 2.0 * (height - 2 * PAD) });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        ExampleUtils.showExampleFrame(new Display());\n+    }\n+}", "timestamp": 1369579898, "metainfo": ""}