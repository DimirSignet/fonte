{"sha": "7bb4d30068e46516738c785d0288222c3e57476e", "log": "Make package scoped Format as per the [lang] coding standards   ", "commit": "\n--- a/src/java/org/apache/commons/lang/IntHashMap.java\n+++ b/src/java/org/apache/commons/lang/IntHashMap.java\n  * <http://www.apache.org/>.\n  */\n \n-/**\n- * Note: originally released under the GNU LGPL v2.1, but rereleased by the original author under the ASF license (above).\n+/*\n+ * Note: originally released under the GNU LGPL v2.1, \n+ * but rereleased by the original author under the ASF license (above).\n  */\n package org.apache.commons.lang;\n \n  *\n  * @author Justin Couch\n  * @author Alex Chaffee (alex@apache.org)\n- * @version $Revision: 1.2 $\n+ * @author Stephen Colebourne\n+ * @version $Revision: 1.3 $\n  * @see java.util.HashMap\n  */\n-public class IntHashMap\n-{\n+class IntHashMap {\n+\n     /**\n      * The hash table data.\n      */\n      * <p>Innerclass that acts as a datastructure to create a new entry in the\n      * table.</p>\n      */\n-    private static class Entry\n-    {\n+    private static class Entry {\n         int hash;\n         int key;\n         Object value;\n          * @param value The value for this key\n          * @param next A reference to the next entry in the table\n          */\n-        protected Entry(int hash, int key, Object value, Entry next)\n-        {\n+        protected Entry(int hash, int key, Object value, Entry next) {\n             this.hash = hash;\n             this.key = key;\n             this.value = value;\n      * <p>Constructs a new, empty hashtable with a default capacity and load\n      * factor, which is <code>20</code> and <code>0.75</code> respectively.</p>\n      */\n-    public IntHashMap()\n-    {\n+    public IntHashMap() {\n         this(20, 0.75f);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is less\n      *   than zero.\n      */\n-    public IntHashMap(int initialCapacity)\n-    {\n+    public IntHashMap(int initialCapacity) {\n         this(initialCapacity, 0.75f);\n     }\n \n      * @throws IllegalArgumentException  if the initial capacity is less\n      *             than zero, or if the load factor is nonpositive.\n      */\n-    public IntHashMap(int initialCapacity, float loadFactor)\n-    {\n-        if (initialCapacity < 0)\n-            throw new IllegalArgumentException(\"Illegal Capacity: \" +\n-                    initialCapacity);\n-        if (loadFactor <= 0)\n+    public IntHashMap(int initialCapacity, float loadFactor) {\n+        super();\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n+        }\n+        if (loadFactor <= 0) {\n             throw new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n-\n-        if (initialCapacity == 0)\n+        }\n+        if (initialCapacity == 0) {\n             initialCapacity = 1;\n+        }\n \n         this.loadFactor = loadFactor;\n         table = new Entry[initialCapacity];\n      *\n      * @return  the number of keys in this hashtable.\n      */\n-    public int size()\n-    {\n+    public int size() {\n         return count;\n     }\n \n      * @return  <code>true</code> if this hashtable maps no keys to values;\n      *          <code>false</code> otherwise.\n      */\n-    public boolean isEmpty()\n-    {\n+    public boolean isEmpty() {\n         return count == 0;\n     }\n \n      * @see        #containsValue(Object)\n      * @see        java.util.Map\n      */\n-    public boolean contains(Object value)\n-    {\n-        if (value == null)\n-        {\n+    public boolean contains(Object value) {\n+        if (value == null) {\n             throw new NullPointerException();\n         }\n \n         Entry tab[] = table;\n-        for (int i = tab.length; i-- > 0;)\n-        {\n-            for (Entry e = tab[i]; e != null; e = e.next)\n-            {\n-                if (e.value.equals(value))\n-                {\n+        for (int i = tab.length; i-- > 0;) {\n+            for (Entry e = tab[i]; e != null; e = e.next) {\n+                if (e.value.equals(value)) {\n                     return true;\n                 }\n             }\n      * @see    java.util.Map\n      * @since JDK1.2\n      */\n-    public boolean containsValue(Object value)\n-    {\n+    public boolean containsValue(Object value) {\n         return contains(value);\n     }\n \n      *    method; <code>false</code> otherwise.\n      * @see #contains(Object)\n      */\n-    public boolean containsKey(int key)\n-    {\n+    public boolean containsKey(int key) {\n         Entry tab[] = table;\n         int hash = key;\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n-        for (Entry e = tab[index]; e != null; e = e.next)\n-        {\n-            if (e.hash == hash)\n-            {\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n                 return true;\n             }\n         }\n      *          this hashtable.\n      * @see     #put(int, Object)\n      */\n-    public Object get(int key)\n-    {\n+    public Object get(int key) {\n         Entry tab[] = table;\n         int hash = key;\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n-        for (Entry e = tab[index]; e != null; e = e.next)\n-        {\n-            if (e.hash == hash)\n-            {\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n                 return e.value;\n             }\n         }\n      * in the hashtable exceeds this hashtable's capacity and load\n      * factor.</p>\n      */\n-    protected void rehash()\n-    {\n+    protected void rehash() {\n         int oldCapacity = table.length;\n         Entry oldMap[] = table;\n \n         threshold = (int) (newCapacity * loadFactor);\n         table = newMap;\n \n-        for (int i = oldCapacity; i-- > 0;)\n-        {\n-            for (Entry old = oldMap[i]; old != null;)\n-            {\n+        for (int i = oldCapacity; i-- > 0;) {\n+            for (Entry old = oldMap[i]; old != null;) {\n                 Entry e = old;\n                 old = old.next;\n \n      * @throws  NullPointerException  if the key is <code>null</code>.\n      * @see     #get(int)\n      */\n-    public Object put(int key, Object value)\n-    {\n+    public Object put(int key, Object value) {\n         // Makes sure the key is not already in the hashtable.\n         Entry tab[] = table;\n         int hash = key;\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n-        for (Entry e = tab[index]; e != null; e = e.next)\n-        {\n-            if (e.hash == hash)\n-            {\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n                 Object old = e.value;\n                 e.value = value;\n                 return old;\n             }\n         }\n \n-        if (count >= threshold)\n-        {\n+        if (count >= threshold) {\n             // Rehash the table if the threshold is exceeded\n             rehash();\n \n      * @return  the value to which the key had been mapped in this hashtable,\n      *          or <code>null</code> if the key did not have a mapping.\n      */\n-    public Object remove(int key)\n-    {\n+    public Object remove(int key) {\n         Entry tab[] = table;\n         int hash = key;\n         int index = (hash & 0x7FFFFFFF) % tab.length;\n-        for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next)\n-        {\n-            if (e.hash == hash)\n-            {\n-                if (prev != null)\n-                {\n+        for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n+            if (e.hash == hash) {\n+                if (prev != null) {\n                     prev.next = e.next;\n-                }\n-                else\n-                {\n+                } else {\n                     tab[index] = e.next;\n                 }\n                 count--;\n     /**\n      * <p>Clears this hashtable so that it contains no keys.</p>\n      */\n-    public synchronized void clear()\n-    {\n-        Entry tab[] = table;\n-        for (int index = tab.length; --index >= 0;)\n+    public synchronized void clear() {\n+        Entry tab[] = table;\n+        for (int index = tab.length; --index >= 0;) {\n             tab[index] = null;\n+        }\n         count = 0;\n     }\n+    \n }", "timestamp": 1059599773, "metainfo": ""}