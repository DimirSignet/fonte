{"sha": "c27f4add9bcb2705e8cf67fdd8b36929b541541f", "log": "[LANG-496] Added LazyInitializer class plus test class.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/concurrent/LazyInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+/**\n+ * <p>\n+ * This class provides a generic implementation of the lazy initialization\n+ * pattern.\n+ * </p>\n+ * <p>\n+ * Sometimes an application has to deal with an object only under certain\n+ * circumstances, e.g. when the user selects a specific menu item or if a\n+ * special event is received. If the creation of the object is costly or the\n+ * consumption of memory or other system resources is significant, it may make\n+ * sense to defer the creation of this object until it is really needed. This is\n+ * a use case for the lazy initialization pattern.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides an implementation of the double-check idiom\n+ * for an instance field as discussed in Joshua Bloch's \"Effective Java\", 2nd\n+ * edition, item 71. The class already implements all necessary synchronization.\n+ * A concrete subclass has to implement the {@code initialize()} method, which\n+ * actually creates the wrapped data object.\n+ * </p>\n+ * <p>\n+ * As an usage example consider that we have a class {@code ComplexObject} whose\n+ * instantiation is a complex operation. In order to apply lazy initialization\n+ * to this class, a subclass of {@code LazyInitializer} has to be created:\n+ *\n+ * <pre>\n+ * public class ComplexObjectInitializer extends LazyInitializer&lt;ComplexObject&gt; {\n+ *     &#064;Override\n+ *     protected ComplexObject initialize() {\n+ *         return new ComplexObject();\n+ *     }\n+ * }\n+ * </pre>\n+ *\n+ * Access to the data object is provided through the {@code get()} method. So,\n+ * code that wants to obtain the {@code ComplexObject} instance would simply\n+ * look like this:\n+ *\n+ * <pre>\n+ * // Create an instance of the lazy initializer\n+ * ComplexObjectInitializer initializer = new ComplexObjectInitializer();\n+ * ...\n+ * // When the object is actually needed:\n+ * ComplexObject cobj = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * If multiple threads call the {@code get()} method when the object has not yet\n+ * been created, they are blocked until initialization completes. The algorithm\n+ * guarantees that only a single instance of the wrapped object class is\n+ * created, which is passed to all callers. Once initialized, calls to the\n+ * {@code get()} method are pretty fast because no synchronization is needed\n+ * (only an access to a <b>volatile</b> member field).\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class LazyInitializer<T> {\n+    /** Stores the managed object. */\n+    private volatile T object;\n+\n+    /**\n+     * Returns the object wrapped by this instance. On first access the object\n+     * is created. After that it is cached and can be accessed pretty fast.\n+     *\n+     * @return the object initialized by this {@code LazyInitializer}\n+     */\n+    public T get() {\n+        T result = object;\n+\n+        if (result == null) {\n+            synchronized (this) {\n+                result = object;\n+                if (result == null) {\n+                    object = result = initialize();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates and initializes the object managed by this {@code\n+     * LazyInitializer}. This method is called by {@link #get()} when the object\n+     * is accessed for the first time. An implementation can focus on the\n+     * creation of the object. No synchronization is needed, as this is already\n+     * handled by {@code get()}.\n+     *\n+     * @return the managed data object\n+     */\n+    protected abstract T initialize();\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/concurrent/LazyInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@code LazyInitializer}.\n+ *\n+ * @version $Id$\n+ */\n+public class LazyInitializerTest extends TestCase {\n+    /** The initializer to be tested. */\n+    private LazyInitializerTestImpl initializer;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        initializer = new LazyInitializerTestImpl();\n+    }\n+\n+    /**\n+     * Tests obtaining the managed object.\n+     */\n+    public void testGet() {\n+        assertNotNull(\"No managed object\", initializer.get());\n+    }\n+\n+    /**\n+     * Tests whether sequential get() invocations always return the same\n+     * instance.\n+     */\n+    public void testGetMultipleTimes() {\n+        Object obj = initializer.get();\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Got different object at \" + i, obj, initializer.get());\n+        }\n+    }\n+\n+    /**\n+     * Tests invoking get() from multiple threads concurrently.\n+     */\n+    public void testGetConcurrent() throws InterruptedException {\n+        final int threadCount = 20;\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+        class GetThread extends Thread {\n+            Object object;\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    // wait until all threads are ready for maximum parallelism\n+                    startLatch.await();\n+                    // access the initializer\n+                    object = initializer.get();\n+                } catch (InterruptedException iex) {\n+                    // ignore\n+                }\n+            }\n+        }\n+\n+        GetThread[] threads = new GetThread[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = new GetThread();\n+            threads[i].start();\n+        }\n+\n+        // fire all threads and wait until they are ready\n+        startLatch.countDown();\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        // check results\n+        Object managedObject = initializer.get();\n+        for (GetThread t : threads) {\n+            assertEquals(\"Wrong object\", managedObject, t.object);\n+        }\n+    }\n+\n+    /**\n+     * A test implementation of LazyInitializer. This class creates a plain\n+     * Object. As Object does not provide a specific equals() method, it is easy\n+     * to check whether multiple instances were created.\n+     */\n+    private static class LazyInitializerTestImpl extends\n+            LazyInitializer<Object> {\n+        @Override\n+        protected Object initialize() {\n+            return new Object();\n+        }\n+    }\n+}", "timestamp": 1253975252, "metainfo": ""}