{"sha": "ab3779080b0c12668cca7fc9f12d6f38d6495892", "log": "Improve Fraction Javadoc, implementation and tests bug 22386, from Phil Steitz   ", "commit": "\n--- a/src/java/org/apache/commons/lang/math/Fraction.java\n+++ b/src/java/org/apache/commons/lang/math/Fraction.java\n  * @author Stephen Colebourne\n  * @author Tim O'Brien\n  * @since 2.0\n- * @version $Id: Fraction.java,v 1.8 2003/08/04 02:01:53 scolebourne Exp $\n+ * @version $Id: Fraction.java,v 1.9 2003/08/13 23:42:17 scolebourne Exp $\n  */\n public final class Fraction extends Number implements Serializable, Comparable {\n \n      * @throws ArithmeticException if the denomiator is <code>zero</code>\n      * @throws ArithmeticException if the denomiator is negative\n      * @throws ArithmeticException if the numerator is negative\n+     * @throws ArithmeticException if the resulting numerator exceeds \n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public static Fraction getFraction(int whole, int numerator, int denominator) {\n         if (denominator == 0) {\n         if (numerator < 0) {\n             throw new ArithmeticException(\"The numerator must not be negative\");\n         }\n+        double numeratorValue = 0;\n         if (whole < 0) {\n-            numerator = whole * denominator - numerator;\n+            numeratorValue = (double) whole * denominator - numerator;\n         } else {\n-            numerator = whole * denominator + numerator;\n-        }\n-        return new Fraction(numerator, denominator);\n+            numeratorValue = (double) whole * denominator + numerator;\n+        }\n+        if (Math.abs(numeratorValue) > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n+        }\n+        return new Fraction((int) numeratorValue, denominator);\n     }\n \n     /**\n             numerator = -numerator;\n             denominator = -denominator;\n         }\n-        int gcd = greatestCommonDenominator(Math.abs(numerator), denominator);\n+        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         return new Fraction(numerator / gcd, denominator / gcd);\n     }\n \n     /**\n      * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n      *\n-     * <p>This method uses the continued fraction algorithm.</p>\n+     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n+     *  continued fraction algorithm</a>, computing a maximum of\n+     *  25 convergents and bounding the denominator by 10,000.</p>\n      *\n      * @param value  the double value to convert\n      * @return a new fraction instance that is close to the value\n-     * @throws ArithmeticException if the value is infinite or <code>NaN</code>\n+     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n+     *  or <code>value = NaN</code>\n      * @throws ArithmeticException if the calculated denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the the algorithm does not converge\n      */\n     public static Fraction getFraction(double value) {\n-        if (Double.isInfinite(value) || Double.isNaN(value)) {\n-            throw new ArithmeticException(\"The value must not be infinite or NaN\");\n-        }\n         int sign = (value < 0 ? -1 : 1);\n         value = Math.abs(value);\n+        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n+            throw new ArithmeticException\n+                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n+        }\n         int wholeNumber = (int) value;\n         value -= wholeNumber;\n-\n-        // http://archives.math.utk.edu/articles/atuyl/confrac/\n+        \n         int numer0 = 0;  // the pre-previous\n         int denom0 = 1;  // the pre-previous\n         int numer1 = 1;  // the previous\n      * @return a new reduce fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n-        int gcd = greatestCommonDenominator(Math.abs(numerator), denominator);\n+        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         return Fraction.getFraction(numerator / gcd, denominator / gcd);\n     }\n \n      *\n      * @param power  the power to raise the fraction to\n      * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n-     * is zero or a new fraction instance raised to the appropriate power\n+     * is zero (even if the fraction equals ZERO) or a new fraction instance \n+     * raised to the appropriate power\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction pow(int power) {\n         if (power == 1) {\n             return this;\n         } else if (power == 0) {\n             return ONE;\n-        } else if (power < 0) {\n-            return getFraction((int) Math.pow(denominator, -power), (int) Math.pow(numerator, -power));\n-        }\n-        return getFraction((int) Math.pow(numerator, power), (int) Math.pow(denominator, power));\n-    }\n-\n-    /**\n-     * <p>Gets the greatest common denominator of two numbers.</p>\n+        } else {\n+            double denominatorValue = Math.pow(denominator, power);\n+            double numeratorValue = Math.pow(numerator, power);\n+            if (numeratorValue > Integer.MAX_VALUE || denominatorValue > Integer.MAX_VALUE) {\n+                throw new ArithmeticException(\"Integer overflow\");\n+            }\n+            if (power < 0) {\n+                return getFraction((int) Math.pow(denominator, -power), \n+                    (int) Math.pow(numerator, -power));\n+            }\n+            return getFraction((int) Math.pow(numerator, power), \n+                (int) Math.pow(denominator, power));\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the greatest common divisor of two numbers.</p>\n      *\n      * @param number1  a positive number\n      * @param number2  a positive number\n-     * @return the greatest common denominator, never zero\n-     */\n-    private static int greatestCommonDenominator(int number1, int number2) {\n+     * @return the greatest common divisor, never zero\n+     */\n+    private static int greatestCommonDivisor(int number1, int number2) {\n         int remainder = number1 % number2;\n         while (remainder != 0) {\n             number1 = number2;\n     //-------------------------------------------------------------------\n \n     /**\n-     * <p>Adds the value of this fraction to another, returning the result.</p>\n-     *\n-     * <p>The implementation spots common cases of zero numerators and equal\n-     * denominators. Otherwise, it uses <code>(a/b) + (c/d) = (a*d + b*c) / (b*d)</code>\n-     * and then reduces the result.</p>\n+     * <p>Adds the value of this fraction to another, returning the result in \n+     * reduced form.</p>\n      *\n      * @param fraction  the fraction to add, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n      * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction add(Fraction fraction) {\n         if (fraction == null) {\n         }\n         if (fraction.numerator == 0) {\n             return this;\n-        }\n-        if (denominator == fraction.denominator) {\n-            return getReducedFraction(numerator + fraction.numerator, denominator);\n-        }\n-        return getReducedFraction(\n-            numerator * fraction.denominator + denominator * fraction.numerator,\n-            denominator * fraction.denominator\n-        );\n+        }     \n+        // Compute lcd explicitly to limit overflow\n+        int gcd = greatestCommonDivisor(Math.abs(fraction.denominator), Math.abs(denominator));\n+        int thisResidue = denominator/gcd;\n+        int thatResidue = fraction.denominator/gcd;\n+        double denominatorValue = Math.abs((double) gcd * thisResidue * thatResidue);\n+        double numeratorValue = (double) numerator * thatResidue + fraction.numerator * thisResidue;\n+        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n+            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n+                throw new ArithmeticException(\"Integer overflow\");\n+        }\n+        return Fraction.getReducedFraction((int) numeratorValue, (int) denominatorValue);\n     }\n \n     /**\n      * <p>Subtracts the value of another fraction from the value of this one,\n-     * returning the result.</p>\n-     *\n-     * <p>The implementation spots common cases of zero numerators and equal\n-     * denominators. Otherwise, it uses <code>(a/b) - (c/d) = (a*d - b*c) / (b*d)</code>\n-     * and then reduces the result.</p>\n+     * returning the result in reduced form.</p>\n      *\n      * @param fraction  the fraction to subtract, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n      * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction subtract(Fraction fraction) {\n         if (fraction == null) {\n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n-        if (numerator == 0) {\n-            return fraction.negate();\n-        }\n-        if (fraction.numerator == 0) {\n-            return this;\n-        }\n-        if (denominator == fraction.denominator) {\n-            return getReducedFraction(numerator - fraction.numerator, denominator);\n-        }\n-        return getReducedFraction(\n-            numerator * fraction.denominator - denominator * fraction.numerator,\n-            denominator * fraction.denominator\n-        );\n-    }\n-\n-    /**\n-     * <p>Multiplies the value of this fraction by another, returning the result.</p>\n-     *\n-     * <p>The implementation uses <code>(a/b)*(c/d) = (a*c)/(b*d)</code>\n-     * and then reduces the result.</p>\n+        return add(fraction.negate());\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the result \n+     * in reduced form.</p>\n      *\n      * @param fraction  the fraction to multipy by, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n      * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction multiplyBy(Fraction fraction) {\n         if (fraction == null) {\n         if (numerator == 0 || fraction.numerator == 0) {\n             return ZERO;\n         }\n-        return getReducedFraction(\n-            numerator * fraction.numerator,\n-            denominator * fraction.denominator\n-        );\n-    }\n-\n-    /**\n-     * <p>Divide the value of this fraction by another, returning the result.</p>\n-     *\n-     * <p>The implementation uses <code>(a/b)/(c/d) = a/b * d/c = (a*d)/(b*c)</code>\n-     * and then reduces the result.</p>\n+        double numeratorValue = (double) numerator * fraction.numerator;\n+        double denominatorValue = (double) denominator * fraction.denominator;\n+        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n+            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n+                throw new ArithmeticException(\"Integer overflow\");\n+        }\n+        return getReducedFraction((int) numeratorValue, (int) denominatorValue);\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another, returning the result \n+     * in reduced form.</p>\n      *\n      * @param fraction  the fraction to divide by, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n      * @throws IllegalArgumentException if the fraction is <code>null</code>\n      * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction divideBy(Fraction fraction) {\n         if (fraction == null) {\n         }\n         if (numerator == 0) {\n             return ZERO;\n-        }\n-        return getReducedFraction(\n-            numerator * fraction.denominator,\n-            denominator * fraction.numerator\n-        );\n+        }  \n+        double numeratorValue = (double) numerator * fraction.denominator;\n+        double denominatorValue = (double) denominator * fraction.numerator;\n+        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n+            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n+                throw new ArithmeticException(\"Integer overflow\");\n+        }\n+        return getReducedFraction((int) numeratorValue, (int) denominatorValue);\n     }\n \n     // Basics\n      * <p>Compares this object to another based on size.</p>\n      *\n      * @param object  the object to compare to\n-     * @return -ve if this is less, 0 if equal, +ve if greater\n+     * @return -1 if this is less, 0 if equal, +1 if greater\n      * @throws ClassCastException if the object is not a <code>Fraction</code>\n      * @throws NullPointerException if the object is <code>null</code>\n      */\n--- a/src/test/org/apache/commons/lang/math/FractionTest.java\n+++ b/src/test/org/apache/commons/lang/math/FractionTest.java\n  * Test cases for the {@link Fraction} classes.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: FractionTest.java,v 1.3 2003/08/04 02:01:53 scolebourne Exp $\n+ * @version $Id: FractionTest.java,v 1.4 2003/08/13 23:42:17 scolebourne Exp $\n  */\n public class FractionTest extends TestCase {\n     \n-    private static final int SKIP = 17;\n+    private static final int SKIP = 53;\n \n     public FractionTest(String name) {\n         super(name);\n         // zero denominator\n         try {\n             f = Fraction.getFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n     }\n \n         // negatives\n         try {\n             f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         // negative whole\n         \n         try {\n             f = Fraction.getFraction(-1, -6, 10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(-1, 6, -10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         // zero denominator\n         try {\n             f = Fraction.getFraction(0, 1, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(1, 2, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-1, -3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2); \n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n     }\n \n         // zero denominator\n         try {\n             f = Fraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getReducedFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getReducedFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n \n         // reduced        \n         \n         try {\n             f = Fraction.getFraction(Double.NaN);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(Double.POSITIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(Double.NEGATIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction((double) Integer.MAX_VALUE + 1);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         // zero\n                 assertEquals(f2.getDenominator(), f.getDenominator());\n             }\n         }\n-        // save time by skipping some tests!\n+        // save time by skipping some tests!  (\n         for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator\n             for (int j = 1; j <= i; j++) {  // numerator\n                 try {\n     public void testFactory_String() {\n         try {\n             Fraction.getFraction(null);\n+            fail(\"expecting ArithmeticException\");\n         } catch (IllegalArgumentException ex) {}\n     }\n+    \n     \n     public void testFactory_String_double() {\n         Fraction f = null;\n         } catch (NumberFormatException ex) {}\n         \n         try {\n+            f = Fraction.getFraction(\"2147483648\"); // too big\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n             f = Fraction.getFraction(\".\");\n         } catch (NumberFormatException ex) {}\n     }\n         \n         try {\n             f = Fraction.getFraction(\"2 3\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"a 3\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 b/4\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 \");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n \n         try {\n             f = Fraction.getFraction(\" 3\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\" \");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n     }\n \n         \n         try {\n             f = Fraction.getFraction(\"2/d\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2e/3\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2/\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"/\");\n+            fail(\"expecting NumberFomatException\");\n         } catch (NumberFormatException ex) {}\n     }\n \n         f = f.pow(-2);\n         assertEquals(25, f.getNumerator());\n         assertEquals(9, f.getDenominator());\n+        \n+        f = Fraction.getFraction(Integer.MAX_VALUE);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n     \n     public void testAdd() {\n         f = f1.add(f2);\n         assertEquals(-1, f.getNumerator());\n         assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n         \n         f1 = Fraction.getFraction(3, 5);\n         f2 = Fraction.getFraction(1, 2);\n         f = f1.add(f2);\n         assertEquals(11, f.getNumerator());\n         assertEquals(10, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 8);\n+        f2 = Fraction.getFraction(1, 6);\n+        f = f1.add(f2);\n+        assertEquals(13, f.getNumerator());\n+        assertEquals(24, f.getDenominator());\n         \n         f1 = Fraction.getFraction(0, 5);\n         f2 = Fraction.getFraction(1, 5);\n         \n         try {\n             f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n     }\n             \n     public void testSubtract() {\n         \n         try {\n             f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+            \n     }\n             \n     public void testMultiply() {\n         f = f1.multiplyBy(f2);\n         assertSame(Fraction.ZERO, f);\n         \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.multiplyBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n         try {\n             f.multiplyBy(null);\n+            fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n             \n     public void testDivide() {\n         f2 = Fraction.ZERO;\n         try {\n             f = f1.divideBy(f2);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n         \n         f1 = Fraction.getFraction(0, 5);\n         f = f1.divideBy(f2);\n         assertSame(Fraction.ZERO, f);\n         \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divideBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n         try {\n             f.divideBy(null);\n+            fail(\"IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n             \n     public void testEquals() {\n         \n         try {\n             f1.compareTo(null);\n+            fail(\"expecting NullPointerException\");\n         } catch (NullPointerException ex) {}\n         \n         try {\n             f1.compareTo(new Object());\n+            fail(\"expecting ClassCastException\");\n         } catch (ClassCastException ex) {}\n         \n         f2 = Fraction.getFraction(2, 5);", "timestamp": 1060818137, "metainfo": ""}