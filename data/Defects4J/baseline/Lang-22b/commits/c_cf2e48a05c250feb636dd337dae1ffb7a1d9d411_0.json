{"sha": "cf2e48a05c250feb636dd337dae1ffb7a1d9d411", "log": "Change StringUtils arguments from String to CharSequence.  Details: Working with (trunk) StringUtils (SU) I see the following emerge:   - In SVN already and continuing: Change StringUtils arguments from String to CharSequence (CS).  - This leads to replacing calls to String.substring(int[,int]) with calls to CharSequence.subSequence(int)  - This leads to creating a CharSequenceUtils class (in SVN now, more on this new class below) and CharSequenceUtils.subSequence(CharSequence,int) to avoid changing \"str.substring(start)\" over and over to \"str.subSequence(start, str.length())\". For examples, see new versions of capitalize and uncapitalize.  - We end up using a toString() on CharSequence to return a String from StringUtil when working with a CharSequence.  So we have StringUtils using CharSequence inputs as much as possible instead of String, which is nice.   The CharSequence method subSequence returns a CharSequence; though the Javadoc states \"Returns a new CharSequence that is a subsequence of this sequence.\", this does not guaranteed the return value to be the same kind of CharSequence as the receiver). Since we are after all in a class called StringUtil, calling toString() is a must.  I propose that we create when possible the methods that are now StringUtils CharSequence methods into CharSequenceUtils and let StringUtil call CharSequenceUtils and then do its toString() and other String specific logic. Later we could have other CharSequence type of utils (for CharBuffer, StringBuiler, StringBuffer, etc) that use the 'primitives' from CharSequenceUtils. This means that for methods that are based solely on methods that are now in CharSequence, these can be moved to CharSequenceUtils without effort (all is* methods only call CharSequence#length() and charAt() for example and are now typed as CS, still in SU).   We can leave @deprecateds method in SU as a nicety to avoid too much porting pain: First change the package to lang3 then you can 'optimize' by changing call sites from SU to CSU.  As a start, I put in SVN a CharSequenceUtils (CSU) implementation for length() and subSequence().   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * Null-safe CharSequence utility methods.\n+ * \n+ * @author Gary Gregory\n+ */\n+public class CharSequenceUtils {\n+\n+\t/**\n+\t * Gets a CharSequence length or <code>0</code> if the CharSequence is\n+\t * <code>null</code>.\n+\t * \n+\t * @param cs\n+\t *            a CharSequence or <code>null</code>\n+\t * @return CharSequence length or <code>0</code> if the CharSequence is\n+\t *         <code>null</code>.\n+\t * @since 3.0\n+\t */\n+\tpublic static int length(CharSequence cs) {\n+\t\treturn cs == null ? 0 : cs.length();\n+\t}\n+\n+    /**\n+     * <p>Reverses a CharSequence as per {@link StringBuilder#reverse()}.</p>\n+     *\n+     * <p>A <code>null</code> CharSequence returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * CharSequenceUtils.reverse(null) = null\n+     * CharSequenceUtils.reverse(\"\").toString() = \"\"\n+     * CharSequenceUtils.reverse(\"bat\").toString() = \"tab\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @return the reversed String, <code>null</code> if null String input\n+     */\n+    public static CharSequence reverse(CharSequence str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new StringBuilder(str).reverse();\n+    }\n+    \n+\t/**\n+\t * Returns a new <code>CharSequence</code> that is a subsequence of this\n+\t * sequence starting with the <code>char</code> value at the specified\n+\t * index. The length (in <code>char</code>s) of the returned sequence is\n+\t * <code>length() - start</code>, so if <code>start == end</code> then an\n+\t * empty sequence is returned. </p>\n+\t * \n+\t * @param start\n+\t *            the start index, inclusive\n+\t * \n+\t * @return the specified subsequence\n+\t * \n+\t * @throws IndexOutOfBoundsException\n+\t *             if <code>start</code> is negative or if <code>start</code> is\n+\t *             greater than <code>length()</code>\n+\t * @since 3.0\n+\t */\n+\tpublic static CharSequence subSequence(CharSequence cs, int start) {\n+\t\treturn cs == null ? null : cs.subSequence(start, cs.length());\n+\t}\n+}\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     // Empty checks\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if a String is empty (\"\") or null.</p>\n+     * <p>Checks if a CharSequence is empty (\"\") or null.</p>\n      *\n      * <pre>\n      * StringUtils.isEmpty(null)      = true\n      * </pre>\n      *\n      * <p>NOTE: This method changed in Lang version 2.0.\n-     * It no longer trims the String.\n+     * It no longer trims the CharSequence.\n      * That functionality is available in isBlank().</p>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is empty or null\n-     */\n-    public static boolean isEmpty(CharSequence str) {\n-        return str == null || str.length() == 0;\n-    }\n-\n-    /**\n-     * <p>Checks if a String is not empty (\"\") and not null.</p>\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is empty or null\n+     */\n+    public static boolean isEmpty(CharSequence cs) {\n+        return cs == null || cs.length() == 0;\n+    }\n+\n+    /**\n+     * <p>Checks if a CharSequence is not empty (\"\") and not null.</p>\n      *\n      * <pre>\n      * StringUtils.isNotEmpty(null)      = false\n      * StringUtils.isNotEmpty(\"  bob  \") = true\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is not empty and not null\n-     */\n-    public static boolean isNotEmpty(CharSequence str) {\n-        return !StringUtils.isEmpty(str);\n-    }\n-\n-    /**\n-     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is not empty and not null\n+     */\n+    public static boolean isNotEmpty(CharSequence cs) {\n+        return !StringUtils.isEmpty(cs);\n+    }\n+\n+    /**\n+     * <p>Checks if a CharSequence is whitespace, empty (\"\") or null.</p>\n      *\n      * <pre>\n      * StringUtils.isBlank(null)      = true\n      * StringUtils.isBlank(\"  bob  \") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is null, empty or whitespace\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is null, empty or whitespace\n      * @since 2.0\n      */\n-    public static boolean isBlank(CharSequence str) {\n+    public static boolean isBlank(CharSequence cs) {\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n+        if (cs == null || (strLen = cs.length()) == 0) {\n             return true;\n         }\n         for (int i = 0; i < strLen; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n+     * <p>Checks if a CharSequence is not empty (\"\"), not null and not whitespace only.</p>\n      *\n      * <pre>\n      * StringUtils.isNotBlank(null)      = false\n      * StringUtils.isNotBlank(\"  bob  \") = true\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @return <code>true</code> if the String is\n+     * @param cs  the CharSequence to check, may be null\n+     * @return <code>true</code> if the CharSequence is\n      *  not empty and not null and not whitespace\n      * @since 2.0\n      */\n-    public static boolean isNotBlank(CharSequence str) {\n-        return !StringUtils.isBlank(str);\n+    public static boolean isNotBlank(CharSequence cs) {\n+        return !StringUtils.isBlank(cs);\n     }\n \n     // Trim\n     // Equals\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n+     * <p>Compares two CharSequences, returning <code>true</code> if they are equal.</p>\n      *\n      * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n      * references are considered to be equal. The comparison is case sensitive.</p>\n      * </pre>\n      *\n      * @see java.lang.String#equals(Object)\n-     * @param str1  the first String, may be null\n-     * @param str2  the second String, may be null\n-     * @return <code>true</code> if the Strings are equal, case sensitive, or\n+     * @param cs1  the first CharSequence, may be null\n+     * @param cs2  the second CharSequence, may be null\n+     * @return <code>true</code> if the CharSequences are equal, case sensitive, or\n      *  both <code>null</code>\n      */\n-    public static boolean equals(String str1, String str2) {\n-        return str1 == null ? str2 == null : str1.equals(str2);\n+    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n+        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n     }\n \n     /**\n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character in the given set of characters.</p>\n      *\n      * <p>A <code>null</code> String will return <code>-1</code>.\n      * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAny(String str, char[] searchChars) {\n-        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAny(CharSequence cs, char[] searchChars) {\n+        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return -1;\n         }\n-        for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     return i;\n     }\n \n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character in the given set of characters.</p>\n      *\n      * <p>A <code>null</code> String will return <code>-1</code>.\n      * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAny(String str, String searchChars) {\n-        if (isEmpty(str) || isEmpty(searchChars)) {\n+    public static int indexOfAny(CharSequence cs, String searchChars) {\n+        if (isEmpty(cs) || isEmpty(searchChars)) {\n             return -1;\n         }\n-        return indexOfAny(str, searchChars.toCharArray());\n+        return indexOfAny(cs, searchChars.toCharArray());\n     }\n \n     // ContainsAny\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains any character in the given\n+     * <p>Checks if the CharSequence contains any character in the given\n      * set of characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n      *\n      * <pre>\n      * StringUtils.containsAny(\"aba\", ['z'])           = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the <code>true</code> if any of the chars are found,\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String str, char[] searchChars) {\n-        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n+        if (cs == null || cs.length() == 0 || searchChars == null || searchChars.length == 0) {\n             return false;\n         }\n-        for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     return true;\n \n     /**\n      * <p>\n-     * Checks if the String contains any character in the given set of characters.\n+     * Checks if the CharSequence contains any character in the given set of characters.\n      * </p>\n      * \n      * <p>\n-     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n+     * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return\n      * <code>false</code>.\n      * </p>\n      * \n      * StringUtils.containsAny(\"aba\",\"z\")          = false\n      * </pre>\n      * \n-     * @param str\n-     *            the String to check, may be null\n+     * @param cs\n+     *            the CharSequence to check, may be null\n      * @param searchChars\n      *            the chars to search for, may be null\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String str, String searchChars) {\n+    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(str, searchChars.toCharArray());\n+        return containsAny(cs, searchChars.toCharArray());\n     }\n \n     // IndexOfAnyBut chars\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Searches a CharSequence to find the first index of any\n      * character not in the given set of characters.</p>\n      *\n-     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * <p>A <code>null</code> CharSequence will return <code>-1</code>.\n      * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAnyBut(String str, char[] searchChars) {\n-        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n+        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return -1;\n         }\n-        outer : for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n+        outer : for (int i = 0; i < cs.length(); i++) {\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < searchChars.length; j++) {\n                 if (searchChars[j] == ch) {\n                     continue outer;\n     // ContainsOnly\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains only certain characters.</p>\n-     *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+     * <p>Checks if the CharSequence contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> valid character array will return <code>false</code>.\n-     * An empty String (\"\") always returns <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) always returns <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.containsOnly(null, *)       = false\n      * StringUtils.containsOnly(\"abz\", 'abc')  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the String to check, may be null\n      * @param valid  an array of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      */\n-    public static boolean containsOnly(String str, char[] valid) {\n+    public static boolean containsOnly(CharSequence cs, char[] valid) {\n         // All these pre-checks are to maintain API with an older version\n-        if ((valid == null) || (str == null)) {\n+        if (valid == null || cs == null) {\n             return false;\n         }\n-        if (str.length() == 0) {\n+        if (cs.length() == 0) {\n             return true;\n         }\n         if (valid.length == 0) {\n             return false;\n         }\n-        return indexOfAnyBut(str, valid) == -1;\n-    }\n-\n-    /**\n-     * <p>Checks if the String contains only certain characters.</p>\n-     *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n+        return indexOfAnyBut(cs, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the CharSequence contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n      * A <code>null</code> valid character String will return <code>false</code>.\n-     * An empty String (\"\") always returns <code>true</code>.</p>\n+     * An empty String (length()=0) always returns <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.containsOnly(null, *)       = false\n      * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param validChars  a String of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 2.0\n      */\n-    public static boolean containsOnly(String str, String validChars) {\n-        if (str == null || validChars == null) {\n+    public static boolean containsOnly(CharSequence cs, String validChars) {\n+        if (cs == null || validChars == null) {\n             return false;\n         }\n-        return containsOnly(str, validChars.toCharArray());\n+        return containsOnly(cs, validChars.toCharArray());\n     }\n \n     // ContainsNone\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks that the String does not contain certain characters.</p>\n-     *\n-     * <p>A <code>null</code> String will return <code>true</code>.\n+     * <p>Checks that the CharSequence does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> CharSequence will return <code>true</code>.\n      * A <code>null</code> invalid character array will return <code>true</code>.\n-     * An empty String (\"\") always returns true.</p>\n+     * An empty CharSequence (length()=0) always returns true.</p>\n      *\n      * <pre>\n      * StringUtils.containsNone(null, *)       = true\n      * StringUtils.containsNone(\"abz\", 'xyz')  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param invalidChars  an array of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n      */\n-    public static boolean containsNone(String str, char[] invalidChars) {\n-        if (str == null || invalidChars == null) {\n+    public static boolean containsNone(CharSequence cs, char[] invalidChars) {\n+        if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        int strSize = str.length();\n+        int strSize = cs.length();\n         int validSize = invalidChars.length;\n         for (int i = 0; i < strSize; i++) {\n-            char ch = str.charAt(i);\n+            char ch = cs.charAt(i);\n             for (int j = 0; j < validSize; j++) {\n                 if (invalidChars[j] == ch) {\n                     return false;\n     }\n \n     /**\n-     * <p>Checks that the String does not contain certain characters.</p>\n-     *\n-     * <p>A <code>null</code> String will return <code>true</code>.\n+     * <p>Checks that the CharSequence does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> CharSequence will return <code>true</code>.\n      * A <code>null</code> invalid character array will return <code>true</code>.\n      * An empty String (\"\") always returns true.</p>\n      *\n      * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @param invalidChars  a String of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n      */\n-    public static boolean containsNone(String str, String invalidChars) {\n-        if (str == null || invalidChars == null) {\n+    public static boolean containsNone(CharSequence cs, String invalidChars) {\n+        if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        return containsNone(str, invalidChars.toCharArray());\n+        return containsNone(cs, invalidChars.toCharArray());\n     }\n \n     // IndexOfAny strings\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      */\n     public static int indexOfAny(String str, String[] searchStrs) {\n-        if ((str == null) || (searchStrs == null)) {\n+        if (str == null || searchStrs == null) {\n             return -1;\n         }\n         int sz = searchStrs.length;\n         }\n     }\n \n-    /**\n-     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n-     * \n-     * @param str\n-     *            a String or <code>null</code>\n-     * @return String length or <code>0</code> if the String is <code>null</code>.\n-     * @since 2.4\n-     */\n-    public static int length(CharSequence str) {\n-        return str == null ? 0 : str.length();\n-    }\n+\t/**\n+\t * Gets a CharSequence length or <code>0</code> if the CharSequence is\n+\t * <code>null</code>.\n+\t * \n+\t * @param cs\n+\t *            a CharSequence or <code>null</code>\n+\t * @return CharSequence length or <code>0</code> if the CharSequence is\n+\t *         <code>null</code>.\n+\t * @since 2.4\n+\t * @deprecated See {@link CharSequenceUtils#length(CharSequence)}\n+\t */\n+\tpublic static int length(CharSequence cs) {\n+\t\treturn CharSequenceUtils.length(cs);\n+\t}\n     \n     // Centering\n     //-----------------------------------------------------------------------\n      * StringUtils.capitalize(\"cAt\") = \"CAt\"\n      * </pre>\n      *\n-     * @param str  the String to capitalize, may be null\n+     * @param cs the String to capitalize, may be null\n      * @return the capitalized String, <code>null</code> if null String input\n      * @see WordUtils#capitalize(String)\n      * @see #uncapitalize(String)\n      * @since 2.0\n      */\n-    public static String capitalize(String str) {\n+    public static String capitalize(CharSequence cs) {\n+        if (cs == null ) {\n+            return null;\n+        }\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n-            return str;\n+        if ((strLen = cs.length()) == 0) {\n+            return cs.toString();\n         }\n         return new StringBuilder(strLen)\n-            .append(Character.toTitleCase(str.charAt(0)))\n-            .append(str.substring(1))\n+            .append(Character.toTitleCase(cs.charAt(0)))\n+            .append(CharSequenceUtils.subSequence(cs, 1))\n             .toString();\n     }\n \n     /**\n-     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * <p>Uncapitalizes a CharSequence changing the first letter to title case as\n      * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n      *\n      * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.\n      * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n      * </pre>\n      *\n-     * @param str  the String to uncapitalize, may be null\n+     * @param cs the String to uncapitalize, may be null\n      * @return the uncapitalized String, <code>null</code> if null String input\n      * @see WordUtils#uncapitalize(String)\n-     * @see #capitalize(String)\n+     * @see #capitalize(CharSequence)\n      * @since 2.0\n      */\n-    public static String uncapitalize(String str) {\n+    public static String uncapitalize(CharSequence cs) {\n+        if (cs == null ) {\n+            return null;\n+        }\n         int strLen;\n-        if (str == null || (strLen = str.length()) == 0) {\n-            return str;\n+        if ((strLen = cs.length()) == 0) {\n+            return cs.toString();\n         }\n         return new StringBuilder(strLen)\n-            .append(Character.toLowerCase(str.charAt(0)))\n-            .append(str.substring(1))\n+            .append(Character.toLowerCase(cs.charAt(0)))\n+            .append(CharSequenceUtils.subSequence(cs, 1))\n             .toString();\n     }\n \n     // Character Tests\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the String contains only unicode letters.</p>\n+     * <p>Checks if the CharSequence contains only unicode letters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlpha(null)   = false\n      * StringUtils.isAlpha(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters, and is non-null\n      */\n-    public static boolean isAlpha(String str) {\n-        if (str == null) {\n+    public static boolean isAlpha(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLetter(str.charAt(i)) == false) {\n+            if (Character.isLetter(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters and\n+     * <p>Checks if the CharSequence contains only unicode letters and\n      * space (' ').</p>\n      *\n      * <p><code>null</code> will return <code>false</code>\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphaSpace(null)   = false\n      * StringUtils.isAlphaSpace(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters and space,\n      *  and is non-null\n      */\n-    public static boolean isAlphaSpace(String str) {\n-        if (str == null) {\n+    public static boolean isAlphaSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters or digits.</p>\n+     * <p>Checks if the CharSequence contains only unicode letters or digits.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphanumeric(null)   = false\n      * StringUtils.isAlphanumeric(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters or digits,\n      *  and is non-null\n      */\n-    public static boolean isAlphanumeric(String str) {\n-        if (str == null) {\n+    public static boolean isAlphanumeric(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+            if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode letters, digits\n+     * <p>Checks if the CharSequence contains only unicode letters, digits\n      * or space (<code>' '</code>).</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAlphanumeric(null)   = false\n      * StringUtils.isAlphanumeric(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains letters, digits or space,\n      *  and is non-null\n      */\n-    public static boolean isAlphanumericSpace(String str) {\n-        if (str == null) {\n+    public static boolean isAlphanumericSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the string contains only ASCII printable characters.</p>\n+     * <p>Checks if the CharSequence contains only ASCII printable characters.</p>\n      * \n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      * \n      * <pre>\n      * StringUtils.isAsciiPrintable(null)     = false\n      * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n      * </pre>\n      *\n-     * @param str the string to check, may be null\n+     * @param cs the CharSequence to check, may be null\n      * @return <code>true</code> if every character is in the range\n      *  32 thru 126\n      * @since 2.1\n      */\n-    public static boolean isAsciiPrintable(String str) {\n-        if (str == null) {\n+    public static boolean isAsciiPrintable(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n+            if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode digits.\n+     * <p>Checks if the CharSequence contains only unicode digits.\n      * A decimal point is not a unicode digit and returns false.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isNumeric(null)   = false\n      * StringUtils.isNumeric(\"12.3\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains digits, and is non-null\n      */\n-    public static boolean isNumeric(String str) {\n-        if (str == null) {\n+    public static boolean isNumeric(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isDigit(str.charAt(i)) == false) {\n+            if (Character.isDigit(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only unicode digits or space\n+     * <p>Checks if the CharSequence contains only unicode digits or space\n      * (<code>' '</code>).\n      * A decimal point is not a unicode digit and returns false.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isNumeric(null)   = false\n      * StringUtils.isNumeric(\"12.3\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains digits or space,\n      *  and is non-null\n      */\n-    public static boolean isNumericSpace(String str) {\n-        if (str == null) {\n+    public static boolean isNumericSpace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only whitespace.</p>\n+     * <p>Checks if the CharSequence contains only whitespace.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>true</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isWhitespace(null)   = false\n      * StringUtils.isWhitespace(\"ab-c\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains whitespace, and is non-null\n      * @since 2.0\n      */\n-    public static boolean isWhitespace(String str) {\n-        if (str == null) {\n+    public static boolean isWhitespace(CharSequence cs) {\n+        if (cs == null) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only lowercase characters.</p>\n+     * <p>Checks if the CharSequence contains only lowercase characters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>false</code>.</p>\n+     * An empty CharSequence (length()=0) will return <code>false</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAllLowerCase(null)   = false\n      * StringUtils.isAllLowerCase(\"abC\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs  the CharSequence to check, may be null\n      * @return <code>true</code> if only contains lowercase characters, and is non-null\n      * @since 2.5\n      */\n-    public static boolean isAllLowerCase(String str) {\n-        if (str == null || isEmpty(str)) {\n+    public static boolean isAllLowerCase(CharSequence cs) {\n+        if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isLowerCase(str.charAt(i)) == false) {\n+            if (Character.isLowerCase(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if the String contains only uppercase characters.</p>\n+     * <p>Checks if the CharSequence contains only uppercase characters.</p>\n      *\n      * <p><code>null</code> will return <code>false</code>.\n-     * An empty String (\"\") will return <code>false</code>.</p>\n+     * An empty String (length()=0) will return <code>false</code>.</p>\n      *\n      * <pre>\n      * StringUtils.isAllUpperCase(null)   = false\n      * StringUtils.isAllUpperCase(\"aBC\") = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param cs the CharSequence to check, may be null\n      * @return <code>true</code> if only contains uppercase characters, and is non-null\n      * @since 2.5\n      */\n-    public static boolean isAllUpperCase(String str) {\n-        if (str == null || isEmpty(str)) {\n+    public static boolean isAllUpperCase(CharSequence cs) {\n+        if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = str.length();\n+        int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if (Character.isUpperCase(str.charAt(i)) == false) {\n+            if (Character.isUpperCase(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n         if (str == null) {\n             return null;\n         }\n-        return new StringBuilder(str).reverse().toString();\n+        return CharSequenceUtils.reverse(str).toString();\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Compares two Strings, and returns the index at which the\n-     * Strings begin to differ.</p>\n+     * <p>Compares two CharSequences, and returns the index at which the\n+     * CharSequences begin to differ.</p>\n      *\n      * <p>For example,\n      * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n      * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n      * </pre>\n      *\n-     * @param str1  the first String, may be null\n-     * @param str2  the second String, may be null\n-     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     * @param cs1  the first CharSequence, may be null\n+     * @param cs2  the second CharSequence, may be null\n+     * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n      * @since 2.0\n      */\n-    public static int indexOfDifference(String str1, String str2) {\n-        if (str1 == str2) {\n+    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n+        if (cs1 == cs2) {\n             return -1;\n         }\n-        if (str1 == null || str2 == null) {\n+        if (cs1 == null || cs2 == null) {\n             return 0;\n         }\n         int i;\n-        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n-            if (str1.charAt(i) != str2.charAt(i)) {\n+        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n+            if (cs1.charAt(i) != cs2.charAt(i)) {\n                 break;\n             }\n         }\n-        if (i < str2.length() || i < str1.length()) {\n+        if (i < cs2.length() || i < cs1.length()) {\n             return i;\n         }\n         return -1;\n     }\n \n     /**\n-     * <p>Compares all Strings in an array and returns the index at which the\n-     * Strings begin to differ.</p>\n+     * <p>Compares all CharSequences in an array and returns the index at which the\n+     * CharSequences begin to differ.</p>\n      *\n      * <p>For example,\n      * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n      * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n      * </pre>\n      *\n-     * @param strs  array of strings, entries may be null\n+     * @param css  array of CharSequences, entries may be null\n      * @return the index where the strings begin to differ; -1 if they are all equal\n      * @since 2.4\n      */\n-    public static int indexOfDifference(String[] strs) {\n-        if (strs == null || strs.length <= 1) {\n+    public static int indexOfDifference(CharSequence[] css) {\n+        if (css == null || css.length <= 1) {\n             return -1;\n         }\n         boolean anyStringNull = false;\n         boolean allStringsNull = true;\n-        int arrayLen = strs.length;\n+        int arrayLen = css.length;\n         int shortestStrLen = Integer.MAX_VALUE;\n         int longestStrLen = 0;\n \n         // sure we are not exceeding the length of the string each time through\n         // the bottom loop.\n         for (int i = 0; i < arrayLen; i++) {\n-            if (strs[i] == null) {\n+            if (css[i] == null) {\n                 anyStringNull = true;\n                 shortestStrLen = 0;\n             } else {\n                 allStringsNull = false;\n-                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n-                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n+                shortestStrLen = Math.min(css[i].length(), shortestStrLen);\n+                longestStrLen = Math.max(css[i].length(), longestStrLen);\n             }\n         }\n \n         // find the position with the first difference across all strings\n         int firstDiff = -1;\n         for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n-            char comparisonChar = strs[0].charAt(stringPos);\n+            char comparisonChar = css[0].charAt(stringPos);\n             for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n-                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n+                if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                     firstDiff = stringPos;\n                     break;\n                 }\n      * @return result distance\n      * @throws IllegalArgumentException if either String input <code>null</code>\n      */\n-    public static int getLevenshteinDistance(String s, String t) {\n+    public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n         if (s == null || t == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n \n         if (n > m) {\n             // swap the input strings to consume less memory\n-            String tmp = s;\n+        \tCharSequence tmp = s;\n             s = t;\n             t = tmp;\n             n = m;\n      */\n     private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n         if (str == null || suffix == null) {\n-            return (str == null && suffix == null);\n+            return str == null && suffix == null;\n         }\n         if (suffix.length() > str.length()) {\n             return false;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.nio.CharBuffer;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests CharSequenceUtils\n+ * \n+ * @author Gary Gregory\n+ */\n+public class CharSequenceUtilsTest extends TestCase {\n+\n+\tpublic void testLength_CharBuffer() {\n+\t\tAssert.assertEquals(0, CharSequenceUtils.length(CharBuffer.wrap(\"\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\"A\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\" \")));\n+\t\tAssert.assertEquals(8, CharSequenceUtils.length(CharBuffer.wrap(\"ABCDEFGH\")));\n+\t}\n+\n+\tpublic void testLength_String() {\n+\t\tAssert.assertEquals(0, CharSequenceUtils.length(null));\n+\t\tAssert.assertEquals(0, CharSequenceUtils.length(\"\"));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(\"A\"));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(\" \"));\n+\t\tAssert.assertEquals(8, CharSequenceUtils.length(\"ABCDEFGH\"));\n+\t}\n+\n+\tpublic void testLength_StringBuffer() {\n+\t\tAssert.assertEquals(0, CharSequenceUtils.length(new StringBuffer(\"\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\"A\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\" \")));\n+\t\tAssert.assertEquals(8, CharSequenceUtils.length(new StringBuffer(\"ABCDEFGH\")));\n+\t}\n+\n+\tpublic void testLength_StringBuilder() {\n+\t\tAssert.assertEquals(0, CharSequenceUtils.length(new StringBuilder(\"\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\"A\")));\n+\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\" \")));\n+\t\tAssert.assertEquals(8, CharSequenceUtils.length(new StringBuilder(\"ABCDEFGH\")));\n+\t}\n+\n+\tpublic void testSubSequence() {\n+\t\t//\n+\t\t// null input\n+\t\t//\n+\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, -1));\n+\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, 0));\n+\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, 1));\n+\t\t//\n+\t\t// non-null input\n+\t\t//\n+\t\tAssert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0));\n+\t\tAssert.assertEquals(\"012\", CharSequenceUtils.subSequence(\"012\", 0));\n+\t\tAssert.assertEquals(\"12\", CharSequenceUtils.subSequence(\"012\", 1));\n+\t\tAssert.assertEquals(\"2\", CharSequenceUtils.subSequence(\"012\", 2));\n+\t\tAssert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(\"012\", 3));\n+\t\t//\n+\t\t// Exception expected\n+\t\t//\n+\t\ttry {\n+\t\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));\n+\t\t\tAssert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+\t\t} catch (IndexOutOfBoundsException e) {\n+\t\t\t// Expected\n+\t\t}\n+\t\ttry {\n+\t\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));\n+\t\t\tAssert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+\t\t} catch (IndexOutOfBoundsException e) {\n+\t\t\t// Expected\n+\t\t}\n+\t}\n+\n+}\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n         assertEquals(\"capitalize(empty-string) failed\",\n                      \"\", StringUtils.capitalize(\"\") );\n         assertEquals(\"capitalize(single-char-string) failed\",\n-                     \"X\", StringUtils.capitalize(\"x\") );\n+                \"X\", StringUtils.capitalize(\"x\") );\n+        assertEquals(\"capitalize(single-char-string) failed\",\n+                \"X\", StringUtils.capitalize(new StringBuilder(\"x\")) );\n+        assertEquals(\"capitalize(single-char-string) failed\",\n+                \"X\", StringUtils.capitalize(new StringBuffer(\"x\")) );\n+        assertEquals(\"capitalize(single-char-string) failed\",\n+                \"X\", StringUtils.capitalize(CharBuffer.wrap(\"x\")) );\n+        \n         assertEquals(\"uncapitalize(String) failed\",\n                      FOO_UNCAP, StringUtils.uncapitalize(FOO_CAP) );\n         assertEquals(\"uncapitalize(empty-string) failed\",\n                      \"\", StringUtils.uncapitalize(\"\") );\n         assertEquals(\"uncapitalize(single-char-string) failed\",\n-                     \"x\", StringUtils.uncapitalize(\"X\") );\n+                \"x\", StringUtils.uncapitalize(\"X\") );\n+        assertEquals(\"uncapitalize(single-char-string) failed\",\n+                \"x\", StringUtils.uncapitalize(new StringBuilder(\"X\")) );\n+        assertEquals(\"uncapitalize(single-char-string) failed\",\n+                \"x\", StringUtils.uncapitalize(new StringBuffer(\"X\")) );\n+        assertEquals(\"uncapitalize(single-char-string) failed\",\n+                \"x\", StringUtils.uncapitalize(CharBuffer.wrap(\"X\")) );\n                      \n         // reflection type of tests: Sentences.\n         assertEquals(\"uncapitalize(capitalize(String)) failed\",", "timestamp": 1268086508, "metainfo": ""}