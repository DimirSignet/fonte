{"sha": "496525b0d626dd5049528cdef61d71681154b660", "log": "[LANG-586] part 2: refactor ToStringStyle and ToStringBuilderTest to verify that we are unsetting the registry when no longer needed  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n      *\n      * @return Set the registry of objects being traversed\n      */\n-    static Set<Object> getRegistry() {\n-        WeakHashMap<Object, Object> m = REGISTRY.get();\n-        return m == null ? Collections.<Object> emptySet() : m.keySet();\n+    static Map<Object, Object> getRegistry() {\n+        return REGISTRY.get();\n     }\n \n     /**\n      *             object.\n      */\n     static boolean isRegistered(Object value) {\n-        return getRegistry().contains(value);\n+        Map<Object, Object> m = getRegistry();\n+        return m != null && m.containsKey(value);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     private final Integer base = new Integer(5);\n     private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n-    \n+\n     public ToStringBuilderTest(String name) {\n         super(name);\n     }\n     public void testSetDefaultEx() {\n         try {\n             ToStringBuilder.setDefaultStyle(null);\n-            \n+\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n     public void testBlank() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n     }\n-    \n+\n     /**\n      * Test wrapper for int primitive.\n      */\n     private String toBaseString(Object o) {\n         return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n     }\n-    \n+\n     // Reflection Array tests\n-    \n+\n     //\n     // Note on the following line of code repeated in the reflection array tests.\n     //\n     //\n     // The expected value is not baseStr + \"[<null>]\" since array==null and is typed as Object.\n     // The null array does not carry array type information.\n-    // If we added a primitive array type constructor and pile of associated methods, \n+    // If we added a primitive array type constructor and pile of associated methods,\n     // then type declaring type information could be carried forward. IMHO, null is null.\n     //\n-    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com  \n+    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com\n     //\n-    \n+\n     public void assertReflectionArray(String expected, Object actual) {\n         if (actual == null) {\n             // Until ToStringBuilder supports null objects.\n         assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionLongArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionIntArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionShortArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionyteArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionCharArray() {\n         assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionDoubleArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionFloatArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionBooleanArray() {\n         assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-    \n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n     // Reflection Array Array tests\n \n     public void testReflectionFloatArrayArray() {\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n \n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionIntArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionhortArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionByteArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionCharArrayArray() {\n         assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionDoubleArrayArray() {\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionBooleanArrayArray() {\n         assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-    \n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n     // Reflection hierarchy tests\n \n     public void testReflectionHierarchyArrayList() {\n         String baseStr = this.toBaseString(base);\n         assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n         assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionHierarchy() {\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n-        \n+\n         ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n         baseStr = this.toBaseString(baseB);\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n         assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     static class ReflectionTestFixtureA {\n         Outer outer = new Outer();\n         assertEquals(toBaseString(outer) + \"[inner=\" + toBaseString(outer.inner) + \"[]]\", outer.toString());\n     }\n-    \n+\n     static class Outer {\n         Inner inner = new Inner();\n         class Inner {\n             return ToStringBuilder.reflectionToString(this);\n         }\n     }\n-    \n+\n     // Reflection cycle tests\n \n     /**\n         assertEquals(\n             this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n             ToStringBuilder.reflectionToString(objects));\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     /**\n         assertEquals(\n             this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n             ToStringBuilder.reflectionToString(objectsLevel2));\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     public void testReflectionArrayArrayCycle() throws Exception {\n                 + basicToString\n                 + \"}}]\",\n             ToStringBuilder.reflectionToString(objects));\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     /**\n             return ToStringBuilder.reflectionToString(this);\n         }\n       }\n-    \n+\n     private static class SelfInstanceTwoVarsReflectionTestFixture {\n         @SuppressWarnings(\"unused\")\n         private SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;\n         public SelfInstanceTwoVarsReflectionTestFixture() {\n             this.typeIsSelf = this;\n         }\n-        \n+\n         public String getOtherType(){\n             return this.otherType;\n         }\n             return ToStringBuilder.reflectionToString(this);\n         }\n       }\n-    \n-    \n+\n+\n     /**\n      * Test an Object pointing to itself, the simplest test.\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testSimpleReflectionObjectCycle() throws Exception {\n         SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n         simple.o = simple;\n-        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n-        this.validateEmptyToStringStyleRegistry();\n+        this.validateNullToStringStyleRegistry();\n     }\n \n     /**\n      * Test a class that defines an ivar pointing to itself.\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n         SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n-        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-    \n-    /**\n-     * Test a class that defines an ivar pointing to itself.  This test was \n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n+    /**\n+     * Test a class that defines an ivar pointing to itself.  This test was\n      * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n         SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n-        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-    \n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n \n     /**\n      * Test Objects pointing to each other.\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testReflectionObjectCycle() throws Exception {\n         assertEquals(\n             this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n             a.toString());\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-    \n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n     /**\n      * Test a nasty combination of arrays and Objects pointing to each other.\n      * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testReflectionArrayAndObjectCycle() throws Exception {\n                 + this.toBaseString(simple)\n                 + \"}]\",\n             ToStringBuilder.reflectionToString(simple));\n-        this.validateEmptyToStringStyleRegistry();\n-    }\n-        \n-    void validateEmptyToStringStyleRegistry() {\n-       if (!ToStringStyle.getRegistry().isEmpty()) {\n+        this.validateNullToStringStyleRegistry();\n+    }\n+\n+    void validateNullToStringStyleRegistry() {\n+       if (ToStringStyle.getRegistry() != null) {\n            System.out.println(ToStringStyle.getRegistry());\n        }\n-       \n-        assertTrue(ToStringStyle.getRegistry().isEmpty());        \n+\n+        assertNull(ToStringStyle.getRegistry());\n     }\n     //  End: Reflection cycle tests\n \n     public void testAppendSuper() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n-        \n+\n         assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n         assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n         assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n     }\n-    \n+\n     public void testAppendToString() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").toString());\n-        \n+\n         assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n         assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n         assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(null).append(\"a\", \"hello\").toString());\n     }\n-    \n+\n     public void testObject() {\n         Integer i3 = new Integer(3);\n         Integer i4 = new Integer(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n     }\n-    \n+\n     public void testByteArray() {\n         byte[] array = new byte[] {1, 2, -3, 4};\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n     }\n-    \n+\n     public void testBooleanArray() {\n         boolean[] array = new boolean[] {true, false, false};\n         assertEquals(baseStr + \"[{true,false,false}]\", new ToStringBuilder(base).append(array).toString());\n         ObjectCycle b = new ObjectCycle();\n         a.obj = b;\n         b.obj = a;\n-       \n+\n         String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n         assertEquals(expected, a.toString());\n-        validateEmptyToStringStyleRegistry();\n-    }\n-    \n+        validateNullToStringStyleRegistry();\n+    }\n+\n     static class ObjectCycle {\n         Object obj;\n-       \n+\n         @Override\n         public String toString() {\n             return new ToStringBuilder(this).append(obj).toString();\n         }\n     }\n-    \n+\n     public void testSimpleReflectionStatics() {\n         SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n         assertEquals(\n      *\n      * <p>Transient fields are not output.</p>\n      *\n-     * <p>Superclass fields will be appended up to and including the specified superclass. \n+     * <p>Superclass fields will be appended up to and including the specified superclass.\n      * A null superclass is treated as <code>java.lang.Object</code>.</p>\n      *\n      * <p>If the style is <code>null</code>, the default\n      * <code>ToStringStyle</code> is used.</p>\n-     * \n+     *\n      * @param object  the Object to be output\n      * @param style  the style of the <code>toString</code> to create,\n      *  may be <code>null</code>\n         ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n         test.setUpToClass(Number.class);\n     }\n-    \n+\n     /**\n      * Tests ReflectionToStringBuilder setUpToClass().\n      */\n             // expected\n         }\n     }\n-    \n+\n     /**\n      * Tests ReflectionToStringBuilder.toString() for statics.\n      */", "timestamp": 1265320678, "metainfo": ""}