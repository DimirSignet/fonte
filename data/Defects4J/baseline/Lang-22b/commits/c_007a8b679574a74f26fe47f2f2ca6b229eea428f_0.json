{"sha": "007a8b679574a74f26fe47f2f2ca6b229eea428f", "log": "Exclude static fields from reflection based builder   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n  * </pre>\n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: CompareToBuilder.java,v 1.1 2002/09/15 10:25:22 scolebourne Exp $\n+ * @version $Id: CompareToBuilder.java,v 1.2 2002/09/17 22:06:37 scolebourne Exp $\n  */\n public class CompareToBuilder {\n     /**\n      * It is also not as efficient as testing explicitly.\n      * Transient members will be not be tested, as they are likely derived\n      * fields, and not part of the value of the object.\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return int - a negative integer, zero, or a positive integer as this \n+     * Static fields will not be tested.\n+     * @param lhs  Left Hand Side\n+     * @param rhs  Right Hand Side\n+     * @return int  a negative integer, zero, or a positive integer as this \n      * object is less than, equal to, or greater than the specified object.\n      * @throws ClassCastException - if the specified object's type prevents it \n      * from being compared to this Object.\n      * If the TestTransients parameter is set to true, transient members will be\n      * tested, otherwise they are ignored, as they are likely derived fields, and\n      * not part of the value of the object. \n+     * Static fields will not be tested.\n      * \n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @param testTransients - whether to include transient fields\n+     * @param lhs  Left Hand Side\n+     * @param rhs  Right Hand Side\n+     * @param testTransients  whether to include transient fields\n      * @return int - a negative integer, zero, or a positive integer as this \n      * object is less than, equal to, or greater than the specified object.\n      * @throws ClassCastException - if the specified object's type prevents it \n      * from being compared to this Object.\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, boolean testTransients) {\n+    public static int reflectionCompare(Object lhs, Object rhs, \n+            boolean testTransients) {\n         if (lhs == rhs) {\n             return 0;\n         }\n         for (int i = 0; i < fields.length && compareToBuilder.comparison == 0; ++i) {\n             Field f = fields[i];\n             if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n-                try {\n-                    compareToBuilder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                if ( !Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        compareToBuilder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n  * \n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: EqualsBuilder.java,v 1.1 2002/09/12 22:00:00 scolebourne Exp $\n+ * @version $Id: EqualsBuilder.java,v 1.2 2002/09/17 22:06:38 scolebourne Exp $\n  */\n public class EqualsBuilder {\n     /**\n      * that it will throw a security exception if run under a security manger, if\n      * the permissions are not set up.\n      * It is also not as efficient as testing explicitly. \n-     * Transient members will be not be tested, as they are likely derived \n-     * fields, and not part of the value of the object. \n+     * Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the object.\n+     * Static fields will not be tested.\n      * \n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  Left Hand Side\n+     * @param rhs  Right Hand Side\n      * @return boolean - if the two objects have tested equals.\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs) {\n      * If the TestTransients parameter is set to true, transient members will be\n      * tested, otherwise they are ignored, as they are likely derived fields, and\n      * not part of the value of the object. \n+     * Static fields will not be tested.\n      * \n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @param testTransients - whether to include transient fields\n+     * @param lhs  Left Hand Side\n+     * @param rhs  Right Hand Side\n+     * @param testTransients  whether to include transient fields\n      * @return boolean - if the two objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+    public static boolean reflectionEquals(Object lhs, Object rhs, \n+            boolean testTransients) {\n         if (lhs == rhs) {\n             return true;\n         }\n         for (int i = 0; i < fields.length && equalsBuilder.isEquals; ++i) {\n             Field f = fields[i];\n             if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n-                try {\n-                    equalsBuilder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        equalsBuilder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n  * </code>\n  * \n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: HashCodeBuilder.java,v 1.1 2002/09/12 21:59:01 scolebourne Exp $\n+ * @version $Id: HashCodeBuilder.java,v 1.2 2002/09/17 22:06:38 scolebourne Exp $\n  */\n public class HashCodeBuilder {\n     \n      * It is also not as efficient as testing explicitly. \n      * Transient members will be not be used, as they are likely derived \n      * fields, and not part of the value of the object. \n+     * Static fields will not be tested.\n      * This constructor uses two hard coded choices for the constants needed\n      * to build a hash code.\n      * \n         return reflectionHashCode(object, false);\n     }\n \n+    /**\n+     * This method uses reflection to build a valid hash code. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the TestTransients parameter is set to true, transient members will be\n+     * tested, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * Static fields will not be tested.\n+     * This constructor uses two hard coded choices for the constants needed\n+     * to build a hash code.\n+     * \n+     * @param object  the object to create a hash code for\n+     * @param testTransients  whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients);\n+    }\n+        \n     /**\n      * This method uses reflection to build a valid hash code. \n      * <p>\n      * It is also not as efficient as testing explicitly. \n      * Transient members will be not be used, as they are likely derived \n      * fields, and not part of the value of the object. \n+     * Static fields will not be tested.\n      * <p>\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n      * these should be different for each class, however this is not vital.\n     public static int reflectionHashCode(\n             int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n             Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false);\n     }\n     \n     /**\n      * If the TestTransients parameter is set to true, transient members will be\n      * tested, otherwise they are ignored, as they are likely derived fields, and\n      * not part of the value of the object. \n-     * This constructor uses two hard coded choices for the constants needed\n-     * to build a hash code.\n-     * \n-     * @param object  the object to create a hash code for\n-     * @param testTransients  whether to include transient fields\n-     * @return int hash code\n-     * @throws IllegalArgumentException if the object is null\n-     */\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients);\n-    }\n-        \n-    /**\n-     * This method uses reflection to build a valid hash code. \n-     * <p>\n-     * It uses Field.setAccessible to gain access to private fields. This means\n-     * that it will throw a security exception if run under a security manger, if\n-     * the permissions are not set up.\n-     * It is also not as efficient as testing explicitly. \n-     * If the TestTransients parameter is set to true, transient members will be\n-     * tested, otherwise they are ignored, as they are likely derived fields, and\n-     * not part of the value of the object. \n+     * Static fields will not be tested.\n      * <p>\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n      * these should be different for each class, however this is not vital.\n         for (int i = 0; i < fields.length; ++i) {\n             Field f = fields[i];\n             if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n-                try {\n-                    hashCodeBuilder.append(f.get(object));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        hashCodeBuilder.append(f.get(object));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n         }", "timestamp": 1032300398, "metainfo": ""}