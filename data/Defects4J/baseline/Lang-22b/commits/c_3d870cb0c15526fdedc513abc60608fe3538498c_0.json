{"sha": "3d870cb0c15526fdedc513abc60608fe3538498c", "log": "Replaced VariableFormatter.Token with java.text.FieldPosition.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n \n package org.apache.commons.lang.text;\n \n+import java.text.FieldPosition;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedList;\n     }\n \n     /**\n-     * A simple class representing a token detected by the <code>VariableParser</code> class.\n-     */\n-    protected static class Token {\n+     * A helper class for detecting variables in the source text. This class provides simple tokenizer functionality. It\n+     * splits input text into tokens for text, variables, and escaped variable start tokens.\n+     */\n+    protected static class VariableParser {\n         /** Constant for the token type ESCAPED_VAR. */\n         static final short ESCAPED_VAR_TOKEN = 3;\n \n          *            The token length\n          * @return a new token\n          */\n-        public static Token newEscapedVariableToken(int aStartIndex, int aLength) {\n-            return new Token(ESCAPED_VAR_TOKEN, aStartIndex, aLength);\n+        public static FieldPosition newEscapedVariableToken(int aStartIndex, int aLength) {\n+            return newToken(VariableParser.ESCAPED_VAR_TOKEN, aStartIndex, aLength);\n         }\n \n         /**\n          *            The token length\n          * @return a new token\n          */\n-        public static Token newTextToken(int aStartIndex, int aLength) {\n-            return new Token(TEXT_TOKEN, aStartIndex, aLength);\n+        public static FieldPosition newTextToken(int aStartIndex, int aLength) {\n+            return newToken(VariableParser.TEXT_TOKEN, aStartIndex, aLength);\n+        }\n+\n+        private static FieldPosition newToken(int type, int beginIndex, int length) {\n+            FieldPosition fp = new FieldPosition(type);\n+            fp.setBeginIndex(beginIndex);\n+            fp.setEndIndex(beginIndex + length);\n+            return fp;\n         }\n \n         /**\n          *            The token length\n          * @return a new token\n          */\n-        public static Token newVariableToken(int aStartIndex, int aLength) {\n-            return new Token(VARIABLE_TOKEN, aStartIndex, aLength);\n-        }\n-\n-        /** Stores the length of this token in characters. */\n-        private int length;\n-\n-        /** Stores the token's start position in the source text. */\n-        private int startIndex;\n-\n-        /** Stores the token type. */\n-        private short type;\n-\n-        /**\n-         * Creates a new token.\n-         * \n-         * @param aType\n-         *            The token type\n-         * @param aStartIndex\n-         *            The token starting index\n-         * @param aLength\n-         *            The token length\n-         */\n-        public Token(short aType, int aStartIndex, int aLength) {\n-            this.setType(aType);\n-            this.setStartIndex(aStartIndex);\n-            this.setLength(aLength);\n-        }\n-\n-        /**\n-         * Returns the token's length.\n-         * \n-         * @return the length of this token in characters\n-         */\n-        public int getLength() {\n-            return this.length;\n-        }\n-\n-        /**\n-         * Returns the token's start index.\n-         * \n-         * @return this token's start index in the source data\n-         */\n-        public int getStartIndex() {\n-            return this.startIndex;\n-        }\n-\n-        /**\n-         * Returns the text for this token from the passed in source array.\n-         * \n-         * @param data\n-         *            the array with the source data\n-         * @return the text for this token\n-         */\n-        public String getText(char[] data) {\n-            return new String(data, getStartIndex(), getLength());\n-        }\n-\n-        /**\n-         * Returns this token's type.\n-         * \n-         * @return the type of this token\n-         */\n-        public short getType() {\n-            return this.type;\n-        }\n-\n-        /**\n-         * @param length\n-         *            The length to set.\n-         */\n-        private void setLength(int length) {\n-            this.length = length;\n-        }\n-\n-        /**\n-         * @param startIndex\n-         *            The startIndex to set.\n-         */\n-        private void setStartIndex(int startIndex) {\n-            this.startIndex = startIndex;\n-        }\n-\n-        /**\n-         * @param type\n-         *            The type to set.\n-         */\n-        private void setType(short type) {\n-            this.type = type;\n-        }\n-    }\n-\n-    /**\n-     * A helper class for detecting variables in the source text. This class provides simple tokenizer functionality. It\n-     * splits input text into tokens for text, variables, and escaped variable start tokens.\n-     */\n-    protected static class VariableParser {\n+        public static FieldPosition newVariableToken(int aStartIndex, int aLength) {\n+            return newToken(VariableParser.VARIABLE_TOKEN, aStartIndex, aLength);\n+        }\n+\n         /** Stores the end index. */\n         private int endIndex;\n \n          */\n         private void checkTextToken(int startPos) {\n             if (startPos < getPos()) {\n-                getTokenList().addLast(Token.newTextToken(startPos, getPos() - startPos));\n+                getTokenList().addLast(VariableParser.newTextToken(startPos, getPos() - startPos));\n             }\n         }\n \n         }\n \n         /**\n-         * Checks if the end of the source data has been reached.\n-         * \n-         * @return a flag whether the end was reached\n-         */\n-        private boolean isEnd() {\n-            return getPos() >= getEndIndex();\n+         * Returns whether there is more to parse.\n+         * \n+         * @return a flag whether there is more to parse.\n+         */\n+        // Named method like java.util.Iterator#hasNext()\n+        private boolean hasNext() {\n+            return getPos() < getEndIndex();\n         }\n \n         /**\n          *            the array with the source data\n          * @return the next token or <b>null</b> if the end is reached\n          */\n-        public Token nextToken(char[] data) {\n+        public FieldPosition nextToken(char[] data) {\n             if (getTokenList().isEmpty()) {\n-                if (isEnd()) {\n+                if (!hasNext()) {\n                     // end of data is reached\n                     return null;\n                 }\n                 int startPos = getPos();\n                 int tokenLen;\n-                while (!isEnd() && getTokenList().isEmpty()) {\n+                while (hasNext() && getTokenList().isEmpty()) {\n                     if ((tokenLen = getEscVarMatcher().isMatch(data, getLength(), getPos())) > 0) {\n                         checkTextToken(startPos);\n-                        getTokenList().addLast(Token.newEscapedVariableToken(getPos(), tokenLen));\n+                        getTokenList().addLast(VariableParser.newEscapedVariableToken(getPos(), tokenLen));\n                         setPos(getPos() + tokenLen);\n                     } else if ((tokenLen = getVarStartMatcher().isMatch(data, getLength(), getPos())) > 0) {\n                         checkTextToken(startPos);\n                         setPos(getPos() + tokenLen);\n                         int varStart = getPos(), endLen = 0;\n-                        while (!isEnd() && (endLen = getVarEndMatcher().isMatch(data, getLength(), getPos())) <= 0) {\n+                        while (hasNext() && (endLen = getVarEndMatcher().isMatch(data, getLength(), getPos())) <= 0) {\n                             setPos(getPos() + 1);\n                         }\n                         if (endLen <= 0) {\n                             checkTextToken(varStart - tokenLen);\n                         } else {\n-                            getTokenList().addLast(Token.newVariableToken(varStart, getPos() - varStart));\n+                            getTokenList().addLast(VariableParser.newVariableToken(varStart, getPos() - varStart));\n                             setPos(getPos() + endLen);\n                         }\n                     } else {\n                     checkTextToken(startPos);\n                 }\n             }\n-            return (Token) getTokenList().removeFirst();\n+            return (FieldPosition) getTokenList().removeFirst();\n         }\n \n         /**\n     public static interface VariableResolver {\n         /**\n          * Returns the value of the specified variable. The variable's value can be an arbitrary object. If no variable\n-         * with the given name is known, an implementation should return <b>null</b>.\n+         * with the given name is known, an implementation should return <code>null</code>.\n          * \n          * @param varName\n          *            the name of the searched variable\n         }\n \n         VariableParser parser = createParser(data, offset, length);\n-        Token tok;\n+        FieldPosition tok;\n         while ((tok = parser.nextToken(data)) != null) {\n-            switch (tok.getType()) {\n-                case Token.TEXT_TOKEN :\n-                    buf.append(data, tok.getStartIndex(), tok.getLength());\n+            switch (tok.getField()) {\n+                case VariableParser.TEXT_TOKEN :\n+                    buf.append(data, tok.getBeginIndex(), getLength(tok));\n                     break;\n \n-                case Token.ESCAPED_VAR_TOKEN :\n+                case VariableParser.ESCAPED_VAR_TOKEN :\n                     buf.append(getVariablePrefix());\n                     tokenCnt++;\n                     break;\n \n-                case Token.VARIABLE_TOKEN :\n-                    String variable = tok.getText(data);\n+                case VariableParser.VARIABLE_TOKEN :\n+                    String variable = new String(data, tok.getBeginIndex(), getLength(tok));\n \n                     // if we've got a loop, create a useful exception message and\n                     // throw\n         return this.escapeCharacter;\n     }\n \n+    private int getLength(FieldPosition tok) {\n+        return tok.getEndIndex() - tok.getBeginIndex();\n+    }\n+\n     /**\n      * Returns the prefix for variables.\n      * ", "timestamp": 1123708912, "metainfo": ""}