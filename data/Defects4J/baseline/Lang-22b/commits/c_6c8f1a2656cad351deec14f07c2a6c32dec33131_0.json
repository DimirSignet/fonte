{"sha": "6c8f1a2656cad351deec14f07c2a6c32dec33131", "log": "applied patch #27778, also added an indexOf(char[]..).   ", "commit": "\n--- a/src/java/org/apache/commons/lang/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang/ArrayUtils.java\n  * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n  * @author Maarten Coene\n  * @since 2.0\n- * @version $Id: ArrayUtils.java,v 1.43 2004/03/16 01:40:57 ggregory Exp $\n+ * @version $Id: ArrayUtils.java,v 1.44 2004/06/06 03:53:23 bayard Exp $\n  */\n public class ArrayUtils {\n \n         return (indexOf(array, valueToFind) != -1);\n     }\n \n+    // char IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns <code>-1</code> if <code>null</code> array input.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  <code>-1</code> if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(final char[] array, final char valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Find the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns <code>-1</code> if <code>null</code> array input.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return -1.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  <code>-1</code> if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return -1;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Find the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns <code>-1</code> if <code>null</code> array input.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  <code>-1</code> if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(final char[] array, final char valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Find the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns <code>-1</code> if <code>null</code> array input.</p>\n+     *\n+     * <p>A negative startIndex will return -1. A startIndex larger than the array\n+     * length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  <code>-1</code> if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return -1;\n+        }\n+        if (startIndex < 0) {\n+            return -1;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(final char[] array, final char valueToFind) {\n+        return (indexOf(array, valueToFind) != -1);\n+    }\n+\n     // byte IndexOf\n     //-----------------------------------------------------------------------\n     /**\n         return (Object[]) result;\n     }\n     \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([\"a\"], 0)           = []\n+     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n+     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n+     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static Object[] remove(final Object[] array, final int index) {\n+        return (Object[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, \"a\")            = null\n+     * ArrayUtils.removeElement([], \"a\")              = []\n+     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static Object[] removeElement(final Object[] array, final Object element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([true], 0)              = []\n+     * ArrayUtils.remove([true, false], 0)       = [false]\n+     * ArrayUtils.remove([true, false], 1)       = [true]\n+     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static boolean[] remove(final boolean[] array, final int index) {\n+        return (boolean[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, true)                = null\n+     * ArrayUtils.removeElement([], true)                  = []\n+     * ArrayUtils.removeElement([true], false)             = [true]\n+     * ArrayUtils.removeElement([true, false], false)      = [true]\n+     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)          = []\n+     * ArrayUtils.remove([1, 0], 0)       = [0]\n+     * ArrayUtils.remove([1, 0], 1)       = [1]\n+     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static byte[] remove(final byte[] array, final int index) {\n+        return (byte[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)        = null\n+     * ArrayUtils.removeElement([], 1)          = []\n+     * ArrayUtils.removeElement([1], 0)         = [1]\n+     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n+     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static byte[] removeElement(final byte[] array, final byte element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove(['a'], 0)           = []\n+     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n+     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n+     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static char[] remove(final char[] array, final int index) {\n+        return (char[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 'a')            = null\n+     * ArrayUtils.removeElement([], 'a')              = []\n+     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n+     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n+     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static char[] removeElement(final char[] array, final char element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static double[] remove(final double[] array, final int index) {\n+        return (double[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static double[] removeElement(final double[] array, final double element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static float[] remove(final float[] array, final int index) {\n+        return (float[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static float[] removeElement(final float[] array, final float element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static int[] remove(final int[] array, final int index) {\n+        return (int[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static int[] removeElement(final int[] array, final int element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static long[] remove(final long[] array, final int index) {\n+        return (long[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static long[] removeElement(final long[] array, final long element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static short[] remove(final short[] array, final int index) {\n+        return (short[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static short[] removeElement(final short[] array, final short element) {\n+        int index = indexOf(array, element);\n+        if (index == -1) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    private static Object remove(final Object array, final int index) {\n+        int length = getLength(array);\n+        if (index < 0 || index >= length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+        \n+        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        if (index < length - 1) {\n+            System.arraycopy(array, index + 1, result, index, length - index - 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/ArrayUtilsRemoveTest.java\n+/*\n+ * Copyright 2002-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests ArrayUtils remove and removeElement methods.\n+ * \n+ * @author Maarten Coene\n+ * @version $Id: ArrayUtilsRemoveTest.java,v 1.1 2004/06/06 03:53:24 bayard Exp $\n+ */\n+public class ArrayUtilsRemoveTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsRemoveTest.class);\n+        suite.setName(\"ArrayUtils remove Tests\");\n+        return suite;\n+    }\n+\n+    public void testRemoveObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.remove(new Object[] {\"a\"}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 0);\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\", \"c\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\", \"c\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((Object[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.remove(new boolean[] {true}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 0);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false, true}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((boolean[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.remove(new byte[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((byte[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveCharArray() {\n+        char[] array;\n+        array = ArrayUtils.remove(new char[] {'a'}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 0);\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b', 'c'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a', 'c'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((char[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.remove(new double[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new double[] {1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new double[] {1, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((double[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.remove(new float[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new float[] {1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new float[] {1, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((float[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveIntArray() {\n+        int[] array;\n+        array = ArrayUtils.remove(new int[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {1, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((int[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveLongArray() {\n+        long[] array;\n+        array = ArrayUtils.remove(new long[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new long[] {1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new long[] {1, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((long[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveShortArray() {\n+        short[] array;\n+        array = ArrayUtils.remove(new short[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new short[] {1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new short[] {1, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((short[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveElementObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.removeElement((Object[]) null, \"a\");\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\"}, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\", \"a\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\", \"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.removeElement((boolean[]) null, true);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true}, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.removeElement((byte[]) null, (byte) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementCharArray() {\n+        char[] array;\n+        array = ArrayUtils.removeElement((char[]) null, 'a');\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a'}, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b', 'a'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b', 'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.removeElement((double[]) null, (double) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1}, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2, 1}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.removeElement((float[]) null, (float) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1}, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2, 1}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementIntArray() {\n+        int[] array;\n+        array = ArrayUtils.removeElement((int[]) null, 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1}, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {2, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementLongArray() {\n+        long[] array;\n+        array = ArrayUtils.removeElement((long[]) null, (long) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1}, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2, 1}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementShortArray() {\n+        short[] array;\n+        array = ArrayUtils.removeElement((short[]) null, (short) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1}, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2, 1}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/lang/ArrayUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/ArrayUtilsTest.java\n  * @author Fredrik Westermarck\n  * @author Gary Gregory\n  * @author Maarten Coene\n- * @version $Id: ArrayUtilsTest.java,v 1.26 2004/02/18 23:06:19 ggregory Exp $\n+ * @version $Id: ArrayUtilsTest.java,v 1.27 2004/06/06 03:53:24 bayard Exp $\n  */\n public class ArrayUtilsTest extends TestCase {\n \n         assertEquals(true, ArrayUtils.contains(array, (short) 2));\n         assertEquals(true, ArrayUtils.contains(array, (short) 3));\n         assertEquals(false, ArrayUtils.contains(array, (short) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.indexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.indexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e'));\n+    }\n+\n+    public void testIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.indexOf(array, 'a', 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6));\n+    }\n+\n+    public void testLastIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+    }\n+\n+    public void testLastIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88));\n+    }\n+\n+    public void testContainsChar() {\n+        char[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 'b'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(true, ArrayUtils.contains(array, 'a'));\n+        assertEquals(true, ArrayUtils.contains(array, 'b'));\n+        assertEquals(true, ArrayUtils.contains(array, 'c'));\n+        assertEquals(true, ArrayUtils.contains(array, 'd'));\n+        assertEquals(false, ArrayUtils.contains(array, 'e'));\n     }\n     \n     //-----------------------------------------------------------------------", "timestamp": 1086494004, "metainfo": ""}