{"sha": "fccf3cd2f7d63142019d3d3b84bfc59a21d9451d", "log": "[LANG-501] Added MultiBackgroundInitializer class with JUnit tests.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/concurrent/MultiBackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * <p>\n+ * A specialized {@link BackgroundInitializer} implementation that can deal with\n+ * multiple background initialization tasks.\n+ * </p>\n+ * <p>\n+ * This class has a similar purpose as {@link BackgroundInitializer}. However,\n+ * it is not limited to a single background initialization task. Rather it\n+ * manages an arbitrary number of {@code BackgroundInitializer} objects,\n+ * executes them, and waits until they are completely initialized. This is\n+ * useful for applications that have to perform multiple initialization tasks\n+ * that can run in parallel (i.e. that do not depend on each other). This class\n+ * takes care about the management of an {@code ExecutorService} and shares it\n+ * with the {@code BackgroundInitializer} objects it is responsible for; so the\n+ * using application need not bother with these details.\n+ * </p>\n+ * <p>\n+ * The typical usage scenario for {@code MultiBackgroundInitializer} is as\n+ * follows:\n+ * <ul>\n+ * <li>Create a new instance of the class. Optionally pass in a pre-configured\n+ * {@code ExecutorService}. Alternatively {@code MultiBackgroundInitializer} can\n+ * create a temporary {@code ExecutorService} and delete it after initialization\n+ * is complete.</li>\n+ * <li>Create specialized {@link BackgroundInitializer} objects for the\n+ * initialization tasks to be performed and add them to the {@code\n+ * MultiBackgroundInitializer} using the\n+ * {@link #addInitializer(String, BackgroundInitializer)} method.</li>\n+ * <li>After all initializers have been added, call the {@link #start()} method.\n+ * </li>\n+ * <li>When access to the result objects produced by the {@code\n+ * BackgroundInitializer} objects is needed call the {@link #get()} method. The\n+ * object returned here provides access to all result objects created during\n+ * initialization. It also stores information about exceptions that have\n+ * occurred.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * {@code MultiBackgroundInitializer} starts a special controller task that\n+ * starts all {@code BackgroundInitializer} objects added to the instance.\n+ * Before the an initializer is started it is checked whether this initializer\n+ * already has an {@code ExecutorService} set. If this is the case, this {@code\n+ * ExecutorService} is used for running the background task. Otherwise the\n+ * current {@code ExecutorService} of this {@code MultiBackgroundInitializer} is\n+ * shared with the initializer.\n+ * </p>\n+ * <p>\n+ * The easiest way of using this class is to let it deal with the management of\n+ * an {@code ExecutorService} itself: If no external {@code ExecutorService} is\n+ * provided, the class creates a temporary {@code ExecutorService} (that is\n+ * capable of executing all background tasks in parallel) and destroys it at the\n+ * end of background processing.\n+ * </p>\n+ * <p>\n+ * Alternatively an external {@code ExecutorService} can be provided - either at\n+ * construction time or later by calling the\n+ * {@link #setExternalExecutor(ExecutorService)} method. In this case all\n+ * background tasks are scheduled at this external {@code ExecutorService}.\n+ * <strong>Important note:</strong> When using an external {@code\n+ * ExecutorService} be sure that the number of threads managed by the service is\n+ * large enough. Otherwise a deadlock can happen! This is the case in the\n+ * following scenario: {@code MultiBackgroundInitializer} starts a task that\n+ * starts all registered {@code BackgroundInitializer} objects and waits for\n+ * their completion. If for instance a single threaded {@code ExecutorService}\n+ * is used, none of the background tasks can be executed, and the task created\n+ * by {@code MultiBackgroundInitializer} waits forever.\n+ * </p>\n+ *\n+ * @version $Id$\n+ */\n+public class MultiBackgroundInitializer\n+        extends\n+        BackgroundInitializer<MultiBackgroundInitializer.MultiBackgroundInitializerResults> {\n+    /** A map with the child initializers. */\n+    private final Map<String, BackgroundInitializer<?>> childInitializers = new HashMap<String, BackgroundInitializer<?>>();\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer}.\n+     */\n+    public MultiBackgroundInitializer() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer} and\n+     * initializes it with the given external {@code ExecutorService}.\n+     *\n+     * @param exec the {@code ExecutorService} for executing the background\n+     * tasks\n+     */\n+    public MultiBackgroundInitializer(ExecutorService exec) {\n+        super(exec);\n+    }\n+\n+    /**\n+     * Adds a new {@code BackgroundInitializer} to this object. When this\n+     * {@code MultiBackgroundInitializer} is started, the given initializer will\n+     * be processed. This method must not be called after {@link #start()} has\n+     * been invoked.\n+     *\n+     * @param name the name of the initializer (must not be <b>null</b>)\n+     * @param init the {@code BackgroundInitializer} to add (must not be\n+     * <b>null</b>)\n+     * @throws IllegalArgumentException if a required parameter is missing\n+     * @throws IllegalStateException if {@code start()} has already been called\n+     */\n+    public void addInitializer(String name, BackgroundInitializer<?> init) {\n+        if (name == null) {\n+            throw new IllegalArgumentException(\n+                    \"Name of child initializer must not be null!\");\n+        }\n+        if (init == null) {\n+            throw new IllegalArgumentException(\n+                    \"Child initializer must not be null!\");\n+        }\n+\n+        synchronized (this) {\n+            if (isStarted()) {\n+                throw new IllegalStateException(\n+                        \"addInitializer() must not be called after start()!\");\n+            }\n+            childInitializers.put(name, init);\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of tasks needed for executing all child {@code\n+     * BackgroundInitializer} objects in parallel. This implementation sums up\n+     * the required tasks for all child initializers (which is necessary if one\n+     * of the child initializers is itself a {@code MultiBackgroundInitializer}\n+     * ). Then it adds 1 for the control task that waits for the completion of\n+     * the children.\n+     *\n+     * @return the number of tasks required for background processing\n+     */\n+    @Override\n+    protected int getTaskCount() {\n+        int result = 1;\n+\n+        for (BackgroundInitializer<?> bi : childInitializers.values()) {\n+            result += bi.getTaskCount();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates the results object. This implementation starts all child {@code\n+     * BackgroundInitializer} objects. Then it collects their results and\n+     * creates a {@code MultiBackgroundInitializerResults} object with this\n+     * data. If a child initializer throws a checked exceptions, it is added to\n+     * the results object. Unchecked exceptions are propagated.\n+     *\n+     * @return the results object\n+     * @throws Exception if an error occurs\n+     */\n+    @Override\n+    protected MultiBackgroundInitializerResults initialize() throws Exception {\n+        Map<String, BackgroundInitializer<?>> inits;\n+        synchronized (this) {\n+            // create a snapshot to operate on\n+            inits = new HashMap<String, BackgroundInitializer<?>>(\n+                    childInitializers);\n+        }\n+\n+        // start the child initializers\n+        ExecutorService exec = getActiveExecutor();\n+        for (BackgroundInitializer<?> bi : inits.values()) {\n+            if (bi.getExternalExecutor() == null) {\n+                // share the executor service if necessary\n+                bi.setExternalExecutor(exec);\n+            }\n+            bi.start();\n+        }\n+\n+        // collect the results\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();\n+        for (Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {\n+            try {\n+                results.put(e.getKey(), e.getValue().get());\n+            } catch (ConcurrentException cex) {\n+                excepts.put(e.getKey(), cex);\n+            }\n+        }\n+\n+        return new MultiBackgroundInitializerResults(inits, results, excepts);\n+    }\n+\n+    /**\n+     * A data class for storing the results of the background initialization\n+     * performed by {@code MultiBackgroundInitializer}. Objects of this inner\n+     * class are returned by {@link MultiBackgroundInitializer#initialize()}.\n+     * They allow access to all result objects produced by the\n+     * {@link BackgroundInitializer} objects managed by the owning instance. It\n+     * is also possible to retrieve status information about single\n+     * {@link BackgroundInitializer}s, i.e. whether they completed normally or\n+     * caused an exception.\n+     */\n+    public static class MultiBackgroundInitializerResults {\n+        /** A map with the child initializers. */\n+        private final Map<String, BackgroundInitializer<?>> initializers;\n+\n+        /** A map with the result objects. */\n+        private final Map<String, Object> resultObjects;\n+\n+        /** A map with the exceptions. */\n+        private final Map<String, ConcurrentException> exceptions;\n+\n+        /**\n+         * Creates a new instance of {@code MultiBackgroundInitializerResults}\n+         * and initializes it with maps for the {@code BackgroundInitializer}\n+         * objects, their result objects and the exceptions thrown by them.\n+         *\n+         * @param inits the {@code BackgroundInitializer} objects\n+         * @param results the result objects\n+         * @param excepts the exceptions\n+         */\n+        private MultiBackgroundInitializerResults(\n+                Map<String, BackgroundInitializer<?>> inits,\n+                Map<String, Object> results,\n+                Map<String, ConcurrentException> excepts) {\n+            initializers = inits;\n+            resultObjects = results;\n+            exceptions = excepts;\n+        }\n+\n+        /**\n+         * Returns the {@code BackgroundInitializer} with the given name. If the\n+         * name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the {@code BackgroundInitializer} with this name\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public BackgroundInitializer<?> getInitializer(String name) {\n+            return checkName(name);\n+        }\n+\n+        /**\n+         * Returns the result object produced by the {@code\n+         * BackgroundInitializer} with the given name. This is the object\n+         * returned by the initializer's {@code initialize()} method. If this\n+         * {@code BackgroundInitializer} caused an exception, <b>null</b> is\n+         * returned. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the result object produced by this {@code\n+         * BackgroundInitializer}\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public Object getResultObject(String name) {\n+            checkName(name);\n+            return resultObjects.get(name);\n+        }\n+\n+        /**\n+         * Returns a flag whether the {@code BackgroundInitializer} with the\n+         * given name caused an exception.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return a flag whether this initializer caused an exception\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public boolean isException(String name) {\n+            checkName(name);\n+            return exceptions.containsKey(name);\n+        }\n+\n+        /**\n+         * Returns the {@code ConcurrentException} object that was thrown by the\n+         * {@code BackgroundInitializer} with the given name. If this\n+         * initializer did not throw an exception, the return value is\n+         * <b>null</b>. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the exception thrown by this initializer\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public ConcurrentException getException(String name) {\n+            checkName(name);\n+            return exceptions.get(name);\n+        }\n+\n+        /**\n+         * Returns a set with the names of all {@code BackgroundInitializer}\n+         * objects managed by the {@code MultiBackgroundInitializer}.\n+         *\n+         * @return an (unmodifiable) set with the names of the managed {@code\n+         * BackgroundInitializer} objects\n+         */\n+        public Set<String> initializerNames() {\n+            return Collections.unmodifiableSet(initializers.keySet());\n+        }\n+\n+        /**\n+         * Checks whether an initializer with the given name exists. If not,\n+         * throws an exception. If it exists, the associated child initializer\n+         * is returned.\n+         *\n+         * @param name the name to check\n+         * @return the initializer with this name\n+         * @throws NoSuchElementException if the name is unknown\n+         */\n+        private BackgroundInitializer<?> checkName(String name) {\n+            BackgroundInitializer<?> init = initializers.get(name);\n+            if (init == null) {\n+                throw new NoSuchElementException(\n+                        \"No child initializer with name \" + name);\n+            }\n+\n+            return init;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/concurrent/MultiBackgroundInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for {@link MultiBackgroundInitializer}.\n+ *\n+ * @version $Id$\n+ */\n+public class MultiBackgroundInitializerTest extends TestCase {\n+    /** Constant for the names of the child initializers. */\n+    private static final String CHILD_INIT = \"childInitializer\";\n+\n+    /** The initializer to be tested. */\n+    private MultiBackgroundInitializer initializer;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        initializer = new MultiBackgroundInitializer();\n+    }\n+\n+    /**\n+     * Tests whether a child initializer has been executed. Optionally the\n+     * expected executor service can be checked, too.\n+     *\n+     * @param child the child initializer\n+     * @param expExec the expected executor service (null if the executor should\n+     * not be checked)\n+     * @throws ConcurrentException if an error occurs\n+     */\n+    private void checkChild(BackgroundInitializer<?> child,\n+            ExecutorService expExec) throws ConcurrentException {\n+        ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n+        Integer result = cinit.get();\n+        assertEquals(\"Wrong result\", 1, result.intValue());\n+        assertEquals(\"Wrong number of executions\", 1, cinit.initializeCalls);\n+        if (expExec != null) {\n+            assertEquals(\"Wrong executor service\", expExec,\n+                    cinit.currentExecutor);\n+        }\n+    }\n+\n+    /**\n+     * Tests addInitializer() if a null name is passed in. This should cause an\n+     * exception.\n+     */\n+    public void testAddInitializerNullName() {\n+        try {\n+            initializer.addInitializer(null, new ChildBackgroundInitializer());\n+            fail(\"Null name not detected!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests addInitializer() if a null initializer is passed in. This should\n+     * cause an exception.\n+     */\n+    public void testAddInitializerNullInit() {\n+        try {\n+            initializer.addInitializer(CHILD_INIT, null);\n+            fail(\"Could add null initializer!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the background processing if there are no child initializers.\n+     */\n+    public void testInitializeNoChildren() throws ConcurrentException {\n+        assertTrue(\"Wrong result of start()\", initializer.start());\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertTrue(\"Got child initializers\", res.initializerNames().isEmpty());\n+        assertTrue(\"Executor not shutdown\", initializer.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Helper method for testing the initialize() method. This method can\n+     * operate with both an external and a temporary executor service.\n+     *\n+     * @return the result object produced by the initializer\n+     */\n+    private MultiBackgroundInitializer.MultiBackgroundInitializerResults checkInitialize()\n+            throws ConcurrentException {\n+        final int count = 5;\n+        for (int i = 0; i < count; i++) {\n+            initializer.addInitializer(CHILD_INIT + i,\n+                    new ChildBackgroundInitializer());\n+        }\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertEquals(\"Wrong number of child initializers\", count, res\n+                .initializerNames().size());\n+        for (int i = 0; i < count; i++) {\n+            String key = CHILD_INIT + i;\n+            assertTrue(\"Name not found: \" + key, res.initializerNames()\n+                    .contains(key));\n+            assertEquals(\"Wrong result object\", Integer.valueOf(1), res\n+                    .getResultObject(key));\n+            assertFalse(\"Exception flag\", res.isException(key));\n+            assertNull(\"Got an exception\", res.getException(key));\n+            checkChild(res.getInitializer(key), initializer.getActiveExecutor());\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Tests background processing if a temporary executor is used.\n+     */\n+    public void testInitializeTempExec() throws ConcurrentException {\n+        checkInitialize();\n+        assertTrue(\"Executor not shutdown\", initializer.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Tests background processing if an external executor service is provided.\n+     */\n+    public void testInitializeExternalExec() throws ConcurrentException {\n+        ExecutorService exec = Executors.newCachedThreadPool();\n+        try {\n+            initializer = new MultiBackgroundInitializer(exec);\n+            checkInitialize();\n+            assertEquals(\"Wrong executor\", exec, initializer\n+                    .getActiveExecutor());\n+            assertFalse(\"Executor was shutdown\", exec.isShutdown());\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of initialize() if a child initializer has a specific\n+     * executor service. Then this service should not be overridden.\n+     */\n+    public void testInitializeChildWithExecutor() throws ConcurrentException {\n+        final String initExec = \"childInitializerWithExecutor\";\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n+            ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n+            c2.setExternalExecutor(exec);\n+            initializer.addInitializer(CHILD_INIT, c1);\n+            initializer.addInitializer(initExec, c2);\n+            initializer.start();\n+            initializer.get();\n+            checkChild(c1, initializer.getActiveExecutor());\n+            checkChild(c2, exec);\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tries to add another child initializer after the start() method has been\n+     * called. This should not be allowed.\n+     */\n+    public void testAddInitializerAfterStart() throws ConcurrentException {\n+        initializer.start();\n+        try {\n+            initializer.addInitializer(CHILD_INIT,\n+                    new ChildBackgroundInitializer());\n+            fail(\"Could add initializer after start()!\");\n+        } catch (IllegalStateException istex) {\n+            initializer.get();\n+        }\n+    }\n+\n+    /**\n+     * Tries to query an unknown child initializer from the results object. This\n+     * should cause an exception.\n+     */\n+    public void testResultGetInitializerUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getInitializer(\"unknown\");\n+            fail(\"Could obtain unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the results of an unknown child initializer from the\n+     * results object. This should cause an exception.\n+     */\n+    public void testResultGetResultObjectUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getResultObject(\"unknown\");\n+            fail(\"Could obtain results from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the exception of an unknown child initializer from the\n+     * results object. This should cause an exception.\n+     */\n+    public void testResultGetExceptionUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.getException(\"unknown\");\n+            fail(\"Could obtain exception from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tries to query the exception flag of an unknown child initializer from\n+     * the results object. This should cause an exception.\n+     */\n+    public void testResultIsExceptionUnknown() throws ConcurrentException {\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        try {\n+            res.isException(\"unknown\");\n+            fail(\"Could obtain exception status from unknown child initializer!\");\n+        } catch (NoSuchElementException nex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests that the set with the names of the initializers cannot be modified.\n+     */\n+    public void testResultInitializerNamesModify() throws ConcurrentException {\n+        checkInitialize();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        Iterator<String> it = res.initializerNames().iterator();\n+        it.next();\n+        try {\n+            it.remove();\n+            fail(\"Could modify set with initializer names!\");\n+        } catch (UnsupportedOperationException uex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of the initializer if one of the child initializers\n+     * throws a runtime exception.\n+     */\n+    public void testInitializeRuntimeEx() throws ConcurrentException {\n+        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        child.ex = new RuntimeException();\n+        initializer.addInitializer(CHILD_INIT, child);\n+        initializer.start();\n+        try {\n+            initializer.get();\n+            fail(\"Runtime exception not thrown!\");\n+        } catch (Exception ex) {\n+            assertEquals(\"Wrong exception\", child.ex, ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests the behavior of the initializer if one of the child initializers\n+     * throws a checked exception.\n+     */\n+    public void testInitializeEx() throws ConcurrentException {\n+        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        child.ex = new Exception();\n+        initializer.addInitializer(CHILD_INIT, child);\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        assertTrue(\"No exception flag\", res.isException(CHILD_INIT));\n+        assertNull(\"Got a results object\", res.getResultObject(CHILD_INIT));\n+        ConcurrentException cex = res.getException(CHILD_INIT);\n+        assertEquals(\"Wrong cause\", child.ex, cex.getCause());\n+    }\n+\n+    /**\n+     * Tests whether MultiBackgroundInitializers can be combined in a nested\n+     * way.\n+     */\n+    public void testInitializeNested() throws ConcurrentException {\n+        final String nameMulti = \"multiChildInitializer\";\n+        initializer\n+                .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n+        MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n+        final int count = 3;\n+        for (int i = 0; i < count; i++) {\n+            mi2\n+                    .addInitializer(CHILD_INIT + i,\n+                            new ChildBackgroundInitializer());\n+        }\n+        initializer.addInitializer(nameMulti, mi2);\n+        initializer.start();\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        ExecutorService exec = initializer.getActiveExecutor();\n+        checkChild(res.getInitializer(CHILD_INIT), exec);\n+        MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n+                .getResultObject(nameMulti);\n+        assertEquals(\"Wrong number of initializers\", count, res2\n+                .initializerNames().size());\n+        for (int i = 0; i < count; i++) {\n+            checkChild(res2.getInitializer(CHILD_INIT + i), exec);\n+        }\n+        assertTrue(\"Executor not shutdown\", exec.isShutdown());\n+    }\n+\n+    /**\n+     * A concrete implementation of {@code BackgroundInitializer} used for\n+     * defining background tasks for {@code MultiBackgroundInitializer}.\n+     */\n+    private static class ChildBackgroundInitializer extends\n+            BackgroundInitializer<Integer> {\n+        /** Stores the current executor service. */\n+        volatile ExecutorService currentExecutor;\n+\n+        /** A counter for the invocations of initialize(). */\n+        volatile int initializeCalls;\n+\n+        /** An exception to be thrown by initialize(). */\n+        Exception ex;\n+\n+        /**\n+         * Records this invocation. Optionally throws an exception.\n+         */\n+        @Override\n+        protected Integer initialize() throws Exception {\n+            currentExecutor = getActiveExecutor();\n+            initializeCalls++;\n+\n+            if (ex != null) {\n+                throw ex;\n+            }\n+\n+            return initializeCalls;\n+        }\n+    }\n+}", "timestamp": 1257018778, "metainfo": ""}