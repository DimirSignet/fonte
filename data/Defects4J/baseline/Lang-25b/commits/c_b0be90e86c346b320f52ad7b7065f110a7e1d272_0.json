{"sha": "b0be90e86c346b320f52ad7b7065f110a7e1d272", "log": "Fix bug 16676: StackOverflow due to ToStringBuilder (http://issues.apache.org/bugzilla/show_bug.cgi?id=16676)   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n package org.apache.commons.lang.builder;\n \n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n \n /**\n  * <p><code>ToString</code> generation routine.</p>\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.16 2003/03/23 17:54:16 scolebourne Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.17 2003/03/27 08:54:31 ggregory Exp $\n  */\n public class ToStringBuilder {\n \n     /**\n+     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references \n+     * and avoid infinite loops.\n+     */\n+    private static ThreadLocal reflectionRegistry = new ThreadLocal() {\n+        protected synchronized Object initialValue() {\n+            // The HashSet implementation is not synchronized, which is just what we need here. \n+            return new HashSet();\n+        }\n+    };\n+    \n+    /**\n      * The default style of output to use\n      */\n     private static ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n      * The object being output\n      */\n     private final Object object;\n+\n+    /**\n+     * Returns the registry of objects being traversed by the \n+     * <code>reflectionToString</code> methods in the current thread.\n+     * @return Set the registry of objects being traversed \n+     */\n+    static Set getReflectionRegistry() {\n+        return (Set) reflectionRegistry.get();\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getReflectionRegistry().contains(value);\n+    }\n+\n+    /**\n+     * Registers the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     */\n+    static void register(Object value) {\n+        getReflectionRegistry().add(value);\n+    }\n+\n+    /**\n+     * Unregisters the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     */\n+    static void unregister(Object value) {\n+        getReflectionRegistry().remove(value);\n+    }\n \n     /**\n      * <p>Constructor for <code>ToStringBuilder</code>.</p>\n         if (object == null) {\n             return style.getNullText();\n         }\n-        if (style == null) {\n-            style = getDefaultStyle();\n-        }\n         ToStringBuilder builder = new ToStringBuilder(object, style);\n         Class clazz = object.getClass();\n         reflectionAppend(object, clazz, builder, outputTransients);\n \n     /**\n      * Appends the fields and values defined by the given object of the\n-     * given Class.\n+     * given Class. If a cycle is detected as an objects is \"toString()'ed\",\n+     * such an object is rendered as if <code>Object.toString()</code> \n+     * had been called and not implemented by the object.\n      * \n      * @param object  the object to append details of\n      * @param clazz  the class of object parameter\n      * @param useTransients  whether to output transient fields\n      */\n     private static void reflectionAppend(Object object, Class clazz, ToStringBuilder builder, boolean useTransients) {\n-        if (clazz.isArray()) {\n-            reflectionAppendArray(object, clazz, builder);\n+        if (isRegistered(object)) {\n+            // The object has already been appended, therefore we have an object cycle. \n+            // Append a simple Object.toString style string. The field name is already appended at this point.\n+            builder.appendAsObjectToString(object);\n             return;\n         }\n-        Field[] fields = clazz.getDeclaredFields();\n-        Field.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length; i++) {\n-            Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n-                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                && (!Modifier.isStatic(f.getModifiers()))) {\n-                try {\n-                    builder.append(f.getName(), f.get(object));\n-                } catch (IllegalAccessException ex) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+        try {\n+            register(object);\n+            if (clazz.isArray()) {\n+                builder.reflectionAppendArray(object);\n+                return;\n+            }\n+            Field[] fields = clazz.getDeclaredFields();\n+            Field.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length; i++) {\n+                Field f = fields[i];\n+                String fieldName = f.getName();\n+                if ((fieldName.indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        // Warning: Field.get(Object) creates wrappers objects for primitive types.\n+                        Object fieldValue = f.get(object);\n+                        if (isRegistered(fieldValue)\n+                            && !f.getType().isPrimitive()) {\n+                            // A known field value has already been appended, therefore we have an object cycle, \n+                            // append a simple Object.toString style string.\n+                            builder.getStyle().appendFieldStart(builder.getStringBuffer(), fieldName);\n+                            builder.appendAsObjectToString(fieldValue);\n+                            // The recursion out of \"builder.append(fieldName, fieldValue);\" below will append the field \n+                            // end marker.\n+                        } else {\n+                            try {\n+                                register(object);\n+                                builder.append(fieldName, fieldValue);\n+                            } finally {\n+                                unregister(object);\n+                            }\n+                        }\n+                    } catch (IllegalAccessException ex) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                    }\n                 }\n             }\n-        }\n-    }\n-\n-    /**\n-     * Appends the array elements in the given <code>Object</code> of the\n-     * given <code>Class</code> to a <code>ToStringBuilder</code>.\n-     * \n-     * @param object  the array object to append details of\n-     * @param clazz  the array class of the object parameter\n-     * @param builder  the builder to append to\n-     */\n-    private static void reflectionAppendArray(Object object, Class clazz, ToStringBuilder builder) {\n-        try {\n-            // A multi-dimension array invokes the append(Object) method.\n-            // A single-dimension array of primitive type pt invokes the append(pt[]) method.\n-            builder.getClass().getDeclaredMethod(\"append\", new Class[] { clazz.getComponentType().isArray() ? Object.class : clazz }).invoke(\n-                builder,\n-                new Object[] { object });\n-        } catch (SecurityException e) {\n-            // \"This cannot happen\"\n-            throw new InternalError(\"Unexpected SecurityException: \" + e.getMessage());\n-        } catch (NoSuchMethodException e) {\n-            // \"This cannot happen\"\n-            throw new InternalError(\"Unexpected NoSuchMethodException: \" + e.getMessage());\n-        } catch (IllegalArgumentException e) {\n-            // Method.invoke exception\n-            // \"This cannot happen\"\n-            throw new InternalError(\"Unexpected IllegalArgumentException: \" + e.getMessage());\n-        } catch (IllegalAccessException e) {\n-            // Method.invoke exception\n-            // \"This cannot happen\"\n-            throw new InternalError(\"Unexpected IllegalAccessException: \" + e.getMessage());\n-        } catch (InvocationTargetException e) {\n-            // Method.invoke exception\n-            // \"This cannot happen\"\n-            throw new InternalError(\"Unexpected InvocationTargetException: \" + e.getMessage());\n+        } finally {\n+            unregister(object);\n         }\n     }\n \n         return this;\n     }\n \n+    /**\n+     * <p>Appends with the same format as the default <code>Object toString()\n+     * </code> method. Appends the class name followed by \n+     * {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param object  the <code>Object</code> whose class name and id to output\n+     */\n+    public ToStringBuilder appendAsObjectToString(Object object) {\n+        this.getStyle().appendAsObjectToString(this.getStringBuffer(), object);\n+        return this;\n+    }\n+\n     //----------------------------------------------------------------------------\n \n     /**\n      */\n     public ToStringBuilder append(Object[] array) {\n         style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder reflectionAppendArray(Object array) {\n+        style.reflectionAppendArrayDetail(buffer, null, array);\n         return this;\n     }\n \n--- a/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n package org.apache.commons.lang.builder;\n \n import java.io.Serializable;\n+import java.lang.reflect.Array;\n import java.util.Collection;\n import java.util.Map;\n \n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n- * @version $Id: ToStringStyle.java,v 1.10 2003/03/23 17:54:16 scolebourne Exp $\n+ * @version $Id: ToStringStyle.java,v 1.11 2003/03/27 08:54:31 ggregory Exp $\n  */\n public abstract class ToStringStyle implements Serializable {\n     \n      *\n      * <p>Either detail or summary views can be specified.</p>\n      *\n+     * <p>If a cycle is detected, an object will be appended with the Object.toString() format.</p>\n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>,\n      * @param detail  output detail or not\n      */\n     protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n-        if (value instanceof Collection) {\n+        if (ToStringBuilder.isRegistered(value) \n+                && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n+            appendAsObjectToString(buffer, value);\n+            \n+        } \n+        else if (value instanceof Collection) {\n             if (detail) {\n                 appendDetail(buffer, fieldName, (Collection) value);\n             } else {\n     }\n \n     /**\n+     * <p>Append to the <code>toString</code> the detail of an any array type.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n+        buffer.append(arrayStart);\n+        int length = Array.getLength(array);\n+        for (int i = 0; i < length; i++) {\n+            Object item = Array.get(array, i);\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+                \n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n      * <p>Append to the <code>toString</code> a summary of an\n      * <code>Object</code> array.</p>\n      *\n             buffer.append('@');\n             buffer.append(Integer.toHexString(System.identityHashCode(object)));\n         }\n+    }\n+\n+    /**\n+     * <p>Appends with the same format as the default <code>Object toString()\n+     * </code> method. Appends the class name followed by \n+     * {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose class name and id to output\n+     */\n+    protected void appendAsObjectToString(StringBuffer buffer, Object object) {\n+        this.appendClassName(buffer, object);\n+        this.appendIdentityHashCode(buffer, object);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n /**\n- * Unit tests {@link org.apache.commons.lang.ToStringBuilder}.\n+ * Unit tests for {@link org.apache.commons.lang.ToStringBuilder}.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: ToStringBuilderTest.java,v 1.6 2003/03/23 17:35:51 scolebourne Exp $\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:alex@apache.org\">Alex Chaffee</a>\n+ * @version $Id: ToStringBuilderTest.java,v 1.7 2003/03/27 08:55:22 ggregory Exp $\n  */\n public class ToStringBuilderTest extends TestCase {\n \n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n     }\n     \n-\tpublic void testReflection() {\n-\t\tassertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n-\t}\n-\n+    /**\n+     * Test wrapper for int primitive.\n+     */\n+    public void testReflectionInteger() {\n+        assertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n+    }\n+\n+    /**\n+     * Test wrapper for char primitive.\n+     */\n+    public void testReflectionCharacter() {\n+        Character c = new Character('A');\n+        assertEquals(this.toBaseString(c) + \"[value=A]\", ToStringBuilder.reflectionToString(c));\n+    }\n+\n+    /**\n+     * Test wrapper for char boolean.\n+     */\n+    public void testReflectionBoolean() {\n+        Boolean b;\n+        b = Boolean.TRUE;\n+        assertEquals(this.toBaseString(b) + \"[value=true]\", ToStringBuilder.reflectionToString(b));\n+        b = Boolean.FALSE;\n+        assertEquals(this.toBaseString(b) + \"[value=false]\", ToStringBuilder.reflectionToString(b));\n+    }\n+\n+    /**\n+     * Create the same toString() as Object.toString().\n+     * @param o the object to create the string for.\n+     * @return a String in the Object.toString format.\n+     */\n     private String toBaseString(Object o) {\n         return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n     }\n         assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionLongArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionIntArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionShortArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionyteArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionCharArray() {\n         assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionDoubleArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionFloatArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionBooleanArray() {\n         assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n     \n     // Reflection Array Array tests\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n \n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionIntArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionhortArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionByteArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionCharArrayArray() {\n         assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionDoubleArrayArray() {\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionBooleanArrayArray() {\n         assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n     }\n     \n     // Reflection hierarchy tests\n         String baseStr = this.toBaseString(base);\n         assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n         assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n+        this.validateEmptyReflectionRegistry();\n     }\n \n     public void testReflectionHierarchy() {\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, List.class));\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n         assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n+        this.validateEmptyReflectionRegistry();\n     }\n \n \tstatic class ReflectionTestFixtureA {\n         }\n     }\n     \n+    // Reflection cycle tests\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        objects[0] = objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycleLevel2() throws Exception {\n+        Object[] objects = new Object[1];\n+        Object[] objectsLevel2 = new Object[1];\n+        objects[0] = objectsLevel2;\n+        objectsLevel2[0] = (Object) objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objectsLevel2));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionArrayArrayCycle() throws Exception {\n+        Object[][] objects = new Object[2][2];\n+        objects[0][0] = objects;\n+        objects[0][1] = objects;\n+        objects[1][0] = objects;\n+        objects[1][1] = objects;\n+        String basicToString = this.toBaseString(objects);\n+        assertEquals(\n+            basicToString\n+                + \"[{{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"},{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleA {\n+        ReflectionTestCycleB b;\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleB {\n+        ReflectionTestCycleA a;\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class SimpleReflectionTestFixture {\n+        Object o;\n+\n+        public SimpleReflectionTestFixture() {\n+        }\n+\n+        public SimpleReflectionTestFixture(Object o) {\n+            this.o = o;\n+        }\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * Test an Object pointing to itself, the simplest test.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSimpleReflectionObjectCycle() throws Exception {\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n+        simple.o = simple;\n+        assertTrue(ToStringBuilder.getReflectionRegistry().isEmpty());\n+        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test Objects pointing to each other.\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionObjectCycle() throws Exception {\n+        ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        a.b = b;\n+        b.a = a;\n+        assertEquals(\n+            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n+            a.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test a nasty combination of arrays and Objects pointing to each other.\n+     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionArrayAndObjectCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n+        objects[0] = (Object) simple;\n+        assertEquals(\n+            this.toBaseString(objects)\n+                + \"[{\"\n+                + this.toBaseString(simple)\n+                + \"[o=\"\n+                + this.toBaseString(objects)\n+                + \"]\"\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(simple)\n+                + \"[o={\"\n+                + this.toBaseString(simple)\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(simple));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+        \n+    void validateEmptyReflectionRegistry() {\n+        assertTrue(ToStringBuilder.getReflectionRegistry().isEmpty());        \n+    }\n+    //  End: Reflection cycle tests\n+\n     public void testAppendSuper() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());", "timestamp": 1048755322, "metainfo": ""}