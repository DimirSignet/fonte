{"sha": "04e212a37a480cddb9918328260cf05c8414dfc3", "log": "Moving most of the methods over to varargs. A couple can't change because they are Object[], Class[] with both end parameters ideally wanting to be vararg. LANG-396  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n      * would match a <code>boolean</code> primitive.</p>\n      *\n      * <p> This is a convenient wrapper for\n-     * {@link #invokeMethod(Object object, String methodName, Object[] args)}.\n+     * {@link #invokeMethod(Object object,String methodName, Object[] args, Class[] parameterTypes)}.\n      * </p>\n      *\n      * @param object invoke method on this object\n      * @param methodName get method with this name\n-     * @param arg use this argument\n+     * @param args use these arguments - treat null as empty array\n      * @return The value returned by the invoked method\n      *\n      * @throws NoSuchMethodException if there is no such accessible method\n      * @throws IllegalAccessException if the requested method is not accessible via reflection\n      */\n     public static Object invokeMethod(Object object, String methodName,\n-            Object arg) throws NoSuchMethodException, IllegalAccessException,\n-            InvocationTargetException {\n-        return invokeMethod(object, methodName, new Object[] { arg });\n-    }\n-\n-    /**\n-     * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n-     *\n-     * <p>This method supports calls to methods taking primitive parameters \n-     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n-     * would match a <code>boolean</code> primitive.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeMethod(Object object,String methodName, Object[] args, Class[] parameterTypes)}.\n-     * </p>\n-     *\n-     * @param object invoke method on this object\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     * @return The value returned by the invoked method\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible via reflection\n-     */\n-    public static Object invokeMethod(Object object, String methodName,\n-            Object[] args) throws NoSuchMethodException,\n+            Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n     }\n \n     /**\n-     * <p>Invoke a method whose parameter type matches exactly the object\n-     * type.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n-     * </p>\n+     * <p>Invoke a method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n      *\n      * @param object invoke method on this object\n      * @param methodName get method with this name\n-     * @param arg use this argument\n+     * @param args use these arguments - treat null as empty array\n      * @return The value returned by the invoked method\n      *\n      * @throws NoSuchMethodException if there is no such accessible method\n      *  via reflection\n      */\n     public static Object invokeExactMethod(Object object, String methodName,\n-            Object arg) throws NoSuchMethodException, IllegalAccessException,\n-            InvocationTargetException {\n-        return invokeExactMethod(object, methodName, new Object[] { arg });\n-    }\n-\n-    /**\n-     * <p>Invoke a method whose parameter types match exactly the object\n-     * types.</p>\n-     *\n-     * <p> This uses reflection to invoke the method obtained from a call to\n-     * <code>getAccessibleMethod()</code>.</p>\n-     *\n-     * @param object invoke method on this object\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     * @return The value returned by the invoked method\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeExactMethod(Object object, String methodName,\n-            Object[] args) throws NoSuchMethodException,\n+            Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n      * would match a <code>boolean</code> primitive.</p>\n      *\n      * <p> This is a convenient wrapper for\n-     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.\n      * </p>\n      *\n      * @param cls invoke static method on this class\n      * @param methodName get method with this name\n-     * @param arg use this argument\n+     * @param args use these arguments - treat null as empty array\n      * @return The value returned by the invoked method\n      *\n      * @throws NoSuchMethodException if there is no such accessible method\n      *  via reflection\n      */\n     public static Object invokeStaticMethod(Class<?> cls, String methodName,\n-            Object arg) throws NoSuchMethodException, IllegalAccessException,\n-            InvocationTargetException {\n-        return invokeStaticMethod(cls, methodName, new Object[] { arg });\n-    }\n-\n-    /**\n-     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n-     *\n-     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n-     *\n-     * <p>This method supports calls to methods taking primitive parameters \n-     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n-     * would match a <code>boolean</code> primitive.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.\n-     * </p>\n-     *\n-     * @param cls invoke static method on this class\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     * @return The value returned by the invoked method\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n-            Object[] args) throws NoSuchMethodException,\n+            Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n     }\n \n     /**\n-     * <p>Invoke a static method whose parameter type matches exactly the object\n-     * type.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args)}.\n-     * </p>\n+     * <p>Invoke a static method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n      *\n      * @param cls invoke static method on this class\n      * @param methodName get method with this name\n-     * @param arg use this argument\n+     * @param args use these arguments - treat null as empty array\n      * @return The value returned by the invoked method\n      *\n      * @throws NoSuchMethodException if there is no such accessible method\n      *  via reflection\n      */\n     public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n-            Object arg) throws NoSuchMethodException, IllegalAccessException,\n-            InvocationTargetException {\n-        return invokeExactStaticMethod(cls, methodName, new Object[] { arg });\n-    }\n-\n-    /**\n-     * <p>Invoke a static method whose parameter types match exactly the object\n-     * types.</p>\n-     *\n-     * <p> This uses reflection to invoke the method obtained from a call to\n-     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n-     *\n-     * @param cls invoke static method on this class\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     * @return The value returned by the invoked method\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n-            Object[] args) throws NoSuchMethodException,\n+            Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n             parameterTypes[i] = args[i].getClass();\n         }\n         return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n-    }\n-\n-    /**\n-     * <p>Return an accessible method (that is, one that can be invoked via\n-     * reflection) with given name and a single parameter.  If no such method\n-     * can be found, return <code>null</code>.\n-     * Basically, a convenience wrapper that constructs a <code>Class</code>\n-     * array for you.</p>\n-     *\n-     * @param cls get method from this class\n-     * @param methodName get method with this name\n-     * @param parameterType taking this type of parameter\n-     * @return The accessible method\n-     */\n-    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n-            Class<?> parameterType) {\n-        return getAccessibleMethod(cls, methodName,\n-                new Class<?>[] { parameterType });\n     }\n \n     /**\n      * @return The accessible method\n      */\n     public static Method getAccessibleMethod(Class<?> cls, String methodName,\n-            Class<?>[] parameterTypes) {\n+            Class<?>... parameterTypes) {\n         try {\n             return getAccessibleMethod(cls.getMethod(methodName,\n                     parameterTypes));\n      * @return the accessible method or <code>null</code> if not found\n      */\n     private static Method getAccessibleMethodFromSuperclass(Class<?> cls,\n-            String methodName, Class<?>[] parameterTypes) {\n+            String methodName, Class<?>... parameterTypes) {\n         Class<?> parentClass = cls.getSuperclass();\n         while (parentClass != null) {\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n      * @return the accessible method or <code>null</code> if not found\n      */\n     private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n-            String methodName, Class<?>[] parameterTypes) {\n+            String methodName, Class<?>... parameterTypes) {\n         Method method = null;\n \n         // Search up the superclass chain\n      * @return The accessible method\n      */\n     public static Method getMatchingAccessibleMethod(Class<?> cls,\n-            String methodName, Class<?>[] parameterTypes) {\n+            String methodName, Class<?>... parameterTypes) {\n         try {\n             Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround(method);", "timestamp": 1269237571, "metainfo": ""}