{"sha": "ea5d1ed0f02c0b3f3bcfcdac839e08f8e4211e21", "log": "merge from LANG_POST_2_4 branch: test as many locales as possible; test overriding a built-in format  ", "commit": "\n--- a/src/test/org/apache/commons/lang/text/ExtendedMessageFormatTest.java\n+++ b/src/test/org/apache/commons/lang/text/ExtendedMessageFormatTest.java\n  */\n package org.apache.commons.lang.text;\n \n+import java.text.ChoiceFormat;\n import java.text.DateFormat;\n import java.text.FieldPosition;\n import java.text.Format;\n import java.text.MessageFormat;\n import java.text.NumberFormat;\n import java.text.ParsePosition;\n+import java.util.Arrays;\n import java.util.Calendar;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.Locale;\n import java.util.Map;\n \n  * @version $Id$\n  */\n public class ExtendedMessageFormatTest extends TestCase {\n-\n-    private Locale[] testLocales = new Locale[] {null, //default locale\n-                                                 Locale.US,\n-                                                 Locale.UK,\n-                                                 Locale.FRANCE,\n-                                                 Locale.GERMANY};\n \n     private Map registry = new HashMap();\n \n         Calendar cal = Calendar.getInstance();\n         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n         Object[] args = new Object[] {\"John Doe\", cal.getTime(), new Double(\"12345.67\")};\n-        String pattern = \"Name: {0,upper} DOB: {1,date,short} Salary: {2,number,currency}\";\n-\n-        for (int i = 0; i < testLocales.length; i++) {\n+        String builtinsPattern = \"DOB: {1,date,short} Salary: {2,number,currency}\";\n+        String extendedPattern = \"Name: {0,upper} \";\n+        String pattern = extendedPattern + builtinsPattern;\n+\n+        HashSet testLocales = new HashSet();\n+        testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales()));\n+        testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));\n+        testLocales.add(null);\n+\n+        for (Iterator l = testLocales.iterator(); l.hasNext();) {\n+            Locale locale = (Locale) l.next();\n+            MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n+            String expectedPattern = extendedPattern + builtins.toPattern();;\n             DateFormat df = null;\n             NumberFormat nf = null;\n             ExtendedMessageFormat emf = null;\n-            if (testLocales[i] == null) {\n+            if (locale == null) {\n                 df = DateFormat.getDateInstance(DateFormat.SHORT);\n                 nf = NumberFormat.getCurrencyInstance();\n                 emf = new ExtendedMessageFormat(pattern, registry);\n             } else {\n-                df = DateFormat.getDateInstance(DateFormat.SHORT, testLocales[i]);\n-                nf = NumberFormat.getCurrencyInstance(testLocales[i]);\n-                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry);\n+                df = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+                nf = NumberFormat.getCurrencyInstance(locale);\n+                emf = new ExtendedMessageFormat(pattern, locale, registry);\n             }\n             StringBuffer expected = new StringBuffer();\n             expected.append(\"Name: \");\n             expected.append(df.format(args[1]));\n             expected.append(\" Salary: \");\n             expected.append(nf.format(args[2]));\n-            assertPatternsEqual(null, pattern, emf.toPattern());\n-            assertEquals(\"\" + testLocales[i], expected.toString(), emf.format(args));\n+            assertPatternsEqual(\"pattern comparison for locale \" + locale, expectedPattern, emf.toPattern());\n+            assertEquals(String.valueOf(locale), expected.toString(), emf.format(args));\n         }\n     }\n \n //        String pattern = \"Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}\";\n //        Object[] lowArgs  = new Object[] {new Integer(1), \"Low\",  new Double(\"1234.56\")};\n //        Object[] highArgs = new Object[] {new Integer(2), \"High\", new Double(\"9876.54\")};\n-\n+//        Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n+//        Locale[] testLocales = new Locale[availableLocales.length + 1];\n+//        testLocales[0] = null;\n+//        System.arraycopy(availableLocales, 0, testLocales, 1, availableLocales.length);\n //        for (int i = 0; i < testLocales.length; i++) {\n //            NumberFormat nf = null;\n //            NumberFormat cf = null;\n      */\n     public void testBuiltInChoiceFormat() {\n         Object[] values = new Number[] {new Integer(1), new Double(\"2.2\"), new Double(\"1234.5\")};\n-        String choicePattern = null; \n+        String choicePattern = null;\n+        Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n \n         choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n         for (int i = 0; i < values.length; i++) {\n-            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]});\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n         }\n \n         choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n         for (int i = 0; i < values.length; i++) {\n-            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]});\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n         }\n     }\n \n         Calendar cal = Calendar.getInstance();\n         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n         Object[] args = new Object[] {cal.getTime()};\n-\n-        checkBuiltInFormat(\"1: {0,date,short}\",    args);\n-        checkBuiltInFormat(\"2: {0,date,medium}\",   args);\n-        checkBuiltInFormat(\"3: {0,date,long}\",     args);\n-        checkBuiltInFormat(\"4: {0,date,full}\",     args);\n-        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", args);\n-        checkBuiltInFormat(\"6: {0,time,short}\",    args);\n-        checkBuiltInFormat(\"7: {0,time,medium}\",   args);\n-        checkBuiltInFormat(\"8: {0,time,long}\",     args);\n-        checkBuiltInFormat(\"9: {0,time,full}\",     args);\n-        checkBuiltInFormat(\"10: {0,time,HH:mm}\",   args);\n+        Locale[] availableLocales = DateFormat.getAvailableLocales();\n+\n+        checkBuiltInFormat(\"1: {0,date,short}\",    args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,date,medium}\",   args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,date,long}\",     args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,date,full}\",     args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", args, availableLocales);\n+        checkBuiltInFormat(\"6: {0,time,short}\",    args, availableLocales);\n+        checkBuiltInFormat(\"7: {0,time,medium}\",   args, availableLocales);\n+        checkBuiltInFormat(\"8: {0,time,long}\",     args, availableLocales);\n+        checkBuiltInFormat(\"9: {0,time,full}\",     args, availableLocales);\n+        checkBuiltInFormat(\"10: {0,time,HH:mm}\",   args, availableLocales);\n+        checkBuiltInFormat(\"11: {0,date}\",         args, availableLocales);\n+        checkBuiltInFormat(\"12: {0,time}\",         args, availableLocales);\n+    }\n+\n+    public void testOverriddenBuiltinFormat() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23);\n+        Object[] args = new Object[] {cal.getTime()};\n+        Locale[] availableLocales = DateFormat.getAvailableLocales();\n+        Map registry = Collections.singletonMap(\"date\", new OverrideShortDateFormatFactory());\n+\n+        //check the non-overridden builtins:\n+        checkBuiltInFormat(\"1: {0,date}\", registry,          args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,date,medium}\", registry,   args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,date,long}\", registry,     args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,date,full}\", registry,     args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", registry, args, availableLocales);\n+\n+        //check the overridden format:\n+        for (int i = -1; i < availableLocales.length; i++) {\n+            Locale locale = i < 0 ? null : availableLocales[i];\n+            MessageFormat dateDefault = createMessageFormat(\"{0,date}\", locale);\n+            String pattern = \"{0,date,short}\";\n+            ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry);\n+            assertEquals(\"overridden date,short format\", dateDefault.format(args), dateShort.format(args));\n+            assertEquals(\"overridden date,short pattern\", pattern, dateShort.toPattern());\n+        }\n     }\n \n     /**\n      */\n     public void testBuiltInNumberFormat() {\n         Object[] args = new Object[] {new Double(\"6543.21\")};\n-        checkBuiltInFormat(\"1: {0,number}\",            args);\n-        checkBuiltInFormat(\"2: {0,number,integer}\",    args);\n-        checkBuiltInFormat(\"3: {0,number,currency}\",   args);\n-        checkBuiltInFormat(\"4: {0,number,percent}\",    args);\n-        checkBuiltInFormat(\"5: {0,number,00000.000}\",  args);\n-    }\n-\n-    /**\n-     * Create ExtendedMessageFormats for the specified pattern and the set of locales\n-     * and check the formated output matches the expected result for the parameters.\n-     */\n-    private void checkBuiltInFormat(String pattern, Object[] args) {\n-        for (int i = 0; i < testLocales.length; i++) {\n-            checkBuiltInFormat(pattern, args, testLocales[i]);\n+        Locale[] availableLocales = NumberFormat.getAvailableLocales();\n+        checkBuiltInFormat(\"1: {0,number}\",            args, availableLocales);\n+        checkBuiltInFormat(\"2: {0,number,integer}\",    args, availableLocales);\n+        checkBuiltInFormat(\"3: {0,number,currency}\",   args, availableLocales);\n+        checkBuiltInFormat(\"4: {0,number,percent}\",    args, availableLocales);\n+        checkBuiltInFormat(\"5: {0,number,00000.000}\",  args, availableLocales);\n+    }\n+\n+    /**\n+     * Test a built in format for the specified Locales, plus <code>null</code> Locale.\n+     * @param pattern MessageFormat pattern\n+     * @param args MessageFormat arguments\n+     * @param locales to test\n+     */\n+    private void checkBuiltInFormat(String pattern, Object[] args, Locale[] locales) {\n+        checkBuiltInFormat(pattern, null, args, locales);\n+    }\n+\n+    /**\n+     * Test a built in format for the specified Locales, plus <code>null</code> Locale.\n+     * @param pattern MessageFormat pattern\n+     * @param registry FormatFactory registry to use\n+     * @param args MessageFormat arguments\n+     * @param locales to test\n+     */\n+    private void checkBuiltInFormat(String pattern, Map registry, Object[] args, Locale[] locales) {\n+        checkBuiltInFormat(pattern, registry, args, (Locale) null);\n+        for (int i = 0; i < locales.length; i++) {\n+            checkBuiltInFormat(pattern, registry, args, locales[i]);\n         }\n     }\n \n     /**\n      * Create an ExtendedMessageFormat for the specified pattern and locale and check the\n      * formated output matches the expected result for the parameters.\n-     */\n-    private void checkBuiltInFormat(String pattern, Object[] args, Locale locale) {\n+     * @param pattern string\n+     * @param registry map\n+     * @param args Object[]\n+     * @param locale Locale\n+     */\n+    private void checkBuiltInFormat(String pattern, Map registry, Object[] args, Locale locale) {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"Pattern=[\");\n         buffer.append(pattern);\n         buffer.append(\"], locale=[\");\n         buffer.append(locale);\n         buffer.append(\"]\");\n-        MessageFormat mf = new MessageFormat(pattern);\n-        if (locale != null) {\n-            mf.setLocale(locale);\n-            mf.applyPattern(pattern);\n-        }\n+        MessageFormat mf = createMessageFormat(pattern, locale);\n         // System.out.println(buffer + \", result=[\" + mf.format(args) +\"]\");\n         ExtendedMessageFormat emf = null;\n         if (locale == null) {\n         }\n     }\n \n+    /**\n+     * Replace MessageFormat(String, Locale) constructor (not available until JDK 1.4).\n+     * @param pattern string\n+     * @param locale Locale\n+     * @return MessageFormat\n+     */\n+    private MessageFormat createMessageFormat(String pattern, Locale locale) {\n+        MessageFormat result = new MessageFormat(pattern);\n+        if (locale != null) {\n+            result.setLocale(locale);\n+            result.applyPattern(pattern);\n+        }\n+        return result;\n+    }\n+\n     // ------------------------ Test Formats ------------------------\n \n     /**\n-     * {@link Format} implementation which converts to upper case.\n+     * {@link Format} implementation which converts to lower case.\n      */\n     private static class LowerCaseFormat extends Format {\n         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n     }\n \n     /**\n-     * {@link Format} implementation which converts to lower case.\n+     * {@link Format} implementation which converts to upper case.\n      */\n     private static class UpperCaseFormat extends Format {\n         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n             return UPPER_INSTANCE;\n         }\n     }\n+    /**\n+     * {@link FormatFactory} implementation to override date format \"short\" to \"default\".\n+     */\n+    private static class OverrideShortDateFormatFactory implements FormatFactory {\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return !\"short\".equals(arguments) ? null\n+                    : locale == null ? DateFormat\n+                            .getDateInstance(DateFormat.DEFAULT) : DateFormat\n+                            .getDateInstance(DateFormat.DEFAULT, locale);\n+        }\n+    }\n }", "timestamp": 1210105815, "metainfo": ""}