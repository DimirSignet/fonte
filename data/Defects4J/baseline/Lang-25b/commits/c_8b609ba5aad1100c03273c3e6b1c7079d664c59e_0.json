{"sha": "8b609ba5aad1100c03273c3e6b1c7079d664c59e", "log": "More tests, more bugfixes (aka rewrite of the guts).   It's looking much better, the only edge case that throws it for a loop is if things start on the 29th of February in a year. I've hacked it in the day mode, but I'm not sure why I had to do that - however I trust the brute force test to be right in day mode.  In month mode, it's even trickier as to what the correct answer is. How many months between 29th Feb and 28th of Feb the next year? The answer is 11, or with days included it's 11 months and 28 days. I can't see any reason to define that better, so I'm declaring that law.   Things are weird if you start on Feb 29 :)  ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n     public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n             TimeZone timezone) {\n \n-        long millis = endMillis - startMillis;\n-        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n-            return formatDuration(millis, format, padWithZeros);\n-        }\n-\n+        // Used to optimise for differences under 28 days and \n+        // called formatDuration(millis, format); however this did not work \n+        // over leap years. \n+        // TODO: Compare performance to see if anything was lost by \n+        // losing this optimisation. \n+        \n         Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n             hours += 24;\n             days -= 1;\n         }\n-        // TODO: Create a test to see if this should be while. ie) one that makes hours above \n-        //       overflow and pushes this above the maximum # of days in a month?\n-        int leapDays = 0;\n-        if (days < 0) {\n-            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-            // Multiple answers possible. \n-            // For example, for Jan 15th to March 10th. If I count days-first it is \n-            // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-            // Here we choose the former. \n-            months -= 1;\n-            start.add(Calendar.MONTH, 1);\n-        }\n-        while (months < 0) {\n-            months += 12;\n-            years -= 1;\n-            if (start instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) start).isLeapYear(start.get(Calendar.YEAR) + 1) &&\n-                     ( end.get(Calendar.MONTH) > 1) )  \n-                {\n-                    leapDays += 1;\n-                }\n-            }\n-            if (end instanceof GregorianCalendar) {\n-                if ( ((GregorianCalendar) end).isLeapYear(end.get(Calendar.YEAR)) &&\n-                     ( end.get(Calendar.MONTH) < 1) )  \n-                {\n-                    leapDays -= 1;\n-                }\n-            }\n-            start.add(Calendar.YEAR, 1);\n-        }\n-\n-        // This rest of this code adds in values that \n+       \n+        if (Token.containsTokenWithValue(tokens, M)) {\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+\n+            while (months < 0) {\n+                months += 12;\n+                years -= 1;\n+            }\n+\n+            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n+                while (years != 0) {\n+                    months += 12 * years;\n+                    years = 0;\n+                }\n+            }\n+        } else {\n+            // there are no M's in the format string\n+\n+            if( !Token.containsTokenWithValue(tokens, y) ) {\n+                int target = end.get(Calendar.YEAR);\n+                if (months < 0) {\n+                    // target is end-year -1\n+                    target -= 1;\n+                }\n+                \n+                while ( (start.get(Calendar.YEAR) != target)) {\n+                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+                    \n+                    // Not sure I grok why this is needed, but the brutal tests show it is\n+                    if(start instanceof GregorianCalendar) {\n+                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n+                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n+                        {\n+                            days += 1;\n+                        }\n+                    }\n+                    \n+                    start.add(Calendar.YEAR, 1);\n+                    \n+                    days += start.get(Calendar.DAY_OF_YEAR);\n+                }\n+                \n+                years = 0;\n+            }\n+            \n+            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+            months = 0;            \n+\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+        }\n+\n+        // The rest of this code adds in values that \n         // aren't requested. This allows the user to ask for the \n         // number of months and get the real count and not just 0->11.\n-        \n-        if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n-            if (Token.containsTokenWithValue(tokens, M)) {\n-                months += 12 * years;\n-                years = 0;\n-            } else {\n-                while ( (start.get(Calendar.YEAR) != end.get(Calendar.YEAR))) {\n-                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR);\n-                    start.add(Calendar.YEAR, 1);\n-                }\n-                years = 0;\n-            }\n-        }\n-        start.set(Calendar.YEAR, end.get(Calendar.YEAR));\n-                \n-        if (!Token.containsTokenWithValue(tokens, M) && months != 0) {   \n-            while(start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {\n-                String date = start.getTime().toString();\n-                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n-                start.add(Calendar.MONTH, 1);\n-            }\n-            days += leapDays;\n-            months = 0;            \n-        }\n-        start.set(Calendar.MONTH, end.get(Calendar.MONTH));\n \n         if (!Token.containsTokenWithValue(tokens, d)) {\n             hours += 24 * days;\n--- a/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n \n         assertEqualDuration( \"365\", new int[] { 2007, 2, 2, 0, 0, 0 },\n                 new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n-  //      assertEqualDuration( \"333\", new int[] { 2007, 1, 2, 0, 0, 0 },\n-  //              new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"333\", new int[] { 2007, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 0, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"28\", new int[] { 2008, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n+        assertEqualDuration( \"393\", new int[] { 2007, 1, 2, 0, 0, 0 },\n+                new int[] { 2008, 2, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"369\", new int[] { 2004, 0, 29, 0, 0, 0 },\n+                new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"338\", new int[] { 2004, 1, 29, 0, 0, 0 },\n+                new int[] { 2005, 1, 1, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"28\", new int[] { 2004, 2, 8, 0, 0, 0 },\n+                new int[] { 2004, 3, 5, 0, 0, 0 }, \"dd\"); \n+\n+        assertEqualDuration( \"48\", new int[] { 1992, 1, 29, 0, 0, 0 },\n+                new int[] { 1996, 1, 29, 0, 0, 0 }, \"M\"); \n+        \n+        \n+        // this seems odd - and will fail if I throw it in as a brute force \n+        // below as it expects the answer to be 12. It's a tricky edge case\n+        assertEqualDuration( \"11\", new int[] { 1996, 1, 29, 0, 0, 0 },\n+                new int[] { 1997, 1, 28, 0, 0, 0 }, \"M\"); \n+        // again - this seems odd\n+        assertEqualDuration( \"11 28\", new int[] { 1996, 1, 29, 0, 0, 0 },\n+                new int[] { 1997, 1, 28, 0, 0, 0 }, \"M d\"); \n+        \n     }\n     \n     public void testDurationsByBruteForce() {\n-        bruteForce(2006, 0, 1);\n-        bruteForce(2006, 0, 2);\n-  //      bruteForce(2007, 1, 2);\n-    }\n-        \n-    private void bruteForce(int year, int month, int day) {\n+        bruteForce(2006, 0, 1, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2006, 0, 2, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2007, 1, 2, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(2004, 1, 29, \"d\", Calendar.DAY_OF_MONTH);\n+        bruteForce(1996, 1, 29, \"d\", Calendar.DAY_OF_MONTH);\n+\n+        bruteForce(1969, 1, 28, \"M\", Calendar.MONTH);  // tests for 48 years\n+        //bruteForce(1996, 1, 29, \"M\", Calendar.MONTH);  // this will fail\n+    }\n+    \n+    private int FOUR_YEARS = 365 * 3 + 366;\n+    \n+    // Takes a minute to run, so generally turned off\n+//    public void testBrutally() {\n+//        Calendar c = Calendar.getInstance();\n+//        c.set(2004, 0, 1, 0, 0, 0);\n+//        for (int i=0; i < FOUR_YEARS; i++) {\n+//            bruteForce(c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH), \"d\", Calendar.DAY_OF_MONTH );\n+//            c.add(Calendar.DAY_OF_MONTH, 1);\n+//        }\n+//    }        \n+    \n+    private void bruteForce(int year, int month, int day, String format, int calendarType) {\n         String msg = year + \"-\" + month + \"-\" + day + \" to \";\n         Calendar c = Calendar.getInstance();\n         c.set(year, month, day, 0, 0, 0);\n         int[] array1 = new int[] { year, month, day, 0, 0, 0 };\n         int[] array2 = new int[] { year, month, day, 0, 0, 0 };\n-        for (int i=0; i < 1500; i++) {\n+        for (int i=0; i < FOUR_YEARS; i++) {\n             array2[0] = c.get(Calendar.YEAR);\n             array2[1] = c.get(Calendar.MONTH);\n             array2[2] = c.get(Calendar.DAY_OF_MONTH);\n             String tmpMsg = msg + array2[0] + \"-\" + array2[1] + \"-\" + array2[2] + \" at \";\n-            assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, \"d\" );\n-            c.add(Calendar.DAY_OF_MONTH, 1);\n+            assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format );\n+            c.add(calendarType, 1);\n         }\n     }\n+    \n+    \n \n     private void assertEqualDuration(String expected, int[] start, int[] end, String format) {\n         assertEqualDuration(null, expected, start, end, format);", "timestamp": 1166595026, "metainfo": ""}