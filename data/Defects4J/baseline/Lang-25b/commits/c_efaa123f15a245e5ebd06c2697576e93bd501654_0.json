{"sha": "efaa123f15a245e5ebd06c2697576e93bd501654", "log": "Add CompareToBuilder for building compareTo methods   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.NumberUtils;\n+/** \n+ * <code>CompareTo</code> generation routines.\n+ * <p>\n+ * This class provides methods to build a good <comde>compareTo()</code> method for any class.\n+ * It is consistent with the <code>equals</code> and <code>hashcode</code> built\n+ * with EqualsBuilder and HashCodeBuilder.\n+ * <p>\n+ * Two object that compare equal using equals should compare equals using\n+ * compareTo.\n+ * <p>\n+ * All relevant fields should be included in the calculation of the comparison. Derived\n+ * fields may be ignored. The same fields, in the same order, should be used in\n+ * both <code>compareTo</code> and <code>equals</code>.\n+ * <p>\n+ * Typical use for the code is as follows:\n+ *\n+ * <pre>\n+ *  public int comapareTo(Object o) {\n+ *    MyClass rhs = (MyClass) o;\n+ *    return new CompareToBuilder()\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .appendb(field3, rhs.field3)\n+ *                 .toComparison();\n+ *  }\n+ * </pre>\n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionCompare</code>, uses <code>Field.setAccessible</code> to change\n+ * the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set. It is also slower than testing\n+ * explicitly.\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * <pre>\n+ * public int compareTo(Object o) {\n+ *   return CompareToBuilder.reflectionCompare(this, obj);\n+ * }\n+ * </pre>\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: CompareToBuilder.java,v 1.1 2002/09/15 10:25:22 scolebourne Exp $\n+ */\n+public class CompareToBuilder {\n+    /**\n+     * If the fields tested are equals.\n+     */\n+    protected int comparison;\n+\n+    /**\n+     * Constructor for CompareToBuilder.\n+     * Starts off assuming that the objects are equal.\n+     * @see java.lang.Object#Object()\n+     */\n+    public CompareToBuilder() {\n+        super();\n+        comparison = 0;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /** \n+     * This method uses reflection to determine the ordering between two objects.\n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly.\n+     * Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the object.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return int - a negative integer, zero, or a positive integer as this \n+     * object is less than, equal to, or greater than the specified object.\n+     * @throws ClassCastException - if the specified object's type prevents it \n+     * from being compared to this Object.\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs) {\n+        return reflectionCompare(lhs, rhs, false);\n+    }\n+\n+    /**\n+     * This method uses reflection to determine if the two object are equal. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the TestTransients parameter is set to true, transient members will be\n+     * tested, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * \n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @param testTransients - whether to include transient fields\n+     * @return int - a negative integer, zero, or a positive integer as this \n+     * object is less than, equal to, or greater than the specified object.\n+     * @throws ClassCastException - if the specified object's type prevents it \n+     * from being compared to this Object.\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean testTransients) {\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        Class c1 = lhs.getClass();\n+        if (!c1.isInstance(rhs)) {\n+            throw new ClassCastException();\n+        }\n+        Field[] fields = c1.getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        for (int i = 0; i < fields.length && compareToBuilder.comparison == 0; ++i) {\n+            Field f = fields[i];\n+            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+                try {\n+                    compareToBuilder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+        return compareToBuilder.toComparison();\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /** Test if two <code>Object</code>s are equal using either the\n+     * <code>compareTo</code> method, or native comparison if the Objects are\n+     * actually arrays.\n+     * <p>\n+     * The objects must be <code>Comparable</code>. If they are not, the method\n+     * will throw a <code>ClassCastException</code>.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     * @throws ClassCastException - if the specified object's type prevents it\n+     * from being compared to this Object.\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        Class lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            //the simple case, not an array, just test the element \n+            comparison = ((Comparable)lhs).compareTo(rhs);\n+        } else {\n+            //'Switch' on type of array, to dispatch to the correct handler\n+            // This handles multi dimensional arrays\n+            if (lhs instanceof long[]) {\n+                append((long[]) lhs, (long[]) rhs);\n+            } else if (lhs instanceof int[]) {\n+                append((int[]) lhs, (int[]) rhs);\n+            } else if (lhs instanceof short[]) {\n+                append((short[]) lhs, (short[]) rhs);\n+            } else if (lhs instanceof char[]) {\n+                append((char[]) lhs, (char[]) rhs);\n+            } else if (lhs instanceof byte[]) {\n+                append((byte[]) lhs, (byte[]) rhs);\n+            } else if (lhs instanceof double[]) {\n+                append((double[]) lhs, (double[]) rhs);\n+            } else if (lhs instanceof float[]) {\n+                append((float[]) lhs, (float[]) rhs);\n+            } else if (lhs instanceof boolean[]) {\n+                append((boolean[]) lhs, (boolean[]) rhs);\n+            } else {\n+                // Not an array of primitives\n+                append((Object[]) lhs, (Object[]) rhs);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>long</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(long lhs, long rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>int</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(int lhs, int rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>short</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(short lhs, short rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>char</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(char lhs, char rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>byte</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(byte lhs, byte rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>double</code>s are <, > or ==. This handles NaNs, \n+     * Infinties, and -0.0. It is compatible with the hash code generated by \n+     * <code>HashCodeBuilder</code>.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(double lhs, double rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = NumberUtils.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>double</code>s are <, > or ==. This handles NaNs, \n+     * Infinties, and -0.0. It is compatible with the hash code generated by \n+     * <code>HashCodeBuilder</code>.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(float lhs, float rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = NumberUtils.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>booleans</code>s are <, > or ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+      */\n+    public CompareToBuilder append(boolean lhs, boolean rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+        \treturn this;\n+        }\n+        if (lhs == false) {\n+        \tcomparison = -1;\n+        } else {\n+        \tcomparison = +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Performs a deep comparison of two object arrays. This also will be\n+     * called for the top level of multi-dimensional, ragged, and multi-typed\n+     * arrays. If two arrays are of different lengths, and all elements of the\n+     * shorter array are equal to the elements in the longer array, the longer\n+     * array is the greater. This is dictionary, or lexical, ordering.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     * @throws ClassCastException - if the specified object's type prevents it \n+     * from being compared to this Object.\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+         }\n+         \n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            Class lhsClass = lhs[i].getClass();\n+            if (!lhsClass.isInstance(rhs[i])) {\n+            \tthrow new ClassCastException();\n+            }\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>long</code> Length and all values\n+     *  are compared. The method append(long, long) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>int</code> Length and all values\n+     *  are compared. The method append(int, int) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>short</code> Length and all values\n+     *  are compared. The method append(short, short) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>char</code> Length and all values\n+     *  are compared. The method append(char, char) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>byte</code> Length and all values\n+     *  are compared. The method append(byte, byte) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>double</code> Length and all values\n+     *  are compared. The method append(double, double) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>float</code> Length and all values\n+     *  are compared. The method append(float, float) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>boolean</code> Length and all values\n+     *  are compared. The method append(boolean, boolean) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n+        for (int i = 0; i < length && comparison == 0; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        if (comparison == 0 && lhs.length != rhs.length) {\n+        \tcomparison = (lhs.length < rhs.length) ? -1 : +1;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Return a negative integer if the object is less than, a positive \n+     * integer if the object is greater than, or 0 if the object is equal.\n+     * \n+     * @return int - a negative integer, zero, or a positive integer as this \n+     * object is less than, equal to, or greater than the specified object.\n+     */\n+    public int toComparison() {\n+        return comparison;\n+    }\n+\n+}\n+", "timestamp": 1032085522, "metainfo": ""}