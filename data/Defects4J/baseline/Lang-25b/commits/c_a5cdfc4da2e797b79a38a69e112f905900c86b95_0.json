{"sha": "a5cdfc4da2e797b79a38a69e112f905900c86b95", "log": "Minor style fixes suggested by checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n      * @param str  the <code>String</code> to escape, may be null\n      * @return a new escaped <code>String</code>, <code>null</code> if null string input\n      * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException if there is a problem writing\n      * @see #unescapeXml(java.lang.String)\n      */\n     public static void escapeXml(Writer writer, String str) throws IOException {\n      * @param str  the <code>String</code> to unescape, may be null\n      * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n      * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException if there is a problem writing\n      * @see #escapeXml(String)\n      */\n     public static void unescapeXml(Writer writer, String str) throws IOException {\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n      * @param rhs  right-hand object\n      * @param compareTransients  whether to compare transient fields\n      * @param reflectUpToClass  last superclass for which fields are compared\n+     * @param excludeFields  fields to exclude\n      * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n      *  is less than, equal to, or greater than <code>rhs</code>\n      * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n      *  with <code>lhs</code>\n      * @since 2.0\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class reflectUpToClass, String[] excludeFields) {\n+    public static int reflectionCompare(\n+        Object lhs, \n+        Object rhs, \n+        boolean compareTransients, \n+        Class reflectUpToClass, \n+        String[] excludeFields) {\n+\n         if (lhs == rhs) {\n             return 0;\n         }\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n     public static int reflectionHashCode(\n             int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n             Object object, boolean testTransients) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null, null);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, \n+                                  object, testTransients, null, null\n+                                 );\n     }\n             \n     /**\n      * @param clazz  the class to append details of\n      * @param builder  the builder to append to\n      * @param useTransients  whether to use transient fields\n+     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n      */\n     private static void reflectionAppend(\n             Object object, \n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n      *             if the Object is <code>null</code>\n      * @since 2.0\n      */\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {\n+    public static String toString(Object object, ToStringStyle style, \n+                                  boolean outputTransients, Class reflectUpToClass) \n+    {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n     }\n \n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n      *  immediately after the delimiter, or if end of string found,\n      *  then the length of string\n      */\n-    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, List tokens, int quoteStart, int quoteLen) {\n+    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n+                               List tokens, int quoteStart, int quoteLen) \n+    {\n         // Loop until we've found the end of the quoted\n         // string or the end of the input\n         workArea.clear();\n      * list.\n      * \n      * @return a new instance of this Tokenizer which has been reset.\n+     * @throws CloneNotSupportedException if there is a problem cloning\n      */\n     Object cloneReset() throws CloneNotSupportedException {\n         StrTokenizer cloned = (StrTokenizer) super.clone();\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n                         checkTextToken(startPos);\n                         setPos(getPos() + tokenLen);\n                         int varStart = getPos(), endLen = 0;\n-                        while (hasNext() && (endLen = getVarEndMatcher().isMatch(data, getPos(), 0, getLength())) <= 0) {\n+                        while ( hasNext() && \n+                                (endLen = getVarEndMatcher().isMatch(data, getPos(), 0, getLength())) <= 0\n+                              )\n+                        {\n                             setPos(getPos() + 1);\n                         }\n                         if (endLen <= 0) {\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n+System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }", "timestamp": 1152080053, "metainfo": ""}