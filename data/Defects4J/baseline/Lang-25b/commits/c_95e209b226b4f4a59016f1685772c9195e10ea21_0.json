{"sha": "95e209b226b4f4a59016f1685772c9195e10ea21", "log": "Genericize some more classes  ", "commit": "\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n      * @return the <code>List</code> of superclasses in order going up from this one\n      *  <code>null</code> if null input\n      */\n-    public static List getAllSuperclasses(Class cls) {\n+    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n         if (cls == null) {\n             return null;\n         }\n-        List classes = new ArrayList();\n-        Class superclass = cls.getSuperclass();\n+        List<Class<?>> classes = new ArrayList<Class<?>>();\n+        Class<?> superclass = cls.getSuperclass();\n         while (superclass != null) {\n             classes.add(superclass);\n             superclass = superclass.getSuperclass();\n--- a/src/java/org/apache/commons/lang/NotImplementedException.java\n+++ b/src/java/org/apache/commons/lang/NotImplementedException.java\n  */\n package org.apache.commons.lang;\n \n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n \n /**\n  * <p>Thrown to indicate that a block of code has not been implemented.\n  * @since 2.0\n  * @version $Id$\n  */\n+//@Immutable\n public class NotImplementedException extends UnsupportedOperationException {\n \n     private static final String DEFAULT_MESSAGE = \"Code is not implemented\";\n      * @param clazz\n      *            the <code>Class</code> that has not implemented the method\n      */\n-    public NotImplementedException(Class clazz) {\n+    public NotImplementedException(Class<?> clazz) {\n         super(clazz == null ? DEFAULT_MESSAGE : DEFAULT_MESSAGE + \" in \" + clazz);\n     }\n \n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n      */\n     public static void addCauseMethodName(String methodName) {\n         if (StringUtils.isNotEmpty(methodName) && !isCauseMethodName(methodName)) {            \n-            List list = getCauseMethodNameList();\n+            List<String> list = getCauseMethodNameList();\n             if (list.add(methodName)) {\n                 synchronized(CAUSE_METHOD_NAMES) {\n                     CAUSE_METHOD_NAMES = toArray(list);\n      */\n     public static void removeCauseMethodName(String methodName) {\n         if (StringUtils.isNotEmpty(methodName)) {\n-            List list = getCauseMethodNameList();\n+            List<String> list = getCauseMethodNameList();\n             if (list.remove(methodName)) {\n                 synchronized(CAUSE_METHOD_NAMES) {\n                     CAUSE_METHOD_NAMES = toArray(list);\n      * @param list a list to transform.\n      * @return the given list as a <code>String[]</code>.\n      */\n-    private static String[] toArray(List list) {\n-        return (String[]) list.toArray(new String[list.size()]);\n+    private static String[] toArray(List<String> list) {\n+        return list.toArray(new String[list.size()]);\n     }\n \n     /**\n      *\n      * @return {@link #CAUSE_METHOD_NAMES} as a List.\n      */\n-    private static ArrayList getCauseMethodNameList() {\n+    private static ArrayList<String> getCauseMethodNameList() {\n         synchronized(CAUSE_METHOD_NAMES) {\n-            return new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));\n+            return new ArrayList<String>(Arrays.asList(CAUSE_METHOD_NAMES));\n         }\n     }\n \n      *  <code>null</code> if none found or null throwable input\n      */\n     public static Throwable getRootCause(Throwable throwable) {\n-        List list = getThrowableList(throwable);\n+        List<Throwable> list = getThrowableList(throwable);\n         return (list.size() < 2 ? null : (Throwable)list.get(list.size() - 1));\n     }\n \n             return true;\n         }\n \n-        Class cls = throwable.getClass();\n+        Class<? extends Throwable> cls = throwable.getClass();\n         synchronized(CAUSE_METHOD_NAMES) {\n             for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i < isize; i++) {\n                 try {\n      * @return the array of throwables, never null\n      */\n     public static Throwable[] getThrowables(Throwable throwable) {\n-        List list = getThrowableList(throwable);\n-        return (Throwable[]) list.toArray(new Throwable[list.size()]);\n+        List<Throwable> list = getThrowableList(throwable);\n+        return list.toArray(new Throwable[list.size()]);\n     }\n \n     /**\n      * @return the list of throwables, never null\n      * @since Commons Lang 2.2\n      */\n-    public static List getThrowableList(Throwable throwable) {\n-        List list = new ArrayList();\n+    public static List<Throwable> getThrowableList(Throwable throwable) {\n+        List<Throwable> list = new ArrayList<Throwable>();\n         while (throwable != null && list.contains(throwable) == false) {\n             list.add(throwable);\n             throwable = ExceptionUtils.getCause(throwable);\n      * @param clazz  the class to search for, subclasses do not match, null returns -1\n      * @return the index into the throwable chain, -1 if no match or null input\n      */\n-    public static int indexOfThrowable(Throwable throwable, Class clazz) {\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz) {\n         return indexOf(throwable, clazz, 0, false);\n     }\n \n      *  negative treated as zero, larger than chain size returns -1\n      * @return the index into the throwable chain, -1 if no match or null input\n      */\n-    public static int indexOfThrowable(Throwable throwable, Class clazz, int fromIndex) {\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz, int fromIndex) {\n         return indexOf(throwable, clazz, fromIndex, false);\n     }\n \n      * @return the index into the throwable chain, -1 if no match or null input\n      * @since 2.1\n      */\n-    public static int indexOfType(Throwable throwable, Class type) {\n+    public static int indexOfType(Throwable throwable, Class<?> type) {\n         return indexOf(throwable, type, 0, true);\n     }\n \n      * @return the index into the throwable chain, -1 if no match or null input\n      * @since 2.1\n      */\n-    public static int indexOfType(Throwable throwable, Class type, int fromIndex) {\n+    public static int indexOfType(Throwable throwable, Class<?> type, int fromIndex) {\n         return indexOf(throwable, type, fromIndex, true);\n     }\n \n      * using references\n      * @return index of the <code>type</code> within throwables nested withing the specified <code>throwable</code>\n      */\n-    private static int indexOf(Throwable throwable, Class type, int fromIndex, boolean subclass) {\n+    private static int indexOf(Throwable throwable, Class<?> type, int fromIndex, boolean subclass) {\n         if (throwable == null || type == null) {\n             return -1;\n         }\n         }\n         Throwable throwables[] = getThrowables(throwable);\n         int count = throwables.length;\n-        ArrayList frames = new ArrayList();\n-        List nextTrace = getStackFrameList(throwables[count - 1]);\n+        ArrayList<String> frames = new ArrayList<String>();\n+        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n         for (int i = count; --i >= 0;) {\n-            List trace = nextTrace;\n+            List<String> trace = nextTrace;\n             if (i != 0) {\n                 nextTrace = getStackFrameList(throwables[i - 1]);\n                 removeCommonFrames(trace, nextTrace);\n                 frames.add(trace.get(j));\n             }\n         }\n-        return (String[]) frames.toArray(new String[0]);\n+        return frames.toArray(new String[0]);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either argument is null\n      * @since 2.0\n      */\n-    public static void removeCommonFrames(List causeFrames, List wrapperFrames) {\n+    public static void removeCommonFrames(List<String> causeFrames, List<String> wrapperFrames) {\n         if (causeFrames == null || wrapperFrames == null) {\n             throw new IllegalArgumentException(\"The List must not be null\");\n         }\n         while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n             // Remove the frame from the cause trace if it is the same\n             // as in the wrapper trace\n-            String causeFrame = (String) causeFrames.get(causeFrameIndex);\n-            String wrapperFrame = (String) wrapperFrames.get(wrapperFrameIndex);\n+            String causeFrame = causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n             if (causeFrame.equals(wrapperFrame)) {\n                 causeFrames.remove(causeFrameIndex);\n             }\n     static String[] getStackFrames(String stackTrace) {\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        List list = new ArrayList();\n+        List<String> list = new ArrayList<String>();\n         while (frames.hasMoreTokens()) {\n             list.add(frames.nextToken());\n         }\n      * @param t is any throwable\n      * @return List of stack frames\n      */\n-    static List getStackFrameList(Throwable t) {\n+    static List<String> getStackFrameList(Throwable t) {\n         String stackTrace = getStackTrace(t);\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        List list = new ArrayList();\n+        List<String> list = new ArrayList<String>();\n         boolean traceStarted = false;\n         while (frames.hasMoreTokens()) {\n             String token = frames.nextToken();\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n     private static final char QUOTE = '\\'';\n \n     private String toPattern;\n-    private Map registry;\n+    private final Map<String, FormatFactory> registry;\n \n     /**\n      * Create a new ExtendedMessageFormat for the default locale.\n      * @param registry Registry of format factories:  Map<String, FormatFactory>\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Map registry) {\n+    public ExtendedMessageFormat(String pattern, Map<String, FormatFactory> registry) {\n         this(pattern, Locale.getDefault(), registry);\n     }\n \n      * @param registry Registry of format factories:  Map<String, FormatFactory>\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, FormatFactory> registry) {\n         super(DUMMY_PATTERN);\n         setLocale(locale);\n         this.registry = registry;\n             toPattern = super.toPattern();\n             return;\n         }\n-        ArrayList foundFormats = new ArrayList();\n-        ArrayList foundDescriptions = new ArrayList();\n+        ArrayList<Format> foundFormats = new ArrayList<Format>();\n+        ArrayList<String> foundDescriptions = new ArrayList<String>();\n         StringBuffer stripCustom = new StringBuffer(pattern.length());\n \n         ParsePosition pos = new ParsePosition(0);\n             // only loop over what we know we have, as MessageFormat on Java 1.3 \n             // seems to provide an extra format element:\n             int i = 0;\n-            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n-                Format f = (Format) it.next();\n+            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n+                Format f = it.next();\n                 if (f != null) {\n                     origFormats[i] = f;\n                 }\n                 name = desc.substring(0, i).trim();\n                 args = desc.substring(i + 1).trim();\n             }\n-            FormatFactory factory = (FormatFactory) registry.get(name);\n+            FormatFactory factory = registry.get(name);\n             if (factory != null) {\n                 return factory.getFormat(name, args, getLocale());\n             }\n      * @param customPatterns The custom patterns to re-insert, if any\n      * @return full pattern\n      */\n-    private String insertFormats(String pattern, ArrayList customPatterns) {\n+    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n         if (!containsElements(customPatterns)) {\n             return pattern;\n         }\n                     fe++;\n                     sb.append(START_FE).append(\n                             readArgumentIndex(pattern, next(pos)));\n-                    String customPattern = (String) customPatterns.get(fe);\n+                    String customPattern = customPatterns.get(fe);\n                     if (customPattern != null) {\n                         sb.append(START_FMT).append(customPattern);\n                     }\n      * @param coll to check\n      * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n      */\n-    private boolean containsElements(Collection coll) {\n+    private boolean containsElements(Collection<?> coll) {\n         if (coll == null || coll.size() == 0) {\n             return false;\n         }\n-        for (Iterator iter = coll.iterator(); iter.hasNext();) {\n+        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n             if (iter.next() != null) {\n                 return true;\n             }\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n  * @since 2.2\n  * @version $Id$\n  */\n-public class StrTokenizer implements ListIterator, Cloneable {\n+public class StrTokenizer implements ListIterator<String>, Cloneable {\n \n     private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n     private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n      *\n      * @return the next String token\n      */\n-    public Object next() {\n+    public String next() {\n         if (hasNext()) {\n             return tokens[tokenPos++];\n         }\n      *\n      * @return the previous token\n      */\n-    public Object previous() {\n+    public String previous() {\n         if (hasPrevious()) {\n             return tokens[--tokenPos];\n         }\n      * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n-    public void set(Object obj) {\n+    public void set(String obj) {\n         throw new UnsupportedOperationException(\"set() is unsupported\");\n     }\n \n      * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n-    public void add(Object obj) {\n+    public void add(String obj) {\n         throw new UnsupportedOperationException(\"add() is unsupported\");\n     }\n \n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n      * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n      * @return the parsed date\n      * @throws IllegalArgumentException if the date string or pattern array is null\n-     * @throws ParseException if none of the date patterns were suitable\n+     * @throws ParseException if none of the date patterns were suitable (or there were none)\n      */\n     public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n         if (str == null || parsePatterns == null) {\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws IllegalArgumentException if the rangeStyle is invalid\n      */\n-    public static Iterator iterator(Date focus, int rangeStyle) {\n+    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws IllegalArgumentException if the rangeStyle is invalid\n      */\n-    public static Iterator iterator(Calendar focus, int rangeStyle) {\n+    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ClassCastException if the object type is\n      *  not a <code>Date</code> or <code>Calendar</code>\n      */\n-    public static Iterator iterator(Object focus, int rangeStyle) {\n+    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n     /**\n      * <p>Date iterator.</p>\n      */\n-    static class DateIterator implements Iterator {\n+    static class DateIterator implements Iterator<Calendar> {\n         private final Calendar endFinal;\n         private final Calendar spot;\n         \n          *\n          * @return Object calendar for the next date\n          */\n-        public Object next() {\n+        public Calendar next() {\n             if (spot.equals(endFinal)) {\n                 throw new NoSuchElementException();\n             }\n             spot.add(Calendar.DATE, 1);\n-            return spot.clone();\n+            return (Calendar) spot.clone();\n         }\n \n         /**\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n      * Parses a classic date format string into Tokens\n      *\n      * @param format to parse\n-     * @return Token[] of tokens\n+     * @return array of Token[]\n      */\n     static Token[] lexx(String format) {\n         char[] array = format.toCharArray();\n-        ArrayList list = new ArrayList(array.length);\n+        ArrayList<Token> list = new ArrayList<Token>(array.length);\n \n         boolean inLiteral = false;\n         StringBuffer buffer = null;\n         for(int i=0; i<sz; i++) {\n             char ch = array[i];\n             if(inLiteral && ch != '\\'') {\n-                buffer.append(ch);\n+                buffer.append(ch); // buffer can't be null if inLiteral is true\n                 continue;\n             }\n             Object value = null;\n                 buffer = null; \n             }\n         }\n-        return (Token[]) list.toArray( new Token[list.size()] );\n+        return list.toArray( new Token[list.size()] );\n     }\n \n     /**", "timestamp": 1237169498, "metainfo": ""}