{"sha": "47afef0fc4b3bb6416da5fb765ca218f98c48eab", "log": "[LANG-560] Added TimedSemaphore class to concurrent package.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * <p>\n+ * A specialized <em>semaphore</em> implementation that provides a number of\n+ * permits in a given time frame.\n+ * </p>\n+ * <p>\n+ * This class is similar to the {@code java.util.concurrent.Semaphore} class\n+ * provided by the JDK in that it manages a configurable number of permits.\n+ * Using the {@link #acquire()} method a permit can be requested by a thread.\n+ * However, there is an additional timing dimension: there is no {@code\n+ * release()} method for freeing a permit, but all permits are automatically\n+ * released at the end of a configurable time frame. If a thread calls\n+ * {@link #acquire()} and the available permits are already exhausted for this\n+ * time frame, the thread is blocked. When the time frame ends all permits\n+ * requested so far are restored, and blocking threads are waked up again, so\n+ * that they can try to acquire a new permit. This basically means that in the\n+ * specified time frame only the given number of operations is possible.\n+ * </p>\n+ * <p>\n+ * A use case for this class is to artificially limit the load produced by a\n+ * process. As an example consider an application that issues database queries\n+ * on a production system in a background process to gather statistical\n+ * information. This background processing should not produce so much database\n+ * load that the functionality and the performance of the production system are\n+ * impacted. Here a {@code TimedSemaphore} could be installed to guarantee that\n+ * only a given number of database queries are issued per second.\n+ * </p>\n+ * <p>\n+ * A thread class for performing database queries could look as follows:\n+ *\n+ * <pre>\n+ * public class StatisticsThread extends Thread {\n+ *     // The semaphore for limiting database load.\n+ *     private final TimedSemaphore semaphore;\n+ *     // Create an instance and set the semaphore\n+ *     public StatisticsThread(TimedSemaphore timedSemaphore) {\n+ *         semaphore = timedSemaphore;\n+ *     }\n+ *     // Gather statistics\n+ *     public void run() {\n+ *         try {\n+ *             while(true) {\n+ *                 semaphore.acquire();   // limit database load\n+ *                 performQuery();        // issue a query\n+ *             }\n+ *         } catch(InterruptedException) {\n+ *             // fall through\n+ *         }\n+ *     }\n+ *     ...\n+ * }\n+ * </pre>\n+ *\n+ * The following code fragment shows how a {@code TimedSemaphore} is created\n+ * that allows only 10 operations per second and passed to the statistics\n+ * thread:\n+ *\n+ * <pre>\n+ * TimedSemaphore sem = new TimedSemaphore(1, TimeUnit.SECOND, 10);\n+ * StatisticsThread thread = new StatisticsThread(sem);\n+ * thread.start();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * When creating an instance the time period for the semaphore must be\n+ * specified. {@code TimedSemaphore} uses an executor service with a\n+ * corresponding period to monitor this interval. The {@code\n+ * ScheduledExecutorService} to be used for this purpose can be provided at\n+ * construction time. Alternatively the class creates an internal executor\n+ * service.\n+ * </p>\n+ * <p>\n+ * Client code that uses {@code TimedSemaphore} has to call the\n+ * {@link #acquire()} method in aach processing step. {@code TimedSemaphore}\n+ * keeps track of the number of invocations of the {@link #acquire()} method and\n+ * blocks the calling thread if the counter exceeds the limit specified. When\n+ * the timer signals the end of the time period the counter is reset and all\n+ * waiting threads are released. Then another cycle can start.\n+ * </p>\n+ * <p>\n+ * It is possible to modify the limit at any time using the\n+ * {@link #setLimit(int)} method. This is useful if the load produced by an\n+ * operation has to be adapted dynamically. In the example scenario with the\n+ * thread collecting statistics it may make sense to specify a low limit during\n+ * day time while allowing a higher load in the night time. Reducing the limit\n+ * takes effect immediately by blocking incoming callers. If the limit is\n+ * increased, waiting threads are not released immediately, but wake up when the\n+ * timer runs out. Then, in the next period more processing steps can be\n+ * performed without blocking. By setting the limit to 0 the semaphore can be\n+ * switched off: in this mode the {@link #acquire()} method never blocks, but\n+ * lets all callers pass directly.\n+ * </p>\n+ * <p>\n+ * When the {@code TimedSemaphore} is no more needed its {@link #shutdown()}\n+ * method should be called. This causes the periodic task that monitors the time\n+ * interval to be canceled. If the {@code ScheduledExecutorService} has been\n+ * created by the semaphore at construction time, it is also shut down.\n+ * resources. After that {@link #acquire()} must not be called any more.\n+ * </p>\n+ *\n+ * @version $Id:$\n+ */\n+public class TimedSemaphore {\n+    /**\n+     * Constant for a value representing no limit. If the limit is set to a\n+     * value less or equal this constant, the {@code TimedSemaphore} will be\n+     * effectively switched off.\n+     */\n+    public static final int NO_LIMIT = 0;\n+\n+    /** Constant for the thread pool size for the executor. */\n+    private static final int THREAD_POOL_SIZE = 1;\n+\n+    /** The executor service for managing the timer thread. */\n+    private final ScheduledExecutorService executorService;\n+\n+    /** Stores the period for this timed semaphore. */\n+    private final long period;\n+\n+    /** The time unit for the period. */\n+    private final TimeUnit unit;\n+\n+    /** A flag whether the executor service was created by this object. */\n+    private final boolean ownExecutor;\n+\n+    /** A future object representing the timer task. */\n+    private ScheduledFuture<?> task;\n+\n+    /** Stores the total number of invocations of the acquire() method. */\n+    private long totalAcquireCount;\n+\n+    /**\n+     * The counter for the periods. This counter is increased every time a\n+     * period ends.\n+     */\n+    private long periodCount;\n+\n+    /** The limit. */\n+    private int limit;\n+\n+    /** The current counter. */\n+    private int acquireCount;\n+\n+    /** The number of invocations of acquire() in the last period. */\n+    private int lastCallsPerPeriod;\n+\n+    /** A flag whether shutdown() was called. */\n+    private boolean shutdown;\n+\n+    /**\n+     * Creates a new instance of {@link TimedSemaphore} and initializes it with\n+     * the given time period and the limit.\n+     *\n+     * @param timePeriod the time period\n+     * @param timeUnit the unit for the period\n+     * @param limit the limit for the semaphore\n+     * @throws IllegalArgumentException if the period is less or equals 0\n+     */\n+    public TimedSemaphore(long timePeriod, TimeUnit timeUnit, int limit) {\n+        this(null, timePeriod, timeUnit, limit);\n+    }\n+\n+    /**\n+     * Creates a new instance of {@link TimedSemaphore} and initializes it with\n+     * an executor service, the given time period, and the limit. The executor\n+     * service will be used for creating a periodic task for monitoring the time\n+     * period. It can be <b>null</b>, then a default service will be created.\n+     *\n+     * @param service the executor service\n+     * @param timePeriod the time period\n+     * @param timeUnit the unit for the period\n+     * @param limit the limit for the semaphore\n+     * @throws IllegalArgumentException if the period is less or equals 0\n+     */\n+    public TimedSemaphore(ScheduledExecutorService service, long timePeriod,\n+            TimeUnit timeUnit, int limit) {\n+        if (timePeriod <= 0) {\n+            throw new IllegalArgumentException(\"Time period must be greater 0!\");\n+        }\n+\n+        period = timePeriod;\n+        unit = timeUnit;\n+\n+        if (service != null) {\n+            executorService = service;\n+            ownExecutor = false;\n+        } else {\n+            ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(\n+                    THREAD_POOL_SIZE);\n+            s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n+            s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+            executorService = s;\n+            ownExecutor = true;\n+        }\n+\n+        setLimit(limit);\n+    }\n+\n+    /**\n+     * Returns the limit enforced by this semaphore. The limit determines how\n+     * many invocations of {@link #acquire()} are allowed within the monitored\n+     * period.\n+     *\n+     * @return the limit\n+     */\n+    public final synchronized int getLimit() {\n+        return limit;\n+    }\n+\n+    /**\n+     * Sets the limit. This is the number of times the {@link #acquire()} method\n+     * can be called within the time period specified. If this limit is reached,\n+     * further invocations of {@link #acquire()} will block. Setting the limit\n+     * to a value &lt;= {@link #NO_LIMIT} will cause the limit to be disabled,\n+     * i.e. an arbitrary number of{@link #acquire()} invocations is allowed in\n+     * the time period.\n+     *\n+     * @param limit the limit\n+     */\n+    public final synchronized void setLimit(int limit) {\n+        this.limit = limit;\n+    }\n+\n+    /**\n+     * Initializes a shutdown. After that the object cannot be used any more.\n+     * This method can be invoked an arbitrary number of times. All invocations\n+     * after the first one do not have any effect.\n+     */\n+    public synchronized void shutdown() {\n+        if (!shutdown) {\n+\n+            if (ownExecutor) {\n+                // if the executor was created by this instance, it has\n+                // to be shutdown\n+                getExecutorService().shutdownNow();\n+            }\n+            if (task != null) {\n+                task.cancel(false);\n+            }\n+\n+            shutdown = true;\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the {@link #shutdown()} method has been called on this\n+     * object. If this method returns <b>true</b>, this instance cannot be used\n+     * any longer.\n+     *\n+     * @return a flag whether a shutdown has been performed\n+     */\n+    public synchronized boolean isShutdown() {\n+        return shutdown;\n+    }\n+\n+    /**\n+     * Tries to acquire a permit from this semaphore. This method will block if\n+     * the limit for the current period has already been reached. If\n+     * {@link #shutdown()} has already been invoked, calling this method will\n+     * cause an exception. The very first call of this method starts the timer\n+     * task which monitors the time period set for this {@code TimedSemaphore}.\n+     * From now on the semaphore is active.\n+     *\n+     * @throws InterruptedException if the thread gets interrupted\n+     * @throws IllegalStateException if this semaphore is already shut down\n+     */\n+    public synchronized void acquire() throws InterruptedException {\n+        if (isShutdown()) {\n+            throw new IllegalStateException(\"TimedSemaphore is shut down!\");\n+        }\n+\n+        if (task == null) {\n+            task = startTimer();\n+        }\n+\n+        boolean canPass = false;\n+        do {\n+            canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();\n+            if (!canPass) {\n+                wait();\n+            } else {\n+                acquireCount++;\n+            }\n+        } while (!canPass);\n+    }\n+\n+    /**\n+     * Returns the number of (successful) acquire invocations during the last\n+     * period. This is the number of times the {@link #acquire()} method was\n+     * called without blocking. This can be useful for testing or debugging\n+     * purposes or to determine a meaningful threshold value. If a limit is set,\n+     * the value returned by this method won't be greater than this limit.\n+     *\n+     * @return the number of non-blocking invocations of the {@link #acquire()}\n+     * method\n+     */\n+    public synchronized int getLastAcquiresPerPeriod() {\n+        return lastCallsPerPeriod;\n+    }\n+\n+    /**\n+     * Returns the number of invocations of the {@link #acquire()} method for\n+     * the current period. This may be useful for testing or debugging purposes.\n+     *\n+     * @return the current number of {@link #acquire()} invocations\n+     */\n+    public synchronized int getAcquireCount() {\n+        return acquireCount;\n+    }\n+\n+    /**\n+     * Returns the number of calls to the {@link #acquire()} method that can\n+     * still be performed in the current period without blocking. This method\n+     * can give an indication whether it is safe to call the {@link #acquire()}\n+     * method without risking to be suspended. However, there is no guarantee\n+     * that a subsequent call to {@link #acquire()} actually is not-blocking\n+     * because in the mean time other threads may have invoked the semaphore.\n+     *\n+     * @return the current number of available {@link #acquire()} calls in the\n+     * current period\n+     */\n+    public synchronized int getAvailablePermits() {\n+        return getLimit() - getAcquireCount();\n+    }\n+\n+    /**\n+     * Returns the average number of successful (i.e. non-blocking)\n+     * {@link #acquire()} invocations for the entire life-time of this {@code\n+     * TimedSemaphore}. This method can be used for instance for statistical\n+     * calculations.\n+     *\n+     * @return the average number of {@link #acquire()} invocations per time\n+     * unit\n+     */\n+    public synchronized double getAverageCallsPerPeriod() {\n+        return (periodCount == 0) ? 0 : (double) totalAcquireCount\n+                / (double) periodCount;\n+    }\n+\n+    /**\n+     * Returns the time period. This is the time monitored by this semaphore.\n+     * Only a given number of invocations of the {@link #acquire()} method is\n+     * possible in this period.\n+     *\n+     * @return the time period\n+     */\n+    public long getPeriod() {\n+        return period;\n+    }\n+\n+    /**\n+     * Returns the time unit. This is the unit used by {@link #getPeriod()}.\n+     *\n+     * @return the time unit\n+     */\n+    public TimeUnit getUnit() {\n+        return unit;\n+    }\n+\n+    /**\n+     * Returns the executor service used by this instance.\n+     *\n+     * @return the executor service\n+     */\n+    protected ScheduledExecutorService getExecutorService() {\n+        return executorService;\n+    }\n+\n+    /**\n+     * Starts the timer. This method is called when {@link #acquire()} is called\n+     * for the first time. It schedules a task to be executed at fixed rate to\n+     * monitor the time period specified.\n+     *\n+     * @return a future object representing the task scheduled\n+     */\n+    protected ScheduledFuture<?> startTimer() {\n+        return getExecutorService().scheduleAtFixedRate(new Runnable() {\n+            public void run() {\n+                endOfPeriod();\n+            }\n+        }, getPeriod(), getPeriod(), getUnit());\n+    }\n+\n+    /**\n+     * The current time period is finished. This method is called by the timer\n+     * used internally to monitor the time period. It resets the counter and\n+     * releases the threads waiting for this barrier.\n+     */\n+    synchronized void endOfPeriod() {\n+        lastCallsPerPeriod = acquireCount;\n+        totalAcquireCount += acquireCount;\n+        periodCount++;\n+        acquireCount = 0;\n+        notifyAll();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.lang3.concurrent.TimedSemaphore;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for TimedSemaphore.\n+ *\n+ * @version $Id$\n+ */\n+public class TimedSemaphoreTest {\n+    /** Constant for the time period. */\n+    private static final long PERIOD = 500;\n+\n+    /** Constant for the time unit. */\n+    private static final TimeUnit UNIT = TimeUnit.MILLISECONDS;\n+\n+    /** Constant for the default limit. */\n+    private static final int LIMIT = 10;\n+\n+    /**\n+     * Tests creating a new instance.\n+     */\n+    @Test\n+    public void testInit() {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        EasyMock.replay(service);\n+        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+                LIMIT);\n+        EasyMock.verify(service);\n+        assertEquals(\"Wrong service\", service, semaphore.getExecutorService());\n+        assertEquals(\"Wrong period\", PERIOD, semaphore.getPeriod());\n+        assertEquals(\"Wrong unit\", UNIT, semaphore.getUnit());\n+        assertEquals(\"Statistic available\", 0, semaphore\n+                .getLastAcquiresPerPeriod());\n+        assertEquals(\"Average available\", 0.0, semaphore\n+                .getAverageCallsPerPeriod(), .05);\n+        assertFalse(\"Already shutdown\", semaphore.isShutdown());\n+        assertEquals(\"Wrong limit\", LIMIT, semaphore.getLimit());\n+    }\n+\n+    /**\n+     * Tries to create an instance with a negative period. This should cause an\n+     * exception.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInitInvalidPeriod() {\n+        new TimedSemaphore(0L, UNIT, LIMIT);\n+    }\n+\n+    /**\n+     * Tests whether a default executor service is created if no service is\n+     * provided.\n+     */\n+    @Test\n+    public void testInitDefaultService() {\n+        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore\n+                .getExecutorService();\n+        assertFalse(\"Wrong periodic task policy\", exec\n+                .getContinueExistingPeriodicTasksAfterShutdownPolicy());\n+        assertFalse(\"Wrong delayed task policy\", exec\n+                .getExecuteExistingDelayedTasksAfterShutdownPolicy());\n+        assertFalse(\"Already shutdown\", exec.isShutdown());\n+        semaphore.shutdown();\n+    }\n+\n+    /**\n+     * Tests starting the timer.\n+     */\n+    @Test\n+    public void testStartTimer() throws InterruptedException {\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD,\n+                UNIT, LIMIT);\n+        ScheduledFuture<?> future = semaphore.startTimer();\n+        assertNotNull(\"No future returned\", future);\n+        Thread.sleep(PERIOD);\n+        final int trials = 10;\n+        int count = 0;\n+        do {\n+            Thread.sleep(PERIOD);\n+            if (count++ > trials) {\n+                fail(\"endOfPeriod() not called!\");\n+            }\n+        } while (semaphore.getPeriodEnds() <= 0);\n+        semaphore.shutdown();\n+    }\n+\n+    /**\n+     * Tests the shutdown() method if the executor belongs to the semaphore. In\n+     * this case it has to be shut down.\n+     */\n+    @Test\n+    public void testShutdownOwnExecutor() {\n+        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        semaphore.shutdown();\n+        assertTrue(\"Not shutdown\", semaphore.isShutdown());\n+        assertTrue(\"Executor not shutdown\", semaphore.getExecutorService()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Tests the shutdown() method for a shared executor service before a task\n+     * was started. This should do pretty much nothing.\n+     */\n+    @Test\n+    public void testShutdownSharedExecutorNoTask() {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        EasyMock.replay(service);\n+        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+                LIMIT);\n+        semaphore.shutdown();\n+        assertTrue(\"Not shutdown\", semaphore.isShutdown());\n+        EasyMock.verify(service);\n+    }\n+\n+    /**\n+     * Prepares an executor service mock to expect the start of the timer.\n+     *\n+     * @param service the mock\n+     * @param future the future\n+     */\n+    private void prepareStartTimer(ScheduledExecutorService service,\n+            ScheduledFuture<?> future) {\n+        service.scheduleAtFixedRate((Runnable) EasyMock.anyObject(), EasyMock\n+                .eq(PERIOD), EasyMock.eq(PERIOD), EasyMock.eq(UNIT));\n+        EasyMock.expectLastCall().andReturn(future);\n+    }\n+\n+    /**\n+     * Tests the shutdown() method for a shared executor after the task was\n+     * started. In this case the task must be canceled.\n+     */\n+    @Test\n+    public void testShutdownSharedExecutorTask() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.expect(future.cancel(false)).andReturn(true);\n+        EasyMock.replay(service, future);\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+                PERIOD, UNIT, LIMIT);\n+        semaphore.acquire();\n+        semaphore.shutdown();\n+        assertTrue(\"Not shutdown\", semaphore.isShutdown());\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tests multiple invocations of the shutdown() method.\n+     */\n+    @Test\n+    public void testShutdownMultipleTimes() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.expect(future.cancel(false)).andReturn(true);\n+        EasyMock.replay(service, future);\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+                PERIOD, UNIT, LIMIT);\n+        semaphore.acquire();\n+        for (int i = 0; i < 10; i++) {\n+            semaphore.shutdown();\n+        }\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tests the acquire() method if a limit is set.\n+     */\n+    @Test\n+    public void testAcquireLimit() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        final int count = 10;\n+        CountDownLatch latch = new CountDownLatch(count - 1);\n+        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1);\n+        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count,\n+                count - 1);\n+        semaphore.setLimit(count - 1);\n+\n+        // start a thread that calls the semaphore count times\n+        t.start();\n+        latch.await();\n+        // now the semaphore's limit should be reached and the thread blocked\n+        assertEquals(\"Wrong semaphore count\", count - 1, semaphore\n+                .getAcquireCount());\n+\n+        // this wakes up the thread, it should call the semaphore once more\n+        semaphore.endOfPeriod();\n+        t.join();\n+        assertEquals(\"Wrong semaphore count (2)\", 1, semaphore\n+                .getAcquireCount());\n+        assertEquals(\"Wrong acquire() count\", count - 1, semaphore\n+                .getLastAcquiresPerPeriod());\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tests the acquire() method if more threads are involved than the limit.\n+     * This method starts a number of threads that all invoke the semaphore. The\n+     * semaphore's limit is set to 1, so in each period only a single thread can\n+     * acquire the semaphore.\n+     */\n+    @Test\n+    public void testAcquireMultipleThreads() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+                PERIOD, UNIT, 1);\n+        semaphore.latch = new CountDownLatch(1);\n+        final int count = 10;\n+        SemaphoreThread[] threads = new SemaphoreThread[count];\n+        for (int i = 0; i < count; i++) {\n+            threads[i] = new SemaphoreThread(semaphore, null, 1, 0);\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < count; i++) {\n+            semaphore.latch.await();\n+            assertEquals(\"Wrong count\", 1, semaphore.getAcquireCount());\n+            semaphore.latch = new CountDownLatch(1);\n+            semaphore.endOfPeriod();\n+            assertEquals(\"Wrong acquire count\", 1, semaphore\n+                    .getLastAcquiresPerPeriod());\n+        }\n+        for (int i = 0; i < count; i++) {\n+            threads[i].join();\n+        }\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tests the acquire() method if no limit is set. A test thread is started\n+     * that calls the semaphore a large number of times. Even if the semaphore's\n+     * period does not end, the thread should never block.\n+     */\n+    @Test\n+    public void testAcquireNoLimit() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+                PERIOD, UNIT, TimedSemaphore.NO_LIMIT);\n+        final int count = 1000;\n+        CountDownLatch latch = new CountDownLatch(count);\n+        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n+        t.start();\n+        latch.await();\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tries to call acquire() after shutdown(). This should cause an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testPassAfterShutdown() throws InterruptedException {\n+        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        semaphore.shutdown();\n+        semaphore.acquire();\n+    }\n+\n+    /**\n+     * Tests a bigger number of invocations that span multiple periods. The\n+     * period is set to a very short time. A background thread calls the\n+     * semaphore a large number of times. While it runs at last one end of a\n+     * period should be reached.\n+     */\n+    @Test\n+    public void testAcquireMultiplePeriods() throws InterruptedException {\n+        final int count = 1000;\n+        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(\n+                PERIOD / 10, TimeUnit.MILLISECONDS, 1);\n+        semaphore.setLimit(count / 4);\n+        CountDownLatch latch = new CountDownLatch(count);\n+        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n+        t.start();\n+        latch.await();\n+        semaphore.shutdown();\n+        assertTrue(\"End of period not reached\", semaphore.getPeriodEnds() > 0);\n+    }\n+\n+    /**\n+     * Tests the methods for statistics.\n+     */\n+    @Test\n+    public void testGetAverageCallsPerPeriod() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+                LIMIT);\n+        semaphore.acquire();\n+        semaphore.endOfPeriod();\n+        assertEquals(\"Wrong average (1)\", 1.0, semaphore\n+                .getAverageCallsPerPeriod(), .005);\n+        semaphore.acquire();\n+        semaphore.acquire();\n+        semaphore.endOfPeriod();\n+        assertEquals(\"Wrong average (2)\", 1.5, semaphore\n+                .getAverageCallsPerPeriod(), .005);\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * Tests whether the available non-blocking calls can be queried.\n+     */\n+    @Test\n+    public void testGetAvailablePermits() throws InterruptedException {\n+        ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+                LIMIT);\n+        for (int i = 0; i < LIMIT; i++) {\n+            assertEquals(\"Wrong available count at \" + i, LIMIT - i, semaphore\n+                    .getAvailablePermits());\n+            semaphore.acquire();\n+        }\n+        semaphore.endOfPeriod();\n+        assertEquals(\"Wrong available count in new period\", LIMIT, semaphore\n+                .getAvailablePermits());\n+        EasyMock.verify(service, future);\n+    }\n+\n+    /**\n+     * A specialized implementation of {@code TimedSemaphore} that is easier to\n+     * test.\n+     */\n+    private static class TimedSemaphoreTestImpl extends TimedSemaphore {\n+        /** A mock scheduled future. */\n+        ScheduledFuture<?> schedFuture;\n+\n+        /** A latch for synchronizing with the main thread. */\n+        volatile CountDownLatch latch;\n+\n+        /** Counter for the endOfPeriod() invocations. */\n+        private int periodEnds;\n+\n+        public TimedSemaphoreTestImpl(long timePeriod, TimeUnit timeUnit,\n+                int limit) {\n+            super(timePeriod, timeUnit, limit);\n+        }\n+\n+        public TimedSemaphoreTestImpl(ScheduledExecutorService service,\n+                long timePeriod, TimeUnit timeUnit, int limit) {\n+            super(service, timePeriod, timeUnit, limit);\n+        }\n+\n+        /**\n+         * Returns the number of invocations of the endOfPeriod() method.\n+         *\n+         * @return the endOfPeriod() invocations\n+         */\n+        public int getPeriodEnds() {\n+            synchronized (this) {\n+                return periodEnds;\n+            }\n+        }\n+\n+        /**\n+         * Invokes the latch if one is set.\n+         */\n+        @Override\n+        public void acquire() throws InterruptedException {\n+            super.acquire();\n+            if (latch != null) {\n+                latch.countDown();\n+            }\n+        }\n+\n+        /**\n+         * Counts the number of invocations.\n+         */\n+        @Override\n+        protected void endOfPeriod() {\n+            super.endOfPeriod();\n+            synchronized (this) {\n+                periodEnds++;\n+            }\n+        }\n+\n+        /**\n+         * Either returns the mock future or calls the super method.\n+         */\n+        @Override\n+        protected ScheduledFuture<?> startTimer() {\n+            return (schedFuture != null) ? schedFuture : super.startTimer();\n+        }\n+    }\n+\n+    /**\n+     * A test thread class that will be used by tests for triggering the\n+     * semaphore. The thread calls the semaphore a configurable number of times.\n+     * When this is done, it can notify the main thread.\n+     */\n+    private static class SemaphoreThread extends Thread {\n+        /** The semaphore. */\n+        private final TimedSemaphore semaphore;\n+\n+        /** A latch for communication with the main thread. */\n+        private final CountDownLatch latch;\n+\n+        /** The number of acquire() calls. */\n+        private final int count;\n+\n+        /** The number of invocations of the latch. */\n+        private final int latchCount;\n+\n+        public SemaphoreThread(TimedSemaphore b, CountDownLatch l, int c, int lc) {\n+            semaphore = b;\n+            latch = l;\n+            count = c;\n+            latchCount = lc;\n+        }\n+\n+        /**\n+         * Calls acquire() on the semaphore for the specified number of times.\n+         * Optionally the latch will also be triggered to synchronize with the\n+         * main test thread.\n+         */\n+        @Override\n+        public void run() {\n+            try {\n+                for (int i = 0; i < count; i++) {\n+                    semaphore.acquire();\n+\n+                    if (i < latchCount) {\n+                        latch.countDown();\n+                    }\n+                }\n+            } catch (InterruptedException iex) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+}", "timestamp": 1262545448, "metainfo": ""}