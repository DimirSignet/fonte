{"sha": "e98fff0e3db77e77a3b71cfe37343d25e5d7f715", "log": "Adding parseDateStrictly method per LANG-486  ", "commit": "\n--- a/src/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang3/time/DateUtils.java\n      * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n      * \n      * <p>The parse will try each parse pattern in turn.\n-     * A parse is only deemed sucessful if it parses the whole of the input string.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n      * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser will be lenient toward the parsed date.\n      * \n      * @param str  the date to parse, not null\n      * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n      * @throws ParseException if none of the date patterns were suitable (or there were none)\n      */\n     public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, parsePatterns, true);\n+    }\n+    \n+  //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser parses strictly - it does not allow for dates such as \"February 942, 1996\". \n+     * \n+     * @param str  the date to parse, not null\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @param lenient Specify whether or not date/time parsing is to be lenient.\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable\n+     * @see java.util.Calender#isLenient()\n+     */\n+    public static Date parseDateStrictly(String str, String[] parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, parsePatterns, false);\n+    }\n+    private static Date parseDateWithLeniency(String str, String[] parsePatterns,\n+\t\t\tboolean lenient) throws ParseException {\n         if (str == null || parsePatterns == null) {\n             throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n         }\n             \n             if (i == 0) {\n                 parser = new SimpleDateFormat(pattern);\n+                parser.setLenient(lenient);\n             } else {\n                 parser.applyPattern(pattern); // cannot be null if i != 0\n             }\n--- a/src/test/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/org/apache/commons/lang3/time/DateUtilsTest.java\n         } catch (IllegalArgumentException ex) {}\n         try {\n             DateUtils.parseDate(dateStr, new String[0]);\n+            fail();\n+        } catch (ParseException ex) {}\n+    }\n+    // LANG-486\n+    public void testParseDateWithLeniency() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1998, 6, 30);\n+        String dateStr = \"February 942, 1996\";\n+        String[] parsers = new String[] {\"MMMMM DDD, yyyy\"};\n+        \n+        Date date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        try {\n+            date = DateUtils.parseDateStrictly(dateStr, parsers);\n             fail();\n         } catch (ParseException ex) {}\n     }", "timestamp": 1262372478, "metainfo": ""}