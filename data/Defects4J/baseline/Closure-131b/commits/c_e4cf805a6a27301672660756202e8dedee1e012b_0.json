{"sha": "e4cf805a6a27301672660756202e8dedee1e012b", "log": "Avoid unnecessary temporary objects when comparing node trees.  R=acleung DELTA=64  (17 added, 22 deleted, 25 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=762   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstChangeProxy.java\n+++ b/src/com/google/javascript/jscomp/AstChangeProxy.java\n \n     int size = replacements.size();\n \n-    if ((size == 1) && node.checkTreeEqualsSilent(replacements.get(0))) {\n+    if ((size == 1) && node.isEquivalentTo(replacements.get(0))) {\n       // trees are equal... don't replace\n       return;\n     }\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n \n           default:\n             if (NodeUtil.isImmutableValue(next)\n-                && next.checkTreeEqualsSilent(value)) {\n+                && next.isEquivalentTo(value)) {\n               // If the r-value of the expr assign is an immutable value,\n               // and the value is used again shortly, then we can exploit\n               // the assign here.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n         options.disambiguateProperties) {\n       // The type based optimizations require that type information is preserved\n       // during other optimizations.\n-      return n1.checkTreeTypeAwareEqualsSilent(n2);\n+      return n1.isEquivalentToTyped(n2);\n     } else {\n-      return n1.checkTreeEqualsSilent(n2);\n+      return n1.isEquivalentTo(n2);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n    */\n   private boolean nodesAreEqual(Node n1, Node n2) {\n     return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&\n-        n1.checkTreeEqualsSilent(n2);\n+        n1.isEquivalentTo(n2);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n    * and the potential replacement are in the same exception handler.\n    */\n   boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n-    return nodeThis.checkTreeEqualsSilent(nodeThat)\n+    return nodeThis.isEquivalentTo(nodeThat)\n         && (!isExceptionPossible(nodeThis)\n             || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n   }\n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n   @Override\n   public boolean equals(Object other) {\n     return other instanceof JSTypeExpression &&\n-        ((JSTypeExpression) other).root.checkTreeEqualsSilent(root);\n+        ((JSTypeExpression) other).root.isEquivalentTo(root);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     }\n \n     @Override\n-    boolean isEquivalentTo(Node node, boolean recurse) {\n-      return (super.isEquivalentTo(node, recurse)\n+    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n+      return (super.isEquivalentTo(node, compareJsType, recurse)\n           && getDouble() == ((NumberNode) node).getDouble());\n     }\n \n     }\n \n     @Override\n-    boolean isEquivalentTo(Node node, boolean recurse) {\n-      return (super.isEquivalentTo(node, recurse)\n+    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n+      return (super.isEquivalentTo(node, compareJsType, recurse)\n           && this.str.equals(((StringNode) node).str));\n     }\n \n   }\n \n   /**\n-   * If this is a compilation pass and not a test, do not construct error\n-   * strings. Instead return true if the trees are equal.\n-   */\n-  public boolean checkTreeEqualsSilent(Node node2) {\n-    return checkTreeEqualsImpl(node2) == null;\n-  }\n-\n-  /**\n    * Helper function to ignore differences in Node subclasses that are no longer\n    * used.\n    */\n    * testing. Returns null if the nodes are equivalent.\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n-    if (!isEquivalentTo(node2, false)) {\n+    if (!isEquivalentTo(node2, false, false)) {\n       return new NodeMismatch(this, node2);\n     }\n \n   }\n \n   /**\n-   * Checks if the subtree under this node is the same as another subtree\n-   * including types. Returns null if it's equal, or a message describing the\n-   * differences.\n-   */\n-  public boolean checkTreeTypeAwareEqualsSilent(Node node2) {\n-    return checkTreeTypeAwareEqualsImpl(node2) == null;\n-  }\n-\n-  /**\n    * Compare this node to node2 recursively and return the first pair of nodes\n    * that differs doing a preorder depth-first traversal. Package private for\n    * testing. Returns null if the nodes are equivalent.\n    */\n   NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) {\n     // Do a non-recursive equivalents check.\n-    boolean eq = this.isEquivalentTo(node2, false);\n-\n-    eq = eq && JSType.isEquivalent(jsType, node2.getJSType());\n-\n-    if (!eq) {\n+    if (!isEquivalentTo(node2, true, false)) {\n       return new NodeMismatch(this, node2);\n     }\n \n \n   /** Returns true if this node is equivalent semantically to another */\n   public boolean isEquivalentTo(Node node) {\n-    return isEquivalentTo(node, true);\n-  }\n-\n-  /** Returns true if this node is equivalent semantically to another */\n-  boolean isEquivalentTo(Node node, boolean recurse) {\n+    return isEquivalentTo(node, false, true);\n+  }\n+\n+  /**\n+   * Returns true if this node is equivalent semantically to another and\n+   * the types are equivalent.\n+   */\n+  public boolean isEquivalentToTyped(Node node) {\n+    return isEquivalentTo(node, true, true);\n+  }\n+\n+  /**\n+   * @param compareJsType Whether to compare the JSTypes of the nodes.\n+   * @param recurse Whether to compare the children of the current node, if\n+   *    not only the the count of the children are compared.\n+   * @return Whether this node is equivalent semantically to the provided node.\n+   */\n+  boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n     if (type != node.getType()\n         || getChildCount() != node.getChildCount()\n         || getNodeClass(this) != getNodeClass(node)) {\n+      return false;\n+    }\n+\n+    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n       return false;\n     }\n \n       for (n = first, n2 = node.first;\n            n != null;\n            n = n.next, n2 = n2.next) {\n-        if (!n.isEquivalentTo(n2, true)) {\n+        if (!n.isEquivalentTo(n2, compareJsType, true)) {\n           return false;\n         }\n       }\n--- a/test/com/google/javascript/jscomp/AstParallelizerTest.java\n+++ b/test/com/google/javascript/jscomp/AstParallelizerTest.java\n     }\n \n     parallelizer.join();\n-    assertTrue(orginal.checkTreeEqualsSilent(root));\n+    assertTrue(orginal.isEquivalentTo(root));\n   }\n \n   private void splitFiles(String[] input) {\n     }\n \n     parallelizer.join();\n-    assertTrue(orginal.checkTreeEqualsSilent(root));\n+    assertTrue(orginal.isEquivalentTo(root));\n   }\n }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n         normalizeActualCode(compiler, externsRootClone, mainRootClone);\n       }\n \n-      boolean codeChange = !mainRootClone.checkTreeEqualsSilent(mainRoot);\n-      boolean externsChange = !externsRootClone\n-          .checkTreeEqualsSilent(externsRoot);\n+      boolean codeChange = !mainRootClone.isEquivalentTo(mainRoot);\n+      boolean externsChange = !externsRootClone.isEquivalentTo(externsRoot);\n \n       // Generally, externs should not be change by the compiler passes.\n       if (externsChange && !allowExternsChanges) {", "timestamp": 1299200672, "metainfo": ""}