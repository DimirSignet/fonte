{"sha": "75a9013e3907e5db97f10578227497d7b018caf5", "log": "made checkVariableReferences hot-swappable and to do this added the functionality to keep lists of all global var references in Compiler  R=nicksantos DELTA=478  (417 added, 8 deleted, 53 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1999   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Supplier;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.util.List;\n+import java.util.Map;\n \n /**\n  * An abstract compiler, to help remove the circular dependency of\n    * Returns the root node of the AST, which includes both externs and source.\n    */\n   abstract Node getRoot();\n+\n+  // TODO(bashir) It would be good to extract a single dumb data object with\n+  // only getters and setters that keeps all global information we keep for a\n+  // compiler instance. Then move some of the functions of this class there.\n+\n+  /**\n+   * Updates the list of references for variables in global scope.\n+   *\n+   * @param refMapPatch Maps each variable to all of its references; may contain\n+   *     references collected from the whole AST or only a SCRIPT sub-tree.\n+   * @param collectionRoot The root of sub-tree in which reference collection\n+   *     has been done. This should either be a SCRIPT node (if collection is\n+   *     done on a single file) or it is assumed that collection is on full AST.\n+   */\n+  abstract void updateGlobalVarReferences(Map<Var, ReferenceCollection>\n+      refMapPatch, Node collectionRoot);\n+\n+  /**\n+   * This can be used to get the list of all references to all global variables\n+   * based on all previous calls to {@code updateGlobalVarReferences}.\n+   *\n+   * @return The reference collection map associated to global scope variable.\n+   */\n+  abstract ReferenceMap getGlobalVarReferences();\n+\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n       Logger.getLogger(\"com.google.javascript.jscomp\");\n \n   private final PrintStream outStream;\n+\n+  private GlobalVarReferenceMap globalRefMap = null;\n \n   /**\n    * Creates a Compiler that reports errors and warnings to its logger.\n   void setHasRegExpGlobalReferences(boolean references) {\n     hasRegExpGlobalReferences = references;\n   }\n+\n+  @Override\n+  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n+      Node collectionRoot) {\n+    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n+        || collectionRoot.getType() == Token.BLOCK);\n+    if (globalRefMap == null) {\n+      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());\n+    }\n+    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n+  }\n+\n+  @Override\n+  ReferenceMap getGlobalVarReferences() {\n+    return globalRefMap;\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Checks that references to variables look reasonable. */\n-  private final PassFactory checkVariableReferences =\n-      new PassFactory(\"checkVariableReferences\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkVariableReferences =\n+      new HotSwapPassFactory(\"checkVariableReferences\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new VariableReferenceCheck(\n           compiler, options.aggressiveVarCheck);\n     }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+/**\n+ * An implementation for {@code ReferenceMap} that is specific to global scope\n+ * and can be used in different passes. In other words instead of relying on\n+ * Var object it relies on the name of the variable. It also supports hot-swap\n+ * update of reference map for a specific script.\n+ *\n+ * @see ReferenceCollectingCallback#exitScope(NodeTraversal)\n+ *\n+ * @author bashir@google.com (Bashir Sadjad)\n+ */\n+class GlobalVarReferenceMap implements ReferenceMap {\n+\n+  private Map<String, ReferenceCollection> refMap = null;\n+\n+  private final Map<String, Integer> inputOrder;\n+\n+  /**\n+   * @param inputs The ordered list of all inputs for the compiler.\n+   */\n+  GlobalVarReferenceMap(List<CompilerInput> inputs) {\n+    inputOrder = Maps.newHashMap();\n+    int ind = 0;\n+    for (CompilerInput input : inputs) {\n+      inputOrder.put(input.getName(), ind);\n+      ind++;\n+    }\n+  }\n+\n+  @Override\n+  public ReferenceCollection getReferences(Var var) {\n+    if (!var.isGlobal()) {\n+      return null;\n+    }\n+    return refMap.get(var.getName());\n+  }\n+\n+  /**\n+   * Resets global var reference map with the new provide map.\n+   *\n+   * @param globalRefMap The reference map result of a\n+   *     {@link ReferenceCollectingCallback} pass collected from the whole AST.\n+   */\n+  private void resetGlobalVarReferences(\n+      Map<Var, ReferenceCollection> globalRefMap) {\n+    refMap = Maps.newHashMap();\n+    for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n+      Var var = entry.getKey();\n+      if (var.isGlobal()) {\n+        refMap.put(var.getName(), entry.getValue());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Updates the internal reference map based on the provided parameters. If\n+   * {@code scriptRoot} is not SCRIPT, it basically replaces the internal map\n+   * with the new one, otherwise it replaces all the information associated to\n+   * the given script.\n+   *\n+   * @param refMapPatch The reference map result of a\n+   *     {@link ReferenceCollectingCallback} pass which might be collected from\n+   *     the whole AST or just a sub-tree associated to a SCRIPT node.\n+   * @param root AST sub-tree root on which reference collection was done.\n+   */\n+  void updateGlobalVarReferences(Map<Var, ReferenceCollection>\n+      refMapPatch, Node root) {\n+    if (refMap == null || root.getType() != Token.SCRIPT) {\n+      resetGlobalVarReferences(refMapPatch);\n+      return;\n+    }\n+    String sourceName = NodeUtil.getSourceName(root);\n+    Preconditions.checkNotNull(sourceName);\n+    // Note there are two assumptions here (i) the order of compiler inputs\n+    // has not changed and (ii) all references are in the order they appear\n+    // in AST (this is enforced in ReferenceCollectionCallback).\n+    removeScriptReferences(sourceName);\n+    for (Entry<Var, ReferenceCollection> entry : refMapPatch.entrySet()) {\n+      Var var = entry.getKey();\n+      if (var.isGlobal()) {\n+        replaceReferences(var.getName(), sourceName, entry.getValue());\n+      }\n+    }\n+  }\n+\n+  private void removeScriptReferences(String sourceName) {\n+    // TODO(bashir): If this is too slow it is not too difficult to make it\n+    // faster with keeping an index for variables accessed in sourceName.\n+    for (ReferenceCollection collection : refMap.values()) {\n+      if (collection == null) {\n+        continue;\n+      }\n+      List<Reference> oldRefs = collection.references;\n+      SourceRefRange range = findSourceRefRange(oldRefs, sourceName);\n+      List<Reference> newRefs = Lists.newArrayList(range.refsBefore());\n+      newRefs.addAll(range.refsAfter());\n+      collection.references = newRefs;\n+    }\n+  }\n+\n+  private void replaceReferences(String varName, String sourceName,\n+      ReferenceCollection newSourceCollection) {\n+    ReferenceCollection combined = new ReferenceCollection();\n+    List<Reference> combinedRefs = combined.references;\n+    ReferenceCollection oldCollection = refMap.get(varName);\n+    refMap.put(varName, combined);\n+    if (oldCollection == null) {\n+      combinedRefs.addAll(newSourceCollection.references);\n+      return;\n+    }\n+    // otherwise replace previous references that are from sourceName\n+    SourceRefRange range = findSourceRefRange(oldCollection.references,\n+        sourceName);\n+    combinedRefs.addAll(range.refsBefore());\n+    combinedRefs.addAll(newSourceCollection.references);\n+    combinedRefs.addAll(range.refsAfter());\n+  }\n+\n+  /**\n+   * Finds the range of references associated to {@code sourceName}. Note that\n+   * even if there is no sourceName references the returned information can be\n+   * used to decide where to insert new sourceName refs.\n+   */\n+  private SourceRefRange findSourceRefRange(List<Reference> refList,\n+      String sourceName) {\n+    // TODO(bashir): We can do binary search here, but since this is fast enough\n+    // right now, we just do a linear search for simplicity.\n+    int lastBefore = -1;\n+    int firstAfter = refList.size();\n+    int index = 0;\n+    int sourceInputOrder = inputOrder.get(sourceName);\n+    for (Reference ref : refList) {\n+      int order = inputOrder.get(ref.getSourceName());\n+      if (order < sourceInputOrder) {\n+        lastBefore = index;\n+      } else if (order > sourceInputOrder) {\n+        firstAfter = index;\n+        break;\n+      }\n+      index++;\n+    }\n+    return new SourceRefRange(refList, lastBefore, firstAfter);\n+  }\n+\n+  private static class SourceRefRange {\n+    private final int lastBefore;\n+    private final int firstAfter;\n+    private final List<Reference> refList;\n+\n+    SourceRefRange(List<Reference> refList, int lastBefore,\n+        int firstAfter) {\n+      this.lastBefore = Math.max(lastBefore, -1);\n+      this.firstAfter = Math.min(firstAfter, refList.size());\n+      this.refList = refList;\n+    }\n+\n+    /** Note that the returned list is backed by {@code refList}! */\n+    List<Reference> refsBefore() {\n+      return refList.subList(0, lastBefore + 1);\n+    }\n+\n+    /** Note that the returned list is backed by {@code refList}! */\n+    List<Reference> refsAfter() {\n+      return refList.subList(firstAfter, refList.size());\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     private final Set<Var> staleVars = Sets.newHashSet();\n \n     @Override\n-    public void afterExitScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {\n+    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n \n             continue;\n         }\n \n-        ReferenceCollection referenceInfo = referenceMap.get(v);\n+        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n \n         if (isInlinableObject(referenceInfo.references)) {\n             // Blacklist the object itself, as well as any other values\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap();\n \n     @Override\n-    public void afterExitScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {\n+    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n       collectAliasCandidates(t, referenceMap);\n       doInlinesForScope(t, referenceMap);\n     }\n      * mark them as aliasing candidates.\n      */\n     private void collectAliasCandidates(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {\n+        ReferenceMap referenceMap) {\n       if (mode != Mode.CONSTANTS_ONLY) {\n         for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n           Var v = it.next();\n-          ReferenceCollection referenceInfo = referenceMap.get(v);\n+          ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n \n           // NOTE(nicksantos): Don't handle variables that are never used.\n           // The tests are much easier to write if you don't, and there's\n      * For all variables in this scope, see if they are only used once.\n      * If it looks safe to do so, inline them.\n      */\n-    private void doInlinesForScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {\n+    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n \n       boolean maybeModifiedArguments =\n           maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n \n-        ReferenceCollection referenceInfo = referenceMap.get(v);\n+        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n \n         // referenceInfo will be null if we're in constants-only mode\n         // and the variable is not a constant.\n     }\n \n     private boolean maybeEscapedOrModifiedArguments(\n-        Scope scope, Map<Var, ReferenceCollection> referenceMap) {\n+        Scope scope, ReferenceMap referenceMap) {\n       if (scope.isLocal()) {\n         Var arguments = scope.getArgumentsVar();\n-        ReferenceCollection refs = referenceMap.get(arguments);\n+        ReferenceCollection refs = referenceMap.getReferences(arguments);\n         if (refs != null && !refs.references.isEmpty()) {\n           for (Reference ref : refs.references) {\n             Node refNode = ref.getNameNode();\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n  *\n  * @author kushal@google.com (Kushal Dave)\n  */\n-class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n+class ReferenceCollectingCallback implements ScopedCallback,\n+    HotSwapCompilerPass {\n \n   /**\n    * Maps a given variable to a collection of references to that name. Note that\n    * Convenience method for running this pass over a tree with this\n    * class as a callback.\n    */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  /**\n+   * Same as process but only runs on a part of AST associated to one script.\n+   */\n+  @Override\n+  public void hotSwapScript(Node scriptRoot) {\n+    NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n   /**\n    */\n   public void exitScope(NodeTraversal t) {\n     blockStack.pop();\n-    behavior.afterExitScope(t, referenceMap);\n+    if (t.getScope().isGlobal()) {\n+      // Update global scope reference lists when we are done with it.\n+      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n+      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n+    } else {\n+      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n+    }\n   }\n \n   /**\n     referenceInfo.add(reference, t, v);\n   }\n \n+  interface ReferenceMap {\n+    ReferenceCollection getReferences(Var var);\n+  }\n+\n+  private static class ReferenceMapWrapper implements ReferenceMap {\n+    private final Map<Var, ReferenceCollection> referenceMap;\n+\n+    public ReferenceMapWrapper(Map<Var, ReferenceCollection> referenceMap) {\n+      this.referenceMap = referenceMap;\n+    }\n+\n+    @Override\n+    public ReferenceCollection getReferences(Var var) {\n+      return referenceMap.get(var);\n+    }\n+  }\n+\n   /**\n    * Way for callers to add specific behavior during traversal that\n    * utilizes the built-up reference information.\n     /**\n      * Called after we finish with a scope.\n      */\n-    void afterExitScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap);\n+    void afterExitScope(NodeTraversal t, ReferenceMap referenceMap);\n   }\n \n   static Behavior DO_NOTHING_BEHAVIOR = new Behavior() {\n     @Override\n-    public void afterExitScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {}\n+    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {}\n   };\n \n   /**\n     }\n \n     /**\n+     * Determines whether this block is equivalent to the very first block that\n+     * is created when reference collection traversal enters global scope. Note\n+     * that when traversing a single script in a hot-swap fashion a new instance\n+     * of {@code BasicBlock} is created.\n+     *\n+     * @return true if this is global scope block.\n+     */\n+    boolean isGlobalScopeBlock() {\n+      return getParent() == null;\n+    }\n+\n+    /**\n      * Determines whether this block is guaranteed to begin executing before\n      * the given block does.\n      */\n         }\n       }\n \n-      return currentBlock == this;\n+      if (currentBlock == this) {\n+        return true;\n+      }\n+      if (isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock()) {\n+        return true;\n+      }\n+      return false;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n-import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n \n /**\n  *\n  * @author kushal@google.com (Kushal Dave)\n  */\n-class VariableReferenceCheck implements CompilerPass {\n+class VariableReferenceCheck implements HotSwapCompilerPass {\n \n   static final DiagnosticType UNDECLARED_REFERENCE = DiagnosticType.warning(\n       \"JSC_REFERENCE_BEFORE_DECLARE\",\n     DiagnosticType.disabled(\"AMBIGUOUS_FUNCTION_DECL\",\n         \"Ambiguous use of a named function: {0}.\");\n \n-  private AbstractCompiler compiler;\n-  private CheckLevel checkLevel;\n+  private final AbstractCompiler compiler;\n+  private final CheckLevel checkLevel;\n \n   // NOTE(nicksantos): It's a lot faster to use a shared Set that\n   // we clear after each method call, because the Set never gets too big.\n-  private Set<BasicBlock> blocksWithDeclarations = Sets.newHashSet();\n+  private final Set<BasicBlock> blocksWithDeclarations = Sets.newHashSet();\n \n   public VariableReferenceCheck(AbstractCompiler compiler,\n       CheckLevel checkLevel) {\n     callback.process(externs, root);\n   }\n \n+  @Override\n+  public void hotSwapScript(Node scriptRoot) {\n+    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n+        compiler, new ReferenceCheckingBehavior());\n+    callback.hotSwapScript(scriptRoot);\n+  }\n+\n   /**\n    * Behavior that checks variables for redeclaration or early references\n    * just after they go out of scope.\n   private class ReferenceCheckingBehavior implements Behavior {\n \n     @Override\n-    public void afterExitScope(NodeTraversal t,\n-        Map<Var, ReferenceCollection> referenceMap) {\n+    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n+      // TODO(bashir) In hot-swap version this means that for global scope we\n+      // only go through all global variables accessed in the modified file not\n+      // all global variables. This should be fixed.\n \n       // Check all vars after finishing a scope\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n-        checkVar(t, v, referenceMap.get(v).references);\n+        checkVar(t, v, referenceMap.getReferences(v).references);\n       }\n     }\n ", "timestamp": 1306258598, "metainfo": ""}