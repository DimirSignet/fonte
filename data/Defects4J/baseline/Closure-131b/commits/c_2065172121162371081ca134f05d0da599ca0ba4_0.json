{"sha": "2065172121162371081ca134f05d0da599ca0ba4", "log": "Adds a TemplateTypeMap, which encapsulates a mapping between template keys (String) and their values (JSType). Hooks into all relevant JSTypes except TemplatizedType.  R=dimvar,nicksantos,johnlenz DELTA=487 (242 added, 197 deleted, 48 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6208   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n   private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n       FunctionType fnType, Node call) {\n-    if (fnType.getTemplateKeys().isEmpty()) {\n+    if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n       return Collections.emptyMap();\n     }\n \n    */\n   private boolean inferTemplatedTypesForCall(\n       Node n, FunctionType fnType) {\n-    if (fnType.getTemplateKeys().isEmpty()) {\n+    if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n       }\n     }\n \n-    if (!funType.getTemplateKeys().isEmpty()) {\n+    if (!funType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n       sb.append(\" * @template \");\n-      sb.append(Joiner.on(\",\").join(funType.getTemplateKeys()));\n+      sb.append(Joiner.on(\",\").join(\n+          funType.getTemplateTypeMap().getTemplateKeys()));\n       sb.append(\"\\n\");\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n   private Node parametersNode = null;\n   private JSType returnType = null;\n   private JSType typeOfThis = null;\n-  private ImmutableList<String> templateKeys = ImmutableList.of();\n+  private TemplateTypeMap templateTypeMap = null;\n   private boolean inferredReturnType = false;\n   private boolean isConstructor = false;\n   private boolean isNativeType = false;\n   }\n \n   /** Set the template name. */\n-  public FunctionBuilder withTemplateKeys(\n-      ImmutableList<String> templateKeys) {\n-    this.templateKeys = templateKeys;\n+  public FunctionBuilder withTemplateKeys(ImmutableList<String> templateKeys) {\n+    this.templateTypeMap = registry.createTemplateTypeMap(templateKeys, null);\n     return this;\n   }\n \n     this.parametersNode = otherType.getParametersNode();\n     this.returnType = otherType.getReturnType();\n     this.typeOfThis = otherType.getTypeOfThis();\n-    this.templateKeys = otherType.getTemplateKeys();\n+    this.templateTypeMap = otherType.getTemplateTypeMap();\n     this.isConstructor = otherType.isConstructor();\n     this.isNativeType = otherType.isNativeObjectType();\n     return this;\n   public FunctionType build() {\n     return new FunctionType(registry, name, sourceNode,\n         new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n-        typeOfThis, templateKeys, isConstructor, isNativeType);\n+        typeOfThis, templateTypeMap, isConstructor, isNativeType);\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n                ArrowType arrowType, JSType typeOfThis,\n-               ImmutableList<String> templateKeys,\n+               TemplateTypeMap templateTypeMap,\n                boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n-        nativeType, templateKeys, null);\n+        nativeType, templateTypeMap);\n     setPrettyPrint(true);\n \n     Preconditions.checkArgument(source == null ||\n       this.kind = Kind.CONSTRUCTOR;\n       this.propAccess = PropAccess.ANY;\n       this.typeOfThis = typeOfThis != null ?\n-          typeOfThis : new InstanceObjectType(registry, this, nativeType, null);\n+          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n     } else {\n       this.kind = Kind.ORDINARY;\n       this.typeOfThis = typeOfThis != null ?\n                 registry,\n                 getReferenceName() + \".prototype\",\n                 registry.getNativeObjectType(OBJECT_TYPE),\n-                isNativeObjectType(), null, null),\n+                isNativeObjectType(), null),\n             null);\n       }\n     }\n             new FunctionBuilder(registry)\n             .withParams(builder)\n             .withReturnType(getReturnType())\n-            .withTemplateKeys(getTemplateKeys())\n+            .withTemplateKeys(getTemplateTypeMap().getTemplateKeys())\n             .build(),\n             source);\n       }\n   public FunctionType getBindReturnType(int argsToBind) {\n     FunctionBuilder builder = new FunctionBuilder(registry)\n         .withReturnType(getReturnType())\n-        .withTemplateKeys(getTemplateKeys());\n+        .withTemplateKeys(getTemplateTypeMap().getTemplateKeys());\n     if (argsToBind >= 0) {\n       Node origParams = getParametersNode();\n       if (origParams != null) {\n     boolean isBind = !isCall;\n     FunctionBuilder builder = new FunctionBuilder(registry)\n         .withReturnType(isCall ? getReturnType() : getBindReturnType(-1))\n-        .withTemplateKeys(getTemplateKeys());\n+        .withTemplateKeys(getTemplateTypeMap().getTemplateKeys());\n \n     Node origParams = getParametersNode();\n     if (origParams != null) {\n \n   @Override\n   public boolean hasAnyTemplateTypesInternal() {\n-    return !getTemplateKeys().isEmpty()\n+    return getTemplateTypeMap().numUnfilledTemplateKeys() > 0\n         || typeOfThis.hasAnyTemplateTypes()\n         || call.hasAnyTemplateTypes();\n   }\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n package com.google.javascript.rhino.jstype;\n \n \n-import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n \n /**\n   private final FunctionType constructor;\n \n   InstanceObjectType(JSTypeRegistry registry, FunctionType constructor) {\n-    this(registry, constructor, false, null);\n+    this(registry, constructor, false);\n   }\n \n   InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n-                     boolean isNativeType,\n-                     ImmutableList<JSType> templatizedTypes) {\n-    super(registry, null, null, isNativeType, constructor.getTemplateKeys(),\n-        templatizedTypes);\n+                     boolean isNativeType) {\n+    super(registry, null, null, isNativeType, constructor.getTemplateTypeMap());\n     Preconditions.checkNotNull(constructor);\n     this.constructor = constructor;\n   }\n   @Override\n   String toStringHelper(boolean forAnnotations) {\n     if (constructor.hasReferenceName()) {\n-      String typeString = constructor.getReferenceName();\n-\n-      ImmutableList<JSType> templatizedTypes = getTemplatizedTypes();\n-      if (!templatizedTypes.isEmpty()) {\n-        typeString += \".<\" + Joiner.on(\",\").join(templatizedTypes) + \">\";\n-      }\n-\n-      return typeString;\n+      return constructor.getReferenceName();\n     } else {\n       return super.toStringHelper(forAnnotations);\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n import com.google.common.base.Predicate;\n-import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n \n   private boolean resolved = false;\n   private JSType resolveResult = null;\n-  private final ImmutableList<String> templateKeys;\n-  private final ImmutableList<JSType> templatizedTypes;\n+  protected final TemplateTypeMap templateTypeMap;\n \n   private boolean inTemplatedCheckVisit = false;\n   private static final CanCastToVisitor CAN_CAST_TO_VISITOR =\n   final JSTypeRegistry registry;\n \n   JSType(JSTypeRegistry registry) {\n-    this(registry, null, null);\n-  }\n-\n-  JSType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n-      ImmutableList<JSType> templatizedTypes) {\n+    this(registry, null);\n+  }\n+\n+  JSType(JSTypeRegistry registry, TemplateTypeMap templateTypeMap) {\n     this.registry = registry;\n \n-    // Do sanity checking on the specified keys and templatized types.\n-    int keysLength = templateKeys == null ? 0 : templateKeys.size();\n-    int typesLength = templatizedTypes == null ? 0 : templatizedTypes.size();\n-    if (typesLength > keysLength) {\n-      throw new IllegalArgumentException(\n-          \"Cannot have more templatized types than template keys\");\n-    } else if (typesLength < keysLength) {\n-      // If there are fewer templatized types than keys, extend the templatized\n-      // types list to match the number of keys, using UNKNOWN_TYPE for the\n-      // unspecified types.\n-      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n-      if (typesLength > 0) {\n-        builder.addAll(templatizedTypes);\n-      }\n-      for (int i = 0; i < keysLength - typesLength; i++) {\n-        builder.add(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n-      }\n-      templatizedTypes = builder.build();\n-    } else if (keysLength == 0 && typesLength == 0) {\n-      // Ensure that both lists are non-null.\n-      templateKeys = ImmutableList.of();\n-      templatizedTypes = ImmutableList.of();\n-    }\n-\n-    this.templateKeys = templateKeys;\n-    this.templatizedTypes = templatizedTypes;\n+    this.templateTypeMap = templateTypeMap == null ?\n+        registry.createTemplateTypeMap(null, null) : templateTypeMap;\n   }\n \n   /**\n   }\n \n   boolean hasAnyTemplateTypesInternal() {\n-    if (isTemplatized()) {\n-      for (JSType templatizedType : templatizedTypes) {\n-        if (templatizedType.hasAnyTemplateTypes()) {\n-          return true;\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * Returns true if this type is templatized; false otherwise.\n-   */\n-  public boolean isTemplatized() {\n-    return !templateKeys.isEmpty();\n-  }\n-\n-  /**\n-   * Returns the template keys associated with this type.\n-   */\n-  public ImmutableList<String> getTemplateKeys() {\n-    return templateKeys;\n-  }\n-\n-  public ImmutableList<JSType> getTemplatizedTypes() {\n-    return templatizedTypes;\n-  }\n-\n-  /**\n-   * Returns true if this type is templatized for the specified key; false\n-   * otherwise.\n-   */\n-  public boolean hasTemplatizedType(String key) {\n-    return templateKeys.contains(key);\n-  }\n-\n-  /**\n-   * Returns the type associated with a given template key. Will return\n-   * the UNKNOWN_TYPE if there is no template type associated with that\n-   * template key.\n-   */\n-  public JSType getTemplatizedType(String key) {\n-     int index = templateKeys.indexOf(key);\n-     if (index < 0) {\n-       return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n-     }\n-     return templatizedTypes.get(index);\n-  }\n-\n-  /**\n-   * Determines if the two specified JSTypes have equivalent, invariant\n-   * templatized types.\n-   */\n-  static boolean hasEquivalentTemplateTypes(\n-      JSType type1, JSType type2, EquivalenceMethod eqMethod) {\n-    ImmutableList<JSType> templatizedTypes1 = type1.getTemplatizedTypes();\n-    ImmutableList<JSType> templatizedTypes2 = type2.getTemplatizedTypes();\n-    int nTemplatizedTypes1 = templatizedTypes1.size();\n-    int nTemplatizedTypes2 = templatizedTypes2.size();\n-\n-    if (nTemplatizedTypes1 != nTemplatizedTypes2) {\n-      return false;\n-    }\n-\n-    for (int i = 0; i < nTemplatizedTypes1; i++) {\n-      JSType templatizedType1 = templatizedTypes1.get(i);\n-      JSType templatizedType2 = templatizedTypes2.get(i);\n-      if (templatizedType1.checkEquivalenceHelper(templatizedType2, eqMethod)) {\n-        return false;\n-      }\n-    }\n-\n-    return true;\n-  }\n-\n+    return templateTypeMap.hasAnyTemplateTypesInternal();\n+  }\n+\n+  /**\n+   * Returns the template type map associated with this type.\n+   */\n+  public TemplateTypeMap getTemplateTypeMap() {\n+    return templateTypeMap;\n+  }\n \n   /**\n    * Tests whether this type is an {@code Object}, or any subtype thereof.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   // The template type name.\n   private Map<String, TemplateType> templateTypes = Maps.newHashMap();\n \n+  // A single empty TemplateTypeMap, which can be safely reused in cases where\n+  // there are no template types.\n+  private final TemplateTypeMap emptyTemplateTypeMap;\n+\n   private final boolean tolerateUndefinedValues;\n \n   /**\n   public JSTypeRegistry(\n       ErrorReporter reporter, boolean tolerateUndefinedValues) {\n     this.reporter = reporter;\n+    this.emptyTemplateTypeMap = new TemplateTypeMap(\n+        this, ImmutableList.<String>of(), ImmutableList.<JSType>of());\n     nativeTypes = new JSType[JSTypeNative.values().length];\n     namesToTypes = new HashMap<String, JSType>();\n     resetForTypeCheck();\n     // use each other's results, so at least one of them will get null\n     // instead of an actual type; however, this seems to be benign.\n     PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n-        new PrototypeObjectType(this, null, null, true, null, null);\n+        new PrototypeObjectType(this, null, null, true, null);\n     registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n \n     // Object\n    */\n   ObjectType createNativeAnonymousObjectType() {\n     PrototypeObjectType type =\n-        new PrototypeObjectType(this, null, null, true, null, null);\n+        new PrototypeObjectType(this, null, null, true, null);\n     type.setPrettyPrint(true);\n     return type;\n   }\n       Node parameters, JSType returnType, ImmutableList<String> templateKeys) {\n     return new FunctionType(this, name, source,\n         createArrowType(parameters, returnType), null,\n-        templateKeys, true, false);\n+        createTemplateTypeMap(templateKeys, null), true, false);\n   }\n \n   /**\n   }\n \n   /**\n+   * Creates a template type map from the specified list of template keys and\n+   * template value types.\n+   */\n+  public TemplateTypeMap createTemplateTypeMap(\n+      ImmutableList<String> templateKeys,\n+      ImmutableList<JSType> templateValues) {\n+    templateKeys = templateKeys == null ?\n+        ImmutableList.<String>of() : templateKeys;\n+    templateValues = templateValues == null ?\n+        ImmutableList.<JSType>of() : templateValues;\n+\n+    return (templateKeys.isEmpty() && templateValues.isEmpty()) ?\n+        emptyTemplateTypeMap :\n+        new TemplateTypeMap(this, templateKeys, templateValues);\n+  }\n+\n+  /*\n    * Creates a templatized type.\n    */\n   public TemplatizedType createTemplatizedType(\n       ObjectType objectType, JSType parameterType) {\n     return new TemplatizedType(this, objectType, parameterType);\n-  }\n-\n-  /**\n-   * Creates a templatized instance of the specified type.\n-   * @param baseType the type to be templatized.\n-   * @param templatizedTypes a list of the template JSTypes. Will be matched by\n-   *     list order to the template keys specified in the constructor function.\n-   */\n-  public JSType createTemplatizedType(\n-      JSType baseType, ImmutableList<JSType> templatizedTypes) {\n-    // Only instance object types can currently be templatized; extend this\n-    // logic when more types can be templatized.\n-    if (baseType instanceof InstanceObjectType) {\n-      ObjectType baseObjType = baseType.toObjectType();\n-      return new InstanceObjectType(\n-          this, baseObjType.getConstructor(), baseObjType.isNativeObjectType(),\n-          templatizedTypes);\n-    } else {\n-      throw new IllegalArgumentException(\n-          \"Only instance object types can be templatized\");\n-    }\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n+++ b/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n \n   @Override\n   public JSType caseObjectType(ObjectType objType) {\n-    if (objType.isTemplatized()) {\n-      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n-      for (JSType templatizedType : objType.getTemplatizedTypes()) {\n-        builder.add(templatizedType.visit(this));\n-      }\n-      return registry.createTemplatizedType(objType, builder.build());\n-    } else {\n-      return objType;\n-    }\n+    return objType;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n     super(registry);\n   }\n \n-  ObjectType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n-      ImmutableList<JSType> templatizedTypes) {\n-    super(registry, templateKeys, templatizedTypes);\n+  ObjectType(JSTypeRegistry registry, TemplateTypeMap templateTypeMap) {\n+    super(registry, templateTypeMap);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n    */\n   PrototypeObjectType(JSTypeRegistry registry, String className,\n       ObjectType implicitPrototype) {\n-    this(registry, className, implicitPrototype, false, null, null);\n+    this(registry, className, implicitPrototype, false, null);\n   }\n \n   /**\n    */\n   PrototypeObjectType(JSTypeRegistry registry, String className,\n       ObjectType implicitPrototype, boolean nativeType,\n-      ImmutableList<String> templateKeys,\n-      ImmutableList<JSType> templatizedTypes) {\n-    super(registry, templateKeys, templatizedTypes);\n+      TemplateTypeMap templateTypeMap) {\n+    super(registry, templateTypeMap);\n     this.properties = new PropertyMap();\n     this.properties.setParentSource(this);\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   private ObjectType referencedObjType;\n \n   ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n-    super(registry);\n+    this(registry, referencedType, null);\n+  }\n+\n+  ProxyObjectType(JSTypeRegistry registry, JSType referencedType,\n+                  TemplateTypeMap templateTypeMap) {\n+    super(registry, templateTypeMap);\n     setReferencedType(referencedType);\n   }\n \n   public boolean hasAnyTemplateTypesInternal() {\n     return referencedType.hasAnyTemplateTypes();\n   }\n+\n+  @Override\n+  public TemplateTypeMap getTemplateTypeMap() {\n+    return referencedType.getTemplateTypeMap();\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Manages a mapping from TemplateType to its resolved JSType. Provides utility\n+ * methods for cloning/extending the map.\n+ *\n+ * @author izaakr@google.com (Izaak Rubin)\n+ */\n+public class TemplateTypeMap implements Serializable {\n+  private final ImmutableList<String> templateKeys;\n+  private final ImmutableList<JSType> templateValues;\n+  final JSTypeRegistry registry;\n+\n+  TemplateTypeMap(JSTypeRegistry registry,\n+                  ImmutableList<String> templateKeys,\n+                  ImmutableList<JSType> templateValues) {\n+    Preconditions.checkNotNull(templateKeys);\n+    Preconditions.checkNotNull(templateValues);\n+\n+    this.registry = registry;\n+    this.templateKeys = templateKeys;\n+\n+    int nKeys = templateKeys.size();\n+    this.templateValues = templateValues.size() > nKeys ?\n+        templateValues.subList(0, nKeys) : templateValues;\n+  }\n+\n+  /**\n+   * Returns a list of all template keys.\n+   */\n+  public ImmutableList<String> getTemplateKeys() {\n+    return templateKeys;\n+  }\n+\n+  /**\n+   * Returns true if this map contains the specified template key, false\n+   * otherwise.\n+   */\n+  public boolean hasTemplateKey(String templateKey) {\n+    return templateKeys.contains(templateKey);\n+  }\n+\n+  /**\n+   * Returns the number of template keys in this map that do not have a\n+   * corresponding JSType value.\n+   */\n+  int numUnfilledTemplateKeys() {\n+    return templateKeys.size() - templateValues.size();\n+  }\n+\n+  /**\n+   * Returns a list of template keys in this map that do not have corresponding\n+   * JSType values.\n+   */\n+  ImmutableList<String> getUnfilledTemplateKeys() {\n+    return templateKeys.subList(templateValues.size(), templateKeys.size());\n+  }\n+\n+  /**\n+   * Returns true if there is a JSType value associated with the specified\n+   * template key; false otherwise.\n+   */\n+  public boolean hasTemplateType(String key) {\n+    return getTemplateTypeInternal(key) != null;\n+  }\n+\n+  /**\n+   * Returns the JSType value associated with the specified template key. If no\n+   * JSType value is associated, returns UNKNOWN_TYPE.\n+   */\n+  public JSType getTemplateType(String key) {\n+    JSType templateType = getTemplateTypeInternal(key);\n+    return (templateType == null) ?\n+        registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) : templateType;\n+  }\n+\n+  /**\n+   * Returns the JSType value associated with the specified template key. If no\n+   * JSType value is associated, returns null.\n+   */\n+  private JSType getTemplateTypeInternal(String key) {\n+    int index = templateKeys.indexOf(key);\n+    if (index < 0 || index >= templateValues.size()) {\n+      return null;\n+    }\n+    return templateValues.get(index);\n+  }\n+\n+  /**\n+   * Determines if this map and the specified map have equivalent template\n+   * types.\n+   */\n+  public boolean checkEquivalenceHelper(\n+      TemplateTypeMap that, EquivalenceMethod eqMethod) {\n+    int thisNumKeys = templateKeys.size();\n+    int thatNumKeys = that.getTemplateKeys().size();\n+\n+    for (int i = 0; i < Math.min(thisNumKeys, thatNumKeys); i++) {\n+      JSType thisTemplateType = getTemplateType(templateKeys.get(i));\n+      JSType thatTemplateType = that.getTemplateType(\n+          that.getTemplateKeys().get(i));\n+      if (!thisTemplateType.checkEquivalenceHelper(\n+          thatTemplateType, eqMethod)) {\n+        return false;\n+      }\n+    }\n+\n+    return thisNumKeys == thatNumKeys ||\n+        eqMethod == EquivalenceMethod.INVARIANT;\n+  }\n+\n+  /**\n+   * Returns a new TemplateTypeMap whose keys have been extended with the\n+   * specified list.\n+   */\n+  TemplateTypeMap extendKeys(ImmutableList<String> newKeys) {\n+    return registry.createTemplateTypeMap(\n+        concatImmutableLists(templateKeys, newKeys), templateValues);\n+  }\n+\n+  /**\n+   * Returns a new TemplateTypeMap whose values have been extended with the\n+   * specified list.\n+   */\n+  TemplateTypeMap extendValues(ImmutableList<JSType> newValues) {\n+    // Ignore any new template values that will not align with an existing\n+    // template key.\n+    int numUnfilledKeys = numUnfilledTemplateKeys();\n+    if (numUnfilledKeys < newValues.size()) {\n+      newValues = newValues.subList(0, numUnfilledKeys);\n+    }\n+\n+    return registry.createTemplateTypeMap(\n+        templateKeys, concatImmutableLists(templateValues, newValues));\n+  }\n+\n+  /**\n+   * Concatenates two ImmutableList instances. If either input is empty, the\n+   * other is returned; otherwise, a new ImmutableList instance is created that\n+   * contains the contents of both arguments.\n+   */\n+  private <T> ImmutableList<T> concatImmutableLists(\n+    ImmutableList<T> first, ImmutableList<T> second) {\n+    if (first.isEmpty()) {\n+      return second;\n+    }\n+    if (second.isEmpty()) {\n+      return first;\n+    }\n+    ImmutableList.Builder<T> builder = ImmutableList.builder();\n+    builder.addAll(first);\n+    builder.addAll(second);\n+    return builder.build();\n+  }\n+\n+  boolean hasAnyTemplateTypesInternal() {\n+    for (JSType templateValue : templateValues) {\n+      if (templateValue.hasAnyTemplateTypes()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n \n package com.google.javascript.rhino.testing;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionBuilder;\n   }\n \n   protected JSType createTemplatizedType(\n-      JSType baseType, ImmutableList<JSType> templatizedTypes) {\n-    return registry.createTemplatizedType(baseType, templatizedTypes);\n-  }\n-\n-  protected JSType createTemplatizedType(\n       ObjectType type, JSType typeParameter) {\n     return registry.createTemplatizedType(type, typeParameter);\n   }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n       .withTemplateKeys(ImmutableList.of(\"T\"))\n       .withReturnType(BOOLEAN_TYPE).build();\n \n-    assertEquals(\"[T]\",\n-        fn.getPropertyType(\"call\").getTemplateKeys().toString());\n-    assertEquals(\"[T]\",\n-        fn.getPropertyType(\"apply\").getTemplateKeys().toString());\n-    assertEquals(\"[T]\",\n-        fn.getPropertyType(\"bind\").getTemplateKeys().toString());\n-    assertEquals(\"[T]\",\n-        fn.getBindReturnType(0).getTemplateKeys().toString());\n+    assertEquals(\"[T]\", fn.getPropertyType(\"call\").getTemplateTypeMap()\n+        .getTemplateKeys().toString());\n+    assertEquals(\"[T]\", fn.getPropertyType(\"apply\").getTemplateTypeMap()\n+        .getTemplateKeys().toString());\n+    assertEquals(\"[T]\", fn.getPropertyType(\"bind\").getTemplateTypeMap()\n+        .getTemplateKeys().toString());\n+    assertEquals(\"[T]\", fn.getBindReturnType(0).getTemplateTypeMap()\n+        .getTemplateKeys().toString());\n   }\n \n   public void testPrint() {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n             .hasAnyTemplateTypes());\n   }\n \n-  public void testTemplatizedType() throws Exception {\n-    FunctionType templatizedCtor = registry.createConstructorType(\n-        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n-    JSType templatizedInstance = registry.createTemplatizedType(\n-        templatizedCtor.getInstanceType(),\n-        ImmutableList.of(NUMBER_TYPE, STRING_TYPE));\n-\n-    assertTrue(templatizedInstance.isTemplatized());\n-    assertTrue(templatizedInstance.hasTemplatizedType(\"A\"));\n-    assertTrue(templatizedInstance.hasTemplatizedType(\"B\"));\n-    assertFalse(templatizedInstance.hasTemplatizedType(\"C\"));\n-\n-    assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType(\"A\"));\n-    assertEquals(STRING_TYPE, templatizedInstance.getTemplatizedType(\"B\"));\n-    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"C\"));\n-\n-    assertEquals(\"TestingType.<number,string>\", templatizedInstance.toString());\n-  }\n-\n-  public void testPartiallyTemplatizedType() throws Exception {\n-    FunctionType templatizedCtor = registry.createConstructorType(\n-        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n-    JSType templatizedInstance = registry.createTemplatizedType(\n-        templatizedCtor.getInstanceType(),\n-        ImmutableList.of(NUMBER_TYPE));\n-\n-    assertTrue(templatizedInstance.isTemplatized());\n-    assertTrue(templatizedInstance.hasTemplatizedType(\"A\"));\n-    assertTrue(templatizedInstance.hasTemplatizedType(\"B\"));\n-    assertFalse(templatizedInstance.hasTemplatizedType(\"C\"));\n-\n-    assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType(\"A\"));\n-    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"B\"));\n-    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"C\"));\n-\n-    assertEquals(\"TestingType.<number,?>\", templatizedInstance.toString());\n-  }\n-\n-  public void testInvalidTemplatizedType() throws Exception {\n-    FunctionType templatizedCtor = registry.createConstructorType(\n-        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n-\n-    boolean exceptionThrown = false;\n-    try {\n-      registry.createTemplatizedType(\n-          templatizedCtor.getInstanceType(),\n-          ImmutableList.of(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE));\n-    } catch (IllegalArgumentException e) {\n-      exceptionThrown = true;\n-    }\n-    assertTrue(exceptionThrown);\n-  }\n-\n   public void testCanCastTo() {\n     assertTrue(ALL_TYPE.canCastTo(NULL_TYPE));\n     assertTrue(ALL_TYPE.canCastTo(VOID_TYPE));", "timestamp": 1359486186, "metainfo": ""}