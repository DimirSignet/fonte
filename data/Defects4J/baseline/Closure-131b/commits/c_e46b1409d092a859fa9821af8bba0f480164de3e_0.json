{"sha": "e46b1409d092a859fa9821af8bba0f480164de3e", "log": "Fix bug in checkUnionEquivalenceHelper.  R=acleung,nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=6226   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n     // edges. If we wanted to be perfect, we'd actually JOIN all the out\n     // lattices of this flow with the in lattice, and then make that the out\n-    // lattice for the ON_EX edge. But it's probably to expensive to be\n+    // lattice for the ON_EX edge. But it's probably too expensive to be\n     // worthwhile.\n     FlowScope output = flowThrough(source, input);\n     Node condition = null;\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n   private static final long serialVersionUID = 1L;\n \n   Collection<JSType> alternates;\n-  private final int hashcode;\n+  private int hashcode;\n \n   /**\n    * Creates a union type.\n    * @return The alternate types of this union type. The returned set is\n    *     immutable.\n    */\n-  public Iterable<JSType> getAlternates() {\n+  public Collection<JSType> getAlternates() {\n+    for (JSType t : alternates) {\n+      if (t.isUnionType()) {\n+        rebuildAlternates();\n+        break;\n+      }\n+    }\n     return alternates;\n+  }\n+\n+  /**\n+   * Use UnionTypeBuilder to rebuild the list of alternates and hashcode\n+   * of the current UnionType.\n+   */\n+  private void rebuildAlternates() {\n+    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n+    for (JSType alternate : alternates) {\n+      builder.addAlternate(alternate);\n+    }\n+    alternates = builder.getAlternates();\n+    hashcode = alternates.hashCode();\n   }\n \n   /**\n   }\n \n   /**\n-   * Two union types are equal if they have the same number of alternates\n-   * and all alternates are equal.\n+   * Two union types are equal if, after flattening nested union types,\n+   * they have the same number of alternates and all alternates are equal.\n    */\n   boolean checkUnionEquivalenceHelper(\n       UnionType that, EquivalenceMethod eqMethod) {\n+    Collection<JSType> thatAlternates = that.getAlternates();\n     if (eqMethod == EquivalenceMethod.IDENTITY\n-        && alternates.size() != that.alternates.size()) {\n+        && getAlternates().size() != thatAlternates.size()) {\n       return false;\n     }\n-    for (JSType alternate : that.alternates) {\n+    for (JSType alternate : thatAlternates) {\n       if (!hasAlternate(alternate, eqMethod)) {\n         return false;\n       }\n   }\n \n   private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {\n-    for (JSType alternate : alternates) {\n+    for (JSType alternate : getAlternates()) {\n       if (alternate.checkEquivalenceHelper(type, eqMethod)) {\n         return true;\n       }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n     this.maxUnionSize = maxUnionSize;\n   }\n \n-  Iterable<JSType> getAlternates() {\n+  Collection<JSType> getAlternates() {\n     JSType specialCaseType = reduceAlternatesWithoutUnion();\n     if (specialCaseType != null) {\n       return ImmutableList.of(specialCaseType);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"}\");\n   }\n \n+  public void testBug8017789() throws Exception {\n+    testTypes(\n+        \"/** @param {(map|function())} isResult */\" +\n+        \"var f = function(isResult) {\" +\n+        \"    while (true)\" +\n+        \"        isResult['t'];\" +\n+        \"};\" +\n+        \"/** @typedef {Object.<string, number>} */\" +\n+        \"var map;\");\n+  }\n+\n+  public void testTypedefBeforeUse() throws Exception {\n+    testTypes(\n+        \"/** @typedef {Object.<string, number>} */\" +\n+        \"var map;\" +\n+        \"/** @param {(map|function())} isResult */\" +\n+        \"var f = function(isResult) {\" +\n+        \"    while (true)\" +\n+        \"        isResult['t'];\" +\n+        \"};\");\n+  }\n+\n   public void testScopedConstructors1() throws Exception {\n     testTypes(\n         \"function foo1() { \" +", "timestamp": 1359589254, "metainfo": ""}