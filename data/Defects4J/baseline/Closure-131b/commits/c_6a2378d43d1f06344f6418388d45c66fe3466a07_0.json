{"sha": "6a2378d43d1f06344f6418388d45c66fe3466a07", "log": "Take advantage of the finer grain side-effect information when determining side-effects. The bulk of the changes here are the move of the \"isKnownLocalValue\" function and its tests from to NodeUtil/NodeUtilTest.  R=nicksantos DELTA=664  (419 added, 201 deleted, 44 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=260873   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n         }\n \n         if (isAssignmentOp(n)) {\n+          Node assignTarget = n.getFirstChild();\n+          if (isName(assignTarget)) {\n+            return true;\n+          }\n+\n           // Assignments will have side effects if\n           // a) The RHS has side effects, or\n           // b) The LHS has side effects, or\n             return true;\n           }\n \n-          Node current = n.getFirstChild();\n-          for (;\n-               current.getType() == Token.GETPROP ||\n-               current.getType() == Token.GETELEM;\n-               current = current.getFirstChild()) { }\n-\n-          return !isLiteralValue(current, true);\n+          if (isGet(assignTarget)) {\n+            // If the object being assigned to is a local object, don't\n+            // consider this a side-effect as it can't be referenced\n+            // elsewhere.  Don't do this recursively as the property might\n+            // be an alias of another object, unlike a literal below.\n+            Node current = assignTarget.getFirstChild();\n+            if (evaluatesToLocalValue(current)) {\n+              return false;\n+            }\n+\n+            // A literal value as defined by \"isLiteralValue\" is guaranteed\n+            // not to be an alias, or any components which are aliases of\n+            // other objects.\n+            // If the root object is a literal don't consider this a\n+            // side-effect.\n+            while (isGet(current)) {\n+              current = current.getFirstChild();\n+            }\n+\n+            return !isLiteralValue(current, true);\n+          } else {\n+            // TODO(johnlenz): remove this code and make this an exception. This\n+            // is here only for legacy reasons, the AST is not valid but\n+            // preserve existing behavior.\n+            return !isLiteralValue(assignTarget, true);\n+          }\n         }\n \n         return true;\n         return false;\n       }\n     } else if (nameNode.getType() == Token.GETPROP) {\n+      if (callNode.isOnlyModifiesThisCall()\n+          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n+        return false;\n+      }\n+\n       // Functions in the \"Math\" namespace have no side effects.\n       if (nameNode.getFirstChild().getType() == Token.NAME) {\n         String namespaceName = nameNode.getFirstChild().getString();\n     }\n     return call;\n   }\n+\n+  /**\n+   * @return Whether the node is known to be a value that is not referenced\n+   * elsewhere.\n+   */\n+  static boolean evaluatesToLocalValue(Node value) {\n+    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n+  }\n+\n+  /**\n+   * @param locals A predicate to apply to unknown local values.\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the expression scope.\n+   */\n+  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch (value.getType()) {\n+      case Token.ASSIGN:\n+        // A result that is aliased by a non-local name, is the effectively the\n+        // same as returning a non-local name, but this doesn't matter if the\n+        // value is immutable.\n+        return NodeUtil.isImmutableValue(value.getLastChild())\n+            || (locals.apply(value)\n+                && evaluatesToLocalValue(value.getLastChild(), locals));\n+      case Token.COMMA:\n+        return evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.AND:\n+      case Token.OR:\n+        return evaluatesToLocalValue(value.getFirstChild(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.HOOK:\n+        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+           && evaluatesToLocalValue(value.getLastChild(), locals);\n+      case Token.INC:\n+      case Token.DEC:\n+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+          return evaluatesToLocalValue(value.getFirstChild(), locals);\n+        } else {\n+          return true;\n+        }\n+      case Token.THIS:\n+        return locals.apply(value);\n+      case Token.NAME:\n+        return isImmutableValue(value) || locals.apply(value);\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        // There is no information about the locality of object properties.\n+        return locals.apply(value);\n+      case Token.CALL:\n+        return callHasLocalResult(value) || locals.apply(value);\n+      case Token.NEW:\n+        return true;\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // Literals objects with non-literal children are allowed.\n+        return true;\n+      case Token.IN:\n+        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+        return true;\n+      default:\n+        // Other op force a local value:\n+        //  x = '' + g (x is now an local string)\n+        //  x -= g (x is now an local number)\n+        if (isAssignmentOp(value)\n+            || isSimpleOperator(value)\n+            || isImmutableValue(value)) {\n+          return true;\n+        }\n+\n+        throw new IllegalStateException(\n+            \"Unexpected expression node\" + value +\n+            \"\\n parent:\" + value.getParent());\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n       Collection<Definition> defs =\n           getCallableDefinitions(definitionProvider, name);\n       // Default to side effects, non-local results\n-      SideEffectFlags flags = new SideEffectFlags();\n+      Node.SideEffectFlags flags = new Node.SideEffectFlags();\n       if (defs == null) {\n         flags.setMutatesGlobalState();\n         flags.setThrows();\n       }\n \n       callNode.setSideEffectFlags(flags.valueOf());\n-    }\n-  }\n-\n-  private static class SideEffectFlags {\n-    private int value = Node.SIDE_EFFECTS_ALL;\n-\n-    int valueOf() {\n-      return value;\n-    }\n-\n-    /** All side-effect occur and the returned results are non-local. */\n-    void setAllFlags() {\n-      value = Node.SIDE_EFFECTS_ALL;\n-    }\n-\n-    /** No side-effects occur and the returned results are local. */\n-    void clearAllFlags() {\n-      value = Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS;\n-    }\n-\n-    boolean areAllFlagsSet() {\n-      return value == Node.SIDE_EFFECTS_ALL;\n-    }\n-\n-    /**\n-     * Preserve the return result flag, but clear the others:\n-     *   no global state change, no throws, no this change, no arguments change\n-     */\n-    void clearSideEffectFlags() {\n-      value |= Node.NO_SIDE_EFFECTS;\n-    }\n-\n-    void setMutatesGlobalState() {\n-      // Modify global means everything must be assumed to be modified.\n-      removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED);\n-      removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n-      removeFlag(Node.FLAG_THIS_UNMODIFIED);\n-    }\n-\n-    void setThrows() {\n-      removeFlag(Node.FLAG_NO_THROWS);\n-    }\n-\n-    void setMutatesThis() {\n-      removeFlag(Node.FLAG_THIS_UNMODIFIED);\n-    }\n-\n-    void setMutatesArguments() {\n-      removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n-    }\n-\n-    void setReturnsTainted() {\n-      removeFlag(Node.FLAG_LOCAL_RESULTS);\n-    }\n-\n-    private void removeFlag(int flag) {\n-      value &= ~flag;\n     }\n   }\n \n               // Assignment to local, if the value isn't a safe local value,\n               // new object creation or literal or known primitive result\n               // value, add it to the local blacklist.\n-              if (value != null && !isKnownLocalValue(value)) {\n+              if (value != null && !NodeUtil.evaluatesToLocalValue(value)) {\n                 Scope scope = traversal.getScope();\n                 Var var = scope.getVar(node.getString());\n                 sideEffectInfo.blacklistLocal(var);\n               break;\n             case Token.RETURN:\n               if (node.hasChildren()\n-                  && !isKnownLocalValue(node.getFirstChild())) {\n+                  && !NodeUtil.evaluatesToLocalValue(node.getFirstChild())) {\n                 sideEffectInfo.setTaintsReturn();\n               }\n               break;\n           Preconditions.checkState(\n               NodeUtil.isAssignmentOp(op)\n               || isIncDec(op) || op.getType() == Token.DELPROP);\n-          if (rhs != null && NodeUtil.isAssign(op) && !isKnownLocalValue(rhs)) {\n+          if (rhs != null\n+              && NodeUtil.isAssign(op)\n+              && !NodeUtil.evaluatesToLocalValue(rhs)) {\n             sideEffectInfo.blacklistLocal(var);\n           }\n         }\n \n       FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);\n       functionSideEffectMap.put(node, sideEffectInfo);\n+\n+      if (inExterns) {\n+        // TODO(johnlenz): determine the locality of the results of extern\n+        // functions.\n+        sideEffectInfo.setTaintsReturn();\n+      }\n \n       JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);\n       if (info != null) {\n    * @return Whether the node is known to be a value that is not a reference\n    *     outside the local scope.\n    */\n-  @VisibleForTesting\n-  static boolean isKnownLocalValue(Node value) {\n-    // TODO(johnlenz): traverse into expression.\n-    // return NodeUtil.isNew(value) || NodeUtil.isLiteralValue(value, true);\n-    switch (value.getType()) {\n-      case Token.ASSIGN:\n-      case Token.COMMA:\n-        return isKnownLocalValue(value.getLastChild());\n-      case Token.AND:\n-      case Token.OR:\n-        return isKnownLocalValue(value.getFirstChild()) &&\n-           isKnownLocalValue(value.getLastChild());\n-      case Token.HOOK:\n-        return isKnownLocalValue(value.getFirstChild().getNext()) &&\n-           isKnownLocalValue(value.getLastChild());\n-      case Token.INC:\n-      case Token.DEC:\n-        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n-          return isKnownLocalValue(value.getFirstChild());\n-        } else {\n-          return true;\n-        }\n-      case Token.THIS:\n-        // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n+  private static boolean isKnownLocalValue(Node value) {\n+    Predicate<Node> taintingPredicate = new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node value) {\n+        switch (value.getType()) {\n+          case Token.THIS:\n+            // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n+            return false;\n+          case Token.NAME:\n+            // TODO(johnlenz): add to local tainting list, if the NAME\n+            // is known to be a local.\n+\n+            return false;\n+          case Token.GETELEM:\n+          case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return false;\n+          case Token.CALL:\n+            // TODO(johnlenz): add to local tainting list, if the call result\n+            // is not known to be a local result.\n+            return false;\n+        }\n         return false;\n-      case Token.NAME:\n-        // TODO(johnlenz): add to local tainting list, if the NAME\n-        // is known to be a local.\n-\n-        // \"undefined\", \"NaN\" and \"Infinity\" are allowed.\n-        return NodeUtil.isImmutableValue(value);\n-      case Token.GETELEM:\n-      case Token.GETPROP:\n-        // There is no information about the locality of object properties.\n-        return false;\n-      case Token.CALL:\n-        // TODO(johnlenz): add to local tainting list, if the call result\n-        // is not known to be a local result.\n-        return false;\n-      case Token.NEW:\n-        return true;\n-      case Token.FUNCTION:\n-      case Token.REGEXP:\n-      case Token.ARRAYLIT:\n-      case Token.OBJECTLIT:\n-        // Literals objects with non-literal children are allowed.\n-        return true;\n-      case Token.IN:\n-        // The IN operator is not include in NodeUtil#isSimpleOperator.\n-        return true;\n-      default:\n-        // Other op force a local value:\n-        //  x = '' + g (x is now an local string)\n-        //  x -= g (x is now an local number)\n-        if (NodeUtil.isAssignmentOp(value)\n-            || NodeUtil.isSimpleOperator(value)\n-            || NodeUtil.isImmutableValue(value)) {\n-          return true;\n-        }\n-\n-        throw new IllegalStateException(\n-            \"Unexpected expression node\" + value +\n-            \"\\n parent:\" + value.getParent());\n-    }\n+      }\n+    };\n+\n+    return NodeUtil.evaluatesToLocalValue(value, taintingPredicate);\n   }\n \n   /**\n               caller.setTaintsThis();\n               changed = true;\n             }\n-          } else if (objectNode != null && isKnownLocalValue(objectNode)\n+          } else if (objectNode != null\n+              && NodeUtil.evaluatesToLocalValue(objectNode)\n               && !isCallOrApply(callSite)) {\n             // Modifying 'this' on a known local object doesn't change any\n             // significant state.\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     | FLAG_ARGUMENTS_UNMODIFIED\n     | FLAG_NO_THROWS;\n \n-\n   /**\n    * Marks this function or constructor call's side effect flags.\n    * This property is only meaningful for {@link Token#CALL} and\n     putIntProp(SIDE_EFFECT_FLAGS, flags);\n   }\n \n+  public void setSideEffectFlags(SideEffectFlags flags) {\n+    setSideEffectFlags(flags.valueOf());\n+  }\n+\n   /**\n    * Returns the side effects flags for this node.\n    */\n   public int getSideEffectFlags() {\n     return getIntProp(SIDE_EFFECT_FLAGS);\n+  }\n+\n+  /**\n+   * A helper class for getting and setting the side-effect flags.\n+   * @author johnlenz@google.com (John Lenz)\n+   */\n+  public static class SideEffectFlags {\n+    private int value = Node.SIDE_EFFECTS_ALL;\n+\n+    public SideEffectFlags() {\n+    }\n+\n+    public SideEffectFlags(int value) {\n+      this.value = value;\n+    }\n+\n+    public int valueOf() {\n+      return value;\n+    }\n+\n+    /** All side-effect occur and the returned results are non-local. */\n+    public void setAllFlags() {\n+      value = Node.SIDE_EFFECTS_ALL;\n+    }\n+\n+    /** No side-effects occur and the returned results are local. */\n+    public void clearAllFlags() {\n+      value = Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS;\n+    }\n+\n+    public boolean areAllFlagsSet() {\n+      return value == Node.SIDE_EFFECTS_ALL;\n+    }\n+\n+    /**\n+     * Preserve the return result flag, but clear the others:\n+     *   no global state change, no throws, no this change, no arguments change\n+     */\n+    public void clearSideEffectFlags() {\n+      value |= Node.NO_SIDE_EFFECTS;\n+    }\n+\n+    public void setMutatesGlobalState() {\n+      // Modify global means everything must be assumed to be modified.\n+      removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED);\n+      removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n+      removeFlag(Node.FLAG_THIS_UNMODIFIED);\n+    }\n+\n+    public void setThrows() {\n+      removeFlag(Node.FLAG_NO_THROWS);\n+    }\n+\n+    public void setMutatesThis() {\n+      removeFlag(Node.FLAG_THIS_UNMODIFIED);\n+    }\n+\n+    public void setMutatesArguments() {\n+      removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n+    }\n+\n+    public void setReturnsTainted() {\n+      removeFlag(Node.FLAG_LOCAL_RESULTS);\n+    }\n+\n+    private void removeFlag(int flag) {\n+      value &= ~flag;\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the only side-effect is \"modifies this\"\n+   */\n+  public boolean isOnlyModifiesThisCall() {\n+    return areBitFlagsSet(\n+        getSideEffectFlags() & Node.NO_SIDE_EFFECTS,\n+        Node.FLAG_GLOBAL_STATE_UNMODIFIED\n+            | Node.FLAG_ARGUMENTS_UNMODIFIED\n+            | Node.FLAG_NO_THROWS);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n     assertExpressionBooleanFalse(\"a?false:false\");\n     assertExpressionBooleanUnknown(\"a?true:false\");\n     assertExpressionBooleanUnknown(\"a?true:foo()\");\n-    \n+\n     assertExpressionBooleanUnknown(\"b\");\n     assertExpressionBooleanUnknown(\"-'0.0'\");\n   }\n     assertSideEffect(false, \"-Infinity\");\n     assertSideEffect(false, \"Infinity\");\n     assertSideEffect(false, \"NaN\");\n+\n+    assertSideEffect(false, \"({}||[]).foo = 2;\");\n+    assertSideEffect(false, \"(true ? {} : []).foo = 2;\");\n+    assertSideEffect(false, \"({},[]).foo = 2;\");\n   }\n \n   public void testRegExpSideEffect() {\n     assertFalse(secondBreak.hasChildren());\n     assertFalse(NodeUtil.isLabelName(secondBreak.getFirstChild()));\n   }\n+\n+  public void testLocalValue1() throws Exception {\n+    // Names are not known to be local.\n+    assertFalse(testLocalValue(\"x\"));\n+    assertFalse(testLocalValue(\"x()\"));\n+    assertFalse(testLocalValue(\"this\"));\n+    assertFalse(testLocalValue(\"arguments\"));\n+\n+    // new objects are local\n+    assertTrue(testLocalValue(\"new x()\"));\n+\n+    // property references are assume to be non-local\n+    assertFalse(testLocalValue(\"(new x()).y\"));\n+    assertFalse(testLocalValue(\"(new x())['y']\"));\n+\n+    // Primitive values are local\n+    assertTrue(testLocalValue(\"null\"));\n+    assertTrue(testLocalValue(\"undefined\"));\n+    assertTrue(testLocalValue(\"Infinity\"));\n+    assertTrue(testLocalValue(\"NaN\"));\n+    assertTrue(testLocalValue(\"1\"));\n+    assertTrue(testLocalValue(\"'a'\"));\n+    assertTrue(testLocalValue(\"true\"));\n+    assertTrue(testLocalValue(\"false\"));\n+    assertTrue(testLocalValue(\"[]\"));\n+    assertTrue(testLocalValue(\"{}\"));\n+\n+    // The contents of arrays and objects don't matter\n+    assertTrue(testLocalValue(\"[x]\"));\n+    assertTrue(testLocalValue(\"{'a':x}\"));\n+\n+    // Pre-increment results in primitive number\n+    assertTrue(testLocalValue(\"++x\"));\n+    assertTrue(testLocalValue(\"--x\"));\n+\n+    // Post-increment, the previous value matters.\n+    assertFalse(testLocalValue(\"x++\"));\n+    assertFalse(testLocalValue(\"x--\"));\n+\n+    // The left side of an only assign matters if it is an alias or mutable.\n+    assertTrue(testLocalValue(\"x=1\"));\n+    assertFalse(testLocalValue(\"x=[]\"));\n+    assertFalse(testLocalValue(\"x=y\"));\n+    // The right hand side of assignment opts don't matter, as they force\n+    // a local result.\n+    assertTrue(testLocalValue(\"x+=y\"));\n+    assertTrue(testLocalValue(\"x*=y\"));\n+    // Comparisons always result in locals, as they force a local boolean\n+    // result.\n+    assertTrue(testLocalValue(\"x==y\"));\n+    assertTrue(testLocalValue(\"x!=y\"));\n+    assertTrue(testLocalValue(\"x>y\"));\n+    // Only the right side of a comma matters\n+    assertTrue(testLocalValue(\"(1,2)\"));\n+    assertTrue(testLocalValue(\"(x,1)\"));\n+    assertFalse(testLocalValue(\"(x,y)\"));\n+\n+    // Both the operands of OR matter\n+    assertTrue(testLocalValue(\"1||2\"));\n+    assertFalse(testLocalValue(\"x||1\"));\n+    assertFalse(testLocalValue(\"x||y\"));\n+    assertFalse(testLocalValue(\"1||y\"));\n+\n+    // Both the operands of AND matter\n+    assertTrue(testLocalValue(\"1&&2\"));\n+    assertFalse(testLocalValue(\"x&&1\"));\n+    assertFalse(testLocalValue(\"x&&y\"));\n+    assertFalse(testLocalValue(\"1&&y\"));\n+\n+    // Only the results of HOOK matter\n+    assertTrue(testLocalValue(\"x?1:2\"));\n+    assertFalse(testLocalValue(\"x?x:2\"));\n+    assertFalse(testLocalValue(\"x?1:x\"));\n+    assertFalse(testLocalValue(\"x?x:y\"));\n+\n+    // Results of ops are local values\n+    assertTrue(testLocalValue(\"!y\"));\n+    assertTrue(testLocalValue(\"~y\"));\n+    assertTrue(testLocalValue(\"y + 1\"));\n+    assertTrue(testLocalValue(\"y + z\"));\n+    assertTrue(testLocalValue(\"y * z\"));\n+\n+    assertTrue(testLocalValue(\"'a' in x\"));\n+    assertTrue(testLocalValue(\"typeof x\"));\n+    assertTrue(testLocalValue(\"x instanceof y\"));\n+\n+    assertTrue(testLocalValue(\"void x\"));\n+    assertTrue(testLocalValue(\"void 0\"));\n+    \n+    assertFalse(testLocalValue(\"{}.x\"));\n+  }\n+\n+  private boolean testLocalValue(String js) {\n+    Node script = parse(\"var test = \" + js +\";\");\n+    Preconditions.checkState(script.getType() == Token.SCRIPT);\n+    Node var = script.getFirstChild();\n+    Preconditions.checkState(var.getType() == Token.VAR);\n+    Node name = var.getFirstChild();\n+    Preconditions.checkState(name.getType() == Token.NAME);\n+    Node value = name.getFirstChild();\n+\n+    return NodeUtil.evaluatesToLocalValue(value);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n   }\n \n   public void testAnnotationInExterns_new4() throws Exception {\n-    // TODO(johnlenz): We would like the entire expression containing\n-    // \"externObjSEThisMethod\" to be considered side-effect free\n-    // in this context, but not yet, and maybe not here.\n+    // The entire expression containing \"externObjSEThisMethod\" is considered\n+    // side-effect free in this context.\n     checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n-        ImmutableList.<String>of(\"externObjSEThis\"));\n+        ImmutableList.<String>of(\n+            \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n   }\n \n   public void testAnnotationInExterns_new5() throws Exception {\n         \"  new externObjSEThis().externObjSEThisMethod('') \" +\n         \"};\" +\n         \"f();\",\n-        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n+        ImmutableList.<String>of(\n+            \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n   }\n \n   public void testAnnotationInExterns_new7() throws Exception {\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n   }\n \n-  public void testLocalValue1() throws Exception {\n-    // Names are not known to be local.\n-    assertFalse(testLocalValue(\"x\"));\n-    assertFalse(testLocalValue(\"x()\"));\n-    assertFalse(testLocalValue(\"this\"));\n-    assertFalse(testLocalValue(\"arguments\"));\n-\n-    // new objects are local\n-    assertTrue(testLocalValue(\"new x()\"));\n-\n-    // property references are assume to be non-local\n-    assertFalse(testLocalValue(\"(new x()).y\"));\n-    assertFalse(testLocalValue(\"(new x())['y']\"));\n-\n-    // Primitive values are local\n-    assertTrue(testLocalValue(\"null\"));\n-    assertTrue(testLocalValue(\"undefined\"));\n-    assertTrue(testLocalValue(\"Infinity\"));\n-    assertTrue(testLocalValue(\"NaN\"));\n-    assertTrue(testLocalValue(\"1\"));\n-    assertTrue(testLocalValue(\"'a'\"));\n-    assertTrue(testLocalValue(\"true\"));\n-    assertTrue(testLocalValue(\"false\"));\n-    assertTrue(testLocalValue(\"[]\"));\n-    assertTrue(testLocalValue(\"{}\"));\n-\n-    // The contents of arrays and objects don't matter\n-    assertTrue(testLocalValue(\"[x]\"));\n-    assertTrue(testLocalValue(\"{'a':x}\"));\n-\n-    // Pre-increment results in primitive number\n-    assertTrue(testLocalValue(\"++x\"));\n-    assertTrue(testLocalValue(\"--x\"));\n-\n-    // Post-increment, the previous value matters.\n-    assertFalse(testLocalValue(\"x++\"));\n-    assertFalse(testLocalValue(\"x--\"));\n-\n-    // Only the right side of an assign matters\n-    assertTrue(testLocalValue(\"x=1\"));\n-    assertFalse(testLocalValue(\"x=y\"));\n-    // The right hand side of assignment opts don't matter, as they force\n-    // a local result.\n-    assertTrue(testLocalValue(\"x+=y\"));\n-    assertTrue(testLocalValue(\"x*=y\"));\n-    // Comparisons always result in locals, as they force a local boolean\n-    // result.\n-    assertTrue(testLocalValue(\"x==y\"));\n-    assertTrue(testLocalValue(\"x!=y\"));\n-    assertTrue(testLocalValue(\"x>y\"));\n-    // Only the right side of a comma matters\n-    assertTrue(testLocalValue(\"(1,2)\"));\n-    assertTrue(testLocalValue(\"(x,1)\"));\n-    assertFalse(testLocalValue(\"(x,y)\"));\n-\n-    // Both the operands of OR matter\n-    assertTrue(testLocalValue(\"1||2\"));\n-    assertFalse(testLocalValue(\"x||1\"));\n-    assertFalse(testLocalValue(\"x||y\"));\n-    assertFalse(testLocalValue(\"1||y\"));\n-\n-    // Both the operands of AND matter\n-    assertTrue(testLocalValue(\"1&&2\"));\n-    assertFalse(testLocalValue(\"x&&1\"));\n-    assertFalse(testLocalValue(\"x&&y\"));\n-    assertFalse(testLocalValue(\"1&&y\"));\n-\n-    // Only the results of HOOK matter\n-    assertTrue(testLocalValue(\"x?1:2\"));\n-    assertFalse(testLocalValue(\"x?x:2\"));\n-    assertFalse(testLocalValue(\"x?1:x\"));\n-    assertFalse(testLocalValue(\"x?x:y\"));\n-\n-    // Results of ops are local values\n-    assertTrue(testLocalValue(\"!y\"));\n-    assertTrue(testLocalValue(\"~y\"));\n-    assertTrue(testLocalValue(\"y + 1\"));\n-    assertTrue(testLocalValue(\"y + z\"));\n-    assertTrue(testLocalValue(\"y * z\"));\n-\n-    assertTrue(testLocalValue(\"'a' in x\"));\n-    assertTrue(testLocalValue(\"typeof x\"));\n-    assertTrue(testLocalValue(\"x instanceof y\"));\n-\n-    assertTrue(testLocalValue(\"void x\"));\n-    assertTrue(testLocalValue(\"void 0\"));\n-  }\n-\n-  boolean testLocalValue(String js) {\n-     Node root = this.parseExpectedJs(\"var test = \" + js +\";\");\n-     Preconditions.checkState(root.getType() == Token.BLOCK);\n-     Node script = root.getFirstChild();\n-     Preconditions.checkState(script.getType() == Token.SCRIPT);\n-     Node var = script.getFirstChild();\n-     Preconditions.checkState(var.getType() == Token.VAR);\n-     Node name = var.getFirstChild();\n-     Preconditions.checkState(name.getType() == Token.NAME);\n-     Node value = name.getFirstChild();\n-\n-     return PureFunctionIdentifier.isKnownLocalValue(value);\n-\n-  }\n-\n   void checkMarkedCalls(String source, List<String> expected) {\n     testSame(source);\n     assertEquals(expected, noSideEffectCalls);", "timestamp": 1285629418, "metainfo": ""}