{"sha": "27fb062582e27295e55c53eb6d93a9f5068dc216", "log": "Add support for declared catch expressions types  R=dimvar DELTA=76  (59 added, 3 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5811   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n    * Any value can be thrown, so it's really impossible to determine the type\n    * of a CATCH param. Treat it as the UNKNOWN type.\n    */\n-  private FlowScope traverseCatch(Node n, FlowScope scope) {\n-    Node name = n.getFirstChild();\n-    JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+  private FlowScope traverseCatch(Node catchNode, FlowScope scope) {\n+    Node name = catchNode.getFirstChild();\n+    String varName = name.getString();\n+    JSType type;\n+    // If the catch expression name was declared in the catch use that type,\n+    // otherwise use \"unknown\".\n+    JSDocInfo info = name.getJSDocInfo();\n+    if (info != null && info.hasType()) {\n+      type = info.getType().evaluate(syntacticScope, registry);\n+    } else {\n+      type = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+    }\n+    redeclareSimpleVar(scope, name, type);\n     name.setJSType(type);\n-    redeclareSimpleVar(scope, name, type);\n     return scope;\n   }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n                child != null;\n                child = child.getNext()) {\n             if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n-              defineFunctionLiteral(child, n);\n+              defineFunctionLiteral(child);\n             }\n           }\n         }\n \n           // Hoisted functions are handled during pre-traversal.\n           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n-            defineFunctionLiteral(n, parent);\n+            defineFunctionLiteral(n);\n           }\n           break;\n \n           break;\n \n         case Token.CATCH:\n-          defineCatch(n, parent);\n+          defineCatch(n);\n           break;\n \n         case Token.VAR:\n-          defineVar(n, parent);\n+          defineVar(n);\n           break;\n \n         case Token.GETPROP:\n     /**\n      * Defines a catch parameter.\n      */\n-    void defineCatch(Node n, Node parent) {\n+    void defineCatch(Node n) {\n       assertDefinitionNode(n, Token.CATCH);\n       Node catchName = n.getFirstChild();\n-      defineSlot(catchName, n, null);\n+      defineSlot(catchName, n,\n+          getDeclaredType(\n+              sourceName, catchName.getJSDocInfo(), catchName, null));\n     }\n \n     /**\n      * Defines a VAR initialization.\n      */\n-    void defineVar(Node n, Node parent) {\n+    void defineVar(Node n) {\n       assertDefinitionNode(n, Token.VAR);\n       JSDocInfo info = n.getJSDocInfo();\n       if (n.hasMoreThanOneChild()) {\n           compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n         }\n         for (Node name : n.children()) {\n-          defineName(name, n, parent, name.getJSDocInfo());\n+          defineName(name, n, name.getJSDocInfo());\n         }\n       } else {\n         Node name = n.getFirstChild();\n-        defineName(name, n, parent,\n-            (info != null) ? info : name.getJSDocInfo());\n+        defineName(name, n, (info != null) ? info : name.getJSDocInfo());\n       }\n     }\n \n     /**\n      * Defines a function literal.\n      */\n-    void defineFunctionLiteral(Node n, Node parent) {\n+    void defineFunctionLiteral(Node n) {\n       assertDefinitionNode(n, Token.FUNCTION);\n \n       // Determine the name and JSDocInfo and l-value for the function.\n      * @param name The {@link Token#NAME} node.\n      * @param var The parent of the {@code name} node, which must be a\n      *     {@link Token#VAR} node.\n-     * @param parent {@code var}'s parent.\n      * @param info the {@link JSDocInfo} information relating to this\n      *     {@code name} node.\n      */\n-    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n+    private void defineName(Node name, Node var, JSDocInfo info) {\n       Node value = name.getFirstChild();\n \n       // variable's type\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"required: string\");\n   }\n \n+  public void testCatchExpression1() throws Exception {\n+    testTypes(\n+        \"function fn() {\" +\n+        \"  /** @type {number} */\" +\n+        \"  var out = 0;\" +\n+        \"  try {\\n\" +\n+        \"    foo();\\n\" +\n+        \"  } catch (/** @type {string} */ e) {\\n\" +\n+        \"    out = e;\" +\n+        \"  }\" +\n+        \"}\\n\",\n+        \"assignment\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testCatchExpression2() throws Exception {\n+    testTypes(\n+        \"function fn() {\" +\n+        \"  /** @type {number} */\" +\n+        \"  var out = 0;\" +\n+        \"  /** @type {string} */\" +\n+        \"  var e;\" +\n+        \"  try {\\n\" +\n+        \"    foo();\\n\" +\n+        \"  } catch (e) {\\n\" +\n+        \"    out = e;\" +\n+        \"  }\" +\n+        \"}\\n\");\n+  }\n+\n   private void testTypes(String js) throws Exception {\n     testTypes(js, (String) null);\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertEquals(\"number\", lastLocalScope.getVar(\"x\").getType().toString());\n   }\n \n+  public void testDeclaredCatchExpression1() {\n+    testSame(\n+        \"try {} catch (e) {}\");\n+    // Note: \"e\" actually belongs to a inner scope but we don't\n+    // model catches as separate scopes currently.\n+    assertEquals(null, globalScope.getVar(\"e\").getType());\n+  }\n+\n+  public void testDeclaredCatchExpression2() {\n+    testSame(\n+        \"try {} catch (/** @type {string} */ e) {}\");\n+    // Note: \"e\" actually belongs to a inner scope but we don't\n+    // model catches as separate scopes currently.\n+    assertEquals(\"string\", globalScope.getVar(\"e\").getType().toString());\n+  }\n+\n   private JSType findNameType(final String name, Scope scope) {\n     return findTypeOnMatchedNode(new Predicate<Node>() {\n       @Override public boolean apply(Node n) {", "timestamp": 1352856297, "metainfo": ""}