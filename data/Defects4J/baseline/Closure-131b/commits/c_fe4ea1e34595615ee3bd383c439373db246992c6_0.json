{"sha": "fe4ea1e34595615ee3bd383c439373db246992c6", "log": "Refactor PerformanceTracker and allow tracking of negative diffs for size increases.  R=acleung DELTA=139 (49 added, 46 deleted, 44 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6094   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n       \"JSC_MISSING_ENTRY_ERROR\",\n       \"required entry point \\\"{0}\\\" never provided\");\n \n+  // Used in PerformanceTracker\n+  static final String PARSING_PASS_NAME = \"parseInputs\";\n+\n   private static final String CONFIG_RESOURCE =\n       \"com.google.javascript.jscomp.parsing.ParserConfig\";\n \n       addChangeHandler(tracker.getCodeChangeHandler());\n     }\n \n-    Tracer tracer = newTracer(\"parseInputs\");\n+    Tracer tracer = newTracer(PARSING_PASS_NAME);\n \n     try {\n       // Parse externs sources.\n       }\n       return externAndJsRoot;\n     } finally {\n-      stopTracer(tracer, \"parseInputs\");\n+      stopTracer(tracer, PARSING_PASS_NAME);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n   private final Node jsRoot;\n   private final boolean trackSize;\n-  private final boolean trackGzippedSize;\n+  private final boolean trackGzSize;\n \n   // Keeps track of AST changes and computes code size estimation\n   // if there is any.\n   private final RecentChange codeChange = new RecentChange();\n \n-  private int curCodeSizeEstimate = -1;\n-  private int curZippedCodeSizeEstimate = -1;\n+  private int codeSize = 0;\n+  private int gzCodeSize = 0;\n+  private int initCodeSize = 0;\n+  private int initGzCodeSize = 0;\n \n   private Deque<String> currentRunningPass = new ArrayDeque<String>();\n \n     switch (mode) {\n       case TIMING_ONLY:\n         this.trackSize = false;\n-        this.trackGzippedSize = false;\n+        this.trackGzSize = false;\n         break;\n \n       case RAW_SIZE:\n         this.trackSize = true;\n-        this.trackGzippedSize = false;\n+        this.trackGzSize = false;\n         break;\n \n       case ALL:\n         this.trackSize = true;\n-        this.trackGzippedSize = true;\n+        this.trackGzSize = true;\n         break;\n \n       case OFF:\n    * @param result Execution time.\n    */\n   void recordPassStop(String passName, long result) {\n-    String currentPassName = currentRunningPass.pop();\n-    if (!passName.equals(currentPassName)) {\n+    if (!passName.equals(currentRunningPass.pop())) {\n       throw new RuntimeException(passName + \" is not running.\");\n     }\n \n-    CodeSizeEstimatePrinter printer = null;\n-    if (codeChange.hasCodeChanged() && (trackSize || trackGzippedSize)) {\n-      printer = estimateCodeSize(jsRoot);\n-    }\n-\n-    Stats logStats = new Stats(currentPassName);\n+    // After parsing, initialize codeSize and gzCodeSize\n+    if (passName.equals(Compiler.PARSING_PASS_NAME) && trackSize) {\n+      CodeSizeEstimatePrinter printer = new CodeSizeEstimatePrinter();\n+      CodeGenerator.forCostEstimation(printer).add(jsRoot);\n+      initCodeSize = codeSize = printer.calcSize();\n+      if (this.trackGzSize) {\n+        initGzCodeSize = gzCodeSize = printer.calcZippedSize();\n+      }\n+    }\n+\n+    // Initialize logStats and summaryStats\n+    Stats logStats = new Stats(passName);\n     log.add(logStats);\n-    updateStats(logStats, result, printer);\n-\n     Stats summaryStats = summary.get(passName);\n     if (summaryStats == null) {\n       summaryStats = new Stats(passName);\n       summary.put(passName, summaryStats);\n     }\n-    updateStats(summaryStats, result, printer);\n-\n-    if (printer != null) {\n+\n+    // Update fields that aren't related to code size\n+    logStats.runtime = result;\n+    logStats.runs = 1;\n+    summaryStats.runtime += result;\n+    summaryStats.runs += 1;\n+    if (codeChange.hasCodeChanged()) {\n+      logStats.changes = 1;\n+      summaryStats.changes += 1;\n+    }\n+\n+    // Update fields related to code size\n+    if (codeChange.hasCodeChanged() && trackSize) {\n+      int newSize = 0;\n+      CodeSizeEstimatePrinter printer = new CodeSizeEstimatePrinter();\n+      CodeGenerator.forCostEstimation(printer).add(jsRoot);\n       if (trackSize) {\n-        curCodeSizeEstimate = printer.calcSize();\n-      }\n-      if (trackGzippedSize) {\n-        curZippedCodeSizeEstimate = printer.calcZippedSize();\n-      }\n-    }\n-  }\n-\n-  private void updateStats(Stats stats,\n-      long result, CodeSizeEstimatePrinter printer) {\n-    stats.runtime += result;\n-    stats.runs += 1;\n-    if (codeChange.hasCodeChanged()) {\n-      stats.changes += 1;\n-    }\n-\n-    if (printer != null) {\n-      recordSizeChange(\n-          curCodeSizeEstimate, printer.calcSize(), stats);\n-      recordGzSizeChange(\n-          curZippedCodeSizeEstimate, printer.calcZippedSize(), stats);\n-    }\n-  }\n-\n-  /**\n-   * Record the size change in the given record for that given pass.\n-   */\n-  private static void recordSizeChange(int oldSize, int newSize, Stats record) {\n-    if (oldSize != -1) {\n-      int delta = oldSize - newSize;\n-      if (delta > 0) {\n-        record.diff += delta;\n-      }\n-    }\n-    if (newSize != -1) {\n-      record.size = newSize;\n-    }\n-  }\n-\n-  /**\n-   * Record the gzip size change in the given record for that given pass.\n-   */\n-  private static void recordGzSizeChange(\n-      int oldSize, int newSize, Stats record) {\n-    if (oldSize != -1) {\n-      int delta = oldSize - newSize;\n-      if (delta > 0) {\n-        record.gzDiff += delta;\n-      }\n-    }\n-    if (newSize != -1) {\n-      record.gzSize = newSize;\n-    }\n-  }\n-\n-  private final CodeSizeEstimatePrinter estimateCodeSize(Node root) {\n-    CodeSizeEstimatePrinter cp = new CodeSizeEstimatePrinter(trackGzippedSize);\n-    CodeGenerator cg = CodeGenerator.forCostEstimation(cp);\n-    cg.add(root);\n-    return cp;\n+        newSize = printer.calcSize();\n+        logStats.diff = codeSize - newSize;\n+        summaryStats.diff += logStats.diff;\n+        codeSize = summaryStats.size = logStats.size = newSize;\n+      }\n+      if (trackGzSize) {\n+        newSize = printer.calcZippedSize();\n+        logStats.gzDiff = gzCodeSize - newSize;\n+        summaryStats.gzDiff += logStats.gzDiff;\n+        gzCodeSize = summaryStats.gzSize = logStats.gzSize = newSize;\n+      }\n+    }\n   }\n \n   public ImmutableMap<String, Stats> getStats() {\n         gzDiff += stats.gzDiff;\n         output.write(\"\\n\");\n       }\n+      Preconditions.checkState(!trackSize || initCodeSize == diff + codeSize);\n+      Preconditions.checkState(!trackGzSize ||\n+          initGzCodeSize == gzDiff + gzCodeSize);\n+\n       output.write(\"TOTAL\");\n       output.write(\",\");\n       output.write(String.valueOf(runtime));\n   /**\n    * Purely use to get a code size estimate and not generate any code at all.\n    */\n-  private static final class CodeSizeEstimatePrinter extends CodeConsumer {\n-    private final boolean trackGzippedSize;\n+  private final class CodeSizeEstimatePrinter extends CodeConsumer {\n     private int size = 0;\n     private char lastChar = '\\0';\n     private final ByteArrayOutputStream output = new ByteArrayOutputStream();\n     private final GZIPOutputStream stream;\n \n-    private CodeSizeEstimatePrinter(boolean trackGzippedSize) {\n-      this.trackGzippedSize = trackGzippedSize;\n-\n+    private CodeSizeEstimatePrinter() {\n       try {\n         stream = new GZIPOutputStream(output);\n       } catch (IOException e) {\n       if (len > 0) {\n         size += len;\n         lastChar = str.charAt(len - 1);\n-        if (trackGzippedSize) {\n+        if (trackGzSize) {\n           try {\n             stream.write(str.getBytes());\n           } catch (IOException e) {\n       return size;\n     }\n \n+    // Called iff trackGzSize is true\n     private int calcZippedSize() {\n-      if (trackGzippedSize) {\n-        try {\n-          stream.finish();\n-          stream.flush();\n-          stream.close();\n-          return output.size();\n-        } catch (IOException e) {\n-          throw new RuntimeException(e);\n-        }\n-      } else {\n-        return -1;\n+      try {\n+        stream.finish();\n+        stream.flush();\n+        stream.close();\n+        return output.size();\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.regex.Pattern;\n \n /**\n  * Tests for {@link PassFactory}.\n     test(options, original.toString(), \"var x = \" + numAdds + \";\");\n   }\n \n+  // Checks that the summary and the log in the output of PerformanceTracker\n+  // have the expected number of columns\n+  public void testPerfTracker() {\n+    ByteArrayOutputStream output = new ByteArrayOutputStream();\n+    PrintStream outstream = new PrintStream(output);\n+    Compiler compiler = new Compiler(outstream);\n+    CompilerOptions options = new CompilerOptions();\n+    List<SourceFile> inputs = Lists.newArrayList();\n+    List<SourceFile> externs = Lists.newArrayList();\n+\n+    options.setTracerMode(TracerMode.ALL);\n+    inputs.add(SourceFile.fromCode(\"foo\", \"function fun(){}\"));\n+    compiler.compile(externs, inputs, options);\n+    outstream.flush();\n+    outstream.close();\n+    Pattern p = Pattern.compile(\n+        \".*Summary:.pass,runtime,runs,changingRuns,reduction,gzReduction\" +\n+        \".*TOTAL,[0-9]+,[0-9]+,[0-9]+,[0-9]+,[0-9]+[^,]\" +\n+        \".*Log:.\" +\n+        \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize.*\",\n+        Pattern.DOTALL);\n+    assertTrue(p.matcher(output.toString()).matches());\n+  }\n+\n   /** Creates a CompilerOptions object with google coding conventions. */\n   @Override\n   protected CompilerOptions createCompilerOptions() {", "timestamp": 1357692231, "metainfo": ""}