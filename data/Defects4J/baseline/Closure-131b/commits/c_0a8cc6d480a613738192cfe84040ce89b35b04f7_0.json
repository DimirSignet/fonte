{"sha": "0a8cc6d480a613738192cfe84040ce89b35b04f7", "log": "Fix a normalization verifcation bug discovered when reviewing unused variables.  R=dimvar DELTA=43 (33 added, 3 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6093   ", "commit": "\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n         }\n       }\n \n+      // If we ran normalize on the AST, we must also run normalize on the\n+      // clone before checking for changes.\n       if (normalizeEnabled) {\n         normalizeActualCode(compiler, externsRootClone, mainRootClone);\n       }\n \n       // Verify normalization is not invalidated.\n       Node normalizeCheckRootClone = root.cloneTree();\n-      Node normalizeCheckExternsRootClone = root.getFirstChild();\n-      Node normalizeCheckMainRootClone = root.getLastChild();\n+      Node normalizeCheckExternsRootClone = normalizeCheckRootClone.getFirstChild();\n+      Node normalizeCheckMainRootClone = normalizeCheckRootClone.getLastChild();\n       new PrepareAst(compiler).process(\n           normalizeCheckExternsRootClone, normalizeCheckMainRootClone);\n       String explanation =\n       // TODO(johnlenz): enable this for most test cases.\n       // Currently, this invalidates test for while-loops, for-loop\n       // initializers, and other naming.  However, a set of code\n-      // (FoldConstants, etc) runs before the Normalize pass, so this can't be\n-      // force on everywhere.\n+      // (Closure primitive rewrites, etc) runs before the Normalize pass,\n+      // so this can't be force on everywhere.\n       if (normalizeEnabled) {\n         new Normalize(compiler, true).process(\n             normalizeCheckExternsRootClone, normalizeCheckMainRootClone);\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private boolean useGoogleCodingConvention = true;\n   private boolean generatePseudoNames = false;\n   private boolean shouldShadow = false;\n+  private boolean withNormalize = false;\n \n   @Override\n   protected CodingConvention getCodingConvention() {\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n+    CompilerPass pass;\n     if (withClosurePass) {\n-      return new ClosurePassAndRenameVars(compiler);\n+      pass = new ClosurePassAndRenameVars(compiler);\n     } else {\n-      return renameVars = new RenameVars(compiler, prefix,\n+      pass =  renameVars = new RenameVars(compiler, prefix,\n           localRenamingOnly, preserveFunctionExpressionNames,\n           generatePseudoNames, shouldShadow,\n           previouslyUsedMap, null, null);\n     }\n+\n+    if (withNormalize) {\n+      // Don't use the standard CompilerTestCase normalization options\n+      // as renaming is a post denormalization operation, but we do still\n+      // want to run the normal normalizations on the input in some cases.\n+      pass = new NormalizePassWrapper(compiler, pass);\n+    }\n+\n+    return pass;\n   }\n \n   @Override\n     previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of());\n     prefix = DEFAULT_PREFIX;\n     withClosurePass = false;\n+    withNormalize = false;\n     localRenamingOnly = false;\n     preserveFunctionExpressionNames = false;\n     generatePseudoNames = false;\n   }\n \n   public void testDollarSignSuperExport2() {\n-    boolean normalizedExpectedJs = false;\n-    super.enableNormalize(false);\n+    withNormalize = true;\n \n     useGoogleCodingConvention = false;\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n             \"var y = function($super,duper){};\",\n          \"var c = function($super,   a,    b         ){};\" +\n             \"var d = function($super,a){};\");\n-\n-    super.disableNormalize();\n   }\n \n   public void testPseudoNames() {\n       renameVars.process(externs, root);\n     }\n   }\n+\n+  private class NormalizePassWrapper implements CompilerPass {\n+    private final Compiler compiler;\n+    private CompilerPass wrappedPass;\n+\n+    private NormalizePassWrapper(Compiler compiler,\n+        CompilerPass wrappedPass) {\n+      this.compiler = compiler;\n+      this.wrappedPass = wrappedPass;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      Normalize normalize = new Normalize(compiler, false);\n+      normalize.process(externs, root);\n+\n+      wrappedPass.process(externs, root);\n+    }\n+  }\n }", "timestamp": 1357684349, "metainfo": ""}