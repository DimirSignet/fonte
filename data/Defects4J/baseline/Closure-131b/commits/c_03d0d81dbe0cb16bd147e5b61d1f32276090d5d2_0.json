{"sha": "03d0d81dbe0cb16bd147e5b61d1f32276090d5d2", "log": "More rhino_ast dead code stripping.  R=nicksantos DELTA=1695  (48 added, 1552 deleted, 95 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3652   ", "commit": "\n--- a/src/com/google/javascript/rhino/EvaluatorException.java\n+++ b/src/com/google/javascript/rhino/EvaluatorException.java\n /**\n  * The class of exceptions thrown by the JavaScript engine.\n  */\n-public class EvaluatorException extends RhinoException\n-{\n+public class EvaluatorException extends RhinoException {\n     static final long serialVersionUID = -8743165779676009808L;\n \n-    public EvaluatorException(String detail)\n-    {\n+    public EvaluatorException(String detail) {\n         super(detail);\n     }\n \n      * @param lineNumber the line number of the source\n      */\n     public EvaluatorException(String detail, String sourceName,\n-                              int lineNumber)\n-    {\n+                              int lineNumber) {\n         this(detail, sourceName, lineNumber, null, 0);\n     }\n \n      *                   null if unknown)\n      */\n     public EvaluatorException(String detail, String sourceName, int lineNumber,\n-                              String lineSource, int columnNumber)\n-    {\n+                              String lineSource, int columnNumber) {\n         super(detail);\n         recordErrorOrigin(sourceName, lineNumber, lineSource, columnNumber);\n     }\n--- a/src/com/google/javascript/rhino/Kit.java\n+++ b/src/com/google/javascript/rhino/Kit.java\n  */\n public class Kit {\n     /**\n-     * If character <tt>c</tt> is a hexadecimal digit, return\n-     * <tt>accumulator</tt> * 16 plus corresponding\n-     * number. Otherise return -1.\n-     */\n-    public static int xDigitToInt(int c, int accumulator)\n-    {\n-        check: {\n-            // Use 0..9 < A..Z < a..z\n-            if (c <= '9') {\n-                c -= '0';\n-                if (0 <= c) { break check; }\n-            } else if (c <= 'F') {\n-                if ('A' <= c) {\n-                    c -= ('A' - 10);\n-                    break check;\n-                }\n-            } else if (c <= 'f') {\n-                if ('a' <= c) {\n-                    c -= ('a' - 10);\n-                    break check;\n-                }\n-            }\n-            return -1;\n-        }\n-        return (accumulator << 4) | c;\n-    }\n-\n-    /**\n      * Throws RuntimeException to indicate failed assertion.\n      * The function never returns and its return type is RuntimeException\n      * only to be able to write <tt>throw Kit.codeBug()</tt> if plain\n      * <tt>Kit.codeBug()</tt> triggers unreachable code error.\n      */\n-    public static RuntimeException codeBug()\n-        throws RuntimeException\n-    {\n+    static RuntimeException codeBug()\n+        throws RuntimeException {\n         RuntimeException ex = new IllegalStateException(\"FAILED ASSERTION\");\n         // Print stack trace ASAP\n         ex.printStackTrace(System.err);\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       boolean printSource,\n       boolean printAnnotations,\n       boolean printType) {\n-    if (Token.shouldPrintTrees()) {\n-        StringBuilder sb = new StringBuilder();\n-        toString(sb, printSource, printAnnotations, printType);\n-        return sb.toString();\n-    }\n-    return String.valueOf(type);\n+    StringBuilder sb = new StringBuilder();\n+    toString(sb, printSource, printAnnotations, printType);\n+    return sb.toString();\n   }\n \n   private void toString(\n       boolean printSource,\n       boolean printAnnotations,\n       boolean printType) {\n-    if (Token.printTrees) {\n-      sb.append(Token.name(type));\n-      if (this instanceof StringNode) {\n+    sb.append(Token.name(type));\n+    if (this instanceof StringNode) {\n+      sb.append(' ');\n+      sb.append(getString());\n+    } else if (type == Token.FUNCTION) {\n+      sb.append(' ');\n+      // In the case of JsDoc trees, the first child is often not a string\n+      // which causes exceptions to be thrown when calling toString or\n+      // toStringTree.\n+      if (first == null || first.getType() != Token.NAME) {\n+        sb.append(\"<invalid>\");\n+      } else {\n+        sb.append(first.getString());\n+      }\n+    } else if (type == Token.NUMBER) {\n+      sb.append(' ');\n+      sb.append(getDouble());\n+    }\n+    if (printSource) {\n+      int lineno = getLineno();\n+      if (lineno != -1) {\n         sb.append(' ');\n-        sb.append(getString());\n-      } else if (type == Token.FUNCTION) {\n-        sb.append(' ');\n-        // In the case of JsDoc trees, the first child is often not a string\n-        // which causes exceptions to be thrown when calling toString or\n-        // toStringTree.\n-        if (first == null || first.getType() != Token.NAME) {\n-          sb.append(\"<invalid>\");\n-        } else {\n-          sb.append(first.getString());\n+        sb.append(lineno);\n+      }\n+    }\n+\n+    if (printAnnotations) {\n+      int[] keys = getSortedPropTypes();\n+      for (int i = 0; i < keys.length; i++) {\n+        int type = keys[i];\n+        PropListItem x = lookupProperty(type);\n+        sb.append(\" [\");\n+        sb.append(propToString(type));\n+        sb.append(\": \");\n+        String value;\n+        switch (type) {\n+          default:\n+            value = x.toString();\n+            break;\n         }\n-      } else if (type == Token.NUMBER) {\n-        sb.append(' ');\n-        sb.append(getDouble());\n-      }\n-      if (printSource) {\n-        int lineno = getLineno();\n-        if (lineno != -1) {\n-          sb.append(' ');\n-          sb.append(lineno);\n-        }\n-      }\n-\n-      if (printAnnotations) {\n-        int[] keys = getSortedPropTypes();\n-        for (int i = 0; i < keys.length; i++) {\n-          int type = keys[i];\n-          PropListItem x = lookupProperty(type);\n-          sb.append(\" [\");\n-          sb.append(propToString(type));\n-          sb.append(\": \");\n-          String value;\n-          switch (type) {\n-            default:\n-              value = x.toString();\n-              break;\n-          }\n-          sb.append(value);\n-          sb.append(']');\n-        }\n-      }\n-\n-      if (printType) {\n-        if (jsType != null) {\n-          String jsTypeString = jsType.toString();\n-          if (jsTypeString != null) {\n-            sb.append(\" : \");\n-            sb.append(jsTypeString);\n-          }\n+        sb.append(value);\n+        sb.append(']');\n+      }\n+    }\n+\n+    if (printType) {\n+      if (jsType != null) {\n+        String jsTypeString = jsType.toString();\n+        if (jsTypeString != null) {\n+          sb.append(\" : \");\n+          sb.append(jsTypeString);\n         }\n       }\n     }\n \n   private static void toStringTreeHelper(Node n, int level, Appendable sb)\n       throws IOException {\n-    if (Token.printTrees) {\n-      for (int i = 0; i != level; ++i) {\n-        sb.append(\"    \");\n-      }\n-      sb.append(n.toString());\n-      sb.append('\\n');\n-      for (Node cursor = n.getFirstChild();\n-           cursor != null;\n-           cursor = cursor.getNext()) {\n-        toStringTreeHelper(cursor, level + 1, sb);\n-      }\n+    for (int i = 0; i != level; ++i) {\n+      sb.append(\"    \");\n+    }\n+    sb.append(n.toString());\n+    sb.append('\\n');\n+    for (Node cursor = n.getFirstChild();\n+         cursor != null;\n+         cursor = cursor.getNext()) {\n+      toStringTreeHelper(cursor, level + 1, sb);\n     }\n   }\n \n   public static String tokenToName(int token) {\n     switch (token) {\n       case Token.ERROR:           return \"error\";\n-      case Token.EOF:             return \"eof\";\n-      case Token.EOL:             return \"eol\";\n       case Token.RETURN:          return \"return\";\n       case Token.BITOR:           return \"bitor\";\n       case Token.BITXOR:          return \"bitxor\";\n--- a/src/com/google/javascript/rhino/RhinoException.java\n+++ b/src/com/google/javascript/rhino/RhinoException.java\n \n package com.google.javascript.rhino;\n \n-import java.io.File;\n-import java.io.FilenameFilter;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-\n /**\n  * The class of exceptions thrown by the JavaScript engine.\n  */\n @SuppressWarnings(\"serial\")\n-public class RhinoException extends RuntimeException\n-{\n-    RhinoException()\n-    {\n+public class RhinoException extends RuntimeException {\n+    RhinoException() {\n     }\n \n-    RhinoException(String details)\n-    {\n+    RhinoException(String details) {\n         super(details);\n     }\n \n-    @Override public final String getMessage()\n-    {\n+    @Override public final String getMessage() {\n         String details = details();\n         if (sourceName == null || lineNumber <= 0) {\n             return details;\n         return buf.toString();\n     }\n \n-    public String details()\n-    {\n+    public String details() {\n         return super.getMessage();\n     }\n \n      * Get the uri of the script source containing the error, or null\n      * if that information is not available.\n      */\n-    public final String sourceName()\n-    {\n+    public final String sourceName() {\n         return sourceName;\n     }\n \n      *\n      * @throws IllegalStateException if the method is called more then once.\n      */\n-    public final void initSourceName(String sourceName)\n-    {\n+    public final void initSourceName(String sourceName) {\n         if (sourceName == null) throw new IllegalArgumentException();\n         if (this.sourceName != null) throw new IllegalStateException();\n         this.sourceName = sourceName;\n      * Returns the line number of the statement causing the error,\n      * or zero if not available.\n      */\n-    public final int lineNumber()\n-    {\n+    public final int lineNumber() {\n         return lineNumber;\n     }\n \n      *\n      * @throws IllegalStateException if the method is called more then once.\n      */\n-    public final void initLineNumber(int lineNumber)\n-    {\n-        if (lineNumber <= 0) throw new IllegalArgumentException(String.valueOf(lineNumber));\n-        if (this.lineNumber > 0) throw new IllegalStateException();\n+    public final void initLineNumber(int lineNumber) {\n+        if (lineNumber <= 0) {\n+          throw new IllegalArgumentException(String.valueOf(lineNumber));\n+        }\n+        if (this.lineNumber > 0) {\n+          throw new IllegalStateException();\n+        }\n         this.lineNumber = lineNumber;\n     }\n \n     /**\n      * The column number of the location of the error, or zero if unknown.\n      */\n-    public final int columnNumber()\n-    {\n+    public final int columnNumber() {\n         return columnNumber;\n     }\n \n      *\n      * @throws IllegalStateException if the method is called more then once.\n      */\n-    public final void initColumnNumber(int columnNumber)\n-    {\n-        if (columnNumber <= 0) throw new IllegalArgumentException(String.valueOf(columnNumber));\n-        if (this.columnNumber > 0) throw new IllegalStateException();\n+    public final void initColumnNumber(int columnNumber) {\n+        if (columnNumber <= 0) {\n+          throw new IllegalArgumentException(String.valueOf(columnNumber));\n+        }\n+        if (this.columnNumber > 0) {\n+          throw new IllegalStateException();\n+        }\n         this.columnNumber = columnNumber;\n     }\n \n     /**\n      * The source text of the line causing the error, or null if unknown.\n      */\n-    public final String lineSource()\n-    {\n+    public final String lineSource() {\n         return lineSource;\n     }\n \n      *\n      * @throws IllegalStateException if the method is called more then once.\n      */\n-    public final void initLineSource(String lineSource)\n-    {\n+    public final void initLineSource(String lineSource) {\n         if (lineSource == null) throw new IllegalArgumentException();\n         if (this.lineSource != null) throw new IllegalStateException();\n         this.lineSource = lineSource;\n     }\n \n     final void recordErrorOrigin(String sourceName, int lineNumber,\n-                                 String lineSource, int columnNumber)\n-    {\n+                                 String lineSource, int columnNumber) {\n         // XXX: for compatibility allow for now -1 to mean 0\n         if (lineNumber == -1) {\n             lineNumber = 0;\n         }\n     }\n \n-    private String generateStackTrace()\n-    {\n-        // The real Rhino code here has been removed.\n-        return \"<No stack trace available>\";\n-    }\n-\n-    /**\n-     * Get a string representing the script stack of this exception.\n-     * If optimization is enabled, this corresponds to all java stack elements\n-     * with a source name ending with \".js\".\n-     * @return a script stack dump\n-     * @since 1.6R6\n-     */\n-    public String getScriptStackTrace()\n-    {\n-        return getScriptStackTrace(new FilenameFilter() {\n-            @Override\n-            public boolean accept(File dir, String name) {\n-                return name.endsWith(\".js\");\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Get a string representing the script stack of this exception.\n-     * If optimization is enabled, this corresponds to all java stack elements\n-     * with a source name matching the <code>filter</code>.\n-     * @param filter the file name filter to determine whether a file is a\n-     *               script file\n-     * @return a script stack dump\n-     * @since 1.6R6\n-     */\n-    public String getScriptStackTrace(FilenameFilter filter)\n-    {\n-        // The real Rhino code here has been removed.\n-        return \"<No stack trace available>\";\n-    }\n-\n-    @Override public void printStackTrace(PrintWriter s)\n-    {\n-        if (interpreterStackInfo == null) {\n-            super.printStackTrace(s);\n-        } else {\n-            s.print(generateStackTrace());\n-        }\n-    }\n-\n-    @Override public void printStackTrace(PrintStream s)\n-    {\n-        if (interpreterStackInfo == null) {\n-            super.printStackTrace(s);\n-        } else {\n-            s.print(generateStackTrace());\n-        }\n-    }\n-\n     private String sourceName;\n     private int lineNumber;\n     private String lineSource;\n     private int columnNumber;\n-\n-    Object interpreterStackInfo;\n-    int[] interpreterLineData;\n }\n--- a/src/com/google/javascript/rhino/ScriptRuntime.java\n+++ b/src/com/google/javascript/rhino/ScriptRuntime.java\n     }\n \n     // It is public so NativeRegExp can access it .\n-    public static boolean isJSLineTerminator(int c)\n-    {\n+    public static boolean isJSLineTerminator(int c) {\n         // Optimization for faster check for eol character:\n         // they do not have 0xDFD0 bits set\n         if ((c & 0xDFD0) != 0) {\n     // A similar problem exists for negative zero.\n     public static final double\n         negativeZero = Double.longBitsToDouble(0x8000000000000000L);\n-\n-    public static final Double NaNobj = new Double(NaN);\n \n     /*\n      * Helper function for toNumber, parseInt, and TokenStream.getToken.\n                     return NaN;\n                 }\n             } else if (radix == 2 || radix == 4 || radix == 8 ||\n-                       radix == 16 || radix == 32)\n-            {\n+                       radix == 16 || radix == 32) {\n                 /* The number may also be inaccurate for one of these bases.\n                  * This happens if the addition in value*radix + digit causes\n                  * a round-down to an even least significant mantissa bit\n         return sum;\n     }\n \n-    public static String escapeString(String s)\n-    {\n+    public static String escapeString(String s) {\n         return escapeString(s, '\"');\n     }\n \n      * For escaping strings printed by object and array literals; not quite\n      * the same as 'escape.'\n      */\n-    public static String escapeString(String s, char escapeQuote)\n-    {\n+    public static String escapeString(String s, char escapeQuote) {\n         if (!(escapeQuote == '\"' || escapeQuote == '\\'')) Kit.codeBug();\n         StringBuffer sb = null;\n \n         return (sb == null) ? s : sb.toString();\n     }\n \n-    static boolean isValidIdentifierName(String s)\n-    {\n+    static boolean isValidIdentifierName(String s) {\n         int L = s.length();\n         if (L == 0)\n             return false;\n      * If str is a decimal presentation of Uint32 value, return it as long.\n      * Othewise return -1L;\n      */\n-    public static long testUint32String(String str)\n-    {\n+    public static long testUint32String(String str) {\n         // The length of the decimal string representation of\n         //  UINT32_MAX_VALUE, 4294967296\n         final int MAX_VALUE_LENGTH = 10;\n         return -1;\n     }\n \n-    static boolean isSpecialProperty(String s)\n-    {\n+    static boolean isSpecialProperty(String s) {\n         return s.equals(\"__proto__\") || s.equals(\"__parent__\");\n     }\n \n     // Statements\n     // ------------------\n \n-    public static String getMessage0(String messageId)\n-    {\n+    public static String getMessage0(String messageId) {\n         return getMessage(messageId, null);\n     }\n \n-    public static String getMessage1(String messageId, Object arg1)\n-    {\n+    public static String getMessage1(String messageId, Object arg1) {\n         Object[] arguments = {arg1};\n-        return getMessage(messageId, arguments);\n-    }\n-\n-    public static String getMessage2(\n-        String messageId, Object arg1, Object arg2)\n-    {\n-        Object[] arguments = {arg1, arg2};\n-        return getMessage(messageId, arguments);\n-    }\n-\n-    public static String getMessage3(\n-        String messageId, Object arg1, Object arg2, Object arg3)\n-    {\n-        Object[] arguments = {arg1, arg2, arg3};\n-        return getMessage(messageId, arguments);\n-    }\n-\n-    public static String getMessage4(\n-        String messageId, Object arg1, Object arg2, Object arg3, Object arg4)\n-    {\n-        Object[] arguments = {arg1, arg2, arg3, arg4};\n         return getMessage(messageId, arguments);\n     }\n \n      * make sense to use a ListResourceBundle instead of a properties\n      * file to avoid (synchronized) text parsing.\n      */\n-    public static String getMessage(String messageId, Object[] arguments)\n-    {\n+    public static String getMessage(String messageId, Object[] arguments) {\n         final String defaultResource\n             = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n \n         MessageFormat formatter = new MessageFormat(formatString);\n         return formatter.format(arguments);\n     }\n-\n-    static boolean isGeneratedScript(String sourceUrl) {\n-        // ALERT: this may clash with a valid URL containing (eval) or\n-        // (Function)\n-        return sourceUrl.indexOf(\"(eval)\") >= 0\n-               || sourceUrl.indexOf(\"(Function)\") >= 0;\n-    }\n-\n-    public static final Object[] emptyArgs = new Object[0];\n-    public static final String[] emptyStrings = new String[0];\n-\n }\n--- a/src/com/google/javascript/rhino/SimpleErrorReporter.java\n+++ b/src/com/google/javascript/rhino/SimpleErrorReporter.java\n \n     @Override\n     public void warning(String message, String sourceName, int line,\n-                        String lineSource, int lineOffset)\n-    {\n+                        String lineSource, int lineOffset) {\n         if (warnings == null) {\n             warnings = new ArrayList<String>();\n         }\n \n     @Override\n     public void error(String message, String sourceName, int line,\n-                      String lineSource, int lineOffset)\n-    {\n+                      String lineSource, int lineOffset) {\n         if (errors == null) {\n             errors = new ArrayList<String>();\n         }\n     @Override\n     public EvaluatorException runtimeError(\n         String message, String sourceName, int line, String lineSource,\n-        int lineOffset)\n-    {\n+        int lineOffset) {\n         return new EvaluatorException(\n             message, sourceName, line, lineSource, lineOffset);\n     }\n     /**\n      * Returns the list of errors, or {@code null} if there were none.\n      */\n-    public List<String> errors()\n-    {\n+    public List<String> errors() {\n         return errors;\n     }\n \n     /**\n      * Returns the list of warnings, or {@code null} if there were none.\n      */\n-    public List<String> warnings()\n-    {\n+    public List<String> warnings() {\n         return warnings;\n     }\n \n     private String formatDetailedMessage(\n         String message, String sourceName, int line, String lineSource,\n-        int lineOffset)\n-    {\n+        int lineOffset) {\n         RhinoException e = new RhinoException(message);\n         if (sourceName != null) {\n           e.initSourceName(sourceName);\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n  *\n  */\n \n-public class Token\n-{\n-\n-    // debug flags\n-    public static final boolean printTrees = true;\n-    public static boolean shouldPrintTrees() {\n-      return printTrees;\n-    }\n-    static final boolean printNames = printTrees;\n-\n+public class Token {\n \n     /**\n      * Token types.  These values correspond to JSTokenType values in\n      * jsscan.c.\n      */\n-\n     public final static int\n-    // start enum\n-        ERROR          = -1, // well-known as the only code < EOF\n-        EOF            = 0,  // end of file token - (not EOF_CHAR)\n-        EOL            = 1,  // end of line\n+        ERROR          = -1,\n \n         RETURN         = 4,\n         BITOR          = 9,\n         LB             = 308,  // left brackets\n         LC             = 309;  // left curly braces\n \n-  public static String name(int token)\n-    {\n-        if (!printNames) {\n-            return String.valueOf(token);\n-        }\n+  public static String name(int token) {\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n           case RETURN:          return \"RETURN\";\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n  * It is based on the C source files jsscan.c and jsscan.h\n  * in the jsref package.\n  *\n- * @see Parser\n- *\n  */\n \n-public class TokenStream\n-{\n-    /*\n-     * For chars - because we need something out-of-range\n-     * to check.  (And checking EOF by exception is annoying.)\n-     * Note distinction from EOF token type!\n-     */\n-    private final static int EOF_CHAR = -1;\n-\n+public class TokenStream {\n     public static boolean isKeyword(String s) {\n-        return Token.EOF != stringToKeyword(s);\n+        return Token.ERROR != stringToKeyword(s);\n     }\n \n     private static int stringToKeyword(String name) {\n         }\n // #/generated#\n // #/string_id_map#\n-        if (id == 0) { return Token.EOF; }\n+        if (id == 0) { return Token.ERROR; }\n         return id & 0xff;\n     }\n \n                 if (c == '\\\\') {\n                     if (! ((i + 5) < length)\n                         && (s.charAt(i + 1) == 'u')\n-                        && 0 <= Kit.xDigitToInt(s.charAt(i + 2), 0)\n-                        && 0 <= Kit.xDigitToInt(s.charAt(i + 3), 0)\n-                        && 0 <= Kit.xDigitToInt(s.charAt(i + 4), 0)\n-                        && 0 <= Kit.xDigitToInt(s.charAt(i + 5), 0)) {\n+                        && 0 <= xDigitToInt(s.charAt(i + 2), 0)\n+                        && 0 <= xDigitToInt(s.charAt(i + 3), 0)\n+                        && 0 <= xDigitToInt(s.charAt(i + 4), 0)\n+                        && 0 <= xDigitToInt(s.charAt(i + 5), 0)) {\n                         return true;\n                      }\n                 }\n         return true;\n     }\n \n-    private static boolean isAlpha(int c) {\n-        // Use 'Z' < 'a'\n-        if (c <= 'Z') {\n-            return 'A' <= c;\n-        } else {\n-            return 'a' <= c && c <= 'z';\n+    /**\n+     * If character <tt>c</tt> is a hexadecimal digit, return\n+     * <tt>accumulator</tt> * 16 plus corresponding\n+     * number. Otherise return -1.\n+     */\n+    private static int xDigitToInt(int c, int accumulator) {\n+        check: {\n+            // Use 0..9 < A..Z < a..z\n+            if (c <= '9') {\n+                c -= '0';\n+                if (0 <= c) { break check; }\n+            } else if (c <= 'F') {\n+                if ('A' <= c) {\n+                    c -= ('A' - 10);\n+                    break check;\n+                }\n+            } else if (c <= 'f') {\n+                if ('a' <= c) {\n+                    c -= ('a' - 10);\n+                    break check;\n+                }\n+            }\n+            return -1;\n         }\n-    }\n-\n-    static boolean isDigit(int c) {\n-        return '0' <= c && c <= '9';\n-    }\n-\n-    /**\n-     * Tests whether the character is a valid JavaScript white space character\n-     * as defined in ECMAScript 3rd edition.\n-     *\n-     * Note:  jsscan.c uses C isspace() (which allows\n-     * \\v, I think.)  note that code in getChar() implicitly accepts\n-     * '\\r' == \\u000D as well.\n-     */\n-    static boolean isJSSpace(int c) {\n-        if (c <= 127) {\n-            return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n-        } else {\n-            return c == 0xA0\n-                || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n-        }\n-    }\n-\n-    private static boolean isJSFormatChar(int c) {\n-        return c > 127 && Character.getType((char)c) == Character.FORMAT;\n+        return (accumulator << 4) | c;\n     }\n }", "timestamp": 1320774661, "metainfo": ""}