{"sha": "ecb54cefac4add529606f2eedfc2316489d71d7d", "log": "Add anonymous functions to the symbol table  R=acleung DELTA=59  (54 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3580   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TreeSet;\n \n import javax.annotation.Nullable;\n \n    * All syntactic scopes in the program, uniquely identified by the node where\n    * they're declared.\n    */\n-  private final Map<Node, SymbolScope> scopes = Maps.newHashMap();\n+  private final Map<Node, SymbolScope> scopes = Maps.newLinkedHashMap();\n \n   /**\n    * All JSDocInfo in the program.\n   }\n \n   /** Gets all the scopes in this symbol table. */\n-  Collection<SymbolScope> getAllScopes() {\n+  public Collection<SymbolScope> getAllScopes() {\n     return Collections.unmodifiableCollection(scopes.values());\n+  }\n+\n+  /**\n+   * Finds anonymous functions in local scopes, and gives them names\n+   * and symbols. They will show up as local variables with names\n+   * \"function%0\", \"function%1\", etc.\n+   */\n+  public void addAnonymousFunctions() {\n+    TreeSet<SymbolScope> scopes = Sets.newTreeSet(LEXICAL_SCOPE_ORDERING);\n+    for (SymbolScope scope : getAllScopes()) {\n+      if (scope.isLexicalScope()) {\n+        scopes.add(scope);\n+      }\n+    }\n+\n+    for (SymbolScope scope : scopes) {\n+      addAnonymousFunctionsInScope(scope);\n+    }\n+  }\n+\n+  private void addAnonymousFunctionsInScope(SymbolScope scope) {\n+    Symbol sym = getSymbolForScope(scope);\n+    if (sym == null) {\n+      // JSCompiler has no symbol for this scope. Check to see if it's a\n+      // local function. If it is, give it a name.\n+      if (scope.isLexicalScope() &&\n+          !scope.isGlobalScope() &&\n+          scope.getParentScope() != null) {\n+        SymbolScope parent = scope.getParentScope();\n+\n+        int count = parent.innerAnonFunctionsWithNames++;\n+        String innerName = \"function%\" + count;\n+        scope.setSymbolForScope(\n+            declareInferredSymbol(\n+                parent, innerName, scope.getRootNode()));\n+      }\n+    }\n   }\n \n   /**\n     private final JSType typeOfThis;\n     private final Map<String, Symbol> ownSymbols = Maps.newHashMap();\n     private final int scopeDepth;\n+\n+    // The number of inner anonymous functions that we've given names to.\n+    private int innerAnonFunctionsWithNames = 0;\n \n     // The symbol associated with a property scope.\n     private Symbol mySymbol;\n     }\n   };\n \n+  private final Ordering<SymbolScope> LEXICAL_SCOPE_ORDERING =\n+      new Ordering<SymbolScope>() {\n+    @Override\n+    public int compare(SymbolScope a, SymbolScope b) {\n+      Preconditions.checkState(a.isLexicalScope() && b.isLexicalScope(),\n+                               \"We can only sort lexical scopes\");\n+      return NODE_ORDERING.compare(a.getRootNode(), b.getRootNode());\n+    }\n+  };\n+\n   private final Ordering<Symbol> SYMBOL_ORDERING = new Ordering<Symbol>() {\n     @Override\n     public int compare(Symbol a, Symbol b) {", "timestamp": 1319837695, "metainfo": ""}