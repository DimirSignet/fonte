{"sha": "8eac7e1fa30f431056d01c9603b5337a4003244c", "log": "Remove the restriction that the \"this\" type of a function declaration must be an ObjectType.  R=nicksantos DELTA=132  (45 added, 45 deleted, 42 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5755   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n \n import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n   private List<ObjectType> implementedInterfaces = null;\n   private List<ObjectType> extendedInterfaces = null;\n   private ObjectType baseType = null;\n-  private ObjectType thisType = null;\n+  private JSType thisType = null;\n   private boolean isConstructor = false;\n   private boolean makesStructs = false;\n   private boolean makesDicts = false;\n     }\n   }\n \n-  private class ThisTypeValidator implements Predicate<JSType> {\n-    @Override\n-    public boolean apply(JSType type) {\n-      // TODO(user): Doing an instanceof check here is too\n-      // restrictive as (Date,Error) is, for instance, an object type\n-      // even though its implementation is a UnionType. Would need to\n-      // create interfaces JSType, ObjectType, FunctionType etc and have\n-      // separate implementation instead of the class hierarchy, so that\n-      // union types can also be object types, etc.\n-      if (!type.restrictByNotNullOrUndefined().isSubtype(\n-              typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n-      }\n-      return true;\n-    }\n-  }\n-\n   /**\n    * @param fnName The function name.\n    * @param compiler The compiler.\n    * @param info The JSDocInfo for this function.\n    */\n   FunctionTypeBuilder inferThisType(JSDocInfo info) {\n-    ObjectType maybeThisType = null;\n+    JSType maybeThisType = null;\n     if (info != null && info.hasThisType()) {\n-      maybeThisType = ObjectType.cast(\n-          info.getThisType().evaluate(scope, typeRegistry));\n+      // TODO(johnlenz): In ES5 strict mode a function can have a null or\n+      // undefined \"this\" value, but all the existing \"@this\" annotations\n+      // don't declare restricted types.\n+      maybeThisType = info.getThisType().evaluate(scope, typeRegistry)\n+          .restrictByNotNullOrUndefined();\n     }\n     if (maybeThisType != null) {\n       thisType = maybeThisType;\n-      thisType.setValidator(new ThisTypeValidator());\n     }\n \n     return this;\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n    * Gets the type of {@code this} in the current scope.\n    */\n   @Override\n-  public ObjectType getTypeOfThis() {\n+  public JSType getTypeOfThis() {\n     if (isGlobal()) {\n       return ObjectType.cast(rootNode.getJSType());\n     }\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n           if (arg.getJSType() != null && arg.getJSType().isFunctionType()) {\n             actions.addAll(getImplicitActionsFromArgument(\n                 arg,\n-                arg.getJSType().toMaybeFunctionType().getTypeOfThis(),\n+                arg.getJSType().toMaybeFunctionType().getTypeOfThis()\n+                    .toObjectType(),\n                 param.getJSType()));\n           }\n         }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       // or GETELEM.\n       if (functionType.isOrdinaryFunction() &&\n           !functionType.getTypeOfThis().isUnknownType() &&\n-          !functionType.getTypeOfThis().isNativeObjectType() &&\n+          !(functionType.getTypeOfThis().toObjectType() != null &&\n+          functionType.getTypeOfThis().toObjectType().isNativeObjectType()) &&\n           !(child.isGetElem() ||\n             child.isGetProp())) {\n         report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       JSType type = functionNode.getJSType();\n       if (type != null && type.isFunctionType()) {\n         FunctionType fnType = type.toMaybeFunctionType();\n-        ObjectType fnThisType = fnType.getTypeOfThis();\n+        JSType fnThisType = fnType.getTypeOfThis();\n         if (!fnThisType.isUnknownType()) {\n           NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n               scopeBuilder.new CollectProperties(fnThisType));\n     }\n     for (Var var : varsToRemove) {\n       globalScope.undeclare(var);\n-      globalScope.getTypeOfThis().removeProperty(var.getName());\n+      globalScope.getTypeOfThis().toObjectType().removeProperty(var.getName());\n     }\n \n     // Now re-traverse the given script.\n      */\n     private final class CollectProperties\n         extends AbstractShallowStatementCallback {\n-      private final ObjectType thisType;\n-\n-      CollectProperties(ObjectType thisType) {\n+      private final JSType thisType;\n+\n+      CollectProperties(JSType thisType) {\n         this.thisType = thisType;\n       }\n \n         JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);\n         Node name = member.getLastChild();\n         if (jsType != null &&\n-            (name.isName() || name.isString())) {\n-          thisType.defineDeclaredProperty(\n+            (name.isName() || name.isString()) &&\n+            thisType.toObjectType() != null) {\n+          thisType.toObjectType().defineDeclaredProperty(\n               name.getString(),\n               jsType,\n               member);\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n   private Node sourceNode = null;\n   private Node parametersNode = null;\n   private JSType returnType = null;\n-  private ObjectType typeOfThis = null;\n+  private JSType typeOfThis = null;\n   private ImmutableList<String> templateKeys = ImmutableList.of();\n   private boolean inferredReturnType = false;\n   private boolean isConstructor = false;\n   }\n \n   /** Set the \"this\" type. */\n-  public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {\n+  public FunctionBuilder withTypeOfThis(JSType typeOfThis) {\n     this.typeOfThis = typeOfThis;\n     return this;\n   }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   /**\n    * The type of {@code this} in the scope of this function.\n    */\n-  private ObjectType typeOfThis;\n+  private JSType typeOfThis;\n \n   /**\n    * The function node which this type represents. It may be {@code null}.\n \n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n-               ArrowType arrowType, ObjectType typeOfThis,\n+               ArrowType arrowType, JSType typeOfThis,\n                ImmutableList<String> templateKeys,\n                boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         call.returnType.getLeastSupertype(other.call.returnType) :\n         call.returnType.getGreatestSubtype(other.call.returnType);\n \n-    ObjectType newTypeOfThis = null;\n+    JSType newTypeOfThis = null;\n     if (isEquivalent(typeOfThis, other.typeOfThis)) {\n       newTypeOfThis = typeOfThis;\n     } else {\n       JSType maybeNewTypeOfThis = leastSuper ?\n           typeOfThis.getLeastSupertype(other.typeOfThis) :\n           typeOfThis.getGreatestSubtype(other.typeOfThis);\n-      if (maybeNewTypeOfThis instanceof ObjectType) {\n-        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n-      } else {\n-        newTypeOfThis = leastSuper ?\n-            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n-            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n-      }\n+      newTypeOfThis = maybeNewTypeOfThis;\n     }\n \n     boolean newReturnTypeInferred =\n         // In practical terms, if C implements I, and I has a method m,\n         // then any m doesn't necessarily have to C#m's 'this'\n         // type doesn't need to match I.\n-        (other.typeOfThis.getConstructor() != null &&\n-             other.typeOfThis.getConstructor().isInterface()) ||\n+        (other.typeOfThis.toObjectType() != null &&\n+             other.typeOfThis.toObjectType().getConstructor() != null &&\n+             other.typeOfThis.toObjectType().getConstructor().isInterface()) ||\n \n         // If one of the 'this' types is covariant of the other,\n         // then we'll treat them as covariant (see comment above).\n    */\n   public ObjectType getInstanceType() {\n     Preconditions.checkState(hasInstanceType());\n-    return typeOfThis;\n+    return typeOfThis.toObjectType();\n   }\n \n   /**\n    * Gets the type of {@code this} in this function.\n    */\n   @Override\n-  public ObjectType getTypeOfThis() {\n-    return typeOfThis.isNoObjectType() ?\n+  public JSType getTypeOfThis() {\n+    return typeOfThis.isEmptyType() ?\n         registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n+++ b/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n \n     boolean changed = false;\n \n-    ObjectType beforeThis = type.getTypeOfThis();\n-    ObjectType afterThis = coerseToThisType(beforeThis.visit(this));\n+    JSType beforeThis = type.getTypeOfThis();\n+    JSType afterThis = coerseToThisType(beforeThis.visit(this));\n     if (beforeThis != afterThis) {\n       changed = true;\n     }\n     return type;\n   }\n \n-  private ObjectType coerseToThisType(JSType type) {\n-    // This isn't quite right, handle autoboxing and \"strict\" mode functions.\n-    ObjectType restricted = type.restrictByNotNullOrUndefined()\n-        .collapseUnion().toObjectType();\n-    return restricted != null ? restricted : registry.getNativeObjectType(\n+  private JSType coerseToThisType(JSType type) {\n+    return type != null ? type : registry.getNativeObjectType(\n         JSTypeNative.UNKNOWN_TYPE);\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   }\n \n   @Override\n-  public ObjectType getTypeOfThis() {\n+  public JSType getTypeOfThis() {\n     return null;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public ObjectType getTypeOfThis() {\n+  public JSType getTypeOfThis() {\n     if (referencedObjType != null) {\n       return referencedObjType.getTypeOfThis();\n     }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n       \"String.prototype.slice = function(sliceArg) {};\" +\n       \"/** @type {number} */ String.prototype.length;\" +\n       \"/** @constructor \\n * @param {*} var_args \\n @return {!Array} */\" +\n-      \"function Array(var_args) {}\" +\n-      \"/** @type {number} */ Array.prototype.length;\" + ACTIVE_X_OBJECT_DEF;\n+      \"function Array(var_args) {}\\n\" +\n+      \"/** @type {number} */ Array.prototype.length;\\n\" +\n+      \"/** @constructor */\\n\" +\n+      \"function Arguments() {}\\n\" +\n+      \"/** @type {number} */\\n\" +\n+      \"Arguments.prototype.length;\\n\" +\n+      \"/** @type {!Arguments} */\\n\" +\n+      \"var arguments;\" +\n+      \"\" + ACTIVE_X_OBJECT_DEF;\n \n   protected Compiler compiler;\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"element BAR does not exist on this enum\");\n   }\n \n-  public void testBackwardsTypedefUse1() throws Exception {\n-    testTypes(\n-        \"/** @this {MyTypedef} */ function f() {}\" +\n-        \"/** @typedef {string} */ var MyTypedef;\",\n-        \"@this type of a function must be an object\\n\" +\n-        \"Actual type: string\");\n-  }\n-\n   public void testBackwardsTypedefUse2() throws Exception {\n     testTypes(\n         \"/** @this {MyTypedef} */ function f() {}\" +\n         \"/** @typedef {!(Date|Array)} */ var MyTypedef;\");\n-  }\n-\n-  public void testBackwardsTypedefUse3() throws Exception {\n-    testTypes(\n-        \"/** @this {MyTypedef} */ function f() {}\" +\n-        \"/** @typedef {(Date|string)} */ var MyTypedef;\",\n-        \"@this type of a function must be an object\\n\" +\n-        \"Actual type: (Date|null|string)\");\n   }\n \n   public void testBackwardsTypedefUse4() throws Exception {\n         \"required: number\");\n   }\n \n+  public void testTemplatedThisType2() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @this {Array.<T>|{length:number}}\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"Array.prototype.method = function() {};\\n\" +\n+        \"(function(){\\n\" +\n+        \"  Array.prototype.method.call(arguments);\" +\n+        \"})();\");\n+  }\n+\n   public void testTemplateType1() throws Exception {\n     testTypes(\n         \"/**\\n\" +\n         \"function f(x, y) {}\\n\" +\n         \"f(g(), function() { h(this); });\",\n         \"actual parameter 1 of h does not match formal parameter\\n\" +\n-        \"found   : Object\\n\" +\n+        \"found   : (Array|F|null)\\n\" +\n         \"required: (F|null)\");\n   }\n \n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertEquals(\"?\", findNameType(\"g\", globalScope).toString());\n   }\n \n+  public void testTemplateType12() {\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"\\n\" +\n+        \"/**\\n\" +\n+        \" * @this {Array.<T>|{length:number}}\\n\" +\n+        \" * @return {T} fn\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"Foo.prototype.method = function() {var g = this;};\\n\");\n+    assertEquals(\"(Array.<T>|{length: number})\",\n+        findNameType(\"g\", lastLocalScope).toString());\n+  }\n+\n   public void testClosureParameterTypesWithoutJSDoc() {\n     testSame(\n         \"/**\\n\" +\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n         .withReturnType(NUMBER_TYPE).build();\n \n     assertLeastSupertype(\n-        \"function (this:Object): (number|string)\", retString, retNumber);\n+        \"function (this:(Array|Date)): (number|string)\", retString, retNumber);\n     assertGreatestSubtype(\n         \"function (this:NoObject): None\", retString, retNumber);\n   }", "timestamp": 1352148586, "metainfo": ""}