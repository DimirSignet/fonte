{"sha": "ad20fd0c59903ace8f89f16a52c528951c7615da", "log": "Some refactoring and tests based on comments in other cls  R=johnlenz DELTA=125  (80 added, 42 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3707   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         // has an authoritative name.\n         String qualifiedName = NodeUtil.getBestLValueName(keyNode);\n         if (qualifiedName != null) {\n-          defineSlot(keyNode, objLit, qualifiedName, keyType, keyType == null);\n+          boolean inferred = keyType == null;\n+          defineSlot(keyNode, objLit, qualifiedName, keyType, inferred);\n         } else if (keyType != null) {\n           setDeferredType(keyNode, keyType);\n         }\n         return;\n       }\n \n-      // NOTE(nicksantos): Determining whether a property is declared or not\n-      // is really really obnoxious.\n-      //\n-      // The problem is that there are two (equally valid) coding styles:\n-      //\n-      // (function() {\n-      //   /* The authoritative definition of goog.bar. */\n-      //   goog.bar = function() {};\n-      // })();\n-      //\n-      // function f() {\n-      //   goog.bar();\n-      //   /* Reset goog.bar to a no-op. */\n-      //   goog.bar = function() {};\n-      // }\n-      //\n-      // In a dynamic language with first-class functions, it's very difficult\n-      // to know which one the user intended without looking at lots of\n-      // contextual information (the second example demonstrates a small case\n-      // of this, but there are some really pathological cases as well).\n-      //\n-      // The current algorithm checks if either the declaration has\n-      // jsdoc type information, or @const with a known type,\n-      // or a function literal with a name we haven't seen before.\n-      boolean inferred = true;\n-      if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType()\n-            || info.hasEnumParameterType()\n-            || (info.isConstant() && valueType != null\n-                && !valueType.isUnknownType())\n-            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-      }\n-\n-      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n-        // Determining declaration for #2\n-        if (info != null) {\n-          inferred = false;\n-        } else if (!scope.isDeclared(qName, false) &&\n-                   n.isUnscopedQualifiedName()) {\n-          inferred = false;\n-        }\n-      }\n-\n+      boolean inferred = isQualifiedNameInferred(\n+          qName, n, info, rhsValue, valueType);\n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n           }\n         }\n       }\n+    }\n+\n+    /**\n+     * Determines whether a qualified name is inferred.\n+     * NOTE(nicksantos): Determining whether a property is declared or not\n+     * is really really obnoxious.\n+     *\n+     * The problem is that there are two (equally valid) coding styles:\n+     *\n+     * (function() {\n+     *   /* The authoritative definition of goog.bar. /\n+     *   goog.bar = function() {};\n+     * })();\n+     *\n+     * function f() {\n+     *   goog.bar();\n+     *   /* Reset goog.bar to a no-op. /\n+     *   goog.bar = function() {};\n+     * }\n+     *\n+     * In a dynamic language with first-class functions, it's very difficult\n+     * to know which one the user intended without looking at lots of\n+     * contextual information (the second example demonstrates a small case\n+     * of this, but there are some really pathological cases as well).\n+     *\n+     * The current algorithm checks if either the declaration has\n+     * jsdoc type information, or @const with a known type,\n+     * or a function literal with a name we haven't seen before.\n+     */\n+    private boolean isQualifiedNameInferred(\n+        String qName, Node n, JSDocInfo info,\n+        Node rhsValue, JSType valueType) {\n+      if (valueType == null) {\n+        return true;\n+      }\n+\n+      boolean inferred = true;\n+      if (info != null) {\n+        inferred = !(info.hasType()\n+            || info.hasEnumParameterType()\n+            || (info.isConstant() && valueType != null\n+                && !valueType.isUnknownType())\n+            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n+      }\n+\n+      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n+        if (info != null) {\n+          inferred = false;\n+        } else if (!scope.isDeclared(qName, false) &&\n+                   n.isUnscopedQualifiedName()) {\n+          inferred = false;\n+        }\n+      }\n+      return inferred;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertEquals(\"number\", yType.toString());\n   }\n \n+  public void testDeclaredObjectLitProperty6() throws Exception {\n+    testSame(\"var x = {/** This is jsdoc */ prop: function(){}};\");\n+    Var prop = globalScope.getVar(\"x.prop\");\n+    JSType propType = prop.getType();\n+    assertEquals(\"function (): undefined\", propType.toString());\n+    assertFalse(prop.isTypeInferred());\n+    assertFalse(\n+        ObjectType.cast(globalScope.getVar(\"x\").getType())\n+        .isPropertyTypeInferred(\"prop\"));\n+  }\n+\n   public void testInferredObjectLitProperty1() throws Exception {\n     testSame(\"var x = {prop: 3};\");\n     Var prop = globalScope.getVar(\"x.prop\");\n     JSType propType = prop.getType();\n     assertEquals(\"number\", propType.toString());\n     assertTrue(prop.isTypeInferred());\n+    assertTrue(\n+        ObjectType.cast(globalScope.getVar(\"x\").getType())\n+        .isPropertyTypeInferred(\"prop\"));\n+  }\n+\n+  public void testInferredObjectLitProperty2() throws Exception {\n+    testSame(\"var x = {prop: function(){}};\");\n+    Var prop = globalScope.getVar(\"x.prop\");\n+    JSType propType = prop.getType();\n+    assertEquals(\"function (): undefined\", propType.toString());\n+    assertTrue(prop.isTypeInferred());\n+    assertTrue(\n+        ObjectType.cast(globalScope.getVar(\"x\").getType())\n+        .isPropertyTypeInferred(\"prop\"));\n   }\n \n   public void testDeclaredConstType1() throws Exception {", "timestamp": 1321376263, "metainfo": ""}