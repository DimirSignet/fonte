{"sha": "d4fd1cb4c14d66eb5dd3acad580f6c36f2f26c48", "log": "Retool error reporting for the DisambiguateProperties pass. Instead of having a global on/off we now report invalidation errors only certain specified properties. This helps the case where dead code removal can strip 10k of \"toObject\" methods as long as that property is valid, but we have tens of thousands of other errors we don't care about.  Also removes error reporting check in TypeValidator.java since it's redundant now.  R=acleung,moedinger DELTA=85  (58 added, 7 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3178   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   // Fixes open source issue: 390\n   boolean operaCompoundAssignFix;\n+\n+  /** List of properties that we report invalidation errors for. */\n+  Map<String, CheckLevel> propertyInvalidationErrors;\n+\n \n   //--------------------------------\n   // Output options\n     replaceStringsFunctionDescriptions = Collections.emptyList();\n     replaceStringsPlaceholderToken = \"\";\n     replaceStringsReservedStrings = Collections.emptySet();\n+    propertyInvalidationErrors = Maps.newHashMap();\n \n     // Output\n     printInputDelimiter = false;\n   public void setAssumeClosuresOnlyCaptureReferences(boolean enable) {\n     this.assumeClosuresOnlyCaptureReferences = enable;\n   }\n+\n+  /**\n+   * Sets the list of properties that we report property invalidation errors\n+   * for.\n+   */\n+  public void setPropertyInvalidationErrors(\n+      Map<String, CheckLevel> propertyInvalidationErrors) {\n+    this.propertyInvalidationErrors =\n+        Maps.newHashMap(propertyInvalidationErrors);\n+  }\n+\n \n   //////////////////////////////////////////////////////////////////////////////\n   // Enums\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       if (tightenTypes == null) {\n-        return DisambiguateProperties.forJSTypeSystem(compiler);\n+        return DisambiguateProperties.forJSTypeSystem(compiler,\n+            options.propertyInvalidationErrors);\n       } else {\n         return DisambiguateProperties.forConcreteTypeSystem(\n-            compiler, tightenTypes);\n+            compiler, tightenTypes, options.propertyInvalidationErrors);\n       }\n     }\n   };\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n         + \"because of type {1} node {2}. {3}\");\n   }\n \n-  private final boolean showInvalidationWarnings;\n-\n   private final AbstractCompiler compiler;\n   private final TypeSystem<T> typeSystem;\n \n    * this pass.\n    */\n   private Multimap<Object, JSError> invalidationMap;\n+\n+  /**\n+   * In practice any large code base will have thousands and thousands of\n+   * type invalidations, which makes reporting all of the errors useless.\n+   * However, certain properties are worth specifically guarding because of the\n+   * large amount of code that can be removed as dead code. This list contains\n+   * the properties (eg: \"toString\") that we care about; if any of these\n+   * properties is invalidated it causes an error.\n+   */\n+  private final Map<String, CheckLevel> propertiesToErrorFor;\n \n   private class Property {\n     /** The name of the property. */\n   private Map<String, Property> properties = Maps.newHashMap();\n \n   static DisambiguateProperties<JSType> forJSTypeSystem(\n-      AbstractCompiler compiler) {\n+      AbstractCompiler compiler,\n+      Map<String, CheckLevel> propertiesToErrorFor) {\n     return new DisambiguateProperties<JSType>(\n-        compiler, new JSTypeSystem(compiler));\n+        compiler, new JSTypeSystem(compiler), propertiesToErrorFor);\n   }\n \n   static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(\n-      AbstractCompiler compiler, TightenTypes tt) {\n+      AbstractCompiler compiler, TightenTypes tt,\n+      Map<String, CheckLevel> propertiesToErrorFor) {\n     return new DisambiguateProperties<ConcreteType>(\n-        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()));\n+        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()),\n+            propertiesToErrorFor);\n   }\n \n   /**\n    * above for either the JSType system, or the concrete type system.\n    */\n   private DisambiguateProperties(AbstractCompiler compiler,\n-                                 TypeSystem<T> typeSystem) {\n+      TypeSystem<T> typeSystem, Map<String, CheckLevel> propertiesToErrorFor) {\n     this.compiler = compiler;\n     this.typeSystem = typeSystem;\n-    this.showInvalidationWarnings = compiler.getErrorLevel(\n-        JSError.make(\"\", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;\n-    if (this.showInvalidationWarnings) {\n+    this.propertiesToErrorFor = propertiesToErrorFor;\n+    if (!this.propertiesToErrorFor.isEmpty()) {\n       this.invalidationMap = LinkedHashMultimap.create();\n     } else {\n       this.invalidationMap = null;\n       Property prop = getProperty(name);\n       if (!prop.scheduleRenaming(n.getLastChild(),\n                                  processProperty(t, prop, type, null))) {\n-        if (showInvalidationWarnings) {\n+        if (propertiesToErrorFor.containsKey(name)) {\n           String suggestion = \"\";\n           if (type instanceof JSType) {\n             JSType jsType = (JSType) type;\n             }\n           }\n           compiler.report(JSError.make(\n-              t.getSourceName(), n, Warnings.INVALIDATION, name,\n-              (type == null ? \"null\" : type.toString()), n.toString(),\n-              suggestion));\n+              t.getSourceName(), n, propertiesToErrorFor.get(name),\n+              Warnings.INVALIDATION, name,\n+              (type == null ? \"null\" : type.toString()),\n+              n.toString(), suggestion));\n         }\n       }\n     }\n                                    processProperty(t, prop, type, null))) {\n           // TODO(user): It doesn't look like the user can do much in this\n           // case right now.\n-          if (showInvalidationWarnings) {\n+          if (propertiesToErrorFor.containsKey(name)) {\n             compiler.report(JSError.make(\n-                t.getSourceName(), child, Warnings.INVALIDATION, name,\n+                t.getSourceName(), child, propertiesToErrorFor.get(name),\n+                Warnings.INVALIDATION, name,\n                 (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n           }\n         }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.DisambiguateProperties.Warnings;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n   private final JSTypeRegistry typeRegistry;\n   private final JSType allValueTypes;\n   private boolean shouldReport = true;\n-  private final boolean recordErrors;\n   private final JSType nullOrUndefined;\n \n   // TODO(nicksantos): Provide accessors to better filter the list of type\n         STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n     this.nullOrUndefined = typeRegistry.createUnionType(\n         NULL_TYPE, VOID_TYPE);\n-    this.recordErrors = compiler.getErrorLevel(\n-        JSError.make(\"\", 0, 0, Warnings.INVALIDATION)) != CheckLevel.OFF;\n   }\n \n   /**\n     if (shouldReport) {\n       compiler.report(error);\n     }\n-    return recordErrors ? error : null;\n+    return error;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n import com.google.javascript.rhino.testing.TestErrorReporter;\n \n import java.util.Collection;\n+import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n import java.util.TreeSet;\n       public void process(Node externs, Node root) {\n         checker.processForTesting(externs, root);\n \n+        Map<String, CheckLevel> propertiesToErrorFor =\n+            Maps.<String, CheckLevel>newHashMap();\n+        propertiesToErrorFor.put(\"foobar\", CheckLevel.ERROR);\n+\n         if (runTightenTypes) {\n           TightenTypes tightener = new TightenTypes(compiler);\n           tightener.process(externs, root);\n           lastPass = DisambiguateProperties.forConcreteTypeSystem(compiler,\n-                                                                  tightener);\n+              tightener, propertiesToErrorFor);\n         } else {\n           // This must be created after type checking is run as it depends on\n           // any mismatches found during checking.\n-          lastPass = DisambiguateProperties.forJSTypeSystem(compiler);\n+          lastPass = DisambiguateProperties.forJSTypeSystem(\n+              compiler, propertiesToErrorFor);\n         }\n \n         lastPass.process(externs, root);\n     testSets(false, js, output, \"{}\");\n   }\n \n+  public void testErrorOnProtectedProperty() {\n+    String js = \"function addSingletonGetter(foo) { foo.foobar = 'a'; };\";\n+\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    compiler.init(new JSSourceFile[]{JSSourceFile.fromCode(\"externs\", \"\")},\n+                  new JSSourceFile[]{\n+                      JSSourceFile.fromCode(\"testcode\", js)}, options);\n+\n+    Node root = compiler.parseInputs();\n+    Node externsRoot = root.getFirstChild();\n+    Node mainRoot = externsRoot.getNext();\n+    getProcessor(compiler).process(externsRoot, mainRoot);\n+\n+    assertEquals(1, compiler.getErrors().length);\n+    assertTrue(compiler.getErrors()[0].toString().contains(\"foobar\"));\n+  }\n+\n   public void runFindHighestTypeInChain() {\n     // Check that this doesn't go into an infinite loop.\n-    DisambiguateProperties.forJSTypeSystem(new Compiler())\n+    DisambiguateProperties.forJSTypeSystem(new Compiler(),\n+        Maps.<String, CheckLevel>newHashMap())\n         .getTypeWithProperty(\"no\",\n             new JSTypeRegistry(new TestErrorReporter(null, null))\n             .getNativeType(JSTypeNative.OBJECT_PROTOTYPE));", "timestamp": 1315002034, "metainfo": ""}