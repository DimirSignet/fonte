{"sha": "660e7b525f76cd64d10ccc8724a1b0e0c501d1d9", "log": "Change on 2010/07/13 09:58:55 by johnlenz          Change source map generation so that runs in O(n) time. Source map         generation is now roughly the time it takes to write the bytes to disk.          R=acleung         DELTA=820  (508 added, 270 deleted, 42 changed)  Change on 2010/07/13 11:14:56 by acleung          Google Analytics Externs Contribution          R=bkuhn,nicksantos         DELTA=438  (438 added, 0 deleted, 0 changed)  Change on 2010/07/13 11:37:57 by nicksantos          Fix goog.scope processing so that it works even if an alias         shadows a global variable.          R=robbyw         DELTA=28  (16 added, 3 deleted, 9 changed)  Change on 2010/07/13 12:45:31 by nicksantos          fix a silly bug where an assignment of a name is interpreted         as an assignment to a name.          R=robbyw         DELTA=7  (6 added, 0 deleted, 1 changed)  Change on 2010/07/13 14:02:13 by nicksantos          Make the goog.asserts functions work better for qualified names         (like x.y).          R=agrieve         DELTA=37  (17 added, 3 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=50006   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     private List<AliasUsage> aliasUsages = Lists.newArrayList();\n \n     // This map is temporary and cleared for each scope.\n-    private Map<String, Node> aliases = Maps.newHashMap();\n+    private Map<String, Var> aliases = Maps.newHashMap();\n \n     private boolean hasErrors = false;\n \n         int type = n.getType();\n         if (type == Token.NAME && parent.getType() == Token.VAR) {\n           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-            aliases.put(n.getString(), n.getFirstChild());\n+            aliases.put(n.getString(), t.getScope().getVar(n.getString()));\n             aliasDefinitions.add(n);\n-\n-            // Undeclare the variable.\n-            t.getScope().undeclare(t.getScope().getVar(n.getString()));\n \n             // If we found an alias, we are done.\n             return;\n           }\n         }\n \n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent)) {\n+        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n+            n == parent.getFirstChild()) {\n           report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n         }\n \n \n       if (t.getScopeDepth() >= 2) {\n         if (n.getType() == Token.NAME) {\n-          Node aliasedNode = aliases.get(n.getString());\n-          // The variable should not exist since we undeclared it when we found\n-          // it.  If it does exist, it's because it's been overridden.\n-          if (t.getScope().getVar(n.getString()) == null &&\n-              aliasedNode != null) {\n+          String name = n.getString();\n+          Var aliasVar = aliases.get(name);\n+\n+          // Check if this name points to an alias.\n+          if (aliasVar != null &&\n+              t.getScope().getVar(name) == aliasVar) {\n             // Note, to support the transitive case, it's important we don't\n             // clone aliasedNode here.  For example,\n             // var g = goog; var d = g.dom; d.createElement('DIV');\n             // The node in aliasedNode (which is \"g\") will be replaced in the\n             // changes pass above with \"goog\".  If we cloned here, we'd end up\n             // with <code>g.dom.createElement('DIV')</code>.\n+            Node aliasedNode = aliasVar.getInitialValue();\n             aliasUsages.add(new AliasedNode(n, aliasedNode));\n           }\n         }\n           endIndex = name.length();\n         }\n         String baseName = name.substring(0, endIndex);\n-        Node aliasedNode = aliases.get(baseName);\n-        if (aliasedNode != null) {\n+        Var aliasVar = aliases.get(baseName);\n+        if (aliasVar != null) {\n+          Node aliasedNode = aliasVar.getInitialValue();\n           aliasUsages.add(new AliasedTypeNode(typeNode,\n               aliasedNode.getQualifiedName() + name.substring(endIndex)));\n         }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Maps;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n import java.util.List;\n-import java.util.Map;\n \n /**\n  * Collects information mapping the generated (compiled) source back to\n  * @see CodePrinter\n  *\n *\n+ * @author johnlenz@google.com (John Lenz)\n  */\n public class SourceMap {\n \n     int id;\n \n     /**\n-     * The input source file.\n+     * The JSON escaped input source file.\n      */\n     String sourceFile;\n \n     Position endPosition;\n \n     /**\n-     * The original name of the token found at the position\n+     * The JSON escaped original name of the token found at the position\n      * represented by this mapping (if any).\n      */\n     String originalName;\n     void appendTo(Appendable out) throws IOException {\n       out.append(\"[\");\n \n-      out.append(escapeString(sourceFile));\n+      out.append(sourceFile);\n \n       out.append(\",\");\n-      out.append(originalPosition.getLineNumber() + \"\");\n+      out.append(String.valueOf(originalPosition.getLineNumber()));\n \n       out.append(\",\");\n-      out.append(originalPosition.getCharacterIndex() + \"\");\n+      out.append(String.valueOf(originalPosition.getCharacterIndex()));\n \n       if (originalName != null) {\n         out.append(\",\");\n-        out.append(escapeString(originalName));\n+        out.append(originalName);\n       }\n \n       out.append(\"]\");\n     }\n   }\n \n-\n-  /**\n-   * Information about a particular line in the compiled (generated) source.\n-   */\n-  private static class LineMapping {\n-    /**\n-     * The line number of this line (indexed by 0).\n-     */\n-    int lineNumber;\n-\n-    /**\n-     * The number of characters on this line.\n-     * Note: This is not guarenteed to be accurate, but\n-     * rather merely reflects the number of characters as\n-     * known by the source map, which is good enough for\n-     * our purposes (because we do not have any information\n-     * for the missing characters anyway).\n-     */\n-    int length;\n-\n-    /**\n-     * The list of all character mappings. Equivalent\n-     * to the values found in the charToMap.\n-     */\n-    List<LineCharMapping> characterMappings = Lists.newArrayList();\n-\n-    /**\n-     * A mapping of each character index on the line to\n-     * its equivalent LineCharMapping describing that character's\n-     * original source file and location.\n-     */\n-    Map<Integer, LineCharMapping> charToMap = Maps.newHashMap();\n-\n-    /**\n-     * Appends the line mapping's character map to the given\n-     * buffer.\n-     */\n-    void appendCharMapTo(Appendable out) throws IOException {\n-      out.append(\"[\");\n-\n-      for (int j = 0; j <= length; ++j) {\n-        if (j > 0) {\n-          out.append(\",\");\n-        }\n-\n-        LineCharMapping current = charToMap.get(j);\n-\n-        if (current == null) {\n-          out.append(\"-1\");\n-        } else {\n-          out.append(String.valueOf(current.basisMapping.id));\n-        }\n-      }\n-\n-      out.append(\"]\");\n-    }\n-  }\n-\n-  /**\n-   * Maps a range of characters in the compiled source file\n-   * back to a given Mapping.\n-   */\n-  private static class LineCharMapping {\n-    /**\n-     * The starting character in the compiled code.\n-     */\n-    int startCharacter;\n-\n-    /**\n-     * The ending character in the compiled code.\n-     */\n-    int endCharacter;\n-\n-    /**\n-     * The mapping associated with this character range\n-     * on the line(s) in the compiled code.\n-     */\n-    Mapping basisMapping;\n-  }\n-\n-  /**\n-   * The list of mappings stored in this map.\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n    */\n   private List<Mapping> mappings = Lists.newArrayList();\n \n   }\n \n   /**\n-   * Adds a mapping for the given node.\n+   * Cache of escaped source file name.\n+   */\n+  private String lastSourceFile = null;\n+  private String lastSourceFileEscaped = null;\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n    *\n    * @param node The node that the new mapping represents.\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n   void addMapping(Node node, Position startPosition, Position endPosition) {\n-    Object sourceFile = node.getProp(Node.SOURCEFILE_PROP);\n+    String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n \n     // If the node does not have an associated source file or\n     // its line number is -1, then the node does not have sufficient\n       return;\n     }\n \n+    // The source file rarely changes, so cache the escaped string.\n+    String escapedSourceFile;\n+    if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n+      lastSourceFile = sourceFile;\n+      lastSourceFileEscaped = escapeString(sourceFile);\n+    }\n+    escapedSourceFile = lastSourceFileEscaped;\n+\n     // Create the new mapping.\n     Mapping mapping = new Mapping();\n     mapping.id = mappings.size();\n-    mapping.sourceFile = sourceFile.toString();\n+    mapping.sourceFile = escapedSourceFile;\n     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n \n-    Object originalName = node.getProp(Node.ORIGINALNAME_PROP);\n+    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n     if (originalName != null) {\n-      mapping.originalName = originalName.toString();\n-    }\n-\n+      mapping.originalName = escapeString(originalName);\n+    }\n \n     // If the mapping is found on the first line, we need to offset\n     // its character position by the number of characters found on\n    * @param offsetIndex The column index of the current character being printed.\n    */\n   void setStartingPosition(int offsetLine, int offsetIndex) {\n+    // TODO(johnlenz): correct this.\n+    // Preconditions.checkState(mappings.isEmpty(),\n+    //     \"Must be set prior to adding mappings\");\n     offsetPosition = new Position(offsetLine, offsetIndex);\n   }\n \n   }\n \n   /**\n-   * Return structure from a determineLineMappings() call.\n-   */\n-  private static class LineMappingInformation {\n-    Map<Integer, LineMapping> mappings;\n-    int maxLine;\n-\n-    public LineMappingInformation(Map<Integer, LineMapping> mappings,\n-                                  int maxLine) {\n-      this.maxLine = maxLine;\n-      this.mappings = mappings;\n-    }\n-  }\n-\n-  /**\n-   * Build the list of mappings per line and per each character on\n-   * that line. This will allow consumers of this source map to ask:\n-   * \"Which mapping best describes this character on this line in the\n-   * generated source code?\".\n-   */\n-  private LineMappingInformation determineLineMappings() {\n+   * Scan the mappings and return the last line mapped.\n+   */\n+  private int findLastLine() {\n     int maxLine = 0;\n-    Map<Integer, LineMapping> lineMappings = Maps.newHashMap();\n-\n     for (Mapping mapping : mappings) {\n-      int prefixLine = prefixPosition.getLineNumber();\n-\n-      int startPositionLine =\n-          prefixLine + mapping.startPosition.getLineNumber();\n-\n-      int endPositionLine = prefixLine + mapping.endPosition.getLineNumber();\n-\n-      // Determine the size of the line.\n+      int endPositionLine = mapping.endPosition.getLineNumber();\n       maxLine = Math.max(maxLine, endPositionLine);\n-\n-      // Iterate over each (possibly partial) line in the generated file that\n-      // this mapping represents.\n-      for (int i = startPositionLine; i <= endPositionLine; ++i) {\n-        LineMapping lineMapping = lineMappings.get(i);\n-\n-        // If there is no line mapping for the current line, create it.\n-        if (lineMapping == null) {\n-          lineMapping = new LineMapping();\n-          lineMapping.lineNumber = i;\n-          lineMappings.put(i, lineMapping);\n-        }\n-\n-        int startCharacter = mapping.startPosition.getCharacterIndex();\n-\n-        // If this is the first line of the generated source file\n-        // (before we consider the prefix added), then add the\n-        // offset on the line caused by the inclusion of the prefix.\n-        if (mapping.startPosition.getLineNumber() == 0) {\n-          startCharacter += prefixPosition.getCharacterIndex();\n-        }\n-\n-        int endCharacter = mapping.endPosition.getCharacterIndex();\n-\n-        if (mapping.endPosition.getLineNumber() == 0) {\n-          endCharacter += prefixPosition.getCharacterIndex();\n-        }\n-\n-        // Set the length of the current line's mapping.\n-        lineMapping.length = Math.max(lineMapping.length, endCharacter);\n-\n-        // If we are not on the starting line, then it means the current\n-        // mapping is multiline and must start on the 0th character.\n-        if (i > startPositionLine) {\n-          startCharacter = 0;\n-        }\n-\n-        // If we are not on the ending line, then it means the current\n-        // mapping is multiline and must start on the last character.\n-        if (i < endPositionLine) {\n-          endCharacter = Integer.MAX_VALUE;\n-        }\n-\n-        // Create the line character mapping for this character.\n-        LineCharMapping lcm = new LineCharMapping();\n-        lcm.startCharacter = startCharacter;\n-        lcm.endCharacter = endCharacter;\n-        lcm.basisMapping = mapping;\n-\n-        lineMapping.characterMappings.add(lcm);\n-      }\n-    }\n-\n-    return new LineMappingInformation(lineMappings, maxLine);\n-  }\n-\n-\n-  /**\n-   * For each character on each of the lines, find the LineCharMapping which\n-   * best represents the generation of that character. This is done by finding\n-   * ALL the LineCharMappings which span that character and then taking the one\n-   * with the *smallest* span. For example, this means that if you have an LCM\n-   * representing a block and an LCM inside of it representing a string literal,\n-   * the string literal will (correctly) be chosen, because its span is smaller\n-   * than that of the block for the characters representing the string literal.\n-   */\n-  private void buildCharacterMappings(Collection<LineMapping> lineMappings) {\n-    for (LineMapping lineMapping : lineMappings) {\n-      for (int i = 0; i <= lineMapping.length; ++i) {\n-        int minLength = Integer.MAX_VALUE;\n-        LineCharMapping current = null;\n-\n-        Collections.sort(lineMapping.characterMappings,\n-            new Comparator<LineCharMapping>() {\n-            @Override\n-            public int compare(LineCharMapping first, LineCharMapping second) {\n-              Mapping firstBasis = first.basisMapping;\n-              Mapping secondBasis = second.basisMapping;\n-\n-              String firstName = firstBasis.originalName;\n-              String secondName = secondBasis.originalName;\n-\n-              firstName = firstName == null ? \"\" : firstName;\n-              secondName = secondName == null ? \"\" : secondName;\n-\n-              return firstName.compareTo(secondName);\n-            }\n-          });\n-\n-        for (LineCharMapping lcm : lineMapping.characterMappings) {\n-          // Ignore LCMs that do not include the current character.\n-          if (i < lcm.startCharacter || i > lcm.endCharacter) {\n-            continue;\n-          }\n-\n-          int lcmLength = lcm.endCharacter - lcm.startCharacter;\n-\n-          // Give precedence to items with names.\n-          if (lcmLength == minLength && lcm.basisMapping.originalName != null) {\n-            current = lcm;\n-            continue;\n-          }\n-\n-          if (lcmLength < minLength) {\n-            minLength = lcmLength;\n-            current = lcm;\n-          }\n-        }\n-\n-        lineMapping.charToMap.put(i, current);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Retrieves the mapping for the given position in the generated source file.\n-   */\n-  Mapping getMappingFor(Position position) {\n-    // Build the map for each line.\n-    LineMappingInformation info = determineLineMappings();\n-    Map<Integer, LineMapping> lineMappings = info.mappings;\n-\n-    // Build the character maps for each line.\n-    buildCharacterMappings(lineMappings.values());\n-\n-    LineMapping lineMapping = lineMappings.get(position.getLineNumber());\n-\n-    if (lineMapping == null) {\n-      return null;\n-    }\n-\n-    LineCharMapping lcm =\n-        lineMapping.charToMap.get(position.getCharacterIndex());\n-\n-\n-    if (lcm == null) {\n-      return null;\n-    }\n-\n-    return lcm.basisMapping;\n+    }\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLineNumber();\n   }\n \n   /**\n    *   represents.\n    */\n   public void appendTo(Appendable out, String name) throws IOException {\n-    // Build the map for each line.\n-    LineMappingInformation info = determineLineMappings();\n-\n-    Map<Integer, LineMapping> lineMappings = info.mappings;\n-    int maxLine = info.maxLine;\n-\n-    // Build the character maps for each line.\n-    buildCharacterMappings(lineMappings.values());\n-\n     // Write the mappings out to the file. The format of the generated\n     // source map is three sections, each deliminated by a magic comment.\n     //\n     // 11) [\"c.js\", 1, 4]\n     // 12) [\"d.js\", 3, 78, \"foo\"]\n \n+    int maxLine = findLastLine();\n+\n     // Add the line character maps.\n     out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n     out.append(escapeString(name));\n     out.append(\", \\\"count\\\": \");\n-    out.append((maxLine + 1) + \"\");\n+    out.append(String.valueOf(maxLine + 1));\n     out.append(\" }\\n\");\n-\n-    for (int i = 0; i <= maxLine; ++i) {\n-      LineMapping lineMapping = lineMappings.get(i);\n-\n-      if (lineMapping == null) {\n-        out.append(\"[]\");\n-      } else {\n-        lineMapping.appendCharMapTo(out);\n-      }\n-\n-      out.append(\"\\n\");\n-    }\n+    (new LineMapper(out)).appendLineMappings();\n \n     // Add the source file maps.\n     out.append(\"/** Begin file information. **/\\n\");\n \n-    // Add legacy file mapping section.  This data is never used but it is\n-    // need for the current file format.\n+    // This section is unused but we need one entry per line to\n+    // prevent changing the format.\n     for (int i = 0; i <= maxLine; ++i) {\n       out.append(\"[]\\n\");\n     }\n     // Add the mappings themselves.\n     out.append(\"/** Begin mapping definitions. **/\\n\");\n \n-    for (int i = 0; i < mappings.size(); ++i) {\n-      Mapping mapping = mappings.get(i);\n+    for (Mapping mapping : mappings) {\n       mapping.appendTo(out);\n       out.append(\"\\n\");\n     }\n   }\n+\n+  /**\n+   * A class to build the line/character to mappings section\n+   * of the source map.\n+   */\n+  private class LineMapper {\n+    // The destination.\n+    private final Appendable out;\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+    // Whether the current line has had a value written yet.\n+    private boolean firstChar = true;\n+\n+    private final static int UNMAPPED = -1;\n+    private final static String UNMAPPED_STRING = \"-1\";\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      Preconditions.checkState(!mappings.isEmpty());\n+\n+      // Start the first line.\n+      openLine();\n+\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          writeClosedMapping(previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        writeCharsBetween(parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        writeClosedMapping(m);\n+      }\n+\n+      // And close the final line.\n+      closeLine();\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      out.append(\"[\");\n+      this.firstChar = true;\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine() throws IOException {\n+      out.append(\"]\\n\");\n+    }\n+\n+    /**\n+     * Add a new char position entry.\n+     * @param id The mapping id to record.\n+     */\n+    private void addCharEntry(String id) throws IOException {\n+      if (firstChar) {\n+        firstChar = false;\n+      } else {\n+        out.append(\",\");\n+      }\n+      out.append(id);\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(Position p) {\n+      return p.getLineNumber() + prefixPosition.getLineNumber();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(Position p) {\n+      int rawLine = p.getLineNumber();\n+      int rawCol = p.getCharacterIndex();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLineNumber();\n+      int l2 = m2.startPosition.getLineNumber();\n+      int c1 = m1.endPosition.getCharacterIndex();\n+      int c2 = m2.startPosition.getCharacterIndex();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void writeClosedMapping(Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        writeCharsUpTo(nextLine, nextCol, m.id);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void writeCharsBetween(Mapping prev, Mapping next)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(next.startPosition);\n+      int nextCol = getAdjustedCol(next.startPosition);\n+      // If the previous value is null, no mapping exists use the special\n+      // \"unmapped value\"(-1).\n+      int id = (prev != null) ? prev.id : UNMAPPED;\n+      writeCharsUpTo(nextLine, nextCol, id);\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void writeCharsUpTo(\n+        int nextLine, int nextCol, int id)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine, \"\");\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        return;\n+      }\n+\n+      String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          for (int j = col; j < nextCol; j++) {\n+            addCharEntry(idString);\n+          }\n+          break;\n+        }\n+\n+        closeLine();\n+        openLine();\n+      }\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       return scope;\n     }\n     JSTypeNative assertedType = assertionFunctionSpec.getAssertedType();\n+    String assertedNodeName = assertedNode.getQualifiedName();\n     // Handle assertions that enforce expressions evaluate to true.\n     if (assertedType == null) {\n-      switch (assertedNode.getType()) {\n-        case Token.NAME:\n-          JSType type = getJSType(assertedNode);\n-          JSType narrowed = type.restrictByNotNullOrUndefined();\n-          if (type != narrowed) {\n-            scope = scope.createChildFlowScope();\n-            redeclare(scope, assertedNode.getString(), narrowed);\n-          }\n-          break;\n-        case Token.AND:\n-        case Token.OR:\n-          BooleanOutcomePair conditionOutcomes =\n-              traverseWithinShortCircuitingBinOp(assertedNode, scope);\n-          scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n-              assertedNode, conditionOutcomes.getOutcomeFlowScope(\n-                  assertedNode.getType(), true), true);\n-          break;\n-      }\n-    } else if (assertedNode.getType() == Token.NAME) {\n+      if (assertedNodeName != null) {\n+        JSType type = getJSType(assertedNode);\n+        JSType narrowed = type.restrictByNotNullOrUndefined();\n+        if (type != narrowed) {\n+          scope = scope.createChildFlowScope();\n+          redeclare(scope, assertedNodeName, narrowed);\n+        }\n+      } else if (assertedNode.getType() == Token.AND ||\n+                 assertedNode.getType() == Token.OR) {\n+        BooleanOutcomePair conditionOutcomes =\n+            traverseWithinShortCircuitingBinOp(assertedNode, scope);\n+        scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n+            assertedNode, conditionOutcomes.getOutcomeFlowScope(\n+                assertedNode.getType(), true), true);\n+      }\n+    } else if (assertedNodeName != null) {\n       // Handle assertions that enforce expressions are of a certain type.\n       JSType type = getJSType(assertedNode);\n       JSType narrowed = type.getGreatestSubtype(getNativeType(assertedType));\n       if (type != narrowed) {\n         scope = scope.createChildFlowScope();\n-        redeclare(scope, assertedNode.getString(), narrowed);\n+        redeclare(scope, assertedNodeName, narrowed);\n       }\n     }\n     return scope;\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n     testScopedNoChanges(\"var x = goog.dom;\", \"y.x();\");\n   }\n \n+  public void testShadowedVar() {\n+    test(\"var Popup = {};\" +\n+         \"var OtherPopup = {};\" +\n+         \"goog.scope(function() {\" +\n+         \"  var Popup = OtherPopup;\" +\n+         \"  Popup.newMethod = function() { return new Popup(); };\" +\n+         \"});\",\n+         \"var Popup = {};\" +\n+         \"var OtherPopup = {};\" +\n+         \"OtherPopup.newMethod = function() { return new OtherPopup(); };\");\n+  }\n+\n   private void testTypes(String aliases, String code) {\n     testScopedNoChanges(aliases, code);\n     Compiler lastCompiler = getLastCompiler();\n   public void testAliasRedefinition() {\n     testScopedFailure(\"var x = goog.dom; x = goog.events;\",\n         ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED);\n+  }\n+\n+  public void testAliasNonRedefinition() {\n+    test(\"var y = {}; goog.scope(function() { goog.dom = y; });\",\n+         \"var y = {}; goog.dom = y;\");\n   }\n \n   public void testScopedReturn() {\n--- a/test/com/google/javascript/jscomp/SourceMapTest.java\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.LinkedListMultimap;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n \n import junit.framework.TestCase;\n \n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Collection;\n import java.util.Map;\n \n /**\n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\",\" +\n                    \" \\\"count\\\": 1 }\\n\" +\n \n-                   \"[0]\\n\" +\n+                   \"[]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9,\" +\n-                   \"10,10,10,10,11,11,12,12,12,12,12,12,13,13,13,13,13,6]\\n\" +\n+                   \"[1,1,1,1,1,1,1,1,2,2,3,4,4,4,3,5,5,5,3,6,8,8,8,7,9,9,9,7,\" +\n+                   \"10,10,10,7,11,12,12,12,12,12,12,12,13,13,13,13,6]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n+\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"testcode\\\",1,0]\\n\" +\n                    \"[\\\"testcode\\\",1,9]\\n\" +\n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,\" +\n-                   \"9,10,10,10,10,11,11,11,11,12,12,12,12,12,12,13,13,13,\" +\n-                   \"13,13,6]\\n\" +\n+                   \"[1,1,1,1,1,1,1,1,2,2,3,4,4,4,3,5,5,5,3,6,8,8,8,7,9,9,9,\" +\n+                   \"7,10,10,10,7,11,11,11,12,12,12,12,12,12,12,13,13,13,\" +\n+                   \"13,6]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[2,2,2,2]\\n\" +\n+                   \"[2,2,2]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\");\n+  }\n+\n+  public void testGoldenOutput4() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;   boo;   goo;\",\n+\n+                   \"/** Begin line maps. **/\" +\n+                   \"{ \\\"file\\\" : \\\"testMap\\\", \\\"count\\\": 1 }\\n\" +\n+                   \"[2,2,2,4,4,4,4,6,6,6,6]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,7]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,7,\\\"boo\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,14]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,14,\\\"goo\\\"]\\n\");\n   }\n \n   public void testBasicDeterminism() throws Exception {\n   private static class RunResult {\n     String generatedSource;\n     SourceMap sourceMap;\n+    public String sourceMapFileContent;\n   }\n \n   private static class Token {\n    * string.\n    */\n   private Map<String, Token> findTokens(String js) {\n-    Map<String, Token> tokens = Maps.newHashMap();\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n \n     int currentLine = 0;\n     int positionOffset = 0;\n   private void compileAndCheck(String js) {\n     RunResult result = compile(js);\n \n+    // Find all instances of the __XXX__ pattern in the original\n+    // source code.\n+    Map<String, Token> originalTokens = findTokens(js);\n+\n     // Find all instances of the __XXX__ pattern in the generated\n     // source code.\n-    Map<String, Token> originalTokens = findTokens(js);\n+    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n \n     // Ensure that the generated instances match via the source map\n     // to the original source code.\n-    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n \n     // Ensure the token counts match.\n     assertEquals(originalTokens.size(), resultTokens.size());\n+\n+    SourceMapReader reader = new SourceMapReader();\n+    try {\n+      reader.parse(result.sourceMapFileContent);\n+    } catch (SourceMapParseException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n \n     // Map the tokens from the generated source back to the\n     // input source and ensure that the map is correct.\n     for (Token token : resultTokens.values()) {\n-      SourceMap.Mapping mapping =\n-          result.sourceMap.getMappingFor(token.position);\n+      OriginalMapping mapping = reader.getMappingForLine(\n+          token.position.getLineNumber() + 1,\n+          token.position.getCharacterIndex() + 1);\n \n       assertNotNull(mapping);\n \n \n       // Ensure that the map correctly points to the token (we add 1\n       // to normalize versus the Rhino line number indexing scheme).\n-      assertEquals(mapping.originalPosition.getLineNumber(),\n+      assertEquals(mapping.position.getLineNumber(),\n                    inputToken.position.getLineNumber() + 1);\n \n       // Ensure that if the token name does not being with an 'STR' (meaning a\n       // string) it has an original name.\n       if (!inputToken.tokenName.startsWith(\"STR\")) {\n-        assertNotNull(mapping.originalName);\n+        assertTrue(!mapping.originalName.isEmpty());\n       }\n \n       // Ensure that if the mapping has a name, it matches the token.\n-      if (mapping.originalName != null) {\n+      if (!mapping.originalName.isEmpty()) {\n         assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n       }\n     }\n     assertTrue(result.success);\n     String source = compiler.toSource();\n \n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      result.sourceMap.appendTo(sb, \"testcode\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n     RunResult rr = new RunResult();\n     rr.generatedSource = source;\n     rr.sourceMap = result.sourceMap;\n+    rr.sourceMapFileContent = sb.toString();\n     return rr;\n   }\n+\n+  public static class SourceMapParseException extends IOException {\n+    public SourceMapParseException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  public static class OriginalMapping {\n+    public final String srcfile;\n+    public final Position position;\n+    public final String originalName;\n+\n+    OriginalMapping(String srcfile, int line, int column, String name) {\n+      this.srcfile = srcfile;\n+      this.position = new Position(line, column);\n+      this.originalName = name;\n+    }\n+  }\n+\n+  /**\n+   * Class for parsing and representing a SourceMap\n+   * TODO(johnlenz): This would be best as a seperate open-source component.\n+   *     Remove this when it is.\n+   */\n+  public class SourceMapReader {\n+    private static final String LINEMAP_HEADER = \"/** Begin line maps. **/\";\n+    private static final String FILEINFO_HEADER =\n+        \"/** Begin file information. **/\";\n+\n+    private static final String DEFINITION_HEADER =\n+        \"/** Begin mapping definitions. **/\";\n+\n+    /**\n+     * Internal class for parsing the SourceMap. Used to maintain parser\n+     * state in an easy to use instance.\n+     */\n+    private class ParseState {\n+      private Reader reader = null;\n+      private int currentPosition = 0;\n+\n+      public ParseState(String contents) {\n+        this.reader = new StringReader(contents);\n+      }\n+\n+      /**\n+       * Consumes a single character. If we have already reached the end\n+       * of the string, returns  -1.\n+       */\n+      private int consumeCharacter() {\n+        try {\n+          currentPosition++;\n+          return reader.read();\n+        } catch (IOException iox) {\n+          // Should never happen. Local reader.\n+          throw new IllegalStateException(\"IOException raised by reader\");\n+        }\n+      }\n+\n+      /**\n+       * Consumes the specified value found in the contents string. If the value\n+       * is not found, throws a parse exception.\n+       */\n+      public void consume(String value) throws SourceMapParseException {\n+         for (int i = 0; i < value.length(); ++i) {\n+          int ch = consumeCharacter();\n+\n+          if (ch == -1 || ch != value.charAt(i)) {\n+            fail(\"At character \" + currentPosition + \" expected: \" + value);\n+          }\n+        }\n+      }\n+\n+      /**\n+       * Consumes characters until the newline character is found or the string\n+       * has been entirely consumed. Returns the string consumed (without the\n+       * newline).\n+       */\n+      public String consumeUntilEOL() throws SourceMapParseException {\n+        StringBuilder sb = new StringBuilder();\n+\n+        int ch = -1;\n+\n+        while ((ch = consumeCharacter()) != '\\n') {\n+          if (ch == -1) {\n+            return sb.toString();\n+          }\n+\n+          sb.append((char) ch);\n+        }\n+\n+        return sb.toString();\n+      }\n+\n+      /**\n+       * Indicates that parsing has failed by throwing a parse exception.\n+       */\n+      public void fail(String message) throws SourceMapParseException {\n+        throw new SourceMapParseException(message);\n+      }\n+    }\n+\n+    /**\n+     * Mapping from a line number (0-indexed), to a list of mapping IDs, one for\n+     * each character on the line. For example, if the array for line 2 is\n+     * [4,,,,5,6,,,7], then there will be the entry:\n+     *\n+     * 1 => {4, 4, 4, 4, 5, 6, 6, 6, 7}\n+     *\n+     */\n+    private Multimap<Integer, Integer> characterMap = null;\n+\n+    /**\n+     * Map of Mapping IDs to the actual mapping object.\n+     */\n+    private Map<Integer, OriginalMapping> mappings = null;\n+\n+    public SourceMapReader() {\n+    }\n+\n+    /**\n+     * Parses the given contents containing a source map.\n+     */\n+    public void parse(String contents) throws SourceMapParseException {\n+      ParseState parser = new ParseState(contents);\n+\n+      characterMap = LinkedListMultimap.create();\n+      mappings = Maps.newHashMap();\n+\n+      try {\n+        // /** Begin line maps. **/{ count: 2 }\n+        parser.consume(LINEMAP_HEADER);\n+        String countJSON = parser.consumeUntilEOL();\n+\n+        JSONObject countObject = new JSONObject(countJSON);\n+\n+        if (!countObject.has(\"count\")) {\n+          parser.fail(\"Missing 'count'\");\n+        }\n+\n+        int lineCount = countObject.getInt(\"count\");\n+\n+        if (lineCount <= 0) {\n+          parser.fail(\"Count must be >= 1\");\n+        }\n+\n+        // [0,,,,,,1,2]\n+        for (int i = 0; i < lineCount; ++i) {\n+          String currentLine = parser.consumeUntilEOL();\n+\n+          // Blank lines are allowed in the spec to indicate no mapping\n+          // information for the line.\n+          if (currentLine.isEmpty()) {\n+            continue;\n+          }\n+\n+          JSONArray charArray = new JSONArray(currentLine);\n+\n+          int lastID = -1;\n+\n+          for (int j = 0; j < charArray.length(); ++j) {\n+            int mappingID = lastID;\n+\n+            if (!charArray.isNull(j)) {\n+              mappingID = charArray.optInt(j);\n+            }\n+\n+            // Save the current character's mapping.\n+            characterMap.put(i, mappingID);\n+\n+            lastID = mappingID;\n+          }\n+        }\n+\n+        // /** Begin file information. **/\n+        parser.consume(FILEINFO_HEADER);\n+\n+        if (parser.consumeUntilEOL().length() > 0) {\n+          parser.fail(\"Unexpected token after file information header\");\n+        }\n+\n+        // File information. Not used, so we just consume it.\n+        for (int i = 0; i < lineCount; ++i) {\n+          parser.consumeUntilEOL();\n+        }\n+\n+        // /** Begin mapping definitions. **/\n+        parser.consume(DEFINITION_HEADER);\n+\n+        if (parser.consumeUntilEOL().length() > 0) {\n+          parser.fail(\"Unexpected token after definition header\");\n+        }\n+\n+        String currentLine = null;\n+\n+        // ['d.js', 3, 78, 'foo']\n+        for (int mappingID = 0;\n+             (currentLine = parser.consumeUntilEOL()).length() > 0;\n+             ++mappingID) {\n+\n+          JSONArray mapArray = new JSONArray(currentLine);\n+\n+          if (mapArray.length() < 3) {\n+            parser.fail(\"Invalid mapping array\");\n+          }\n+\n+          OriginalMapping mapping = new OriginalMapping(\n+              mapArray.getString(0), // srcfile\n+              mapArray.getInt(1),    // line\n+              mapArray.getInt(2),    // column\n+              mapArray.optString(3, \"\")); // identifier\n+\n+          mappings.put(mappingID, mapping);\n+        }\n+      } catch (JSONException ex) {\n+        parser.fail(\"JSON parse exception: \" + ex);\n+      }\n+    }\n+\n+    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n+\n+      if (!characterMap.containsKey(lineNumber - 1)) {\n+        return null;\n+      }\n+\n+      Collection<Integer> mapIds = characterMap.get(lineNumber - 1);\n+\n+      int columnPosition = columnIndex - 1;\n+      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n+        return null;\n+      }\n+\n+      // TODO(user): Find a way to make this faster.\n+      Integer[] mapIdsAsArray = new Integer[mapIds.size()];\n+      mapIds.<Integer>toArray(mapIdsAsArray);\n+\n+      int mapId = mapIdsAsArray[columnPosition];\n+\n+      if (mapId < 0) {\n+        return null;\n+      }\n+\n+      return mappings.get(mapId);\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n     verify(\"out2\", startType);\n   }\n \n+  public void testAssert6() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x.y\", startType);\n+    inFunction(\"out1 = x.y; goog.asserts.assert(x.y); out2 = x.y;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", OBJECT_TYPE);\n+  }\n+\n   public void testAssertNumber() {\n     JSType startType = createNullableType(ALL_TYPE);\n     assuming(\"x\", startType);\n     inFunction(\"out1 = x; goog.asserts.assertObject(x); out2 = x;\");\n     verify(\"out1\", startType);\n     verify(\"out2\", ARRAY_TYPE);\n+  }\n+\n+  public void testAssertObject3() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x.y\", startType);\n+    inFunction(\"out1 = x.y; goog.asserts.assertObject(x.y); out2 = x.y;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", OBJECT_TYPE);\n   }\n \n   public void testAssertArray() {", "timestamp": 1279060137, "metainfo": ""}