{"sha": "11e59819ec6134736004cebf264b030517a7bff1", "log": "Allow type names to be split across multiple lines. To avoid parsing ambiguities, we insist that the type name must end in a '.' to get this behavior.  R=acleung DELTA=49  (40 added, 0 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=579   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                     type = createJSTypeExpression(newStringNode(\"number\"));\n                   }\n                   if (!jsdocBuilder.recordEnumParameterType(type)) {\n-                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                    parser.addWarning(\n+                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                   }\n                   token = eatTokensUntilEOL(token);\n                   continue retry;\n                     if (isBracketedParam) {\n                       token = next();\n \n-                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n-                      // It makes no sense under our type system.\n+                      // Throw out JsDocToolkit's \"default\" parameter\n+                      // annotation.  It makes no sense under our type\n+                      // system.\n                       if (JsDocToken.EQUALS == token) {\n                         token = next();\n                         if (JsDocToken.STRING == token) {\n       return reportGenericTypeSyntaxWarning();\n     }\n \n-    Node typeName = newStringNode(stream.getString());\n+    String typeName = stream.getString();\n+    while (match(JsDocToken.EOL) &&\n+        typeName.charAt(typeName.length() - 1) == '.') {\n+      skipEOLs();\n+      if (match(JsDocToken.STRING)) {\n+        next();\n+        typeName += stream.getString();\n+      }\n+    }\n+\n+    Node typeNameNode = newStringNode(typeName);\n+\n     if (match(JsDocToken.LT)) {\n       next();\n       skipEOLs();\n       Node memberType = parseTypeExpressionList(next());\n       if (memberType != null) {\n-        typeName.addChildToFront(memberType);\n+        typeNameNode.addChildToFront(memberType);\n \n         skipEOLs();\n         if (!match(JsDocToken.GT)) {\n         next();\n       }\n     }\n-    return typeName;\n+    return typeNameNode;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     assertTypeEquals(STRING_TYPE, info.getType());\n   }\n \n+  public void testParseNamedType5() throws Exception {\n+    JSDocInfo info = parse(\"@type {!goog.\\nBar}*/\");\n+    assertTypeEquals(\n+        registry.createNamedType(\"goog.Bar\", null, -1, -1),\n+        info.getType());\n+  }\n+\n+  public void testParseNamedType6() throws Exception {\n+    JSDocInfo info = parse(\"@type {!goog.\\n * Bar.\\n * Baz}*/\");\n+    assertTypeEquals(\n+        registry.createNamedType(\"goog.Bar.Baz\", null, -1, -1),\n+        info.getType());\n+  }\n+\n+  public void testParseNamedTypeError1() throws Exception {\n+    // To avoid parsing ambiguities, type names must end in a '.' to\n+    // get the continuation behavior.\n+    parse(\"@type {!goog\\n * .Bar} */\", \"expected closing }\");\n+  }\n+\n+  public void testParseNamedTypeError2() throws Exception {\n+    parse(\"@type {!goog.\\n * Bar\\n * .Baz} */\", \"expected closing }\");\n+  }\n+\n   public void testTypedefType1() throws Exception {\n     JSDocInfo info = parse(\"@typedef string */\");\n     assertTrue(info.hasTypedefType());\n   }\n \n   public void testParseBooleanType2() throws Exception {\n-    assertTypeEquals(BOOLEAN_OBJECT_TYPE, parse(\"@type {!Boolean}*/\").getType());\n+    assertTypeEquals(\n+        BOOLEAN_OBJECT_TYPE, parse(\"@type {!Boolean}*/\").getType());\n   }\n \n   public void testParseNumberType1() throws Exception {\n     assertTypeEquals(REFERENCE_ERROR_TYPE,\n         parse(\"@type {!ReferenceError}*/\").getType());\n     assertTypeEquals(TYPE_ERROR_TYPE, parse(\"@type {!TypeError}*/\").getType());\n-    assertTypeEquals(RANGE_ERROR_TYPE, parse(\"@type {!RangeError}*/\").getType());\n-    assertTypeEquals(SYNTAX_ERROR_TYPE, parse(\"@type {!SyntaxError}*/\").getType());\n+    assertTypeEquals(\n+        RANGE_ERROR_TYPE, parse(\"@type {!RangeError}*/\").getType());\n+    assertTypeEquals(\n+        SYNTAX_ERROR_TYPE, parse(\"@type {!SyntaxError}*/\").getType());\n   }\n \n   public void testParseUndefinedType1() throws Exception {", "timestamp": 1298385202, "metainfo": ""}