{"sha": "31c31c6b7dd120c203244300f55eb4509dc3c1f9", "log": "Check for common misuses of NaN. Fixes issue 857  R=dimvar DELTA=412  (257 added, 142 deleted, 13 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5854   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckSuspiciousCode.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Checks for common errors, such as misplaced semicolons:\n+ * <pre>\n+ * if (x); act_now();\n+ * </pre>\n+ *  or comparison against NaN:\n+ * <pre>\n+ * if (x === NaN) act();\n+ * </pre>\n+ * and generates warnings.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+final class CheckSuspiciousCode extends AbstractPostOrderCallback {\n+\n+  static final DiagnosticType SUSPICIOUS_SEMICOLON = DiagnosticType.warning(\n+      \"JSC_SUSPICIOUS_SEMICOLON\",\n+      \"If this if/for/while really shouldn't have a body, use {}\");\n+\n+  static final DiagnosticType SUSPICIOUS_COMPARISON_WITH_NAN =\n+      DiagnosticType.warning(\n+          \"JSC_SUSPICIOUS_NAN\",\n+          \"Comparison again NaN is always false. Did you mean isNaN()?\");\n+\n+  CheckSuspiciousCode() {\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    checkMissingSemicolon(t, n);\n+    checkNaN(t, n);\n+  }\n+\n+  private void checkMissingSemicolon(NodeTraversal t, Node n) {\n+    switch (n.getType()) {\n+      case Token.IF:\n+        Node trueCase = n.getFirstChild().getNext();\n+        reportIfWasEmpty(t, trueCase);\n+        Node elseCase = trueCase.getNext();\n+        if (elseCase != null) {\n+          reportIfWasEmpty(t, elseCase);\n+        }\n+        break;\n+\n+      case Token.WHILE:\n+      case Token.FOR:\n+        reportIfWasEmpty(t, NodeUtil.getLoopCodeBlock(n));\n+        break;\n+    }\n+  }\n+\n+  private void reportIfWasEmpty(NodeTraversal t, Node block) {\n+    Preconditions.checkState(block.isBlock());\n+\n+    // A semicolon is distinguished from a block without children by\n+    // annotating it with EMPTY_BLOCK.  Blocks without children are\n+    // usually intentional, especially with loops.\n+    if (!block.hasChildren() && block.wasEmptyNode()) {\n+        t.getCompiler().report(\n+            t.makeError(block, SUSPICIOUS_SEMICOLON));\n+    }\n+  }\n+\n+  private void checkNaN(NodeTraversal t, Node n) {\n+    switch (n.getType()) {\n+      case Token.EQ:\n+      case Token.GE:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.LT:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+        reportIfNaN(t, n.getFirstChild());\n+        reportIfNaN(t, n.getLastChild());\n+    }\n+  }\n+\n+  private void reportIfNaN(NodeTraversal t, Node n) {\n+    if (NodeUtil.isNaN(n)) {\n+      t.getCompiler().report(\n+          t.makeError(n.getParent(), SUSPICIOUS_COMPARISON_WITH_NAN));\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n         compiler) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n       if (options.checkSuspiciousCode) {\n-        sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n+        sharedCallbacks.add(new CheckSuspiciousCode());\n       }\n \n       if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n       \"es5Strict, externsValidation, fileoverviewTags, globalThis, \" +\n       \"internetExplorerChecks, invalidCasts, misplacedTypeAnnotation, \" +\n       \"missingProperties, \" +\n-      \"nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, \" +\n+      \"nonStandardJsDocs, suspiciousCode, strictModuleDepCheck, \" +\n+      \"typeInvalidation, \" +\n       \"undefinedNames, undefinedVars, unknownDefines, uselessCode, \" +\n       \"visibility\";\n \n       DiagnosticGroups.registerGroup(\"nonStandardJsDocs\",\n           RhinoErrorReporter.BAD_JSDOC_ANNOTATION);\n \n-  public static DiagnosticGroup ACCESS_CONTROLS =\n+  public static final DiagnosticGroup ACCESS_CONTROLS =\n       DiagnosticGroups.registerGroup(\"accessControls\",\n           DEPRECATED, VISIBILITY);\n \n       DiagnosticGroups.registerGroup(\"violatedModuleDep\",\n           VarCheck.VIOLATED_MODULE_DEP_ERROR);\n \n-  public static DiagnosticGroup EXTERNS_VALIDATION =\n+  public static final DiagnosticGroup EXTERNS_VALIDATION =\n       DiagnosticGroups.registerGroup(\"externsValidation\",\n           VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR,\n           VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n       DiagnosticGroups.registerGroup(\"missingProperties\",\n           TypeCheck.INEXISTENT_PROPERTY);\n \n-  // TODO: add more IE specific checks here.\n   public static final DiagnosticGroup INTERNET_EXPLORER_CHECKS =\n       DiagnosticGroups.registerGroup(\"internetExplorerChecks\",\n           RhinoErrorReporter.TRAILING_COMMA);\n       DiagnosticGroups.registerGroup(\"cast\",\n           TypeValidator.INVALID_CAST);\n \n+  public static final DiagnosticGroup SUSPICIOUS_CODE =\n+      DiagnosticGroups.registerGroup(\"suspiciousCode\",\n+          CheckSuspiciousCode.SUSPICIOUS_SEMICOLON,\n+          CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN);\n+\n   /**\n    * Adds warning levels by name.\n    */\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Gets the boolean value of a node that represents a literal. This method\n    * effectively emulates the <code>Boolean()</code> JavaScript cast function\n    * except it return UNKNOWN for known values with side-effects, use\n-   * getExpressionBooleanValue if you don't care about side-effects.\n+   * getImpureBooleanValue if you don't care about side-effects.\n    */\n   static TernaryValue getPureBooleanValue(Node n) {\n     switch (n.getType()) {\n     }\n     return result;\n   }\n+\n+  static boolean isNaN(Node n) {\n+    if ((n.isName() && n.getString().equals(\"NaN\")) ||\n+        (n.getType() == Token.DIV &&\n+         n.getFirstChild().isNumber() && n.getFirstChild().getDouble() == 0 &&\n+         n.getLastChild().isNumber() && n.getLastChild().getDouble() == 0)) {\n+      return true;\n+    }\n+    return false;\n+  }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckSuspiciousCodeTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for CheckSuspiciousCode\n+ */\n+public class CheckSuspiciousCodeTest extends CompilerTestCase {\n+  public CheckSuspiciousCodeTest() {\n+    this.parseTypeInfo = true;\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new CombinedCompilerPass(compiler,\n+        new CheckSuspiciousCode());\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void test(String js, DiagnosticType error) {\n+    test(js, js, null, error);\n+  }\n+\n+  public void testSuspiciousSemi() {\n+    final DiagnosticType e = CheckSuspiciousCode.SUSPICIOUS_SEMICOLON;\n+    final DiagnosticType ok = null;  //  code is 'ok', verify no warning\n+\n+    test(\"if(x()) x = y;\", ok);\n+    test(\"if(x()); x = y;\", e);  // I've had this bug, damned ;\n+    test(\"if(x()){} x = y;\", ok);\n+\n+    test(\"if(x()) x = y; else y=z;\", ok);\n+    test(\"if(x()); else y=z;\", e);\n+    test(\"if(x()){} else y=z;\", ok);\n+    test(\"if(x()) x = y; else;\", e);\n+    test(\"if(x()) x = y; else {}\", ok);\n+\n+    test(\"while(x()) x = y;\", ok);\n+    test(\"while(x()); x = y;\", e);\n+    test(\"while(x()){} x = y;\", ok);\n+    test(\"while(x()); {x = y}\", e);\n+    test(\"while(x()){} {x = y}\", ok);\n+\n+    test(\"for(;;) x = y;\", ok);\n+    test(\"for(;;); x = y;\", e);\n+    test(\"for(;;){} x = y;\", ok);\n+    test(\"for(x in y) x = y;\", ok);\n+    test(\"for(x in y); x = y;\", e);\n+    test(\"for(x in y){} x = y;\", ok);\n+  }\n+\n+  private void testReportNaN(String js) {\n+    testSame(js, CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN);\n+  }\n+\n+  public void testComparison1() {\n+    testReportNaN(\"x == NaN\");\n+    testReportNaN(\"x != NaN\");\n+    testReportNaN(\"x === NaN\");\n+    testReportNaN(\"x !== NaN\");\n+    testReportNaN(\"x < NaN\");\n+    testReportNaN(\"x <= NaN\");\n+    testReportNaN(\"x > NaN\");\n+    testReportNaN(\"x >= NaN\");\n+  }\n+\n+  public void testComparison2() {\n+    testReportNaN(\"NaN == x\");\n+    testReportNaN(\"NaN != x\");\n+    testReportNaN(\"NaN === x\");\n+    testReportNaN(\"NaN !== x\");\n+    testReportNaN(\"NaN < x\");\n+    testReportNaN(\"NaN <= x\");\n+    testReportNaN(\"NaN > x\");\n+    testReportNaN(\"NaN >= x\");\n+  }\n+\n+  public void testComparison3() {\n+    testReportNaN(\"x == 0/0\");\n+    testReportNaN(\"x != 0/0\");\n+    testReportNaN(\"x === 0/0\");\n+    testReportNaN(\"x !== 0/0\");\n+    testReportNaN(\"x < 0/0\");\n+    testReportNaN(\"x <= 0/0\");\n+    testReportNaN(\"x > 0/0\");\n+    testReportNaN(\"x >= 0/0\");\n+  }\n+\n+  public void testComparison4() {\n+    testReportNaN(\"0/0 == x\");\n+    testReportNaN(\"0/0 != x\");\n+    testReportNaN(\"0/0 === x\");\n+    testReportNaN(\"0/0 !== x\");\n+    testReportNaN(\"0/0 < x\");\n+    testReportNaN(\"0/0 <= x\");\n+    testReportNaN(\"0/0 > x\");\n+    testReportNaN(\"0/0 >= x\");\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n import java.util.Collection;\n import java.util.Set;\n \n+/**\n+ * Tests for NodeUtil\n+ */\n public class NodeUtilTest extends TestCase {\n \n   private static Node parse(String js) {\n     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n   }\n \n-  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n+  private void assertSideEffect(boolean se, String js, boolean globalRegExp) {\n     Node n = parse(js);\n     Compiler compiler = new Compiler();\n-    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n+    compiler.setHasRegExpGlobalReferences(globalRegExp);\n     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n   }\n \n     assertNodeNames(Sets.newHashSet(\"foo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n             parse(\"var foo;\")));\n-    assertNodeNames(Sets.newHashSet(\"foo\",\"goo\"),\n+    assertNodeNames(Sets.newHashSet(\"foo\", \"goo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n             parse(\"var foo,goo;\")));\n     assertNodeNames(Sets.<String>newHashSet(),\n   }\n \n   private boolean testValidDefineValue(String js) {\n-    Node script = parse(\"var test = \" + js +\";\");\n+    Node script = parse(\"var test = \" + js + \";\");\n     Node var = script.getFirstChild();\n     Node name = var.getFirstChild();\n     Node value = name.getFirstChild();\n     assertEquals(\"x\", getFunctionLValue(\"var x = (y, function() {});\"));\n   }\n \n+  public void testIsNaN() {\n+    assertEquals(true, NodeUtil.isNaN(getNode(\"NaN\")));\n+    assertEquals(false, NodeUtil.isNaN(getNode(\"Infinity\")));\n+    assertEquals(false, NodeUtil.isNaN(getNode(\"x\")));\n+    assertEquals(true, NodeUtil.isNaN(getNode(\"0/0\")));\n+    assertEquals(false, NodeUtil.isNaN(getNode(\"1/0\")));\n+    assertEquals(false, NodeUtil.isNaN(getNode(\"0/1\")));\n+    assertEquals(false, NodeUtil.isNaN(IR.number(0.0)));\n+  }\n+\n   public void testIsExecutedExactlyOnce() {\n     assertEquals(true, executedOnceTestCase(\"x;\"));\n ", "timestamp": 1353436033, "metainfo": ""}