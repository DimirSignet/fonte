{"sha": "3651a7121d8a74440172e32e1d2de880f24df011", "log": "Add a mechanism for using output wrappers with escaping.  R=johnlenz DELTA=147  (91 added, 46 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5679   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import java.util.Map.Entry;\n import java.util.Set;\n import java.util.logging.Level;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Implementations of AbstractCommandLineRunner translate flags into Java\n   // Bookkeeping to measure optimal phase orderings.\n   private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n \n-  private static final String OUTPUT_WRAPPER_MARKER = \"%output%\";\n+  private static final String OUTPUT_MARKER = \"%output%\";\n+  private static final String OUTPUT_MARKER_JS_STRING = \"%output|jsstring%\";\n \n   private final RunTimeStats runTimeStats = new RunTimeStats();\n \n     String baseName = new File(fileName).getName();\n     writeOutput(out, compiler, compiler.toSource(m),\n         parsedModuleWrappers.get(m.getName()).replace(\"%basename%\", baseName),\n-        \"%s\");\n+        \"%s\", null);\n   }\n \n   /**\n    * wrapper that contains a placeholder where the code should be inserted.\n    */\n   static void writeOutput(Appendable out, Compiler compiler, String code,\n-      String wrapper, String codePlaceholder) throws IOException {\n+      String wrapper, String codePlaceholder,\n+      @Nullable Function<String, String> escaper)\n+      throws IOException {\n     int pos = wrapper.indexOf(codePlaceholder);\n     if (pos != -1) {\n       String prefix = \"\";\n         out.append(prefix);\n       }\n \n-      out.append(code);\n+      out.append(escaper == null ? code : escaper.apply(code));\n \n       int suffixStart = pos + codePlaceholder.length();\n       if (suffixStart != wrapper.length()) {\n     } else if (result.success) {\n       outputModuleGraphJson();\n       if (modules == null) {\n-        writeOutput(\n-            jsOutput, compiler, compiler.toSource(), config.outputWrapper,\n-            OUTPUT_WRAPPER_MARKER);\n+        outputSingleBinary();\n \n         // Output the source map if requested.\n         outputSourceMap(options, config.jsOutputFile);\n       } else {\n-        parsedModuleWrappers = parseModuleWrappers(\n-            config.moduleWrapper, modules);\n-        maybeCreateDirsForPath(config.moduleOutputPathPrefix);\n-\n-        // If the source map path is in fact a pattern for each\n-        // module, create a stream per-module. Otherwise, create\n-        // a single source map.\n-        Writer mapOut = null;\n-\n-        if (!shouldGenerateMapPerModule(options)) {\n-          mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, null));\n-        }\n-\n-        for (JSModule m : modules) {\n-          if (shouldGenerateMapPerModule(options)) {\n-            mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, m));\n-          }\n-\n-          Writer writer =\n-              fileNameToLegacyOutputWriter(getModuleOutputFileName(m));\n-\n-          if (options.sourceMapOutputPath != null) {\n-            compiler.getSourceMap().reset();\n-          }\n-\n-          writeModuleOutput(writer, m);\n-\n-          if (options.sourceMapOutputPath != null) {\n-            compiler.getSourceMap().appendTo(mapOut, m.getName());\n-          }\n-\n-          writer.close();\n-\n-          if (shouldGenerateMapPerModule(options) && mapOut != null) {\n-            mapOut.close();\n-            mapOut = null;\n-          }\n-        }\n-\n-        if (mapOut != null) {\n-          mapOut.close();\n-        }\n+        outputModuleBinaryAndSourceMaps(modules, options);\n       }\n \n       // Output the externs if required.\n \n     // return 0 if no errors, the error count otherwise\n     return Math.min(result.errors.length, 0x7f);\n+  }\n+\n+  Function<String, String> getJavascriptEscaper() {\n+    throw new UnsupportedOperationException(\n+        \"SourceCodeEscapers is not in the standard release of Guava yet :(\");\n+  }\n+\n+  void outputSingleBinary() throws IOException {\n+    Function<String, String> escaper = null;\n+    String marker = OUTPUT_MARKER;\n+    if (config.outputWrapper.contains(OUTPUT_MARKER_JS_STRING)) {\n+      marker = OUTPUT_MARKER_JS_STRING;\n+      escaper = getJavascriptEscaper();\n+    }\n+\n+    writeOutput(\n+        jsOutput, compiler, compiler.toSource(), config.outputWrapper,\n+        marker, escaper);\n+  }\n+\n+  private void outputModuleBinaryAndSourceMaps(\n+      List<JSModule> modules, B options)\n+      throws FlagUsageException, IOException {\n+    parsedModuleWrappers = parseModuleWrappers(\n+        config.moduleWrapper, modules);\n+    maybeCreateDirsForPath(config.moduleOutputPathPrefix);\n+\n+    // If the source map path is in fact a pattern for each\n+    // module, create a stream per-module. Otherwise, create\n+    // a single source map.\n+    Writer mapOut = null;\n+\n+    if (!shouldGenerateMapPerModule(options)) {\n+      mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, null));\n+    }\n+\n+    for (JSModule m : modules) {\n+      if (shouldGenerateMapPerModule(options)) {\n+        mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, m));\n+      }\n+\n+      Writer writer =\n+          fileNameToLegacyOutputWriter(getModuleOutputFileName(m));\n+\n+      if (options.sourceMapOutputPath != null) {\n+        compiler.getSourceMap().reset();\n+      }\n+\n+      writeModuleOutput(writer, m);\n+\n+      if (options.sourceMapOutputPath != null) {\n+        compiler.getSourceMap().appendTo(mapOut, m.getName());\n+      }\n+\n+      writer.close();\n+\n+      if (shouldGenerateMapPerModule(options) && mapOut != null) {\n+        mapOut.close();\n+        mapOut = null;\n+      }\n+    }\n+\n+    if (mapOut != null) {\n+      mapOut.close();\n+    }\n   }\n \n   private void outputTracerReport() {\n \n     /**\n      * Interpolate output into this string at the place denoted\n-     *  by the marker token %output%. See --output_wrapper_marker\n+     * by the marker token %output%, or %output|jsstring%\n      */\n     CommandLineConfig setOutputWrapper(String outputWrapper) {\n       this.outputWrapper = outputWrapper;\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n \n     @Option(name = \"--output_wrapper\",\n         usage = \"Interpolate output into this string at the place denoted\"\n-        + \" by the marker token %output%. See --output_wrapper_marker\")\n+        + \" by the marker token %output%. Use marker token %output|jsstring%\"\n+        + \" to do js string escaping on the output.\")\n     private String output_wrapper = \"\";\n \n     @Option(name = \"--module_wrapper\",", "timestamp": 1350671417, "metainfo": ""}