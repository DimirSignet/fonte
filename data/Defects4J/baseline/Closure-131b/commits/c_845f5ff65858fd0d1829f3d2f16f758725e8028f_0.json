{"sha": "845f5ff65858fd0d1829f3d2f16f758725e8028f", "log": "Add buttloads of tests.  Rewrite JSDoc inference to be more redundant, which should help it to be more robust.  Assorted other fixes.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n    */\n   protected abstract B createOptions();\n \n-  final protected void initOptionsFromFlags(CompilerOptions options) {\n-\n-    DiagnosticGroups.setWarningLevels(\n+  protected DiagnosticGroups getDiagnoticGroups() {\n+    return new DiagnosticGroups();\n+  }\n+\n+  protected void initOptionsFromFlags(CompilerOptions options) {\n+\n+    DiagnosticGroups diagnosticGroups = getDiagnoticGroups();\n+\n+    diagnosticGroups.setWarningLevels(\n         options, AbstractCompilerRunner.FLAG_jscomp_error.get(),\n         CheckLevel.ERROR);\n-    DiagnosticGroups.setWarningLevels(\n+    diagnosticGroups.setWarningLevels(\n         options, AbstractCompilerRunner.FLAG_jscomp_warning.get(),\n         CheckLevel.WARNING);\n-    DiagnosticGroups.setWarningLevels(\n+    diagnosticGroups.setWarningLevels(\n         options, AbstractCompilerRunner.FLAG_jscomp_off.get(),\n         CheckLevel.OFF);\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     moduleGraph_ = null;\n     inputs_ = makeCompilerInput(inputs, false);\n     options_ = options;\n+    initBasedOnOptions();\n \n     initInputsByNameMap();\n   }\n     }\n     inputs_ = getAllInputsFromModules();\n     options_ = options;\n-\n+    initBasedOnOptions();\n \n     initInputsByNameMap();\n+  }\n+\n+  /**\n+   * Do any initialization that is dependent on the compiler options.\n+   */\n+  private void initBasedOnOptions() {\n+    // Create the source map if necessary.\n+    if (options_.sourceMapOutputPath != null) {\n+      sourceMap_ = new SourceMap();\n+    }\n   }\n \n   private CompilerInput[] makeCompilerInput(\n     // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n     // unmodified local names.\n     normalize();\n-\n-    // Create the source map if necessary.\n-    if (options_.sourceMapOutputPath != null) {\n-      this.sourceMap_ = new SourceMap();\n-    }\n   }\n \n   private void externExports() {\n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-\n /**\n  * Check for invalid breaks and continues in the program.\n  *\n \n   private String sourceName = null;\n \n-  // List of labels for switch statements.\n-  private Deque<String> switchLabels = new ArrayDeque<String>();\n-\n-  static final DiagnosticType INVALID_BREAK = DiagnosticType.error(\n-      \"JSC_INVALID_BREAK\",\n-      \"unlabeled break must be inside loop or switch\");\n-\n-  static final DiagnosticType INVALID_CONTINUE = DiagnosticType.error(\n-      \"JSC_INVALID_CONTINUE\",\n-      \"continue must be inside loop\");\n-\n-  static final DiagnosticType INVALID_LABEL_CONTINUE = DiagnosticType.error(\n-      \"JSC_INVALID_LABEL_CONTINUE\",\n-      \"continue can only target labels of loop structures\");\n-\n   static final DiagnosticType USE_OF_WITH = DiagnosticType.warning(\n       \"JSC_USE_OF_WITH\",\n       \"The use of the 'with' structure should be avoided.\");\n \n   @Override\n   public void process(Node externs, Node root) {\n-    check(root, false, false);\n+    check(root);\n   }\n \n   /**\n-   * Reports errors for any invalid breaks and continues in an AST. This method\n-   * uses recursion to perform a pre-order traversal. It keeps track the\n-   * iteration-statement nest depth and switch-statement nest depth. If there is\n-   * a break or continue in the AST but there is no corresponding nesting of\n-   * iteration-statement or switch-statement, the function will report an error.\n-   * Also, it keeps track of the labels for switch-statements. If a labeled\n-   * continue-statement points to a switch-statement, it will also report an\n-   * error.\n-   * <p>\n-   * There is no need to verify that a label has actually been defined because\n-   * the parser has already done so.\n-   * <p>\n-   * TODO(user): Use a light version of NodeTraversal for this and other\n-   * similar passes.\n+   * Reports errors for any invalid use of control structures.\n    *\n    * @param node Current node to check.\n-   * @param inLoop Is there a loop above this node.\n-   * @param inSwitch Is there a switch above this node.\n    */\n-  private void check(Node node, boolean inLoop, boolean inSwitch) {\n+  private void check(Node node) {\n     switch (node.getType()) {\n       case Token.WITH:\n         JSDocInfo info = node.getJSDocInfo();\n         }\n         break;\n \n-      case Token.FUNCTION:\n-        // Save the old labels because we are in a new scope.\n-        Deque<String> oldSwitchLabels = switchLabels;\n-        switchLabels = new ArrayDeque<String>();\n-\n-        // Reset to zero since the spec does not allow break/continue across\n-        // functions.\n-        Node body = node.getFirstChild().getNext().getNext();\n-        check(body, false, false);\n-\n-        // Restore the old labels.\n-        switchLabels = oldSwitchLabels;\n-        break;\n-\n-      case Token.FOR:\n-        Node child = node.getFirstChild();\n-        check(child, inLoop, inSwitch);\n-        child = child.getNext();\n-        check(child, inLoop, inSwitch);\n-        child = child.getNext();\n-        // We have a FOR-IN if we have 3 blocks only.\n-        if (child.getNext() == null) {\n-          // This is the case when we have FOR.\n-          check(child, true, inSwitch);\n-        } else {\n-          check(child, inLoop, inSwitch);\n-          check(child.getNext(), true, inSwitch);\n-        }\n-        break;\n-\n-      case Token.WHILE:\n-        check(node.getFirstChild(), inLoop, inSwitch);\n-        check(node.getFirstChild().getNext(), true, inSwitch);\n-        break;\n-\n-      case Token.DO:\n-        check(node.getFirstChild(), true, inSwitch);\n-        break;\n-\n-      case Token.SWITCH:\n-        check(node.getFirstChild(), inLoop, inSwitch);\n-        for (Node cChild = node.getFirstChild().getNext(); cChild != null;) {\n-          Node next = cChild.getNext();\n-          check(cChild, inLoop, true);\n-          cChild = next;\n-        }\n-        break;\n-\n       case Token.SCRIPT:\n         // Remember the source file name in case we need to report an error.\n         sourceName = (String) node.getProp(Node.SOURCENAME_PROP);\n-        for (Node sChild = node.getFirstChild(); sChild != null;) {\n-          Node next = sChild.getNext();\n-          check(sChild, false, false);\n-          sChild = next;\n-        }\n         break;\n+    }\n \n-      case Token.LABEL:\n-        Node switchNode = node.getLastChild();\n-\n-        // Record the switch label in the list.\n-        if (switchNode.getType() == Token.SWITCH) {\n-          String label = node.getFirstChild().getString();\n-          switchLabels.addFirst(label);\n-          check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-          switchLabels.removeFirst();\n-        } else {\n-          check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-        }\n-        break;\n-\n-      case Token.BREAK:\n-        // Make sure we are in at least one loop nest or switch nest.\n-        if (!node.hasChildren() && !inLoop && !inSwitch) {\n-          report(node, INVALID_BREAK);\n-        }\n-        break;\n-\n-      case Token.CONTINUE:\n-        // If there is no label, we just need to make sure we are in at least\n-        // one loop nest.\n-        if (!inLoop) {\n-          report(node, INVALID_CONTINUE);\n-        }\n-        if (node.hasChildren()) {\n-          // Now we have to verify that the label is not a label for \"switch\".\n-          Node label = node.getFirstChild();\n-          if (switchLabels.contains(label.getString())) {\n-            report(node, INVALID_LABEL_CONTINUE);\n-          }\n-        }\n-        break;\n-\n-      default:\n-        for (Node bChild = node.getFirstChild(); bChild != null;) {\n-          Node next = bChild.getNext();\n-          check(bChild, inLoop, inSwitch);\n-          bChild = next;\n-        }\n+    for (Node bChild = node.getFirstChild(); bChild != null;) {\n+      Node next = bChild.getNext();\n+      check(bChild);\n+      bChild = next;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n  */\n public class DiagnosticGroups {\n \n-  private DiagnosticGroups() {} // all static\n+  DiagnosticGroups() {}\n \n   private final static Map<String, DiagnosticGroup> groupsByName =\n       Maps.newHashMap();\n   }\n \n   /** Find the diagnostic group registered under the given name. */\n-  static DiagnosticGroup forName(String name) {\n+  DiagnosticGroup forName(String name) {\n     return groupsByName.get(name);\n   }\n \n   /**\n    * Adds warning levels by name.\n    */\n-  static void setWarningLevels(CompilerOptions options,\n+  void setWarningLevels(CompilerOptions options,\n       List<String> diagnosticGroups, CheckLevel level) {\n     for (String name : diagnosticGroups) {\n-      DiagnosticGroup group = DiagnosticGroups.forName(name);\n+      DiagnosticGroup group = forName(name);\n       Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n       options.setWarningLevel(group, level);\n     }\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n       Node condition = NodeUtil.getConditionExpression(n);\n       if (condition != null) {\n         tryMinimizeCondition(t, condition, n);\n-      }\n+        // The root condition node might have changed, get it again.\n+        condition = NodeUtil.getConditionExpression(n);\n+        this.tryFoldForCondition(condition, n);\n+      }\n+        \n       tryFoldFor(t, n, parent);\n       return;\n     }\n   }\n \n   /**\n+   * Remove always true loop conditions.\n+   */\n+  private void tryFoldForCondition(Node n, Node parent) {\n+    if (NodeUtil.isLiteralValue(n)) {\n+      boolean result = NodeUtil.getBooleanValue(n);\n+      if (result) {\n+        parent.replaceChild(n, new Node(Token.EMPTY));\n+        compiler.reportCodeChange();\n+      }\n+    }\n+  }\n+  \n+  /**\n    * Replaces a node with a number node if the new number node is not equivalent\n    * to the current node.\n    */\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n-import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.FunctionType;\n-import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.EnumType;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Set the JSDocInfo on all types.\n+ *\n+ * Propagates JSDoc across the type graph, but not across the symbol graph.\n+ * This means that if you have:\n+ * <code>\n+ * var x = new Foo();\n+ * x.bar;\n+ * </code>\n+ * then the JSType attached to x.bar may get associated JSDoc, but the\n+ * Node and Var will not.\n+ *\n+ * JSDoc is initially attached to AST Nodes at parse time.\n+ * There are 3 ways that JSDoc get propagated across the type system.\n+ * 1) Nominal types (e.g., constructors) may contain JSDocInfo for their\n+ *    declaration.\n+ * 2) Object types have a JSDocInfo slot for each property on that type.\n+ * 3) Shape types (like structural functions) may have JSDocInfo.\n+ *\n+ * #1 and #2 should be self-explanatory, and non-controversial. #3 is\n+ * a bit trickier. It means that if you have:\n+ * <code>\n+ * /** @param {number} x /\n+ * Foo.prototype.bar = goog.abstractMethod;\n+ * </code>\n+ * the JSDocInfo will appear in two places in the type system: in the 'bar'\n+ * slot of Foo.prototype, and on the anonymous function type created by\n+ * this expression.\n  *\n *\n  */\n     JSDocInfo docInfo;\n \n     switch (n.getType()) {\n-      case Token.FUNCTION:\n-        // Infer JSDocInfo on all programmer-defined types.\n-        // Conveniently, all programmer-defined types are functions.\n-        JSType fnType = n.getJSType();\n-        if (fnType == null) {\n-          break;\n+      // Infer JSDocInfo on types of all type declarations on variables.\n+      case Token.NAME:\n+        if (parent == null) {\n+          return;\n+        }\n+\n+        // Only allow JSDoc on VARs, function declarations, and assigns.\n+        if (parent.getType() != Token.VAR &&\n+            !NodeUtil.isFunctionDeclaration(parent) &&\n+            !(parent.getType() == Token.ASSIGN &&\n+              n == parent.getFirstChild())) {\n+          return;\n         }\n \n         // There are four places the doc info could live.\n         // /** ... */ var x = function() { ... }\n         docInfo = n.getJSDocInfo();\n         if (docInfo == null &&\n-            (parent.getType() == Token.ASSIGN ||\n-             parent.getType() == Token.NAME)) {\n+            !(parent.getType() == Token.VAR &&\n+                !parent.hasOneChild())) {\n           docInfo = parent.getJSDocInfo();\n-\n-          if (docInfo == null) {\n-            Node gramps = parent.getParent();\n-            if (gramps != null && gramps.getType() == Token.VAR &&\n-                gramps.hasOneChild()) {\n-              docInfo = gramps.getJSDocInfo();\n-            }\n-          }\n-        }\n-\n-        if (docInfo != null && fnType instanceof FunctionType) {\n-          FunctionType maybeCtorType = (FunctionType) fnType;\n-          maybeCtorType.setJSDocInfo(docInfo);\n-          if (maybeCtorType.isConstructor()) {\n-            maybeCtorType.getInstanceType().setJSDocInfo(docInfo);\n-          }\n-        }\n+        }\n+\n+        // Try to find the type of the NAME.\n+        JSType varType = n.getJSType();\n+        if (varType == null && parent.getType() == Token.FUNCTION) {\n+          varType = parent.getJSType();\n+        }\n+\n+        // If we have no type to attach JSDocInfo to, then there's nothing\n+        // we can do.\n+        if (varType == null || docInfo == null) {\n+          return;\n+        }\n+\n+        // Dereference the type. If the result is not an object, or already\n+        // has docs attached, then do nothing.\n+        ObjectType objType = dereferenceToObject(varType);\n+        if (objType == null || objType.getJSDocInfo() != null) {\n+          return;\n+        }\n+\n+        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n         break;\n \n       case Token.GETPROP:\n             docInfo = parent.getJSDocInfo();\n           }\n           if (docInfo != null) {\n-            JSType lhsType = n.getFirstChild().getJSType();\n-            if (lhsType != null &&\n-                lhsType instanceof ObjectType) {\n-              ObjectType objectType = (ObjectType) lhsType;\n-              objectType.setPropertyJSDocInfo(\n-                  n.getLastChild().getString(), docInfo, inExterns);\n+            ObjectType lhsType =\n+                dereferenceToObject(n.getFirstChild().getJSType());\n+            if (lhsType != null) {\n+              // Put the JSDoc in the property slot, if there is one.\n+              String propName = n.getLastChild().getString();\n+              if (lhsType.hasOwnProperty(propName)) {\n+                lhsType.setPropertyJSDocInfo(propName, docInfo, inExterns);\n+              }\n+\n+              // Put the JSDoc in any constructors or function shapes as well.\n+              ObjectType propType =\n+                  dereferenceToObject(lhsType.getPropertyType(propName));\n+              if (propType != null) {\n+                attachJSDocInfoToNominalTypeOrShape(\n+                    propType, docInfo, n.getQualifiedName());\n+              }\n             }\n           }\n         }\n         break;\n     }\n   }\n+\n+  /**\n+   * Dereferences the given type to an object, or returns null.\n+   */\n+  private ObjectType dereferenceToObject(JSType type) {\n+    type = type == null ? null : type.dereference();\n+    return (type instanceof ObjectType) ? (ObjectType) type : null;\n+  }\n+\n+  /**\n+   * Handle cases #1 and #3 in the class doc.\n+   */\n+  private void attachJSDocInfoToNominalTypeOrShape(\n+      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n+    if (objType.isConstructor() ||\n+        objType.isEnumType() ||\n+        objType.isInterface()) {\n+      // Named types.\n+      if (objType.hasReferenceName() &&\n+          objType.getReferenceName().equals(qName)) {\n+        objType.setJSDocInfo(docInfo);\n+\n+        if (objType.isConstructor() || objType.isInterface()) {\n+          ((FunctionType) objType).getInstanceType().setJSDocInfo(\n+              docInfo);\n+        } else if (objType instanceof EnumType) {\n+          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n+        }\n+      }\n+    } else if (!objType.isNativeObjectType() &&\n+        objType.isFunctionType()) {\n+      // Structural functions.\n+      objType.setJSDocInfo(docInfo);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n \n   public void process(Node externs, Node root) {\n     sanityCheckNormalization(externs, root);\n-    sanityCheckCodeGeneration(root);\n+    Node reparsedRoot = sanityCheckCodeGeneration(root);\n+    if (reparsedRoot != null) {\n+      sanityCheckSymbolTable(reparsedRoot, root);\n+    }\n+  }\n+\n+  /**\n+   * Sanity checks that symbol table is up-to-date.\n+   */\n+  private void sanityCheckSymbolTable(Node reparsedRoot, Node originalRoot) {\n+    SymbolTable table = compiler.acquireSymbolTable();\n+    table.verify(reparsedRoot, originalRoot);\n+    table.release();\n   }\n \n   /**\n    * Sanity checks code generation by performing it once, parsing the result,\n    * then generating code from the second parse tree to verify that it matches\n    * the code generated from the first parse tree.\n+   *\n+   * @return The regenerated parse tree. Null on error.\n    */\n-  private void sanityCheckCodeGeneration(Node root) {\n+  private Node sanityCheckCodeGeneration(Node root) {\n     if (compiler.hasHaltingErrors()) {\n       // Don't even bother checking code generation if we already know the\n       // the code is bad.\n-      return;\n+      return null;\n     }\n \n     String source = compiler.toSource(root);\n     if (compiler.hasHaltingErrors()) {\n       compiler.report(JSError.make(CANNOT_PARSE_GENERATED_CODE,\n               StringUtil.truncateAtMaxLength(source, 100, true)));\n-      return;\n+      return null;\n     }\n \n     String source2 = compiler.toSource(root2);\n               StringUtil.truncateAtMaxLength(source, 100, true),\n               StringUtil.truncateAtMaxLength(source2, 100, true)));\n     }\n+\n+    return root2;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n  */\n class SymbolTable implements ScopeCreator, CodeChangeHandler {\n   static final DiagnosticType MISSING_VARIABLE =\n-      DiagnosticType.warning(\n+      DiagnosticType.error(\n           \"JSC_MISSING_VARIABLE\",\n           \"Missing variable name: {0}\");\n \n   static final DiagnosticType MOVED_VARIABLE =\n-      DiagnosticType.warning(\n+      DiagnosticType.error(\n           \"JSC_MOVED_VARIABLE\",\n           \"Moved variable name: {0}\");\n \n   static final DiagnosticType VARIABLE_COUNT_MISMATCH =\n-      DiagnosticType.warning(\n+      DiagnosticType.error(\n           \"JSC_VARIABLE_COUNT_MISMATCH\",\n           \"Variable count does not match.\" +\n           \"\\nCached : {0}\\nActual : {1}\");\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  boolean isNominalType() {\n+  public boolean isNominalType() {\n     return hasReferenceName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   }\n \n   @Override\n-  boolean isNominalType() {\n+  public boolean isNominalType() {\n     return hasReferenceName();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * Whether this type is a nominal type (a named instance object or\n    * a named enum).\n    */\n-  boolean isNominalType() {\n+  public boolean isNominalType() {\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   }\n \n   @Override\n-  boolean isNominalType() {\n+  public boolean isNominalType() {\n     return true;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  boolean isNominalType() {\n+  public boolean isNominalType() {\n     return referencedType.isNominalType();\n   }\n \n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+/* \n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+ \n+package com.google.javascript.rhino.testing;\n+\n+import com.google.javascript.rhino.JSTypeExpression;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.RecordTypeBuilder;\n+\n+import junit.framework.TestCase;\n+\n+\n+public abstract class BaseJSTypeTestCase extends TestCase {\n+  protected JSTypeRegistry registry;\n+  protected TestErrorReporter errorReporter;\n+\n+  protected JSType ALL_TYPE;\n+  protected ObjectType NO_OBJECT_TYPE;\n+  protected ObjectType NO_TYPE;\n+  protected JSType ARRAY_FUNCTION_TYPE;\n+  protected ObjectType ARRAY_TYPE;\n+  protected JSType BOOLEAN_OBJECT_FUNCTION_TYPE;\n+  protected ObjectType BOOLEAN_OBJECT_TYPE;\n+  protected JSType BOOLEAN_TYPE;\n+  protected JSType CHECKED_UNKNOWN_TYPE;\n+  protected JSType DATE_FUNCTION_TYPE;\n+  protected ObjectType DATE_TYPE;\n+  protected JSType ERROR_FUNCTION_TYPE;\n+  protected ObjectType ERROR_TYPE;\n+  protected JSType EVAL_ERROR_FUNCTION_TYPE;\n+  protected ObjectType EVAL_ERROR_TYPE;\n+  protected FunctionType FUNCTION_FUNCTION_TYPE;\n+  protected FunctionType FUNCTION_INSTANCE_TYPE;\n+  protected ObjectType FUNCTION_PROTOTYPE;\n+  protected JSType GREATEST_FUNCTION_TYPE;\n+  protected JSType LEAST_FUNCTION_TYPE;\n+  protected JSType MATH_TYPE;\n+  protected JSType NULL_TYPE;\n+  protected JSType NUMBER_OBJECT_FUNCTION_TYPE;\n+  protected ObjectType NUMBER_OBJECT_TYPE;\n+  protected JSType NUMBER_STRING_BOOLEAN;\n+  protected JSType NUMBER_TYPE;\n+  protected FunctionType OBJECT_FUNCTION_TYPE;\n+  protected JSType OBJECT_NUMBER_STRING;\n+  protected JSType OBJECT_NUMBER_STRING_BOOLEAN;\n+  protected JSType OBJECT_PROTOTYPE;\n+  protected ObjectType OBJECT_TYPE;\n+  protected JSType RANGE_ERROR_FUNCTION_TYPE;\n+  protected ObjectType RANGE_ERROR_TYPE;\n+  protected JSType REFERENCE_ERROR_FUNCTION_TYPE;\n+  protected ObjectType REFERENCE_ERROR_TYPE;\n+  protected JSType REGEXP_FUNCTION_TYPE;\n+  protected ObjectType REGEXP_TYPE;\n+  protected JSType STRING_OBJECT_FUNCTION_TYPE;\n+  protected ObjectType STRING_OBJECT_TYPE;\n+  protected JSType STRING_TYPE;\n+  protected JSType SYNTAX_ERROR_FUNCTION_TYPE;\n+  protected ObjectType SYNTAX_ERROR_TYPE;\n+  protected JSType TYPE_ERROR_FUNCTION_TYPE;\n+  protected ObjectType TYPE_ERROR_TYPE;\n+  protected FunctionType U2U_CONSTRUCTOR_TYPE;\n+  protected FunctionType U2U_FUNCTION_TYPE;\n+  protected ObjectType UNKNOWN_TYPE;\n+  protected JSType URI_ERROR_FUNCTION_TYPE;\n+  protected ObjectType URI_ERROR_TYPE;\n+  protected JSType VOID_TYPE;\n+\n+  protected int NATIVE_PROPERTIES_COUNT;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    errorReporter = new TestErrorReporter(null, null);\n+    registry = new JSTypeRegistry(errorReporter);\n+    initTypes();\n+  }\n+\n+  protected void initTypes() {\n+    ALL_TYPE =\n+        registry.getNativeType(JSTypeNative.ALL_TYPE);\n+    NO_OBJECT_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n+    NO_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n+    ARRAY_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE);\n+    ARRAY_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);\n+    BOOLEAN_OBJECT_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE);\n+    BOOLEAN_OBJECT_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);\n+    BOOLEAN_TYPE =\n+        registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+    CHECKED_UNKNOWN_TYPE =\n+        registry.getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+    DATE_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);\n+    DATE_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.DATE_TYPE);\n+    ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.ERROR_FUNCTION_TYPE);\n+    ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.ERROR_TYPE);\n+    EVAL_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE);\n+    EVAL_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.EVAL_ERROR_TYPE);\n+    FUNCTION_FUNCTION_TYPE =\n+        registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);\n+    FUNCTION_INSTANCE_TYPE =\n+        registry.getNativeFunctionType(JSTypeNative.FUNCTION_INSTANCE_TYPE);\n+    FUNCTION_PROTOTYPE =\n+        registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE);\n+    GREATEST_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE);\n+    LEAST_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);\n+    NULL_TYPE =\n+        registry.getNativeType(JSTypeNative.NULL_TYPE);\n+    NUMBER_OBJECT_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE);\n+    NUMBER_OBJECT_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);\n+    NUMBER_STRING_BOOLEAN =\n+        registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN);\n+    NUMBER_TYPE =\n+        registry.getNativeType(JSTypeNative.NUMBER_TYPE);\n+    OBJECT_FUNCTION_TYPE =\n+        registry.getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE);\n+    OBJECT_NUMBER_STRING =\n+        registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING);\n+    OBJECT_NUMBER_STRING_BOOLEAN =\n+        registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN);\n+    OBJECT_PROTOTYPE =\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE);\n+    OBJECT_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n+    RANGE_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE);\n+    RANGE_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.RANGE_ERROR_TYPE);\n+    REFERENCE_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE);\n+    REFERENCE_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.REFERENCE_ERROR_TYPE);\n+    REGEXP_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE);\n+    REGEXP_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);\n+    STRING_OBJECT_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE);\n+    STRING_OBJECT_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);\n+    STRING_TYPE =\n+        registry.getNativeType(JSTypeNative.STRING_TYPE);\n+    SYNTAX_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE);\n+    SYNTAX_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.SYNTAX_ERROR_TYPE);\n+    TYPE_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE);\n+    TYPE_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.TYPE_ERROR_TYPE);\n+    U2U_CONSTRUCTOR_TYPE =\n+        registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n+    U2U_FUNCTION_TYPE =\n+        registry.getNativeFunctionType(JSTypeNative.U2U_FUNCTION_TYPE);\n+    UNKNOWN_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n+    URI_ERROR_FUNCTION_TYPE =\n+        registry.getNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE);\n+    URI_ERROR_TYPE =\n+        registry.getNativeObjectType(JSTypeNative.URI_ERROR_TYPE);\n+    VOID_TYPE =\n+        registry.getNativeType(JSTypeNative.VOID_TYPE);\n+\n+    addNativeProperties(registry);\n+\n+    NATIVE_PROPERTIES_COUNT = OBJECT_TYPE.getPropertiesCount();\n+  }\n+\n+  /** Adds a basic set of properties to the native types. */\n+  public static void addNativeProperties(JSTypeRegistry registry) {\n+    JSType booleanType = registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+    JSType numberType = registry.getNativeType(JSTypeNative.NUMBER_TYPE);\n+    JSType stringType = registry.getNativeType(JSTypeNative.STRING_TYPE);\n+    JSType unknownType = registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+\n+    ObjectType objectType =\n+        registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n+    ObjectType arrayType =\n+        registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);\n+    ObjectType dateType =\n+        registry.getNativeObjectType(JSTypeNative.DATE_TYPE);\n+    ObjectType regexpType =\n+        registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);\n+    ObjectType booleanObjectType =\n+        registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);\n+    ObjectType numberObjectType =\n+        registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);\n+    ObjectType stringObjectType =\n+        registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);\n+\n+    ObjectType objectPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, objectPrototype, \"constructor\", objectType);\n+    addMethod(registry, objectPrototype, \"toString\", stringType);\n+    addMethod(registry, objectPrototype, \"toLocaleString\", stringType);\n+    addMethod(registry, objectPrototype, \"valueOf\", unknownType);\n+    addMethod(registry, objectPrototype, \"hasOwnProperty\", booleanType);\n+    addMethod(registry, objectPrototype, \"isPrototypeOf\", booleanType);\n+    addMethod(registry, objectPrototype, \"propertyIsEnumerable\", booleanType);\n+\n+    ObjectType arrayPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, arrayPrototype, \"constructor\", arrayType);\n+    addMethod(registry, arrayPrototype, \"toString\", stringType);\n+    addMethod(registry, arrayPrototype, \"toLocaleString\", stringType);\n+    addMethod(registry, arrayPrototype, \"concat\", arrayType);\n+    addMethod(registry, arrayPrototype, \"join\", stringType);\n+    addMethod(registry, arrayPrototype, \"pop\", unknownType);\n+    addMethod(registry, arrayPrototype, \"push\", numberType);\n+    addMethod(registry, arrayPrototype, \"reverse\", arrayType);\n+    addMethod(registry, arrayPrototype, \"shift\", unknownType);\n+    addMethod(registry, arrayPrototype, \"slice\", arrayType);\n+    addMethod(registry, arrayPrototype, \"sort\", arrayType);\n+    addMethod(registry, arrayPrototype, \"splice\", arrayType);\n+    addMethod(registry, arrayPrototype, \"unshift\", numberType);\n+    arrayType.defineDeclaredProperty(\"length\", numberType, true);\n+\n+    ObjectType booleanPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, booleanPrototype, \"constructor\", booleanObjectType);\n+    addMethod(registry, booleanPrototype, \"toString\", stringType);\n+    addMethod(registry, booleanPrototype, \"valueOf\", booleanType);\n+\n+    ObjectType datePrototype = registry\n+        .getNativeFunctionType(JSTypeNative.DATE_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, datePrototype, \"constructor\", dateType);\n+    addMethod(registry, datePrototype, \"toString\", stringType);\n+    addMethod(registry, datePrototype, \"toDateString\", stringType);\n+    addMethod(registry, datePrototype, \"toTimeString\", stringType);\n+    addMethod(registry, datePrototype, \"toLocaleString\", stringType);\n+    addMethod(registry, datePrototype, \"toLocaleDateString\", stringType);\n+    addMethod(registry, datePrototype, \"toLocaleTimeString\", stringType);\n+    addMethod(registry, datePrototype, \"valueOf\", numberType);\n+    addMethod(registry, datePrototype, \"getTime\", numberType);\n+    addMethod(registry, datePrototype, \"getFullYear\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCFullYear\", numberType);\n+    addMethod(registry, datePrototype, \"getMonth\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCMonth\", numberType);\n+    addMethod(registry, datePrototype, \"getDate\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCDate\", numberType);\n+    addMethod(registry, datePrototype, \"getDay\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCDay\", numberType);\n+    addMethod(registry, datePrototype, \"getHours\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCHours\", numberType);\n+    addMethod(registry, datePrototype, \"getMinutes\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCMinutes\", numberType);\n+    addMethod(registry, datePrototype, \"getSeconds\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCSeconds\", numberType);\n+    addMethod(registry, datePrototype, \"getMilliseconds\", numberType);\n+    addMethod(registry, datePrototype, \"getUTCMilliseconds\", numberType);\n+    addMethod(registry, datePrototype, \"getTimezoneOffset\", numberType);\n+    addMethod(registry, datePrototype, \"setTime\", numberType);\n+    addMethod(registry, datePrototype, \"setMilliseconds\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCMilliseconds\", numberType);\n+    addMethod(registry, datePrototype, \"setSeconds\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCSeconds\", numberType);\n+    addMethod(registry, datePrototype, \"setMinutes\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCMinutes\", numberType);\n+    addMethod(registry, datePrototype, \"setHours\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCHours\", numberType);\n+    addMethod(registry, datePrototype, \"setDate\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCDate\", numberType);\n+    addMethod(registry, datePrototype, \"setMonth\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCMonth\", numberType);\n+    addMethod(registry, datePrototype, \"setFullYear\", numberType);\n+    addMethod(registry, datePrototype, \"setUTCFullYear\", numberType);\n+    addMethod(registry, datePrototype, \"toUTCString\", stringType);\n+    addMethod(registry, datePrototype, \"toGMTString\", stringType);\n+\n+    ObjectType numberPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, numberPrototype, \"constructor\", numberObjectType);\n+    addMethod(registry, numberPrototype, \"toString\", stringType);\n+    addMethod(registry, numberPrototype, \"toLocaleString\", stringType);\n+    addMethod(registry, numberPrototype, \"valueOf\", numberType);\n+    addMethod(registry, numberPrototype, \"toFixed\", stringType);\n+    addMethod(registry, numberPrototype, \"toExponential\", stringType);\n+    addMethod(registry, numberPrototype, \"toPrecision\", stringType);\n+\n+    ObjectType regexpPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.REGEXP_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, regexpPrototype, \"constructor\", regexpType);\n+    addMethod(registry, regexpPrototype, \"exec\",\n+        registry.createNullableType(arrayType));\n+    addMethod(registry, regexpPrototype, \"test\", booleanType);\n+    addMethod(registry, regexpPrototype, \"toString\", stringType);\n+    regexpType.defineDeclaredProperty(\"source\", stringType, true);\n+    regexpType.defineDeclaredProperty(\"global\", booleanType, true);\n+    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, true);\n+    regexpType.defineDeclaredProperty(\"multiline\", booleanType, true);\n+    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, true);\n+\n+    ObjectType stringPrototype = registry\n+        .getNativeFunctionType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE)\n+        .getPrototype();\n+    addMethod(registry, stringPrototype, \"constructor\", stringObjectType);\n+    addMethod(registry, stringPrototype, \"toString\", stringType);\n+    addMethod(registry, stringPrototype, \"valueOf\", stringType);\n+    addMethod(registry, stringPrototype, \"charAt\", stringType);\n+    addMethod(registry, stringPrototype, \"charCodeAt\", numberType);\n+    addMethod(registry, stringPrototype, \"concat\", stringType);\n+    addMethod(registry, stringPrototype, \"indexOf\", numberType);\n+    addMethod(registry, stringPrototype, \"lastIndexOf\", numberType);\n+    addMethod(registry, stringPrototype, \"localeCompare\", numberType);\n+    addMethod(registry, stringPrototype, \"match\",\n+        registry.createNullableType(arrayType));\n+    addMethod(registry, stringPrototype, \"replace\", stringType);\n+    addMethod(registry, stringPrototype, \"search\", numberType);\n+    addMethod(registry, stringPrototype, \"slice\", stringType);\n+    addMethod(registry, stringPrototype, \"split\", arrayType);\n+    addMethod(registry, stringPrototype, \"substring\", stringType);\n+    addMethod(registry, stringPrototype, \"toLowerCase\", stringType);\n+    addMethod(registry, stringPrototype, \"toLocaleLowerCase\", stringType);\n+    addMethod(registry, stringPrototype, \"toUpperCase\", stringType);\n+    addMethod(registry, stringPrototype, \"toLocaleUpperCase\", stringType);\n+    stringObjectType.defineDeclaredProperty(\"length\", numberType, true);\n+  }\n+\n+  private static void addMethod(\n+      JSTypeRegistry registry, ObjectType receivingType, String methodName,\n+      JSType returnType) {\n+    receivingType.defineDeclaredProperty(methodName,\n+        new FunctionType(registry, null, null, null, returnType), true);\n+  }\n+\n+  protected JSType createUnionType(JSType... variants) {\n+    return registry.createUnionType(variants);\n+  }\n+\n+  protected RecordTypeBuilder createRecordTypeBuilder() {\n+    return new RecordTypeBuilder(registry);\n+  }\n+\n+  protected JSType createNullableType(JSType type) {\n+    return registry.createNullableType(type);\n+  }\n+\n+  protected JSType createOptionalType(JSType type) {\n+    return registry.createOptionalType(type);\n+  }\n+\n+  /**\n+   * Asserts that a Node representing a type expression resolves to the\n+   * correct {@code JSType}.\n+   */\n+  protected void assertTypeEquals(JSType expected, Node actual) {\n+    assertTypeEquals(expected, new JSTypeExpression(actual, \"\", registry));\n+  }\n+\n+  /**\n+   * Asserts that a a type expression resolves to the correct {@code JSType}.\n+   */\n+  protected void assertTypeEquals(JSType expected, JSTypeExpression actual) {\n+    assertEquals(expected, resolve(actual));\n+  }\n+\n+  /**\n+   * Resolves a type expression, expecting the given warnings.\n+   */\n+  protected JSType resolve(JSTypeExpression n, String... warnings) {\n+    errorReporter.setWarnings(warnings);\n+    return n.evaluate(null);\n+  }\n+\n+  /**\n+   * A definition of all extern types. This should be kept in sync with\n+   * javascript/externs/es3.js. This is used to check that the builtin types\n+   * declared in {@link JSTypeRegistry} have the same type as that in the\n+   * externs. It can also be used for any tests that want to use builtin types\n+   * in their externs.\n+   */\n+  public static final String ALL_NATIVE_EXTERN_TYPES =\n+      \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @param {*} opt_value\\n\"\n+      + \" */\\n\"\n+      + \"function Object(opt_value) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Object}\\n\"\n+      + \" * @param {*} var_args\\n\"\n+      + \" */\\n\"\n+      + \"\\n\"\n+      + \"function Function(var_args) {}\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Object}\\n\"\n+      + \" * @param {*} var_args\\n\"\n+      + \" * @return {!Array}\\n\"\n+      + \" */\\n\"\n+      + \"function Array(var_args) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @param {*} opt_value\\n\"\n+      + \" * @return {boolean}\\n\"\n+      + \" */\\n\"\n+      + \"function Boolean(opt_value) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @param {*} opt_value\\n\"\n+      + \" * @return {number}\\n\"\n+      + \" */\\n\"\n+      + \"function Number(opt_value) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @return {string}\\n\"\n+      + \" */\\n\"\n+      + \"function Date(opt_yr_num, opt_mo_num, opt_day_num, opt_hr_num,\"\n+      + \"    opt_min_num, opt_sec_num, opt_ms_num) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Object}\\n\"\n+      + \" * @param {*} opt_str\\n\"\n+      + \" * @return {string}\\n\"\n+      + \" */\\n\"\n+      + \"function String(opt_str) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @param {*} opt_pattern\\n\"\n+      + \" * @param {*} opt_flags\\n\"\n+      + \" * @return {!RegExp}\\n\"\n+      + \" */\\n\"\n+      + \"function RegExp(opt_pattern, opt_flags) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!Error}\\n\"\n+      + \" */\\n\"\n+      + \"function Error(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!EvalError}\\n\"\n+      + \" */\\n\"\n+      + \"function EvalError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!RangeError}\\n\"\n+      + \" */\\n\"\n+      + \"function RangeError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!ReferenceError}\\n\"\n+      + \" */\\n\"\n+      + \"function ReferenceError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!SyntaxError}\\n\"\n+      + \" */\\n\"\n+      + \"function SyntaxError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!TypeError}\\n\"\n+      + \" */\\n\"\n+      + \"function TypeError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @constructor\\n\"\n+      + \" * @extends {Error}\\n\"\n+      + \" * @param {*} opt_message\\n\"\n+      + \" * @param {*} opt_file\\n\"\n+      + \" * @param {*} opt_line\\n\"\n+      + \" * @return {!URIError}\\n\"\n+      + \" */\\n\"\n+      + \"function URIError(opt_message, opt_file, opt_line) {}\\n\"\n+      + \"\\n\"\n+      + \"/**\\n\"\n+      + \" * @param {string} progId\\n\"\n+      + \" * @param {string} opt_location\\n\"\n+      + \" * @constructor\\n\"\n+      + \" */\\n\"\n+      + \"function ActiveXObject(progId, opt_location) {}\\n\";\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/testing/TestErrorReporter.java\n+/* \n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+ \n+package com.google.javascript.rhino.testing;\n+\n+import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.EvaluatorException;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ * <p>An error reporter for testing that verifies that messages reported to the\n+ * reporter are expected.</p>\n+ *\n+ * <p>Sample use</p>\n+ * <pre>\n+ * TestErrorReporter e =\n+ *   new TestErrorReporter(null, new String[] { \"first warning\" });\n+ * ...\n+ * assertTrue(e.hasEncounteredAllWarnings());\n+ * </pre>\n+ *\n+*\n+ */\n+public final class TestErrorReporter extends Assert implements ErrorReporter {\n+  private String[] errors;\n+  private String[] warnings;\n+  private int errorsIndex = 0;\n+  private int warningsIndex = 0;\n+\n+  public TestErrorReporter(String[] errors, String[] warnings) {\n+    this.errors = errors;\n+    this.warnings = warnings;\n+  }\n+\n+  public void setErrors(String[] errors) {\n+    this.errors = errors;\n+    errorsIndex = 0;\n+  }\n+\n+  public void setWarnings(String[] warnings) {\n+    this.warnings = warnings;\n+    warningsIndex = 0;\n+  }\n+\n+  public void error(String message, String sourceName, int line,\n+      String lineSource, int lineOffset) {\n+    if (errors != null && errorsIndex < errors.length) {\n+      assertEquals(errors[errorsIndex++], message);\n+    } else {\n+      fail(\"extra error: \" + message);\n+    }\n+  }\n+\n+  public void warning(String message, String sourceName, int line,\n+      String lineSource, int lineOffset) {\n+    if (warnings != null && warningsIndex < warnings.length) {\n+      assertEquals(warnings[warningsIndex++], message);\n+    } else {\n+      fail(\"extra warning: \" + message);\n+    }\n+  }\n+\n+  public EvaluatorException runtimeError(String message, String sourceName,\n+      int line, String lineSource, int lineOffset) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Returns whether all warnings were reported to this reporter.\n+   */\n+  public boolean hasEncounteredAllWarnings() {\n+    return (warnings == null) ?\n+        warningsIndex == 0 :\n+        warnings.length == warningsIndex;\n+  }\n+\n+  /**\n+   * Returns whether all errors were reported to this reporter.\n+   */\n+  public boolean hasEncounteredAllErrors() {\n+    return (errors == null) ?\n+        errorsIndex == 0 :\n+        errors.length == errorsIndex;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   private boolean normalizeEnabled = false;\n \n   /**\n+   * An expected symbol table error. Only useful for testing the\n+   * symbol table error-handling.\n+   */\n+  private DiagnosticType expectedSymbolTableError = null;\n+\n+  /**\n    * Whether the MarkNoSideEffectsCalls pass runs before the pass being tested\n    */\n   private boolean markNoSideEffects = false;\n           0, compiler.getErrorCount());\n \n       // Verify the symbol table.\n-      ErrorManager symbolTableWarnings = new BlackHoleErrorManager(compiler);\n+      ErrorManager symbolTableErrorManager =\n+          new BlackHoleErrorManager(compiler);\n       Node expectedRoot = parseExpectedJs(expected);\n       SymbolTable table = compiler.acquireSymbolTable();\n       table.verify(expectedRoot, mainRoot);\n       table.release();\n \n+      JSError[] stErrors = symbolTableErrorManager.getErrors();\n+      if (expectedSymbolTableError != null) {\n+        assertEquals(\"There should be one error.\", 1, stErrors.length);\n+        assertEquals(expectedSymbolTableError, stErrors[0].getType());\n+      } else {\n+        assertEquals(\"Unexpected symbol table error(s): \" +\n+            Join.join(\"\\n\", stErrors),\n+            0, stErrors.length);\n+      }\n+\n       if (warning == null) {\n         assertEquals(\n             \"Unexpected warning(s): \" + Join.join(\"\\n\", aggregateWarnings),\n             0, aggregateWarningCount);\n-      } else if (symbolTableWarnings.getWarnings().length > 0) {\n-        JSError[] warnings = symbolTableWarnings.getWarnings();\n-        assertEquals(\"There should be one symbol table warning\",\n-            1, warnings.length);\n-        assertEquals(warning, warnings[0].getType());\n       } else {\n         assertEquals(\"There should be one warning, repeated \" + numRepetitions +\n             \" time(s).\", numRepetitions, aggregateWarningCount);\n     Compiler compiler = new Compiler();\n     return compiler;\n   }\n+\n+  protected void setExpectedSymbolTableError(DiagnosticType type) {\n+    this.expectedSymbolTableError = type;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/ControlStructureCheckTest.java\n+++ b/test/com/google/javascript/jscomp/ControlStructureCheckTest.java\n *\n  */\n public class ControlStructureCheckTest extends CompilerTestCase {\n+  // Rhino parse error message text\n+  final String UNLABELED_BREAK =\n+    \"unlabelled break must be inside loop or switch\";\n+\n+  final String UNEXPECTED_CONTINUE = \"continue must be inside loop\";\n+\n+  final String UNEXPECTED_LABLED_CONTINUE =\n+    \"continue can only use labeles of iteration statements\";\n+\n+  final String UNDEFINED_LABEL = \"undefined label\";\n+\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return new ControlStructureCheck(compiler);\n   }\n \n   public void testContinueToLabelSwitch() {\n-    assertInvalidLabelContinue(\n+    assertInvalidLabeledContinue(\n         \"while(1) {a: switch(1) {case(1): continue a; }}\");\n   }\n \n     assertNoError(\"b: while(1) { a: switch(1) { case(1): continue b; } }\");\n   }\n \n-  public void testContinueNotCrossFunction() {\n+  public void testContinueNotCrossFunction1() {\n     assertNoError(\"a:switch(1){case(1):function f(){a:while(1){continue a;}}}\");\n+  }\n+\n+  public void testContinueNotCrossFunction2() {\n+    assertUndefinedLabel(\n+        \"a:switch(1){case(1):function f(){while(1){continue a;}}}\");\n   }\n \n   public void testUseOfWith1() {\n   }\n \n   private void assertInvalidBreak(String js) {\n-    assertSomeError(js, ControlStructureCheck.INVALID_BREAK);\n+    testParseError(js, UNLABELED_BREAK);\n   }\n \n   private void assertInvalidContinue(String js) {\n-    assertSomeError(js, ControlStructureCheck.INVALID_CONTINUE);\n+    testParseError(js, UNEXPECTED_CONTINUE);\n   }\n \n-  private void assertInvalidLabelContinue(String js) {\n-    assertSomeError(js, ControlStructureCheck.INVALID_LABEL_CONTINUE);\n+  private void assertInvalidLabeledContinue(String js) {\n+    testParseError(js, UNEXPECTED_LABLED_CONTINUE);\n   }\n \n-  /**\n-   * Tests that either a parse error or the given error is triggered.\n-   * The new parser is stricter with control structure checks, so it will catch\n-   * some of these at parse time.\n-   */\n-  private void assertSomeError(String js, DiagnosticType error) {\n-    if (!hasParseError(js)) {\n-      test(js, js, error);\n-    }\n+  private void assertUndefinedLabel(String js) {\n+    testParseError(js, UNDEFINED_LABEL);\n   }\n \n-  private boolean hasParseError(String js) {\n+  private void testParseError(String js, String errorText) {\n     Compiler compiler = new Compiler();\n     compiler.parseTestCode(js);\n-    return compiler.getErrorCount() > 0;\n+    assertTrue(compiler.getErrorCount() == 1);\n+    String msg = compiler.getErrors()[0].toString();\n+    assertTrue(msg.contains(errorText));\n   }\n }\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     fold(\"for(;!true;) { foo() }\", \"\");\n     fold(\"for(;void 0;) { foo() }\", \"\");\n     fold(\"for(;undefined;) { foo() }\", \"\");\n-    fold(\"for(;!false;) foo() \", \"for(;1;) foo()\");\n-    fold(\"for(;true;) foo() \", \"for(;1;) foo() \");\n-    fold(\"for(;!void 0;) foo()\", \"for(;1;) foo()\");\n+    fold(\"for(;!false;) foo() \", \"for(;;) foo()\");\n+    fold(\"for(;true;) foo() \", \"for(;;) foo() \");\n+    fold(\"for(;1;) foo()\", \"for(;;) foo()\");\n+    foldSame(\"for(;;) foo()\");\n+    fold(\"for(;!void 0;) foo()\", \"for(;;) foo()\");\n     fold(\"for(;false;) { var a = 0; }\", \"var a\");\n \n     // Make sure it plays nice with minimizing\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.ScopeCreator;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.Deque;\n+\n+\n+/**\n+ * Tests for {@link InferJSDocInfo}.\n+*\n+ */\n+// TODO(nicksantos): A lot of this code is duplicated from\n+// TypedScopeCreatorTest. We should create a common test harness for\n+// assertions about type information.\n+public class InferJSDocInfoTest extends CompilerTestCase {\n+\n+  private JSTypeRegistry registry;\n+  private Scope globalScope;\n+  private Scope lastLocalScope;\n+\n+  @Override\n+  public int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected CompilerOptions getOptions() {\n+    CompilerOptions options = super.getOptions();\n+    options.ideMode = true;\n+    return options;\n+  }\n+\n+  private final Callback callback = new AbstractPostOrderCallback() {\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      Scope s = t.getScope();\n+      if (s.isGlobal()) {\n+        globalScope = s;\n+      } else {\n+        lastLocalScope = s;\n+      }\n+    }\n+  };\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    registry = compiler.getTypeRegistry();\n+    return new CompilerPass() {\n+      public void process(Node externs, Node root) {\n+        ScopeCreator scopeCreator =\n+            new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n+        Scope topScope = scopeCreator.createScope(root.getParent(), null);\n+        (new TypeInferencePass(\n+            compiler, compiler.getReverseAbstractInterpreter(),\n+            topScope, scopeCreator)).process(externs, root);\n+        NodeTraversal t = new NodeTraversal(\n+            compiler, callback, scopeCreator);\n+        t.traverseRoots(Lists.newArrayList(externs, root));\n+        (new InferJSDocInfo(compiler)).process(externs, root);\n+      }\n+    };\n+  }\n+\n+  public void testNativeCtor() {\n+    testSame(\n+        \"/** Object. \\n * @param {*} x \\n * @constructor */ \" +\n+        \"function Object(x) {};\" +\n+        \"var x = new Object();\" +\n+        \"/** Another object. */ var y = new Object();\");\n+    assertEquals(\n+        \"Object.\",\n+        findGlobalNameType(\"x\").getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Object.\",\n+        findGlobalNameType(\"y\").getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Object.\",\n+        globalScope.getVar(\"y\").getType().getJSDocInfo().getBlockDescription());\n+  }\n+\n+  public void testStructuralFunctions() {\n+    testSame(\n+        \"/** Object. \\n * @param {*} x \\n * @constructor */ \" +\n+        \"function Object(x) {};\" +\n+        \"/** Function. \\n * @param {*} x */ \" +\n+        \"function fn(x) {};\" +\n+        \"var goog = {};\" +\n+        \"/** Another object. \\n * @type {Object} */ goog.x = new Object();\" +\n+        \"/** Another function. \\n * @param {number} x */ goog.y = fn;\");\n+    assertEquals(\n+        \"(Object|null)\",\n+        globalScope.getVar(\"goog.x\").getType().toString());\n+    assertEquals(\n+        \"Object.\",\n+        globalScope.getVar(\"goog.x\").getType().restrictByNotNullOrUndefined()\n+        .getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Another function.\",\n+        globalScope.getVar(\"goog.y\").getType()\n+        .getJSDocInfo().getBlockDescription());\n+  }\n+\n+  public void testInstanceObject() {\n+    // Asserts that no property gets attached to the instance object.\n+    testSame(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"var f = new Foo();\" +\n+        \"/** @type {number} */ f.bar = 4;\");\n+    ObjectType type = (ObjectType) globalScope.getVar(\"f\").getType();\n+    assertEquals(\"Foo\", type.toString());\n+    assertFalse(type.hasProperty(\"bar\"));\n+    assertNull(type.getOwnPropertyJSDocInfo(\"bar\"));\n+  }\n+\n+  public void testInterface() {\n+    testSame(\n+        \"/** An interface. \\n * @interface */ function Foo() {}\" +\n+        \"var f = new Foo();\" +\n+        \"/** @type {number} */ f.bar = 4;\");\n+    ObjectType type = (ObjectType) globalScope.getVar(\"Foo\").getType();\n+    assertEquals(\n+        \"An interface.\",\n+        type.getJSDocInfo().getBlockDescription());\n+  }\n+\n+  public void testNamespacedCtor() {\n+    testSame(\n+        \"var goog = {};\" +\n+        \"/** Hello! \\n * @constructor */ goog.Foo = function() {};\" +\n+        \"goog.Foo.bar = goog.Foo;\" +\n+        \"/** Bye! \\n * @param {string=} opt_x */\" +\n+        \"goog.Foo.prototype.baz = goog.Foo;\" +\n+        \"/** Blargh */ var x = new goog.Foo();\");\n+    assertEquals(\n+        \"Hello!\",\n+        findGlobalNameType(\"x\").getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Hello!\",\n+        findGlobalNameType(\"goog.Foo\").getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Hello!\",\n+        findGlobalNameType(\n+            \"goog.Foo.bar\").getJSDocInfo().getBlockDescription());\n+\n+    assertEquals(\n+        \"Hello!\",\n+        findGlobalNameType(\n+            \"goog.Foo.prototype.baz\").getJSDocInfo().getBlockDescription());\n+\n+    ObjectType proto = (ObjectType) findGlobalNameType(\"goog.Foo.prototype\");\n+    assertEquals(\n+        \"Bye!\",\n+        proto.getPropertyType(\"baz\").getJSDocInfo().getBlockDescription());\n+  }\n+\n+  public void testAbstractMethod() {\n+    testSame(\n+        \"/** Abstract method. \\n * @type {!Function} */ var abstractMethod;\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** Block description. \\n * @param {number} x */\" +\n+        \"Foo.prototype.bar = abstractMethod;\");\n+    FunctionType abstractMethod =\n+        (FunctionType) findGlobalNameType(\"abstractMethod\");\n+    assertNull(abstractMethod.getJSDocInfo());\n+\n+    FunctionType ctor = (FunctionType) findGlobalNameType(\"Foo\");\n+    ObjectType proto = ctor.getInstanceType().getImplicitPrototype();\n+    FunctionType method = (FunctionType) proto.getPropertyType(\"bar\");\n+    assertEquals(\n+        \"Block description.\",\n+        method.getJSDocInfo().getBlockDescription());\n+    assertEquals(\n+        \"Block description.\",\n+        proto.getOwnPropertyJSDocInfo(\"bar\").getBlockDescription());\n+  }\n+\n+  private JSType findGlobalNameType(String name) {\n+    return findNameType(name, globalScope);\n+  }\n+\n+  private JSType findNameType(String name, Scope scope) {\n+    Node root = scope.getRootNode();\n+    Deque<Node> queue = Lists.newLinkedList();\n+    queue.push(root);\n+    while (!queue.isEmpty()) {\n+      Node current = queue.pop();\n+      if (name.equals(current.getQualifiedName()) &&\n+          current.getJSType() != null) {\n+        return current.getJSType();\n+      }\n+\n+      for (Node child : current.children()) {\n+        queue.push(child);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private JSType getNativeType(JSTypeNative type) {\n+    return registry.getNativeType(type);\n+  }\n+\n+  private ObjectType getNativeObjectType(JSTypeNative type) {\n+    return (ObjectType) registry.getNativeType(type);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/JSCompilerSourceExcerptProviderTest.java\n+++ b/test/com/google/javascript/jscomp/JSCompilerSourceExcerptProviderTest.java\n     JSSourceFile bar = JSSourceFile.fromCode(\"bar\",\n         \"bar:first line\\nbar:second line\\nbar:third line\\nbar:fourth line\\n\");\n     Compiler compiler = new Compiler();\n-    compiler.init(new JSSourceFile[] {}, new JSSourceFile[] {foo, bar}, null);\n+    CompilerOptions options = new CompilerOptions();\n+    compiler.init(\n+        new JSSourceFile[] {}, new JSSourceFile[] {foo, bar}, options);\n     this.provider = compiler;\n   }\n \n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n \n   @Override public void setUp() {\n     otherPass = null;\n+  }\n+\n+  @Override protected int getNumRepetitions() {\n+    return 1;\n   }\n \n   /** {@inheritDoc} */\n     }\n     assert(exceptionCaught);\n   }\n+\n+  public void testSymbolTable() throws Exception {\n+    otherPass = new CompilerPass() {\n+      @Override public void process(Node externs, Node root) {\n+        SymbolTable st = getLastCompiler().acquireSymbolTable();\n+        st.createScope(root, null);\n+        Node script = root.getFirstChild();\n+        script.removeChild(script.getFirstChild());\n+        st.release();\n+      }\n+    };\n+\n+    test(\"var x;\", null, SymbolTable.VARIABLE_COUNT_MISMATCH);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n  */\n public class SymbolTableTest extends CompilerTestCase {\n \n-  DiagnosticType targetWarning = null;\n+  DiagnosticType targetError = null;\n \n   @Override protected CompilerPass getProcessor(Compiler compiler) {\n     return new BuggyVariableChanger(compiler);\n   }\n \n   @Override public void setUp() {\n-    targetWarning = null;\n+    setExpectedSymbolTableError(null);\n+    targetError = null;\n   }\n \n   public void testOk() throws Exception {\n   }\n \n   public void testCountMismatch() throws Exception {\n-    targetWarning = VARIABLE_COUNT_MISMATCH;\n-    test(\"var x = 3, y = 5;\", \"\", null, targetWarning);\n+    setExpectedSymbolTableError(VARIABLE_COUNT_MISMATCH);\n+    test(\"var x = 3, y = 5;\", \"\");\n   }\n \n   public void testMovedVariable() throws Exception {\n-    targetWarning = MOVED_VARIABLE;\n-    test(\"var x = 3, y = 5;\", \"var x, y = 5;\", null, targetWarning);\n+    setExpectedSymbolTableError(MOVED_VARIABLE);\n+    test(\"var x = 3, y = 5;\", \"var x, y = 5;\");\n   }\n \n   public void testMissingVariable() throws Exception {\n-    targetWarning = MISSING_VARIABLE;\n-    test(\"var x = 3, y = 5;\", \"var z = 3, y = 5;\", null, targetWarning);\n+    setExpectedSymbolTableError(MISSING_VARIABLE);\n+    test(\"var x = 3, y = 5;\", \"var z = 3, y = 5;\");\n+  }\n+\n+  @Override\n+  protected void setExpectedSymbolTableError(DiagnosticType type) {\n+    super.setExpectedSymbolTableError(type);\n+    targetError = type;\n   }\n \n   /**\n       if (node.getType() == Token.VAR) {\n         compiler.reportCodeChange();\n \n-        if (targetWarning == null) {\n+        if (targetError == null) {\n           // the \"correct\" implementation\n           parent.removeChild(node);\n           for (Node child = node.getFirstChild();\n                child != null; child = child.getNext()) {\n             scope.undeclare(scope.getVar(child.getString()));\n           }\n-        } else if (targetWarning == VARIABLE_COUNT_MISMATCH) {\n+        } else if (targetError == VARIABLE_COUNT_MISMATCH) {\n           // A bad implementation where we forget to undeclare all vars.\n           parent.removeChild(node);\n           scope.undeclare(scope.getVar(node.getFirstChild().getString()));\n-        } else if (targetWarning == MISSING_VARIABLE) {\n+        } else if (targetError == MISSING_VARIABLE) {\n           // A bad implementation where we don't update the var name.\n           node.getFirstChild().setString(\"z\");\n-        } else if (targetWarning == MOVED_VARIABLE) {\n+        } else if (targetError == MOVED_VARIABLE) {\n           // A bad implementation where we take the var out of the tree.\n           Node oldName = node.getFirstChild();\n           oldName.detachFromParent();\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/AllTests.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import com.google.javascript.rhino.jstype.BooleanLiteralSetTest;\n+import com.google.javascript.rhino.jstype.FunctionParamBuilderTest;\n+import com.google.javascript.rhino.jstype.JSTypeRegistryTest;\n+import com.google.javascript.rhino.jstype.JSTypeTest;\n+import com.google.javascript.rhino.jstype.TernaryValueTest;\n+import com.google.javascript.rhino.jstype.UnionTypeBuilderTest;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+public class AllTests {\n+  public static Test suite() throws Exception {\n+    // suspend logging\n+    Logger.getLogger(\"com.google\").setLevel(Level.OFF);\n+\n+    // The testing framework is lame and doesn't work in third_party.\n+    // Manually load the classes.\n+    TestSuite suite = new TestSuite();\n+\n+    suite.addTestSuite(JSDocInfoTest.class);\n+    suite.addTestSuite(NodeTest.class);\n+    suite.addTestSuite(ParserTest.class);\n+    suite.addTestSuite(TokenStreamTest.class);\n+\n+    suite.addTestSuite(BooleanLiteralSetTest.class);\n+    suite.addTestSuite(FunctionParamBuilderTest.class);\n+    suite.addTestSuite(JSTypeRegistryTest.class);\n+    suite.addTestSuite(JSTypeTest.class);\n+    suite.addTestSuite(TernaryValueTest.class);\n+    suite.addTestSuite(UnionTypeBuilderTest.class);\n+\n+    return suite;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import static com.google.javascript.rhino.JSDocInfo.Visibility.PRIVATE;\n+import static com.google.javascript.rhino.JSDocInfo.Visibility.PROTECTED;\n+import static com.google.javascript.rhino.JSDocInfo.Visibility.PUBLIC;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n+\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.testing.TestErrorReporter;\n+\n+import junit.framework.TestCase;\n+\n+public class JSDocInfoTest extends TestCase {\n+  private TestErrorReporter errorReporter = new TestErrorReporter(null, null);\n+  private JSTypeRegistry registry = new JSTypeRegistry(errorReporter);\n+\n+  private JSType getNativeType(JSTypeNative typeId) {\n+    return registry.getNativeType(typeId);\n+  }\n+\n+  /**\n+   * Tests the assigned ordinal of the elements of the\n+   * {@link JSDocInfo.Visibility} enum.\n+   */\n+  public void testVisibilityOrdinal() {\n+    assertEquals(0, PRIVATE.ordinal());\n+    assertEquals(1, PROTECTED.ordinal());\n+    assertEquals(2, PUBLIC.ordinal());\n+  }\n+\n+  public void testSetType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setType(fromString(\"string\"));\n+\n+    assertNull(info.getBaseType());\n+    assertNull(info.getDescription());\n+    assertNull(info.getEnumParameterType());\n+    assertEquals(0, info.getParameterCount());\n+    assertNull(info.getReturnType());\n+    assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));\n+    assertNull(info.getVisibility());\n+    assertTrue(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetTypeAndVisibility() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setType(fromString(\"string\"));\n+    info.setVisibility(PROTECTED);\n+\n+    assertNull(info.getBaseType());\n+    assertNull(info.getDescription());\n+    assertNull(info.getEnumParameterType());\n+    assertEquals(0, info.getParameterCount());\n+    assertNull(info.getReturnType());\n+    assertEquals(getNativeType(STRING_TYPE), resolve(info.getType()));\n+    assertEquals(PROTECTED, info.getVisibility());\n+    assertTrue(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetReturnType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setReturnType(fromString(\"string\"));\n+\n+    assertNull(info.getBaseType());\n+    assertNull(info.getDescription());\n+    assertNull(info.getEnumParameterType());\n+    assertEquals(0, info.getParameterCount());\n+    assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));\n+    assertNull(info.getType());\n+    assertNull(info.getVisibility());\n+    assertFalse(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetReturnTypeAndBaseType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setBaseType(\n+        new JSTypeExpression(\n+            new Node(Token.BANG, Node.newString(\"Number\")), \"\", registry));\n+    info.setReturnType(fromString(\"string\"));\n+\n+    assertEquals(getNativeType(NUMBER_OBJECT_TYPE),\n+        resolve(info.getBaseType()));\n+    assertNull(info.getDescription());\n+    assertNull(info.getEnumParameterType());\n+    assertEquals(0, info.getParameterCount());\n+    assertEquals(getNativeType(STRING_TYPE), resolve(info.getReturnType()));\n+    assertNull(info.getType());\n+    assertNull(info.getVisibility());\n+    assertFalse(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetEnumParameterType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setEnumParameterType(fromString(\"string\"));\n+\n+    assertNull(info.getBaseType());\n+    assertNull(info.getDescription());\n+    assertEquals(getNativeType(STRING_TYPE),\n+        resolve(info.getEnumParameterType()));\n+    assertEquals(0, info.getParameterCount());\n+    assertNull(info.getReturnType());\n+    assertNull(info.getType());\n+    assertNull(info.getVisibility());\n+    assertFalse(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testMultipleSetType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setType(fromString(\"number\"));\n+\n+    try {\n+      info.setReturnType(fromString(\"boolean\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setEnumParameterType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setTypedefType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    assertEquals(getNativeType(NUMBER_TYPE), resolve(info.getType()));\n+    assertNull(info.getReturnType());\n+    assertNull(info.getEnumParameterType());\n+    assertNull(info.getTypedefType());\n+    assertTrue(info.hasType());\n+  }\n+\n+  public void testMultipleSetType2() {\n+    JSDocInfo info = new JSDocInfo();\n+\n+    info.setReturnType(fromString(\"boolean\"));\n+\n+    try {\n+      info.setType(fromString(\"number\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setEnumParameterType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setTypedefType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    assertEquals(getNativeType(BOOLEAN_TYPE),\n+        resolve(info.getReturnType()));\n+    assertNull(info.getEnumParameterType());\n+    assertNull(info.getType());\n+    assertNull(info.getTypedefType());\n+    assertFalse(info.hasType());\n+  }\n+\n+  public void testMultipleSetType3() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setEnumParameterType(fromString(\"boolean\"));\n+\n+    try {\n+      info.setType(fromString(\"number\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setReturnType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    try {\n+      info.setTypedefType(fromString(\"string\"));\n+      fail(\"Expected exception\");\n+    } catch (IllegalStateException e) {}\n+\n+    assertNull(info.getType());\n+    assertNull(info.getTypedefType());\n+    assertNull(info.getReturnType());\n+    assertEquals(getNativeType(BOOLEAN_TYPE),\n+        resolve(info.getEnumParameterType()));\n+  }\n+\n+  public void testSetTypedefType() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setTypedefType(fromString(\"boolean\"));\n+\n+    assertEquals(getNativeType(BOOLEAN_TYPE),\n+        resolve(info.getTypedefType()));\n+    assertTrue(info.hasTypedefType());\n+    assertFalse(info.hasType());\n+    assertFalse(info.hasEnumParameterType());\n+    assertFalse(info.hasReturnType());\n+  }\n+\n+  public void testSetConstant() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setConstant(true);\n+\n+    assertFalse(info.hasType());\n+    assertTrue(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetConstructor() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setConstructor(true);\n+\n+    assertFalse(info.isConstant());\n+    assertTrue(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetDefine() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setDefine(true);\n+\n+    assertTrue(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertTrue(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetHidden() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setHidden(true);\n+\n+    assertFalse(info.hasType());\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertTrue(info.isHidden());\n+    assertFalse(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetShouldPreserveTry() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setShouldPreserveTry(true);\n+\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetNoTypeCheck() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setNoCheck(true);\n+\n+    assertFalse(info.isDeprecated());\n+    assertFalse(info.isNoAlias());\n+    assertFalse(info.isOverride());\n+    assertTrue(info.isNoTypeCheck());\n+  }\n+\n+  public void testSetOverride() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setOverride(true);\n+\n+    assertFalse(info.isDeprecated());\n+    assertFalse(info.isNoAlias());\n+    assertTrue(info.isOverride());\n+  }\n+\n+  public void testSetExport() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setExport(true);\n+\n+    assertTrue(info.isExport());\n+  }\n+\n+  public void testSetNoAlias() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setNoAlias(true);\n+\n+    assertFalse(info.isDeprecated());\n+    assertFalse(info.isOverride());\n+    assertTrue(info.isNoAlias());\n+  }\n+\n+  public void testSetDeprecated() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setDeprecated(true);\n+\n+    assertFalse(info.isNoAlias());\n+    assertFalse(info.isOverride());\n+    assertTrue(info.isDeprecated());\n+  }\n+\n+  public void testMultipleSetFlags1() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setConstant(true);\n+    info.setConstructor(true);\n+    info.setHidden(true);\n+    info.setShouldPreserveTry(true);\n+\n+    assertFalse(info.hasType());\n+    assertTrue(info.isConstant());\n+    assertTrue(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertTrue(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+\n+    info.setHidden(false);\n+\n+    assertTrue(info.isConstant());\n+    assertTrue(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+\n+    info.setConstant(false);\n+    info.setConstructor(false);\n+\n+    assertFalse(info.isConstant());\n+    assertFalse(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+\n+    info.setConstructor(true);\n+\n+    assertFalse(info.isConstant());\n+    assertTrue(info.isConstructor());\n+    assertFalse(info.isDefine());\n+    assertFalse(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+  }\n+\n+  public void testSetFileOverviewWithDocumentationOff() {\n+    JSDocInfo info = new JSDocInfo();\n+    info.documentFileOverview(\"hi bob\");\n+    assertNull(info.getFileOverview());\n+  }\n+\n+  public void testSetFileOverviewWithDocumentationOn() {\n+    JSDocInfo info = new JSDocInfo(true);\n+    info.documentFileOverview(\"hi bob\");\n+    assertEquals(\"hi bob\", info.getFileOverview());\n+  }\n+\n+  public void testSetSuppressions() {\n+    JSDocInfo info = new JSDocInfo(true);\n+    info.setSuppressions(Sets.newHashSet(\"sam\", \"bob\"));\n+    assertEquals(Sets.newHashSet(\"bob\", \"sam\"), info.getSuppressions());\n+  }\n+\n+  /** Gets the type expression for a simple type name. */\n+  private JSTypeExpression fromString(String s) {\n+    return new JSTypeExpression(Node.newString(s), \"\", registry);\n+  }\n+\n+  private JSType resolve(JSTypeExpression n, String... warnings) {\n+    errorReporter.setWarnings(warnings);\n+    return n.evaluate(null);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import com.google.common.base.Pair;\n+import com.google.javascript.rhino.testing.TestErrorReporter;\n+\n+import junit.framework.TestCase;\n+\n+public class NodeTest extends TestCase {\n+  public void testMergeExtractNormal() throws Exception {\n+    testMergeExtract(5, 6);\n+    testMergeExtract(456, 3423);\n+    testMergeExtract(0, 0);\n+  }\n+\n+  public void testMergeExtractErroneous() throws Exception {\n+    assertEquals(-1, Node.mergeLineCharNo(-5, 90));\n+    assertEquals(-1, Node.mergeLineCharNo(0, -1));\n+    assertEquals(-1, Node.extractLineno(-1));\n+    assertEquals(-1, Node.extractCharno(-1));\n+  }\n+\n+  public void testMergeOverflowGraciously() throws Exception {\n+    int linecharno = Node.mergeLineCharNo(89, 4096);\n+    assertEquals(89, Node.extractLineno(linecharno));\n+    assertEquals(4095, Node.extractCharno(linecharno));\n+  }\n+\n+  public void testCheckTreeEqualsImplSame() {\n+    Node node1 = new Node(1, new Node(2));\n+    Node node2 = new Node(1, new Node(2));\n+    assertEquals(null, node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testCheckTreeEqualsImplDifferentType() {\n+    Node node1 = new Node(1, new Node(2));\n+    Node node2 = new Node(2, new Node(2));\n+    assertEquals(Pair.of(node1, node2), node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testCheckTreeEqualsImplDifferentChildCount() {\n+    Node node1 = new Node(1, new Node(2));\n+    Node node2 = new Node(1);\n+    assertEquals(Pair.of(node1, node2), node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testCheckTreeEqualsImplDifferentChild() {\n+    Node child1 = new Node(1);\n+    Node child2 = new Node(2);\n+    Node node1 = new Node(1, child1);\n+    Node node2 = new Node(1, child2);\n+    assertEquals(Pair.of(child1, child2), node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testCheckTreeEqualsSame() {\n+    Node node1 = new Node(1);\n+    assertEquals(null, node1.checkTreeEquals(node1));\n+  }\n+\n+  public void testCheckTreeEqualsStringDifferent() {\n+    Node node1 = new Node(1);\n+    Node node2 = new Node(2);\n+    assertNotNull(node1.checkTreeEquals(node2));\n+  }\n+\n+  public void testCheckTreeEqualsBooleanSame() {\n+    Node node1 = new Node(1);\n+    assertEquals(true, node1.checkTreeEqualsSilent(node1));\n+  }\n+\n+  public void testCheckTreeEqualsBooleanDifferent() {\n+    Node node1 = new Node(1);\n+    Node node2 = new Node(2);\n+    assertEquals(false, node1.checkTreeEqualsSilent(node2));\n+  }\n+\n+  public void testCheckTreeEqualsImplDifferentIncProp() {\n+    Node node1 = new Node(Token.INC);\n+    node1.putIntProp(Node.INCRDECR_PROP, 1);\n+    Node node2 = new Node(Token.INC);\n+    assertNotNull(node1.checkTreeEqualsImpl(node2));\n+  }\n+\n+  public void testVarArgs1() {\n+    assertFalse(new Node(1).isVarArgs());\n+  }\n+\n+  public void testVarArgs2() {\n+    Node n = new Node(1);\n+    n.setVarArgs(false);\n+    assertFalse(n.isVarArgs());\n+  }\n+\n+  public void testVarArgs3() {\n+    Node n = new Node(1);\n+    n.setVarArgs(true);\n+    assertTrue(n.isVarArgs());\n+  }\n+\n+  private void testMergeExtract(int lineno, int charno) {\n+    int linecharno = Node.mergeLineCharNo(lineno, charno);\n+    assertEquals(lineno, Node.extractLineno(linecharno));\n+    assertEquals(charno, Node.extractCharno(linecharno));\n+  }\n+\n+  public void testFileLevelJSDocAppender() {\n+    Node n = new Node(1);\n+    Node.FileLevelJsDocBuilder builder = n.getJsDocBuilderForNode();\n+    builder.append(\"foo\");\n+    builder.append(\"bar\");\n+    assertEquals(\"foobar\", n.getJSDocInfo().getLicense());\n+  }\n+\n+  public void testIsQualifiedName() {\n+    assertTrue(getNode(\"a\").isQualifiedName());\n+    assertTrue(getNode(\"$\").isQualifiedName());\n+    assertTrue(getNode(\"_\").isQualifiedName());\n+    assertTrue(getNode(\"a.b\").isQualifiedName());\n+    assertTrue(getNode(\"a_b.cccccc$d4.x.y.zA$\").isQualifiedName());\n+    assertTrue(getNode(\"this.foo\").isQualifiedName());\n+    assertFalse(getNode(\"0\").isQualifiedName());\n+    assertFalse(getNode(\"[]\").isQualifiedName());\n+    assertFalse(getNode(\"{}\").isQualifiedName());\n+    assertFalse(getNode(\"''\").isQualifiedName());\n+    assertFalse(getNode(\"a[b]\").isQualifiedName());\n+    assertFalse(getNode(\"a[b].c\").isQualifiedName());\n+    assertFalse(getNode(\"c.a[b]\").isQualifiedName());\n+    assertFalse(getNode(\"a()\").isQualifiedName());\n+    assertFalse(getNode(\"a().b\").isQualifiedName());\n+    assertFalse(getNode(\"b.a()\").isQualifiedName());\n+    assertFalse(getNode(\"'a'\").isQualifiedName());\n+    assertFalse(getNode(\"/x/\").isQualifiedName());\n+    assertFalse(getNode(\"++x\").isQualifiedName());\n+  }\n+\n+  public void testCloneAnnontations() {\n+    Node n = getNode(\"a\");\n+    assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+    n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n+\n+    Node nodeClone = n.cloneNode();\n+    assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME));\n+  }\n+\n+  private static Node getNode(String js) {\n+    Node root = parse(\"var a=(\" + js + \");\");\n+    Node expr = root.getFirstChild();\n+    Node var = expr.getFirstChild();\n+    return var.getFirstChild();\n+  }\n+\n+  private static Node parse(String string) {\n+    CompilerEnvirons environment = new CompilerEnvirons();\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+    environment.setErrorReporter(testErrorReporter);\n+    environment.setParseJSDoc(true);\n+    Parser p = new Parser(environment, testErrorReporter, null);\n+    return p.parse(string, null, 0);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/ParserTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import com.google.common.base.Pair;\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+import com.google.javascript.rhino.testing.TestErrorReporter;\n+\n+\n+import java.util.List;\n+\n+public class ParserTest extends BaseJSTypeTestCase {\n+  private static final String TRAILING_COMMA_MESSAGE =\n+      ScriptRuntime.getMessage0(\"msg.trailing.comma\");\n+\n+  public void testLinenoCharnoAssign1() throws Exception {\n+    Node assign = parse(\"a = b\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ASSIGN, assign.getType());\n+    assertEquals(0, assign.getLineno());\n+    assertEquals(2, assign.getCharno());\n+  }\n+\n+  public void testLinenoCharnoAssign2() throws Exception {\n+    Node assign = parse(\"\\n a.g.h.k    =  45\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ASSIGN, assign.getType());\n+    assertEquals(1, assign.getLineno());\n+    assertEquals(12, assign.getCharno());\n+  }\n+\n+  public void testLinenoCharnoCall() throws Exception {\n+    Node call = parse(\"\\n foo(123);\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.CALL, call.getType());\n+    assertEquals(1, call.getLineno());\n+    assertEquals(4, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetProp1() throws Exception {\n+    Node getprop = parse(\"\\n foo.bar\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETPROP, getprop.getType());\n+    assertEquals(1, getprop.getLineno());\n+    assertEquals(4, getprop.getCharno());\n+\n+    Node name = getprop.getFirstChild().getNext();\n+    assertEquals(Token.STRING, name.getType());\n+    assertEquals(1, name.getLineno());\n+    assertEquals(5, name.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetProp2() throws Exception {\n+    Node getprop = parse(\"\\n foo.\\nbar\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETPROP, getprop.getType());\n+    assertEquals(1, getprop.getLineno());\n+    assertEquals(4, getprop.getCharno());\n+\n+    Node name = getprop.getFirstChild().getNext();\n+    assertEquals(Token.STRING, name.getType());\n+    assertEquals(2, name.getLineno());\n+    assertEquals(0, name.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem1() throws Exception {\n+    Node call = parse(\"\\n foo[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(1, call.getLineno());\n+    assertEquals(4, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem2() throws Exception {\n+    Node call = parse(\"\\n   \\n foo()[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(2, call.getLineno());\n+    assertEquals(6, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem3() throws Exception {\n+    Node call = parse(\"\\n   \\n (8 + kl)[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(2, call.getLineno());\n+    assertEquals(9, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoForComparison() throws Exception {\n+    Node lt =\n+      parse(\"for (; i < j;){}\").getFirstChild().getFirstChild().getNext();\n+\n+    assertEquals(Token.LT, lt.getType());\n+    assertEquals(0, lt.getLineno());\n+    assertEquals(9, lt.getCharno());\n+  }\n+\n+  public void testLinenoCharnoHook() throws Exception {\n+    Node n = parse(\"\\n a ? 9 : 0\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.HOOK, n.getType());\n+    assertEquals(1, n.getLineno());\n+    assertEquals(3, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoArrayLiteral() throws Exception {\n+    Node n = parse(\"\\n  [8, 9]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ARRAYLIT, n.getType());\n+    assertEquals(1, n.getLineno());\n+    assertEquals(2, n.getCharno());\n+\n+    n = n.getFirstChild();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(1, n.getLineno());\n+    assertEquals(3, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(1, n.getLineno());\n+    assertEquals(6, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoObjectLiteral() throws Exception {\n+    Node n = parse(\"\\n\\n var a = {a:0\\n,b :1};\")\n+        .getFirstChild().getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.OBJECTLIT, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(9, n.getCharno());\n+\n+    n = n.getFirstChild();\n+\n+    assertEquals(Token.STRING, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(10, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(12, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.STRING, n.getType());\n+    assertEquals(3, n.getLineno());\n+    assertEquals(1, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(3, n.getLineno());\n+    assertEquals(4, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoAdd() throws Exception {\n+    testLinenoCharnoBinop(\"+\");\n+  }\n+\n+  public void testLinenoCharnoSub() throws Exception {\n+    testLinenoCharnoBinop(\"-\");\n+  }\n+\n+  public void testLinenoCharnoMul() throws Exception {\n+    testLinenoCharnoBinop(\"*\");\n+  }\n+\n+  public void testLinenoCharnoDiv() throws Exception {\n+    testLinenoCharnoBinop(\"/\");\n+  }\n+\n+  public void testLinenoCharnoMod() throws Exception {\n+    testLinenoCharnoBinop(\"%\");\n+  }\n+\n+  public void testLinenoCharnoShift() throws Exception {\n+    testLinenoCharnoBinop(\"<<\");\n+  }\n+\n+  public void testLinenoCharnoBinaryAnd() throws Exception {\n+    testLinenoCharnoBinop(\"&\");\n+  }\n+\n+  public void testLinenoCharnoAnd() throws Exception {\n+    testLinenoCharnoBinop(\"&&\");\n+  }\n+\n+  public void testLinenoCharnoBinaryOr() throws Exception {\n+    testLinenoCharnoBinop(\"|\");\n+  }\n+\n+  public void testLinenoCharnoOr() throws Exception {\n+    testLinenoCharnoBinop(\"||\");\n+  }\n+\n+  public void testLinenoCharnoLt() throws Exception {\n+    testLinenoCharnoBinop(\"<\");\n+  }\n+\n+  public void testLinenoCharnoLe() throws Exception {\n+    testLinenoCharnoBinop(\"<=\");\n+  }\n+\n+  public void testLinenoCharnoGt() throws Exception {\n+    testLinenoCharnoBinop(\">\");\n+  }\n+\n+  public void testLinenoCharnoGe() throws Exception {\n+    testLinenoCharnoBinop(\">=\");\n+  }\n+\n+  private void testLinenoCharnoBinop(String binop) {\n+    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n+        getFirstChild().getFirstChild();\n+\n+    assertEquals(0, op.getLineno());\n+    assertEquals(11, op.getCharno());\n+  }\n+\n+  public void testUnescapedSlashInRegexpCharClass() throws Exception {\n+    // The tokenizer without the fix for this bug throws an error.\n+    parse(\"var foo = /[/]/;\");\n+    parse(\"var foo = /[hi there/]/;\");\n+    parse(\"var foo = /[/yo dude]/;\");\n+    parse(\"var foo = /\\\\/[@#$/watashi/wa/suteevu/desu]/;\");\n+  }\n+\n+  private void assertNodeEquality(Node expected, Node found) {\n+    String message = expected.checkTreeEquals(found);\n+    if (message != null) {\n+      fail(message);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testParse() {\n+    Node a = Node.newString(Token.NAME, \"a\");\n+    a.addChildToFront(Node.newString(Token.NAME, \"b\"));\n+    List<Pair<String, Node>> testCases = ImmutableList.of(\n+        Pair.of(\n+            \"3;\",\n+            createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),\n+        Pair.of(\n+            \"var a = b;\",\n+             createScript(new Node(Token.VAR, a))),\n+        Pair.of(\n+            \"\\\"hell\\\\\\no\\\\ world\\\\\\n\\\\\\n!\\\"\",\n+             createScript(new Node(Token.EXPR_RESULT,\n+             Node.newString(Token.STRING, \"hello world!\")))));\n+\n+    for (Pair<String, Node> testCase : testCases) {\n+      assertNodeEquality(testCase.second, parse(testCase.first));\n+    }\n+  }\n+\n+  private Node createScript(Node n) {\n+    Node script = new ScriptOrFnNode(Token.SCRIPT);\n+    script.addChildToBack(n);\n+    return script;\n+  }\n+\n+  public void testTrailingCommaWarning1() {\n+    parse(\"var a = ['foo', 'bar'];\");\n+  }\n+\n+  public void testTrailingCommaWarning2() {\n+    parse(\"var a = ['foo',,'bar'];\");\n+  }\n+\n+  public void testTrailingCommaWarning3() {\n+    parse(\"var a = ['foo', 'bar',];\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning4() {\n+    parse(\"var a = [,];\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning5() {\n+    parse(\"var a = {'foo': 'bar'};\");\n+  }\n+\n+  public void testTrailingCommaWarning6() {\n+    parse(\"var a = {'foo': 'bar',};\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning7() {\n+    parse(\"var a = {,};\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  private Node parse(String string, String... warnings) {\n+    CompilerEnvirons environment = new CompilerEnvirons();\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n+    environment.setErrorReporter(testErrorReporter);\n+    environment.setParseJSDoc(true);\n+    environment.setParseJSDocDocumentation(true);\n+    Parser p = new Parser(environment, testErrorReporter, registry);\n+    Node script = p.parse(string, null, 0);\n+\n+    // verifying that all warnings were seen\n+    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n+    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n+\n+    return script;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/TokenStreamTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import static com.google.javascript.rhino.Token.ADD;\n+import static com.google.javascript.rhino.Token.ANNOTATION;\n+import static com.google.javascript.rhino.Token.BANG;\n+import static com.google.javascript.rhino.Token.COLON;\n+import static com.google.javascript.rhino.Token.COMMA;\n+import static com.google.javascript.rhino.Token.DOT;\n+import static com.google.javascript.rhino.Token.ELLIPSIS;\n+import static com.google.javascript.rhino.Token.ELSE;\n+import static com.google.javascript.rhino.Token.EOC;\n+import static com.google.javascript.rhino.Token.EOF;\n+import static com.google.javascript.rhino.Token.EOL;\n+import static com.google.javascript.rhino.Token.EQUALS;\n+import static com.google.javascript.rhino.Token.GT;\n+import static com.google.javascript.rhino.Token.IF;\n+import static com.google.javascript.rhino.Token.LB;\n+import static com.google.javascript.rhino.Token.LC;\n+import static com.google.javascript.rhino.Token.LP;\n+import static com.google.javascript.rhino.Token.LT;\n+import static com.google.javascript.rhino.Token.NAME;\n+import static com.google.javascript.rhino.Token.PIPE;\n+import static com.google.javascript.rhino.Token.QMARK;\n+import static com.google.javascript.rhino.Token.RB;\n+import static com.google.javascript.rhino.Token.RC;\n+import static com.google.javascript.rhino.Token.RP;\n+import static com.google.javascript.rhino.Token.STAR;\n+import static com.google.javascript.rhino.Token.STRING;\n+import static com.google.javascript.rhino.Token.name;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.List;\n+\n+public class TokenStreamTest extends TestCase {\n+\n+  public void testLinenoCharnoGetUngetchar() throws Exception {\n+    TokenStream stream = stream(\"some\\nrandom\\nstring\");\n+\n+    int c;\n+    assertLinenoOffset(stream, 0, -1);\n+    c = getAndTestChar(stream, 's');\n+    assertLinenoOffset(stream, 0, 0);\n+    stream.ungetChar(c);\n+    assertLinenoOffset(stream, 0, -1);\n+    c = getAndTestChar(stream, 's');\n+    c = getAndTestChar(stream, 'o');\n+    assertLinenoOffset(stream, 0, 1);\n+    stream.ungetChar(c);\n+    assertLinenoOffset(stream, 0, 0);\n+    c = getAndTestChar(stream, 'o');\n+    assertLinenoOffset(stream, 0, 1);\n+    c = getAndTestChar(stream, 'm');\n+    assertLinenoOffset(stream, 0, 2);\n+    stream.ungetChar(c);\n+    assertLinenoOffset(stream, 0, 1);\n+    c = getAndTestChar(stream, 'm');\n+    c = getAndTestChar(stream, 'e');\n+    assertLinenoOffset(stream, 0, 3);\n+    c = getAndTestChar(stream, '\\n');\n+    assertLinenoOffset(stream, 0, 4);\n+    c = getAndTestChar(stream, 'r');\n+    assertLinenoOffset(stream, 1, 0);\n+    c = getAndTestChar(stream, 'a');\n+    assertLinenoOffset(stream, 1, 1);\n+    c = getAndTestChar(stream, 'n');\n+    assertLinenoOffset(stream, 1, 2);\n+    c = getAndTestChar(stream, 'd');\n+    assertLinenoOffset(stream, 1, 3);\n+    stream.ungetChar(c);\n+    stream.ungetChar('n');\n+    c = getAndTestChar(stream, 'n');\n+    assertLinenoOffset(stream, 1, 2);\n+    c = getAndTestChar(stream, 'd');\n+    assertLinenoOffset(stream, 1, 3);\n+    c = getAndTestChar(stream, 'o');\n+    assertLinenoOffset(stream, 1, 4);\n+    c = getAndTestChar(stream, 'm');\n+    assertLinenoOffset(stream, 1, 5);\n+    c = getAndTestChar(stream, '\\n');\n+    assertLinenoOffset(stream, 1, 6);\n+    c = getAndTestChar(stream, 's');\n+    assertLinenoOffset(stream, 2, 0);\n+    c = getAndTestChar(stream, 't');\n+    assertLinenoOffset(stream, 2, 1);\n+    c = getAndTestChar(stream, 'r');\n+    assertLinenoOffset(stream, 2, 2);\n+    c = getAndTestChar(stream, 'i');\n+    assertLinenoOffset(stream, 2, 3);\n+    c = getAndTestChar(stream, 'n');\n+    assertLinenoOffset(stream, 2, 4);\n+    c = getAndTestChar(stream, 'g');\n+    assertLinenoOffset(stream, 2, 5);\n+  }\n+\n+  private int getAndTestChar(TokenStream stream, char e) throws IOException {\n+    int c = stream.getChar();\n+    assertEquals(e, (char) c);\n+    return c;\n+  }\n+\n+  public void testLinenoCharno1() throws Exception {\n+    TokenStream stream = stream(\"if else\");\n+    testNextTokenPosition(stream, IF, 0, 0);\n+    testNextTokenPosition(stream, ELSE, 0, 3);\n+  }\n+\n+  public void testLinenoCharno2() throws Exception {\n+    TokenStream stream = stream(\" if   else\");\n+    testNextTokenPosition(stream, IF, 0, 1);\n+    testNextTokenPosition(stream, ELSE, 0, 6);\n+  }\n+\n+  public void testLinenoCharno3() throws Exception {\n+    TokenStream stream = stream(\" if \\n  else\");\n+    testNextTokenPosition(stream, IF, 0, 1);\n+    testNextTokenPosition(stream, EOL, 0, 4);\n+    testNextTokenPosition(stream, ELSE, 1, 2);\n+  }\n+\n+  public void testLinenoCharno4() throws Exception {\n+    TokenStream stream = stream(\"foo.bar\");\n+    testNextTokenPosition(stream, NAME, 0, 0);\n+    testNextTokenPosition(stream, DOT, 0, 3);\n+    testNextTokenPosition(stream, NAME, 0, 4);\n+  }\n+\n+  public void testLinenoCharno5() throws Exception {\n+    TokenStream stream = stream(\"   foo  \\n + \\n  (\");\n+    testNextTokenPosition(stream, NAME, 0, 3);\n+    testNextTokenPosition(stream, EOL, 0, 8);\n+    testNextTokenPosition(stream, ADD, 1, 1);\n+    testNextTokenPosition(stream, EOL, 1, 3);\n+    testNextTokenPosition(stream, LP, 2, 2);\n+  }\n+\n+  public void testJSDocTokenization1() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, LC, STRING, RC, EOL, STAR, ANNOTATION);\n+    List<String> strings = ImmutableList.of(\"type\", \"string\", \"private\");\n+    testJSDocTokenStream(\" * @type {string}\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" *    @type { string } \\n * @private\",\n+        tokens, strings);\n+    testJSDocTokenStream(\" * @type   {  string}\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string  }\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string}\\n *   @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string}   \\n * @private\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization2() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string |null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<string |  null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<string|null  >}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array  .<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param   {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|   null>}  \", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"     @param { Array .< string |null > } \",\n+        tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization3() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.< string || null> }\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string || null >  } \",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {Array .<string   ||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.< string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param   {Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param   {   Array.<string|| null> }\",\n+        tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization4() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, LP, STRING, COMMA, STRING, RP, GT, RC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<(string,null)>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array  .<(string,null)> } \", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<  (  string,null)>}\",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<(string  , null)>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<(string,   null)  > }  \",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array  .<  (string,null)>}   \",\n+        tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization5() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"foo.Bar\");\n+    testJSDocTokenStream(\"@param foo.Bar*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param   foo.Bar*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param foo.Bar   */\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization6() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);\n+    List<String> strings = ImmutableList.of(\"hidden\", \"static\", \"desc\");\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n @static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n @desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc */\", tokens, strings);\n+    testJSDocTokenStream(\" @hidden \\n@static\\n @desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static    \\n @desc  */\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden   \\n@static   \\n @desc*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization7() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, LT, EOC);\n+    List<String> strings = ImmutableList.of();\n+\n+    testJSDocTokenStream(\"................<*/\", tokens, strings);\n+    testJSDocTokenStream(\"............... .<*/\", tokens, strings);\n+    testJSDocTokenStream(\"................< */\", tokens, strings);\n+    testJSDocTokenStream(\"............... .< */\", tokens, strings);\n+    testJSDocTokenStream(\"............... .< */ \", tokens, strings);\n+    testJSDocTokenStream(\" ............... .< */ \", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization8() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING,\n+        STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\n+        \"param\", \"foo.Bar\", \"opt_name\", \"this\", \"parameter\", \"is\", \"a\", \"name\");\n+    testJSDocTokenStream(\n+        \" * @param foo.Bar opt_name this parameter is a name\\n\" +\n+        \" */\", tokens, strings);\n+    testJSDocTokenStream(\n+        \"  *  @param foo.Bar opt_name this parameter is a name \\n\" +\n+        \" */ \", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization9() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION,\n+        STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\n+        \"param\", \"foo.Bar\", \"opt_name\", \"this\", \"parameter\", \"does\",\n+        \"media\", \"blah\");\n+    testJSDocTokenStream(\n+        \" * @param foo.Bar opt_name this parameter does @media blah\\n\" +\n+        \" */\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization10() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(STRING, GT, EOC);\n+    List<String> strings = ImmutableList.of(\"Array<String\");\n+    testJSDocTokenStream(\"Array<String>*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization11() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, QMARK, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"string\");\n+    testJSDocTokenStream(\"@param {string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {string ?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {string ?  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param { string  ?  }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {string?  }*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization12() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(STRING, ELLIPSIS, EOC);\n+    List<String> strings = ImmutableList.of(\"function\");\n+\n+    testJSDocTokenStream(\"function ...*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization13() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(ELLIPSIS, LB, STRING, RB, EOC);\n+    List<String> strings = ImmutableList.of(\"number\");\n+\n+    testJSDocTokenStream(\"...[number]*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization14() throws Exception {\n+    // Since ES4 type parsing only requires to parse an ellispis when it is\n+    // followed by a comma (,) we are allowing this case to parse this way.\n+    // This is a simplification of the tokenizer, but the extra complexity is\n+    // never used.\n+    List<Integer> tokens = ImmutableList.of(STRING, LB, STRING, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar...\");\n+\n+    testJSDocTokenStream(\"foo[ bar...*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization15() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        STRING, LB, STRING, COMMA, ELLIPSIS, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar\");\n+\n+    testJSDocTokenStream(\"foo[ bar,...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[ bar ,...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[bar, ...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[ bar  ,   ...  */\", tokens, strings);\n+    testJSDocTokenStream(\"foo [bar,... */\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization16() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        STRING, COLON, COLON, COLON, ELLIPSIS, STRING, COLON, STRING, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar\", \"bar2\");\n+\n+    testJSDocTokenStream(\"foo:::...bar:bar2*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization17() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\"..\");\n+\n+    testJSDocTokenStream(\"..\\n*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization18() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\".\");\n+\n+    testJSDocTokenStream(\".\\n*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization19() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(ANNOTATION, LC, STAR, RC, EOC);\n+    List<String> strings = ImmutableList.of(\"type\", \"*\");\n+\n+    testJSDocTokenStream(\"@type {*}*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization20() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, BANG, STRING, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Object\");\n+    testJSDocTokenStream(\"@param {!Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {!Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {! Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { !Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {!Object  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  ! Object  }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {!Object  }*/\", tokens, strings);\n+  }\n+\n+  public void testJSDocTokenization21() throws Exception {\n+    List<Integer> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, EQUALS, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Object\");\n+    testJSDocTokenStream(\"@param {Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object =}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {Object=  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object = }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Object=  }*/\", tokens, strings);\n+  }\n+  \n+  public void testJSDocLinenoCharno1() throws Exception {\n+    TokenStream stream = stream(\" * @type {string}\\n  *   @private\");\n+    testNextJSDocTokenPosition(stream, STAR, 0, 1);\n+    testNextJSDocTokenPosition(stream, ANNOTATION, 0, 3);\n+    testNextJSDocTokenPosition(stream, LC, 0, 9);\n+    testNextJSDocTokenPosition(stream, STRING, 0, 10);\n+    testNextJSDocTokenPosition(stream, RC, 0, 16);\n+    testNextJSDocTokenPosition(stream, EOL, 0, 17);\n+    testNextJSDocTokenPosition(stream, STAR, 1, 2);\n+    testNextJSDocTokenPosition(stream, ANNOTATION, 1, 6);\n+  }\n+\n+  public void testJSDocLinenoCharno2() throws Exception {\n+    TokenStream stream = stream(\"@param \\n  {Array .<string\\n  | null>}\");\n+    testNextJSDocTokenPosition(stream, ANNOTATION, 0, 0);\n+    testNextJSDocTokenPosition(stream, EOL, 0, 7);\n+    testNextJSDocTokenPosition(stream, LC, 1, 2);\n+    testNextJSDocTokenPosition(stream, STRING, 1, 3);\n+    testNextJSDocTokenPosition(stream, LT, 1, 9);\n+    testNextJSDocTokenPosition(stream, STRING, 1, 11);\n+    testNextJSDocTokenPosition(stream, EOL, 1, 17);\n+    testNextJSDocTokenPosition(stream, PIPE, 2, 2);\n+    testNextJSDocTokenPosition(stream, STRING, 2, 4);\n+    testNextJSDocTokenPosition(stream, GT, 2, 8);\n+    testNextJSDocTokenPosition(stream, RC, 2, 9);\n+  }\n+\n+  private void testJSDocTokenStream(String comment, List<Integer> tokens,\n+      List<String> strings) throws IOException {\n+    TokenStream stream = stream(comment);\n+    int stringsIndex = 0;\n+    for (int token : tokens) {\n+      int readToken = stream.getJSDocToken();\n+\n+      // token equality\n+      if (token != readToken) {\n+        assertEquals(name(token), name(readToken));\n+      }\n+\n+      // string equality\n+      if (token == ANNOTATION || token == STRING) {\n+        assertEquals(strings.get(stringsIndex++), stream.getString());\n+      }\n+    }\n+  }\n+\n+  private void testNextTokenPosition(TokenStream stream, int token,\n+      int lineno, int charno) throws IOException {\n+    assertEquals(token, stream.getToken());\n+    assertLinenoCharno(stream, lineno, charno);\n+  }\n+\n+  private void testNextJSDocTokenPosition(TokenStream stream, int token,\n+      int lineno, int charno) throws IOException {\n+    assertEquals(token, stream.getJSDocToken());\n+    assertLinenoCharno(stream, lineno, charno);\n+  }\n+\n+  private void assertLinenoCharno(TokenStream stream, int lineno, int charno) {\n+    assertEquals(\"lineno\", lineno, stream.getLineno());\n+    assertEquals(\"charno\", charno, stream.getCharno());\n+  }\n+\n+  private void assertLinenoOffset(TokenStream stream, int lineno,\n+      int charnoCursor) {\n+    assertEquals(\"lineno\", lineno, stream.getLineno());\n+    assertEquals(\"offset\", charnoCursor, stream.getOffset());\n+  }\n+\n+  private TokenStream stream(String source) {\n+    return new TokenStream(new Parser(null, null),\n+        new StringReader(source), null, 0);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/BooleanLiteralSetTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import static com.google.javascript.rhino.jstype.BooleanLiteralSet.BOTH;\n+import static com.google.javascript.rhino.jstype.BooleanLiteralSet.EMPTY;\n+import static com.google.javascript.rhino.jstype.BooleanLiteralSet.FALSE;\n+import static com.google.javascript.rhino.jstype.BooleanLiteralSet.TRUE;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests {@link BooleanLiteralSet}.\n+ *\n+*\n+ */\n+public class BooleanLiteralSetTest extends TestCase {\n+\n+  public void testIntersection() {\n+    assertEquals(EMPTY, EMPTY.intersection(EMPTY));\n+    assertEquals(EMPTY, EMPTY.intersection(TRUE));\n+    assertEquals(EMPTY, EMPTY.intersection(FALSE));\n+    assertEquals(EMPTY, EMPTY.intersection(BOTH));\n+    assertEquals(EMPTY, TRUE.intersection(EMPTY));\n+    assertEquals(TRUE, TRUE.intersection(TRUE));\n+    assertEquals(EMPTY, TRUE.intersection(FALSE));\n+    assertEquals(TRUE, TRUE.intersection(BOTH));\n+    assertEquals(EMPTY, FALSE.intersection(EMPTY));\n+    assertEquals(EMPTY, FALSE.intersection(TRUE));\n+    assertEquals(FALSE, FALSE.intersection(FALSE));\n+    assertEquals(FALSE, FALSE.intersection(BOTH));\n+    assertEquals(EMPTY, BOTH.intersection(EMPTY));\n+    assertEquals(TRUE, BOTH.intersection(TRUE));\n+    assertEquals(FALSE, BOTH.intersection(FALSE));\n+    assertEquals(BOTH, BOTH.intersection(BOTH));\n+  }\n+\n+  public void testUnion() {\n+    assertEquals(EMPTY, EMPTY.union(EMPTY));\n+    assertEquals(TRUE, EMPTY.union(TRUE));\n+    assertEquals(FALSE, EMPTY.union(FALSE));\n+    assertEquals(BOTH, EMPTY.union(BOTH));\n+    assertEquals(TRUE, TRUE.union(EMPTY));\n+    assertEquals(TRUE, TRUE.union(TRUE));\n+    assertEquals(BOTH, TRUE.union(FALSE));\n+    assertEquals(BOTH, TRUE.union(BOTH));\n+    assertEquals(FALSE, FALSE.union(EMPTY));\n+    assertEquals(BOTH, FALSE.union(TRUE));\n+    assertEquals(FALSE, FALSE.union(FALSE));\n+    assertEquals(BOTH, FALSE.union(BOTH));\n+    assertEquals(BOTH, BOTH.union(EMPTY));\n+    assertEquals(BOTH, BOTH.union(TRUE));\n+    assertEquals(BOTH, BOTH.union(FALSE));\n+    assertEquals(BOTH, BOTH.union(BOTH));\n+  }\n+\n+  public void testGet() {\n+    assertEquals(TRUE, BooleanLiteralSet.get(true));\n+    assertEquals(FALSE, BooleanLiteralSet.get(false));\n+  }\n+\n+  public void testContains() {\n+    assertFalse(EMPTY.contains(true));\n+    assertFalse(EMPTY.contains(false));\n+    assertTrue(TRUE.contains(true));\n+    assertFalse(TRUE.contains(false));\n+    assertFalse(FALSE.contains(true));\n+    assertTrue(FALSE.contains(false));\n+    assertTrue(BOTH.contains(true));\n+    assertTrue(BOTH.contains(false));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+\n+/**\n+ * Tests for FunctionParamBuilder.\n+*\n+ */\n+public class FunctionParamBuilderTest extends BaseJSTypeTestCase {\n+\n+  public void testBuild() throws Exception {\n+    FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n+    assertTrue(builder.addRequiredParams(NUMBER_TYPE));\n+    assertTrue(builder.addOptionalParams(BOOLEAN_TYPE));\n+    assertTrue(builder.addVarArgs(STRING_TYPE));\n+\n+    Node params = builder.build();\n+    assertEquals(NUMBER_TYPE, params.getFirstChild().getJSType());\n+    assertEquals(registry.createOptionalType(BOOLEAN_TYPE),\n+        params.getFirstChild().getNext().getJSType());\n+    assertEquals(registry.createOptionalType(STRING_TYPE),\n+        params.getLastChild().getJSType());\n+\n+    assertTrue(params.getFirstChild().getNext().isOptionalArg());\n+    assertTrue(params.getLastChild().isVarArgs());\n+  }\n+\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.SimpleErrorReporter;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests {@link JSTypeRegistry}.\n+ *\n+*\n+ */\n+public class JSTypeRegistryTest extends TestCase {\n+  // TODO(user): extend this class with more tests, as JSTypeRegistry is\n+  // now much larger\n+  public void testGetBuiltInType() {\n+    JSTypeRegistry typeRegistry = new JSTypeRegistry(null);\n+    assertEquals(typeRegistry.getNativeType(JSTypeNative.BOOLEAN_TYPE),\n+        typeRegistry.getType(\"boolean\"));\n+  }\n+\n+  public void testGetDeclaredType() {\n+    JSTypeRegistry typeRegistry = new JSTypeRegistry(null);\n+    JSType type = typeRegistry.createAnonymousObjectType();\n+    String name = \"Foo\";\n+    typeRegistry.declareType(name, type);\n+    assertEquals(type, typeRegistry.getType(name));\n+\n+    // Ensure different instances are independent.\n+    JSTypeRegistry typeRegistry2 = new JSTypeRegistry(null);\n+    assertEquals(null, typeRegistry2.getType(name));\n+    assertEquals(type, typeRegistry.getType(name));\n+  }\n+\n+  public void testGetDeclaredTypeInNamespace() {\n+    JSTypeRegistry typeRegistry = new JSTypeRegistry(null);\n+    JSType type = typeRegistry.createAnonymousObjectType();\n+    String name = \"a.b.Foo\";\n+    typeRegistry.declareType(name, type);\n+    assertEquals(type, typeRegistry.getType(name));\n+    assertTrue(typeRegistry.hasNamespace(\"a\"));\n+    assertTrue(typeRegistry.hasNamespace(\"a.b\"));\n+  }\n+\n+  public void testTypeAsNamespace() {\n+    JSTypeRegistry typeRegistry = new JSTypeRegistry(null);\n+\n+    JSType type = typeRegistry.createAnonymousObjectType();\n+    String name = \"a.b.Foo\";\n+    typeRegistry.declareType(name, type);\n+    assertEquals(type, typeRegistry.getType(name));\n+\n+    type = typeRegistry.createAnonymousObjectType();\n+    name = \"a.b.Foo.Bar\";\n+    typeRegistry.declareType(name, type);\n+    assertEquals(type, typeRegistry.getType(name));\n+\n+    assertTrue(typeRegistry.hasNamespace(\"a\"));\n+    assertTrue(typeRegistry.hasNamespace(\"a.b\"));\n+    assertTrue(typeRegistry.hasNamespace(\"a.b.Foo\"));\n+  }\n+\n+  public void testGenerationIncrementing() {\n+    SimpleErrorReporter reporter = new SimpleErrorReporter();\n+    final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter);\n+\n+    StaticScope<JSType> scope = new StaticScope<JSType>() {\n+          public StaticSlot<JSType> getSlot(final String name) {\n+            return new SimpleSlot(\n+                name,\n+                typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n+                false);\n+          }\n+          public StaticSlot<JSType> getOwnSlot(String name) {\n+            return getSlot(name);\n+          }\n+          public StaticScope<JSType> getParentScope() { return null; }\n+          public JSType getTypeOfThis() { return null; }\n+        };\n+\n+    ObjectType namedType =\n+        (ObjectType) typeRegistry.getType(scope, \"Foo\", null, 0, 0);\n+    ObjectType subNamed =\n+        typeRegistry.createObjectType(typeRegistry.createObjectType(namedType));\n+\n+    // Subclass of named type is initially unresolved.\n+    typeRegistry.setLastGeneration(false);\n+    typeRegistry.resolveTypesInScope(scope);\n+    assertTrue(subNamed.isUnknownType());\n+\n+    // Subclass of named type is still unresolved, even though the named type is\n+    // now present in the registry.\n+    typeRegistry.declareType(\"Foo\", typeRegistry.createAnonymousObjectType());\n+    typeRegistry.resolveTypesInScope(scope);\n+    assertTrue(subNamed.isUnknownType());\n+\n+    assertNull(\"Unexpected errors: \" + reporter.errors(),\n+        reporter.errors());\n+    assertNull(\"Unexpected warnings: \" + reporter.warnings(),\n+        reporter.warnings());\n+\n+    // After incrementing the generation, resolve works again.\n+    typeRegistry.incrementGeneration();\n+    typeRegistry.setLastGeneration(true);\n+    typeRegistry.resolveTypesInScope(scope);\n+    assertFalse(subNamed.isUnknownType());\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n+import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n+import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n+\n+import com.google.common.base.Pair;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Visibility;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class JSTypeTest extends BaseJSTypeTestCase {\n+  private FunctionType dateMethod;\n+  private FunctionType functionType;\n+  private NamedType unresolvedNamedType;\n+  private FunctionType googBar;\n+  private FunctionType googSubBar;\n+  private FunctionType googSubSubBar;\n+  private ObjectType googBarInst;\n+  private ObjectType googSubBarInst;\n+  private ObjectType googSubSubBarInst;\n+  private NamedType namedGoogBar;\n+  private ObjectType subclassOfUnresolvedNamedType;\n+  private FunctionType subclassCtor;\n+  private FunctionType interfaceType;\n+  private JSType recordType;\n+  private EnumType enumType;\n+  private EnumElementType elementsType;\n+\n+  private static final StaticScope<JSType> EMPTY_SCOPE =\n+      new StaticScope<JSType>() {\n+    @Override\n+    public StaticScope<JSType> getParentScope() { return null; }\n+\n+    @Override\n+    public StaticSlot<JSType> getSlot(String name) { return null; }\n+\n+    @Override\n+    public StaticSlot<JSType> getOwnSlot(String name) { return null; }\n+\n+    @Override\n+    public JSType getTypeOfThis() { return null; }\n+  };\n+\n+  /**\n+   * A non exhaustive list of representative types used to test simple\n+   * properties that should hold for all types (such as the reflexivity\n+   * of subtyping).\n+   */\n+  private List<JSType> types;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    recordType = builder.build();\n+\n+    enumType = new EnumType(registry, \"Enum\", NUMBER_TYPE);\n+    elementsType = enumType.getElementsType();\n+    functionType = new FunctionType(registry, null, null, null, NUMBER_TYPE);\n+    dateMethod = new FunctionType(registry, null, null, new Node(Token.LP),\n+        NUMBER_TYPE, DATE_TYPE);\n+    unresolvedNamedType =\n+        new NamedType(registry, \"not.resolved.named.type\", null, -1, -1);\n+    namedGoogBar = new NamedType(registry, \"goog.Bar\", null, -1, -1);\n+\n+    subclassCtor =\n+        new FunctionType(registry, null, null, null, null, null, null,\n+                         true, false);\n+    subclassCtor.setPrototypeBasedOn(unresolvedNamedType);\n+    subclassOfUnresolvedNamedType = subclassCtor.getInstanceType();\n+\n+    interfaceType = new FunctionType(registry, \"Interface\", null);\n+\n+    googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n+    googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true);\n+    googBar.setImplementedInterfaces(\n+        Lists.<ObjectType>newArrayList(interfaceType.getInstanceType()));\n+    googBarInst = googBar.getInstanceType();\n+\n+    googSubBar = registry.createConstructorType(\n+        \"googSubBar\", null, null, null);\n+    googSubBar.setPrototypeBasedOn(googBar.getInstanceType());\n+    googSubBarInst = googSubBar.getInstanceType();\n+\n+    googSubSubBar = registry.createConstructorType(\n+        \"googSubSubBar\", null, null, null);\n+    googSubSubBar.setPrototypeBasedOn(googSubBar.getInstanceType());\n+    googSubSubBarInst = googSubSubBar.getInstanceType();\n+\n+    final ObjectType googObject = registry.createAnonymousObjectType();\n+    googObject.defineDeclaredProperty(\"Bar\", googBar, false);\n+\n+    namedGoogBar.resolve(null, new StaticScope<JSType>() {\n+          public StaticSlot<JSType> getSlot(String name) {\n+            if (\"goog\".equals(name)) {\n+              return new SimpleSlot(\"goog\", googObject, false);\n+            } else {\n+              return null;\n+            }\n+          }\n+\n+          public StaticSlot<JSType> getOwnSlot(String name) {\n+            return getSlot(name);\n+          }\n+\n+          public StaticScope<JSType> getParentScope() {\n+            return null;\n+          }\n+\n+          public JSType getTypeOfThis() { return null; }\n+        });\n+\n+    types = ImmutableList.of(\n+        NO_OBJECT_TYPE,\n+        NO_TYPE,\n+        BOOLEAN_OBJECT_TYPE,\n+        BOOLEAN_TYPE,\n+        STRING_OBJECT_TYPE,\n+        STRING_TYPE,\n+        VOID_TYPE,\n+        UNKNOWN_TYPE,\n+        NULL_TYPE,\n+        NUMBER_OBJECT_TYPE,\n+        NUMBER_TYPE,\n+        DATE_TYPE,\n+        ERROR_TYPE,\n+        SYNTAX_ERROR_TYPE,\n+        dateMethod,\n+        functionType,\n+        unresolvedNamedType,\n+        googBar,\n+        googSubBar,\n+        googSubSubBar,\n+        namedGoogBar,\n+        googBar.getInstanceType(),\n+        subclassOfUnresolvedNamedType,\n+        subclassCtor,\n+        recordType,\n+        enumType,\n+        elementsType,\n+        googBar,\n+        googSubBar);\n+  }\n+\n+  /**\n+   * Tests the behavior of the top constructor type.\n+   */\n+  public void testUniversalConstructorType() throws Exception {\n+    // isXxx\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNoObjectType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNoType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isArrayType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isBooleanValueType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isDateType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumElementType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNamedType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNumber());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberObjectType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberValueType());\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isObject());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isFunctionPrototypeType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isRegexpType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isString());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isStringObjectType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isStringValueType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isUnionType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isAllType());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isVoidType());\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isConstructor());\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(NO_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.canAssignTo(functionType));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(recordType));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(NULL_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(STRING_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canTestForEqualityWith\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(NO_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(functionType));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(recordType));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(NULL_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(TYPE_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForEqualityWith(VOID_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(functionType));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(recordType));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue( U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.\n+        canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.isNullable());\n+\n+    // isObject\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isObject());\n+\n+    // matchesXxx\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.matchesInt32Context());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.matchesNumberContext());\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.matchesObjectContext());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.matchesStringContext());\n+    assertFalse(U2U_CONSTRUCTOR_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Function\",\n+        U2U_CONSTRUCTOR_TYPE.toString());\n+\n+    // getPropertyType\n+    assertEquals(UNKNOWN_TYPE,\n+        U2U_CONSTRUCTOR_TYPE.getPropertyType(\"anyProperty\"));\n+\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the Bottom Object yype.\n+   */\n+  public void testNoObjectType() throws Exception {\n+    // isXxx\n+    assertTrue(NO_OBJECT_TYPE.isNoObjectType());\n+    assertFalse(NO_OBJECT_TYPE.isNoType());\n+    assertFalse(NO_OBJECT_TYPE.isArrayType());\n+    assertFalse(NO_OBJECT_TYPE.isBooleanValueType());\n+    assertFalse(NO_OBJECT_TYPE.isDateType());\n+    assertFalse(NO_OBJECT_TYPE.isEnumElementType());\n+    assertFalse(NO_OBJECT_TYPE.isNullType());\n+    assertFalse(NO_OBJECT_TYPE.isNamedType());\n+    assertFalse(NO_OBJECT_TYPE.isNullType());\n+    assertTrue(NO_OBJECT_TYPE.isNumber());\n+    assertFalse(NO_OBJECT_TYPE.isNumberObjectType());\n+    assertFalse(NO_OBJECT_TYPE.isNumberValueType());\n+    assertTrue(NO_OBJECT_TYPE.isObject());\n+    assertFalse(NO_OBJECT_TYPE.isFunctionPrototypeType());\n+    assertFalse(NO_OBJECT_TYPE.isRegexpType());\n+    assertTrue(NO_OBJECT_TYPE.isString());\n+    assertFalse(NO_OBJECT_TYPE.isStringObjectType());\n+    assertFalse(NO_OBJECT_TYPE.isStringValueType());\n+    assertFalse(NO_OBJECT_TYPE.isEnumType());\n+    assertFalse(NO_OBJECT_TYPE.isUnionType());\n+    assertFalse(NO_OBJECT_TYPE.isAllType());\n+    assertFalse(NO_OBJECT_TYPE.isVoidType());\n+    assertTrue(NO_OBJECT_TYPE.isConstructor());\n+    assertFalse(NO_OBJECT_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(NO_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(functionType));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(recordType));\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(NULL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canTestForEqualityWith\n+    assertFalse(NO_OBJECT_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(recordType));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(NULL_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForEqualityWith(VOID_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(recordType));\n+    assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(NO_OBJECT_TYPE.isNullable());\n+\n+    // isObject\n+    assertTrue(NO_OBJECT_TYPE.isObject());\n+\n+    // matchesXxx\n+    assertTrue(NO_OBJECT_TYPE.matchesInt32Context());\n+    assertTrue(NO_OBJECT_TYPE.matchesNumberContext());\n+    assertTrue(NO_OBJECT_TYPE.matchesObjectContext());\n+    assertTrue(NO_OBJECT_TYPE.matchesStringContext());\n+    assertTrue(NO_OBJECT_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"NoObject\", NO_OBJECT_TYPE.toString());\n+\n+    // getPropertyType\n+    assertEquals(NO_TYPE,\n+        NO_OBJECT_TYPE.getPropertyType(\"anyProperty\"));\n+  }\n+\n+  /**\n+   * Tests the behavior of the Bottom type.\n+   */\n+  public void testNoType() throws Exception {\n+    // isXxx\n+    assertFalse(NO_TYPE.isNoObjectType());\n+    assertTrue(NO_TYPE.isNoType());\n+    assertFalse(NO_TYPE.isArrayType());\n+    assertFalse(NO_TYPE.isBooleanValueType());\n+    assertFalse(NO_TYPE.isDateType());\n+    assertFalse(NO_TYPE.isEnumElementType());\n+    assertFalse(NO_TYPE.isNullType());\n+    assertFalse(NO_TYPE.isNamedType());\n+    assertFalse(NO_TYPE.isNullType());\n+    assertTrue(NO_TYPE.isNumber());\n+    assertFalse(NO_TYPE.isNumberObjectType());\n+    assertFalse(NO_TYPE.isNumberValueType());\n+    assertTrue(NO_TYPE.isObject());\n+    assertFalse(NO_TYPE.isFunctionPrototypeType());\n+    assertFalse(NO_TYPE.isRegexpType());\n+    assertTrue(NO_TYPE.isString());\n+    assertFalse(NO_TYPE.isStringObjectType());\n+    assertFalse(NO_TYPE.isStringValueType());\n+    assertFalse(NO_TYPE.isEnumType());\n+    assertFalse(NO_TYPE.isUnionType());\n+    assertFalse(NO_TYPE.isAllType());\n+    assertFalse(NO_TYPE.isVoidType());\n+    assertTrue(NO_TYPE.isConstructor());\n+    assertFalse(NO_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertTrue(NO_TYPE.canAssignTo(NO_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(functionType));\n+    assertTrue(NO_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(ALL_TYPE));\n+    assertTrue(NO_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canTestForEqualityWith\n+    assertFalse(NO_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertFalse(NO_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(NULL_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(NO_TYPE.canTestForEqualityWith(VOID_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertTrue(NO_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertTrue(NO_TYPE.isNullable());\n+\n+    // isObject\n+    assertTrue(NO_TYPE.isObject());\n+\n+    // matchesXxx\n+    assertTrue(NO_TYPE.matchesInt32Context());\n+    assertTrue(NO_TYPE.matchesNumberContext());\n+    assertTrue(NO_TYPE.matchesObjectContext());\n+    assertTrue(NO_TYPE.matchesStringContext());\n+    assertTrue(NO_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"None\", NO_TYPE.toString());\n+\n+    // getPropertyType\n+    assertEquals(NO_TYPE,\n+        NO_TYPE.getPropertyType(\"anyProperty\"));\n+  }\n+\n+  /**\n+   * Tests the behavior of the Array type.\n+   */\n+  public void testArrayType() throws Exception {\n+    // isXxx\n+    assertTrue(ARRAY_TYPE.isArrayType());\n+    assertFalse(ARRAY_TYPE.isBooleanValueType());\n+    assertFalse(ARRAY_TYPE.isDateType());\n+    assertFalse(ARRAY_TYPE.isEnumElementType());\n+    assertFalse(ARRAY_TYPE.isNamedType());\n+    assertFalse(ARRAY_TYPE.isNullType());\n+    assertFalse(ARRAY_TYPE.isNumber());\n+    assertFalse(ARRAY_TYPE.isNumberObjectType());\n+    assertFalse(ARRAY_TYPE.isNumberValueType());\n+    assertTrue(ARRAY_TYPE.isObject());\n+    assertFalse(ARRAY_TYPE.isFunctionPrototypeType());\n+    assertTrue(ARRAY_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(ARRAY_TYPE.isRegexpType());\n+    assertFalse(ARRAY_TYPE.isString());\n+    assertFalse(ARRAY_TYPE.isStringObjectType());\n+    assertFalse(ARRAY_TYPE.isStringValueType());\n+    assertFalse(ARRAY_TYPE.isEnumType());\n+    assertFalse(ARRAY_TYPE.isUnionType());\n+    assertFalse(ARRAY_TYPE.isAllType());\n+    assertFalse(ARRAY_TYPE.isVoidType());\n+    assertFalse(ARRAY_TYPE.isConstructor());\n+    assertTrue(ARRAY_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertFalse(ARRAY_TYPE.canAssignTo(NO_TYPE));\n+    assertFalse(ARRAY_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(ARRAY_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(ARRAY_TYPE.canAssignTo(functionType));\n+    assertFalse(ARRAY_TYPE.canAssignTo(recordType));\n+    assertFalse(ARRAY_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(ARRAY_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(ARRAY_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(ARRAY_TYPE.canAssignTo(namedGoogBar));\n+    assertFalse(ARRAY_TYPE.canAssignTo(REGEXP_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(ARRAY_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(recordType));\n+    assertFalse(ARRAY_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(recordType));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(ARRAY_TYPE.isNullable());\n+    assertTrue(createUnionType(ARRAY_TYPE, NULL_TYPE).isNullable());\n+\n+    // isObject\n+    assertTrue(ARRAY_TYPE.isObject());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        ARRAY_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE),\n+        ARRAY_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE),\n+        ARRAY_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createUnionType(ARRAY_TYPE, functionType),\n+        ARRAY_TYPE.getLeastSupertype(functionType));\n+    assertEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, ARRAY_TYPE),\n+        ARRAY_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE),\n+        ARRAY_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // getPropertyType\n+    assertEquals(17, ARRAY_TYPE.getImplicitPrototype().getPropertiesCount());\n+    assertEquals(18, ARRAY_TYPE.getPropertiesCount());\n+    assertReturnTypeEquals(ARRAY_TYPE,\n+        ARRAY_TYPE.getPropertyType(\"constructor\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        ARRAY_TYPE.getPropertyType(\"toString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        ARRAY_TYPE.getPropertyType(\"toLocaleString\"));\n+    assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"concat\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        ARRAY_TYPE.getPropertyType(\"join\"));\n+    assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType(\"pop\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"push\"));\n+    assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"reverse\"));\n+    assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType(\"shift\"));\n+    assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"slice\"));\n+    assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"sort\"));\n+    assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType(\"splice\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"unshift\"));\n+    assertEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType(\"length\"));\n+\n+    // isPropertyType*\n+    assertPropertyTypeDeclared(ARRAY_TYPE, \"pop\");\n+\n+    // matchesXxx\n+    assertFalse(ARRAY_TYPE.matchesInt32Context());\n+    assertFalse(ARRAY_TYPE.matchesNumberContext());\n+    assertTrue(ARRAY_TYPE.matchesObjectContext());\n+    assertTrue(ARRAY_TYPE.matchesStringContext());\n+    assertFalse(ARRAY_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Array\", ARRAY_TYPE.toString());\n+\n+    assertTrue(ARRAY_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the unknown type.\n+   */\n+  public void testUnknownType() throws Exception {\n+    // isXxx\n+    assertFalse(UNKNOWN_TYPE.isArrayType());\n+    assertFalse(UNKNOWN_TYPE.isBooleanObjectType());\n+    assertFalse(UNKNOWN_TYPE.isBooleanValueType());\n+    assertFalse(UNKNOWN_TYPE.isDateType());\n+    assertFalse(UNKNOWN_TYPE.isEnumElementType());\n+    assertFalse(UNKNOWN_TYPE.isNamedType());\n+    assertFalse(UNKNOWN_TYPE.isNullType());\n+    assertFalse(UNKNOWN_TYPE.isNumberObjectType());\n+    assertFalse(UNKNOWN_TYPE.isNumberValueType());\n+    assertTrue(UNKNOWN_TYPE.isObject());\n+    assertFalse(UNKNOWN_TYPE.isFunctionPrototypeType());\n+    assertFalse(UNKNOWN_TYPE.isRegexpType());\n+    assertFalse(UNKNOWN_TYPE.isStringObjectType());\n+    assertFalse(UNKNOWN_TYPE.isStringValueType());\n+    assertFalse(UNKNOWN_TYPE.isEnumType());\n+    assertFalse(UNKNOWN_TYPE.isUnionType());\n+    assertTrue(UNKNOWN_TYPE.isUnknownType());\n+    assertFalse(UNKNOWN_TYPE.isVoidType());\n+    assertFalse(UNKNOWN_TYPE.isConstructor());\n+    assertFalse(UNKNOWN_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertNull(UNKNOWN_TYPE.autoboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(UNKNOWN_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(functionType));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(recordType));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(namedGoogBar));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(unresolvedNamedType));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canBeCalled\n+    assertTrue(UNKNOWN_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(recordType));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(recordType));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+\n+    // canHaveNullValue\n+    assertTrue(UNKNOWN_TYPE.isNullable());\n+\n+    // getGreatestCommonType\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(UNKNOWN_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(STRING_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(functionType));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // matchesXxx\n+    assertTrue(UNKNOWN_TYPE.matchesInt32Context());\n+    assertTrue(UNKNOWN_TYPE.matchesNumberContext());\n+    assertTrue(UNKNOWN_TYPE.matchesObjectContext());\n+    assertTrue(UNKNOWN_TYPE.matchesStringContext());\n+    assertTrue(UNKNOWN_TYPE.matchesUint32Context());\n+\n+    // isPropertyType*\n+    assertPropertyTypeUnknown(UNKNOWN_TYPE, \"XXX\");\n+\n+    // toString\n+    assertEquals(\"?\", UNKNOWN_TYPE.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the unknown type.\n+   */\n+  public void testAllType() throws Exception {\n+    // isXxx\n+    assertFalse(ALL_TYPE.isArrayType());\n+    assertFalse(ALL_TYPE.isBooleanValueType());\n+    assertFalse(ALL_TYPE.isDateType());\n+    assertFalse(ALL_TYPE.isEnumElementType());\n+    assertFalse(ALL_TYPE.isNamedType());\n+    assertFalse(ALL_TYPE.isNullType());\n+    assertFalse(ALL_TYPE.isNumber());\n+    assertFalse(ALL_TYPE.isNumberObjectType());\n+    assertFalse(ALL_TYPE.isNumberValueType());\n+    assertFalse(ALL_TYPE.isObject());\n+    assertFalse(ALL_TYPE.isFunctionPrototypeType());\n+    assertFalse(ALL_TYPE.isRegexpType());\n+    assertFalse(ALL_TYPE.isString());\n+    assertFalse(ALL_TYPE.isStringObjectType());\n+    assertFalse(ALL_TYPE.isStringValueType());\n+    assertFalse(ALL_TYPE.isEnumType());\n+    assertFalse(ALL_TYPE.isUnionType());\n+    assertTrue(ALL_TYPE.isAllType());\n+    assertFalse(ALL_TYPE.isVoidType());\n+    assertFalse(ALL_TYPE.isConstructor());\n+    assertFalse(ALL_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertFalse(ALL_TYPE.canAssignTo(NO_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(functionType));\n+    assertFalse(ALL_TYPE.canAssignTo(recordType));\n+    assertFalse(ALL_TYPE.canAssignTo(NULL_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(ALL_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(ALL_TYPE.canAssignTo(namedGoogBar));\n+    assertFalse(ALL_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(ALL_TYPE.canAssignTo(VOID_TYPE));\n+    assertTrue(ALL_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(ALL_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(recordType));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(ALL_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(recordType));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertTrue(ALL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(ALL_TYPE.isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(functionType));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // matchesXxx\n+    assertFalse(ALL_TYPE.matchesInt32Context());\n+    assertFalse(ALL_TYPE.matchesNumberContext());\n+    assertFalse(ALL_TYPE.matchesObjectContext());\n+    assertTrue(ALL_TYPE.matchesStringContext());\n+    assertFalse(ALL_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"*\", ALL_TYPE.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the Object type (the object\n+   * at the top of the JavaScript hierarchy).\n+   */\n+  public void testTheObjectType() throws Exception {\n+    // implicit prototype\n+    assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n+\n+    // isXxx\n+    assertFalse(OBJECT_TYPE.isNoObjectType());\n+    assertFalse(OBJECT_TYPE.isNoType());\n+    assertFalse(OBJECT_TYPE.isArrayType());\n+    assertFalse(OBJECT_TYPE.isBooleanValueType());\n+    assertFalse(OBJECT_TYPE.isDateType());\n+    assertFalse(OBJECT_TYPE.isEnumElementType());\n+    assertFalse(OBJECT_TYPE.isNullType());\n+    assertFalse(OBJECT_TYPE.isNamedType());\n+    assertFalse(OBJECT_TYPE.isNullType());\n+    assertFalse(OBJECT_TYPE.isNumber());\n+    assertFalse(OBJECT_TYPE.isNumberObjectType());\n+    assertFalse(OBJECT_TYPE.isNumberValueType());\n+    assertTrue(OBJECT_TYPE.isObject());\n+    assertFalse(OBJECT_TYPE.isFunctionPrototypeType());\n+    assertTrue(OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(OBJECT_TYPE.isRegexpType());\n+    assertFalse(OBJECT_TYPE.isString());\n+    assertFalse(OBJECT_TYPE.isStringObjectType());\n+    assertFalse(OBJECT_TYPE.isStringValueType());\n+    assertFalse(OBJECT_TYPE.isEnumType());\n+    assertFalse(OBJECT_TYPE.isUnionType());\n+    assertFalse(OBJECT_TYPE.isAllType());\n+    assertFalse(OBJECT_TYPE.isVoidType());\n+    assertFalse(OBJECT_TYPE.isConstructor());\n+    assertTrue(OBJECT_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertFalse(OBJECT_TYPE.canAssignTo(NO_TYPE));\n+    assertTrue(OBJECT_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(functionType));\n+    assertFalse(OBJECT_TYPE.canAssignTo(recordType));\n+    assertFalse(OBJECT_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(namedGoogBar));\n+    assertTrue(OBJECT_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(OBJECT_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(OBJECT_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(OBJECT_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(OBJECT_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(recordType));\n+    assertFalse(OBJECT_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(recordType));\n+    assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // isNullable\n+    assertFalse(OBJECT_TYPE.isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE),\n+        OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(functionType));\n+    assertEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // getPropertyType\n+    assertEquals(7, OBJECT_TYPE.getPropertiesCount());\n+    assertReturnTypeEquals(OBJECT_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"constructor\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"toString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"toLocaleString\"));\n+    assertReturnTypeEquals(UNKNOWN_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"valueOf\"));\n+    assertReturnTypeEquals(BOOLEAN_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"hasOwnProperty\"));\n+    assertReturnTypeEquals(BOOLEAN_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"isPrototypeOf\"));\n+    assertReturnTypeEquals(BOOLEAN_TYPE,\n+        OBJECT_TYPE.getPropertyType(\"propertyIsEnumerable\"));\n+\n+    // matchesXxx\n+    assertFalse(OBJECT_TYPE.matchesInt32Context());\n+    assertFalse(OBJECT_TYPE.matchesNumberContext());\n+    assertTrue(OBJECT_TYPE.matchesObjectContext());\n+    assertTrue(OBJECT_TYPE.matchesStringContext());\n+    assertFalse(OBJECT_TYPE.matchesUint32Context());\n+\n+    // implicit prototype\n+    assertEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype());\n+\n+    // toString\n+    assertEquals(\"Object\", OBJECT_TYPE.toString());\n+\n+    assertTrue(OBJECT_TYPE.isNativeObjectType());\n+    assertTrue(OBJECT_TYPE.getImplicitPrototype().isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the number value type.\n+   */\n+  public void testNumberObjectType() throws Exception {\n+    // isXxx\n+    assertFalse(NUMBER_OBJECT_TYPE.isArrayType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isBooleanObjectType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isBooleanValueType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isDateType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isEnumElementType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isNamedType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isNullType());\n+    assertTrue(NUMBER_OBJECT_TYPE.isNumber());\n+    assertTrue(NUMBER_OBJECT_TYPE.isNumberObjectType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isNumberValueType());\n+    assertTrue(NUMBER_OBJECT_TYPE.isObject());\n+    assertFalse(NUMBER_OBJECT_TYPE.isFunctionPrototypeType());\n+    assertTrue(NUMBER_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isRegexpType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isString());\n+    assertFalse(NUMBER_OBJECT_TYPE.isStringObjectType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isStringValueType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isEnumType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isUnionType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isAllType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isVoidType());\n+    assertFalse(NUMBER_OBJECT_TYPE.isConstructor());\n+    assertTrue(NUMBER_OBJECT_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n+\n+    // unboxesTo\n+    assertEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(functionType));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(namedGoogBar));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(\n+            createUnionType(NUMBER_OBJECT_TYPE, NULL_TYPE)));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(\n+            createUnionType(NUMBER_TYPE, NULL_TYPE)));\n+    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(NUMBER_OBJECT_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(elementsType));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(NUMBER_OBJECT_TYPE.isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE),\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE),\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType),\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(functionType));\n+    assertEquals(OBJECT_TYPE,\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE),\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE),\n+        NUMBER_OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // matchesXxx\n+    assertTrue(NUMBER_OBJECT_TYPE.matchesInt32Context());\n+    assertTrue(NUMBER_OBJECT_TYPE.matchesNumberContext());\n+    assertTrue(NUMBER_OBJECT_TYPE.matchesObjectContext());\n+    assertTrue(NUMBER_OBJECT_TYPE.matchesStringContext());\n+    assertTrue(NUMBER_OBJECT_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Number\", NUMBER_OBJECT_TYPE.toString());\n+\n+    assertTrue(NUMBER_OBJECT_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the number value type.\n+   */\n+  public void testNumberValueType() throws Exception {\n+    // isXxx\n+    assertFalse(NUMBER_TYPE.isArrayType());\n+    assertFalse(NUMBER_TYPE.isBooleanObjectType());\n+    assertFalse(NUMBER_TYPE.isBooleanValueType());\n+    assertFalse(NUMBER_TYPE.isDateType());\n+    assertFalse(NUMBER_TYPE.isEnumElementType());\n+    assertFalse(NUMBER_TYPE.isNamedType());\n+    assertFalse(NUMBER_TYPE.isNullType());\n+    assertTrue(NUMBER_TYPE.isNumber());\n+    assertFalse(NUMBER_TYPE.isNumberObjectType());\n+    assertTrue(NUMBER_TYPE.isNumberValueType());\n+    assertFalse(NUMBER_TYPE.isFunctionPrototypeType());\n+    assertFalse(NUMBER_TYPE.isRegexpType());\n+    assertFalse(NUMBER_TYPE.isString());\n+    assertFalse(NUMBER_TYPE.isStringObjectType());\n+    assertFalse(NUMBER_TYPE.isStringValueType());\n+    assertFalse(NUMBER_TYPE.isEnumType());\n+    assertFalse(NUMBER_TYPE.isUnionType());\n+    assertFalse(NUMBER_TYPE.isAllType());\n+    assertFalse(NUMBER_TYPE.isVoidType());\n+    assertFalse(NUMBER_TYPE.isConstructor());\n+    assertFalse(NUMBER_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(NUMBER_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(NUMBER_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(NUMBER_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(NUMBER_TYPE.canAssignTo(functionType));\n+    assertFalse(NUMBER_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(NUMBER_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(NUMBER_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(NUMBER_TYPE.canAssignTo(namedGoogBar));\n+    assertTrue(NUMBER_TYPE.canAssignTo(\n+            createUnionType(NUMBER_TYPE, NULL_TYPE)));\n+    assertTrue(NUMBER_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(NUMBER_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(NUMBER_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // isNullable\n+    assertFalse(NUMBER_TYPE.isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        NUMBER_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE),\n+        NUMBER_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(NUMBER_TYPE,\n+        NUMBER_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createUnionType(NUMBER_TYPE, functionType),\n+        NUMBER_TYPE.getLeastSupertype(functionType));\n+    assertEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE),\n+        NUMBER_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(createUnionType(NUMBER_TYPE, DATE_TYPE),\n+        NUMBER_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE),\n+        NUMBER_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // matchesXxx\n+    assertTrue(NUMBER_TYPE.matchesInt32Context());\n+    assertTrue(NUMBER_TYPE.matchesNumberContext());\n+    assertTrue(NUMBER_TYPE.matchesObjectContext());\n+    assertTrue(NUMBER_TYPE.matchesStringContext());\n+    assertTrue(NUMBER_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"number\", NUMBER_TYPE.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the null type.\n+   */\n+  public void testNullType() throws Exception {\n+    // isXxx\n+    assertFalse(NULL_TYPE.isArrayType());\n+    assertFalse(NULL_TYPE.isBooleanValueType());\n+    assertFalse(NULL_TYPE.isDateType());\n+    assertFalse(NULL_TYPE.isEnumElementType());\n+    assertFalse(NULL_TYPE.isNamedType());\n+    assertTrue(NULL_TYPE.isNullType());\n+    assertFalse(NULL_TYPE.isNumber());\n+    assertFalse(NULL_TYPE.isNumberObjectType());\n+    assertFalse(NULL_TYPE.isNumberValueType());\n+    assertFalse(NULL_TYPE.isFunctionPrototypeType());\n+    assertFalse(NULL_TYPE.isRegexpType());\n+    assertFalse(NULL_TYPE.isString());\n+    assertFalse(NULL_TYPE.isStringObjectType());\n+    assertFalse(NULL_TYPE.isStringValueType());\n+    assertFalse(NULL_TYPE.isEnumType());\n+    assertFalse(NULL_TYPE.isUnionType());\n+    assertFalse(NULL_TYPE.isAllType());\n+    assertFalse(NULL_TYPE.isVoidType());\n+    assertFalse(NULL_TYPE.isConstructor());\n+    assertFalse(NULL_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertNull(NULL_TYPE.autoboxesTo());\n+\n+    // canAssignTo\n+    assertFalse(NULL_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(NO_TYPE));\n+    assertTrue(NULL_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(NULL_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(functionType));\n+    assertFalse(NULL_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(NULL_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(NULL_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(NO_OBJECT_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(NO_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(NULL_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(ALL_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(STRING_OBJECT_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(NUMBER_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(functionType)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(OBJECT_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(DATE_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(REGEXP_TYPE)));\n+    assertTrue(NULL_TYPE.canAssignTo(createNullableType(ARRAY_TYPE)));\n+\n+    // canBeCalled\n+    assertFalse(NULL_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(NULL_TYPE.canTestForEqualityWith(NO_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE));\n+    assertTrue(NULL_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(NULL_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(TYPE_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(VOID_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(NULL_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(NULL_TYPE.canTestForShallowEqualityWith(\n+            createNullableType(STRING_OBJECT_TYPE)));\n+\n+    // getLeastSupertype\n+    assertEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE));\n+    assertEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createNullableType(STRING_OBJECT_TYPE),\n+        NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createNullableType(NUMBER_TYPE),\n+        NULL_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createNullableType(functionType),\n+        NULL_TYPE.getLeastSupertype(functionType));\n+    assertEquals(createNullableType(OBJECT_TYPE),\n+        NULL_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(createNullableType(DATE_TYPE),\n+        NULL_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(createNullableType(REGEXP_TYPE),\n+        NULL_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // matchesXxx\n+    assertTrue(NULL_TYPE.matchesInt32Context());\n+    assertTrue(NULL_TYPE.matchesNumberContext());\n+    assertFalse(NULL_TYPE.matchesObjectContext());\n+    assertTrue(NULL_TYPE.matchesStringContext());\n+    assertTrue(NULL_TYPE.matchesUint32Context());\n+\n+    // matchesObjectContext\n+    assertFalse(NULL_TYPE.matchesObjectContext());\n+\n+    // toString\n+    assertEquals(\"null\", NULL_TYPE.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the Date type.\n+   */\n+  public void testDateType() throws Exception {\n+    // isXxx\n+    assertFalse(DATE_TYPE.isArrayType());\n+    assertFalse(DATE_TYPE.isBooleanValueType());\n+    assertTrue(DATE_TYPE.isDateType());\n+    assertFalse(DATE_TYPE.isEnumElementType());\n+    assertFalse(DATE_TYPE.isNamedType());\n+    assertFalse(DATE_TYPE.isNullType());\n+    assertFalse(DATE_TYPE.isNumberValueType());\n+    assertFalse(DATE_TYPE.isFunctionPrototypeType());\n+    assertTrue(DATE_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(DATE_TYPE.isRegexpType());\n+    assertFalse(DATE_TYPE.isStringValueType());\n+    assertFalse(DATE_TYPE.isEnumType());\n+    assertFalse(DATE_TYPE.isUnionType());\n+    assertFalse(DATE_TYPE.isAllType());\n+    assertFalse(DATE_TYPE.isVoidType());\n+    assertFalse(DATE_TYPE.isConstructor());\n+    assertTrue(DATE_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertNull(DATE_TYPE.autoboxesTo());\n+\n+    // canAssignTo\n+    assertFalse(DATE_TYPE.canAssignTo(NO_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(functionType));\n+    assertFalse(DATE_TYPE.canAssignTo(NULL_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(STRING_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(DATE_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(DATE_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(DATE_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(DATE_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(DATE_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(DATE_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(DATE_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(DATE_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(DATE_TYPE.isNullable());\n+    assertTrue(createNullableType(DATE_TYPE).isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        DATE_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE),\n+        DATE_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, NUMBER_TYPE),\n+        DATE_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, functionType),\n+        DATE_TYPE.getLeastSupertype(functionType));\n+    assertEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n+        DATE_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // getPropertyType\n+    assertEquals(46, DATE_TYPE.getImplicitPrototype().getPropertiesCount());\n+    assertEquals(46, DATE_TYPE.getPropertiesCount());\n+    assertReturnTypeEquals(DATE_TYPE, DATE_TYPE.getPropertyType(\"constructor\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toDateString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toTimeString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toLocaleString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toLocaleDateString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toLocaleTimeString\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"valueOf\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getTime\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getFullYear\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCFullYear\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getMonth\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCMonth\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getDate\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCDate\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getDay\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getUTCDay\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"getHours\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCHours\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getMinutes\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCMinutes\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getSeconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCSeconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getMilliseconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getUTCMilliseconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"getTimezoneOffset\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"setTime\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setMilliseconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCMilliseconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setSeconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCSeconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCSeconds\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setMinutes\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCMinutes\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"setHours\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCHours\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"setDate\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCDate\"));\n+    assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType(\"setMonth\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCMonth\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setFullYear\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        DATE_TYPE.getPropertyType(\"setUTCFullYear\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toUTCString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        DATE_TYPE.getPropertyType(\"toGMTString\"));\n+\n+    // matchesXxx\n+    assertTrue(DATE_TYPE.matchesInt32Context());\n+    assertTrue(DATE_TYPE.matchesNumberContext());\n+    assertTrue(DATE_TYPE.matchesObjectContext());\n+    assertTrue(DATE_TYPE.matchesStringContext());\n+    assertTrue(DATE_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Date\", DATE_TYPE.toString());\n+\n+    assertTrue(DATE_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the RegExp type.\n+   */\n+  public void testRegExpType() throws Exception {\n+    // isXxx\n+    assertFalse(REGEXP_TYPE.isNoType());\n+    assertFalse(REGEXP_TYPE.isNoObjectType());\n+    assertFalse(REGEXP_TYPE.isArrayType());\n+    assertFalse(REGEXP_TYPE.isBooleanValueType());\n+    assertFalse(REGEXP_TYPE.isDateType());\n+    assertFalse(REGEXP_TYPE.isEnumElementType());\n+    assertFalse(REGEXP_TYPE.isNamedType());\n+    assertFalse(REGEXP_TYPE.isNullType());\n+    assertFalse(REGEXP_TYPE.isNumberValueType());\n+    assertFalse(REGEXP_TYPE.isFunctionPrototypeType());\n+    assertTrue(REGEXP_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertTrue(REGEXP_TYPE.isRegexpType());\n+    assertFalse(REGEXP_TYPE.isStringValueType());\n+    assertFalse(REGEXP_TYPE.isEnumType());\n+    assertFalse(REGEXP_TYPE.isUnionType());\n+    assertFalse(REGEXP_TYPE.isAllType());\n+    assertFalse(REGEXP_TYPE.isVoidType());\n+\n+    // autoboxesTo\n+    assertNull(REGEXP_TYPE.autoboxesTo());\n+\n+    // canAssignTo\n+    assertFalse(REGEXP_TYPE.canAssignTo(NO_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(NO_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(BOOLEAN_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(EVAL_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(functionType));\n+    assertFalse(REGEXP_TYPE.canAssignTo(NULL_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertTrue(REGEXP_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(URI_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(RANGE_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(REFERENCE_ERROR_TYPE));\n+    assertTrue(REGEXP_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(STRING_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(SYNTAX_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(TYPE_ERROR_TYPE));\n+    assertTrue(REGEXP_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(REGEXP_TYPE.canAssignTo(VOID_TYPE));\n+\n+    // canBeCalled\n+    assertTrue(REGEXP_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(REGEXP_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(REGEXP_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(REGEXP_TYPE.isNullable());\n+    assertTrue(createNullableType(REGEXP_TYPE).isNullable());\n+\n+    // getLeastSupertype\n+    assertEquals(ALL_TYPE,\n+        REGEXP_TYPE.getLeastSupertype(ALL_TYPE));\n+    assertEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE),\n+        REGEXP_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));\n+    assertEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE),\n+        REGEXP_TYPE.getLeastSupertype(NUMBER_TYPE));\n+    assertEquals(createUnionType(REGEXP_TYPE, functionType),\n+        REGEXP_TYPE.getLeastSupertype(functionType));\n+    assertEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE));\n+    assertEquals(createUnionType(DATE_TYPE, REGEXP_TYPE),\n+        REGEXP_TYPE.getLeastSupertype(DATE_TYPE));\n+    assertEquals(REGEXP_TYPE,\n+        REGEXP_TYPE.getLeastSupertype(REGEXP_TYPE));\n+\n+    // getPropertyType\n+    assertEquals(9, REGEXP_TYPE.getImplicitPrototype().getPropertiesCount());\n+    assertEquals(14, REGEXP_TYPE.getPropertiesCount());\n+    assertReturnTypeEquals(REGEXP_TYPE,\n+        REGEXP_TYPE.getPropertyType(\"constructor\"));\n+    assertReturnTypeEquals(createNullableType(ARRAY_TYPE),\n+        REGEXP_TYPE.getPropertyType(\"exec\"));\n+    assertReturnTypeEquals(BOOLEAN_TYPE,\n+        REGEXP_TYPE.getPropertyType(\"test\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        REGEXP_TYPE.getPropertyType(\"toString\"));\n+    assertEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType(\"source\"));\n+    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"global\"));\n+    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"ignoreCase\"));\n+    assertEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType(\"multiline\"));\n+    assertEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType(\"lastIndex\"));\n+\n+    // matchesXxx\n+    assertFalse(REGEXP_TYPE.matchesInt32Context());\n+    assertFalse(REGEXP_TYPE.matchesNumberContext());\n+    assertTrue(REGEXP_TYPE.matchesObjectContext());\n+    assertTrue(REGEXP_TYPE.matchesStringContext());\n+    assertFalse(REGEXP_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"RegExp\", REGEXP_TYPE.toString());\n+\n+    assertTrue(REGEXP_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the string object type.\n+   */\n+  public void testStringObjectType() throws Exception {\n+    // isXxx\n+    assertFalse(STRING_OBJECT_TYPE.isArrayType());\n+    assertFalse(STRING_OBJECT_TYPE.isBooleanObjectType());\n+    assertFalse(STRING_OBJECT_TYPE.isBooleanValueType());\n+    assertFalse(STRING_OBJECT_TYPE.isDateType());\n+    assertFalse(STRING_OBJECT_TYPE.isEnumElementType());\n+    assertFalse(STRING_OBJECT_TYPE.isNamedType());\n+    assertFalse(STRING_OBJECT_TYPE.isNullType());\n+    assertFalse(STRING_OBJECT_TYPE.isNumber());\n+    assertFalse(STRING_OBJECT_TYPE.isNumberObjectType());\n+    assertFalse(STRING_OBJECT_TYPE.isNumberValueType());\n+    assertFalse(STRING_OBJECT_TYPE.isFunctionPrototypeType());\n+    assertTrue(STRING_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(STRING_OBJECT_TYPE.isRegexpType());\n+    assertTrue(STRING_OBJECT_TYPE.isString());\n+    assertTrue(STRING_OBJECT_TYPE.isStringObjectType());\n+    assertFalse(STRING_OBJECT_TYPE.isStringValueType());\n+    assertFalse(STRING_OBJECT_TYPE.isEnumType());\n+    assertFalse(STRING_OBJECT_TYPE.isUnionType());\n+    assertFalse(STRING_OBJECT_TYPE.isAllType());\n+    assertFalse(STRING_OBJECT_TYPE.isVoidType());\n+    assertFalse(STRING_OBJECT_TYPE.isConstructor());\n+    assertTrue(STRING_OBJECT_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n+\n+    // unboxesTo\n+    assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(STRING_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(STRING_OBJECT_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(STRING_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // properties (ECMA-262 page 98 - 106)\n+    assertEquals(23, STRING_OBJECT_TYPE.getImplicitPrototype().\n+        getPropertiesCount());\n+    assertEquals(24, STRING_OBJECT_TYPE.getPropertiesCount());\n+\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"toString\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"valueOf\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"charAt\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"charCodeAt\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"concat\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"indexOf\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"lastIndexOf\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"localeCompare\"));\n+    assertReturnTypeEquals(createNullableType(ARRAY_TYPE),\n+        STRING_OBJECT_TYPE.getPropertyType(\"match\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"replace\"));\n+    assertReturnTypeEquals(NUMBER_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"search\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"slice\"));\n+    assertReturnTypeEquals(ARRAY_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"split\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"substring\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"toLowerCase\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"toLocaleLowerCase\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"toUpperCase\"));\n+    assertReturnTypeEquals(STRING_TYPE,\n+        STRING_OBJECT_TYPE.getPropertyType(\"toLocaleUpperCase\"));\n+    assertEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType(\"length\"));\n+\n+    // matchesXxx\n+    assertTrue(STRING_OBJECT_TYPE.matchesInt32Context());\n+    assertTrue(STRING_OBJECT_TYPE.matchesNumberContext());\n+    assertTrue(STRING_OBJECT_TYPE.matchesObjectContext());\n+    assertTrue(STRING_OBJECT_TYPE.matchesStringContext());\n+    assertTrue(STRING_OBJECT_TYPE.matchesUint32Context());\n+\n+    // isNullable\n+    assertFalse(STRING_OBJECT_TYPE.isNullable());\n+    assertTrue(createNullableType(STRING_OBJECT_TYPE).isNullable());\n+\n+    assertTrue(STRING_OBJECT_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the string value type.\n+   */\n+  public void testStringValueType() throws Exception {\n+    // isXxx\n+    assertFalse(STRING_TYPE.isArrayType());\n+    assertFalse(STRING_TYPE.isBooleanObjectType());\n+    assertFalse(STRING_TYPE.isBooleanValueType());\n+    assertFalse(STRING_TYPE.isDateType());\n+    assertFalse(STRING_TYPE.isEnumElementType());\n+    assertFalse(STRING_TYPE.isNamedType());\n+    assertFalse(STRING_TYPE.isNullType());\n+    assertFalse(STRING_TYPE.isNumber());\n+    assertFalse(STRING_TYPE.isNumberObjectType());\n+    assertFalse(STRING_TYPE.isNumberValueType());\n+    assertFalse(STRING_TYPE.isFunctionPrototypeType());\n+    assertFalse(STRING_TYPE.isRegexpType());\n+    assertTrue(STRING_TYPE.isString());\n+    assertFalse(STRING_TYPE.isStringObjectType());\n+    assertTrue(STRING_TYPE.isStringValueType());\n+    assertFalse(STRING_TYPE.isEnumType());\n+    assertFalse(STRING_TYPE.isUnionType());\n+    assertFalse(STRING_TYPE.isAllType());\n+    assertFalse(STRING_TYPE.isVoidType());\n+    assertFalse(STRING_TYPE.isConstructor());\n+    assertFalse(STRING_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo());\n+\n+    // unboxesTo\n+    assertEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(STRING_TYPE.canAssignTo(ALL_TYPE));\n+    assertTrue(STRING_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertTrue(STRING_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(DATE_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(REGEXP_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(ARRAY_TYPE));\n+    assertTrue(STRING_TYPE.canAssignTo(STRING_TYPE));\n+    assertTrue(STRING_TYPE.canAssignTo(UNKNOWN_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(STRING_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(functionType));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(ARRAY_TYPE));\n+    assertTrue(STRING_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(STRING_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(STRING_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertTrue(STRING_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(STRING_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(STRING_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(STRING_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // matchesXxx\n+    assertTrue(STRING_TYPE.matchesInt32Context());\n+    assertTrue(STRING_TYPE.matchesNumberContext());\n+    assertTrue(STRING_TYPE.matchesObjectContext());\n+    assertTrue(STRING_TYPE.matchesStringContext());\n+    assertTrue(STRING_TYPE.matchesUint32Context());\n+\n+    // isNullable\n+    assertFalse(STRING_TYPE.isNullable());\n+    assertTrue(createNullableType(STRING_TYPE).isNullable());\n+\n+    // toString\n+    assertEquals(\"string\", STRING_TYPE.toString());\n+\n+    // findPropertyType\n+    assertEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType(\"length\"));\n+    assertEquals(null, STRING_TYPE.findPropertyType(\"unknownProperty\"));\n+  }\n+\n+  private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) {\n+    assertTrue(ownerType.isPropertyTypeDeclared(prop));\n+    assertFalse(ownerType.isPropertyTypeInferred(prop));\n+  }\n+\n+  private void assertPropertyTypeInferred(ObjectType ownerType, String prop) {\n+    assertFalse(ownerType.isPropertyTypeDeclared(prop));\n+    assertTrue(ownerType.isPropertyTypeInferred(prop));\n+  }\n+\n+  private void assertPropertyTypeUnknown(ObjectType ownerType, String prop) {\n+    assertFalse(ownerType.isPropertyTypeDeclared(prop));\n+    assertFalse(ownerType.isPropertyTypeInferred(prop));\n+    assertTrue(ownerType.getPropertyType(prop).isUnknownType());\n+  }\n+\n+  private void assertReturnTypeEquals(JSType expectedReturnType,\n+      JSType function) {\n+    assertTrue(function instanceof FunctionType);\n+    assertEquals(expectedReturnType, ((FunctionType) function).getReturnType());\n+  }\n+\n+\n+  /**\n+   * Tests the behavior of record types.\n+   */\n+  public void testRecordType() throws Exception {\n+    // isXxx\n+    assertTrue(recordType.isObject());\n+    assertFalse(recordType.isFunctionPrototypeType());\n+\n+    // canAssignTo\n+    assertTrue(recordType.canAssignTo(ALL_TYPE));\n+    assertFalse(recordType.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(recordType.canAssignTo(NUMBER_TYPE));\n+    assertFalse(recordType.canAssignTo(DATE_TYPE));\n+    assertFalse(recordType.canAssignTo(REGEXP_TYPE));\n+    assertTrue(recordType.canAssignTo(UNKNOWN_TYPE));\n+    assertTrue(recordType.canAssignTo(OBJECT_TYPE));\n+    assertFalse(recordType.canAssignTo(U2U_CONSTRUCTOR_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(recordType.autoboxesTo());\n+\n+    // canBeCalled\n+    assertFalse(recordType.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(recordType.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(recordType.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(recordType.canTestForEqualityWith(recordType));\n+    assertTrue(recordType.canTestForEqualityWith(functionType));\n+    assertTrue(recordType.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(recordType.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(recordType.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(recordType.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(recordType.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(recordType.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(recordType.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(recordType.canTestForShallowEqualityWith(recordType));\n+    assertFalse(recordType.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(recordType.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(recordType.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(recordType.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(recordType.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(recordType.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // matchesXxx\n+    assertFalse(recordType.matchesInt32Context());\n+    assertFalse(recordType.matchesNumberContext());\n+    assertTrue(recordType.matchesObjectContext());\n+    assertFalse(recordType.matchesStringContext());\n+    assertFalse(recordType.matchesUint32Context());\n+  }\n+\n+  /**\n+   * Tests the behavior of the instance of Function.\n+   */\n+  public void testFunctionInstanceType() throws Exception {\n+    FunctionType functionInst = FUNCTION_INSTANCE_TYPE;\n+\n+    // isXxx\n+    assertTrue(functionInst.isObject());\n+    assertFalse(functionInst.isFunctionPrototypeType());\n+    assertTrue(functionInst.getImplicitPrototype()\n+        .isFunctionPrototypeType());\n+\n+    // canAssignTo\n+    assertTrue(functionInst.canAssignTo(ALL_TYPE));\n+    assertFalse(functionInst.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(functionInst.canAssignTo(NUMBER_TYPE));\n+    assertFalse(functionInst.canAssignTo(DATE_TYPE));\n+    assertFalse(functionInst.canAssignTo(REGEXP_TYPE));\n+    assertTrue(functionInst.canAssignTo(UNKNOWN_TYPE));\n+    assertTrue(functionInst.canAssignTo(U2U_CONSTRUCTOR_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(functionInst.autoboxesTo());\n+\n+    // canBeCalled\n+    assertTrue(functionInst.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(functionInst.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(functionInst.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(functionInst.canTestForEqualityWith(functionInst));\n+    assertTrue(functionInst.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(functionInst.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(functionInst.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(functionInst.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(functionInst.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(functionInst.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(functionInst.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(functionInst.canTestForShallowEqualityWith(functionInst));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(functionInst.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(functionInst.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(functionInst.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(functionInst.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(functionInst.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // matchesXxx\n+    assertFalse(functionInst.matchesInt32Context());\n+    assertFalse(functionInst.matchesNumberContext());\n+    assertTrue(functionInst.matchesObjectContext());\n+    assertFalse(functionInst.matchesStringContext());\n+    assertFalse(functionInst.matchesUint32Context());\n+\n+    // hasProperty\n+    assertTrue(functionInst.hasProperty(\"prototype\"));\n+    assertPropertyTypeInferred(functionInst, \"prototype\");\n+\n+    // misc\n+    assertEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor());\n+    assertEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype());\n+    assertEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType());\n+  }\n+\n+  /**\n+   * Tests the behavior of functional types.\n+   */\n+  public void testFunctionType() throws Exception {\n+    // isXxx\n+    assertTrue(functionType.isObject());\n+    assertFalse(functionType.isFunctionPrototypeType());\n+    assertTrue(functionType.getImplicitPrototype().getImplicitPrototype()\n+        .isFunctionPrototypeType());\n+\n+    // canAssignTo\n+    assertTrue(functionType.canAssignTo(ALL_TYPE));\n+    assertFalse(functionType.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(functionType.canAssignTo(NUMBER_TYPE));\n+    assertFalse(functionType.canAssignTo(DATE_TYPE));\n+    assertFalse(functionType.canAssignTo(REGEXP_TYPE));\n+    assertTrue(functionType.canAssignTo(UNKNOWN_TYPE));\n+    assertTrue(functionType.canAssignTo(U2U_CONSTRUCTOR_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(functionType.autoboxesTo());\n+\n+    // canBeCalled\n+    assertTrue(functionType.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(functionType.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(functionType.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(functionType.canTestForEqualityWith(functionType));\n+    assertTrue(functionType.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(functionType.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(functionType.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(functionType.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(functionType.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(functionType.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(functionType.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertTrue(functionType.canTestForShallowEqualityWith(functionType));\n+    assertFalse(functionType.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(functionType.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(functionType.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(functionType.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(functionType.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(functionType.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // matchesXxx\n+    assertFalse(functionType.matchesInt32Context());\n+    assertFalse(functionType.matchesNumberContext());\n+    assertTrue(functionType.matchesObjectContext());\n+    assertFalse(functionType.matchesStringContext());\n+    assertFalse(functionType.matchesUint32Context());\n+\n+    // hasProperty\n+    assertTrue(functionType.hasProperty(\"prototype\"));\n+    assertPropertyTypeInferred(functionType, \"prototype\");\n+  }\n+\n+  /**\n+   * Tests the subtyping relation of record types.\n+   */\n+  public void testRecordTypeSubtyping() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+    JSType subRecordType = builder.build();\n+\n+    assertTrue(subRecordType.isSubtype(recordType));\n+    assertFalse(recordType.isSubtype(subRecordType));\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", OBJECT_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    JSType differentRecordType = builder.build();\n+\n+    assertFalse(differentRecordType.isSubtype(recordType));\n+    assertFalse(recordType.isSubtype(differentRecordType));\n+  }\n+\n+  /**\n+   * Tests the subtyping relation of record types when an object has\n+   * an inferred property..\n+   */\n+  public void testRecordTypeSubtypingWithInferredProperties() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", googSubBarInst);\n+    JSType record = builder.build();\n+\n+    ObjectType subtypeProp = registry.createAnonymousObjectType();\n+    subtypeProp.defineInferredProperty(\"a\", googSubSubBarInst, false);\n+    assertTrue(subtypeProp.isSubtype(record));\n+    assertFalse(record.isSubtype(subtypeProp));\n+\n+    ObjectType supertypeProp = registry.createAnonymousObjectType();\n+    supertypeProp.defineInferredProperty(\"a\", googBarInst, false);\n+    assertFalse(supertypeProp.isSubtype(record));\n+    assertFalse(record.isSubtype(supertypeProp));\n+\n+    ObjectType declaredSubtypeProp = registry.createAnonymousObjectType();\n+    declaredSubtypeProp.defineDeclaredProperty(\"a\", googSubSubBarInst, false);\n+    assertFalse(declaredSubtypeProp.isSubtype(record));\n+    assertFalse(record.isSubtype(declaredSubtypeProp));\n+  }\n+\n+  /**\n+   * Tests the getLeastSupertype method for record types.\n+   */\n+  public void testRecordTypeLeastSuperType1() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+    JSType subRecordType = builder.build();\n+\n+    JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n+    assertEquals(leastSupertype, recordType);\n+  }\n+\n+  public void testRecordTypeLeastSuperType2() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"e\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+    JSType subRecordType = builder.build();\n+\n+    JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+\n+    assertEquals(leastSupertype, builder.build());\n+  }\n+\n+  public void testRecordTypeLeastSuperType3() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"d\", NUMBER_TYPE);\n+    builder.addProperty(\"e\", STRING_TYPE);\n+    builder.addProperty(\"f\", STRING_TYPE);\n+    JSType subRecordType = builder.build();\n+\n+    JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n+    assertEquals(leastSupertype, OBJECT_TYPE);\n+  }\n+\n+  public void testRecordTypeLeastSuperType4() {\n+    JSType leastSupertype = recordType.getLeastSupertype(OBJECT_TYPE);\n+    assertEquals(leastSupertype, OBJECT_TYPE);\n+  }\n+\n+  /**\n+   * Tests the getGreastestSubtype method for record types.\n+   */\n+  public void testRecordTypeGreatestSubType1() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"d\", NUMBER_TYPE);\n+    builder.addProperty(\"e\", STRING_TYPE);\n+    builder.addProperty(\"f\", STRING_TYPE);\n+\n+    JSType subRecordType = builder.build();\n+\n+    JSType subtype = recordType.getGreatestSubtype(subRecordType);\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"d\", NUMBER_TYPE);\n+    builder.addProperty(\"e\", STRING_TYPE);\n+    builder.addProperty(\"f\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+\n+    assertEquals(subtype, builder.build());\n+  }\n+\n+  public void testRecordTypeGreatestSubType2() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+\n+    JSType subRecordType = builder.build();\n+\n+    JSType subtype = recordType.getGreatestSubtype(subRecordType);\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+\n+    assertEquals(subtype, builder.build());\n+  }\n+\n+  public void testRecordTypeGreatestSubType3() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+\n+    JSType subRecordType = builder.build();\n+\n+    JSType subtype = recordType.getGreatestSubtype(subRecordType);\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", NUMBER_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+\n+    assertEquals(subtype, builder.build());\n+  }\n+\n+  public void testRecordTypeGreatestSubType4() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", STRING_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", STRING_TYPE);\n+\n+    JSType subRecordType = builder.build();\n+\n+    JSType subtype = recordType.getGreatestSubtype(subRecordType);\n+    assertEquals(subtype, NO_TYPE);\n+  }\n+\n+  public void testRecordTypeGreatestSubType5() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", STRING_TYPE);\n+\n+    JSType recordType = builder.build();\n+\n+    assertEquals(NO_OBJECT_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+\n+    // if Function is given a property \"a\" of type \"string\", then it's\n+    // a subtype of the record type {a: string}.\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, false);\n+    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+                 U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n+  }\n+\n+  public void testRecordTypeGreatestSubType6() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"x\", UNKNOWN_TYPE);\n+\n+    JSType recordType = builder.build();\n+\n+    assertEquals(NO_OBJECT_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+\n+    // if Function is given a property \"x\" of type \"string\", then it's\n+    // also a subtype of the record type {x: ?}.\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n+    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertEquals(U2U_CONSTRUCTOR_TYPE,\n+                 U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n+  }\n+\n+  public void testRecordTypeGreatestSubType7() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"x\", NUMBER_TYPE);\n+\n+    JSType recordType = builder.build();\n+\n+    // if Function is given a property \"x\" of type \"string\", then it's\n+    // not a subtype of the record type {x: number}.\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n+    assertEquals(NO_OBJECT_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+  }\n+  public void testRecordTypeGreatestSubType8() {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"xyz\", UNKNOWN_TYPE);\n+\n+    JSType recordType = builder.build();\n+\n+    assertEquals(NO_OBJECT_TYPE,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+\n+    // if goog.Bar is given a property \"xyz\" of type \"string\", then it's\n+    // also a subtype of the record type {x: ?}.\n+    googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, false);\n+\n+    assertEquals(googBar,\n+                 recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertEquals(googBar,\n+                 U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType));\n+\n+    ObjectType googBarInst = googBar.getInstanceType();\n+    assertEquals(NO_OBJECT_TYPE,\n+                 recordType.getGreatestSubtype(googBarInst));\n+    assertEquals(NO_OBJECT_TYPE,\n+                 googBarInst.getGreatestSubtype(recordType));\n+  }\n+\n+  /**\n+   * Tests the \"apply\" method on the function type.\n+   */\n+  public void testApplyOfDateMethod() {\n+    JSType applyType = dateMethod.getPropertyType(\"apply\");\n+    assertTrue(\"apply should be a function\",\n+        applyType instanceof FunctionType);\n+\n+    FunctionType applyFn = (FunctionType) applyType;\n+    assertEquals(\"apply should have the same return type as its function\",\n+        NUMBER_TYPE, applyFn.getReturnType());\n+\n+    Node params = applyFn.getParametersNode();\n+    assertEquals(\"apply takes two args\",\n+        2, params.getChildCount());\n+    assertEquals(\"apply's first arg is the @this type\",\n+        registry.createOptionalNullableType(DATE_TYPE),\n+        params.getFirstChild().getJSType());\n+    assertEquals(\"apply's second arg is an Array\",\n+        registry.createOptionalNullableType(OBJECT_TYPE),\n+        params.getLastChild().getJSType());\n+    assertTrue(\"apply's args must be optional\",\n+        params.getFirstChild().isOptionalArg());\n+    assertTrue(\"apply's args must be optional\",\n+        params.getLastChild().isOptionalArg());\n+  }\n+\n+  /**\n+   * Tests the \"call\" method on the function type.\n+   */\n+  public void testCallOfDateMethod() {\n+    JSType callType = dateMethod.getPropertyType(\"call\");\n+    assertTrue(\"call should be a function\",\n+        callType instanceof FunctionType);\n+\n+    FunctionType callFn = (FunctionType) callType;\n+    assertEquals(\"call should have the same return type as its function\",\n+        NUMBER_TYPE, callFn.getReturnType());\n+\n+    Node params = callFn.getParametersNode();\n+    assertEquals(\"call takes one argument in this case\",\n+        1, params.getChildCount());\n+    assertEquals(\"call's first arg is the @this type\",\n+        registry.createOptionalNullableType(DATE_TYPE),\n+        params.getFirstChild().getJSType());\n+    assertTrue(\"call's args must be optional\",\n+        params.getFirstChild().isOptionalArg());\n+  }\n+\n+  /**\n+   * Tests the representation of function types.\n+   */\n+  public void testFunctionTypeRepresentation() {\n+    assertEquals(\"function (number, string): boolean\",\n+        registry.createFunctionType(BOOLEAN_TYPE, false, NUMBER_TYPE,\n+            STRING_TYPE).toString());\n+\n+    assertEquals(\"function (this:Array, ...[*]): Array\",\n+        ARRAY_FUNCTION_TYPE.toString());\n+\n+    assertEquals(\"function (this:Boolean, *): boolean\",\n+        BOOLEAN_OBJECT_FUNCTION_TYPE.toString());\n+\n+    assertEquals(\"function (this:Number, *): number\",\n+        NUMBER_OBJECT_FUNCTION_TYPE.toString());\n+\n+    assertEquals(\"function (this:String, *): string\",\n+        STRING_OBJECT_FUNCTION_TYPE.toString());\n+\n+    assertEquals(\"function (...[number]): boolean\",\n+        registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE)\n+        .toString());\n+\n+    assertEquals(\"function (number, ...[string]): boolean\",\n+        registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE,\n+            STRING_TYPE).toString());\n+\n+    assertEquals(\"function (this:Date, number): (boolean|number|string)\",\n+        new FunctionType(registry, null,\n+            null,\n+            new JSTypeRegistry(null).createParameters(NUMBER_TYPE),\n+            NUMBER_STRING_BOOLEAN,\n+            DATE_TYPE).toString());\n+  }\n+\n+  /**\n+   * Tests relationships between structural function types.\n+   */\n+  public void testFunctionTypeRelationships() {\n+    FunctionType dateMethodEmpty = new FunctionType(registry, null, null,\n+        null, null, DATE_TYPE);\n+    FunctionType dateMethodWithParam = new FunctionType(registry, null, null,\n+        new JSTypeRegistry(null).createParameters(NUMBER_TYPE), null, DATE_TYPE);\n+    FunctionType dateMethodWithReturn = new FunctionType(registry, null, null,\n+        null, NUMBER_TYPE, DATE_TYPE);\n+    FunctionType stringMethodEmpty = new FunctionType(registry, null, null,\n+        null, null, STRING_OBJECT_TYPE);\n+    FunctionType stringMethodWithParam = new FunctionType(registry, null, null,\n+        new JSTypeRegistry(null).createParameters(NUMBER_TYPE), null,\n+        STRING_OBJECT_TYPE);\n+    FunctionType stringMethodWithReturn = new FunctionType(registry, null,\n+        null, null, NUMBER_TYPE, STRING_OBJECT_TYPE);\n+\n+    // One-off tests.\n+    assertFalse(stringMethodEmpty.isSubtype(dateMethodEmpty));\n+\n+    // Systemic tests.\n+    List<FunctionType> allFunctions = Lists.newArrayList(\n+        dateMethodEmpty, dateMethodWithParam, dateMethodWithReturn,\n+        stringMethodEmpty, stringMethodWithParam, stringMethodWithReturn);\n+    for (int i = 0; i < allFunctions.size(); i++) {\n+      for (int j = 0; j < allFunctions.size(); j++) {\n+        FunctionType typeA = allFunctions.get(i);\n+        FunctionType typeB = allFunctions.get(j);\n+        assertEquals(String.format(\"equals(%s, %s)\", typeA, typeB),\n+            i == j, typeA.equals(typeB));\n+\n+        // For this particular set of functions, the functions are subtypes\n+        // of each other iff they have the same \"this\" type.\n+        assertEquals(String.format(\"isSubtype(%s, %s)\", typeA, typeB),\n+            typeA.getTypeOfThis().equals(typeB.getTypeOfThis()),\n+            typeA.isSubtype(typeB));\n+\n+        if (i == j) {\n+          assertEquals(typeA, typeA.getLeastSupertype(typeB));\n+          assertEquals(typeA, typeA.getGreatestSubtype(typeB));\n+        } else {\n+          assertEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n+              U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n+          assertEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n+              NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n+        }\n+      }\n+    }\n+  }\n+  /**\n+   * Tests relationships between structural function types.\n+   */\n+  public void testFunctionSubTypeRelationships() {\n+    FunctionType googBarMethod = new FunctionType(registry, null, null,\n+        null, null, googBar);\n+    FunctionType googBarParamFn = new FunctionType(registry, null, null,\n+        new JSTypeRegistry(null).createParameters(googBar), null, null);\n+    FunctionType googBarReturnFn = new FunctionType(registry, null, null,\n+        null, googBar, null);\n+    FunctionType googSubBarMethod = new FunctionType(registry, null, null,\n+        null, null, googSubBar);\n+    FunctionType googSubBarParamFn = new FunctionType(registry, null, null,\n+        new JSTypeRegistry(null).createParameters(googSubBar), null, null);\n+    FunctionType googSubBarReturnFn = new FunctionType(registry, null, null,\n+        null, googSubBar, null);\n+\n+    assertTrue(googBarMethod.isSubtype(googSubBarMethod));\n+    assertTrue(googBarReturnFn.isSubtype(googSubBarReturnFn));\n+\n+    List<FunctionType> allFunctions = Lists.newArrayList(\n+        googBarMethod, googBarParamFn, googBarReturnFn,\n+        googSubBarMethod, googSubBarParamFn, googSubBarReturnFn);\n+    for (int i = 0; i < allFunctions.size(); i++) {\n+      for (int j = 0; j < allFunctions.size(); j++) {\n+        FunctionType typeA = allFunctions.get(i);\n+        FunctionType typeB = allFunctions.get(j);\n+        assertEquals(String.format(\"equals(%s, %s)\", typeA, typeB),\n+            i == j, typeA.equals(typeB));\n+\n+        // TODO(nicksantos): This formulation of least subtype and greatest\n+        // supertype is a bit loose. We might want to tighten it up later.\n+        if (i == j) {\n+          assertEquals(typeA, typeA.getLeastSupertype(typeB));\n+          assertEquals(typeA, typeA.getGreatestSubtype(typeB));\n+        } else {\n+          assertEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n+              U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n+          assertEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n+              NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tests that defining a property of a function's {@code prototype} adds the\n+   * property to it instance type.\n+   */\n+  public void testFunctionPrototypeAndImplicitPrototype1() {\n+    FunctionType constructor =\n+        registry.createConstructorType(null, null, null, null);\n+    ObjectType instance = constructor.getInstanceType();\n+\n+    // adding one property on the prototype\n+    ObjectType prototype =\n+        (ObjectType) constructor.getPropertyType(\"prototype\");\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false);\n+\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n+  }\n+\n+  /**\n+   * Tests that replacing a function's {@code prototype} changes the visible\n+   * properties of its instance type.\n+   */\n+  public void testFunctionPrototypeAndImplicitPrototype2() {\n+    FunctionType constructor =\n+        registry.createConstructorType(null, null, null, null);\n+    ObjectType instance = constructor.getInstanceType();\n+\n+    // replacing the prototype\n+    ObjectType prototype = registry.createAnonymousObjectType();\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false);\n+    constructor.defineDeclaredProperty(\"prototype\", prototype, true);\n+\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n+  }\n+\n+  /**\n+   * Tests that the native constructor U2U_CONSTRUCTOR_TYPE is properly\n+   * implemented.\n+   */\n+  public void testFunctionCyclycity() throws Exception {\n+    FunctionPrototypeType instanceType =\n+        new FunctionPrototypeType(\n+            registry, U2U_CONSTRUCTOR_TYPE,\n+            U2U_CONSTRUCTOR_TYPE.getInstanceType());\n+    U2U_CONSTRUCTOR_TYPE.setPrototype(instanceType);\n+    U2U_CONSTRUCTOR_TYPE.detectImplicitPrototypeCycle();\n+    instanceType.detectImplicitPrototypeCycle();\n+  }\n+\n+  /** Tests assigning jsdoc on a prototype property. */\n+  public void testJSDocOnPrototypeProperty() throws Exception {\n+    subclassCtor.setPropertyJSDocInfo(\"prototype\", new JSDocInfo(), true);\n+    assertNull(subclassCtor.getOwnPropertyJSDocInfo(\"prototype\"));\n+  }\n+\n+  /**\n+   * Tests the behavior of the void type.\n+   */\n+  public void testVoidType() throws Exception {\n+    // canAssignTo\n+    assertTrue(VOID_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(VOID_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canAssignTo(REGEXP_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(VOID_TYPE.autoboxesTo());\n+\n+    // canTestForEqualityWith\n+    assertTrue(VOID_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertFalse(VOID_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(VOID_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(VOID_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(VOID_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertTrue(VOID_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(VOID_TYPE.canTestForShallowEqualityWith(\n+            createUnionType(NUMBER_TYPE, VOID_TYPE)));\n+\n+    // matchesXxx\n+    assertFalse(VOID_TYPE.matchesInt32Context());\n+    assertFalse(VOID_TYPE.matchesNumberContext());\n+    assertFalse(VOID_TYPE.matchesObjectContext());\n+    assertTrue(VOID_TYPE.matchesStringContext());\n+    assertFalse(VOID_TYPE.matchesUint32Context());\n+  }\n+\n+  /**\n+   * Tests the behavior of the boolean type.\n+   */\n+  public void testBooleanValueType() throws Exception {\n+    // isXxx\n+    assertFalse(BOOLEAN_TYPE.isArrayType());\n+    assertFalse(BOOLEAN_TYPE.isBooleanObjectType());\n+    assertTrue(BOOLEAN_TYPE.isBooleanValueType());\n+    assertFalse(BOOLEAN_TYPE.isDateType());\n+    assertFalse(BOOLEAN_TYPE.isEnumElementType());\n+    assertFalse(BOOLEAN_TYPE.isNamedType());\n+    assertFalse(BOOLEAN_TYPE.isNullType());\n+    assertFalse(BOOLEAN_TYPE.isNumberObjectType());\n+    assertFalse(BOOLEAN_TYPE.isNumberValueType());\n+    assertFalse(BOOLEAN_TYPE.isFunctionPrototypeType());\n+    assertFalse(BOOLEAN_TYPE.isRegexpType());\n+    assertFalse(BOOLEAN_TYPE.isStringObjectType());\n+    assertFalse(BOOLEAN_TYPE.isStringValueType());\n+    assertFalse(BOOLEAN_TYPE.isEnumType());\n+    assertFalse(BOOLEAN_TYPE.isUnionType());\n+    assertFalse(BOOLEAN_TYPE.isAllType());\n+    assertFalse(BOOLEAN_TYPE.isVoidType());\n+    assertFalse(BOOLEAN_TYPE.isConstructor());\n+    assertFalse(BOOLEAN_TYPE.isInstanceType());\n+\n+    // autoboxesTo\n+    assertEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo());\n+\n+    // unboxesTo\n+    assertEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo());\n+\n+    // canAssignTo\n+    assertTrue(BOOLEAN_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(functionType));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(namedGoogBar));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(REGEXP_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(BOOLEAN_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(BOOLEAN_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForEqualityWith(UNKNOWN_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertFalse(BOOLEAN_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(functionType));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE));\n+\n+    // isNullable\n+    assertFalse(BOOLEAN_TYPE.isNullable());\n+\n+    // matchesXxx\n+    assertTrue(BOOLEAN_TYPE.matchesInt32Context());\n+    assertTrue(BOOLEAN_TYPE.matchesNumberContext());\n+    assertTrue(BOOLEAN_TYPE.matchesObjectContext());\n+    assertTrue(BOOLEAN_TYPE.matchesStringContext());\n+    assertTrue(BOOLEAN_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"boolean\", BOOLEAN_TYPE.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the Boolean type.\n+   */\n+  public void testBooleanObjectType() throws Exception {\n+    // isXxx\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isArrayType());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isBooleanObjectType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isBooleanValueType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isDateType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isEnumElementType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isNamedType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isNullType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isNumberObjectType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isNumberValueType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isFunctionPrototypeType());\n+    assertTrue(\n+        BOOLEAN_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isRegexpType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isStringObjectType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isStringValueType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isEnumType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isUnionType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isAllType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isVoidType());\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isConstructor());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isInstanceType());\n+\n+    // canAssignTo\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(functionType));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(NULL_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(DATE_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canAssignTo(unresolvedNamedType));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(namedGoogBar));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canAssignTo(REGEXP_TYPE));\n+    // canBeCalled\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(functionType));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(functionType));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isNullable());\n+\n+    // matchesXxx\n+    assertTrue(BOOLEAN_OBJECT_TYPE.matchesInt32Context());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.matchesNumberContext());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.matchesObjectContext());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.matchesStringContext());\n+    assertTrue(BOOLEAN_OBJECT_TYPE.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Boolean\", BOOLEAN_OBJECT_TYPE.toString());\n+\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the behavior of the enum type.\n+   */\n+  public void testEnumType() throws Exception {\n+    EnumType enumType = new EnumType(registry, \"Enum\", NUMBER_TYPE);\n+\n+    // isXxx\n+    assertFalse(enumType.isArrayType());\n+    assertFalse(enumType.isBooleanObjectType());\n+    assertFalse(enumType.isBooleanValueType());\n+    assertFalse(enumType.isDateType());\n+    assertFalse(enumType.isEnumElementType());\n+    assertFalse(enumType.isNamedType());\n+    assertFalse(enumType.isNullType());\n+    assertFalse(enumType.isNumberObjectType());\n+    assertFalse(enumType.isNumberValueType());\n+    assertFalse(enumType.isFunctionPrototypeType());\n+    assertFalse(enumType.isRegexpType());\n+    assertFalse(enumType.isStringObjectType());\n+    assertFalse(enumType.isStringValueType());\n+    assertTrue(enumType.isEnumType());\n+    assertFalse(enumType.isUnionType());\n+    assertFalse(enumType.isAllType());\n+    assertFalse(enumType.isVoidType());\n+    assertFalse(enumType.isConstructor());\n+    assertFalse(enumType.isInstanceType());\n+\n+    // canAssignTo\n+    assertTrue(enumType.canAssignTo(ALL_TYPE));\n+    assertFalse(enumType.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(enumType.canAssignTo(NUMBER_TYPE));\n+    assertFalse(enumType.canAssignTo(functionType));\n+    assertFalse(enumType.canAssignTo(NULL_TYPE));\n+    assertTrue(enumType.canAssignTo(OBJECT_TYPE));\n+    assertFalse(enumType.canAssignTo(DATE_TYPE));\n+    assertTrue(enumType.canAssignTo(unresolvedNamedType));\n+    assertFalse(enumType.canAssignTo(namedGoogBar));\n+    assertFalse(enumType.canAssignTo(REGEXP_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(enumType.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(enumType.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(functionType));\n+    assertFalse(enumType.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(enumType.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(enumType.canTestForShallowEqualityWith(NO_TYPE));\n+    assertTrue(enumType.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(enumType.\n+        canTestForShallowEqualityWith(enumType));\n+    assertFalse(enumType.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(functionType));\n+    assertFalse(enumType.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(enumType.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(enumType.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(enumType.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(enumType.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(enumType.isNullable());\n+\n+    // matchesXxx\n+    assertFalse(enumType.matchesInt32Context());\n+    assertFalse(enumType.matchesNumberContext());\n+    assertTrue(enumType.matchesObjectContext());\n+    assertTrue(enumType.matchesStringContext());\n+    assertFalse(enumType.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"enum{Enum}\", enumType.toString());\n+  }\n+\n+  /**\n+   * Tests the behavior of the enum element type.\n+   */\n+  public void testEnumElementType() throws Exception {\n+    // isXxx\n+    assertFalse(elementsType.isArrayType());\n+    assertFalse(elementsType.isBooleanObjectType());\n+    assertFalse(elementsType.isBooleanValueType());\n+    assertFalse(elementsType.isDateType());\n+    assertTrue(elementsType.isEnumElementType());\n+    assertFalse(elementsType.isNamedType());\n+    assertFalse(elementsType.isNullType());\n+    assertFalse(elementsType.isNumberObjectType());\n+    assertFalse(elementsType.isNumberValueType());\n+    assertFalse(elementsType.isFunctionPrototypeType());\n+    assertFalse(elementsType.isRegexpType());\n+    assertFalse(elementsType.isStringObjectType());\n+    assertFalse(elementsType.isStringValueType());\n+    assertFalse(elementsType.isEnumType());\n+    assertFalse(elementsType.isUnionType());\n+    assertFalse(elementsType.isAllType());\n+    assertFalse(elementsType.isVoidType());\n+    assertFalse(elementsType.isConstructor());\n+    assertFalse(elementsType.isInstanceType());\n+\n+    // canAssignTo\n+    assertTrue(elementsType.canAssignTo(ALL_TYPE));\n+    assertFalse(elementsType.canAssignTo(STRING_OBJECT_TYPE));\n+    assertTrue(elementsType.canAssignTo(NUMBER_TYPE));\n+    assertFalse(elementsType.canAssignTo(functionType));\n+    assertFalse(elementsType.canAssignTo(NULL_TYPE));\n+    assertTrue(elementsType.canAssignTo(OBJECT_TYPE)); // autoboxing\n+    assertFalse(elementsType.canAssignTo(DATE_TYPE));\n+    assertTrue(elementsType.canAssignTo(unresolvedNamedType));\n+    assertFalse(elementsType.canAssignTo(namedGoogBar));\n+    assertFalse(elementsType.canAssignTo(REGEXP_TYPE));\n+\n+    // canBeCalled\n+    assertFalse(elementsType.canBeCalled());\n+\n+    // canTestForEqualityWith\n+    assertTrue(elementsType.canTestForEqualityWith(ALL_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(STRING_OBJECT_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(NUMBER_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(elementsType));\n+    assertTrue(elementsType.canTestForEqualityWith(functionType));\n+    assertFalse(elementsType.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(OBJECT_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(DATE_TYPE));\n+    assertTrue(elementsType.canTestForEqualityWith(REGEXP_TYPE));\n+\n+    // canTestForShallowEqualityWith\n+    assertTrue(elementsType.canTestForShallowEqualityWith(NO_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(NO_OBJECT_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(ARRAY_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(BOOLEAN_TYPE));\n+    assertTrue(elementsType.\n+        canTestForShallowEqualityWith(elementsType));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(DATE_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(ERROR_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(EVAL_ERROR_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(functionType));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(NULL_TYPE));\n+    assertTrue(elementsType.canTestForShallowEqualityWith(NUMBER_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(OBJECT_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(URI_ERROR_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(RANGE_ERROR_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(REGEXP_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(STRING_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(STRING_OBJECT_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n+    assertFalse(elementsType.\n+        canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n+    assertTrue(elementsType.canTestForShallowEqualityWith(ALL_TYPE));\n+    assertFalse(elementsType.canTestForShallowEqualityWith(VOID_TYPE));\n+\n+    // isNullable\n+    assertFalse(elementsType.isNullable());\n+\n+    // matchesXxx\n+    assertTrue(elementsType.matchesInt32Context());\n+    assertTrue(elementsType.matchesNumberContext());\n+    assertTrue(elementsType.matchesObjectContext());\n+    assertTrue(elementsType.matchesStringContext());\n+    assertTrue(elementsType.matchesUint32Context());\n+\n+    // toString\n+    assertEquals(\"Enum.<number>\", elementsType.toString());\n+  }\n+\n+  public void testStringEnumType() throws Exception {\n+    EnumElementType stringEnum =\n+        new EnumType(registry, \"Enum\", STRING_TYPE).getElementsType();\n+\n+    assertEquals(UNKNOWN_TYPE, stringEnum.getPropertyType(\"length\"));\n+    assertEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n+    assertEquals(false, stringEnum.hasProperty(\"length\"));\n+    assertEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo());\n+    assertNull(stringEnum.getConstructor());\n+  }\n+\n+  public void testStringObjectEnumType() throws Exception {\n+    EnumElementType stringEnum =\n+        new EnumType(registry, \"Enum\", STRING_OBJECT_TYPE).getElementsType();\n+\n+    assertEquals(NUMBER_TYPE, stringEnum.getPropertyType(\"length\"));\n+    assertEquals(NUMBER_TYPE, stringEnum.findPropertyType(\"length\"));\n+    assertEquals(true, stringEnum.hasProperty(\"length\"));\n+    assertEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor());\n+  }\n+\n+  /**\n+   * Tests the behavior of variants type.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testUnionType() throws Exception {\n+    UnionType nullOrString =\n+        (UnionType) createUnionType(NULL_TYPE, STRING_OBJECT_TYPE);\n+    UnionType stringOrNull =\n+        (UnionType) createUnionType(STRING_OBJECT_TYPE, NULL_TYPE);\n+\n+    assertEquals(nullOrString, stringOrNull);\n+    assertEquals(stringOrNull, nullOrString);\n+\n+    assertTypeCanAssignToItself(createUnionType(VOID_TYPE, NUMBER_TYPE));\n+    assertTypeCanAssignToItself(\n+        createUnionType(NUMBER_TYPE, STRING_TYPE, OBJECT_TYPE));\n+    assertTypeCanAssignToItself(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE));\n+    assertTypeCanAssignToItself(createUnionType(VOID_TYPE));\n+\n+    UnionType nullOrUnknown =\n+        (UnionType) createUnionType(NULL_TYPE, unresolvedNamedType);\n+    assertTrue(nullOrUnknown.isUnknownType());\n+    assertEquals(nullOrUnknown, NULL_TYPE.getLeastSupertype(nullOrUnknown));\n+    assertEquals(nullOrUnknown, nullOrUnknown.getLeastSupertype(NULL_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        NULL_TYPE.getGreatestSubtype(nullOrUnknown));\n+    assertEquals(UNKNOWN_TYPE,\n+        nullOrUnknown.getGreatestSubtype(NULL_TYPE));\n+\n+    assertTrue(NULL_TYPE.differsFrom(nullOrUnknown));\n+    assertTrue(nullOrUnknown.differsFrom(NULL_TYPE));\n+    assertFalse(nullOrUnknown.differsFrom(unresolvedNamedType));\n+\n+    assertTrue(NULL_TYPE.isSubtype(nullOrUnknown));\n+    assertTrue(unresolvedNamedType.isSubtype(nullOrUnknown));\n+    assertTrue(nullOrUnknown.isSubtype(NULL_TYPE));\n+\n+    assertEquals(unresolvedNamedType,\n+        nullOrUnknown.restrictByNotNullOrUndefined());\n+\n+    // findPropertyType\n+    assertEquals(NUMBER_TYPE, nullOrString.findPropertyType(\"length\"));\n+    assertEquals(null, nullOrString.findPropertyType(\"lengthx\"));\n+  }\n+\n+  /**\n+   * Tests object types.\n+   */\n+  public void testObjectType() throws Exception {\n+    PrototypeObjectType objectType =\n+        new PrototypeObjectType(registry, null, null);\n+\n+    // isXxx\n+    assertFalse(objectType.isAllType());\n+    assertFalse(objectType.isArrayType());\n+    assertFalse(objectType.isDateType());\n+    assertFalse(objectType.isFunctionPrototypeType());\n+    assertTrue(objectType.getImplicitPrototype() == OBJECT_TYPE);\n+\n+    // canAssignTo\n+    assertTrue(objectType.canAssignTo(ALL_TYPE));\n+    assertFalse(objectType.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(objectType.canAssignTo(NUMBER_TYPE));\n+    assertFalse(objectType.canAssignTo(functionType));\n+    assertFalse(objectType.canAssignTo(NULL_TYPE));\n+    assertFalse(objectType.canAssignTo(DATE_TYPE));\n+    assertTrue(objectType.canAssignTo(OBJECT_TYPE));\n+    assertTrue(objectType.canAssignTo(unresolvedNamedType));\n+    assertFalse(objectType.canAssignTo(namedGoogBar));\n+    assertFalse(objectType.canAssignTo(REGEXP_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(objectType.autoboxesTo());\n+\n+    // canTestForEqualityWith\n+    assertTrue(objectType.canTestForEqualityWith(NUMBER_TYPE));\n+\n+    // matchesXxxContext\n+    assertFalse(objectType.matchesInt32Context());\n+    assertFalse(objectType.matchesNumberContext());\n+    assertTrue(objectType.matchesObjectContext());\n+    assertFalse(objectType.matchesStringContext());\n+    assertFalse(objectType.matchesUint32Context());\n+\n+    // isNullable\n+    assertFalse(objectType.isNullable());\n+    assertTrue(createNullableType(objectType).isNullable());\n+\n+    // toString\n+    assertEquals(\"{...}\", objectType.toString());\n+  }\n+\n+  /**\n+   * Tests the goog.Bar type.\n+   */\n+  public void testGoogBar() throws Exception {\n+    assertTrue(namedGoogBar.isInstanceType());\n+    assertFalse(googBar.isInstanceType());\n+    assertFalse(namedGoogBar.isConstructor());\n+    assertTrue(googBar.isConstructor());\n+    assertTrue(googBar.getInstanceType().isInstanceType());\n+    assertTrue(namedGoogBar.getConstructor().isConstructor());\n+    assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType());\n+\n+    // canAssignTo\n+    assertTypeCanAssignToItself(googBar);\n+    assertTypeCanAssignToItself(namedGoogBar);\n+    googBar.canAssignTo(namedGoogBar);\n+    namedGoogBar.canAssignTo(googBar);\n+    assertTrue(googBar.equals(googBar));\n+    assertFalse(googBar.equals(googSubBar));\n+  }\n+\n+  /**\n+   * Tests how properties are counted for object types.\n+   */\n+  public void testObjectTypePropertiesCount() throws Exception {\n+    ObjectType sup = registry.createAnonymousObjectType();\n+    int nativeProperties = sup.getPropertiesCount();\n+\n+    sup.defineDeclaredProperty(\"a\", DATE_TYPE, false);\n+    assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n+\n+    sup.defineDeclaredProperty(\"b\", DATE_TYPE, false);\n+    assertEquals(nativeProperties + 2, sup.getPropertiesCount());\n+\n+    ObjectType sub = registry.createObjectType(sup);\n+    assertEquals(nativeProperties + 2, sub.getPropertiesCount());\n+  }\n+\n+  /**\n+   * Tests how properties are defined.\n+   */\n+  public void testDefineProperties() {\n+    ObjectType prototype = googBar.getPrototype();\n+    ObjectType instance = googBar.getInstanceType();\n+\n+    assertEquals(instance.getImplicitPrototype(), prototype);\n+\n+    // Test declarations.\n+    assertTrue(\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+    assertFalse(\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+    assertFalse(\n+        instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+    assertEquals(NUMBER_TYPE, instance.getPropertyType(\"declared\"));\n+\n+    // Test inferring different types.\n+    assertTrue(\n+        prototype.defineInferredProperty(\"inferred1\", STRING_TYPE, false));\n+    assertTrue(\n+        prototype.defineInferredProperty(\"inferred1\", NUMBER_TYPE, false));\n+    assertEquals(\n+        createUnionType(NUMBER_TYPE, STRING_TYPE),\n+        instance.getPropertyType(\"inferred1\"));\n+\n+    // Test inferring different types on different objects.\n+    assertTrue(\n+        prototype.defineInferredProperty(\"inferred2\", STRING_TYPE, false));\n+    assertTrue(\n+        instance.defineInferredProperty(\"inferred2\", NUMBER_TYPE, false));\n+    assertEquals(\n+        createUnionType(NUMBER_TYPE, STRING_TYPE),\n+        instance.getPropertyType(\"inferred2\"));\n+\n+    // Test inferring on the supertype and declaring on the subtype.\n+    assertTrue(\n+        prototype.defineInferredProperty(\"prop\", STRING_TYPE, false));\n+    assertTrue(\n+        instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, false));\n+    assertEquals(NUMBER_TYPE, instance.getPropertyType(\"prop\"));\n+    assertEquals(STRING_TYPE, prototype.getPropertyType(\"prop\"));\n+  }\n+\n+  /**\n+   * Tests that properties are correctly counted even when shadowing occurs.\n+   */\n+  public void testObjectTypePropertiesCountWithShadowing() {\n+    ObjectType sup = registry.createAnonymousObjectType();\n+    int nativeProperties = sup.getPropertiesCount();\n+\n+    sup.defineDeclaredProperty(\"a\", OBJECT_TYPE, false);\n+    assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n+\n+    ObjectType sub = registry.createObjectType(sup);\n+    sub.defineDeclaredProperty(\"a\", OBJECT_TYPE, false);\n+    assertEquals(nativeProperties + 1, sub.getPropertiesCount());\n+  }\n+\n+  public void testObjectTypeIsPropertyInExterns() {\n+    ObjectType sup =\n+        registry.createObjectType(registry.createAnonymousObjectType());\n+    ObjectType sub = registry.createObjectType(sup);\n+\n+    sup.defineProperty(\"externProp\", null, false, /* inExterns */ true);\n+    sub.defineProperty(\"externProp\", null, false, /* inExterns */ false);\n+\n+    assertTrue(sup.isPropertyInExterns(\"externProp\"));\n+    assertFalse(sub.isPropertyInExterns(\"externProp\"));\n+  }\n+\n+  /**\n+   * Tests the named type goog.Bar.\n+   */\n+  public void testNamedGoogBar() throws Exception {\n+    // isXxx\n+    assertFalse(namedGoogBar.isFunctionPrototypeType());\n+    assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType());\n+\n+    // canAssignTo\n+    assertTrue(namedGoogBar.canAssignTo(ALL_TYPE));\n+    assertFalse(namedGoogBar.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(namedGoogBar.canAssignTo(NUMBER_TYPE));\n+    assertFalse(namedGoogBar.canAssignTo(functionType));\n+    assertFalse(namedGoogBar.canAssignTo(NULL_TYPE));\n+    assertTrue(namedGoogBar.canAssignTo(OBJECT_TYPE));\n+    assertFalse(namedGoogBar.canAssignTo(DATE_TYPE));\n+    assertTrue(namedGoogBar.canAssignTo(namedGoogBar));\n+    assertTrue(namedGoogBar.canAssignTo(unresolvedNamedType));\n+    assertFalse(namedGoogBar.canAssignTo(REGEXP_TYPE));\n+    assertFalse(namedGoogBar.canAssignTo(ARRAY_TYPE));\n+\n+    // autoboxesTo\n+    assertNull(namedGoogBar.autoboxesTo());\n+\n+    // properties\n+    assertEquals(DATE_TYPE, namedGoogBar.getPropertyType(\"date\"));\n+\n+    assertFalse(namedGoogBar.isNativeObjectType());\n+    assertFalse(namedGoogBar.getImplicitPrototype().isNativeObjectType());\n+  }\n+\n+  /**\n+   * Tests the prototype chaining of native objects.\n+   */\n+  public void testPrototypeChaining() throws Exception {\n+    // equals\n+    assertEquals(ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        OBJECT_TYPE);\n+    assertEquals(BOOLEAN_OBJECT_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), OBJECT_TYPE);\n+    assertEquals(DATE_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        OBJECT_TYPE);\n+    assertEquals(ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        OBJECT_TYPE);\n+    assertEquals(EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        ERROR_TYPE);\n+    assertEquals(NUMBER_OBJECT_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), OBJECT_TYPE);\n+    assertEquals(URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        ERROR_TYPE);\n+    assertEquals(RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        ERROR_TYPE);\n+    assertEquals(REFERENCE_ERROR_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), ERROR_TYPE);\n+    assertEquals(STRING_OBJECT_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), OBJECT_TYPE);\n+    assertEquals(REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(),\n+        OBJECT_TYPE);\n+    assertEquals(SYNTAX_ERROR_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), ERROR_TYPE);\n+    assertEquals(TYPE_ERROR_TYPE.getImplicitPrototype().\n+        getImplicitPrototype(), ERROR_TYPE);\n+\n+    // not same\n+    assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(),\n+        URI_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(),\n+        RANGE_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(),\n+        REFERENCE_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(),\n+        SYNTAX_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(),\n+        TYPE_ERROR_TYPE.getImplicitPrototype());\n+\n+    assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(),\n+        RANGE_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(),\n+        REFERENCE_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(),\n+        SYNTAX_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(),\n+        TYPE_ERROR_TYPE.getImplicitPrototype());\n+\n+    assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(),\n+        REFERENCE_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(),\n+        SYNTAX_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(),\n+        TYPE_ERROR_TYPE.getImplicitPrototype());\n+\n+    assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(),\n+        SYNTAX_ERROR_TYPE.getImplicitPrototype());\n+    assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(),\n+        TYPE_ERROR_TYPE.getImplicitPrototype());\n+\n+    assertNotSame(SYNTAX_ERROR_TYPE.getImplicitPrototype(),\n+        TYPE_ERROR_TYPE.getImplicitPrototype());\n+  }\n+\n+  /**\n+   * Tests that function instances have their constructor pointer back at the\n+   * function that created them.\n+   */\n+  public void testInstanceFunctionChaining() throws Exception {\n+    // Array\n+    assertEquals(ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor());\n+\n+    // Boolean\n+    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n+        BOOLEAN_OBJECT_TYPE.getConstructor());\n+\n+    // Date\n+    assertEquals(DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor());\n+\n+    // Error\n+    assertEquals(ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor());\n+\n+    // EvalError\n+    assertEquals(EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor());\n+\n+    // Number\n+    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n+        NUMBER_OBJECT_TYPE.getConstructor());\n+\n+    // Object\n+    assertEquals(OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor());\n+\n+    // RangeError\n+    assertEquals(RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor());\n+\n+    // ReferenceError\n+    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n+        REFERENCE_ERROR_TYPE.getConstructor());\n+\n+    // RegExp\n+    assertEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor());\n+\n+    // String\n+    assertEquals(STRING_OBJECT_FUNCTION_TYPE,\n+        STRING_OBJECT_TYPE.getConstructor());\n+\n+    // SyntaxError\n+    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n+        SYNTAX_ERROR_TYPE.getConstructor());\n+\n+    // TypeError\n+    assertEquals(TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor());\n+\n+    // URIError\n+    assertEquals(URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor());\n+  }\n+\n+  /**\n+   * Tests that the method {@link JSType#canTestForEqualityWith(JSType)} handles\n+   * special corner cases.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testCanTestForEqualityWithCornerCases() {\n+    // null == undefined is always true\n+    assertFalse(NULL_TYPE.canTestForEqualityWith(VOID_TYPE));\n+\n+    // (Object,null) == undefined could be true or false\n+    UnionType nullableObject =\n+        (UnionType) createUnionType(OBJECT_TYPE, NULL_TYPE);\n+    assertTrue(nullableObject.canTestForEqualityWith(VOID_TYPE));\n+    assertTrue(VOID_TYPE.canTestForEqualityWith(nullableObject));\n+  }\n+\n+  /**\n+   * Tests the {@link JSType#testForEquality(JSType)} method.\n+   */\n+  public void testTestForEquality() {\n+    compare(TRUE, NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n+    compare(UNKNOWN, ALL_TYPE, ALL_TYPE);\n+    compare(TRUE, NO_TYPE, NO_TYPE);\n+    compare(UNKNOWN, NO_OBJECT_TYPE, NUMBER_TYPE);\n+    compare(UNKNOWN, ALL_TYPE, NUMBER_TYPE);\n+    compare(UNKNOWN, NO_TYPE, NUMBER_TYPE);\n+\n+    compare(FALSE, NULL_TYPE, BOOLEAN_TYPE);\n+    compare(TRUE, NULL_TYPE, NULL_TYPE);\n+    compare(FALSE, NULL_TYPE, NUMBER_TYPE);\n+    compare(FALSE, NULL_TYPE, OBJECT_TYPE);\n+    compare(FALSE, NULL_TYPE, STRING_TYPE);\n+    compare(TRUE, NULL_TYPE, VOID_TYPE);\n+    compare(UNKNOWN, NULL_TYPE, createUnionType(UNKNOWN_TYPE, VOID_TYPE));\n+    compare(UNKNOWN, NULL_TYPE, createUnionType(OBJECT_TYPE, VOID_TYPE));\n+    compare(UNKNOWN, NULL_TYPE, unresolvedNamedType);\n+    compare(UNKNOWN,\n+        NULL_TYPE, createUnionType(unresolvedNamedType, DATE_TYPE));\n+\n+    compare(FALSE, VOID_TYPE, REGEXP_TYPE);\n+    compare(TRUE, VOID_TYPE, VOID_TYPE);\n+    compare(UNKNOWN, VOID_TYPE, createUnionType(REGEXP_TYPE, VOID_TYPE));\n+\n+    compare(UNKNOWN, NUMBER_TYPE, BOOLEAN_TYPE);\n+    compare(UNKNOWN, NUMBER_TYPE, NUMBER_TYPE);\n+    compare(UNKNOWN, NUMBER_TYPE, OBJECT_TYPE);\n+\n+    compare(UNKNOWN, ARRAY_TYPE, BOOLEAN_TYPE);\n+    compare(UNKNOWN, OBJECT_TYPE, BOOLEAN_TYPE);\n+    compare(UNKNOWN, OBJECT_TYPE, STRING_TYPE);\n+\n+    compare(UNKNOWN, STRING_TYPE, STRING_TYPE);\n+\n+    compare(UNKNOWN, STRING_TYPE, BOOLEAN_TYPE);\n+    compare(UNKNOWN, STRING_TYPE, NUMBER_TYPE);\n+    compare(FALSE, STRING_TYPE, VOID_TYPE);\n+    compare(FALSE, STRING_TYPE, NULL_TYPE);\n+    compare(FALSE, STRING_TYPE, createUnionType(NULL_TYPE, VOID_TYPE));\n+\n+    compare(UNKNOWN, UNKNOWN_TYPE, BOOLEAN_TYPE);\n+    compare(UNKNOWN, UNKNOWN_TYPE, NULL_TYPE);\n+    compare(UNKNOWN, UNKNOWN_TYPE, VOID_TYPE);\n+  }\n+\n+  private void compare(TernaryValue r, JSType t1, JSType t2) {\n+    assertEquals(r, t1.testForEquality(t2));\n+    assertEquals(r, t2.testForEquality(t1));\n+  }\n+\n+  /**\n+   * Tests the subtyping relationships among simple types.\n+   */\n+  public void testSubtypingSimpleTypes() throws Exception {\n+    // Any\n+    assertTrue(NO_TYPE.isSubtype(NO_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(ARRAY_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(DATE_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(functionType));\n+    assertTrue(NO_TYPE.isSubtype(NULL_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(NUMBER_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(OBJECT_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(REGEXP_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(STRING_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(ALL_TYPE));\n+    assertTrue(NO_TYPE.isSubtype(VOID_TYPE));\n+\n+    // AnyObject\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(NO_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(DATE_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(functionType));\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(NUMBER_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(STRING_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(NO_OBJECT_TYPE.isSubtype(VOID_TYPE));\n+\n+    // Array\n+    assertFalse(ARRAY_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(DATE_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(functionType));\n+    assertFalse(ARRAY_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(ARRAY_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(ARRAY_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(ARRAY_TYPE.isSubtype(VOID_TYPE));\n+\n+    // boolean\n+    assertFalse(BOOLEAN_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(ARRAY_TYPE));\n+    assertTrue(BOOLEAN_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(DATE_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(functionType));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(BOOLEAN_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.isSubtype(VOID_TYPE));\n+\n+    // Boolean\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(DATE_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(functionType));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(VOID_TYPE));\n+\n+    // Date\n+    assertFalse(DATE_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.isSubtype(DATE_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(functionType));\n+    assertFalse(DATE_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(DATE_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(DATE_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(DATE_TYPE.isSubtype(VOID_TYPE));\n+\n+    // Error\n+    assertFalse(ERROR_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE));\n+    assertTrue(ERROR_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(functionType));\n+    assertFalse(ERROR_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(ERROR_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(ERROR_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(VOID_TYPE));\n+\n+    // EvalError\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE));\n+    assertTrue(EVAL_ERROR_TYPE.isSubtype(ERROR_TYPE));\n+    assertTrue(EVAL_ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(functionType));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertTrue(EVAL_ERROR_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(EVAL_ERROR_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(EVAL_ERROR_TYPE.isSubtype(VOID_TYPE));\n+\n+    // RangeError\n+    assertTrue(RANGE_ERROR_TYPE.isSubtype(ERROR_TYPE));\n+\n+    // ReferenceError\n+    assertTrue(REFERENCE_ERROR_TYPE.isSubtype(ERROR_TYPE));\n+\n+    // TypeError\n+    assertTrue(TYPE_ERROR_TYPE.isSubtype(ERROR_TYPE));\n+\n+    // UriError\n+    assertTrue(URI_ERROR_TYPE.isSubtype(ERROR_TYPE));\n+\n+    // Unknown\n+    assertFalse(ALL_TYPE.isSubtype(NO_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(ARRAY_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(BOOLEAN_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(EVAL_ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(functionType));\n+    assertFalse(ALL_TYPE.isSubtype(NULL_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(NUMBER_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(NUMBER_OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(URI_ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(RANGE_ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(REFERENCE_ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(REGEXP_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(STRING_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(STRING_OBJECT_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(SYNTAX_ERROR_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(TYPE_ERROR_TYPE));\n+    assertTrue(ALL_TYPE.isSubtype(ALL_TYPE));\n+    assertFalse(ALL_TYPE.isSubtype(VOID_TYPE));\n+  }\n+\n+  /**\n+   * Tests subtyping of union types.\n+   */\n+  public void testSubtypingUnionTypes() throws Exception {\n+    // subtypes\n+    assertTrue(BOOLEAN_TYPE.\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE)));\n+    assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE).\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE)));\n+    assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE).\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE)));\n+    assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE).\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE)));\n+    assertTrue(createUnionType(BOOLEAN_TYPE).\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE)));\n+    assertTrue(createUnionType(STRING_TYPE).\n+        isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE)));\n+    assertTrue(createUnionType(STRING_TYPE, NULL_TYPE).isSubtype(ALL_TYPE));\n+    assertTrue(createUnionType(DATE_TYPE, REGEXP_TYPE).isSubtype(OBJECT_TYPE));\n+    assertTrue(createUnionType(URI_ERROR_TYPE, EVAL_ERROR_TYPE).\n+        isSubtype(ERROR_TYPE));\n+    assertTrue(createUnionType(URI_ERROR_TYPE, EVAL_ERROR_TYPE).\n+        isSubtype(OBJECT_TYPE));\n+\n+    // not subtypes\n+    assertFalse(createUnionType(STRING_TYPE, NULL_TYPE).isSubtype(NO_TYPE));\n+    assertFalse(createUnionType(STRING_TYPE, NULL_TYPE).\n+        isSubtype(NO_OBJECT_TYPE));\n+    assertFalse(createUnionType(NO_OBJECT_TYPE, NULL_TYPE).\n+        isSubtype(OBJECT_TYPE));\n+\n+    // defined unions\n+    assertTrue(NUMBER_TYPE.isSubtype(OBJECT_NUMBER_STRING));\n+    assertTrue(OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING));\n+    assertTrue(STRING_TYPE.isSubtype(OBJECT_NUMBER_STRING));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING));\n+\n+    assertTrue(NUMBER_TYPE.isSubtype(NUMBER_STRING_BOOLEAN));\n+    assertTrue(BOOLEAN_TYPE.isSubtype(NUMBER_STRING_BOOLEAN));\n+    assertTrue(STRING_TYPE.isSubtype(NUMBER_STRING_BOOLEAN));\n+\n+    assertTrue(NUMBER_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN));\n+    assertTrue(OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN));\n+    assertTrue(STRING_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN));\n+    assertTrue(BOOLEAN_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN));\n+    assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN));\n+  }\n+\n+  /**\n+   * Tests that the Object type is the greatest element (top) of the object\n+   * hierarchy.\n+   */\n+  public void testSubtypingObjectTopOfObjects() throws Exception {\n+    assertTrue(OBJECT_TYPE.isSubtype(OBJECT_TYPE));\n+    assertTrue(createUnionType(DATE_TYPE, REGEXP_TYPE).isSubtype(OBJECT_TYPE));\n+    assertTrue(createUnionType(OBJECT_TYPE, NO_OBJECT_TYPE).\n+        isSubtype(OBJECT_TYPE));\n+    assertTrue(functionType.isSubtype(OBJECT_TYPE));\n+  }\n+\n+  public void testSubtypingFunctionPrototypeType() throws Exception {\n+    FunctionType sub1 = registry.createConstructorType(null, null, null, null);\n+    sub1.setPrototypeBasedOn(googBar);\n+    FunctionType sub2 = registry.createConstructorType(null, null, null, null);\n+    sub2.setPrototypeBasedOn(googBar);\n+\n+    ObjectType o1 = sub1.getInstanceType();\n+    ObjectType o2 = sub2.getInstanceType();\n+\n+    assertFalse(o1.isSubtype(o2));\n+    assertFalse(o1.getImplicitPrototype().isSubtype(o2.getImplicitPrototype()));\n+    assertTrue(o1.getImplicitPrototype().isSubtype(googBar));\n+    assertTrue(o2.getImplicitPrototype().isSubtype(googBar));\n+  }\n+\n+  public void testSubtypingFunctionFixedArgs() throws Exception {\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        false, BOOLEAN_TYPE);\n+    FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        false, BOOLEAN_TYPE);\n+\n+    assertTrue(f1.isSubtype(f1));\n+    assertFalse(f1.isSubtype(f2));\n+    assertTrue(f2.isSubtype(f1));\n+    assertTrue(f2.isSubtype(f2));\n+\n+    assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2));\n+  }\n+\n+  public void testSubtypingFunctionMultipleFixedArgs() throws Exception {\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        false, EVAL_ERROR_TYPE, STRING_TYPE);\n+    FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        false, ERROR_TYPE, ALL_TYPE);\n+\n+    assertTrue(f1.isSubtype(f1));\n+    assertFalse(f1.isSubtype(f2));\n+    assertTrue(f2.isSubtype(f1));\n+    assertTrue(f2.isSubtype(f2));\n+\n+    assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2));\n+  }\n+\n+  public void testSubtypingFunctionFixedArgsNotMatching() throws Exception {\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        false, EVAL_ERROR_TYPE);\n+    FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        false, ERROR_TYPE, ALL_TYPE);\n+\n+    assertTrue(f1.isSubtype(f1));\n+    assertFalse(f1.isSubtype(f2));\n+    assertTrue(f2.isSubtype(f1));\n+    assertTrue(f2.isSubtype(f2));\n+\n+    assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2));\n+  }\n+\n+  public void testSubtypingFunctionVariableArgsOneOnly() throws Exception {\n+    // f1 = (EvalError...) -> Object\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        true, EVAL_ERROR_TYPE);\n+    // f2 = (Error, Object) -> String\n+    FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        false, ERROR_TYPE, OBJECT_TYPE);\n+\n+    assertTrue(f1.isSubtype(f1));\n+    assertFalse(f1.isSubtype(f2));\n+    assertFalse(f2.isSubtype(f1));\n+    assertTrue(f2.isSubtype(f2));\n+\n+    assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2));\n+  }\n+\n+  public void testSubtypingFunctionVariableArgsBoth() throws Exception {\n+    // f1 = (UriError, EvalError, EvalError...) -> Object\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        true,  URI_ERROR_TYPE, EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n+    // f2 = (Error, Object, EvalError...) -> String\n+    FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE);\n+\n+    assertTrue(f1.isSubtype(f1));\n+    assertFalse(f1.isSubtype(f2));\n+    assertTrue(f2.isSubtype(f1));\n+    assertTrue(f2.isSubtype(f2));\n+\n+    assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2));\n+  }\n+\n+  public void testSubtypingMostGeneralFunction() throws Exception {\n+    // (EvalError, String) -> Object\n+    FunctionType f1 = registry.createFunctionType(OBJECT_TYPE,\n+        false, EVAL_ERROR_TYPE, STRING_TYPE);\n+    // (string, void) -> number\n+    FunctionType f2 = registry.createFunctionType(NUMBER_TYPE,\n+        false, STRING_TYPE, VOID_TYPE);\n+    // (Date, string, number) -> AnyObject\n+    FunctionType f3 = registry.createFunctionType(NO_OBJECT_TYPE,\n+        false, DATE_TYPE, STRING_TYPE, NUMBER_TYPE);\n+    // (Number) -> Any\n+    FunctionType f4 = registry.createFunctionType(NO_TYPE,\n+        false, NUMBER_OBJECT_TYPE);\n+    // f1 = (EvalError...) -> Object\n+    FunctionType f5 = registry.createFunctionType(OBJECT_TYPE,\n+        true, EVAL_ERROR_TYPE);\n+    // f2 = (Error, Object) -> String\n+    FunctionType f6 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        false, ERROR_TYPE, OBJECT_TYPE);\n+    // f1 = (UriError, EvalError...) -> Object\n+    FunctionType f7 = registry.createFunctionType(OBJECT_TYPE,\n+        true,  URI_ERROR_TYPE, EVAL_ERROR_TYPE);\n+    // f2 = (Error, Object, EvalError...) -> String\n+    FunctionType f8 = registry.createFunctionType(STRING_OBJECT_TYPE,\n+        true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE);\n+\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(LEAST_FUNCTION_TYPE));\n+\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertTrue(GREATEST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(GREATEST_FUNCTION_TYPE));\n+\n+    assertTrue(f1.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f2.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f3.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f4.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f5.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f6.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f7.isSubtype(GREATEST_FUNCTION_TYPE));\n+    assertTrue(f8.isSubtype(GREATEST_FUNCTION_TYPE));\n+\n+    assertFalse(f1.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f2.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f3.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f4.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f5.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f6.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f7.isSubtype(LEAST_FUNCTION_TYPE));\n+    assertFalse(f8.isSubtype(LEAST_FUNCTION_TYPE));\n+\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f1));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f2));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f3));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f4));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f5));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f6));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f7));\n+    assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f8));\n+\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f1));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f2));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f3));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f4));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f5));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f6));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f7));\n+    assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f8));\n+  }\n+\n+  /**\n+   * Types to test for symmetrical relationships.\n+   */\n+  private List<JSType> getTypesToTestForSymmetry() {\n+    return Lists.newArrayList(\n+        UNKNOWN_TYPE,\n+        NULL_TYPE,\n+        VOID_TYPE,\n+        NUMBER_TYPE,\n+        STRING_TYPE,\n+        BOOLEAN_TYPE,\n+        OBJECT_TYPE,\n+        U2U_CONSTRUCTOR_TYPE,\n+        ALL_TYPE,\n+        NO_TYPE,\n+        NO_OBJECT_TYPE,\n+        createUnionType(BOOLEAN_TYPE, STRING_TYPE),\n+        createUnionType(NUMBER_TYPE, STRING_TYPE),\n+        createUnionType(NULL_TYPE, dateMethod),\n+        createUnionType(UNKNOWN_TYPE, dateMethod),\n+        createUnionType(namedGoogBar, dateMethod),\n+        enumType,\n+        elementsType,\n+        dateMethod,\n+        functionType,\n+        unresolvedNamedType,\n+        googBar,\n+        namedGoogBar,\n+        googBar.getInstanceType(),\n+        namedGoogBar,\n+        subclassOfUnresolvedNamedType,\n+        subclassCtor,\n+        recordType\n+                              );\n+  }\n+\n+  /**\n+   * Tests that getLeastSupertype is a symmetric relation.\n+   */\n+  public void testSymmetryOfLeastSupertype() {\n+    List<JSType> listA = getTypesToTestForSymmetry();\n+    List<JSType> listB = getTypesToTestForSymmetry();\n+    for (JSType typeA : listA) {\n+      for (JSType typeB : listB) {\n+        JSType aOnB = typeA.getLeastSupertype(typeB);\n+        JSType bOnA = typeB.getLeastSupertype(typeA);\n+\n+        // Use a custom assert message instead of the normal assertEquals,\n+        // to make it more helpful.\n+        assertTrue(\n+            String.format(\"getLeastSupertype not symmetrical:\\n\" +\n+                \"typeA: %s\\ntypeB: %s\\n\" +\n+                \"a.getLeastSupertype(b): %s\\n\" +\n+                \"b.getLeastSupertype(a): %s\\n\",\n+                typeA, typeB, aOnB, bOnA),\n+            aOnB.equals(bOnA));\n+      }\n+    }\n+  }\n+\n+  public void testWeirdBug() {\n+    assertFalse(googBar.equals(googBar.getInstanceType()));\n+    assertFalse(googBar.getInstanceType().equals(googBar));\n+    assertFalse(googBar.isSubtype(googBar.getInstanceType()));\n+    assertFalse(googBar.getInstanceType().isSubtype(googBar));\n+  }\n+\n+  /**\n+   * Tests that getGreatestSubtype is a symmetric relation.\n+   */\n+  public void testSymmetryOfGreatestSubtype() {\n+    List<JSType> listA = getTypesToTestForSymmetry();\n+    List<JSType> listB = getTypesToTestForSymmetry();\n+    for (JSType typeA : listA) {\n+      for (JSType typeB : listB) {\n+        JSType aOnB = typeA.getGreatestSubtype(typeB);\n+        JSType bOnA = typeB.getGreatestSubtype(typeA);\n+\n+        // Use a custom assert message instead of the normal assertEquals,\n+        // to make it more helpful.\n+        assertTrue(\n+            String.format(\"getGreatestSubtype not symmetrical:\\n\" +\n+                \"typeA: %s\\ntypeB: %s\\n\" +\n+                \"a.getGreatestSubtype(b): %s\\n\" +\n+                \"b.getGreatestSubtype(a): %s\\n\",\n+                typeA, typeB, aOnB, bOnA),\n+            aOnB.equals(bOnA));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tests that getLeastSupertype is a reflexive relation.\n+   */\n+  public void testReflexivityOfLeastSupertype() {\n+    List<JSType> list = getTypesToTestForSymmetry();\n+    for (JSType type : list) {\n+      assertEquals(\"getLeastSupertype not reflexive\",\n+          type, type.getLeastSupertype(type));\n+    }\n+  }\n+\n+  /**\n+   * Tests that getGreatestSubtype is a reflexive relation.\n+   */\n+  public void testReflexivityOfGreatestSubtype() {\n+    List<JSType> list = getTypesToTestForSymmetry();\n+    for (JSType type : list) {\n+      assertEquals(\"getGreatestSubtype not reflexive\",\n+          type, type.getGreatestSubtype(type));\n+    }\n+  }\n+\n+  /**\n+   * Tests {@link JSType#getLeastSupertype(JSType)} for unresolved named types.\n+   */\n+  public void testLeastSupertypeUnresolvedNamedType() {\n+    // (undefined,function(?):?) and ? unresolved named type\n+    JSType expected = registry.createUnionType(\n+        unresolvedNamedType, U2U_FUNCTION_TYPE);\n+    assertEquals(expected,\n+        unresolvedNamedType.getLeastSupertype(U2U_FUNCTION_TYPE));\n+    assertEquals(expected,\n+        U2U_FUNCTION_TYPE.getLeastSupertype(unresolvedNamedType));\n+    assertEquals(\"(function (...[?]): ?|not.resolved.named.type)\",\n+        expected.toString());\n+  }\n+\n+  public void testLeastSupertypeUnresolvedNamedType2() {\n+    JSType expected = registry.createUnionType(\n+        unresolvedNamedType, UNKNOWN_TYPE);\n+    assertEquals(expected,\n+        unresolvedNamedType.getLeastSupertype(UNKNOWN_TYPE));\n+    assertEquals(expected,\n+        UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType));\n+    assertEquals(UNKNOWN_TYPE, expected);\n+  }\n+\n+  public void testLeastSupertypeUnresolvedNamedType3() {\n+    JSType expected = registry.createUnionType(\n+        unresolvedNamedType, CHECKED_UNKNOWN_TYPE);\n+    assertEquals(expected,\n+        unresolvedNamedType.getLeastSupertype(CHECKED_UNKNOWN_TYPE));\n+    assertEquals(expected,\n+        CHECKED_UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType));\n+    assertEquals(CHECKED_UNKNOWN_TYPE, expected);\n+  }\n+\n+  /** Tests the subclass of an unresolve named type */\n+  public void testSubclassOfUnresolvedNamedType() {\n+    assertTrue(subclassOfUnresolvedNamedType.isUnknownType());\n+  }\n+\n+  /**\n+   * Tests the {@link NamedType#equals} function, which had a bug in it.\n+   */\n+  public void testNamedTypeEquals() {\n+    JSTypeRegistry jst = new JSTypeRegistry(null);\n+\n+    // test == if references are equal\n+    NamedType a = new NamedType(jst, \"type1\", \"source\", 1, 0);\n+    NamedType b = new NamedType(jst, \"type1\", \"source\", 1, 0);\n+    assertTrue(a.equals(b));\n+\n+    // test != to non-NamedType\n+    assertFalse(a.equals(\"type1\"));\n+\n+    // test == instance of referenced type\n+    assertTrue(namedGoogBar.equals(googBar.getInstanceType()));\n+    assertTrue(googBar.getInstanceType().equals(namedGoogBar));\n+  }\n+\n+  /**\n+   * Tests the {@link NamedType#equals} function against other types.\n+   */\n+  public void testNamedTypeEquals2() {\n+    // test == if references are equal\n+    NamedType a = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n+    NamedType b = new NamedType(registry, \"typeB\", \"source\", 1, 0);\n+\n+    ObjectType realA = registry.createConstructorType(\n+        \"typeA\", null, null, null).getInstanceType();\n+    ObjectType realB = registry.createEnumType(\n+        \"typeB\", NUMBER_TYPE).getElementsType();\n+    registry.declareType(\"typeA\", realA);\n+    registry.declareType(\"typeB\", realB);\n+\n+    assertEquals(a.hashCode(), realA.hashCode());\n+    assertEquals(a, realA);\n+    assertEquals(b.hashCode(), realB.hashCode());\n+    assertEquals(b, realB);\n+\n+    a.resolve(null, null);\n+    b.resolve(null, null);\n+\n+    assertTrue(a.isResolved());\n+    assertTrue(b.isResolved());\n+    assertEquals(a.hashCode(), realA.hashCode());\n+    assertEquals(a, realA);\n+    assertEquals(b.hashCode(), realB.hashCode());\n+    assertEquals(b, realB);\n+  }\n+\n+  /**\n+   * Tests the {@link NamedType#equals} function against other types\n+   * when it's forward-declared.\n+   */\n+  public void testForwardDeclaredNamedTypeEquals() {\n+    // test == if references are equal\n+    NamedType a = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n+    NamedType b = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n+    registry.forwardDeclareType(\"typeA\");\n+\n+    assertEquals(a.hashCode(), b.hashCode());\n+    assertEquals(a, b);\n+\n+    a.resolve(null, EMPTY_SCOPE);\n+\n+    assertTrue(a.isResolved());\n+    assertFalse(b.isResolved());\n+\n+    assertEquals(a.hashCode(), b.hashCode());\n+    assertEquals(a, b);\n+\n+    assertFalse(a.equals(UNKNOWN_TYPE));\n+    assertFalse(b.equals(UNKNOWN_TYPE));\n+  }\n+\n+  public void testForwardDeclaredNamedType() {\n+    NamedType a = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n+    registry.forwardDeclareType(\"typeA\");\n+\n+    assertEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE));\n+    assertEquals(CHECKED_UNKNOWN_TYPE,\n+        a.getLeastSupertype(CHECKED_UNKNOWN_TYPE));\n+    assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a));\n+    assertEquals(CHECKED_UNKNOWN_TYPE,\n+        CHECKED_UNKNOWN_TYPE.getLeastSupertype(a));\n+  }\n+\n+  /**\n+   * Tests {@link JSType#getGreatestSubtype(JSType)} on simple types.\n+   */\n+  public void testGreatestSubtypeSimpleTypes() {\n+    assertEquals(ARRAY_TYPE,\n+        ARRAY_TYPE.getGreatestSubtype(ALL_TYPE));\n+    assertEquals(ARRAY_TYPE,\n+        ALL_TYPE.getGreatestSubtype(ARRAY_TYPE));\n+    assertEquals(NO_OBJECT_TYPE,\n+        REGEXP_TYPE.getGreatestSubtype(NO_OBJECT_TYPE));\n+    assertEquals(NO_OBJECT_TYPE,\n+        NO_OBJECT_TYPE.getGreatestSubtype(REGEXP_TYPE));\n+    assertEquals(NO_OBJECT_TYPE,\n+        ARRAY_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE));\n+    assertEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE));\n+    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(functionType));\n+    assertEquals(STRING_OBJECT_TYPE,\n+        STRING_OBJECT_TYPE.getGreatestSubtype(OBJECT_TYPE));\n+    assertEquals(STRING_OBJECT_TYPE,\n+        OBJECT_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE));\n+    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(DATE_TYPE));\n+    assertEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE));\n+    assertEquals(EVAL_ERROR_TYPE,\n+        ERROR_TYPE.getGreatestSubtype(EVAL_ERROR_TYPE));\n+    assertEquals(EVAL_ERROR_TYPE,\n+        EVAL_ERROR_TYPE.getGreatestSubtype(ERROR_TYPE));\n+    assertEquals(NO_TYPE,\n+        NULL_TYPE.getGreatestSubtype(ERROR_TYPE));\n+    assertEquals(UNKNOWN_TYPE,\n+        NUMBER_TYPE.getGreatestSubtype(UNKNOWN_TYPE));\n+  }\n+\n+  /**\n+   * Tests {@link JSType#getGreatestSubtype(JSType)} on union types.\n+   */\n+  public void testGreatestSubtypeUnionTypes1() {\n+    assertEquals(NULL_TYPE, createNullableType(STRING_TYPE).getGreatestSubtype(\n+            createNullableType(NUMBER_TYPE)));\n+  }\n+\n+  /**\n+   * Tests {@link JSType#getGreatestSubtype(JSType)} on union types.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testGreatestSubtypeUnionTypes2() {\n+    UnionType evalUriError =\n+        (UnionType) createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n+    assertEquals(evalUriError,\n+        evalUriError.getGreatestSubtype(ERROR_TYPE));\n+  }\n+\n+  /**\n+   * Tests {@link JSType#getGreatestSubtype(JSType)} on union types.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testGreatestSubtypeUnionTypes3() {\n+    // (number,undefined,null)\n+    UnionType nullableOptionalNumber =\n+        (UnionType) createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE);\n+    // (null,undefined)\n+    UnionType nullUndefined =\n+        (UnionType) createUnionType(VOID_TYPE, NULL_TYPE);\n+    assertEquals(nullUndefined,\n+        nullUndefined.getGreatestSubtype(nullableOptionalNumber));\n+    assertEquals(nullUndefined,\n+        nullableOptionalNumber.getGreatestSubtype(nullUndefined));\n+  }\n+\n+  /**\n+   * Tests that a derived class extending a type via a named type is a subtype\n+   * of it.\n+   */\n+  public void testSubtypingDerivedExtendsNamedBaseType() throws Exception {\n+    ObjectType derived =\n+        registry.createObjectType(registry.createObjectType(namedGoogBar));\n+\n+    assertTrue(derived.isSubtype(googBar.getInstanceType()));\n+  }\n+\n+  public void testNamedSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        googBar.getPrototype(),\n+        googBar.getInstanceType(),\n+        googSubBar.getPrototype(),\n+        googSubBar.getInstanceType(),\n+        googSubSubBar.getPrototype(),\n+        googSubSubBar.getInstanceType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testRecordSubtypeChain() throws Exception {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", STRING_TYPE);\n+    JSType aType = builder.build();\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", STRING_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    JSType abType = builder.build();\n+\n+    builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"a\", STRING_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"c\", NUMBER_TYPE);\n+    JSType abcType = builder.build();\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        aType,\n+        abType,\n+        abcType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testRecordAndObjectChain2() throws Exception {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"date\", DATE_TYPE);\n+    JSType hasDateProperty = builder.build();\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        hasDateProperty,\n+        googBar.getInstanceType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testRecordAndObjectChain3() throws Exception {\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    builder.addProperty(\"date\", UNKNOWN_TYPE);\n+    JSType hasUnknownDateProperty = builder.build();\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        hasUnknownDateProperty,\n+        googBar.getInstanceType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testNullableNamedTypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.createOptionalNullableType(\n+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)),\n+        registry.createOptionalNullableType(\n+            registry.getNativeType(JSTypeNative.OBJECT_TYPE)),\n+        registry.createOptionalNullableType(googBar.getPrototype()),\n+        registry.createOptionalNullableType(googBar.getInstanceType()),\n+        registry.createNullableType(googSubBar.getPrototype()),\n+        registry.createNullableType(googSubBar.getInstanceType()),\n+        googSubSubBar.getPrototype(),\n+        googSubSubBar.getInstanceType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testEnumTypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        enumType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testFunctionSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),\n+        dateMethod,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testConstructorSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testGoogBarSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        googBar,\n+        googSubBar,\n+        googSubSubBar,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  public void testConstructorWithArgSubtypeChain() throws Exception {\n+    FunctionType googBarArgConstructor = registry.createConstructorType(\n+        \"barArg\", null, registry.createParameters(googBar), null);\n+    FunctionType googSubBarArgConstructor = registry.createConstructorType(\n+        \"subBarArg\", null, registry.createParameters(googSubBar), null);\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        googBarArgConstructor,\n+        googSubBarArgConstructor,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  /**\n+   * Tests that the given chain of types has a total ordering defined\n+   * by the subtype relationship, with types at the top of the lattice\n+   * listed first.\n+   *\n+   * Also verifies that the infimum of any two types on the chain\n+   * is the lower type, and the supremum of any two types on the chain\n+   * is the higher type.\n+   */\n+  public void verifySubtypeChain(List<JSType> typeChain) throws Exception {\n+    verifySubtypeChain(typeChain, true);\n+  }\n+\n+  public void verifySubtypeChain(List<JSType> typeChain,\n+                                 boolean checkSubtyping) throws Exception {\n+    for (int i = 0; i < typeChain.size(); i++) {\n+      for (int j = 0; j < typeChain.size(); j++) {\n+        JSType typeI = typeChain.get(i);\n+        JSType typeJ = typeChain.get(j);\n+\n+        if (i == j) {\n+          assertTrue(typeI + \" should equal itself\", typeI.equals(typeI));\n+        } else {\n+          assertFalse(typeI + \" should not equal \" + typeJ,\n+              typeI.equals(typeJ));\n+        }\n+\n+        if (checkSubtyping) {\n+          if (i <= j) {\n+            assertTrue(typeJ + \" should be a subtype of \" + typeI,\n+                typeJ.isSubtype(typeI));\n+          } else {\n+            assertFalse(typeJ + \" should not be a subtype of \" + typeI,\n+                typeJ.isSubtype(typeI));\n+          }\n+\n+          JSType expectedSupremum = i < j ? typeI : typeJ;\n+          JSType expectedInfimum = i > j ? typeI : typeJ;\n+          assertEquals(\n+              expectedSupremum + \" should be the least supertype of \" + typeI +\n+              \" and \" + typeJ,\n+              expectedSupremum, typeI.getLeastSupertype(typeJ));\n+          assertEquals(\n+              expectedInfimum + \" should be the greatest subtype of \" + typeI +\n+              \" and \" + typeJ,\n+              expectedInfimum, typeI.getGreatestSubtype(typeJ));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Tests that special union types can assign to other types. For instance\n+   * <code>(number,Number)</code> can assign to <code>number</code> or\n+   * <code>Number</code> even though <code>number &lt; (number, Number)</code>\n+   * and <code>Number &lt; (number,Number)</code>. Unions containing the unknown\n+   * type should be able to assign to any other type.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testSpecialUnionCanAssignTo() throws Exception {\n+    // autoboxing quirks\n+    UnionType numbers =\n+        (UnionType) createUnionType(NUMBER_TYPE, NUMBER_OBJECT_TYPE);\n+    assertTrue(numbers.canAssignTo(NUMBER_TYPE));\n+    assertTrue(numbers.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertFalse(numbers.canAssignTo(EVAL_ERROR_TYPE));\n+\n+    UnionType strings =\n+        (UnionType) createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n+    assertTrue(strings.canAssignTo(STRING_TYPE));\n+    assertTrue(strings.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(strings.canAssignTo(DATE_TYPE));\n+\n+    UnionType booleans =\n+        (UnionType) createUnionType(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE);\n+    assertTrue(booleans.canAssignTo(BOOLEAN_TYPE));\n+    assertTrue(booleans.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(booleans.canAssignTo(REGEXP_TYPE));\n+\n+    // unknown quirks\n+    JSType unknown = createUnionType(UNKNOWN_TYPE, DATE_TYPE);\n+    assertTrue(unknown.canAssignTo(STRING_TYPE));\n+\n+    // all members need to be assignable to\n+    UnionType stringDate =\n+        (UnionType) createUnionType(STRING_OBJECT_TYPE, DATE_TYPE);\n+    assertTrue(stringDate.canAssignTo(OBJECT_TYPE));\n+    assertFalse(stringDate.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(stringDate.canAssignTo(DATE_TYPE));\n+  }\n+\n+  /**\n+   * Tests the behavior of\n+   * {@link JSType#getRestrictedTypeGivenToBooleanOutcome(boolean)}.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testRestrictedTypeGivenToBoolean() {\n+    // simple cases\n+    assertEquals(BOOLEAN_TYPE,\n+        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(BOOLEAN_TYPE,\n+        BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(NO_TYPE,\n+        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NULL_TYPE,\n+        NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(NUMBER_TYPE,\n+        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NUMBER_TYPE,\n+        NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(STRING_TYPE,\n+        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(STRING_TYPE,\n+        STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(STRING_OBJECT_TYPE,\n+        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NO_TYPE,\n+        STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(NO_TYPE,\n+        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(VOID_TYPE,\n+        VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(NO_OBJECT_TYPE,\n+        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NO_TYPE,\n+        NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(NO_TYPE,\n+        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NO_TYPE,\n+        NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(ALL_TYPE,\n+        ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(UNKNOWN_TYPE,\n+        UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    // unions\n+    UnionType nullableStringValue =\n+        (UnionType) createNullableType(STRING_TYPE);\n+    assertEquals(STRING_TYPE,\n+        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(nullableStringValue,\n+        nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false));\n+\n+    UnionType nullableStringObject =\n+        (UnionType) createNullableType(STRING_OBJECT_TYPE);\n+    assertEquals(STRING_OBJECT_TYPE,\n+        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true));\n+    assertEquals(NULL_TYPE,\n+        nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false));\n+  }\n+\n+  public void testRegisterProperty() {\n+    int i = 0;\n+    Set<JSType> allObjects = Sets.newHashSet();\n+    for (JSType type : types) {\n+      String propName = \"ALF\" + i++;\n+      if (type instanceof ObjectType) {\n+        ObjectType objType = (ObjectType) type;\n+        objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false);\n+        objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false);\n+        assertEquals(type,\n+            registry.getGreatestSubtypeWithProperty(type, propName));\n+        assertEquals(Sets.newHashSet(type),\n+            registry.getTypesWithProperty(propName));\n+        assertEquals(NO_TYPE,\n+            registry.getGreatestSubtypeWithProperty(type, \"GRRR\"));\n+        allObjects.add(type);\n+      }\n+    }\n+    assertEquals(registry.getTypesWithProperty(\"GRRR\"),\n+        Sets.newHashSet(NO_TYPE));\n+    assertEquals(allObjects, registry.getTypesWithProperty(\"allHaz\"));\n+  }\n+\n+  public void testRegisterPropertyMemoization() {\n+    ObjectType derived1 = registry.createObjectType(\"d1\", null, namedGoogBar);\n+    ObjectType derived2 = registry.createObjectType(\"d2\", null, namedGoogBar);\n+\n+    derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n+\n+    assertEquals(derived1,\n+        registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n+    assertEquals(NO_OBJECT_TYPE,\n+        registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n+\n+    derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n+\n+    assertEquals(derived1,\n+        registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n+    assertEquals(derived2,\n+        registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n+  }\n+\n+  public void testGoodSetPrototypeBasedOn() {\n+    FunctionType fun = registry.createConstructorType(\"fun\", null, null, null);\n+    fun.setPrototypeBasedOn(unresolvedNamedType);\n+    assertTrue(fun.getInstanceType().isUnknownType());\n+  }\n+\n+  public void testInvalidSetPrototypeBasedOn() {\n+    FunctionType fun = registry.createConstructorType(\"fun\", null, null, null);\n+    assertFalse(fun.getInstanceType().isUnknownType());\n+\n+    // You cannot change the prototype chain after checking if it is unknown.\n+    try {\n+      fun.setPrototypeBasedOn(unresolvedNamedType);\n+      fail();\n+    } catch (IllegalStateException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  public void testGetTypeUnderEquality1() {\n+    for (JSType type : types) {\n+      testGetTypeUnderEquality(type, type, type, type);\n+    }\n+  }\n+\n+  public void testGetTypesUnderEquality2() {\n+    // objects can be equal to numbers\n+    testGetTypeUnderEquality(\n+        NUMBER_TYPE, OBJECT_TYPE,\n+        NUMBER_TYPE, OBJECT_TYPE);\n+  }\n+\n+  public void testGetTypesUnderEquality3() {\n+    // null == undefined\n+    testGetTypeUnderEquality(\n+        NULL_TYPE, VOID_TYPE,\n+        NULL_TYPE, VOID_TYPE);\n+  }\n+\n+  @SuppressWarnings(\"checked\")\n+  public void testGetTypesUnderEquality4() {\n+    // (number,string) and number/string\n+    UnionType stringNumber =\n+        (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE);\n+    testGetTypeUnderEquality(\n+        stringNumber, STRING_TYPE,\n+        stringNumber, STRING_TYPE);\n+    testGetTypeUnderEquality(\n+        stringNumber, NUMBER_TYPE,\n+        stringNumber, NUMBER_TYPE);\n+  }\n+\n+  public void testGetTypesUnderEquality5() {\n+    // (number,null) and undefined\n+    JSType nullUndefined = createUnionType(VOID_TYPE, NULL_TYPE);\n+    testGetTypeUnderEquality(\n+        nullUndefined, NULL_TYPE,\n+        nullUndefined, NULL_TYPE);\n+    testGetTypeUnderEquality(\n+        nullUndefined, VOID_TYPE,\n+        nullUndefined, VOID_TYPE);\n+  }\n+\n+  public void testGetTypesUnderEquality6() {\n+    // (number,undefined,null) == null\n+    JSType optNullNumber = createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_TYPE);\n+    testGetTypeUnderEquality(\n+        optNullNumber, NULL_TYPE,\n+        createUnionType(NULL_TYPE, VOID_TYPE), NULL_TYPE);\n+  }\n+\n+  private void testGetTypeUnderEquality(\n+      JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n+    // creating the pairs\n+    Pair<JSType, JSType> p12 = t1.getTypesUnderEquality(t2);\n+    Pair<JSType, JSType> p21 = t2.getTypesUnderEquality(t1);\n+\n+    // t1Eq\n+    assertEquals(t1Eq, p12.first);\n+    assertEquals(t1Eq, p21.second);\n+\n+    // t2Eq\n+    assertEquals(t2Eq, p12.second);\n+    assertEquals(t2Eq, p21.first);\n+  }\n+\n+  @SuppressWarnings(\"checked\")\n+      public void testGetTypesUnderInequality1() {\n+    // objects can be not equal to numbers\n+    UnionType numberObject =\n+        (UnionType) createUnionType(NUMBER_TYPE, OBJECT_TYPE);\n+    testGetTypesUnderInequality(\n+        numberObject, NUMBER_TYPE,\n+        numberObject, NUMBER_TYPE);\n+    testGetTypesUnderInequality(\n+        numberObject, OBJECT_TYPE,\n+        numberObject, OBJECT_TYPE);\n+  }\n+\n+  @SuppressWarnings(\"checked\")\n+      public void testGetTypesUnderInequality2() {\n+    // null == undefined\n+    UnionType nullUndefined =\n+        (UnionType) createUnionType(VOID_TYPE, NULL_TYPE);\n+    testGetTypesUnderInequality(\n+        nullUndefined, NULL_TYPE,\n+        NO_TYPE, NO_TYPE);\n+    testGetTypesUnderInequality(\n+        nullUndefined, VOID_TYPE,\n+        NO_TYPE, NO_TYPE);\n+  }\n+\n+  @SuppressWarnings(\"checked\")\n+      public void testGetTypesUnderInequality3() {\n+    // (number,string)\n+    UnionType stringNumber =\n+        (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE);\n+    testGetTypesUnderInequality(\n+        stringNumber, NUMBER_TYPE,\n+        stringNumber, NUMBER_TYPE);\n+    testGetTypesUnderInequality(\n+        stringNumber, STRING_TYPE,\n+        stringNumber, STRING_TYPE);\n+  }\n+\n+  @SuppressWarnings(\"checked\")\n+      public void testGetTypesUnderInequality4() throws Exception {\n+    // (number,undefined,null) and null\n+    UnionType nullableOptionalNumber =\n+        (UnionType) createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE);\n+    testGetTypesUnderInequality(\n+        nullableOptionalNumber, NULL_TYPE,\n+        NUMBER_TYPE, NULL_TYPE);\n+  }\n+\n+  private void testGetTypesUnderInequality(\n+      JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) {\n+    // creating the pairs\n+    Pair<JSType, JSType> p12 = t1.getTypesUnderInequality(t2);\n+    Pair<JSType, JSType> p21 = t2.getTypesUnderInequality(t1);\n+\n+    // t1Eq\n+    assertEquals(t1Eq, p12.first);\n+    assertEquals(t1Eq, p21.second);\n+\n+    // t2Eq\n+    assertEquals(t2Eq, p12.second);\n+    assertEquals(t2Eq, p21.first);\n+  }\n+\n+\n+  /**\n+   * Tests the factory method\n+   * {@link JSTypeRegistry#createRecordType}.\n+   */\n+  public void testCreateRecordType() throws Exception {\n+    Map<String, JSType> properties = new HashMap<String, JSType>();\n+    properties.put(\"hello\", NUMBER_TYPE);\n+\n+    JSType recordType = registry.createRecordType(properties);\n+    assertEquals(\"{ hello : number }\", recordType.toString());\n+  }\n+\n+  /**\n+   * Tests the factory method\n+   * {@link JSTypeRegistry#createUnionType(JSType...)}.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testCreateUnionType() throws Exception {\n+    // number\n+    UnionType optNumber =\n+        (UnionType) registry.createUnionType(NUMBER_TYPE, DATE_TYPE);\n+    assertTrue(optNumber.contains(NUMBER_TYPE));\n+    assertTrue(optNumber.contains(DATE_TYPE));\n+\n+    // union\n+    UnionType optUnion =\n+        (UnionType) registry.createUnionType(REGEXP_TYPE,\n+            registry.createUnionType(STRING_OBJECT_TYPE, DATE_TYPE));\n+    assertTrue(optUnion.contains(DATE_TYPE));\n+    assertTrue(optUnion.contains(STRING_OBJECT_TYPE));\n+    assertTrue(optUnion.contains(REGEXP_TYPE));\n+  }\n+\n+  /**\n+   * Tests the factory method {@link JSTypeRegistry#createOptionalType(JSType)}.\n+   */\n+  public void testCreateOptionalType() throws Exception {\n+    // number\n+    UnionType optNumber = (UnionType) registry.createOptionalType(NUMBER_TYPE);\n+    assertUnionContains(optNumber, NUMBER_TYPE);\n+    assertUnionContains(optNumber, VOID_TYPE);\n+\n+    // union\n+    UnionType optUnion =\n+        (UnionType) registry.createOptionalType(\n+            createUnionType(STRING_OBJECT_TYPE, DATE_TYPE));\n+    assertUnionContains(optUnion, DATE_TYPE);\n+    assertUnionContains(optUnion, STRING_OBJECT_TYPE);\n+    assertUnionContains(optUnion, VOID_TYPE);\n+  }\n+\n+  public void assertUnionContains(UnionType union, JSType type) {\n+    assertTrue(union + \" should contain \" + type, union.contains(type));\n+  }\n+\n+  /**\n+   * Tests the factory method\n+   * {@link JSTypeRegistry#createAnonymousObjectType()}}.\n+   */\n+  public void testCreateAnonymousObjectType() throws Exception {\n+    // anonymous\n+    ObjectType anonymous = registry.createAnonymousObjectType();\n+    assertEquals(OBJECT_TYPE, anonymous.getImplicitPrototype());\n+    assertEquals(\"{...}\", anonymous.getReferenceName());\n+  }\n+\n+  /**\n+   * Tests the factory methods\n+   * {@link JSTypeRegistry#createObjectType(ObjectType)}} and\n+   * {@link JSTypeRegistry#createObjectType(String, Node, ObjectType)}}.\n+   */\n+  public void testCreateObjectType() throws Exception {\n+    // simple\n+    ObjectType subDate =\n+        registry.createObjectType(DATE_TYPE.getImplicitPrototype());\n+    assertEquals(DATE_TYPE.getImplicitPrototype(),\n+        subDate.getImplicitPrototype());\n+    assertEquals(\"{...}\", subDate.getReferenceName());\n+\n+    // name, node, prototype\n+    ObjectType subError = registry.createObjectType(\"Foo\", null,\n+        ERROR_TYPE.getImplicitPrototype());\n+    assertEquals(ERROR_TYPE.getImplicitPrototype(),\n+        subError.getImplicitPrototype());\n+    assertEquals(\"Foo\", subError.getReferenceName());\n+  }\n+\n+  /**\n+   * Tests {@code (U2U_CONSTRUCTOR,undefined) <: (U2U_CONSTRUCTOR,undefined)}.\n+   */\n+  @SuppressWarnings(\"checked\")\n+      public void testBug903110() throws Exception {\n+    UnionType union =\n+        (UnionType) createUnionType(U2U_CONSTRUCTOR_TYPE, VOID_TYPE);\n+    assertTrue(VOID_TYPE.isSubtype(union));\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(union));\n+    assertTrue(union.isSubtype(union));\n+  }\n+\n+  /**\n+   * Tests {@code U2U_FUNCTION_TYPE <: U2U_CONSTRUCTOR} and\n+   * {@code U2U_FUNCTION_TYPE <: (U2U_CONSTRUCTOR,undefined)}.\n+   */\n+  public void testBug904123() throws Exception {\n+    assertTrue(U2U_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE));\n+    assertTrue(U2U_FUNCTION_TYPE.\n+        isSubtype(createOptionalType(U2U_CONSTRUCTOR_TYPE)));\n+  }\n+\n+  public void testUnionWithUnknown() throws Exception {\n+    assertTrue(createUnionType(UNKNOWN_TYPE, NULL_TYPE).isUnknownType());\n+  }\n+\n+  /**\n+   * Assert that a type can assign to itself.\n+   */\n+  private void assertTypeCanAssignToItself(JSType type) {\n+    assertTrue(type.canAssignTo(type));\n+  }\n+\n+  /**\n+   * Tests that hasOwnProperty returns true when a property is defined directly\n+   * on a class and false if the property is defined on the supertype or not at\n+   * all.\n+   */\n+  public void testHasOwnProperty() throws Exception {\n+    ObjectType sup =\n+        registry.createObjectType(registry.createAnonymousObjectType());\n+    ObjectType sub = registry.createObjectType(sup);\n+\n+    sup.defineProperty(\"base\", null, false, false);\n+    sub.defineProperty(\"sub\", null, false, false);\n+\n+    assertTrue(sup.hasProperty(\"base\"));\n+    assertFalse(sup.hasProperty(\"sub\"));\n+    assertTrue(sup.hasOwnProperty(\"base\"));\n+    assertFalse(sup.hasOwnProperty(\"sub\"));\n+    assertFalse(sup.hasOwnProperty(\"none\"));\n+\n+    assertTrue(sub.hasProperty(\"base\"));\n+    assertTrue(sub.hasProperty(\"sub\"));\n+    assertFalse(sub.hasOwnProperty(\"base\"));\n+    assertTrue(sub.hasOwnProperty(\"sub\"));\n+    assertFalse(sub.hasOwnProperty(\"none\"));\n+  }\n+\n+  public void testNamedTypeHasOwnProperty() throws Exception {\n+    namedGoogBar.getImplicitPrototype().defineProperty(\"base\", null, false,\n+        false);\n+    namedGoogBar.defineProperty(\"sub\", null, false, false);\n+\n+    assertFalse(namedGoogBar.hasOwnProperty(\"base\"));\n+    assertTrue(namedGoogBar.hasProperty(\"base\"));\n+    assertTrue(namedGoogBar.hasOwnProperty(\"sub\"));\n+    assertTrue(namedGoogBar.hasProperty(\"sub\"));\n+  }\n+\n+  public void testGetPropertyNames() throws Exception {\n+    ObjectType sup =\n+        registry.createObjectType(registry.createAnonymousObjectType());\n+    ObjectType sub = registry.createObjectType(sup);\n+\n+    sup.defineProperty(\"base\", null, false, false);\n+    sub.defineProperty(\"sub\", null, false, false);\n+\n+    assertEquals(Sets.newHashSet(\"isPrototypeOf\", \"toLocaleString\",\n+          \"propertyIsEnumerable\", \"toString\", \"valueOf\", \"hasOwnProperty\",\n+          \"constructor\", \"base\", \"sub\"), sub.getPropertyNames());\n+    assertEquals(Sets.newHashSet(\"isPrototypeOf\", \"toLocaleString\",\n+          \"propertyIsEnumerable\", \"toString\", \"valueOf\", \"hasOwnProperty\",\n+          \"constructor\", \"base\"), sup.getPropertyNames());\n+\n+    assertEquals(Sets.newHashSet(), NO_OBJECT_TYPE.getPropertyNames());\n+  }\n+\n+  public void testGetAndSetJSDocInfoWithNamedType() throws Exception {\n+    JSDocInfo info = new JSDocInfo();\n+    info.setDeprecated(true);\n+\n+    assertNull(namedGoogBar.getOwnPropertyJSDocInfo(\"X\"));\n+    namedGoogBar.setPropertyJSDocInfo(\"X\", info, false);\n+    assertTrue(namedGoogBar.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n+    assertPropertyTypeInferred(namedGoogBar, \"X\");\n+    assertEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType(\"X\"));\n+  }\n+\n+  public void testGetAndSetJSDocInfoWithObjectTypes() throws Exception {\n+    ObjectType sup =\n+        registry.createObjectType(registry.createAnonymousObjectType());\n+    ObjectType sub = registry.createObjectType(sup);\n+\n+    JSDocInfo deprecated = new JSDocInfo();\n+    deprecated.setDeprecated(true);\n+\n+    JSDocInfo privateInfo = new JSDocInfo();\n+    privateInfo.setVisibility(Visibility.PRIVATE);\n+\n+    sup.defineProperty(\"X\", NUMBER_TYPE, false, false);\n+    sup.setPropertyJSDocInfo(\"X\", privateInfo, false);\n+\n+    sub.setPropertyJSDocInfo(\"X\", deprecated, false);\n+\n+    assertFalse(sup.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n+    assertEquals(Visibility.PRIVATE,\n+        sup.getOwnPropertyJSDocInfo(\"X\").getVisibility());\n+    assertEquals(NUMBER_TYPE, sup.getPropertyType(\"X\"));\n+    assertTrue(sub.getOwnPropertyJSDocInfo(\"X\").isDeprecated());\n+    assertNull(sub.getOwnPropertyJSDocInfo(\"X\").getVisibility());\n+    assertEquals(NUMBER_TYPE, sub.getPropertyType(\"X\"));\n+  }\n+\n+  public void testGetAndSetJSDocInfoWithNoType() throws Exception {\n+    JSDocInfo deprecated = new JSDocInfo();\n+    deprecated.setDeprecated(true);\n+\n+    NO_TYPE.setPropertyJSDocInfo(\"X\", deprecated, false);\n+    assertNull(NO_TYPE.getOwnPropertyJSDocInfo(\"X\"));\n+  }\n+\n+  public void testObjectGetSubTypes() throws Exception {\n+    assertTrue(OBJECT_FUNCTION_TYPE.getSubTypes().contains(googBar));\n+    assertTrue(googBar.getSubTypes().contains(googSubBar));\n+    assertFalse(googBar.getSubTypes().contains(googSubSubBar));\n+    assertFalse(googSubBar.getSubTypes().contains(googSubBar));\n+    assertTrue(googSubBar.getSubTypes().contains(googSubSubBar));\n+  }\n+\n+  public void testImplementingType() throws Exception {\n+    assertTrue(registry.getDirectImplementors(\n+        interfaceType.getInstanceType()).contains(googBar));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/TernaryValueTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n+import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n+import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the behavior of {@link TernaryValue} by verifying the truth tables\n+ * of the operations {@link TernaryValue#and(TernaryValue)},\n+ * {@link TernaryValue#not()}, {@link TernaryValue#or(TernaryValue)}\n+ * and {@link TernaryValue#xor(TernaryValue)} as well as the\n+ * {@link TernaryValue#toBoolean(boolean)} method.\n+ *\n+*\n+ */\n+public class TernaryValueTest extends TestCase {\n+  public void testOrdinal() throws Exception {\n+    assertEquals(0, FALSE.ordinal());\n+    assertEquals(1, TRUE.ordinal());\n+    assertEquals(2, UNKNOWN.ordinal());\n+  }\n+\n+  public void testAnd() throws Exception {\n+    assertEquals(TRUE, TRUE.and(TRUE));\n+    assertEquals(FALSE, TRUE.and(FALSE));\n+    assertEquals(UNKNOWN, TRUE.and(UNKNOWN));\n+\n+    assertEquals(FALSE, FALSE.and(TRUE));\n+    assertEquals(FALSE, FALSE.and(FALSE));\n+    assertEquals(FALSE, FALSE.and(UNKNOWN));\n+\n+    assertEquals(UNKNOWN, UNKNOWN.and(TRUE));\n+    assertEquals(FALSE, UNKNOWN.and(FALSE));\n+    assertEquals(UNKNOWN, UNKNOWN.and(UNKNOWN));\n+  }\n+\n+  public void testNot() throws Exception {\n+    assertEquals(FALSE, TRUE.not());\n+    assertEquals(TRUE, FALSE.not());\n+    assertEquals(UNKNOWN, UNKNOWN.not());\n+  }\n+\n+  public void testOr() throws Exception {\n+    assertEquals(TRUE, TRUE.or(TRUE));\n+    assertEquals(TRUE, TRUE.or(FALSE));\n+    assertEquals(TRUE, TRUE.or(UNKNOWN));\n+\n+    assertEquals(TRUE, FALSE.or(TRUE));\n+    assertEquals(FALSE, FALSE.or(FALSE));\n+    assertEquals(UNKNOWN, FALSE.or(UNKNOWN));\n+\n+    assertEquals(TRUE, UNKNOWN.or(TRUE));\n+    assertEquals(UNKNOWN, UNKNOWN.or(FALSE));\n+    assertEquals(UNKNOWN, UNKNOWN.or(UNKNOWN));\n+  }\n+\n+  public void testXor() throws Exception {\n+    assertEquals(FALSE, TRUE.xor(TRUE));\n+    assertEquals(TRUE, TRUE.xor(FALSE));\n+    assertEquals(UNKNOWN, TRUE.xor(UNKNOWN));\n+\n+    assertEquals(TRUE, FALSE.xor(TRUE));\n+    assertEquals(FALSE, FALSE.xor(FALSE));\n+    assertEquals(UNKNOWN, FALSE.xor(UNKNOWN));\n+\n+    assertEquals(UNKNOWN, UNKNOWN.xor(TRUE));\n+    assertEquals(UNKNOWN, UNKNOWN.xor(FALSE));\n+    assertEquals(UNKNOWN, UNKNOWN.xor(UNKNOWN));\n+  }\n+\n+  public void testToBoolean() throws Exception {\n+    assertTrue(TRUE.toBoolean(true));\n+    assertTrue(TRUE.toBoolean(false));\n+\n+    assertFalse(FALSE.toBoolean(true));\n+    assertFalse(FALSE.toBoolean(false));\n+\n+    assertTrue(UNKNOWN.toBoolean(true));\n+    assertFalse(UNKNOWN.toBoolean(false));\n+  }\n+\n+  public void testToString() {\n+    assertEquals(\"true\", TRUE.toString());\n+    assertEquals(\"false\", FALSE.toString());\n+    assertEquals(\"unknown\", UNKNOWN.toString());\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/UnionTypeBuilderTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+/**\n+ * Test for {@link UnionTypeBuilder}.\n+ *\n+*\n+ */\n+public class UnionTypeBuilderTest extends BaseJSTypeTestCase {\n+\n+  public void testAllType() {\n+    assertUnion(\"*\", ALL_TYPE);\n+    assertUnion(\"*\", NUMBER_TYPE, ALL_TYPE);\n+    assertUnion(\"*\", ALL_TYPE, NUMBER_TYPE);\n+    assertUnion(\"*\", ALL_TYPE, NUMBER_TYPE, NO_TYPE);\n+  }\n+\n+  public void testEmptyUnion() {\n+    assertUnion(\"None\");\n+    assertUnion(\"None\", NO_TYPE, NO_TYPE);\n+  }\n+\n+  public void testUnionTypes() {\n+    JSType union = registry.createUnionType(STRING_TYPE, OBJECT_TYPE);\n+\n+    assertUnion(\"*\", ALL_TYPE, union);\n+    assertUnion(\"(Object|string)\", OBJECT_TYPE, union);\n+    assertUnion(\"(Object|string)\", union, OBJECT_TYPE);\n+    assertUnion(\"(Object|number|string)\", NUMBER_TYPE, union);\n+    assertUnion(\"(Object|number|string)\", union, NUMBER_TYPE);\n+    assertUnion(\"(Object|boolean|number|string)\", union,\n+        registry.createUnionType(NUMBER_TYPE, BOOLEAN_TYPE));\n+    assertUnion(\"(Object|boolean|number|string)\",\n+        registry.createUnionType(NUMBER_TYPE, BOOLEAN_TYPE), union);\n+    assertUnion(\"(Object|string)\", union, STRING_OBJECT_TYPE);\n+  }\n+\n+  public void testUnknownTypes() {\n+    JSType unresolvedNameA1 =\n+        new NamedType(registry, \"not.resolved.A\", null, -1, -1);\n+    JSType unresolvedNameA2 =\n+        new NamedType(registry, \"not.resolved.A\", null, -1, -1);\n+    JSType unresolvedNameB =\n+        new NamedType(registry, \"not.resolved.B\", null, -1, -1);\n+\n+    assertUnion(\"?\", UNKNOWN_TYPE);\n+    assertUnion(\"?\", UNKNOWN_TYPE, UNKNOWN_TYPE);\n+\n+    // NOTE: \"(?)\" means there are multiple unknown types in the union.\n+    assertUnion(\"?\", UNKNOWN_TYPE, unresolvedNameA1);\n+    assertUnion(\"not.resolved.A\", unresolvedNameA1, unresolvedNameA2);\n+    assertUnion(\"(not.resolved.A|not.resolved.B)\",\n+        unresolvedNameA1, unresolvedNameB);\n+    assertUnion(\"(Object|not.resolved.A)\", unresolvedNameA1, OBJECT_TYPE);\n+  }\n+\n+  public void testRemovalOfDupes() {\n+    JSType stringAndObject =\n+        registry.createUnionType(STRING_TYPE, OBJECT_TYPE);\n+    assertUnion(\"(Object|string)\", stringAndObject, STRING_OBJECT_TYPE);\n+    assertUnion(\"(Object|string)\", STRING_OBJECT_TYPE, stringAndObject);\n+  }\n+\n+  public void assertUnion(String expected, JSType ... types) {\n+    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n+    for (JSType type : types) {\n+      builder.addAlternate(type);\n+    }\n+    assertEquals(expected, builder.build().toString());\n+  }\n+}", "timestamp": 1260222811, "metainfo": ""}