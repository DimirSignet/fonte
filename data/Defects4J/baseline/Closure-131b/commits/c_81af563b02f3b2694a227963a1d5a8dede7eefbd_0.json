{"sha": "81af563b02f3b2694a227963a1d5a8dede7eefbd", "log": "Add a heuristic for figuring out the type of an inferred variable that is read across multiple scopes. This isn't perfect, but it should catch a lot of common cases. Fixes issue 726  Tested: yes  R=johnlenz,dimvar DELTA=249  (221 added, 9 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5332   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n+import com.google.common.collect.HashMultiset;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMultiset;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Multiset;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.IR;\n \n     /** Gets a list of variables whose properties are escaped. */\n     Set<String> getEscapedQualifiedNames();\n+\n+    /** Gets the number of times each variable has been assigned. */\n+    Multiset<String> getAssignedNameCounts();\n   }\n \n   static class UnknownFunctionContents implements FunctionContents {\n     @Override\n     public Set<String> getEscapedQualifiedNames() {\n       return ImmutableSet.of();\n+    }\n+\n+    @Override\n+    public Multiset<String> getAssignedNameCounts() {\n+      return ImmutableMultiset.of();\n     }\n   }\n \n     private boolean hasNonEmptyReturns = false;\n     private Set<String> escapedVarNames;\n     private Set<String> escapedQualifiedNames;\n+    private final Multiset<String> assignedVarNames = HashMultiset.create();\n \n     AstFunctionContents(Node n) {\n       this.n = n;\n       }\n       escapedQualifiedNames.add(name);\n     }\n+\n+    @Override\n+    public Multiset<String> getAssignedNameCounts() {\n+      return assignedVarNames;\n+    }\n+\n+    void recordAssignedName(String name) {\n+      assignedVarNames.add(name);\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Returns whether this is a bleeding function (an anonymous named function\n+   * that bleeds into the inner scope).\n+   */\n+  static boolean isBleedingFunctionName(Node n) {\n+    return n.isName() && !n.getString().isEmpty() &&\n+        isFunctionExpression(n.getParent());\n+  }\n+\n+  /**\n    * Determines if a node is a function expression that has an empty body.\n    *\n    * @param node a node\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     /** The enclosing scope */\n     final Scope scope;\n \n+    /** @see isMarkedEscaped */\n     private boolean markedEscaped = false;\n+\n+    /** @see isMarkedAssignedExactlyOnce */\n+    private boolean markedAssignedExactlyOnce = false;\n \n     /**\n      * Creates a variable.\n \n     /**\n      * Whether this is a bleeding function (an anonymous named function\n-     * that bleeds into the inner scope.\n+     * that bleeds into the inner scope).\n      */\n     public boolean isBleedingFunction() {\n       return NodeUtil.isFunctionExpression(getParentNode());\n       return \"Scope.Var \" + name + \"{\" + type + \"}\";\n     }\n \n-    /** Record that this is escaped by an inner scope. */\n+    /**\n+     * Record that this is escaped by an inner scope.\n+     *\n+     * In other words, it's assigned in an inner scope so that it's much harder\n+     * to make assertions about its value at a given point.\n+     */\n     void markEscaped() {\n       markedEscaped = true;\n     }\n      */\n     boolean isMarkedEscaped() {\n       return markedEscaped;\n+    }\n+\n+    /**\n+     * Record that this is assigned exactly once..\n+     *\n+     * In other words, it's assigned in an inner scope so that it's much harder\n+     * to make assertions about its value at a given point.\n+     */\n+    void markAssignedExactlyOnce() {\n+      markedAssignedExactlyOnce = true;\n+    }\n+\n+    /**\n+     * Whether this is assigned exactly once.\n+     * Notice that not all scope creators record this information.\n+     */\n+    boolean isMarkedAssignedExactlyOnce() {\n+      return markedAssignedExactlyOnce;\n     }\n   }\n \n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Var getSlot(String name) {\n     return getVar(name);\n   }\n \n   @Override\n-  public StaticSlot<JSType> getOwnSlot(String name) {\n+  public Var getOwnSlot(String name) {\n     return vars.get(name);\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         // There are two situations where we don't want to use type information\n         // from the scope, even if we have it.\n \n-        // 1) The var is escaped in a weird way, e.g.,\n+        // 1) The var is escaped and assigned in an inner scope, e.g.,\n         // function f() { var x = 3; function g() { x = null } (x); }\n         boolean isInferred = var.isTypeInferred();\n         boolean unflowable = isInferred &&\n             isUnflowable(syntacticScope.getVar(varName));\n \n         // 2) We're reading type information from another scope for an\n-        // inferred variable.\n-        // var t = null; function f() { (t); }\n-        boolean nonLocalInferredSlot =\n-            isInferred &&\n-            syntacticScope.getParent() != null &&\n-            var == syntacticScope.getParent().getSlot(varName);\n+        // inferred variable. That variable is assigned more than once,\n+        // and we can't know which type we're getting.\n+        //\n+        // var t = null; function f() { (t); } doStuff(); t = {};\n+        //\n+        // Notice that this heuristic isn't perfect. For example, you might\n+        // have:\n+        //\n+        // function f() { (t); } f(); var t = 3;\n+        //\n+        // In this case, we would infer the first reference to t as\n+        // type {number}, even though it's undefined.\n+        boolean nonLocalInferredSlot = false;\n+        if (isInferred && syntacticScope.isLocal()) {\n+          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n+          if (var == maybeOuterVar &&\n+              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n+            nonLocalInferredSlot = true;\n+          }\n+        }\n \n         if (!unflowable && !nonLocalInferredSlot) {\n           type = var.getType();\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multiset;\n import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n           Preconditions.checkState(v.getScope() == scope);\n           v.markEscaped();\n         }\n+\n+        for (Multiset.Entry<String> entry :\n+                 contents.getAssignedNameCounts().entrySet()) {\n+          Var v = scope.getVar(entry.getElement());\n+          Preconditions.checkState(v.getScope() == scope);\n+          if (entry.getCount() == 1) {\n+            v.markAssignedExactlyOnce();\n+          }\n+        }\n       }\n     }\n \n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n-        // We only need to worry about escaped variables at depth 3.\n-        // An variable escaped at depth 2 is, by definition, a global variable.\n+      if (t.getScopeDepth() <= 1) {\n+        // The first-order function analyzer looks at two types of variables:\n+        //\n+        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n+        //\n+        // 2) Local variables that are assigned more than once.\n+        //\n         // We treat all global variables as escaped by default, so there's\n         // no reason to do this extra computation for them.\n         return;\n       }\n \n-      if (n.isName() && NodeUtil.isLValue(n)) {\n+      if (n.isName() && NodeUtil.isLValue(n) &&\n+          // Be careful of bleeding functions, which create variables\n+          // in the inner scope, not the scope where the name appears.\n+          !NodeUtil.isBleedingFunctionName(n)) {\n         String name = n.getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n         if (var != null) {\n           Scope ownerScope = var.getScope();\n+          if (ownerScope.isLocal()) {\n+            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+          }\n+\n           if (scope != ownerScope && ownerScope.isLocal()) {\n             data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n           }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"Property name2 never defined on rec\");\n   }\n \n+  public void testIssue726() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @return {!Function} */ \" +\n+        \"Foo.prototype.getDeferredBar = function() { \" +\n+        \"  var self = this;\" +\n+        \"  return function() {\" +\n+        \"    self.bar(true);\" +\n+        \"  };\" +\n+        \"};\",\n+        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n   public void testIssue765() throws Exception {\n     testTypes(\n         \"/** @constructor */\" +", "timestamp": 1344469061, "metainfo": ""}