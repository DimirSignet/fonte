{"sha": "00241aa722c2245784e63dba9d444fce88134aed", "log": "Automated g4 rollback  *** Reason for rollback ***  Change caused tests to stop building.  *** Original change description ***  New @struct and @dict annotations for constructors. With these annotations, one can enforce only dot or only bracket access on object properties.   Revision created by MOE tool push_codebase. MOE_MIGRATION=5489   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   private ObjectType baseType = null;\n   private ObjectType thisType = null;\n   private boolean isConstructor = false;\n-  private boolean makesStructs = false;\n-  private boolean makesDicts = false;\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n   private ImmutableList<String> templateTypeNames = ImmutableList.of();\n       DiagnosticType.warning(\n           \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\",\n           \"@implements used without @constructor or @interface for {0}\");\n-\n-  static final DiagnosticType CONSTRUCTOR_REQUIRED =\n-      DiagnosticType.warning(\"JSC_CONSTRUCTOR_REQUIRED\",\n-                             \"{0} used without @constructor for {1}\");\n \n   static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning(\n       \"JSC_VAR_ARGS_MUST_BE_LAST\",\n   FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n     if (info != null) {\n       isConstructor = info.isConstructor();\n-      makesStructs = info.makesStructs();\n-      makesDicts = info.makesDicts();\n       isInterface = info.isInterface();\n-\n-      if (makesStructs && !isConstructor) {\n-        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n-      } else if (makesDicts && !isConstructor) {\n-        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n-      }\n \n       // base type\n       if (info.hasBaseType()) {\n           }\n         }\n       } else if (info.getImplementedInterfaceCount() > 0) {\n-        reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n+        reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);\n       }\n \n       // extended interfaces (for interface only)\n         fnName, contents.getSourceNode(), parametersNode, returnType);\n     JSType existingType = typeRegistry.getType(fnName);\n \n-    if (makesStructs) {\n-      fnType.setStruct();\n-    } else if (makesDicts) {\n-      fnType.setDict();\n-    }\n     if (existingType != null) {\n       boolean isInstanceObject = existingType.isInstanceType();\n       if (isInstanceObject || fnName.equals(\"Function\")) {\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   static final DiagnosticType CONFLICTING_EXTENDED_TYPE =\n       DiagnosticType.warning(\n           \"JSC_CONFLICTING_EXTENDED_TYPE\",\n-          \"{1} cannot extend this type; {0}s can only extend {0}s\");\n+          \"{0} cannot extend this type; \" +\n+          \"a constructor can only extend objects \" +\n+          \"and an interface can only extend interfaces\");\n \n   static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE =\n     DiagnosticType.warning(\n         break;\n \n       case Token.IN:\n-        validator.expectObject(t, n, getJSType(n.getLastChild()),\n-                               \"'in' requires an object\");\n         left = n.getFirstChild();\n-        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n+        right = n.getLastChild();\n+        leftType = getJSType(left);\n+        rightType = getJSType(right);\n+        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n+        validator.expectString(t, left, leftType, \"left side of 'in'\");\n         ensureTyped(t, n, BOOLEAN_TYPE);\n         break;\n \n       case Token.INSTANCEOF:\n         left = n.getFirstChild();\n         right = n.getLastChild();\n+        leftType = getJSType(left);\n         rightType = getJSType(right).restrictByNotNullOrUndefined();\n+\n         validator.expectAnyObject(\n-            t, left, getJSType(left), \"deterministic instanceof yields false\");\n+            t, left, leftType, \"deterministic instanceof yields false\");\n         validator.expectActualObject(\n             t, right, rightType, \"instanceof requires an object\");\n         ensureTyped(t, n, BOOLEAN_TYPE);\n    * @param parent The parent of <code>n</code>\n    */\n   private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n+    // GETPROP nodes have an assigned type on their node by the scope creator\n+    // if this is an enum declaration. The only namespaced enum declarations\n+    // that we allow are of the form object.name = ...;\n+    if (n.getJSType() != null && parent.isAssign()) {\n+      return;\n+    }\n+\n     // obj.prop or obj.method()\n     // Lots of types can appear on the left, a call to a void function can\n     // never be on the left. getPropertyType will decide what is acceptable\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n-    // Do this first b/c we want to check even when the getprop is an lvalue\n-    if (childType.isDict()) {\n-      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      // GETPROP nodes have an assigned type on their node by the scope creator\n-      // if this is an enum declaration. The only namespaced enum declarations\n-      // that we allow are of the form object.name = ...;\n+    // TODO(user): remove in favor of flagging every property access on\n+    // non-object.\n+    if (!validator.expectNotNullOrUndefined(t, n, childType,\n+            \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n+      ensureTyped(t, n);\n       return;\n-    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n-        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n-      checkPropertyAccess(childType, property.getString(), t, n);\n-    }\n+    }\n+\n+    checkPropertyAccess(childType, property.getString(), t, n);\n     ensureTyped(t, n);\n   }\n \n    * @param n The node being visited.\n    */\n   private void visitGetElem(NodeTraversal t, Node n) {\n-    validator.expectIndexMatch(\n-        t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild()));\n+    Node left = n.getFirstChild();\n+    Node right = n.getLastChild();\n+    validator.expectIndexMatch(t, n, getJSType(left), getJSType(right));\n     ensureTyped(t, n);\n   }\n \n     String functionPrivateName = n.getFirstChild().getString();\n     if (functionType.isConstructor()) {\n       FunctionType baseConstructor = functionType.getSuperClassConstructor();\n-      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n-          baseConstructor != null &&\n-          baseConstructor.isInterface() && functionType.isConstructor()) {\n+      if (baseConstructor != null &&\n+          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n+          (baseConstructor.isInterface() && functionType.isConstructor())) {\n         compiler.report(\n-            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n-                        \"constructor\", functionPrivateName));\n+            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n       } else {\n-        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n-            baseConstructor != null) {\n-          if (functionType.makesStructs() && !baseConstructor.makesStructs()) {\n-            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n-                                        \"struct\", functionPrivateName));\n-          } else if (functionType.makesDicts() &&\n-                     !baseConstructor.makesDicts()) {\n-            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n-                                        \"dict\", functionPrivateName));\n-          }\n-        }\n         // All interfaces are properly implemented by a class\n         for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n           boolean badImplementedType = false;\n         if (extInterface.getConstructor() != null\n             && !extInterface.getConstructor().isInterface()) {\n           compiler.report(\n-              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n-                          \"interface\", functionPrivateName));\n+              t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n         }\n       }\n       // Interface cannot implement any interfaces\n    */\n   double getTypedPercent() {\n     int total = nullCount + unknownCount + typedCount;\n-    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;\n+    if (total == 0) {\n+      return 0.0;\n+    } else {\n+      return (100.0 * typedCount) / total;\n+    }\n   }\n \n   private JSType getNativeType(JSTypeNative typeId) {\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n   static final DiagnosticType UNKNOWN_TYPEOF_VALUE =\n       DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\");\n \n-  static final DiagnosticType ILLEGAL_PROPERTY_ACCESS =\n-      DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\",\n-                             \"Cannot do {0} access on a {1}\");\n-\n   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n       INVALID_CAST,\n       TYPE_MISMATCH_WARNING,\n       HIDDEN_PROPERTY_MISMATCH,\n       INTERFACE_METHOD_NOT_IMPLEMENTED,\n       HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n-      UNKNOWN_TYPEOF_VALUE,\n-      ILLEGAL_PROPERTY_ACCESS);\n+      UNKNOWN_TYPEOF_VALUE);\n \n   TypeValidator(AbstractCompiler compiler) {\n     this.compiler = compiler;\n    * @param indexType The type inside the brackets of the GETELEM.\n    */\n   void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n-                        JSType indexType) {\n+      JSType indexType) {\n     Preconditions.checkState(n.isGetElem());\n     Node indexNode = n.getLastChild();\n-    if (objType.isStruct()) {\n-      report(JSError.make(t.getSourceName(), indexNode,\n-                          ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));\n-    }\n     if (objType.isUnknownType()) {\n       expectStringOrNumber(t, indexNode, indexType, \"property access\");\n     } else {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     }\n \n     @Override\n-    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+    public final boolean shouldTraverse(NodeTraversal t, Node n,\n+        Node parent) {\n       inputId = t.getInputId();\n       if (n.isFunction() ||\n           n.isScript()) {\n               .inferTemplateTypeName(info)\n               .inferReturnType(info)\n               .inferInheritance(info);\n+\n \n           // Infer the context type.\n           boolean searchedForThisType = false;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     INTERFACE\n   }\n \n-  // relevant only for constructors\n-  private enum PropAccess { ANY, STRUCT, DICT }\n-\n   /**\n    * {@code [[Call]]} property.\n    */\n   private final Kind kind;\n \n   /**\n-   * Whether the instances are structs, dicts, or unrestricted.\n-   */\n-  private PropAccess propAccess;\n-\n-  /**\n    * The type of {@code this} in the scope of this function.\n    */\n   private ObjectType typeOfThis;\n \n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n-               ArrowType arrowType, ObjectType typeOfThis,\n-               ImmutableList<String> templateTypeNames,\n-               boolean isConstructor, boolean nativeType) {\n+      ArrowType arrowType, ObjectType typeOfThis,\n+      ImmutableList<String> templateTypeNames,\n+      boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n         nativeType);\n         Token.FUNCTION == source.getType());\n     Preconditions.checkNotNull(arrowType);\n     this.source = source;\n+    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n     if (isConstructor) {\n-      this.kind = Kind.CONSTRUCTOR;\n-      this.propAccess = PropAccess.ANY;\n       this.typeOfThis = typeOfThis != null ?\n           typeOfThis : new InstanceObjectType(registry, this, nativeType);\n     } else {\n-      this.kind = Kind.ORDINARY;\n       this.typeOfThis = typeOfThis != null ?\n           typeOfThis :\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n   @Override\n   public boolean isOrdinaryFunction() {\n     return kind == Kind.ORDINARY;\n-  }\n-\n-  /**\n-   * When a class B inherits from A and A is annotated as a struct, then B\n-   * automatically gets the annotation, even if B's constructor is not\n-   * explicitly annotated.\n-   */\n-  public boolean makesStructs() {\n-    if (!isConstructor()) {\n-      return false;\n-    }\n-    if (propAccess == PropAccess.STRUCT) {\n-      return true;\n-    }\n-    FunctionType superc = getSuperClassConstructor();\n-    if (superc != null && superc.makesStructs()) {\n-      setStruct();\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * When a class B inherits from A and A is annotated as a dict, then B\n-   * automatically gets the annotation, even if B's constructor is not\n-   * explicitly annotated.\n-   */\n-  public boolean makesDicts() {\n-    if (!isConstructor()) {\n-      return false;\n-    }\n-    if (propAccess == PropAccess.DICT) {\n-      return true;\n-    }\n-    FunctionType superc = getSuperClassConstructor();\n-    if (superc != null && superc.makesDicts()) {\n-      setDict();\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public void setStruct() {\n-    propAccess = PropAccess.STRUCT;\n-  }\n-\n-  public void setDict() {\n-    propAccess = PropAccess.DICT;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n-   * Returns true iff {@code this} can be a {@code struct}.\n-   * UnionType overrides the method, assume {@code this} is not a union here.\n-   */\n-  public boolean isStruct() {\n-    if (isObject()) {\n-      FunctionType ctor = toObjectType().getConstructor();\n-      // getConstructor can return an *interface* type, so it's not safe to\n-      // assume that makesStructs is only called on constructors.\n-      return ctor != null && ctor.makesStructs();\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * Returns true iff {@code this} can be a {@code dict}.\n-   * UnionType overrides the method, assume {@code this} is not a union here.\n-   */\n-  public boolean isDict() {\n-    if (isObject()) {\n-      FunctionType ctor = toObjectType().getConstructor();\n-      return ctor != null && ctor.makesDicts();\n-    }\n-    return false;\n-  }\n-\n-  /**\n    * Downcasts this to a UnionType, or returns null if this is not a UnionType.\n    *\n    * Named in honor of Haskell's Maybe type constructor.\n   }\n \n   /**\n-   * Turn a scalar type to the corresponding object type.\n-   *\n-   * @return the auto-boxed type or {@code null} if this type is not a scalar.\n+   * Gets the type to which this type auto-boxes.\n+   *\n+   * @return the auto-boxed type or {@code null} if this type does not auto-box\n    */\n   public JSType autoboxesTo() {\n     return null;\n   }\n \n   /**\n-   * Turn an object type to its corresponding scalar type.\n+   * Gets the type to which this type unboxes.\n    *\n    * @return the unboxed type or {@code null} if this type does not unbox.\n    */\n \n   /**\n    * Casts this to an ObjectType, or returns null if this is not an ObjectType.\n-   * If this is a scalar type, it will *not* be converted to an object type.\n-   * If you want to simulate JS autoboxing or dereferencing, you should use\n-   * autoboxesTo() or dereference().\n+   *\n+   * Does not change the underlying JS type. If you want to simulate JS\n+   * autoboxing or dereferencing, you should use autoboxesTo() or dereference().\n+   * Those methods may change the underlying JS type.\n    */\n   public ObjectType toObjectType() {\n     return this instanceof ObjectType ? (ObjectType) this : null;\n   /**\n    * Dereference a type for property access.\n    *\n-   * Filters null/undefined and autoboxes the resulting type.\n-   * Never returns null.\n+   * Autoboxes the type, and filters null/undefined, and returns the result.\n    */\n   public JSType autobox() {\n     JSType restricted = restrictByNotNullOrUndefined();\n   /**\n    * Dereference a type for property access.\n    *\n-   * Filters null/undefined, autoboxes the resulting type, and returns it\n+   * Autoboxes the type, filters null/undefined, and returns the result\n    * iff it's an object.\n    */\n   public final ObjectType dereference() {\n-    return autobox().toObjectType();\n+    return ObjectType.cast(autobox());\n   }\n \n   /**\n     if (thatType.isUnknownType()) {\n       return true;\n     }\n+    // equality\n+    if (thisType.isEquivalentTo(thatType)) {\n+      return true;\n+    }\n     // all type\n     if (thatType.isAllType()) {\n-      return true;\n-    }\n-    // equality\n-    if (thisType.isEquivalentTo(thatType)) {\n       return true;\n     }\n     // unions\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n    * @param returnType the function's return type\n    * @param parameterTypes the parameters' types\n    */\n-  private FunctionType createConstructorTypeWithVarArgs(\n+  public FunctionType createConstructorTypeWithVarArgs(\n       JSType returnType, JSType... parameterTypes) {\n     return createConstructorType(\n         null, null, createParametersWithVarArgs(parameterTypes), returnType);\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     // Find all the interfaces implemented by this class and compare each one\n     // to the interface instance.\n     ObjectType thatObj = that.toObjectType();\n-    FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n-\n-    if (getConstructor() != null && getConstructor().isInterface()) {\n-      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n+    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n+    if (thatCtor != null && thatCtor.isInterface()) {\n+      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n+      for (ObjectType thisInterface : thisInterfaces) {\n         if (thisInterface.isSubtype(that)) {\n           return true;\n         }\n       }\n-    } else if (thatCtor != null && thatCtor.isInterface()) {\n-      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n-      for (ObjectType thisInterface : thisInterfaces) {\n+    }\n+\n+    if (getConstructor() != null && getConstructor().isInterface()) {\n+      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n         if (thisInterface.isSubtype(that)) {\n           return true;\n         }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean isStruct() {\n-    return referencedType.isStruct();\n-  }\n-\n-  @Override\n-  public boolean isDict() {\n-    return referencedType.isDict();\n-  }\n-\n-  @Override\n   public boolean isNativeObjectType() {\n     return referencedObjType == null\n         ? false : referencedObjType.isNativeObjectType();\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n   public boolean isUnknownType() {\n     for (JSType t : alternates) {\n       if (t.isUnknownType()) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean isStruct() {\n-    for (JSType typ : getAlternates()) {\n-      if (typ.isStruct()) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean isDict() {\n-    for (JSType typ : getAlternates()) {\n-      if (typ.isDict()) {\n         return true;\n       }\n     }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   public void testBadImplements2() throws Exception {\n     testTypes(\"/** @interface */function Disposable() {}\\n\" +\n         \"/** @implements {Disposable}\\n */function f() {}\",\n-        \"@implements used without @constructor for f\");\n+        \"@implements used without @constructor or @interface for f\");\n   }\n \n   public void testBadImplements3() throws Exception {\n   public void testBadInterfaceExtends2() throws Exception {\n     testTypes(\"/** @constructor */function A() {}\\n\" +\n         \"/** @interface \\n * @extends {A} */function B() {}\",\n-        \"B cannot extend this type; interfaces can only extend interfaces\");\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n   }\n \n   public void testBadInterfaceExtends3() throws Exception {\n     testTypes(\"/** @interface */function A() {}\\n\" +\n         \"/** @constructor \\n * @extends {A} */function B() {}\",\n-        \"B cannot extend this type; constructors can only extend constructors\");\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n   }\n \n   public void testBadInterfaceExtends4() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testBadImplements2() throws Exception {\n     testTypes(\"/** @interface */function Disposable() {}\\n\" +\n         \"/** @implements {Disposable}\\n */function f() {}\",\n-        \"@implements used without @constructor for f\");\n+        \"@implements used without @constructor or @interface for f\");\n   }\n \n   public void testBadImplements3() throws Exception {\n   public void testBadInterfaceExtends2() throws Exception {\n     testTypes(\"/** @constructor */function A() {}\\n\" +\n         \"/** @interface \\n * @extends {A} */function B() {}\",\n-        \"B cannot extend this type; interfaces can only extend interfaces\");\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n   }\n \n   public void testBadInterfaceExtends3() throws Exception {\n     testTypes(\"/** @interface */function A() {}\\n\" +\n         \"/** @constructor \\n * @extends {A} */function B() {}\",\n-        \"B cannot extend this type; constructors can only extend constructors\");\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n   }\n \n   public void testBadInterfaceExtends4() throws Exception {\n         \"Foo.prototype.bar = function() {\" +\n         \"  if (this.x == null) { this.initX(); alert(this.x.foo); }\" +\n         \"};\");\n-  }\n-\n-  public void testGetpropDict1() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1(){ this['prop'] = 123; }\" +\n-              \"/** @param{Dict1} x */\" +\n-              \"function takesDict(x) { return x.prop; }\",\n-              \"Cannot do '.' access on a dict\");\n-  }\n-\n-  public void testGetpropDict2() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1(){ this['prop'] = 123; }\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @extends {Dict1}\\n\" +\n-              \" */\" +\n-              \"function Dict1kid(){ this['prop'] = 123; }\" +\n-              \"/** @param{Dict1kid} x */\" +\n-              \"function takesDict(x) { return x.prop; }\",\n-              \"Cannot do '.' access on a dict\");\n-  }\n-\n-  public void testGetpropDict3() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1() { this['prop'] = 123; }\" +\n-              \"/** @constructor */\" +\n-              \"function NonDict() { this.prop = 321; }\" +\n-              \"/** @param{(NonDict|Dict1)} x */\" +\n-              \"function takesDict(x) { return x.prop; }\",\n-              \"Cannot do '.' access on a dict\");\n-  }\n-\n-  public void testGetpropDict4() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1() { this['prop'] = 123; }\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1() { this.prop = 123; }\" +\n-              \"/** @param{(Struct1|Dict1)} x */\" +\n-              \"function takesNothing(x) { return x.prop; }\",\n-              \"Cannot do '.' access on a dict\");\n-  }\n-\n-  public void testGetpropDict5() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1(){ this.prop = 123; }\",\n-              \"Cannot do '.' access on a dict\");\n-  }\n-\n-  public void testGetelemStruct1() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1(){ this.prop = 123; }\" +\n-              \"/** @param{Struct1} x */\" +\n-              \"function takesStruct(x) {\" +\n-              \"  var z = x;\" +\n-              \"  return z['prop'];\" +\n-              \"}\",\n-              \"Cannot do '[]' access on a struct\");\n-  }\n-\n-  public void testGetelemStruct2() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1(){ this.prop = 123; }\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @extends {Struct1}\" +\n-              \" */\" +\n-              \"function Struct1kid(){ this.prop = 123; }\" +\n-              \"/** @param{Struct1kid} x */\" +\n-              \"function takesStruct2(x) { return x['prop']; }\",\n-              \"Cannot do '[]' access on a struct\");\n-  }\n-\n-  public void testGetelemStruct3() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1(){ this.prop = 123; }\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @extends {Struct1}\\n\" +\n-              \" */\" +\n-              \"function Struct1kid(){ this.prop = 123; }\" +\n-              \"var x = (new Struct1kid())['prop'];\",\n-              \"Cannot do '[]' access on a struct\");\n-  }\n-\n-  public void testGetelemStruct4() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1() { this.prop = 123; }\" +\n-              \"/** @constructor */\" +\n-              \"function NonStruct() { this.prop = 321; }\" +\n-              \"/** @param{(NonStruct|Struct1)} x */\" +\n-              \"function takesStruct(x) { return x['prop']; }\",\n-              \"Cannot do '[]' access on a struct\");\n-  }\n-\n-  public void testGetelemStruct5() throws Exception {\n-    testTypes(\"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" */\" +\n-              \"function Struct1() { this.prop = 123; }\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" */\" +\n-              \"function Dict1() { this['prop'] = 123; }\" +\n-              \"/** @param{(Struct1|Dict1)} x */\" +\n-              \"function takesNothing(x) { return x['prop']; }\",\n-              \"Cannot do '[]' access on a struct\");\n-  }\n-\n-  public void testGetelemStruct6() throws Exception {\n-    // By casting Bar to Foo, the illegal bracket access is not detected\n-    testTypes(\"/** @interface */ function Foo(){}\\n\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" * @implements {Foo}\\n\" +\n-              \" */\" +\n-              \"function Bar(){ this.x = 123; }\\n\" +\n-              \"var z = /** @type {Foo} */(new Bar)['x'];\");\n   }\n \n   public void testArrayAccess1() throws Exception {\n         \"}\");\n   }\n \n-  public void testConstructorType10() throws Exception {\n-    testTypes(\"/** @constructor */\" +\n-              \"function NonStr() {}\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @struct\\n\" +\n-              \" * @extends{NonStr}\\n\" +\n-              \" */\" +\n-              \"function NonStrKid() {}\",\n-              \"NonStrKid cannot extend this type; \" +\n-              \"structs can only extend structs\");\n-  }\n-\n-  public void testConstructorType11() throws Exception {\n-    testTypes(\"/** @constructor */\" +\n-              \"function NonDict() {}\" +\n-              \"/**\\n\" +\n-              \" * @constructor\\n\" +\n-              \" * @dict\\n\" +\n-              \" * @extends{NonDict}\\n\" +\n-              \" */\" +\n-              \"function NonDictKid() {}\",\n-              \"NonDictKid cannot extend this type; \" +\n-              \"dicts can only extend dicts\");\n-  }\n-\n-  public void testBadStruct() throws Exception {\n-    testTypes(\"/** @struct */function Struct1() {}\",\n-              \"@struct used without @constructor for Struct1\");\n-  }\n-\n-  public void testBadDict() throws Exception {\n-    testTypes(\"/** @dict */function Dict1() {}\",\n-              \"@dict used without @constructor for Dict1\");\n-  }\n-\n   public void testAnonymousPrototype1() throws Exception {\n     testTypes(\n         \"var ns = {};\" +\n         \"/** @desc description @ return {string} x */\" +\n         \"/** @interface \\n @extends {Int0} \\n @extends {Int1} */\" +\n         \"function Int2() {};\",\n-        \"Int2 cannot extend this type; interfaces can only extend interfaces\");\n+        \"Int2 cannot extend this type; a constructor can only extend \" +\n+        \"objects and an interface can only extend interfaces\");\n   }\n \n   public void testMultipleExtendsInterface6() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     assertFalse(U2U_CONSTRUCTOR_TYPE.isStringValueType());\n     assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumType());\n     assertFalse(U2U_CONSTRUCTOR_TYPE.isUnionType());\n-    assertFalse(U2U_CONSTRUCTOR_TYPE.isStruct());\n-    assertFalse(U2U_CONSTRUCTOR_TYPE.isDict());\n     assertFalse(U2U_CONSTRUCTOR_TYPE.isAllType());\n     assertFalse(U2U_CONSTRUCTOR_TYPE.isVoidType());\n     assertTrue(U2U_CONSTRUCTOR_TYPE.isConstructor());\n     assertFalse(NO_OBJECT_TYPE.isStringValueType());\n     assertFalse(NO_OBJECT_TYPE.isEnumType());\n     assertFalse(NO_OBJECT_TYPE.isUnionType());\n-    assertFalse(NO_OBJECT_TYPE.isStruct());\n-    assertFalse(NO_OBJECT_TYPE.isDict());\n     assertFalse(NO_OBJECT_TYPE.isAllType());\n     assertFalse(NO_OBJECT_TYPE.isVoidType());\n     assertTrue(NO_OBJECT_TYPE.isConstructor());\n     assertFalse(NO_TYPE.isStringValueType());\n     assertFalse(NO_TYPE.isEnumType());\n     assertFalse(NO_TYPE.isUnionType());\n-    assertFalse(NO_TYPE.isStruct());\n-    assertFalse(NO_TYPE.isDict());\n     assertFalse(NO_TYPE.isAllType());\n     assertFalse(NO_TYPE.isVoidType());\n     assertTrue(NO_TYPE.isConstructor());\n     assertFalse(NO_RESOLVED_TYPE.isStringValueType());\n     assertFalse(NO_RESOLVED_TYPE.isEnumType());\n     assertFalse(NO_RESOLVED_TYPE.isUnionType());\n-    assertFalse(NO_RESOLVED_TYPE.isStruct());\n-    assertFalse(NO_RESOLVED_TYPE.isDict());\n     assertFalse(NO_RESOLVED_TYPE.isAllType());\n     assertFalse(NO_RESOLVED_TYPE.isVoidType());\n     assertTrue(NO_RESOLVED_TYPE.isConstructor());\n     assertFalse(ARRAY_TYPE.isStringValueType());\n     assertFalse(ARRAY_TYPE.isEnumType());\n     assertFalse(ARRAY_TYPE.isUnionType());\n-    assertFalse(ARRAY_TYPE.isStruct());\n-    assertFalse(ARRAY_TYPE.isDict());\n     assertFalse(ARRAY_TYPE.isAllType());\n     assertFalse(ARRAY_TYPE.isVoidType());\n     assertFalse(ARRAY_TYPE.isConstructor());\n     assertFalse(UNKNOWN_TYPE.isStringValueType());\n     assertFalse(UNKNOWN_TYPE.isEnumType());\n     assertFalse(UNKNOWN_TYPE.isUnionType());\n-    assertFalse(UNKNOWN_TYPE.isStruct());\n-    assertFalse(UNKNOWN_TYPE.isDict());\n     assertTrue(UNKNOWN_TYPE.isUnknownType());\n     assertFalse(UNKNOWN_TYPE.isVoidType());\n     assertFalse(UNKNOWN_TYPE.isConstructor());\n     assertFalse(ALL_TYPE.isStringValueType());\n     assertFalse(ALL_TYPE.isEnumType());\n     assertFalse(ALL_TYPE.isUnionType());\n-    assertFalse(ALL_TYPE.isStruct());\n-    assertFalse(ALL_TYPE.isDict());\n     assertTrue(ALL_TYPE.isAllType());\n     assertFalse(ALL_TYPE.isVoidType());\n     assertFalse(ALL_TYPE.isConstructor());\n     assertFalse(OBJECT_TYPE.isStringValueType());\n     assertFalse(OBJECT_TYPE.isEnumType());\n     assertFalse(OBJECT_TYPE.isUnionType());\n-    assertFalse(OBJECT_TYPE.isStruct());\n-    assertFalse(OBJECT_TYPE.isDict());\n     assertFalse(OBJECT_TYPE.isAllType());\n     assertFalse(OBJECT_TYPE.isVoidType());\n     assertFalse(OBJECT_TYPE.isConstructor());\n     assertFalse(NUMBER_OBJECT_TYPE.isStringValueType());\n     assertFalse(NUMBER_OBJECT_TYPE.isEnumType());\n     assertFalse(NUMBER_OBJECT_TYPE.isUnionType());\n-    assertFalse(NUMBER_OBJECT_TYPE.isStruct());\n-    assertFalse(NUMBER_OBJECT_TYPE.isDict());\n     assertFalse(NUMBER_OBJECT_TYPE.isAllType());\n     assertFalse(NUMBER_OBJECT_TYPE.isVoidType());\n     assertFalse(NUMBER_OBJECT_TYPE.isConstructor());\n     assertFalse(NUMBER_TYPE.isStringValueType());\n     assertFalse(NUMBER_TYPE.isEnumType());\n     assertFalse(NUMBER_TYPE.isUnionType());\n-    assertFalse(NUMBER_TYPE.isStruct());\n-    assertFalse(NUMBER_TYPE.isDict());\n     assertFalse(NUMBER_TYPE.isAllType());\n     assertFalse(NUMBER_TYPE.isVoidType());\n     assertFalse(NUMBER_TYPE.isConstructor());\n     assertFalse(NULL_TYPE.isStringValueType());\n     assertFalse(NULL_TYPE.isEnumType());\n     assertFalse(NULL_TYPE.isUnionType());\n-    assertFalse(NULL_TYPE.isStruct());\n-    assertFalse(NULL_TYPE.isDict());\n     assertFalse(NULL_TYPE.isAllType());\n     assertFalse(NULL_TYPE.isVoidType());\n     assertFalse(NULL_TYPE.isConstructor());\n     assertFalse(DATE_TYPE.isStringValueType());\n     assertFalse(DATE_TYPE.isEnumType());\n     assertFalse(DATE_TYPE.isUnionType());\n-    assertFalse(DATE_TYPE.isStruct());\n-    assertFalse(DATE_TYPE.isDict());\n     assertFalse(DATE_TYPE.isAllType());\n     assertFalse(DATE_TYPE.isVoidType());\n     assertFalse(DATE_TYPE.isConstructor());\n     assertFalse(REGEXP_TYPE.isStringValueType());\n     assertFalse(REGEXP_TYPE.isEnumType());\n     assertFalse(REGEXP_TYPE.isUnionType());\n-    assertFalse(REGEXP_TYPE.isStruct());\n-    assertFalse(REGEXP_TYPE.isDict());\n     assertFalse(REGEXP_TYPE.isAllType());\n     assertFalse(REGEXP_TYPE.isVoidType());\n \n     assertFalse(STRING_OBJECT_TYPE.isStringValueType());\n     assertFalse(STRING_OBJECT_TYPE.isEnumType());\n     assertFalse(STRING_OBJECT_TYPE.isUnionType());\n-    assertFalse(STRING_OBJECT_TYPE.isStruct());\n-    assertFalse(STRING_OBJECT_TYPE.isDict());\n     assertFalse(STRING_OBJECT_TYPE.isAllType());\n     assertFalse(STRING_OBJECT_TYPE.isVoidType());\n     assertFalse(STRING_OBJECT_TYPE.isConstructor());\n     assertTrue(STRING_TYPE.isStringValueType());\n     assertFalse(STRING_TYPE.isEnumType());\n     assertFalse(STRING_TYPE.isUnionType());\n-    assertFalse(STRING_TYPE.isStruct());\n-    assertFalse(STRING_TYPE.isDict());\n     assertFalse(STRING_TYPE.isAllType());\n     assertFalse(STRING_TYPE.isVoidType());\n     assertFalse(STRING_TYPE.isConstructor());\n     assertFalse(BOOLEAN_TYPE.isStringValueType());\n     assertFalse(BOOLEAN_TYPE.isEnumType());\n     assertFalse(BOOLEAN_TYPE.isUnionType());\n-    assertFalse(BOOLEAN_TYPE.isStruct());\n-    assertFalse(BOOLEAN_TYPE.isDict());\n     assertFalse(BOOLEAN_TYPE.isAllType());\n     assertFalse(BOOLEAN_TYPE.isVoidType());\n     assertFalse(BOOLEAN_TYPE.isConstructor());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isStringValueType());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isEnumType());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isUnionType());\n-    assertFalse(BOOLEAN_OBJECT_TYPE.isStruct());\n-    assertFalse(BOOLEAN_OBJECT_TYPE.isDict());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isAllType());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isVoidType());\n     assertFalse(BOOLEAN_OBJECT_TYPE.isConstructor());\n     assertFalse(enumType.isStringValueType());\n     assertTrue(enumType.isEnumType());\n     assertFalse(enumType.isUnionType());\n-    assertFalse(enumType.isStruct());\n-    assertFalse(enumType.isDict());\n     assertFalse(enumType.isAllType());\n     assertFalse(enumType.isVoidType());\n     assertFalse(enumType.isConstructor());\n     assertFalse(elementsType.isStringValueType());\n     assertFalse(elementsType.isEnumType());\n     assertFalse(elementsType.isUnionType());\n-    assertFalse(elementsType.isStruct());\n-    assertFalse(elementsType.isDict());\n     assertFalse(elementsType.isAllType());\n     assertFalse(elementsType.isVoidType());\n     assertFalse(elementsType.isConstructor());", "timestamp": 1347389564, "metainfo": ""}