{"sha": "00995a24f8cc4fc91c279165f14ffb6fe08f6d95", "log": "Add a sanity-check pass for tracking when symbols are added/removed in a compilation job.  I'm not sure yet how we want to expose this, but I found it useful when debugging locally.  R=johnlenz DELTA=106  (91 added, 6 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5515   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n import java.util.List;\n import java.util.Map;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * An abstract compiler, to help remove the circular dependency of\n  * passes on JSCompiler.\n    */\n   public abstract double getProgress();\n \n-  /** Sets the progress to a certain value in [0,1] range. */\n-  abstract void setProgress(double progress);\n+  /**\n+   * Gets the last pass name set by setProgress.\n+   */\n+  abstract String getLastPassName();\n+\n+  /**\n+   * Sets the progress percentage as well as the name of the last pass that\n+   * ran (if available).\n+   * @param progress A precentage expressed as a double in the range [0, 1].\n+   *     Use -1 if you just want to set the last pass name.\n+   */\n+  abstract void setProgress(double progress, @Nullable String lastPassName);\n \n   /**\n    * The subdir js/ contains libraries of code that we inject\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.base.Throwables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.common.io.CharStreams;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n   private GlobalVarReferenceMap globalRefMap = null;\n \n   private volatile double progress = 0.0;\n+  private String lastPassName;\n \n   /**\n    * Creates a Compiler that reports errors and warnings to its logger.\n   }\n \n   private void compileInternal() {\n-    setProgress(0.0);\n+    setProgress(0.0, null);\n     parse();\n     // 15 percent of the work is assumed to be for parsing (based on some\n     // minimal analysis on big JS projects, of course this depends on options)\n-    setProgress(0.15);\n+    setProgress(0.15, \"parse\");\n     if (hasErrors()) {\n       return;\n     }\n     if (options.devMode == DevMode.START_AND_END) {\n       runSanityCheck();\n     }\n-    setProgress(1.0);\n+    setProgress(1.0, \"recordFunctionInformation\");\n   }\n \n   public void parse() {\n   }\n \n   @Override\n-  void setProgress(double newProgress) {\n+  String getLastPassName() {\n+    return lastPassName;\n+  }\n+\n+  @Override\n+  void setProgress(double newProgress, String passName) {\n+    this.lastPassName = passName;\n     if (newProgress > 1.0) {\n       progress = 1.0;\n-    } else if (newProgress < 0.0) {\n-      progress = 0.0;\n     } else {\n       progress = newProgress;\n     }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.jstype.StaticSymbolTable;\n \n+import java.io.PrintStream;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n       return new Ref(type, -1);\n     }\n   }\n+\n+\n+  /**\n+   * An experimental compiler pass for tracking what symbols were added/removed\n+   * at each stage of compilation.\n+   *\n+   * When \"global namespace tracker\" mode is on, we rebuild the global namespace\n+   * after each pass, and diff it against the last namespace built.\n+   */\n+  static class Tracker implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+    private final PrintStream stream;\n+    private final Predicate<String> isInterestingSymbol;\n+\n+    private Set<String> previousSymbolsInTree = ImmutableSet.of();\n+\n+    /**\n+       @param stream The stream to print logs to.\n+     * @param isInterestingSymbol A predicate to determine which symbols\n+     *     we care about.\n+     */\n+    Tracker(AbstractCompiler compiler, PrintStream stream,\n+        Predicate<String> isInterestingSymbol) {\n+      this.compiler = compiler;\n+      this.stream = stream;\n+      this.isInterestingSymbol = isInterestingSymbol;\n+    }\n+\n+    @Override public void process(Node externs, Node root) {\n+      GlobalNamespace namespace = new GlobalNamespace(compiler, externs, root);\n+\n+      Set<String> currentSymbols = Sets.newTreeSet();\n+      for (String name : namespace.getNameIndex().keySet()) {\n+        if (isInterestingSymbol.apply(name)) {\n+          currentSymbols.add(name);\n+        }\n+      }\n+\n+      String passName = compiler.getLastPassName();\n+      if (passName == null) {\n+        passName = \"[Unknown pass]\";\n+      }\n+\n+      for (String sym : currentSymbols) {\n+        if (!previousSymbolsInTree.contains(sym)) {\n+          stream.println(String.format(\"%s: Added by %s\", sym, passName));\n+        }\n+      }\n+\n+      for (String sym : previousSymbolsInTree) {\n+        if (!currentSymbols.contains(sym)) {\n+          stream.println(String.format(\"%s: Removed by %s\", sym, passName));\n+        }\n+      }\n+\n+      previousSymbolsInTree = currentSymbols;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   private String currentPassName = null;\n   private PassFactory sanityCheck = null;\n \n+  private double progress = 0.0;\n+  private double progressStep = 0.0;\n+\n   // The following static properties are only used for computing optimal\n   // phase orderings. They should not be touched by normal compiler runs.\n   private static boolean randomizeLoops = false;\n    */\n   @Override\n   public void process(Node externs, Node root) {\n-    double progress = 0.0;\n-    double progressStep = 0.0;\n+    progress = 0.0;\n+    progressStep = 0.0;\n     if (progressRange != null) {\n       progressStep = (progressRange.maxValue - progressRange.initialValue)\n           / passes.size();\n       progress = progressRange.initialValue;\n     }\n+\n     for (CompilerPass pass : passes) {\n       pass.process(externs, root);\n-      if (progressRange != null) {\n-        progress += progressStep;\n-        compiler.setProgress(progress);\n-      }\n       if (hasHaltingErrors()) {\n         return;\n       }\n \n     String passToCheck = currentPassName;\n     try {\n+      if (progressRange == null) {\n+        compiler.setProgress(-1, currentPassName);\n+      } else {\n+        progress += progressStep;\n+        compiler.setProgress(progress, currentPassName);\n+      }\n       stopTracer(currentTracer, currentPassName);\n       currentPassName = null;\n       currentTracer = null;\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n   public void testProgress() {\n     final List<Double> progressList = Lists.newArrayList();\n     compiler = new Compiler() {\n-      @Override void setProgress(double p) {\n+      @Override void setProgress(double p, String name) {\n         progressList.add(p);\n       }\n     };", "timestamp": 1348066508, "metainfo": ""}