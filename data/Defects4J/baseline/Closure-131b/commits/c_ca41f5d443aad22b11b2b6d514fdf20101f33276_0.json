{"sha": "ca41f5d443aad22b11b2b6d514fdf20101f33276", "log": "Split \"+=\" and friends early and fold it late. Fixes issue 550.  R=acleung DELTA=114  (109 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3671   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.ASSIGN_MOD:\n         return Token.MOD;\n     }\n-    throw new IllegalArgumentException(\"Not an assiment op\");\n+    throw new IllegalArgumentException(\"Not an assiment op:\" + n);\n   }\n \n   static boolean isExpressionNode(Node n) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n       case Token.ASSIGN:\n         return tryFoldAssign(subtree, left, right);\n+\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_MOD:\n+        return tryUnfoldAssignOp(subtree, left, right);\n \n       case Token.ADD:\n         return tryFoldAdd(subtree, left, right);\n   private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n \n+    if (!late) {\n+      return n;\n+    }\n+\n     // Tries to convert x = x + y -> x += y;\n     if (!right.hasChildren() ||\n         right.getFirstChild().getNext() != right.getLastChild()) {\n     reportCodeChange();\n \n     return newNode;\n+  }\n+\n+  private Node tryUnfoldAssignOp(Node n, Node left, Node right) {\n+    if (late) {\n+      return n;\n+    }\n+\n+    if (!n.hasChildren() ||\n+        n.getFirstChild().getNext() != n.getLastChild()) {\n+      return n;\n+    }\n+\n+    if (mayHaveSideEffects(left)) {\n+      return n;\n+    }\n+\n+    // Tries to convert x += y -> x = x + y;\n+    int op = NodeUtil.getOpFromAssignmentOp(n);\n+    Node replacement = new Node(Token.ASSIGN, left.detachFromParent(),\n+        new Node(op, left.cloneTree(), right.detachFromParent())\n+            .useSourceInfoFrom(n));\n+    n.getParent().replaceChild(n, replacement);\n+    reportCodeChange();\n+\n+    return replacement;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = 12 | NaN\", \"x=12\");\n   }\n \n-  public void testFoldingMixTypes() {\n+  public void testFoldingMixTypesLate() {\n+    late = true;\n     fold(\"x = x + '2'\", \"x+='2'\");\n     fold(\"x = +x + +'2'\", \"x = +x + 2\");\n     fold(\"x = x - '2'\", \"x-=2\");\n     fold(\"x = '2' ^ x\", \"x^=2\");\n     fold(\"x = '2' & x\", \"x&=2\");\n     fold(\"x = '2' | x\", \"x|=2\");\n+\n+    fold(\"x = '2' | y\", \"x=2|y\");\n+    fold(\"x = y | '2'\", \"x=y|2\");\n+    fold(\"x = y | (a && '2')\", \"x=y|(a&&2)\");\n+    fold(\"x = y | (a,'2')\", \"x=y|(a,2)\");\n+    fold(\"x = y | (a?'1':'2')\", \"x=y|(a?1:2)\");\n+    fold(\"x = y | ('x'?'1':'2')\", \"x=y|('x'?1:2)\");\n+  }\n+\n+  public void testFoldingMixTypesEarly() {\n+    late = false;\n+    foldSame(\"x = x + '2'\");\n+    fold(\"x = +x + +'2'\", \"x = +x + 2\");\n+    fold(\"x = x - '2'\", \"x = x - 2\");\n+    fold(\"x = x ^ '2'\", \"x = x ^ 2\");\n+    fold(\"x = '2' ^ x\", \"x = 2 ^ x\");\n+    fold(\"x = '2' & x\", \"x = 2 & x\");\n+    fold(\"x = '2' | x\", \"x = 2 | x\");\n \n     fold(\"x = '2' | y\", \"x=2|y\");\n     fold(\"x = y | '2'\", \"x=y|2\");\n     fold(\"print(1/2)\", \"print(0.5)\");\n   }\n \n-  public void testAssignOps() {\n+  public void testAssignOpsLate() {\n+    late = true;\n     fold(\"x=x+y\", \"x+=y\");\n     foldSame(\"x=y+x\");\n     fold(\"x=x*y\", \"x*=y\");\n     fold(\"x=y*x\", \"x*=y\");\n     fold(\"x.y=x.y+z\", \"x.y+=z\");\n     foldSame(\"next().x = next().x + 1\");\n+    // This is ok, really.\n+    fold(\"({a:1}).a = ({a:1}).a + 1\", \"({a:1}).a = 2\");\n+  }\n+\n+ public void testAssignOpsEarly() {\n+    late = false;\n+    foldSame(\"x=x+y\");\n+    foldSame(\"x=y+x\");\n+    foldSame(\"x=x*y\");\n+    foldSame(\"x=y*x\");\n+    foldSame(\"x.y=x.y+z\");\n+    foldSame(\"next().x = next().x + 1\");\n+\n+    foldSame(\"x=x-y\");\n+    foldSame(\"x=y-x\");\n+    foldSame(\"x=x|y\");\n+    foldSame(\"x=y|x\");\n+    foldSame(\"x=x*y\");\n+    foldSame(\"x=y*x\");\n+    foldSame(\"x.y=x.y+z\");\n+    foldSame(\"next().x = next().x + 1\");\n+    // This is ok, really.\n+    fold(\"({a:1}).a = ({a:1}).a + 1\", \"({a:1}).a = 2\");\n   }\n \n   public void testFoldAdd1() {\n     testSame(\"(![foo()])\");\n   }\n \n-  public void testFoldObjectLiteralRef() {\n+  public void testFoldObjectLiteralRef1() {\n     // Leave extra side-effects in place\n     testSame(\"var x = ({a:foo(),b:bar()}).a\");\n     testSame(\"var x = ({a:1,b:bar()}).a\");\n \n     // on the LHS the object act as a temporary leave it in place.\n     testSame(\"({a:x}).a = 1\");\n-    testSame(\"({a:x}).a += 1\");\n+    test(\"({a:x}).a += 1\", \"({a:x}).a = x + 1\");\n     testSame(\"({a:x}).a ++\");\n     testSame(\"({a:x}).a --\");\n \n \n     // GETELEM is handled the same way.\n     test(\"var x = ({'a':1})['a']\", \"var x = 1\");\n+  }\n+\n+  public void testFoldObjectLiteralRef2() {\n+    late = false;\n+    test(\"({a:x}).a += 1\", \"({a:x}).a = x + 1\");\n+    late = true;\n+    testSame(\"({a:x}).a += 1\");\n   }\n \n   public void testIEString() {", "timestamp": 1320862097, "metainfo": ""}