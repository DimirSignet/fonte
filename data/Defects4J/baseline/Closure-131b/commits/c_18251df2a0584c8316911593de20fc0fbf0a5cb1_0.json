{"sha": "18251df2a0584c8316911593de20fc0fbf0a5cb1", "log": "Always declare a symbol for 'this', even if there are no references to it. This almost gets the new JS indexer up to feature parity with the old one. This makes some fundamental changes in how \"this\" is represented in the SymbolTable codegraph, and I think this should make the code a lot more flexible, so that we can expose \"this\" in many different ways without changes to jscompiler.  R=stevey,acleung DELTA=399  (227 added, 75 deleted, 97 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3564   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     }\n \n     symbolTable.fillNamespaceReferences();\n+    symbolTable.fillPropertyScopes();\n     symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n     symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n     symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n     return Collections.unmodifiableCollection(symbol.references.values());\n   }\n \n+  public List<Reference> getReferenceList(Symbol symbol) {\n+    return ImmutableList.copyOf(symbol.references.values());\n+  }\n+\n   @Override\n   public Iterable<Symbol> getAllSymbols() {\n     return Collections.unmodifiableCollection(symbols.values());\n    */\n   public Symbol declareInferredSymbol(\n       SymbolScope scope, String name, Node declNode) {\n-    Symbol symbol = new Symbol(name, null, true, scope);\n-    symbols.put(declNode, name, symbol);\n-\n-    Symbol replacement = scope.ownSymbols.put(name, symbol);\n-    Preconditions.checkState(replacement == null, \"duplicate symbol\");\n-\n-    symbol.setDeclaration(new Reference(symbol, declNode));\n-    return symbol;\n+    return declareSymbol(name, null, true, scope, declNode, null);\n   }\n \n   /**\n    * scope.\n    */\n   public Symbol getSymbolForScope(SymbolScope scope) {\n-    if (scope.isPropertyScope()) {\n-      return getSymbolForTypeHelper(scope.getTypeOfThis(), false);\n-    }\n-\n+    if (scope.getSymbolForScope() == null) {\n+      scope.setSymbolForScope(findSymbolForScope(scope));\n+    }\n+    return scope.getSymbolForScope();\n+  }\n+\n+  /**\n+   * Find the symbol associated with the given scope.\n+   * Notice that we won't always be able to figure out this association\n+   * dynamically, so sometimes we'll just create the association when we\n+   * create the scope.\n+   */\n+  private Symbol findSymbolForScope(SymbolScope scope) {\n     Node rootNode = scope.getRootNode();\n+    if (rootNode.getParent() == null) {\n+      return globalScope.getSlot(GLOBAL_THIS);\n+    }\n+\n     if (rootNode.getType() != Token.FUNCTION) {\n       return null;\n     }\n         sym.getJSDocInfo());\n   }\n \n+  private Symbol addSymbol(\n+      String name, JSType type, boolean inferred, SymbolScope scope,\n+      Node declNode) {\n+    Symbol symbol = new Symbol(name, type, inferred, scope);\n+    symbols.put(declNode, name, symbol);\n+\n+    Symbol replacedSymbol = scope.ownSymbols.put(name, symbol);\n+    Preconditions.checkState(replacedSymbol == null);\n+    return symbol;\n+  }\n+\n   private Symbol declareSymbol(\n       String name, JSType type, boolean inferred,\n       SymbolScope scope, Node declNode, JSDocInfo info) {\n-    Symbol symbol = new Symbol(name, type, inferred, scope);\n+    Symbol symbol = addSymbol(name, type, inferred, scope, declNode);\n     symbol.setJSDocInfo(info);\n-    symbols.put(declNode, name, symbol);\n-\n-    Symbol replacedSymbol = scope.ownSymbols.put(name, symbol);\n-    Preconditions.checkState(replacedSymbol == null);\n-\n-    symbol.setDeclaration(new Reference(symbol, declNode));\n+    symbol.setDeclaration(symbol.defineReferenceAt(declNode));\n     return symbol;\n   }\n \n           }\n         }\n       }\n+    }\n+  }\n+\n+  void fillPropertyScopes() {\n+    // Collect all object symbols.\n+    List<Symbol> types = Lists.newArrayList();\n+    for (Symbol sym : getAllSymbols()) {\n+      JSType type = sym.getType();\n+      ObjectType dereferenced = type == null ? null : type.dereference();\n+      if (dereferenced != null) {\n+        types.add(sym);\n+      }\n+    }\n+\n+    // Create a property scope for each symbol, and populate\n+    // it with that symbol's properties.\n+    //\n+    // The order of operations here is significant.\n+    //\n+    // When we add properties to Foo, we'll remove Foo.prototype from\n+    // the symbol table and replace it with a fresh symbol in Foo's\n+    // property scope. So the symbol for Foo.prototype in\n+    // {@code instances} will be stale.\n+    //\n+    // To prevent this, we sort the list by the reverse of the\n+    // default symbol order, which will do the right thing.\n+    Collections.sort(types,\n+        Collections.reverseOrder(getNaturalSymbolOrdering()));\n+    for (Symbol s : types) {\n+      createPropertyScopeFor(s);\n     }\n   }\n \n    */\n   void fillPropertySymbols(\n       AbstractCompiler compiler, Node externs, Node root) {\n-    // Collect all ctors and interface ctors.\n-    // We need to create these lists first, so that we don't end up\n-    // mutating the symbol table while we're creating new symbols.\n-    List<Symbol> types = Lists.newArrayList();\n-    List<Symbol> instances = Lists.newArrayList();\n-    for (Symbol sym : getAllSymbols()) {\n-      FunctionType t = sym.getFunctionType();\n-      if (t != null && t.isNominalConstructor()) {\n-        types.add(sym);\n-\n-        Symbol instance = getSymbolForInstancesOf(t);\n-        if (instance != null) {\n-          instances.add(instance);\n-        }\n-      }\n-    }\n-\n-    // Create a property scope for each symbol, and populate\n-    // it with that symbol's properties.\n-    //\n-    // The order of operations here is significant.\n-    //\n-    // When we add properties to Foo, we'll remove Foo.prototype from\n-    // the symbol table and replace it with a fresh symbol in Foo's\n-    // property scope. So the symbol for Foo.prototype in\n-    // {@code instances} will be stale.\n-    //\n-    // To prevent this, we always populate {@code instances} before\n-    // their constructors.\n-    for (Symbol s : instances) {\n-      createPropertyScopeFor(s);\n-    }\n-\n-    for (Symbol s : types) {\n-      createPropertyScopeFor(s);\n-    }\n-\n     (new PropertyRefCollector(compiler)).process(externs, root);\n   }\n \n     }\n   }\n \n+  /**\n+   * Build a property scope for the given symbol. Any properties of the symbol\n+   * will be added to the property scope.\n+   *\n+   * It is important that property scopes are created in order from the leaves\n+   * up to the root, so this should only be called from #fillPropertyScopes.\n+   * If you try to create a property scope for a parent before its leaf,\n+   * then the leaf will get cut and re-added to the parent property scope,\n+   * and weird things will happen.\n+   */\n   private void createPropertyScopeFor(Symbol s) {\n     // In order to build a property scope for s, we will need to build\n     // a property scope for all its implicit prototypes first. This means\n     }\n \n     SymbolScope parentPropertyScope = null;\n-    ObjectType type = s.getType().toObjectType();\n+    ObjectType type = s.getType() == null ? null : s.getType().toObjectType();\n+    if (type == null) {\n+      return;\n+    }\n+\n     ObjectType proto = type.getParentScope();\n     if (proto != null && proto != type && proto.getConstructor() != null) {\n       Symbol parentSymbol = getSymbolForInstancesOf(proto.getConstructor());\n       propNames = set;\n     }\n \n-    s.propertyScope = new SymbolScope(null, parentPropertyScope, type);\n+    s.setPropertyScope(new SymbolScope(null, parentPropertyScope, type, s));\n     for (String propName : propNames) {\n       StaticSlot<JSType> newProp = instanceType.getSlot(propName);\n       if (newProp.getDeclaration() == null) {\n         if (newSym.getJSDocInfo() == null) {\n           newSym.setJSDocInfo(oldProp.getJSDocInfo());\n         }\n-        newSym.propertyScope = oldProp.propertyScope;\n+        newSym.setPropertyScope(oldProp.propertyScope);\n         for (Reference ref : oldProp.references.values()) {\n           newSym.defineReferenceAt(ref.getNode());\n         }\n       myScope = new SymbolScope(\n           otherScopeRoot,\n           otherScopeParent == null ? null : createScopeFrom(otherScopeParent),\n-          otherScope.getTypeOfThis());\n+          otherScope.getTypeOfThis(),\n+          null);\n       scopes.put(otherScopeRoot, myScope);\n       if (myScope.isGlobalScope()) {\n         globalScope = myScope;\n       return JSType.toMaybeFunctionType(getType());\n     }\n \n-    public void defineReferenceAt(Node n) {\n-      if (!references.containsKey(n)) {\n-        references.put(n, new Reference(this, n));\n-      }\n+    public Reference defineReferenceAt(Node n) {\n+      Reference result = references.get(n);\n+      if (result == null) {\n+        result = new Reference(this, n);\n+        references.put(n, result);\n+      }\n+      return result;\n     }\n \n     /** Sets the declaration node. May only be called once. */\n     void setDeclaration(Reference ref) {\n       Preconditions.checkState(this.declaration == null);\n       this.declaration = ref;\n-      references.put(ref.getNode(), ref);\n     }\n \n     public boolean inGlobalScope() {\n \n     public SymbolScope getPropertyScope() {\n       return propertyScope;\n+    }\n+\n+    void setPropertyScope(SymbolScope scope) {\n+      this.propertyScope = scope;\n+      if (scope != null) {\n+        this.propertyScope.setSymbolForScope(this);\n+      }\n     }\n \n     @Override\n     private final Map<String, Symbol> ownSymbols = Maps.newHashMap();\n     private final int scopeDepth;\n \n+    // The symbol associated with a property scope.\n+    private Symbol mySymbol;\n+\n     SymbolScope(\n         Node rootNode,\n         @Nullable SymbolScope parent,\n-        JSType typeOfThis) {\n+        JSType typeOfThis,\n+        Symbol mySymbol) {\n       this.rootNode = rootNode;\n       this.parent = parent;\n       this.typeOfThis = typeOfThis;\n       this.scopeDepth = parent == null ? 0 : (parent.getScopeDepth() + 1);\n+      this.mySymbol = mySymbol;\n+    }\n+\n+    Symbol getSymbolForScope() {\n+      return mySymbol;\n+    }\n+\n+    void setSymbolForScope(Symbol sym) {\n+      this.mySymbol = sym;\n     }\n \n     @Override\n   }\n \n   private class ThisRefCollector\n-      extends NodeTraversal.AbstractPostOrderCallback\n+      extends NodeTraversal.AbstractScopedCallback\n       implements CompilerPass {\n     private final AbstractCompiler compiler;\n+\n+    // The 'this' symbols in the current scope chain.\n+    //\n+    // If we don't know how to declare 'this' in a scope chain,\n+    // then null should be on the stack. But this should be a rare\n+    // occurrence. We should strive to always be able to come up\n+    // with some symbol for 'this'.\n+    private final List<Symbol> thisStack = Lists.newArrayList();\n \n     ThisRefCollector(AbstractCompiler compiler) {\n       this.compiler = compiler;\n     }\n \n     @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.THIS) {\n-        return;\n-      }\n-\n+    public void enterScope(NodeTraversal t) {\n       Symbol symbol = null;\n       if (t.inGlobalScope()) {\n-        // declare the global this at the first place it's used.\n-        if (globalScope.getSlot(GLOBAL_THIS) == null) {\n-          symbol = declareSymbol(\n+        // Declare the global this at the first input root.\n+        // This is a bizarre place to put it, but we need some\n+        // location with a real file path (because all symbols\n+        // must have a path).\n+        // Note that root.lastChild.firstChild is the first non-extern input.\n+        Node firstInputRoot = t.getScopeRoot().getLastChild().getFirstChild();\n+        if (firstInputRoot != null) {\n+          symbol = addSymbol(\n               GLOBAL_THIS,\n               registry.getNativeType(JSTypeNative.GLOBAL_THIS),\n               false /* declared */,\n               globalScope,\n-              n,\n-              null);\n-        } else {\n-          symbol = globalScope.getSlot(GLOBAL_THIS);\n+              firstInputRoot);\n+          symbol.setDeclaration(new Reference(symbol, firstInputRoot));\n         }\n       } else {\n         // Otherwise, declare a \"this\" property when possible.\n         Preconditions.checkNotNull(scope);\n         Symbol scopeSymbol = getSymbolForScope(scope);\n         if (scopeSymbol != null) {\n-          createPropertyScopeFor(scopeSymbol);\n-\n           SymbolScope propScope = scopeSymbol.getPropertyScope();\n-          symbol = propScope.getSlot(\"this\");\n-          if (symbol == null) {\n-            JSType type = n.getJSType();\n-            symbol = declareSymbol(\n-                \"this\",\n-                type,\n-                type != null && !type.isUnknownType(),\n-                propScope,\n-                n,\n-                null);\n+          if (propScope != null) {\n+            // If a function is assigned multiple times, we only want\n+            // one addressable \"this\" symbol.\n+            symbol = propScope.getOwnSlot(\"this\");\n+            if (symbol == null) {\n+              JSType rootType = t.getScopeRoot().getJSType();\n+              FunctionType fnType = rootType == null\n+                  ? null : rootType.toMaybeFunctionType();\n+              JSType type = fnType == null\n+                  ? null : fnType.getTypeOfThis();\n+              symbol = addSymbol(\n+                  \"this\",\n+                  type,\n+                  false /* declared */,\n+                  scope,\n+                  t.getScopeRoot());\n+            }\n+\n+            // TODO(nicksantos): It's non-obvious where the declaration of\n+            // the 'this' symbol should be. Figure this out later.\n           }\n         }\n       }\n \n+      thisStack.add(symbol);\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      thisStack.remove(thisStack.size() - 1);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.THIS) {\n+        return;\n+      }\n+\n+      Symbol symbol = thisStack.get(thisStack.size() - 1);\n       if (symbol != null) {\n-        symbol.defineReferenceAt(n);\n+        Reference ref = symbol.defineReferenceAt(n);\n+        if (symbol.getDeclaration() == null) {\n+          symbol.setDeclaration(ref);\n+        }\n       }\n     }\n   }\n         return result;\n       }\n \n+      // Source position is a bit mask of line in the top 4 bits, so this\n+      // is a quick way to compare order without computing absolute position.\n       return a.getSourcePosition() - b.getSourcePosition();\n     }\n   };\n         return result;\n       }\n \n-      if (scopeA.isLexicalScope() && !scopeB.isLexicalScope()) {\n+      if (a.getDeclaration() == null && b.getDeclaration() == null) {\n+        return a.getName().compareTo(b.getName());\n+      } else if (a.getDeclaration() == null) {\n         return -1;\n-      }\n-\n-      if (scopeB.isLexicalScope() && !scopeA.isLexicalScope()) {\n+      } else if (b.getDeclaration() == null) {\n+        return 1;\n+      }\n+\n+      // Make sure that Ctor comes before Ctor.prototype, even though\n+      // they're on the same node.\n+      if (b.getName().endsWith(\".prototype\") &&\n+          b.getName().equals(a.getName() + \".prototype\")) {\n+        return -1;\n+      } else if (a.getName().endsWith(\".prototype\") &&\n+          a.getName().equals(b.getName() + \".prototype\")) {\n         return 1;\n       }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertNotNull(getGlobalVar(table, \"x\"));\n     assertEquals(\"number\", getGlobalVar(table, \"x\").getType().toString());\n \n-    assertEquals(1, getVars(table).size());\n+    // 2 == sizeof({x, *global*})\n+    assertEquals(2, getVars(table).size());\n   }\n \n   public void testGlobalThisReferences() throws Exception {\n     Symbol global = getGlobalVar(table, \"*global*\");\n     assertNotNull(global);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(global));\n+    List<Reference> refs = table.getReferenceList(global);\n     assertEquals(1, refs.size());\n+  }\n+\n+  public void testGlobalThisReferences2() throws Exception {\n+    // Make sure the global this is declared, even if it isn't referenced.\n+    SymbolTable table = createSymbolTable(\"\");\n+\n+    Symbol global = getGlobalVar(table, \"*global*\");\n+    assertNotNull(global);\n+\n+    List<Reference> refs = table.getReferenceList(global);\n+    assertEquals(0, refs.size());\n   }\n \n   public void testGlobalThisPropertyReferences() throws Exception {\n     Symbol foo = getGlobalVar(table, \"Foo\");\n     assertNotNull(foo);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(foo));\n+    List<Reference> refs = table.getReferenceList(foo);\n     assertEquals(2, refs.size());\n   }\n \n     SymbolTable table = createSymbolTable(\n         \"/** @type {number} */ var x = 5; x = 6;\");\n     Symbol x = getGlobalVar(table, \"x\");\n-    List<Reference> refs = Lists.newArrayList(table.getReferences(x));\n+    List<Reference> refs = table.getReferenceList(x);\n \n     assertEquals(2, refs.size());\n     assertEquals(x.getDeclaration(), refs.get(0));\n     SymbolTable table = createSymbolTable(\n         \"function f(x) { return x; }\");\n     Symbol x = getLocalVar(table, \"x\");\n-    List<Reference> refs = Lists.newArrayList(table.getReferences(x));\n+    List<Reference> refs = table.getReferenceList(x);\n \n     assertEquals(2, refs.size());\n     assertEquals(x.getDeclaration(), refs.get(0));\n     SymbolTable table = createSymbolTable(\n         \"/** @constructor */ function F() { this.foo = 3; this.bar = 5; }\");\n \n-    Symbol t = getGlobalVar(table, \"F.this\");\n+    Symbol f = getGlobalVar(table, \"F\");\n+    assertNotNull(f);\n+\n+    Symbol t = table.getParameterInFunction(f, \"this\");\n     assertNotNull(t);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(t));\n+    List<Reference> refs = table.getReferenceList(t);\n     assertEquals(2, refs.size());\n   }\n \n   public void testLocalThisReferences2() throws Exception {\n     SymbolTable table = createSymbolTable(\n         \"/** @constructor */ function F() {}\" +\n-        \"/** doc */ F.prototype.baz = \" +\n+        \"F.prototype.baz = \" +\n         \"    function() { this.foo = 3; this.bar = 5; };\");\n \n-    Symbol t = getGlobalVar(table, \"F.prototype.baz.this\");\n+    Symbol baz = getGlobalVar(table, \"F.prototype.baz\");\n+    assertNotNull(baz);\n+\n+    Symbol t = table.getParameterInFunction(baz, \"this\");\n     assertNotNull(t);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(t));\n-    assertEquals(2, refs.size());\n+    List<Reference> refs = table.getReferenceList(t);\n+    assertEquals(2, refs.size());\n+  }\n+\n+  public void testLocalThisReferences3() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function F() {}\");\n+\n+    Symbol baz = getGlobalVar(table, \"F\");\n+    assertNotNull(baz);\n+\n+    Symbol t = table.getParameterInFunction(baz, \"this\");\n+    assertNotNull(t);\n+\n+    List<Reference> refs = table.getReferenceList(t);\n+    assertEquals(0, refs.size());\n   }\n \n   public void testNamespacedReferences() throws Exception {\n   public void testGlobalVarInExterns() throws Exception {\n     SymbolTable table = createSymbolTable(\"customExternFn(1);\");\n     Symbol fn = getGlobalVar(table, \"customExternFn\");\n-    List<Reference> refs = Lists.newArrayList(table.getReferences(fn));\n+    List<Reference> refs = table.getReferenceList(fn);\n     assertEquals(2, refs.size());\n \n     SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode());\n     assertTrue(scope.isGlobalScope());\n-    assertNull(table.getSymbolForScope(scope));\n+    assertEquals(SymbolTable.GLOBAL_THIS,\n+        table.getSymbolForScope(scope).getName());\n   }\n \n   public void testLocalVarInExterns() throws Exception {\n     SymbolTable table = createSymbolTable(\"\");\n     Symbol arg = getLocalVar(table, \"customExternArg\");\n-    List<Reference> refs = Lists.newArrayList(table.getReferences(arg));\n+    List<Reference> refs = table.getReferenceList(arg);\n     assertEquals(1, refs.size());\n \n     Symbol fn = getGlobalVar(table, \"customExternFn\");\n         getGlobalVar(table, \"DomHelper.prototype\");\n     assertNotNull(prototype);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n+    List<Reference> refs = table.getReferenceList(prototype);\n \n     // One of the refs is implicit in the declaration of the function.\n     assertEquals(refs.toString(), 2, refs.size());\n         getGlobalVar(table, \"Snork.prototype\");\n     assertNotNull(prototype);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n+    List<Reference> refs = table.getReferenceList(prototype);\n     assertEquals(2, refs.size());\n   }\n \n     Symbol foo = getGlobalVar(table, \"Foo\");\n     assertNotNull(foo);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(foo));\n+    List<Reference> refs = table.getReferenceList(foo);\n     assertEquals(5, refs.size());\n \n     assertEquals(1, refs.get(0).getNode().getLineno());\n     Symbol str = getGlobalVar(table, \"String\");\n     assertNotNull(str);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(str));\n+    List<Reference> refs = table.getReferenceList(str);\n \n     // We're going to pick up a lot of references from the externs,\n     // so it's not meaningful to check the number of references.\n     Symbol x = getLocalVar(table, \"x\");\n     assertNotNull(x);\n \n-    List<Reference> refs = Lists.newArrayList(table.getReferences(x));\n+    List<Reference> refs = table.getReferenceList(x);\n     assertEquals(2, refs.size());\n \n     assertEquals(code.indexOf(\"x) {\"), refs.get(0).getNode().getCharno());\n     assertNotNull(xNumber);\n     assertFalse(table.getScope(xNumber).isGlobalScope());\n \n-    assertEquals(\"?\", xNumber.getType().toString());\n+    assertEquals(\"number\", xNumber.getType().toString());\n   }\n \n   public void testNaturalSymbolOrdering() {", "timestamp": 1319685752, "metainfo": ""}