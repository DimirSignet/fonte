{"sha": "384daa779c874c449d86ec219de29cf45fd965db", "log": "Allow @private {type} The JSDoc people seem OK with this approach. The implementation is a bit of a fudge job, but I think this will do the \"right\" thing without breaking any of the existing APIs.  R=johnlenz,dimvar DELTA=155  (106 added, 32 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5962   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   token = eatTokensUntilEOL();\n                   continue retry;\n \n-                case PRIVATE:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case PROTECTED:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case PUBLIC:\n-                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n                 case NO_SHADOW:\n                   if (!jsdocBuilder.recordNoShadow()) {\n                     parser.addParserWarning(\"msg.jsdoc.noshadow\",\n \n                 case DEFINE:\n                 case RETURN:\n+                case PRIVATE:\n+                case PROTECTED:\n+                case PUBLIC:\n                 case THIS:\n                 case TYPE:\n                 case TYPEDEF:\n                   charno = stream.getCharno();\n \n                   Node typeNode = null;\n-                  if (!lookAheadForTypeAnnotation() &&\n-                      annotation == Annotation.RETURN) {\n-                    // If RETURN doesn't have a type annotation, record\n-                    // it as the unknown type.\n-                    typeNode = newNode(Token.QMARK);\n-                  } else {\n+                  boolean hasType = lookAheadForTypeAnnotation();\n+                  boolean isVisibilityAnnotation =\n+                      (annotation == Annotation.PRIVATE ||\n+                       annotation == Annotation.PROTECTED ||\n+                       annotation == Annotation.PUBLIC);\n+                  boolean canSkipTypeAnnotation =\n+                      (isVisibilityAnnotation ||\n+                       annotation == Annotation.RETURN);\n+                  type = null;\n+                  if (hasType || !canSkipTypeAnnotation) {\n                     skipEOLs();\n                     token = next();\n                     typeNode = parseAndRecordTypeNode(token);\n-                  }\n-\n-                  if (annotation == Annotation.THIS) {\n-                    typeNode = wrapNode(Token.BANG, typeNode);\n-                  }\n-                  type = createJSTypeExpression(typeNode);\n-\n-                  if (type == null) {\n-                    // error reported during recursive descent\n-                    // recovering parsing\n-                  } else {\n+\n+                    if (annotation == Annotation.THIS) {\n+                      typeNode = wrapNode(Token.BANG, typeNode);\n+                    }\n+                    type = createJSTypeExpression(typeNode);\n+                  }\n+\n+                  // The error was reported during recursive descent\n+                  // recovering parsing\n+                  boolean hasError = type == null && !canSkipTypeAnnotation;\n+                  if (!hasError) {\n+                    // Record types for @type.\n+                    // If the @private, @protected, or @public annotations\n+                    // have a type attached, pretend that they actually wrote:\n+                    // @type {type}\\n@private\n+                    // This will have some weird behavior in some cases\n+                    // (for example, @private can now be used as a type-cast),\n+                    // but should be mostly OK.\n+                    if ((type != null && isVisibilityAnnotation)\n+                        || annotation == Annotation.TYPE) {\n+                      if (!jsdocBuilder.recordType(type)) {\n+                        parser.addTypeWarning(\n+                            \"msg.jsdoc.incompat.type\", lineno, charno);\n+                      }\n+                    }\n+\n                     switch (annotation) {\n                       case DEFINE:\n                         if (!jsdocBuilder.recordDefineType(type)) {\n                         }\n                         break;\n \n+                      case PRIVATE:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.private\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n+                      case PROTECTED:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.protected\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n+                      case PUBLIC:\n+                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n+                          parser.addParserWarning(\n+                              \"msg.jsdoc.visibility.public\",\n+                              lineno, charno);\n+                        }\n+                        break;\n+\n                       case RETURN:\n+                        if (type == null) {\n+                          type = createJSTypeExpression(newNode(Token.QMARK));\n+                        }\n+\n                         if (!jsdocBuilder.recordReturnType(type)) {\n                           parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n \n                       case THIS:\n                         if (!jsdocBuilder.recordThisType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-\n-                      case TYPE:\n-                        if (!jsdocBuilder.recordType(type)) {\n                           parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n                         }\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n           case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n           case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n           case HOOK:            return \"HOOK\";\n-          case COLON:           return \"COLON\";\n           case OR:              return \"OR\";\n           case AND:             return \"AND\";\n           case INC:             return \"INC\";\n           case BANG:            return \"BANG\";\n           case VOID:            return \"VOID\";\n           case EQUALS:          return \"EQUALS\";\n+          case LB:              return \"LB\";\n+          case LC:              return \"LC\";\n+          case COLON:           return \"COLON\";\n         }\n \n         // Token without name\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         s.getVar(\"TypeError\").getType());\n     assertTypeEquals(URI_ERROR_FUNCTION_TYPE,\n         s.getVar(\"URIError\").getType());\n+  }\n+\n+  public void testPrivateType() throws Exception {\n+    testTypes(\n+        \"/** @private {number} */ var x = false;\",\n+        \"initializing variable\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   public void testTypeCheck1() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n           \"function DictDict() {}\",\n           \"Bad type annotation. \" +\n           \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict21() throws Exception {\n+    parse(\"/**\\n\" +\n+          \" * @private {string}\\n\" +\n+          \" * @type {number}\\n\" +\n+          \" */\\n\" +\n+          \"function DictDict() {}\",\n+          \"Bad type annotation. \" +\n+          \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict22() throws Exception {\n+    parse(\"/**\\n\" +\n+          \" * @protected {string}\\n\" +\n+          \" * @param {string} x\\n\" +\n+          \" */\\n\" +\n+          \"function DictDict(x) {}\",\n+          \"Bad type annotation. \" +\n+          \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict23() throws Exception {\n+    parse(\"/**\\n\" +\n+          \" * @public {string}\\n\" +\n+          \" * @return {string} x\\n\" +\n+          \" */\\n\" +\n+          \"function DictDict() {}\",\n+          \"Bad type annotation. \" +\n+          \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testPrivateType() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@private {string} */\");\n+    assertTypeEquals(STRING_TYPE, jsdoc.getType());\n+  }\n+\n+  public void testProtectedType() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@protected {string} */\");\n+    assertTypeEquals(STRING_TYPE, jsdoc.getType());\n+  }\n+\n+  public void testPublicType() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@public {string} */\");\n+    assertTypeEquals(STRING_TYPE, jsdoc.getType());\n   }\n \n   public void testStableIdGeneratorConflict() throws Exception {", "timestamp": 1355267961, "metainfo": ""}