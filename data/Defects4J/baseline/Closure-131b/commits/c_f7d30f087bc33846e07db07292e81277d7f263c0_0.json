{"sha": "f7d30f087bc33846e07db07292e81277d7f263c0", "log": "Fix a bug in goog.scope when the inlined alias conflicts with a local variable.  R=acleung DELTA=151  (151 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5056   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n     }\n   }\n \n+  /** Only rename things that match the whitelist. Wraps another renamer. */\n+  static class WhitelistedRenamer implements Renamer {\n+    private Renamer delegate;\n+    private Set<String> whitelist;\n+\n+    WhitelistedRenamer(Renamer delegate, Set<String> whitelist) {\n+      this.delegate = delegate;\n+      this.whitelist = whitelist;\n+    }\n+\n+    @Override public void addDeclaredName(String name) {\n+      if (whitelist.contains(name)) {\n+        delegate.addDeclaredName(name);\n+      }\n+    }\n+\n+    @Override public String getReplacementName(String oldName) {\n+      return whitelist.contains(oldName)\n+          ? delegate.getReplacementName(oldName) : null;\n+    }\n+\n+    @Override public boolean stripConstIfReplaced() {\n+      return delegate.stripConstIfReplaced();\n+    }\n+\n+    @Override public Renamer forChildScope() {\n+      return new WhitelistedRenamer(delegate.forChildScope(), whitelist);\n+    }\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\n import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\n import com.google.javascript.jscomp.Scope.Var;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n import javax.annotation.Nullable;\n \n     // This map is temporary and cleared for each scope.\n     private final Map<String, Var> aliases = Maps.newHashMap();\n \n+    // Suppose you create an alias.\n+    // var x = goog.x;\n+    // As a side-effect, this means you can shadow the namespace 'goog'\n+    // in inner scopes. When we inline the namespaces, we have to rename\n+    // these shadows.\n+    //\n+    // Fortunately, we already have a name uniquifier that runs during tree\n+    // normalization (before optimizations). We run it here on a limited\n+    // set of variables, but only as a last resort (because this will screw\n+    // up warning messages downstream).\n+    private final Set<String> forbiddenLocals = Sets.newHashSet();\n+    private boolean hasNamespaceShadows = false;\n+\n     private boolean hasErrors = false;\n \n     private AliasTransformation transformation = null;\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n+      if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n+      }\n+\n       if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n         aliases.clear();\n+        forbiddenLocals.clear();\n         transformation = null;\n+        hasNamespaceShadows = false;\n       }\n     }\n \n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n+\n+          int rootIndex = qualifiedName.indexOf(\".\");\n+          if (rootIndex != -1) {\n+            String qNameRoot = qualifiedName.substring(0, rootIndex);\n+            if (!aliases.containsKey(qNameRoot)) {\n+              forbiddenLocals.add(qNameRoot);\n+            }\n+          }\n         } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n           // do nothing.\n           // TODO(robbyw): Support using locals for private variables.\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n+      }\n+    }\n+\n+    /** Find out if there are any local shadows of namespaces. */\n+    private void findNamespaceShadows(NodeTraversal t) {\n+      if (hasNamespaceShadows) {\n+        return;\n+      }\n+\n+      Scope scope = t.getScope();\n+      for (Var v : scope.getVarIterable()) {\n+        if (forbiddenLocals.contains(v.getName())) {\n+          hasNamespaceShadows = true;\n+          return;\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Rename any local shadows of namespaces.\n+     * This should be a very rare occurrence, so only do this traversal\n+     * if we know that we need it.\n+     */\n+    private void renameNamespaceShadows(NodeTraversal t) {\n+      if (hasNamespaceShadows) {\n+        MakeDeclaredNamesUnique.Renamer renamer =\n+            new MakeDeclaredNamesUnique.WhitelistedRenamer(\n+                new MakeDeclaredNamesUnique.ContextualRenamer(),\n+                forbiddenLocals);\n+        for (String s : forbiddenLocals) {\n+          renamer.addDeclaredName(s);\n+        }\n+        MakeDeclaredNamesUnique uniquifier =\n+            new MakeDeclaredNamesUnique(renamer);\n+        NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n          \"var Popup = {};\" +\n          \"var OtherPopup = {};\" +\n          \"OtherPopup.newMethod = function() { return new OtherPopup(); };\");\n+  }\n+\n+  public void testShadowedScopedVar() {\n+    test(\"var goog = {};\" +\n+         \"goog.bar = {};\" +\n+         \"goog.scope(function() {\" +\n+         \"  var bar = goog.bar;\" +\n+         // This is bogus, because when the aliases are expanded, goog will\n+         // shadow goog.bar.\n+         \"  bar.newMethod = function(goog) { return goog + bar; };\" +\n+         \"});\",\n+         \"var goog={};\" +\n+         \"goog.bar={};\" +\n+         \"goog.bar.newMethod=function(goog$$1){return goog$$1 + goog.bar}\");\n+  }\n+\n+  public void testShadowedScopedVarTwoScopes() {\n+    test(\"var goog = {};\" +\n+         \"goog.bar = {};\" +\n+         \"goog.scope(function() {\" +\n+         \"  var bar = goog.bar;\" +\n+         \"  bar.newMethod = function(goog, a) { return bar + a; };\" +\n+         \"});\" +\n+         \"goog.scope(function() {\" +\n+         \"  var bar = goog.bar;\" +\n+         \"  bar.newMethod2 = function(goog, b) { return bar + b; };\" +\n+         \"});\",\n+         \"var goog={};\" +\n+         \"goog.bar={};\" +\n+         \"goog.bar.newMethod=function(goog$$1, a){return goog.bar + a};\" +\n+         \"goog.bar.newMethod2=function(goog$$1, b){return goog.bar + b};\");\n+  }\n+\n+  public void testUsingObjectLiteralToEscapeScoping() {\n+    // There are many ways to shoot yourself in the foot with goog.scope\n+    // and make the compiler generate bad code. We generally don't care.\n+    //\n+    // We only try to protect against accidental mis-use, not deliberate\n+    // mis-use.\n+    test(\n+        \"var goog = {};\" +\n+        \"goog.bar = {};\" +\n+        \"goog.scope(function() {\" +\n+        \"  var bar = goog.bar;\" +\n+        \"  var baz = goog.bar.baz;\" +\n+        \"  goog.foo = function() {\" +\n+        \"    goog.bar = {baz: 3};\" +\n+        \"    return baz;\" +\n+        \"  };\" +\n+        \"});\",\n+        \"var goog = {};\" +\n+        \"goog.bar = {};\" +\n+        \"goog.foo = function(){\" +\n+        \"  goog.bar = {baz:3};\" +\n+        \"  return goog.bar.baz;\" +\n+        \"};\");\n   }\n \n   private void testTypes(String aliases, String code) {", "timestamp": 1340319745, "metainfo": ""}