{"sha": "8ab4ecc013925ccdd65b3b9a1fb0e604735629be", "log": "Report changing/total loopable passes in PerformanceTracker.  R=blickly DELTA=101 (34 added, 39 deleted, 28 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6108   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     String comment = passName\n         + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n     if (options.tracer.isOn()) {\n-      tracker.recordPassStart(passName);\n+      tracker.recordPassStart(passName, true);\n     }\n     return new Tracer(\"Compiler\", comment);\n   }\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n   private int initCodeSize = 0;\n   private int initGzCodeSize = 0;\n \n-  private Deque<String> currentRunningPass = new ArrayDeque<String>();\n+  private Deque<Stats> currentPass = new ArrayDeque<Stats>();\n \n   /** Summary stats by pass name. */\n   private final Map<String, Stats> summary = Maps.newHashMap();\n   /** Stats for each run of a compiler pass. */\n   private final List<Stats> log = Lists.newArrayList();\n \n-\n   public static class Stats {\n-    public Stats(String pass) {\n+    Stats(String pass, boolean iot) {\n       this.pass = pass;\n+      this.isOneTime = iot;\n     }\n     public final String pass;\n+    public final boolean isOneTime;\n     public long runtime = 0;\n     public int runs = 0;\n     public int changes = 0;\n     return codeChange;\n   }\n \n-  void recordPassStart(String passName) {\n-    currentRunningPass.push(passName);\n+  void recordPassStart(String passName, boolean isOneTime) {\n+    currentPass.push(new Stats(passName, isOneTime));\n     codeChange.reset();\n   }\n \n    * @param result Execution time.\n    */\n   void recordPassStop(String passName, long result) {\n-    if (!passName.equals(currentRunningPass.pop())) {\n+    Stats logStats = currentPass.pop();\n+    if (!passName.equals(logStats.pass)) {\n       throw new RuntimeException(passName + \" is not running.\");\n     }\n \n       }\n     }\n \n-    // Initialize logStats and summaryStats\n-    Stats logStats = new Stats(passName);\n+    // Populate log and summary\n     log.add(logStats);\n     Stats summaryStats = summary.get(passName);\n     if (summaryStats == null) {\n-      summaryStats = new Stats(passName);\n+      summaryStats = new Stats(passName, logStats.isOneTime);\n       summary.put(passName, summaryStats);\n     }\n \n       int runtime = 0;\n       int runs = 0;\n       int changes = 0;\n+      int loopRuns = 0;\n+      int loopChanges = 0;\n       int diff = 0;\n       int gzDiff = 0;\n-\n-      // header\n-      output.write(\"Summary:\\n\");\n-      output.write(\"pass,runtime,runs,changingRuns,reduction,gzReduction\\n\");\n \n       ArrayList<Entry<String, Stats>> a = new ArrayList<Entry<String, Stats>>();\n       for (Entry<String, Stats> entry : summary.entrySet()) {\n       }\n       Collections.sort(a, new CmpEntries());\n \n+      output.write(\"Summary:\\n\" +\n+          \"pass,runtime,runs,changingRuns,reduction,gzReduction\\n\");\n       for (Entry<String, Stats> entry : a) {\n         String key = entry.getKey();\n         Stats stats = entry.getValue();\n-\n-        output.write(key);\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.runtime));\n         runtime += stats.runtime;\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.runs));\n         runs += stats.runs;\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.changes));\n         changes += stats.changes;\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.diff));\n+        if (!stats.isOneTime) {\n+          loopRuns += stats.runs;\n+          loopChanges += stats.changes;\n+        }\n         diff += stats.diff;\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.gzDiff));\n         gzDiff += stats.gzDiff;\n-        output.write(\"\\n\");\n-      }\n+        output.write(key + \",\" +\n+            String.valueOf(stats.runtime) + \",\" +\n+            String.valueOf(stats.runs) + \",\" +\n+            String.valueOf(stats.changes) + \",\" +\n+            String.valueOf(stats.diff) + \",\" +\n+            String.valueOf(stats.gzDiff) + \"\\n\");\n+      }\n+      output.write(\"\\nTOTAL:\" +\n+          \"\\nRuntime(ms): \" + String.valueOf(runtime) +\n+          \"\\n#Runs: \" + String.valueOf(runs) +\n+          \"\\n#Changing runs: \" + String.valueOf(changes) +\n+          \"\\n#Loopable runs: \" + String.valueOf(loopRuns) +\n+          \"\\n#Changing loopable runs: \" + String.valueOf(loopChanges) +\n+          \"\\nReduction(bytes): \" + String.valueOf(diff) +\n+          \"\\nGzReduction(bytes): \" + String.valueOf(gzDiff) +\n+          \"\\nSize(bytes): \" + String.valueOf(codeSize) +\n+          \"\\nGzSize(bytes): \" + String.valueOf(gzCodeSize) + \"\\n\\n\");\n+\n       Preconditions.checkState(!trackSize || initCodeSize == diff + codeSize);\n       Preconditions.checkState(!trackGzSize ||\n           initGzCodeSize == gzDiff + gzCodeSize);\n \n-      output.write(\"TOTAL\");\n-      output.write(\",\");\n-      output.write(String.valueOf(runtime));\n-      output.write(\",\");\n-      output.write(String.valueOf(runs));\n-      output.write(\",\");\n-      output.write(String.valueOf(changes));\n-      output.write(\",\");\n-      output.write(String.valueOf(diff));\n-      output.write(\",\");\n-      output.write(String.valueOf(gzDiff));\n-      output.write(\"\\n\");\n-      output.write(\"\\n\");\n-\n-      output.write(\"Log:\\n\");\n-      output.write(\n+      output.write(\"Log:\\n\" +\n           \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize\\n\");\n       for (Stats stats : log) {\n-        output.write(stats.pass);\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.runtime));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.runs));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.changes));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.diff));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.gzDiff));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.size));\n-        output.write(\",\");\n-        output.write(String.valueOf(stats.gzSize));\n-        output.write(\"\\n\");\n+        output.write(stats.pass + \",\" +\n+            String.valueOf(stats.runtime) + \",\" +\n+            String.valueOf(stats.runs) + \",\" +\n+            String.valueOf(stats.changes) + \",\" +\n+            String.valueOf(stats.diff) + \",\" +\n+            String.valueOf(stats.gzDiff) + \",\" +\n+            String.valueOf(stats.size) + \",\" +\n+            String.valueOf(stats.gzSize) + \"\\n\");\n       }\n       output.write(\"\\n\");\n       output.close();\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   /**\n    * Marks the beginning of a pass.\n    */\n-  private void startPass(String passName) {\n+  private void startPass(String passName, boolean isOneTime) {\n     Preconditions.checkState(currentTracer == null && currentPassName == null);\n     currentPassName = passName;\n-    currentTracer = newTracer(passName);\n+    currentTracer = newTracer(passName, isOneTime);\n   }\n \n   /**\n   /**\n    * Returns a new tracer for the given pass name.\n    */\n-  private Tracer newTracer(String passName) {\n+  private Tracer newTracer(String passName, boolean isOneTime) {\n     String comment = passName +\n         (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n     if (tracker != null) {\n-      tracker.recordPassStart(passName);\n+      tracker.recordPassStart(passName, isOneTime);\n     }\n     return new Tracer(\"JSCompiler\", comment);\n   }\n     @Override\n     public void process(Node externs, Node root) {\n       logger.fine(name);\n-      startPass(name);\n+      startPass(name, factory.isOneTimePass());\n       // Delay the creation of the actual pass until *after* all previous passes\n       // have been processed.\n       // Some precondition checks rely on this, eg, in CoalesceVariableNames.\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     outstream.flush();\n     outstream.close();\n     Pattern p = Pattern.compile(\n-        \".*Summary:.pass,runtime,runs,changingRuns,reduction,gzReduction\" +\n-        \".*TOTAL,[0-9]+,[0-9]+,[0-9]+,[0-9]+,[0-9]+[^,]\" +\n-        \".*Log:.\" +\n+        \".*Summary:\\npass,runtime,runs,changingRuns,reduction,gzReduction\" +\n+        \".*TOTAL:\" +\n+        \"\\nRuntime\\\\(ms\\\\): [0-9]+\" +\n+        \"\\n#Runs: [0-9]+\" +\n+        \"\\n#Changing runs: [0-9]+\" +\n+        \"\\n#Loopable runs: [0-9]+\" +\n+        \"\\n#Changing loopable runs: [0-9]+\" +\n+        \"\\nReduction\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\nGzReduction\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\nSize\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\nGzSize\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\n\\nLog:\\n\" +\n         \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize.*\",\n         Pattern.DOTALL);\n     assertTrue(p.matcher(output.toString()).matches());", "timestamp": 1357771660, "metainfo": ""}