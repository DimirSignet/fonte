{"sha": "c26da905cc06126658ba25f037d77d9ce6c02b45", "log": "back off a little bit on function return type inference  R=acleung DELTA=42  (37 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4480   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    * Builds the function type, and puts it in the registry.\n    */\n   FunctionType buildAndRegister() {\n-    if (returnType == null &&\n-        !contents.mayHaveNonEmptyReturns() && !contents.mayBeFromExterns()) {\n-      returnType = typeRegistry.getNativeType(VOID_TYPE);\n-      returnTypeInferred = true;\n+    if (returnType == null) {\n+      // Infer return types.\n+      // We need to be extremely conservative about this, because of two\n+      // competing needs.\n+      // 1) If we infer the return type of f too widely, then we won't be able\n+      //    to assign f to other functions.\n+      // 2) If we infer the return type of f too narrowly, then we won't be\n+      //    able to override f in subclasses.\n+      // So we only infer in cases where the user doesn't expect to write\n+      // @return annotations--when it's very obvious that the function returns\n+      // nothing.\n+      if (!contents.mayHaveNonEmptyReturns() &&\n+          !contents.mayHaveSingleThrow() &&\n+          !contents.mayBeFromExterns()) {\n+        returnType = typeRegistry.getNativeType(VOID_TYPE);\n+        returnTypeInferred = true;\n+      }\n     }\n \n     if (returnType == null) {\n     /** Returns if a return of a real value (not undefined) appears. */\n     boolean mayHaveNonEmptyReturns();\n \n+    /** Returns if this consists of a single throw. */\n+    boolean mayHaveSingleThrow();\n+\n     /** Gets a list of variables in this scope that are escaped. */\n     Iterable<String> getEscapedVarNames();\n \n \n     @Override\n     public boolean mayHaveNonEmptyReturns() {\n+      return true;\n+    }\n+\n+    @Override\n+    public boolean mayHaveSingleThrow() {\n       return true;\n     }\n \n     }\n \n     @Override\n+    public boolean mayHaveSingleThrow() {\n+      Node block = n.getLastChild();\n+      return block.hasOneChild() && block.getFirstChild().isThrow();\n+    }\n+\n+    @Override\n     public Iterable<String> getEscapedVarNames() {\n       return escapedVarNames == null\n           ? ImmutableList.<String>of() : escapedVarNames;\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @this {Date} */ var f;\",\n         \"f\",\n         \"function (this:Date): ?\");\n+  }\n+\n+  public void testFunctionInference21() throws Exception {\n+    testTypes(\n+        \"var f = function() { throw 'x' };\" +\n+        \"/** @return {boolean} */ var g = f;\");\n+    testFunctionType(\n+        \"var f = function() { throw 'x' };\",\n+        \"f\",\n+        \"function (): ?\");\n   }\n \n   public void testInnerFunction1() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n   public void testReturnTypeInference4() {\n     testSame(\"function f() { throw Error(); }\");\n     assertEquals(\n-        \"function (): undefined\",\n+        \"function (): ?\",\n         findNameType(\"f\", globalScope).toString());\n   }\n ", "timestamp": 1333575527, "metainfo": ""}