{"sha": "d0433a709e773335895e2c3df6d36ee85d35da25", "log": "This CL adds a new AngularPass  When enabled this flag triggers compiler to process a special @angularInject annotation.  When a function declaration is annotated with @angularInject, AngularPass compiler pass will extract function parameter names, combine them into an array of strings and create a special `$inject` property on the declared function containing the array.  For example,  /** @angularInject */ function Something(a, b) {}  will be transformed into function Something(a, b) {} Something.$inject = ['a', 'b'];  This would take of the burden of maintaining dependency declarations for Angular Dependency Injector from developers resulting in cleaner code while still supporting code minification.  This CL adds AngularPass.java (and corresponding test file) containing AST traversal, node extraction and node creation logic.  First, AngularPass.Traversal class is used to traverse AST, locate nodes annotated with @angularInject, determine their type, locate the FUNCTION node, and decide which node the new \".$inject = [...]\" ASSIGN node should be attached to.  Second, all discovered eligible nodes are iterated through, function parameters extracted and corresponding \".$inject = [param...]\" node created and attached to the AST.  R=blickly DELTA=579 (575 added, 1 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6187   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     options.transformAMDToCJSModules = config.transformAMDToCJSModules;\n     options.processCommonJSModules = config.processCommonJSModules;\n     options.commonJSModulePathPrefix = config.commonJSModulePathPrefix;\n+    options.angularPass = config.angularPass;\n   }\n \n   final protected A getCompiler() {\n       this.warningsWhitelistFile = fileName;\n       return this;\n     }\n+\n+    private boolean angularPass = false;\n+\n+    /**\n+     * Sets whether to process AngularJS-specific annotations.\n+     */\n+    CommandLineConfig setAngularPass(boolean angularPass) {\n+      this.angularPass = angularPass;\n+      return this;\n+    }\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/AngularPass.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Compiler pass for AngularJS-specific needs. Generates {@code $inject} \\\n+ * properties for functions (class constructors, wrappers, etc) annotated with\n+ * @angularInject.\n+ *\n+ * <p>For example, the following code:</p>\n+ * <pre>{@code\n+ *\n+ * /** @angularInject * /\n+ * function Controller(dependency1, dependency2) {\n+ *   // do something\n+ * }\n+ *\n+ * }</pre>\n+ *\n+ * <p>will be transformed into:\n+ * <pre>{@code\n+ *\n+ * function Controller(dependency1, dependency2) {\n+ *   // do something\n+ * }\n+ * Controller.$inject = ['dependency1', 'dependency2'];\n+ *\n+ * }</pre>\n+ *\n+ * <p> This pass also supports assignments of function expressions to variables\n+ * like:\n+ * <pre>{@code\n+ *\n+ * /** @angularInject * /\n+ * var filter = function(a, b) {};\n+ *\n+ * var ns = {};\n+ * /** @angularInject * /\n+ * ns.method = function(a,b,c) {};\n+ *\n+ * /** @angularInject * /\n+ * var shorthand = ns.method2 = function(a,b,c,) {}\n+ *\n+ * }</pre>\n+ */\n+class AngularPass extends AbstractPostOrderCallback implements CompilerPass {\n+  final AbstractCompiler compiler;\n+\n+  /** Nodes annotated with @angularInject */\n+  private List<NodeContext> injectables = new ArrayList<NodeContext>();\n+\n+  public AngularPass(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  public static final String INJECT_PROPERTY_NAME = \"$inject\";\n+\n+  static final DiagnosticType INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR =\n+      DiagnosticType.error(\"JSC_INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\",\n+          \"@angularInject only applies to functions defined in blocks or \" +\n+          \"global scope.\");\n+\n+  static final DiagnosticType INJECT_NON_FUNCTION_ERROR =\n+      DiagnosticType.error(\"JSC_INJECT_NON_FUNCTION_ERROR\",\n+          \"@angularInject can only be used when defining a function or \" +\n+          \"assigning a function expression.\");\n+\n+  static final DiagnosticType FUNCTION_NAME_ERROR =\n+      DiagnosticType.error(\"JSC_FUNCTION_NAME_ERROR\",\n+          \"Unable to determine target function name for @angularInject.\");\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    // Traverses AST looking for nodes annotated with @angularInject.\n+    NodeTraversal.traverse(compiler, root, this);\n+    CodingConvention convention = compiler.getCodingConvention();\n+    boolean codeChanged = false;\n+    // iterates through annotated nodes adding $inject property to elements.\n+    for (NodeContext entry : injectables) {\n+      String name = entry.getName();\n+      Node fn = entry.getFunctionNode();\n+      List<Node> dependencies = createDependenciesList(fn);\n+      // skips entry if it does have any dependencies.\n+      if (dependencies.size() == 0) {\n+        continue;\n+      }\n+      Node dependenciesArray = IR.arraylit(dependencies.toArray(\n+          new Node[dependencies.size()]));\n+      // creates `something.$inject = ['param1', 'param2']` node.\n+      Node statement = IR.exprResult(\n+          IR.assign(\n+              NodeUtil.newQualifiedNameNode(convention,\n+                  name + \".\" + INJECT_PROPERTY_NAME),\n+              dependenciesArray\n+          )\n+      );\n+      // adds `something.$inject = [...]` node after the annotated node.\n+      Node target = entry.getTarget();\n+      target.getParent().addChildAfter(statement, target);\n+      codeChanged = true;\n+    }\n+    if (codeChanged) {\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Given a FUNCTION node returns array of STRING nodes representing function\n+   * parameters.\n+   * @param n the FUNCTION node.\n+   * @return STRING nodes.\n+   */\n+  private List<Node> createDependenciesList(Node n) {\n+    Preconditions.checkArgument(n.isFunction());\n+    Node params = NodeUtil.getFunctionParameters(n);\n+    if (params != null) {\n+      return createStringsFromParamList(params);\n+    }\n+    return Lists.newArrayList();\n+  }\n+\n+  /**\n+   * Given a PARAM_LIST node creates an array of corresponding STRING nodes.\n+   * @param params PARAM_LIST node.\n+   * @return array of STRING nodes.\n+   */\n+  private List<Node> createStringsFromParamList(Node params) {\n+    Node param = params.getFirstChild();\n+    ArrayList<Node> names = Lists.newArrayList();\n+    while (param != null && param.isName()) {\n+      names.add(IR.string(param.getString()).srcref(param));\n+      param = param.getNext();\n+    }\n+    return names;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    JSDocInfo docInfo = n.getJSDocInfo();\n+    if (docInfo != null && docInfo.isAngularInject()) {\n+      addNode(n, t);\n+    }\n+  }\n+\n+  /**\n+   * Add node to the list of injectables.\n+   * @param n node to add.\n+   * @param t node traversal instance.\n+   */\n+  private void addNode(Node n, NodeTraversal t) {\n+    Node target = null;\n+    Node fn = null;\n+    String name = null;\n+\n+    switch (n.getType()) {\n+      // handles assignment cases like:\n+      // a = function() {}\n+      // a = b = c = function() {}\n+      case Token.ASSIGN:\n+        name = n.getFirstChild().getQualifiedName();\n+        // last node of chained assignment.\n+        fn = n;\n+        while (fn.isAssign()) {\n+          fn = fn.getLastChild();\n+        }\n+        target = n.getParent();\n+        break;\n+\n+      // handles function case:\n+      // function fnName() {}\n+      case Token.FUNCTION:\n+        name = NodeUtil.getFunctionName(n);\n+        fn = n;\n+        target = n;\n+        break;\n+\n+      // handles var declaration cases like:\n+      // var a = function() {}\n+      // var a = b = function() {}\n+      case Token.VAR:\n+        name = n.getFirstChild().getString();\n+        // looks for a function node.\n+        fn = getDeclarationRValue(n);\n+        target = n;\n+        break;\n+    }\n+    // checks that the declaration took place in a block or in a global scope.\n+    if (!target.getParent().isScript() && !target.getParent().isBlock()) {\n+      compiler.report(t.makeError(n, INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));\n+      return;\n+    }\n+    // checks that it is a function declaration.\n+    if (fn == null || !fn.isFunction()) {\n+      compiler.report(t.makeError(n, INJECT_NON_FUNCTION_ERROR));\n+      return;\n+    }\n+    // checks that name is present, which must always be the case unless the\n+    // compiler allowed a syntax error or a dangling anonymous function\n+    // expression.\n+    Preconditions.checkNotNull(name);\n+    // registers the node.\n+    injectables.add(new NodeContext(name, n, fn, target));\n+  }\n+\n+  /**\n+   * Given a VAR node (variable declaration) returns the node of initial value.\n+   *\n+   * <pre>{@code\n+   * var x;  // null\n+   * var y = \"value\"; // STRING \"value\" node\n+   * var z = x = y = function() {}; // FUNCTION node\n+   * }</pre>\n+   * @param n VAR node.\n+   * @return the assigned intial value, or the rightmost rvalue of an assignment\n+   * chain, or null.\n+   */\n+  private Node getDeclarationRValue(Node n) {\n+    Preconditions.checkNotNull(n);\n+    Preconditions.checkArgument(n.isVar());\n+    n = n.getFirstChild().getFirstChild();\n+    if (n == null) {\n+      return null;\n+    }\n+    while (n.isAssign()) {\n+      n = n.getLastChild();\n+    }\n+    return n;\n+  }\n+\n+  class NodeContext {\n+    /** Name of the function/object. */\n+    private String name;\n+    /** Node jsDoc is attached to. */\n+    private Node node;\n+    /** Function node */\n+    private Node functionNode;\n+    /** Node after which to inject the new code */\n+    private Node target;\n+\n+    public NodeContext(String name, Node node, Node functionNode, Node target) {\n+      this.name = name;\n+      this.node = node;\n+      this.functionNode = functionNode;\n+      this.target = target;\n+    }\n+\n+    /**\n+     * @return the name.\n+     */\n+    public String getName() {\n+      return name;\n+    }\n+\n+    /**\n+     * @return the node.\n+     */\n+    public Node getNode() {\n+      return node;\n+    }\n+\n+    /**\n+     * @return the context.\n+     */\n+    public Node getFunctionNode() {\n+      return functionNode;\n+    }\n+\n+    /**\n+     * @return the context.\n+     */\n+    public Node getTarget() {\n+      return target;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         + \"jQuery.fn and jQuery.extend()\")\n     private boolean process_jquery_primitives = false;\n \n+    @Option(name = \"--angular_pass\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Generate $inject properties for AngularJS for functions \"\n+        + \"annotated with @angularInject\")\n+    private boolean angular_pass = false;\n+\n     @Option(name = \"--output_manifest\",\n         usage = \"Prints out a list of all the files in the compilation. \"\n         + \"If --manage_closure_dependencies is on, this will not include \"\n     options.jqueryPass = flags.process_jquery_primitives &&\n         CompilationLevel.ADVANCED_OPTIMIZATIONS == level;\n \n+    options.angularPass = flags.angular_pass;\n+\n     if (!flags.translationsFile.isEmpty()) {\n       try {\n         options.messageBundle = new XtbMessageBundle(\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Processes jQuery aliases */\n   public boolean jqueryPass;\n+\n+  /** Processes AngularJS-specific annotations */\n+  boolean angularPass;\n \n   /** Remove goog.abstractMethod assignments. */\n   boolean removeAbstractMethods;\n     removeTryCatchFinally = false;\n     closurePass = false;\n     jqueryPass = false;\n+    angularPass = false;\n     removeAbstractMethods = true;\n     removeClosureAsserts = false;\n     stripTypes = Collections.emptySet();\n     this.generateExports = generateExports;\n   }\n \n+  public void setAngularPass(boolean angularPass) {\n+    this.angularPass = angularPass;\n+  }\n+\n   public void setCodingConvention(CodingConvention codingConvention) {\n     this.codingConvention = codingConvention;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       checks.add(jqueryAliases);\n     }\n \n+    if (options.angularPass) {\n+      checks.add(angularPass);\n+    }\n+\n     checks.add(checkSideEffects);\n \n     if (options.checkSuspiciousCode ||\n     @Override\n     protected CompilerPass create(AbstractCompiler compiler) {\n       return new ExpandJqueryAliases(compiler);\n+    }\n+  };\n+\n+  /** Process AngularJS-specific annotations. */\n+  final PassFactory angularPass =\n+      new PassFactory(\"angularPass\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n+      return new AngularPass(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/AngularPassTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests {@link AngularPass}.\n+ */\n+public class AngularPassTest extends CompilerTestCase {\n+\n+  public AngularPassTest() {\n+    super();\n+    enableLineNumberCheck(false);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new AngularPass(compiler);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // This pass only runs once.\n+    return 1;\n+  }\n+\n+  @Override\n+  protected CompilerOptions getOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+    // enables angularPass.\n+    options.angularPass = true;\n+    return getOptions(options);\n+  }\n+\n+  public void testAngularInjectAddsInjectToFunctions() throws Exception {\n+    test(\n+        \"/** @angularInject */\" +\n+        \"function fn(a, b) {}\",\n+\n+        \"function fn(a, b) {}\\n\" +\n+        \"fn.$inject=['a', 'b']\"\n+    );\n+\n+    testSame(\n+        \"function fn(a, b) {}\"\n+    );\n+  }\n+\n+  public void testAngularInjectAddsInjectToProps() throws Exception {\n+    test(\n+        \"var ns = {};\\n\" +\n+        \"/** @angularInject */\" +\n+        \"ns.fn = function (a, b) {}\",\n+\n+        \"var ns = {};\\n\" +\n+        \"ns.fn = function (a, b) {}\\n\" +\n+        \"ns.fn.$inject=['a', 'b']\"\n+    );\n+\n+    testSame(\n+        \"var ns = {};\\n\" +\n+        \"ns.fn = function (a, b) {}\"\n+    );\n+  }\n+\n+  public void testAngularInjectAddsInjectToNestedProps() throws Exception {\n+    test(\n+        \"var ns = {}; ns.subns = {};\\n\" +\n+        \"/** @angularInject */\" +\n+        \"ns.subns.fn = function (a, b) {}\",\n+\n+        \"var ns = {};ns.subns = {};\\n\" +\n+        \"ns.subns.fn = function (a, b) {}\\n\" +\n+        \"ns.subns.fn.$inject=['a', 'b']\"\n+    );\n+\n+    testSame(\n+        \"var ns = {};\\n\" +\n+        \"ns.fn = function (a, b) {}\"\n+    );\n+  }\n+\n+  public void testAngularInjectAddsInjectToVars() throws Exception {\n+    test(\n+        \"/** @angularInject */\" +\n+        \"var fn = function (a, b) {}\",\n+\n+        \"var fn = function (a, b) {};\\n\" +\n+        \"fn.$inject=['a', 'b']\"\n+    );\n+\n+    testSame(\n+        \"var fn = function (a, b) {}\"\n+    );\n+  }\n+\n+  public void testAngularInjectAddsInjectToVarsWithChainedAssignment()\n+      throws Exception {\n+    test(\n+        \"var ns = {};\\n\" +\n+        \"/** @angularInject */\" +\n+        \"var fn = ns.func = function (a, b) {}\",\n+\n+        \"var ns = {}; var fn = ns.func = function (a, b) {};\\n\" +\n+        \"fn.$inject=['a', 'b']\"\n+    );\n+\n+    testSame(\n+        \"var ns = {};\\n\" +\n+        \"var fn = ns.func = function (a, b) {}\"\n+    );\n+  }\n+\n+  public void testAngularInjectInBlock() throws Exception {\n+    test(\n+        \"(function() {\" +\n+        \"var ns = {};\\n\" +\n+        \"/** @angularInject */\" +\n+        \"var fn = ns.func = function (a, b) {}\" +\n+        \"})()\",\n+\n+        \"(function() {\" +\n+        \"var ns = {}; var fn = ns.func = function (a, b) {};\\n\" +\n+        \"fn.$inject=['a', 'b']\" +\n+        \"})()\"\n+    );\n+\n+    testSame(\n+        \"(function() {\" +\n+        \"var ns = {};\\n\" +\n+        \"var fn = ns.func = function (a, b) {}\" +\n+        \"})()\"\n+    );\n+  }\n+\n+  public void testAngularInjectAddsToTheRightBlock() throws Exception {\n+    test(\n+        \"var fn = 10;\\n\" +\n+        \"(function() {\" +\n+        \"var ns = {};\\n\" +\n+        \"/** @angularInject */\" +\n+        \"var fn = ns.func = function (a, b) {}\" +\n+        \"})()\",\n+\n+        \"var fn = 10;\" +\n+        \"(function() {\" +\n+        \"var ns = {}; var fn = ns.func = function (a, b) {};\\n\" +\n+        \"fn.$inject=['a', 'b']\" +\n+        \"})()\"\n+    );\n+  }\n+\n+  public void testAngularInjectInNonBlock() throws Exception {\n+    test(\n+        \"function fake(){}; var ns = {};\" +\n+        \"fake(\" +\n+        \"/** @angularInject */\" +\n+        \"ns.func = function (a, b) {}\" +\n+        \")\",\n+        null,\n+        AngularPass.INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\n+    );\n+\n+    test(\n+        \"/** @angularInject */(\" +\n+        \"function (a, b) {}\" +\n+        \")\",\n+        null,\n+        AngularPass.INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\n+    );\n+  }\n+\n+  public void testAngularInjectNonFunction() throws Exception {\n+    test(\n+        \"/** @angularInject */\" +\n+        \"var a = 10\",\n+        null,\n+        AngularPass.INJECT_NON_FUNCTION_ERROR\n+    );\n+\n+    test(\n+        \"/** @angularInject */\" +\n+        \"var x\",\n+        null,\n+        AngularPass.INJECT_NON_FUNCTION_ERROR\n+    );\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.generateExports = true;\n     test(options, \"/** @export */ function f() {}\",\n          \"/** @export */ function f() {} goog.exportSymbol('f', f);\");\n+  }\n+\n+  public void testAngularPassOff() {\n+    testSame(createCompilerOptions(),\n+        \"/** @angularInject */ function f() {} \" +\n+        \"/** @angularInject */ function g(a){} \" +\n+        \"/** @angularInject */ var b = function f(a) {} \");\n+  }\n+\n+  public void testAngularPassOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.angularPass = true;\n+    test(options,\n+        \"/** @angularInject */ function f() {} \" +\n+        \"/** @angularInject */ function g(a){} \" +\n+        \"/** @angularInject */ var b = function f(a, b, c) {} \",\n+\n+        \"function f() {} \" +\n+        \"function g(a) {} g.$inject=['a'];\" +\n+        \"var b = function f(a, b, c) {}; b.$inject=['a', 'b', 'c']\");\n   }\n \n   public void testExportTestFunctionsOff() {", "timestamp": 1359082385, "metainfo": ""}