{"sha": "8301ee7fec23ffdee9ea2c8ce5a8b80f343744e5", "log": "Modified ZipArchiveInputStream.Buffer to look more like a java.nio.ByteBuffer  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n                                  boolean allowStoredEntriesWithDataDescriptor) {\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        in = new PushbackInputStream(inputStream, buf.buf.length);\n+        in = new PushbackInputStream(inputStream, buf.capacity());\n         this.allowStoredEntriesWithDataDescriptor =\n             allowStoredEntriesWithDataDescriptor;\n     }\n             return -1;\n         }\n \n-        if (buf.offsetInBuffer >= buf.lengthOfLastRead) {\n-            buf.offsetInBuffer = 0;\n-            if ((buf.lengthOfLastRead = in.read(buf.buf)) == -1) {\n+        if (buf.position >= buf.limit) {\n+            buf.position = 0;\n+            if ((buf.limit = in.read(buf.array)) == -1) {\n                 return -1;\n             }\n-            count(buf.lengthOfLastRead);\n-            current.bytesReadFromStream += buf.lengthOfLastRead;\n-        }\n-\n-        int availableBytesInBuffer = buf.lengthOfLastRead - buf.offsetInBuffer;\n-        int toRead = Math.min(availableBytesInBuffer, length);\n+            count(buf.limit);\n+            current.bytesReadFromStream += buf.limit;\n+        }\n+\n+        int toRead = Math.min(buf.remaining(), length);\n         if ((csize - current.bytesRead) < toRead) {\n             // if it is smaller than toRead then it fits into an int\n             toRead = (int) (csize - current.bytesRead);\n         }\n-        System.arraycopy(buf.buf, buf.offsetInBuffer, buffer, start, toRead);\n-        buf.offsetInBuffer += toRead;\n+        System.arraycopy(buf.array, buf.position, buffer, start, toRead);\n+        buf.position += toRead;\n         current.bytesRead += toRead;\n         crc.update(buffer, start, toRead);\n         return toRead;\n                 throw new ZipException(\"This archive needs a preset dictionary\"\n                                        + \" which is not supported by Commons\"\n                                        + \" Compress.\");\n-            } else if (buf.lengthOfLastRead == -1) {\n+            } else if (buf.limit == -1) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n         }\n         do {\n             if (inf.needsInput()) {\n                 fill();\n-                if (buf.lengthOfLastRead > 0) {\n-                    current.bytesReadFromStream += buf.lengthOfLastRead;\n+                if (buf.limit > 0) {\n+                    current.bytesReadFromStream += buf.limit;\n                 } else {\n                     break;\n                 }\n \n             // Pushback any required bytes\n             if (diff > 0) {\n-                pushback(buf.buf, buf.lengthOfLastRead - diff, diff);\n+                pushback(buf.array, buf.limit - diff, diff);\n             }\n         }\n \n         long remaining = current.entry.getCompressedSize()\n             - current.bytesReadFromStream;\n         while (remaining > 0) {\n-            long n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\n-                                                        remaining));\n+            long n = in.read(buf.array, 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n                 throw new EOFException(\n                                        \"Truncated ZIP entry: \" + current.entry.getName());\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        if ((buf.lengthOfLastRead = in.read(buf.buf)) > 0) {\n-            count(buf.lengthOfLastRead);\n-            inf.setInput(buf.buf, 0, buf.lengthOfLastRead);\n+        if ((buf.limit = in.read(buf.array)) > 0) {\n+            count(buf.limit);\n+            inf.setInput(buf.array, 0, buf.limit);\n         }\n     }\n \n         int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n \n         while (!done) {\n-            int r = in.read(buf.buf, off,\n+            int r = in.read(buf.array, off,\n                             ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                 // read the whole archive without ever finding a\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n             if (r + off < 4) {\n-                // buf is too small to check for a signature, loop\n+                // buffer too small to check for a signature, loop\n                 off += r;\n                 continue;\n             }\n         boolean done = false;\n         int readTooMuch = 0;\n         for (int i = 0; !done && i < lastRead - 4; i++) {\n-            if (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\n-                if ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n-                    || (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n+            if (buf.array[i] == LFH[0] && buf.array[i + 1] == LFH[1]) {\n+                if ((buf.array[i + 2] == LFH[2] && buf.array[i + 3] == LFH[3])\n+                    || (buf.array[i] == CFH[2] && buf.array[i + 3] == CFH[3])) {\n                     // found a LFH or CFH:\n                     readTooMuch = offset + lastRead - i - expectedDDLen;\n                     done = true;\n                 }\n-                else if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n+                else if (buf.array[i + 2] == DD[2] && buf.array[i + 3] == DD[3]) {\n                     // found DD:\n                     readTooMuch = offset + lastRead - i;\n                     done = true;\n                     //   descriptor\n                     // * copy the remaining bytes to cache\n                     // * read data descriptor\n-                    pushback(buf.buf, offset + lastRead - readTooMuch,\n+                    pushback(buf.array, offset + lastRead - readTooMuch,\n                              readTooMuch);\n-                    bos.write(buf.buf, 0, i);\n+                    bos.write(buf.array, 0, i);\n                     readDataDescriptor();\n                 }\n             }\n                                int lastRead, int expecteDDLen) {\n         final int cacheable = offset + lastRead - expecteDDLen - 3;\n         if (cacheable > 0) {\n-            bos.write(buf.buf, 0, cacheable);\n-            System.arraycopy(buf.buf, cacheable, buf.buf, 0,\n+            bos.write(buf.array, 0, cacheable);\n+            System.arraycopy(buf.array, cacheable, buf.array, 0,\n                              expecteDDLen + 3);\n             offset = expecteDDLen + 3;\n         } else {\n      * Contains a temporary buffer used to read from the wrapped\n      * stream together with some information needed for internal\n      * housekeeping.\n+     * \n+     * This class is similar to a java.nio.ByteBuffer but can't be replaced,\n+     * because the limit contains the length of the last read operation and\n+     * when the end of the stream is reached the limit is thus set to -1.\n+     * This is not allowed for a ByteBuffer.\n      */\n     private static final class Buffer {\n         /**\n          * Buffer used as temporary buffer when reading from the stream.\n          */\n-        private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n+        private final byte[] array = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n+\n         /**\n-         * {@link #buf buf} may contain data the client hasnt read, yet,\n+         * {@link #array array} may contain data the client hasnt read, yet,\n          * this is the first byte that hasn't been read so far.\n          */\n-        private int offsetInBuffer = 0;\n+        private int position = 0;\n+\n         /**\n-         * Number of bytes read from the wrapped stream into {@link #buf\n-         * buf} with the last read operation.\n+         * Number of bytes read from the wrapped stream into {@link #array\n+         * array} with the last read operation.\n          */\n-        private int lengthOfLastRead = 0;\n+        private int limit = 0;\n+\n         /**\n          * Reset internal housekeeping.\n          */\n         private void reset() {\n-            offsetInBuffer = lengthOfLastRead = 0;\n+            position = limit = 0;\n+        }\n+\n+        /**\n+         * Returns the number of bytes left to read.\n+         */\n+        private int remaining() {\n+            return limit - position;\n+        }\n+\n+        /**\n+         * Returns the length of the buffer.\n+         */\n+        private int capacity() {\n+            return array.length;\n         }\n     }\n }", "timestamp": 1387404619, "metainfo": ""}