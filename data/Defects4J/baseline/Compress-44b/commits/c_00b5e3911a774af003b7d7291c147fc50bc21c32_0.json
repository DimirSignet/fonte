{"sha": "00b5e3911a774af003b7d7291c147fc50bc21c32", "log": "merge hard reset", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      */\n     private volatile boolean decompressConcatenated = false;\n \n-    private final int memoryLimitInKb;\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n         this.decompressUntilEOF = null;\n-        this.memoryLimitInKb = -1;\n-    }\n-\n-    /**\n-     * Create an instance with the provided decompress Concatenated option.\n-     *\n-     * @param decompressUntilEOF\n-     *            if true, decompress until the end of the input; if false, stop\n-     *            after the first stream and leave the input position to point\n-     *            to the next byte after the stream. This setting applies to the\n-     *            gzip, bzip2 and xz formats only.\n-     *\n-     * @param memoryLimitInKb\n-     *            Some streams require allocation of potentially significant\n-     *            byte arrays/tables, and they can offer checks to prevent OOMs\n-     *            on corrupt files.  Set the maximum allowed memory allocation in KBs.\n-     *\n-     * @since 1.14\n-     */\n-    public CompressorStreamFactory(final boolean decompressUntilEOF, final int memoryLimitInKb) {\n-        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the\n-        // current value\n-        this.decompressConcatenated = decompressUntilEOF;\n-        this.memoryLimitInKb = memoryLimitInKb;\n-    }\n-\n+    }\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n-        this(decompressUntilEOF, -1);\n+        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n+        this.decompressConcatenated = decompressUntilEOF;\n     }\n \n     /**\n                 if (!XZUtils.isXZCompressionAvailable()) {\n                     throw new CompressorException(\"XZ compression is not available.\");\n                 }\n-                return new XZCompressorInputStream(in, actualDecompressConcatenated, memoryLimitInKb);\n+                return new XZCompressorInputStream(in, actualDecompressConcatenated);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                return new LZMACompressorInputStream(in, memoryLimitInKb);\n+                return new LZMACompressorInputStream(in);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                return new ZCompressorInputStream(in, memoryLimitInKb);\n+                return new ZCompressorInputStream(in);\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n import org.junit.Test;\n \n @SuppressWarnings(\"deprecation\") // deliberately tests setDecompressConcatenated\n         }\n     }\n \n+    @Before\n+    public void setUp() {\n+        //make sure to reset this before each test\n+        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        //make sure this is really, truly reset after all the tests\n+        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n+    }\n+\n     private final TestData[] tests = {\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factoryTrue, true),\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factorySetTrue, true),\n         //This test is here instead of the xz unit test to make sure\n         //that the parameter is properly passed via the CompressorStreamFactory\n         try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n-            int c = compressorIs.read();\n+            compressorIs.read();\n         }\n     }\n \n     }\n \n     private InputStream getStreamFor(final String fileName, final int memoryLimitInKb) throws Exception {\n-        CompressorStreamFactory fac = new CompressorStreamFactory(true,\n-                memoryLimitInKb);\n+        MemoryLimit.setMemoryLimitInKb(memoryLimitInKb);\n+        CompressorStreamFactory fac = new CompressorStreamFactory(true);\n         InputStream is = new BufferedInputStream(\n                 new FileInputStream(getFile(fileName)));\n         try {\n--- a/src/main/java/org/apache/commons/compress/MemoryLimitException.java\n+++ b/src/main/java/org/apache/commons/compress/MemoryLimitException.java\n  * if a stream tries to allocate a byte array that is larger than\n  * the allowable limit.\n  *\n- * <p/>\n- * Set the global memory limit via {@link MemoryLimit#setMemoryLimitInKb(int)}.\n- *\n  * @since 1.14\n  */\n public class MemoryLimitException extends IOException {\n \n-    /**\n-     *\n-     * @param memoryNeeded estimated memory needed\n-     * @param memoryLimit memory limit applied\n-     */\n-    public MemoryLimitException(long memoryNeeded, int memoryLimit) {\n-        super(\"\" + memoryNeeded + \" KiB of memory would be needed; limit was \"\n-                + memoryLimit + \" KiB.  If the file is not corrupt, consider \" +\n-                \"increasing MemoryLimit.MEMORY_LIMIT_IN_KB.\");\n+    //long instead of int to account for overflow for corrupt files\n+    private final long memoryNeededInKb;\n+    private final int memoryLimitInKb;\n+\n+    public MemoryLimitException(long memoryNeededInKb, int memoryLimitInKb) {\n+        super(buildMessage(memoryNeededInKb, memoryLimitInKb));\n+        this.memoryNeededInKb = memoryNeededInKb;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n+    public MemoryLimitException(long memoryNeededInKb, int memoryLimitInKb, Exception e) {\n+        super(buildMessage(memoryNeededInKb, memoryLimitInKb), e);\n+        this.memoryNeededInKb = memoryNeededInKb;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n+    public long getMemoryNeededInKb() {\n+        return memoryNeededInKb;\n+    }\n+\n+    public int getMemoryLimitInKb() {\n+        return memoryLimitInKb;\n+    }\n+\n+    private static String buildMessage(long memoryNeededInKb, int memoryLimitInKb) {\n+        return \"\" + memoryNeededInKb + \" kb of memory would be needed; limit was \"\n+                + memoryLimitInKb + \" kb. \" +\n+                \"If the file is not corrupt, consider increasing the memory limit.\";\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.LZMAInputStream;\n \n public class LZMACompressorInputStream extends CompressorInputStream {\n     private final InputStream in;\n \n+    public LZMACompressorInputStream(final InputStream inputStream)\n+            throws IOException {\n+        in = new LZMAInputStream(inputStream, -1);\n+    }\n+\n     /**\n      * Creates a new input stream that decompresses LZMA-compressed data\n      * from the specified input stream.\n      *\n      * @param       inputStream where to read the compressed data\n      *\n+     * @param       memoryLimitInKb calculated memory use threshold.  Throws MemoryLimitException\n+     *                            if calculate memory use is above this threshold\n+     *\n      * @throws      IOException if the input is not in the .lzma format,\n      *                          the input is corrupt or truncated, the .lzma\n      *                          headers specify sizes that are not supported\n-     *                          by this implementation, the underlying\n-     *                          <code>inputStream</code> throws an exception or\n-     *                          if the calculated memory usage\n-     *                          is &gt; {@link MemoryLimit#MEMORY_LIMIT_IN_KB}.\n+     *                          by this implementation, or the underlying\n+     *                          <code>inputStream</code> throws an exception\n      *\n      * @since 1.14\n      */\n-    public LZMACompressorInputStream(final InputStream inputStream)\n+    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n             throws IOException {\n         try {\n-            in = new LZMAInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n+            in = new LZMAInputStream(inputStream, memoryLimitInKb);\n         } catch (org.tukaani.xz.MemoryLimitException e) {\n             //convert to commons-compress exception\n-            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit());\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n-import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.compressors.CompressorInputStream;\n import org.apache.commons.compress.utils.BitInputStream;\n \n     /**\n      * Initializes the arrays based on the maximum code size.\n+     * First checks that the estimated memory usage is below memoryLimitInKb\n+     *\n      * @param maxCodeSize maximum code size\n-     *\n-     * @throws MemoryLimitException\n-     *      if the calculated memory usage, based on the maxTableSize,\n-     *      is &gt; {@link MemoryLimit#MEMORY_LIMIT_IN_KB}\n-     */\n-    protected void initializeTables(final int maxCodeSize) throws MemoryLimitException {\n+     * @param memoryLimitInKb maximum allowed estimated memory usage in Kb\n+     * @throws MemoryLimitException if estimated memory usage is greater than memoryLimitInKb\n+     */\n+    protected void initializeTables(final int maxCodeSize, final int memoryLimitInKb)\n+            throws MemoryLimitException {\n+\n+        if (memoryLimitInKb > -1) {\n+            final int maxTableSize = 1 << maxCodeSize;\n+            //account for potential overflow\n+            long memoryUsageInBytes = (long) maxTableSize * 6;//(4 (prefixes) + 1 (characters) +1 (outputStack))\n+            long memoryUsageInKb = memoryUsageInBytes >> 10;\n+\n+            if (memoryUsageInKb > (long)memoryLimitInKb) {\n+                throw new MemoryLimitException(memoryUsageInKb, memoryLimitInKb);\n+            }\n+        }\n+        initializeTables(maxCodeSize);\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n+     * @param maxCodeSize maximum code size\n+     */\n+    protected void initializeTables(final int maxCodeSize) {\n         final int maxTableSize = 1 << maxCodeSize;\n-\n-        //account for potential overflow\n-        long memoryUsageInBytes = (long)maxTableSize * 6;//(4 (prefixes) + 1 (characters) +1 (outputStack))\n-        MemoryLimit.checkLimitInKb(memoryUsageInBytes >> 10);\n-\n         prefixes = new int[maxTableSize];\n         characters = new byte[maxTableSize];\n         outputStack = new byte[maxTableSize];\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.XZ;\n import org.tukaani.xz.SingleXZInputStream;\n     public XZCompressorInputStream(final InputStream inputStream,\n                                    final boolean decompressConcatenated)\n             throws IOException {\n+        this(inputStream, decompressConcatenated, -1);\n+    }\n \n+    /**\n+     * Creates a new input stream that decompresses XZ-compressed data\n+     * from the specified input stream.\n+     *\n+     * @param       inputStream where to read the compressed data\n+     * @param       decompressConcatenated\n+     *                          if true, decompress until the end of the\n+     *                          input; if false, stop after the first .xz\n+     *                          stream and leave the input position to point\n+     *                          to the next byte after the .xz stream\n+     * @param       memoryLimitInKb memory limit used when reading blocks.  If\n+     *                          the estimated memory limit is exceeded on {@link #read()},\n+     *                          a {@link MemoryLimitException} is thrown.\n+     *\n+     * @throws      IOException if the input is not in the .xz format,\n+     *                          the input is corrupt or truncated, the .xz\n+     *                          headers specify options that are not supported\n+     *                          by this implementation,\n+     *                          or the underlying <code>inputStream</code> throws an exception\n+     *\n+     * @since 1.14\n+     */\n+    public XZCompressorInputStream(InputStream inputStream,\n+                                   boolean decompressConcatenated, final int memoryLimitInKb)\n+            throws IOException {\n         if (decompressConcatenated) {\n-            in = new XZInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n+            in = new XZInputStream(inputStream, memoryLimitInKb);\n         } else {\n-            in = new SingleXZInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n+            in = new SingleXZInputStream(inputStream, memoryLimitInKb);\n         }\n     }\n \n             count(ret == -1 ? -1 : 1);\n             return ret;\n         } catch (org.tukaani.xz.MemoryLimitException e) {\n-            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit());\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n         }\n     }\n \n             return ret;\n         } catch (org.tukaani.xz.MemoryLimitException e) {\n             //convert to commons-compress MemoryLimtException\n-            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit());\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n         }\n     }\n \n             return in.skip(n);\n         } catch (org.tukaani.xz.MemoryLimitException e) {\n             //convert to commons-compress MemoryLimtException\n-            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit());\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n     private final int maxCodeSize;\n     private long totalCodesRead = 0;\n \n-    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+    public ZCompressorInputStream(final InputStream inputStream, final int memoryLimitInKb)\n+            throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         final int firstByte = (int) in.readBits(8);\n         final int secondByte = (int) in.readBits(8);\n         if (blockMode) {\n             setClearCode(DEFAULT_CODE_SIZE);\n         }\n-        initializeTables(maxCodeSize);\n+        initializeTables(maxCodeSize, memoryLimitInKb);\n         clearEntries();\n+    }\n+\n+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, -1);\n     }\n     \n     private void clearEntries() {\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n             return fac.createCompressorInputStream(is);\n         } catch (CompressorException e) {\n             if (e.getCause() != null && e.getCause() instanceof Exception) {\n-                //unwrap cause to reveal MemoryLimiteException\n+                //unwrap cause to reveal MemoryLimitException\n                 throw (Exception)e.getCause();\n             } else {\n                 throw e;", "timestamp": 1493124811, "metainfo": ""}