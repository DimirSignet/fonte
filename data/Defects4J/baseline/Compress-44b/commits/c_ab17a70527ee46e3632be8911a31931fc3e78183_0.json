{"sha": "ab17a70527ee46e3632be8911a31931fc3e78183", "log": "Add missing '@Override' annotations to implementations of interface methods.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n              0, 0, DEFAULT_MODE, inputFile.lastModified() / 1000);\n     }\n \n+    @Override\n     public long getSize() {\n         return this.getLength();\n     }\n \n+    @Override\n     public String getName() {\n         return name;\n     }\n         return lastModified;\n     }\n \n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(1000 * getLastModified());\n     }\n         return length;\n     }\n \n+    @Override\n     public boolean isDirectory() {\n         return false;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n      *\n      * @return This entry's name.\n      */\n+    @Override\n     public String getName() {\n         if ((localFileHeader.arjFlags & LocalFileHeader.Flags.PATHSYM) != 0) {\n             return localFileHeader.name.replaceAll(\"/\",\n      *\n      * @return This entry's file size.\n      */\n+    @Override\n     public long getSize() {\n         return localFileHeader.originalSize;\n     }\n      *\n      * @return True if the entry refers to a directory\n      */\n+    @Override\n     public boolean isDirectory() {\n         return localFileHeader.fileType == LocalFileHeader.FileTypes.DIRECTORY;\n     }\n      *\n      * @return the last modified date\n      */\n+    @Override\n     public Date getLastModifiedDate() {\n         long ts = isHostOsUnix() ? localFileHeader.dateTimeModified * 1000l\n             : ZipUtil.dosToJavaTime(0xFFFFFFFFL & localFileHeader.dateTimeModified);\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * @return Returns the filesize.\n      * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n      */\n+    @Override\n     public long getSize() {\n         return this.filesize;\n     }\n      * \n      * @return Returns the name.\n      */\n+    @Override\n     public String getName() {\n         return this.name;\n     }\n         return this.mtime;\n     }\n \n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(1000 * getTime());\n     }\n      * \n      * @return TRUE if this entry is a directory.\n      */\n+    @Override\n     public boolean isDirectory() {\n         return CpioUtil.fileType(mode) == C_ISDIR;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n      * Returns the name of the entry.\n      * @return the name of the entry.\n      */\n+    @Override\n     public String getName() {\n         return name;\n     }\n      * The last modified date.\n      * @return the last modified date\n      */\n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(mtime);\n     }\n      * Is this a directory?\n      * @return whether this is a directory\n      */\n+    @Override\n     public boolean isDirectory() {\n         return type == TYPE.DIRECTORY;\n     }\n      * Returns the size of the entry.\n      * @return the size\n      */\n+    @Override\n     public long getSize() {\n         return isDirectory() ? SIZE_UNKNOWN : size;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n         // released first.\n         queue = new PriorityQueue<DumpArchiveEntry>(10,\n                 new Comparator<DumpArchiveEntry>() {\n+                    @Override\n                     public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n                         if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                             return Integer.MAX_VALUE;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n      *\n      * @return This entry's name.\n      */\n+    @Override\n     public String getName() {\n         return name;\n     }\n      *\n      * @return True if this entry is a directory.\n      */\n+    @Override\n     public boolean isDirectory() {\n         return isDirectory;\n     }\n      * last modified date.\n      * @return the last modified date\n      */\n+    @Override\n     public Date getLastModifiedDate() {\n         if (hasLastModifiedDate) {\n             return ntfsTimeToJavaTime(lastModifiedDate);\n      *\n      * @return This entry's file size.\n      */\n+    @Override\n     public long getSize() {\n         return size;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n      * Closes the archive.\n      * @throws IOException if closing the file fails\n      */\n+    @Override\n     public void close() throws IOException {\n         if (file != null) {\n             try {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n      * \n      * @throws IOException on error\n      */\n+    @Override\n     public void close() throws IOException {\n         if (!finished) {\n             finish();\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      *\n      * @return This entry's name.\n      */\n+    @Override\n     public String getName() {\n         return name;\n     }\n         return new Date(modTime * MILLIS_PER_SECOND);\n     }\n \n+    @Override\n     public Date getLastModifiedDate() {\n         return getModTime();\n     }\n      *\n      * @return This entry's file size.\n      */\n+    @Override\n     public long getSize() {\n         return size;\n     }\n      *\n      * @return True if this entry is a directory.\n      */\n+    @Override\n     public boolean isDirectory() {\n         if (file != null) {\n             return file.isDirectory();\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * ZipEncoding.\n      */\n     static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n+            @Override\n             public boolean canEncode(String name) { return true; }\n \n+            @Override\n             public ByteBuffer encode(String name) {\n                 final int length = name.length();\n                 byte[] buf = new byte[length];\n                 return ByteBuffer.wrap(buf);\n             }\n \n+            @Override\n             public String decode(byte[] buffer) {\n                 final int length = buffer.length;\n                 StringBuilder result = new StringBuilder(length);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n         data = null;\n     }\n \n+    @Override\n     public byte[] getCentralDirectoryData() {\n         if (data == null) {\n             this.assembleData();\n         return b;\n     }\n \n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         if (data == null) {\n             assembleData();\n         return new ZipShort(data != null ? data.length : 0);\n     }\n \n+    @Override\n     public byte[] getLocalFileDataData() {\n         return getCentralDirectoryData();\n     }\n \n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return getCentralDirectoryLength();\n     }\n \n+    @Override\n     public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n         throws ZipException {\n \n      * Doesn't do anything special since this class always uses the\n      * same data in central directory and local file data.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length)\n         throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n      * The Header-ID.\n      * @return the value for the header id for this extrafield\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n      * Header-ID or length specifier.\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(WORD         // CRC\n                           + 2         // Mode\n      * Delegate to local file data.\n      * @return the centralDirectory length\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return getLocalFileDataLength();\n     }\n      * or length specifier.\n      * @return get the data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         // CRC will be added later\n         byte[] data = new byte[getLocalFileDataLength().getValue() - WORD];\n      * Delegate to local file data.\n      * @return the local file data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         return getLocalFileDataData();\n     }\n      * @param length the number of bytes in the array from offset\n      * @throws ZipException on error\n      */\n+    @Override\n     public void parseFromLocalFileData(byte[] data, int offset, int length)\n         throws ZipException {\n \n      * Doesn't do anything special since this class always uses the\n      * same data in central directory and local file data.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length)\n         throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n+    @Override\n     public boolean canEncode(String name) {\n         return true;\n     }\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n+    @Override\n     public ByteBuffer encode(String name) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return ByteBuffer.wrap(name.getBytes());\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n+    @Override\n     public String decode(byte[] data) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return new String(data);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n      * The Header-ID.\n      * @return the header id\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return ID;\n     }\n      * Header-ID or length specifier.\n      * @return 0\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return NULL;\n     }\n      * Header-ID or length specifier.\n      * @return 0\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return NULL;\n     }\n      * or length specifier.\n      * @return the data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         return NO_BYTES;\n     }\n      * length specifier.\n      * @return the data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         return NO_BYTES;\n     }\n      *\n      * @throws ZipException on error\n      */\n+    @Override\n     public void parseFromLocalFileData(byte[] data, int offset, int length)\n         throws ZipException {\n         if (length != 0) {\n      * Doesn't do anything special since this class always uses the\n      * same data in central directory and local file data.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length)\n         throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n+    @Override\n     public boolean canEncode(String name) {\n         CharsetEncoder enc = this.charset.newEncoder();\n         enc.onMalformedInput(CodingErrorAction.REPORT);\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n+    @Override\n     public ByteBuffer encode(String name) {\n         CharsetEncoder enc = this.charset.newEncoder();\n \n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n+    @Override\n     public String decode(byte[] data) throws IOException {\n         return this.charset.newDecoder()\n             .onMalformedInput(CodingErrorAction.REPORT)\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n      *\n      * @return the header id\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return headerId;\n     }\n      *\n      * @return the length of the local data\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(localData != null ? localData.length : 0);\n     }\n      *\n      * @return the local data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         return ZipUtil.copy(localData);\n     }\n      *\n      * @return the central data length\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         if (centralData != null) {\n             return new ZipShort(centralData.length);\n      *\n      * @return the central data if present, else return the local file data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         if (centralData != null) {\n             return ZipUtil.copy(centralData);\n      *            the number of bytes to use in the data array.\n      * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n      */\n+    @Override\n     public void parseFromLocalFileData(byte[] data, int offset, int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n      *            the number of bytes to use in the data array.\n      * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n     private static class DefaultBackingStoreSupplier implements ScatterGatherBackingStoreSupplier {\n         final AtomicInteger storeNum = new AtomicInteger(0);\n \n+        @Override\n         public ScatterGatherBackingStore get() throws IOException {\n             File tempFile = File.createTempFile(\"parallelscatter\", \"n\" + storeNum.incrementAndGet());\n             return new FileBasedScatterGatherBackingStore(tempFile);\n         }\n         final ZipArchiveEntryRequest zipArchiveEntryRequest = createZipArchiveEntryRequest(zipArchiveEntry, source);\n         return new Callable<Object>() {\n+            @Override\n             public Object call() throws Exception {\n                 tlScatterStreams.get().addArchiveEntry(zipArchiveEntryRequest);\n                 return null;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n      * Closes this stream, freeing all resources involved in the creation of this stream.\n      * @throws IOException If closing fails\n      */\n+    @Override\n     public void close() throws IOException {\n         backingStore.close();\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n             this.unicode = unicode;\n         }\n \n+        @Override\n         public int compareTo(Simple8BitChar a) {\n             return this.unicode - a.unicode;\n         }\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n+    @Override\n     public boolean canEncode(String name) {\n \n         for (int i=0;i<name.length();++i) {\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n+    @Override\n     public ByteBuffer encode(String name) {\n         ByteBuffer out = ByteBuffer.allocate(name.length()\n                                              + 6 + (name.length() + 1) / 2);\n      * @see\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n+    @Override\n     public String decode(byte[] data) throws IOException {\n         char [] ret = new char[data.length];\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n         writtenToOutputStreamForLastEntry = 0;\n     }\n \n+    @Override\n     public void close() throws IOException {\n         def.end();\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n         super(comment, bytes);\n     }\n \n+    @Override\n     public ZipShort getHeaderId() {\n         return UCOM_ID;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n         super(name, bytes);\n     }\n \n+    @Override\n     public ZipShort getHeaderId() {\n         return UPATH_ID;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n      *\n      * @return a completely arbitrary value that should be ignored.\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n      *\n      * @return The LocalFileDataLength value\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(localFileData == null ? 0 : localFileData.length);\n     }\n      *\n      * @return The CentralDirectoryLength value\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return centralDirectoryData == null\n             ? getLocalFileDataLength()\n      *\n      * @return The LocalFileDataData value\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         return ZipUtil.copy(localFileData);\n     }\n      *\n      * @return The CentralDirectoryData value\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         return centralDirectoryData == null\n             ? getLocalFileDataData() : ZipUtil.copy(centralDirectoryData);\n      * @param offset offset into buffer to read data\n      * @param length the length of data\n      */\n+    @Override\n     public void parseFromLocalFileData(byte[] buffer, int offset, int length) {\n         localFileData = new byte[length];\n         System.arraycopy(buffer, offset, localFileData, 0, length);\n      * @param offset offset into buffer to read data\n      * @param length the length of data\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length) {\n         centralDirectoryData = new byte[length];\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n      * Get the header id.\n      * @return the header id\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return headerId;\n     }\n      * Get the length of the local data.\n      * @return the length of the local data\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(localData != null ? localData.length : 0);\n     }\n      * Get the local data.\n      * @return the local data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         return ZipUtil.copy(localData);\n     }\n      * If there is no central data, get the local file data length.\n      * @return the central data length\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         if (centralData != null) {\n             return new ZipShort(centralData.length);\n      * Get the central data.\n      * @return the central data if present, else return the local file data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         if (centralData != null) {\n             return ZipUtil.copy(centralData);\n      * @param length the number of bytes to use in the data array.\n      * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n      */\n+    @Override\n     public void parseFromLocalFileData(byte[] data, int offset, int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n      * @param length the number of bytes to use in the data array.\n      * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(byte[] data, int offset,\n                                               int length) {\n         byte[] tmp = new byte[length];\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n      *\n      * @return the value for the header id for this extrafield\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(4 /* reserved */\n                             + 2 /* Tag#1 */\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return getLocalFileDataLength();\n     }\n      *\n      * @return get the data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         byte[] data = new byte[getLocalFileDataLength().getValue()];\n         int pos = 4;\n      *\n      * @return the central directory data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         return getLocalFileDataData();\n     }\n      * @param length the number of bytes in the array from offset\n      * @throws java.util.zip.ZipException on error\n      */\n+    @Override\n     public void parseFromLocalFileData(\n             byte[] data, int offset, int length\n     ) throws ZipException {\n      * Doesn't do anything special since this class always uses the\n      * same parsing logic for both central directory and local file data.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(\n             byte[] buffer, int offset, int length\n     ) throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n      *\n      * @return the value for the header id for this extrafield\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(1 +\n                 (bit0_modifyTimePresent ? 4 : 0) +\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return new ZipShort(1 +\n                 (bit0_modifyTimePresent ? 4 : 0)\n      *\n      * @return get the data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         byte[] data = new byte[getLocalFileDataLength().getValue()];\n         int pos = 0;\n      *\n      * @return the central directory data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n         byte[] localData = getLocalFileDataData();\n      * @param length the number of bytes in the array from offset\n      * @throws java.util.zip.ZipException on error\n      */\n+    @Override\n     public void parseFromLocalFileData(\n             byte[] data, int offset, int length\n     ) throws ZipException {\n      * Doesn't do anything special since this class always uses the\n      * same parsing logic for both central directory and local file data.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(\n             byte[] buffer, int offset, int length\n     ) throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n      *\n      * @return the value for the header id for this extrafield\n      */\n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n         int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n      *\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return ZERO;\n     }\n      *\n      * @return get the data\n      */\n+    @Override\n     public byte[] getLocalFileDataData() {\n         byte[] uidBytes = uid.toByteArray();\n         byte[] gidBytes = gid.toByteArray();\n      *\n      * @return get the data\n      */\n+    @Override\n     public byte[] getCentralDirectoryData() {\n         return new byte[0];\n     }\n      * @param length the number of bytes in the array from offset\n      * @throws java.util.zip.ZipException on error\n      */\n+    @Override\n     public void parseFromLocalFileData(\n             byte[] data, int offset, int length\n     ) throws ZipException {\n      * Doesn't do anything since this class doesn't store anything\n      * inside the central directory.\n      */\n+    @Override\n     public void parseFromCentralDirectoryData(\n             byte[] buffer, int offset, int length\n     ) throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n         this.diskStart = diskStart;\n     }\n \n+    @Override\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n     }\n \n+    @Override\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(size != null ? 2 * DWORD : 0);\n     }\n \n+    @Override\n     public ZipShort getCentralDirectoryLength() {\n         return new ZipShort((size != null ? DWORD : 0)\n                             + (compressedSize != null ? DWORD : 0)\n                             + (diskStart != null ? WORD : 0));\n     }\n \n+    @Override\n     public byte[] getLocalFileDataData() {\n         if (size != null || compressedSize != null) {\n             if (size == null || compressedSize == null) {\n         return EMPTY;\n     }\n \n+    @Override\n     public byte[] getCentralDirectoryData() {\n         byte[] data = new byte[getCentralDirectoryLength().getValue()];\n         int off = addSizes(data);\n         return data;\n     }\n \n+    @Override\n     public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n         throws ZipException {\n         if (length == 0) {\n         }\n     }\n \n+    @Override\n     public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                               int length)\n         throws ZipException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      * leak through and the returned value may depend on your local\n      * time zone as well as your version of Java.</p>\n      */\n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date(getTime());\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * Closes the archive.\n      * @throws IOException if an error occurs closing the archive.\n      */\n+    @Override\n     public void close() throws IOException {\n         // this flag is only written here and read in finalize() which\n         // can never be run in parallel.\n      */\n     private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n         new Comparator<ZipArchiveEntry>() {\n+        @Override\n         public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n             if (e1 == e2) {\n                 return 0;\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n         ArchiveInputStreamIterator(ArchiveInputStream in) {\n             this.in = in;\n         }\n+        @Override\n         public boolean hasNext() throws IOException {\n             return (next = in.getNextEntry()) != null;\n         }\n+        @Override\n         public ArchiveEntry next() {\n             return next;\n         }\n+        @Override\n         public InputStream getInputStream() {\n             return in;\n         }\n             this.in = in;\n             nestedEnum = in.getEntriesInPhysicalOrder();\n         }\n+        @Override\n         public boolean hasNext() {\n             return nestedEnum.hasMoreElements();\n         }\n+        @Override\n         public ArchiveEntry next() {\n             return current = nestedEnum.nextElement();\n         }\n+        @Override\n         public InputStream getInputStream() throws IOException {\n             return in.getInputStream(current);\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n     reset();\n   }\n \n-  public long getValue() {\n+  @Override\n+public long getValue() {\n     long ret = crc;\n     return (~ret) & 0xffffffffL;\n   }\n \n-  public void reset() {\n+  @Override\n+public void reset() {\n     crc = 0xffffffff;\n   }\n \n-  public void update(byte[] b, int off, int len) {\n+  @Override\n+public void update(byte[] b, int off, int len) {\n     int localCrc = crc;\n \n     while(len > 7) {\n     crc = localCrc;\n   }\n \n-  final public void update(int b) {\n+  @Override\n+final public void update(int b) {\n     crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\n   }\n     \n--- a/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n         os = new FileOutputStream(target);\n     }\n \n+    @Override\n     public InputStream getInputStream() throws IOException {\n         return new FileInputStream(target);\n     }\n \n+    @Override\n     @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n     public void closeForWriting() throws IOException {\n         if (!closed) {\n         }\n     }\n \n+    @Override\n     public void writeOut(byte[] data, int offset, int length) throws IOException {\n         os.write(data, offset, length);\n     }\n \n+    @Override\n     public void close() throws IOException {\n         closeForWriting();\n         target.delete();\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n         this.byteOrder = byteOrder;\n     }\n     \n+    @Override\n     public void close() throws IOException {\n         in.close();\n     }\n--- a/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n         assertTrue(ARCDIR.exists());\n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n+            @Override\n             public boolean accept(File dir, String name) {\n                 return !name.endsWith(\".txt\");\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n     public static Collection<Object[]> data() {\n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n+            @Override\n             public boolean accept(File dir, String name) {\n                 return !name.endsWith(\".txt\");\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n     public static Collection<Object[]> data() {\n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n+            @Override\n             public boolean accept(File dir, String name) {\n                 return !name.endsWith(\".txt\");\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n     String first_payload = \"ABBA\";\n     String second_payload = \"AAAAAAAAAAAA\";\n     ZipArchiveEntryPredicate allFilesPredicate = new ZipArchiveEntryPredicate() {\n+        @Override\n         public boolean test(ZipArchiveEntry zipArchiveEntry) {\n             return true;\n         }\n--- a/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveEntry.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveEntry.java\n         name = pName;\n     }\n \n+    @Override\n     public String getName() {\n         return name;\n     }\n \n+    @Override\n     public long getSize() {\n         // TODO Auto-generated method stub\n         return 0;\n     }\n \n+    @Override\n     public boolean isDirectory() {\n         // TODO Auto-generated method stub\n         return false;\n     }\n \n+    @Override\n     public Date getLastModifiedDate() {\n         return new Date();\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n         ExecutorService es = Executors.newFixedThreadPool(1);\n \n         ScatterGatherBackingStoreSupplier supp = new ScatterGatherBackingStoreSupplier() {\n+            @Override\n             public ScatterGatherBackingStore get() throws IOException {\n                 return new FileBasedScatterGatherBackingStore(tmp = File.createTempFile(\"parallelscatter\", \"n1\"));\n             }\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n             ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n             zipCreator.addArchiveEntry(za, new InputStreamSupplier() {\n+                @Override\n                 public InputStream get() {\n                     return new ByteArrayInputStream(payloadBytes);\n                 }\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n             ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n             final Callable<Object> callable = zipCreator.createCallable(za, new InputStreamSupplier() {\n+                @Override\n                 public InputStream get() {\n                     return new ByteArrayInputStream(payloadBytes);\n                 }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n         ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"test1.xml\");\n         archiveEntry.setMethod(ZipEntry.DEFLATED);\n         InputStreamSupplier supp = new InputStreamSupplier() {\n+            @Override\n             public InputStream get() {\n                 return new ByteArrayInputStream(\"Hello\".getBytes());\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n \n     private InputStreamSupplier createPayloadSupplier(final ByteArrayInputStream payload) {\n         return new InputStreamSupplier() {\n+            @Override\n             public InputStream get() {\n                 return payload;\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n \n     private static ZipOutputTest write100KFiles(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n \n     private static final ZipOutputTest write100KFilesModeNever =\n         new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n         throws Throwable {\n         withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\",\n                              new ZipOutputTest() {\n-                                 public void test(File f,\n+                                 @Override\n+                                public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      write100KFilesToStream(zos);\n     private static ZipOutputTest\n         write3EntriesCreatingBigArchive(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n \n     private static final ZipOutputTest write3EntriesCreatingBigArchiveModeNever =\n         new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n         throws Throwable {\n         withTemporaryArchive(\"read3EntriesCreatingBigArchiveFileUsingZipFile\",\n                              new ZipOutputTest() {\n-                                 public void test(File f,\n+                                 @Override\n+                                public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      write3EntriesCreatingBigArchiveToStream(zos);\n     private static ZipOutputTest writeBigStoredEntry(final boolean knownSize,\n                                                      final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n     private static ZipOutputTest\n         writeBigStoredEntryModeNever(final boolean knownSize) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n         writeBigDeflatedEntryToStream(final boolean knownSize,\n                                       final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f,\n                              ZipArchiveOutputStream zos)\n                 throws IOException {\n     private static ZipOutputTest\n         writeBigDeflatedEntryUnknownSizeToStream(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 try {\n         writeBigDeflatedEntryToFile(final boolean knownSize,\n                                     final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeNever\",\n                              new ZipOutputTest() {\n-                                 public void test(File f,\n+                                 @Override\n+                                public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      zos.setUseZip64(Zip64Mode.Never);\n     private static ZipOutputTest\n         writeBigDeflatedEntryToFileModeNever(final boolean knownSize) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n     private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize,\n                                                        final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n     private static ZipOutputTest\n         writeSmallStoredEntryModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n         writeSmallDeflatedEntryToStream(final boolean knownSize,\n                                         final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n     private static ZipOutputTest\n         writeSmallDeflatedEntryToStreamModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n         writeSmallDeflatedEntryToFile(final boolean knownSize,\n                                       final Zip64Mode mode) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n     private static ZipOutputTest\n         writeSmallDeflatedEntryToFileModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n+            @Override\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n--- a/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n     @Test\n     public void testDefaultExtraction() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws IOException {\n                 return new FramedSnappyCompressorInputStream(is);\n             }\n     @Test\n     public void testDefaultExtractionViaFactory() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(CompressorStreamFactory.SNAPPY_FRAMED,\n     @Test\n     public void testDefaultExtractionViaFactoryAutodetection() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws Exception {\n                 return new CompressorStreamFactory().createCompressorInputStream(is);\n             }\n--- a/src/test/java/org/apache/commons/compress/compressors/ZTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/ZTestCase.java\n     @Test\n     public void testZUnarchive() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws IOException {\n                 return new ZCompressorInputStream(is);\n             }\n     @Test\n     public void testZUnarchiveViaFactory() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(CompressorStreamFactory.Z, is);\n     @Test\n     public void testZUnarchiveViaAutoDetection() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n+            @Override\n             public CompressorInputStream wrap(InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(new BufferedInputStream(is));\n--- a/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n     @Test\n     public void skipUsingSkip() throws Exception {\n         skip(new StreamWrapper() {\n+                @Override\n                 public InputStream wrap(InputStream toWrap) {\n                     return toWrap;\n                 }\n     @Test\n     public void skipUsingRead() throws Exception {\n         skip(new StreamWrapper() {\n+                @Override\n                 public InputStream wrap(InputStream toWrap) {\n                     return new FilterInputStream(toWrap) {\n                         @Override\n     @Test\n     public void skipUsingSkipAndRead() throws Exception {\n         skip(new StreamWrapper() {\n+                @Override\n                 public InputStream wrap(final InputStream toWrap) {\n                     return new FilterInputStream(toWrap) {\n                         boolean skipped;", "timestamp": 1460217857, "metainfo": ""}