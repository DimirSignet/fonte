{"sha": "1845f089720f61cc0ba1227742ab3ccc92b99c70", "log": "COMPRESS-271 incomplete implementation of writing block LZ4 streams  the current code doesn't fulfill the \"specific parsing rules\", yet. This means the resulting output is not valid right now.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n import java.io.IOException;\n import java.io.OutputStream;\n import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n \n         start writing the literal before we know how long the next\n         back-reference is going to be.\n \n-      * there is a special rule for the final blocks\n+      * there are special rules for the final blocks\n \n         > There are specific parsing rules to respect in order to remain\n         > compatible with assumptions made by the decoder :\n     private final byte[] oneByte = new byte[1];\n \n     private boolean finished = false;\n+\n+    private Deque<Pair> pairs = new LinkedList<>();\n \n     /**\n      * Creates a new LZ4 output stream.\n     }\n \n     private void addLiteralBlock(LZ77Compressor.LiteralBlock block) throws IOException {\n+        Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());\n+        last.addLiteral(block);\n     }\n \n     private void addBackReference(LZ77Compressor.BackReference block) throws IOException {\n+        Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());\n+        last.setBackReference(block);\n+    }\n+\n+    private Pair writeBlocksAndReturnUnfinishedPair(int length) throws IOException {\n+        writeWritablePairs(length);\n+        Pair last = pairs.peekLast();\n+        if (last == null || last.hasBackReference()) {\n+            last = new Pair();\n+            pairs.addLast(last);\n+        }\n+        return last;\n     }\n \n     private void writeFinalLiteralBlock() throws IOException {\n+        rewriteLastPairs();\n+        for (Pair p : pairs) {\n+            if (!p.hasBeenWritten()) {\n+                p.writeTo(os);\n+            }\n+        }\n+        pairs.clear();\n+    }\n+\n+    private void writeWritablePairs(int lengthOfBlocksAfterLastPair) throws IOException {\n+        int unwrittenLength = lengthOfBlocksAfterLastPair;\n+        for (Iterator<Pair> it = pairs.descendingIterator(); it.hasNext(); ) {\n+            Pair p = it.next();\n+            if (p.hasBeenWritten()) {\n+                break;\n+            }\n+            unwrittenLength += p.length();\n+        }\n+        for (Pair p : pairs) {\n+            if (p.hasBeenWritten()) {\n+                continue;\n+            }\n+            unwrittenLength -= p.length();\n+            if (p.canBeWritten(unwrittenLength)) {\n+                p.writeTo(os);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void rewriteLastPairs() {\n     }\n \n     final static class Pair {\n         private final List<byte[]> literals = new LinkedList<>();\n         private int brOffset, brLength;\n+        private boolean written;\n \n         void addLiteral(LZ77Compressor.LiteralBlock block) {\n             literals.add(Arrays.copyOfRange(block.getData(), block.getOffset(),\n         }\n         int length() {\n             return literalLength() + brLength;\n+        }\n+        boolean hasBeenWritten() {\n+            return written;\n         }\n         void writeTo(OutputStream out) throws IOException {\n             int litLength = literalLength();\n                         - BlockLZ4CompressorInputStream.BACK_REFERENCE_SIZE_MASK, out);\n                 }\n             }\n+            written = true;\n         }\n         private int literalLength() {\n             int length = 0;", "timestamp": 1485023939, "metainfo": ""}