{"sha": "f965bc23bc9f12748b6693424f829b6b08c8a71b", "log": "[COMPRESS-368]   Allow compressor extensions through a standard JRE ServiceLoader.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n import org.apache.commons.compress.compressors.lzma.LZMAUtils;\n-import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n-import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n-import org.apache.commons.compress.compressors.xz.XZUtils;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;\n import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;\n import org.apache.commons.compress.compressors.snappy.SnappyCompressorInputStream;\n+import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n+import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n+import org.apache.commons.compress.compressors.xz.XZUtils;\n import org.apache.commons.compress.compressors.z.ZCompressorInputStream;\n import org.apache.commons.compress.utils.IOUtils;\n+import org.apache.commons.compress.utils.Lists;\n+import org.apache.commons.compress.utils.ServiceLoaderIterator;\n \n /**\n- * <p>Factory to create Compressor[In|Out]putStreams from names. To add other\n+ * <p>\n+ * Factory to create Compressor[In|Out]putStreams from names. To add other\n  * implementations you should extend CompressorStreamFactory and override the\n- * appropriate methods (and call their implementation from super of course).</p>\n+ * appropriate methods (and call their implementation from super of course).\n+ * </p>\n  * \n  * Example (Compressing a file):\n  * \n  * <pre>\n- * final OutputStream out = new FileOutputStream(output); \n- * CompressorOutputStream cos = \n- *      new CompressorStreamFactory().createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n+ * final OutputStream out = new FileOutputStream(output);\n+ * CompressorOutputStream cos = new CompressorStreamFactory()\n+ *         .createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n  * IOUtils.copy(new FileInputStream(input), cos);\n  * cos.close();\n  * </pre>\n  * \n  * Example (Decompressing a file):\n+ * \n  * <pre>\n- * final InputStream is = new FileInputStream(input); \n- * CompressorInputStream in = \n- *      new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.BZIP2, is);\n+ * final InputStream is = new FileInputStream(input);\n+ * CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.BZIP2,\n+ *         is);\n  * IOUtils.copy(in, new FileOutputStream(output));\n  * in.close();\n  * </pre>\n- * @Immutable provided that the deprecated method setDecompressConcatenated is not used.\n+ * \n+ * @Immutable provided that the deprecated method setDecompressConcatenated is\n+ *            not used.\n  * @ThreadSafe even if the deprecated method setDecompressConcatenated is used\n  */\n-public class CompressorStreamFactory {\n-\n-    /**\n-     * Constant (value {@value}) used to identify the BZIP2 compression algorithm.\n+public class CompressorStreamFactory implements CompressorStreamProvider {\n+\n+    private static final CompressorStreamFactory SINGLETON = new CompressorStreamFactory();\n+\n+    /**\n+     * Constant (value {@value}) used to identify the BZIP2 compression\n+     * algorithm.\n+     * \n      * @since 1.1\n      */\n     public static final String BZIP2 = \"bzip2\";\n \n     /**\n-     * Constant (value {@value}) used to identify the GZIP compression algorithm.\n-     * Not supported as an output stream type.\n+     * Constant (value {@value}) used to identify the GZIP compression\n+     * algorithm. Not supported as an output stream type.\n+     * \n      * @since 1.1\n      */\n     public static final String GZIP = \"gz\";\n-    \n-    /**\n-     * Constant (value {@value}) used to identify the PACK200 compression algorithm.\n+\n+    /**\n+     * Constant (value {@value}) used to identify the PACK200 compression\n+     * algorithm.\n+     * \n      * @since 1.3\n      */\n     public static final String PACK200 = \"pack200\";\n \n     /**\n      * Constant (value {@value}) used to identify the XZ compression method.\n+     * \n      * @since 1.4\n      */\n     public static final String XZ = \"xz\";\n     /**\n      * Constant (value {@value}) used to identify the LZMA compression method.\n      * Not supported as an output stream type.\n+     * \n      * @since 1.6\n      */\n     public static final String LZMA = \"lzma\";\n \n     /**\n-     * Constant (value {@value}) used to identify the \"framed\" Snappy compression method.\n-     * Not supported as an output stream type.\n+     * Constant (value {@value}) used to identify the \"framed\" Snappy\n+     * compression method. Not supported as an output stream type.\n+     * \n      * @since 1.7\n      */\n     public static final String SNAPPY_FRAMED = \"snappy-framed\";\n \n     /**\n-     * Constant (value {@value}) used to identify the \"raw\" Snappy compression method.\n-     * Not supported as an output stream type.\n+     * Constant (value {@value}) used to identify the \"raw\" Snappy compression\n+     * method. Not supported as an output stream type.\n+     * \n      * @since 1.7\n      */\n     public static final String SNAPPY_RAW = \"snappy-raw\";\n \n     /**\n-     * Constant (value {@value}) used to identify the traditional Unix compress method.\n-     * Not supported as an output stream type.\n+     * Constant (value {@value}) used to identify the traditional Unix compress\n+     * method. Not supported as an output stream type.\n+     * \n      * @since 1.7\n      */\n     public static final String Z = \"z\";\n \n     /**\n      * Constant (value {@value}) used to identify the Deflate compress method.\n+     * \n      * @since 1.9\n      */\n     public static final String DEFLATE = \"deflate\";\n \n     /**\n-     * If true, decompress until the end of the input.\n-     * If false, stop after the first stream and leave the \n-     * input position to point to the next byte after the stream\n+     * If true, decompress until the end of the input. If false, stop after the\n+     * first stream and leave the input position to point to the next byte after\n+     * the stream\n      */\n     private final Boolean decompressUntilEOF;\n-    // This is Boolean so setDecompressConcatenated can determine whether it has been set by the ctor\n-    // once the setDecompressConcatenated method has been removed, it can revert to boolean\n-\n-    /**\n-     * If true, decompress until the end of the input.\n-     * If false, stop after the first stream and leave the \n-     * input position to point to the next byte after the stream\n+    // This is Boolean so setDecompressConcatenated can determine whether it has\n+    // been set by the ctor\n+    // once the setDecompressConcatenated method has been removed, it can revert\n+    // to boolean\n+\n+    // Thread-local gate to prevent recursive provider lookups\n+    private SortedMap<String, CompressorStreamProvider> compressorInputStreamProviders;\n+    private SortedMap<String, CompressorStreamProvider> compressorOutputStreamProviders;\n+    \n+    /**\n+     * If true, decompress until the end of the input. If false, stop after the\n+     * first stream and leave the input position to point to the next byte after\n+     * the stream\n      */\n     private volatile boolean decompressConcatenated = false;\n \n+    static void putAll(Set<String> names, CompressorStreamProvider provider,\n+            TreeMap<String, CompressorStreamProvider> map) {\n+        for (String name : names) {\n+            map.put(toKey(name), provider);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new sorted map from input stream provider names to provider\n+     * objects.\n+     *\n+     * <p>\n+     * The map returned by this method will have one entry for each provider for\n+     * which support is available in the current Java virtual machine. If two or\n+     * more supported provider have the same name then the resulting map will\n+     * contain just one of them; which one it will contain is not specified.\n+     * </p>\n+     *\n+     * <p>\n+     * The invocation of this method, and the subsequent use of the resulting\n+     * map, may cause time-consuming disk or network I/O operations to occur.\n+     * This method is provided for applications that need to enumerate all of\n+     * the available providers, for example to allow user provider selection.\n+     * </p>\n+     *\n+     * <p>\n+     * This method may return different results at different times if new\n+     * providers are dynamically made available to the current Java virtual\n+     * machine.\n+     * </p>\n+     *\n+     * @return An immutable, map from names to provider objects\n+     * @since 1.13\n+     */\n+    public static SortedMap<String, CompressorStreamProvider> findAvailableCompressorInputStreamProviders() {\n+        return AccessController.doPrivileged(new PrivilegedAction<SortedMap<String, CompressorStreamProvider>>() {\n+            @Override\n+            public SortedMap<String, CompressorStreamProvider> run() {\n+                TreeMap<String, CompressorStreamProvider> map = new TreeMap<>();\n+                putAll(SINGLETON.getInputStreamCompressorNames(), SINGLETON, map);\n+                for (CompressorStreamProvider provider : findCompressorStreamProviders()) {\n+                    putAll(provider.getInputStreamCompressorNames(), provider, map);\n+                }\n+                return map;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Constructs a new sorted map from output stream provider names to provider\n+     * objects.\n+     *\n+     * <p>\n+     * The map returned by this method will have one entry for each provider for\n+     * which support is available in the current Java virtual machine. If two or\n+     * more supported provider have the same name then the resulting map will\n+     * contain just one of them; which one it will contain is not specified.\n+     * </p>\n+     *\n+     * <p>\n+     * The invocation of this method, and the subsequent use of the resulting\n+     * map, may cause time-consuming disk or network I/O operations to occur.\n+     * This method is provided for applications that need to enumerate all of\n+     * the available providers, for example to allow user provider selection.\n+     * </p>\n+     *\n+     * <p>\n+     * This method may return different results at different times if new\n+     * providers are dynamically made available to the current Java virtual\n+     * machine.\n+     * </p>\n+     *\n+     * @return An immutable, map from names to provider objects\n+     * @since 1.13\n+     */\n+    public static SortedMap<String, CompressorStreamProvider> findAvailableCompressorOutputStreamProviders() {\n+        return AccessController.doPrivileged(new PrivilegedAction<SortedMap<String, CompressorStreamProvider>>() {\n+            @Override\n+            public SortedMap<String, CompressorStreamProvider> run() {\n+                TreeMap<String, CompressorStreamProvider> map = new TreeMap<>();\n+                putAll(SINGLETON.getOutputStreamCompressorNames(), SINGLETON, map);\n+                for (CompressorStreamProvider provider : findCompressorStreamProviders()) {\n+                    putAll(provider.getOutputStreamCompressorNames(), provider, map);\n+                }\n+                return map;\n+            }\n+\n+        });\n+    }\n+\n+    @Override\n+    public Set<String> getInputStreamCompressorNames() {\n+        HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, GZIP, BZIP2, XZ, LZMA, PACK200, SNAPPY_RAW, SNAPPY_FRAMED, Z, DEFLATE);\n+        return set;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputStreamCompressorNames() {\n+        HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, GZIP, BZIP2, XZ, PACK200, DEFLATE);\n+        return set;\n+    }\n+\n+    private static Iterator<CompressorStreamProvider> serviceLoaderIterator() {\n+        return new ServiceLoaderIterator<>(CompressorStreamProvider.class);\n+    }\n+\n+    private static ArrayList<CompressorStreamProvider> findCompressorStreamProviders() {\n+        return Lists.newArrayList(serviceLoaderIterator());\n+    }\n+\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n-        this.decompressUntilEOF = null;  \n+        this.decompressUntilEOF = null;\n     }\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n-     * @param       decompressUntilEOF\n-     *                          if true, decompress until the end of the\n-     *                          input; if false, stop after the first\n-     *                          stream and leave the input position to point\n-     *                          to the next byte after the stream.\n-     *           This setting applies to the gzip, bzip2 and xz formats only.\n+     * \n+     * @param decompressUntilEOF\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream. This setting applies to the\n+     *            gzip, bzip2 and xz formats only.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n         this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the current value\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n         this.decompressConcatenated = decompressUntilEOF;\n     }\n \n     /**\n-     * Whether to decompress the full input or only the first stream\n-     * in formats supporting multiple concatenated input streams.\n-     *\n-     * <p>This setting applies to the gzip, bzip2 and xz formats only.</p>\n-     *\n-     * @param       decompressConcatenated\n-     *                          if true, decompress until the end of the\n-     *                          input; if false, stop after the first\n-     *                          stream and leave the input position to point\n-     *                          to the next byte after the stream\n+     * Whether to decompress the full input or only the first stream in formats\n+     * supporting multiple concatenated input streams.\n+     *\n+     * <p>\n+     * This setting applies to the gzip, bzip2 and xz formats only.\n+     * </p>\n+     *\n+     * @param decompressConcatenated\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream\n      * @since 1.5\n-     * @deprecated 1.10 use the {@link #CompressorStreamFactory(boolean)} constructor instead\n-     * @throws IllegalStateException if the constructor {@link #CompressorStreamFactory(boolean)} \n-     * was used to create the factory\n+     * @deprecated 1.10 use the {@link #CompressorStreamFactory(boolean)}\n+     *             constructor instead\n+     * @throws IllegalStateException\n+     *             if the constructor {@link #CompressorStreamFactory(boolean)}\n+     *             was used to create the factory\n      */\n     @Deprecated\n     public void setDecompressConcatenated(final boolean decompressConcatenated) {\n     }\n \n     /**\n-     * Create an compressor input stream from an input stream, autodetecting\n-     * the compressor type from the first few bytes of the stream. The InputStream\n+     * Create an compressor input stream from an input stream, autodetecting the\n+     * compressor type from the first few bytes of the stream. The InputStream\n      * must support marks, like BufferedInputStream.\n      * \n-     * @param in the input stream\n+     * @param in\n+     *            the input stream\n      * @return the compressor input stream\n-     * @throws CompressorException if the compressor name is not known\n-     * @throws IllegalArgumentException if the stream is null or does not support mark\n+     * @throws CompressorException\n+     *             if the compressor name is not known\n+     * @throws IllegalArgumentException\n+     *             if the stream is null or does not support mark\n      * @since 1.1\n      */\n-    public CompressorInputStream createCompressorInputStream(final InputStream in)\n-            throws CompressorException {\n+    public CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {\n         if (in == null) {\n             throw new IllegalArgumentException(\"Stream must not be null.\");\n         }\n                 return new DeflateCompressorInputStream(in);\n             }\n \n-            if (XZUtils.matches(signature, signatureLength) &&\n-                XZUtils.isXZCompressionAvailable()) {\n+            if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {\n                 return new XZCompressorInputStream(in, decompressConcatenated);\n             }\n \n-            if (LZMAUtils.matches(signature, signatureLength) &&\n-                LZMAUtils.isLZMACompressionAvailable()) {\n+            if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {\n                 return new LZMACompressorInputStream(in);\n             }\n \n     }\n \n     /**\n-     * Create a compressor input stream from a compressor name and an input stream.\n-     * \n-     * @param name of the compressor,\n-     * i.e. {@value #GZIP}, {@value #BZIP2}, {@value #XZ}, {@value #LZMA},\n-     * {@value #PACK200}, {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, \n-     * {@value #Z} or {@value #DEFLATE} \n-     * @param in the input stream\n+     * Creates a compressor input stream from a compressor name and an input\n+     * stream.\n+     * \n+     * @param name\n+     *            of the compressor, i.e. {@value #GZIP}, {@value #BZIP2},\n+     *            {@value #XZ}, {@value #LZMA}, {@value #PACK200},\n+     *            {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, {@value #Z} or\n+     *            {@value #DEFLATE}\n+     * @param in\n+     *            the input stream\n      * @return compressor input stream\n-     * @throws CompressorException if the compressor name is not known\n-     * @throws IllegalArgumentException if the name or input stream is null\n-     */\n-    public CompressorInputStream createCompressorInputStream(final String name,\n-            final InputStream in) throws CompressorException {\n+     * @throws CompressorException\n+     *             if the compressor name is not known\n+     * @throws IllegalArgumentException\n+     *             if the name or input stream is null\n+     */\n+    @Override\n+    public CompressorInputStream createCompressorInputStream(final String name, final InputStream in)\n+            throws CompressorException {\n         if (name == null || in == null) {\n-            throw new IllegalArgumentException(\n-                    \"Compressor name and stream must not be null.\");\n+            throw new IllegalArgumentException(\"Compressor name and stream must not be null.\");\n         }\n \n         try {\n             }\n \n         } catch (final IOException e) {\n-            throw new CompressorException(\n-                    \"Could not create CompressorInputStream.\", e);\n-        }\n+            throw new CompressorException(\"Could not create CompressorInputStream.\", e);\n+        }\n+        final CompressorStreamProvider compressorStreamProvider = getCompressorInputStreamProviders().get(toKey(name));\n+        if (compressorStreamProvider != null) {\n+            return compressorStreamProvider.createCompressorInputStream(name, in);\n+        }\n+        \n         throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n     }\n \n-    /**\n-     * Create an compressor output stream from an compressor name and an output stream.\n-     * \n-     * @param name the compressor name,\n-     * i.e. {@value #GZIP}, {@value #BZIP2}, {@value #XZ},\n-     * {@value #PACK200} or {@value #DEFLATE} \n-     * @param out the output stream\n+    private static String toKey(final String name) {\n+        return name.toUpperCase(Locale.ROOT);\n+    }\n+\n+    /**\n+     * Creates an compressor output stream from an compressor name and an output\n+     * stream.\n+     * \n+     * @param name\n+     *            the compressor name, i.e. {@value #GZIP}, {@value #BZIP2},\n+     *            {@value #XZ}, {@value #PACK200} or {@value #DEFLATE}\n+     * @param out\n+     *            the output stream\n      * @return the compressor output stream\n-     * @throws CompressorException if the archiver name is not known\n-     * @throws IllegalArgumentException if the archiver name or stream is null\n-     */\n-    public CompressorOutputStream createCompressorOutputStream(\n-            final String name, final OutputStream out)\n+     * @throws CompressorException\n+     *             if the archiver name is not known\n+     * @throws IllegalArgumentException\n+     *             if the archiver name or stream is null\n+     */\n+    @Override\n+    public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out)\n             throws CompressorException {\n         if (name == null || out == null) {\n-            throw new IllegalArgumentException(\n-                    \"Compressor name and stream must not be null.\");\n+            throw new IllegalArgumentException(\"Compressor name and stream must not be null.\");\n         }\n \n         try {\n             }\n \n         } catch (final IOException e) {\n-            throw new CompressorException(\n-                    \"Could not create CompressorOutputStream\", e);\n+            throw new CompressorException(\"Could not create CompressorOutputStream\", e);\n+        }\n+        final CompressorStreamProvider compressorStreamProvider = getCompressorOutputStreamProviders().get(toKey(name));\n+        if (compressorStreamProvider != null) {\n+            return compressorStreamProvider.createCompressorOutputStream(name, out);\n         }\n         throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n     }\n     boolean getDecompressConcatenated() {\n         return decompressConcatenated;\n     }\n+    \n+    public static CompressorStreamFactory getSingleton() {\n+        return SINGLETON;\n+    }\n+\n+    public static String getBzip2() {\n+        return BZIP2;\n+    }\n+\n+    public static String getGzip() {\n+        return GZIP;\n+    }\n+\n+    public static String getPack200() {\n+        return PACK200;\n+    }\n+\n+    public static String getXz() {\n+        return XZ;\n+    }\n+\n+    public static String getLzma() {\n+        return LZMA;\n+    }\n+\n+    public static String getSnappyFramed() {\n+        return SNAPPY_FRAMED;\n+    }\n+\n+    public static String getSnappyRaw() {\n+        return SNAPPY_RAW;\n+    }\n+\n+    public static String getZ() {\n+        return Z;\n+    }\n+\n+    public static String getDeflate() {\n+        return DEFLATE;\n+    }\n+\n+    public Boolean getDecompressUntilEOF() {\n+        return decompressUntilEOF;\n+    }\n+\n+    public SortedMap<String, CompressorStreamProvider> getCompressorInputStreamProviders() {\n+        if (compressorInputStreamProviders == null) {\n+            compressorInputStreamProviders = Collections\n+                    .unmodifiableSortedMap(findAvailableCompressorInputStreamProviders());\n+        }\n+        return compressorInputStreamProviders;\n+    }\n+\n+    public SortedMap<String, CompressorStreamProvider> getCompressorOutputStreamProviders() {\n+        if (compressorOutputStreamProviders == null) {\n+            compressorOutputStreamProviders = Collections\n+                    .unmodifiableSortedMap(findAvailableCompressorOutputStreamProviders());\n+        }\n+        return compressorOutputStreamProviders;\n+    }\n+    \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Set;\n+\n+/**\n+ * Creates Compressor {@link CompressorInputStream}s and\n+ * {@link CompressorOutputStream}s.\n+ * \n+ * @since 1.13\n+ */\n+public interface CompressorStreamProvider {\n+\n+    /**\n+     * Creates a compressor input stream from a compressor name and an input\n+     * stream.\n+     * \n+     * @param name\n+     *            of the compressor, i.e. {@value #GZIP}, {@value #BZIP2},\n+     *            {@value #XZ}, {@value #LZMA}, {@value #PACK200},\n+     *            {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, {@value #Z} or\n+     *            {@value #DEFLATE}\n+     * @param in\n+     *            the input stream\n+     * @return compressor input stream\n+     * @throws CompressorException\n+     *             if the compressor name is not known\n+     * @throws IllegalArgumentException\n+     *             if the name or input stream is null\n+     */\n+    CompressorInputStream createCompressorInputStream(final String name, final InputStream in)\n+            throws CompressorException;\n+\n+    /**\n+     * Creates a compressor output stream from an compressor name and an output\n+     * stream.\n+     * \n+     * @param name\n+     *            the compressor name, i.e. {@value #GZIP}, {@value #BZIP2},\n+     *            {@value #XZ}, {@value #PACK200} or {@value #DEFLATE}\n+     * @param out\n+     *            the output stream\n+     * @return the compressor output stream\n+     * @throws CompressorException\n+     *             if the archiver name is not known\n+     * @throws IllegalArgumentException\n+     *             if the archiver name or stream is null\n+     */\n+    CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out)\n+            throws CompressorException;\n+\n+    /**\n+     * Gets all the input stream compressor names for this provider\n+     * \n+     * @return all the input compressor names for this provider\n+     */\n+    Set<String> getInputStreamCompressorNames();\n+\n+    /**\n+     * Gets all the output stream compressor names for this provider\n+     * \n+     * @return all the output compressor names for this provider\n+     */\n+    Set<String> getOutputStreamCompressorNames();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/Iterators.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+/**\n+ * Iterator utilities.\n+ * \n+ * @since 1.13.\n+ */\n+public class Iterators {\n+\n+    /**\n+     * Adds all the elements in the source {@code iterator} to the target\n+     * {@code collection}.\n+     * \n+     * <p>\n+     * When this method returns, the {@code iterator} will be \"empty\": its\n+     * {@code hasNext()} method returns {@code false}.\n+     * </p>\n+     *\n+     * @return {@code true} if the target {@code collection} was modified as a\n+     *         result of this operation\n+     */\n+    public static <T> boolean addAll(final Collection<T> collection, final Iterator<? extends T> iterator) {\n+        Objects.requireNonNull(collection);\n+        Objects.requireNonNull(iterator);\n+        boolean wasModified = false;\n+        while (iterator.hasNext()) {\n+            wasModified |= collection.add(iterator.next());\n+        }\n+        return wasModified;\n+    }\n+\n+    private Iterators() {\n+        // do not instantiate\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/Lists.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+/**\n+ * List utilities\n+ *\n+ * @since 1.13\n+ */\n+public class Lists {\n+\n+    /**\n+     * Creates a new {@link ArrayList}.\n+     * \n+     * @return a new {@link ArrayList}\n+     */\n+    public static <E> ArrayList<E> newArrayList() {\n+        return new ArrayList<>();\n+    }\n+\n+    /**\n+     * Creates a new {@link ArrayList} filled with the contents of the given\n+     * {@code iterator}.\n+     * \n+     * @param iterator\n+     *            the source iterator\n+     * @return a new {@link ArrayList}\n+     */\n+    public static <E> ArrayList<E> newArrayList(final Iterator<? extends E> iterator) {\n+        final ArrayList<E> list = newArrayList();\n+        Iterators.addAll(list, iterator);\n+        return list;\n+    }\n+\n+    private Lists() {\n+        // do not instantiate\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/ServiceLoaderIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Iterates all services for a given class through the standard\n+ * {@link ServiceLoader} mechanism.\n+ * \n+ * @param <E>\n+ *            The service to load\n+ * @since 1.13\n+ */\n+public class ServiceLoaderIterator<E> implements Iterator<E> {\n+\n+    private E nextServiceLoader;\n+    private final Class<E> service;\n+    private final Iterator<E> serviceLoaderIterator;\n+\n+    public ServiceLoaderIterator(final Class<E> service) {\n+        this(service, ClassLoader.getSystemClassLoader());\n+    }\n+\n+    public ServiceLoaderIterator(final Class<E> service, final ClassLoader classLoader) {\n+        this.service = service;\n+        final ServiceLoader<E> serviceLoader = ServiceLoader.load(service, classLoader);\n+        serviceLoaderIterator = serviceLoader.iterator();\n+        nextServiceLoader = null;\n+    }\n+\n+    private boolean getNextServiceLoader() {\n+        while (nextServiceLoader == null) {\n+            try {\n+                if (!serviceLoaderIterator.hasNext()) {\n+                    return false;\n+                }\n+                nextServiceLoader = serviceLoaderIterator.next();\n+            } catch (final ServiceConfigurationError e) {\n+                if (e.getCause() instanceof SecurityException) {\n+                    // Ignore security exceptions\n+                    // TODO Log?\n+                    continue;\n+                }\n+                throw e;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        return getNextServiceLoader();\n+    }\n+\n+    @Override\n+    public E next() {\n+        if (!getNextServiceLoader()) {\n+            throw new NoSuchElementException(\"No more elements for service \" + service.getName());\n+        }\n+        final E tempNext = nextServiceLoader;\n+        nextServiceLoader = null;\n+        return tempNext;\n+    }\n+\n+    @Override\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"service=\" + service.getName());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/CompressorServiceLoaderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+import org.apache.commons.compress.compressors.TestCompressorStreamProvider.InvocationConfirmationException;\n+import org.junit.Test;\n+\n+public class CompressorServiceLoaderTest {\n+\n+    @Test(expected = InvocationConfirmationException.class)\n+    public void testInputStream() throws CompressorException {\n+        new CompressorStreamFactory().createCompressorInputStream(\"TestInput1\", new ByteArrayInputStream(new byte[] {}));\n+    }\n+\n+    @Test(expected = InvocationConfirmationException.class)\n+    public void testOutputStream() throws CompressorException {\n+        new CompressorStreamFactory().createCompressorOutputStream(\"TestOutput1\", new ByteArrayOutputStream());\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/CompressorStreamFactoryRoundtripTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/CompressorStreamFactoryRoundtripTest.java\n \n     @Test\n     public void testCompressorStreamFactoryRoundtrip() throws Exception {\n-        final CompressorStreamFactory factory = new CompressorStreamFactory();\n+        final CompressorStreamProvider factory = new CompressorStreamFactory();\n         final ByteArrayOutputStream compressedOs = new ByteArrayOutputStream();\n         final CompressorOutputStream compressorOutputStream = factory.createCompressorOutputStream(compressorName,\n                 compressedOs);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/TestCompressorStreamProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class TestCompressorStreamProvider implements CompressorStreamProvider {\n+\n+    public static final class InvocationConfirmationException extends CompressorException {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public InvocationConfirmationException(String message) {\n+            super(message);\n+        }\n+    }\n+    \n+    @Override\n+    public CompressorInputStream createCompressorInputStream(String name, InputStream in) throws CompressorException {\n+        throw new InvocationConfirmationException(name);\n+    }\n+\n+    @Override\n+    public CompressorOutputStream createCompressorOutputStream(String name, OutputStream out)\n+            throws CompressorException {\n+        throw new InvocationConfirmationException(name);\n+    }\n+\n+    @Override\n+    public Set<String> getInputStreamCompressorNames() {\n+        HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, \"TestInput1\");\n+        return set;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputStreamCompressorNames() {\n+        HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, \"TestOutput1\");\n+        return set;\n+    }\n+\n+}", "timestamp": 1479270003, "metainfo": ""}