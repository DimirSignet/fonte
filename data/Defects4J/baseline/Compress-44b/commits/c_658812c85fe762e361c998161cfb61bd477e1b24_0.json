{"sha": "658812c85fe762e361c998161cfb61bd477e1b24", "log": "ZipArchiveInputStream.closeEntry fails to advance  Properly advances to next entry upon calling closeEntry when there are extra junk bytes after the compressed data section of a zip entry. This applies to the ZipArchiveInputStream implementation.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         }\n \n         // Ensure all entry bytes are read\n-        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n-                && !current.hasDataDescriptor) {\n+        if (currentEntryHasOutstandingBytes()) {\n             drainCurrentEntryData();\n         } else {\n             skip(Long.MAX_VALUE);\n             // Pushback any required bytes\n             if (diff > 0) {\n                 pushback(buf.array(), buf.limit() - diff, diff);\n+                current.bytesReadFromStream -= diff;\n+            }\n+\n+            // Drain remainder of entry if not all data bytes were required\n+            if (currentEntryHasOutstandingBytes()) {\n+                drainCurrentEntryData();\n             }\n         }\n \n         buf.clear().flip();\n         current = null;\n         lastStoredEntry = null;\n+    }\n+\n+    /**\n+     * If the compressed size of the current entry is included in the entry header\n+     * and there are any outstanding bytes in the underlying stream, then\n+     * this returns true.\n+     *\n+     * @return true, if current entry is determined to have outstanding bytes, false otherwise\n+     */\n+    private boolean currentEntryHasOutstandingBytes() {\n+        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n+                && !current.hasDataDescriptor;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n             assertArrayEquals(expected, IOUtils.toByteArray(in));\n         }\n     }\n+\n+    /**\n+     * Test case for\n+     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-364\"\n+     * >COMPRESS-364</a>.\n+     */\n+    @Test\n+    public void testWithBytesAfterData() throws Exception {\n+        final int expectedNumEntries = 2;\n+        final InputStream is = ZipArchiveInputStreamTest.class\n+                .getResourceAsStream(\"/archive_with_bytes_after_data.zip\");\n+        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n+\n+        try {\n+            int actualNumEntries = 0;\n+            ZipArchiveEntry zae = zip.getNextZipEntry();\n+            while (zae != null) {\n+                actualNumEntries++;\n+                readEntry(zip, zae);\n+                zae = zip.getNextZipEntry();\n+            }\n+            assertEquals(expectedNumEntries, actualNumEntries);\n+        } finally {\n+            zip.close();\n+        }\n+    }\n+\n+    private static byte[] readEntry(ZipArchiveInputStream zip, ZipArchiveEntry zae) throws IOException {\n+        final int len = (int)zae.getSize();\n+        final byte[] buff = new byte[len];\n+        zip.read(buff, 0, len);\n+\n+        return buff;\n+    }\n }", "timestamp": 1475857093, "metainfo": ""}