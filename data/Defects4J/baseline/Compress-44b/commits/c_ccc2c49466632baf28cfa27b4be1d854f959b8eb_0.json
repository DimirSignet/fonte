{"sha": "ccc2c49466632baf28cfa27b4be1d854f959b8eb", "log": "Changed PackableObjectException to extends IOException and simplified a couple exception handlings  ", "commit": "\n--- a/src/java/org/apache/commons/compress/ArchiverFactory.java\n+++ b/src/java/org/apache/commons/compress/ArchiverFactory.java\n \t * The archiver must implement the archiver interface and must\n \t * be an concrete implementation\n \t * \n-\t * @param className full qualified archiver implementation\n+\t * @param clazz full qualified archiver implementation\n \t * @throws ArchiveException if the new archiver does not implement the archiver interface\n \t */\n \tpublic static void registerArchiver(Class clazz) \n \t * Returns an archiver, filled with an existing archive.\n \t * Uses the byte header to identify the archiver. If no corresponding\n \t * archiver could be found, a filename extension check will be done.\n-\t * @param archivedFile an existing archive\n+\t * @param file an existing archive\n \t * @return an archiver, filled with the archive\n \t */\n \tpublic static Archive getInstance(File file) \n \t\t\tthrow new ArchiveException(\"A security violation occured while reading the field ARCHIVER_NAME\", e);\n \t\t} catch (IllegalArgumentException e) {\n \t\t\tthrow new ArchiveException(\"Internal factory exception\", e);\n-\t\t} catch (InstantiationException e) {\n+\t\t} catch (Exception e) {\n \t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n-\t\t} catch (IllegalAccessException e) {\n-\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n-\t\t} catch (PackableObjectException e) {\n-\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n-\t\t} \n+\t\t}\n \t}\n }\n--- a/src/java/org/apache/commons/compress/CompressorFactory.java\n+++ b/src/java/org/apache/commons/compress/CompressorFactory.java\n \t * The archiver must implement the archiver interface and must\n \t * be an concrete implementation\n \t * \n-\t * @param className full qualified archiver implementation\n+\t * @param clazz full qualified archiver implementation\n \t * @throws ArchiveException if the new archiver does not implement the archiver interface\n \t */\n \tpublic static void registerCompressor(Class clazz) \n \n \t/**\n \t * Constructor. Takes the name of the implementation.\n-\t * @param _name - name of the implementation\n+\t * @param name - name of the implementation\n \t */\n \tprivate CompressorFactory(String name) { \n \t\tthis.name = name; \n \t * the first matching implementation will be instanciated.\n \t * \n \t * @return the compressor, or null, if no matching compressor could be found\n-\t * @throws CompressorException if the compressor could not be created\n+\t * @throws CompressException if the compressor could not be created\n \t */\n \tpublic static Compressor getInstance(String compressorName) \n \t\tthrows CompressException {\n \t * Returns an archiver, filled with an existing archive.\n \t * Uses the byte header to identify the archiver. If no corresponding\n \t * archiver could be found, a filename extension check will be done.\n-\t * @param archivedFile an existing archive\n+\t * @param file an existing archive\n \t * @return an archiver, filled with the archive\n \t */\n \tpublic static Compressor getInstance(File file) \n \t\t\tthrow new CompressException(\"A security violation occured while reading the field ARCHIVER_NAME\", e);\n \t\t} catch (IllegalArgumentException e) {\n \t\t\tthrow new CompressException(\"Internal factory exception\", e);\n-\t\t} catch (InstantiationException e) {\n+\t\t} catch (Exception e) {\n \t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n-\t\t} catch (IllegalAccessException e) {\n-\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n-\t\t} catch (PackableObjectException e) {\n-\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n-\t\t} \n+\t\t}\n \t}\n \t/**\n \t * <code>BZIP2</code> Compressor Factory\n--- a/src/java/org/apache/commons/compress/PackableObject.java\n+++ b/src/java/org/apache/commons/compress/PackableObject.java\n \n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n \t/**\n \t * String Chooser.\n \t * @param value\n-\t * @param methodName\n+\t * @param choose\n \t * @return\n-\t * @throws ArchiveException\n-\t * @throws FileNotFoundException \n \t */\n \tprotected boolean isPackableWith(Object value, int choose) {\n \t\tif(value == null) {\n \t * @param file the file to identify\n \t * @param packables a list of packables\n \t * @return a matching packable object, or null\n-\t * @throws ArchiveException\n+\t * @throws IOException\n \t */\n-\tpublic static PackableObject identifyByHeader(File file, List packables) \n-\t\tthrows PackableObjectException {\n+\tpublic static PackableObject identifyByHeader(File file, List packables) throws IOException {\n \t\t/* FileInputStream for the archive */\n \t\tFileInputStream fis = null;\n \t\t\n \t\t\t\n \t\t\t// No implementation found\n \t\t\treturn null;\n-\t\t} catch (FileNotFoundException e) {\n-\t\t\tthrow new PackableObjectException(\"File not found\", e);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new PackableObjectException(\"Internal factory exception\", e);\n+\n \t\t} finally {\n-\t\t\ttry {\n-\t\t\t\tfis.close();\n-\t\t\t} catch (IOException e1) {\n-\t\t\t\tthrow new PackableObjectException(\"Error while closing InputStream to file\", e1);\n-\t\t\t}\n+\t        fis.close();\n \t\t}\n \t}\n }\n--- a/src/java/org/apache/commons/compress/PackableObjectException.java\n+++ b/src/java/org/apache/commons/compress/PackableObjectException.java\n  */\n package org.apache.commons.compress;\n \n+import java.io.IOException;\n+\n /**\n  * Exception for the archiver. \n  */\n-public class PackableObjectException extends Exception {\n+public class PackableObjectException extends IOException {\n \t/**\n \t * Comment for <code>serialVersionUID</code>\n \t */", "timestamp": 1213722473, "metainfo": ""}