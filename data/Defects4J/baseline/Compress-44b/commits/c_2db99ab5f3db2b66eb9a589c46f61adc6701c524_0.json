{"sha": "2db99ab5f3db2b66eb9a589c46f61adc6701c524", "log": "Removed duplication between ZipArchiveOutputStream and StreamCompressor  Reatained all compatibility in ZipArchiveOutputStream  Made StreamCompressor and all instantiation of this package private.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n import org.apache.commons.compress.utils.BoundedInputStream;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Queue;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.Closeable;\n import java.io.DataOutput;\n import java.io.IOException;\n import java.io.InputStream;\n  *\n  * @since 1.10\n  */\n-public abstract class StreamCompressor {\n+abstract class StreamCompressor implements Closeable {\n \n     /*\n      * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n \n     private final CRC32 crc = new CRC32();\n \n-    int writtenToOutputStream = 0;\n-    int sourcePayloadLength = 0;\n-    long actualCrc;\n+    private long writtenToOutputStream = 0;\n+    private long sourcePayloadLength = 0;\n+    private long totalWrittenToOutputStream = 0;\n \n     private final int bufferSize = 4096;\n     private final byte[] outputBuffer = new byte[bufferSize];\n     private final byte[] readerBuf = new byte[bufferSize];\n \n-    protected StreamCompressor(Deflater deflater) {\n+    StreamCompressor(Deflater deflater) {\n         this.def = deflater;\n     }\n \n     /**\n      * Create a stream compressor with the given compression level.\n      *\n+     * @param os       The #OutputStream stream to receive output\n+     * @param deflater The deflater to use\n+     * @return A stream compressor\n+     */\n+    static StreamCompressor create(OutputStream os, Deflater deflater) {\n+        return new OutputStreamCompressor(deflater, os);\n+    }\n+\n+    /**\n+     * Create a stream compressor with the default compression level.\n+     *\n+     * @param os The #OutputStream stream to receive output\n+     * @return A stream compressor\n+     */\n+    static StreamCompressor create(OutputStream os) {\n+        return create(os, new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n+    }\n+\n+    /**\n+     * Create a stream compressor with the given compression level.\n+     *\n+     * @param os       The #DataOutput to receive output\n+     * @param deflater The deflater to use for the compressor\n+     * @return A stream compressor\n+     */\n+    static StreamCompressor create(DataOutput os, Deflater deflater) {\n+        return new DataOutputCompressor(deflater, os);\n+    }\n+\n+    /**\n+     * Create a stream compressor with the given compression level.\n+     *\n      * @param compressionLevel The #Deflater compression level\n-     * @param os The #OutputStream stream to receive output\n-     * @return A stream compressor\n-     */\n-    public static StreamCompressor create(int compressionLevel, OutputStream os) {\n-        final Deflater deflater = new Deflater(compressionLevel, true);\n-        return new OutputStreamCompressor(deflater, os);\n-    }\n-\n-    /**\n-     * Create a stream compressor with the default compression level.\n-     *\n-     * @param os The #OutputStream stream to receive output\n-     * @return A stream compressor\n-     */\n-    public static StreamCompressor create( OutputStream os) {\n-        return create(Deflater.DEFAULT_COMPRESSION, os);\n-    }\n-\n-    /**\n-     * Create a stream compressor with the given compression level.\n-     *\n-     * @param compressionLevel The #Deflater compression level\n-     * @param os The #DataOutput to receive output\n-     * @return A stream compressor\n-     */\n-    public static StreamCompressor create(int compressionLevel, DataOutput os) {\n-        final Deflater deflater = new Deflater(compressionLevel, true);\n-        return new DataOutputCompressor(deflater, os);\n-    }\n-\n-    /**\n-     * Create a stream compressor with the given compression level.\n-     *\n-     * @param compressionLevel The #Deflater compression level\n-     * @param bs The #ScatterGatherBackingStore to receive output\n+     * @param bs               The #ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n     public static StreamCompressor create(int compressionLevel, ScatterGatherBackingStore bs) {\n      * @param bs The #ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n-    public static StreamCompressor create( ScatterGatherBackingStore bs) {\n+    public static StreamCompressor create(ScatterGatherBackingStore bs) {\n         return create(Deflater.DEFAULT_COMPRESSION, bs);\n     }\n \n     /**\n      * The crc32 of the last deflated file\n+     *\n      * @return the crc32\n      */\n \n     public long getCrc32() {\n-        return actualCrc;\n+        return crc.getValue();\n     }\n \n     /**\n      * Return the number of bytes read from the source stream\n+     *\n      * @return The number of bytes read, never negative\n      */\n-    public int getBytesRead() {\n+    public long getBytesRead() {\n         return sourcePayloadLength;\n     }\n \n     /**\n      * The number of bytes written to the output\n+     *\n      * @return The number of bytes, never negative\n      */\n-    public int getBytesWritten() {\n+    public long getBytesWritten() {\n         return writtenToOutputStream;\n     }\n \n     /**\n+     * The total number of bytes written to the output for all files\n+     *\n+     * @return The number of bytes, never negative\n+     */\n+    public long getTotalBytesWritten() {\n+        return totalWrittenToOutputStream;\n+    }\n+\n+\n+    /**\n      * Deflate the given source using the supplied compression method\n+     *\n      * @param source The source to compress\n      * @param method The #ZipArchiveEntry compression method\n      * @throws IOException When failures happen\n         reset();\n         int length;\n \n-        while(( length = source.read(readerBuf, 0, readerBuf.length)) >= 0){\n-            crc.update(readerBuf, 0, length);\n-            if (method == ZipArchiveEntry.DEFLATED) {\n-                writeDeflated(readerBuf, 0, length);\n-            } else {\n-                writeOut(readerBuf, 0, length);\n-                writtenToOutputStream += length;\n-            }\n-            sourcePayloadLength += length;\n+        while ((length = source.read(readerBuf, 0, readerBuf.length)) >= 0) {\n+            write(readerBuf, 0, length, method);\n         }\n         if (method == ZipArchiveEntry.DEFLATED) {\n             flushDeflater();\n         }\n-        actualCrc = crc.getValue();\n-\n-\n-    }\n-\n-    private void reset(){\n+    }\n+\n+    /**\n+     * Writes bytes to ZIP entry.\n+     *\n+     * @param b      the byte array to write\n+     * @param offset the start position to write from\n+     * @param length the number of bytes to write\n+     * @param method the comrpession method to use\n+     * @return the number of bytes written to the stream this time\n+     * @throws IOException on error\n+     */\n+    long write(byte[] b, int offset, int length, int method) throws IOException {\n+        long current = writtenToOutputStream;\n+        crc.update(b, offset, length);\n+        if (method == ZipArchiveEntry.DEFLATED) {\n+            writeDeflated(b, offset, length);\n+        } else {\n+            writeCounted(b, offset, length);\n+        }\n+        sourcePayloadLength += length;\n+        return writtenToOutputStream - current;\n+    }\n+\n+\n+    void reset() {\n         crc.reset();\n         def.reset();\n         sourcePayloadLength = 0;\n         writtenToOutputStream = 0;\n     }\n \n-    private void flushDeflater() throws IOException {\n+    public void close() throws IOException {\n+        def.end();\n+    }\n+\n+    void flushDeflater() throws IOException {\n         def.finish();\n         while (!def.finished()) {\n             deflate();\n         }\n     }\n \n-    private void writeDeflated(byte[]b, int offset, int length)\n+    private void writeDeflated(byte[] b, int offset, int length)\n             throws IOException {\n         if (length > 0 && !def.finished()) {\n             if (length <= DEFLATER_BLOCK_SIZE) {\n     private void deflate() throws IOException {\n         int len = def.deflate(outputBuffer, 0, outputBuffer.length);\n         if (len > 0) {\n-            writeOut(outputBuffer, 0, len);\n-            writtenToOutputStream += len;\n-        }\n-    }\n-\n-    protected abstract void writeOut(byte[] data, int offset, int length) throws IOException ;\n+            writeCounted(outputBuffer, 0, len);\n+        }\n+    }\n+\n+    public void writeCounted(byte[] data) throws IOException {\n+        writeCounted(data, 0, data.length);\n+    }\n+\n+    public void writeCounted(byte[] data, int offset, int length) throws IOException {\n+        writeOut(data, offset, length);\n+        writtenToOutputStream += length;\n+        totalWrittenToOutputStream += length;\n+    }\n+\n+    protected abstract void writeOut(byte[] data, int offset, int length) throws IOException;\n \n     private static final class ScatterGatherBackingStoreCompressor extends StreamCompressor {\n         private final ScatterGatherBackingStore bs;\n \n         protected final void writeOut(byte[] data, int offset, int length)\n                 throws IOException {\n-                bs.writeOut(data, offset, length);\n+            bs.writeOut(data, offset, length);\n         }\n     }\n \n \n         protected final void writeOut(byte[] data, int offset, int length)\n                 throws IOException {\n-                os.write(data, offset, length);\n+            os.write(data, offset, length);\n         }\n     }\n \n     private static final class DataOutputCompressor extends StreamCompressor {\n         private final DataOutput raf;\n+\n         public DataOutputCompressor(Deflater deflater, DataOutput raf) {\n             super(deflater);\n             this.raf = raf;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.zip.CRC32;\n import java.util.zip.Deflater;\n import java.util.zip.ZipException;\n \n     private final List<ZipArchiveEntry> entries =\n         new LinkedList<ZipArchiveEntry>();\n \n-    /**\n-     * CRC instance to avoid parsing DEFLATED data twice.\n-     */\n-    private final CRC32 crc = new CRC32();\n-\n-    /**\n-     * Count the bytes written to out.\n-     */\n-    private long written = 0;\n+    private final StreamCompressor streamCompressor;\n \n     /**\n      * Start of central directory.\n     private ZipEncoding zipEncoding =\n         ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING);\n \n+\n     /**\n      * This Deflater object is used for output.\n      *\n      */\n-    protected final Deflater def = new Deflater(level, true);\n-\n-    /**\n-     * This buffer serves as a Deflater.\n-     *\n-     */\n-    private final byte[] buf = new byte[BUFFER_SIZE];\n-\n+    protected final Deflater def;\n     /**\n      * Optional random access output.\n      */\n     public ZipArchiveOutputStream(OutputStream out) {\n         this.out = out;\n         this.raf = null;\n+        def = new Deflater(level, true);\n+        streamCompressor = StreamCompressor.create(out, def);\n     }\n \n     /**\n             _raf = null;\n             o = new FileOutputStream(file);\n         }\n+        def = new Deflater(level, true);\n+        streamCompressor = StreamCompressor.create(_raf, def);\n         out = o;\n         raf = _raf;\n     }\n             throw new IOException(\"This archive contains unclosed entries.\");\n         }\n \n-        cdOffset = written;\n+        cdOffset = streamCompressor.getTotalBytesWritten();\n         for (ZipArchiveEntry ze : entries) {\n             writeCentralFileHeader(ze);\n         }\n-        cdLength = written - cdOffset;\n+        cdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\n         writeZip64CentralDirectory();\n         writeCentralDirectoryEnd();\n         offsets.clear();\n         entries.clear();\n-        def.end();\n+        streamCompressor.close();\n         finished = true;\n     }\n \n \n         flushDeflater();\n \n-        long bytesWritten = written - entry.dataStart;\n-        long realCrc = crc.getValue();\n-        crc.reset();\n-\n+        long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n+        long realCrc = streamCompressor.getCrc32();\n+        entry.bytesRead = streamCompressor.getBytesRead();\n         doCloseEntry(realCrc, bytesWritten);\n+        streamCompressor.reset();\n     }\n \n     /**\n      */\n     private void closeCopiedEntry() throws IOException {\n         preClose();\n-        long realCrc = entry.entry.getCrc();\n         entry.bytesRead = entry.entry.getSize();\n-        doCloseEntry(realCrc, entry.entry.getCompressedSize());\n+        doCloseCopiedEntry();\n     }\n \n     private void doCloseEntry(long realCrc, long bytesWritten) throws IOException {\n         final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n-        final boolean actuallyNeedsZip64 =\n-                handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n-\n+        final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n+\n+        closeEntry(actuallyNeedsZip64);\n+    }\n+\n+    private void doCloseCopiedEntry() throws IOException {\n+        Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n+        boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n+        closeEntry(actuallyNeedsZip64);\n+    }\n+\n+    private void closeEntry(boolean actuallyNeedsZip64) throws IOException {\n         if (raf != null) {\n             rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n      */\n     private void flushDeflater() throws IOException {\n         if (entry.entry.getMethod() == DEFLATED) {\n-            def.finish();\n-            while (!def.finished()) {\n-                deflate();\n-            }\n+            streamCompressor.flushDeflater();\n         }\n     }\n \n             entry.entry.setCompressedSize(bytesWritten);\n             entry.entry.setCrc(crc);\n \n-            def.reset();\n         } else if (raf == null) {\n             if (entry.entry.getCrc() != crc) {\n                 throw new ZipException(\"bad CRC checksum for entry \"\n             entry.entry.setCrc(crc);\n         }\n \n+        return checkIfNeedsZip64(effectiveMode);\n+    }\n+\n+    /**\n+     * Ensures the current entry's size and CRC information is set to\n+     * the values just written, verifies it isn't too big in the\n+     * Zip64Mode.Never case and returns whether the entry would\n+     * require a Zip64 extra field.\n+     */\n+    private boolean checkIfNeedsZip64(Zip64Mode effectiveMode)\n+            throws ZipException {\n         final boolean actuallyNeedsZip64 = effectiveMode == Zip64Mode.Always\n-            || entry.entry.getSize() >= ZIP64_MAGIC\n-            || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n+                || entry.entry.getSize() >= ZIP64_MAGIC\n+                || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n-            throw new Zip64RequiredException(Zip64RequiredException\n-                                             .getEntryTooBigMessage(entry.entry));\n+            throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(entry.entry));\n         }\n         return actuallyNeedsZip64;\n     }\n-\n     /**\n      * When using random access output, write the local file header\n      * and potentiall the ZIP64 extra containing the correct CRC and\n             def.setLevel(level);\n             hasCompressionLevelChanged = false;\n         }\n-        writeLocalFileHeader((ZipArchiveEntry)archiveEntry);\n+        writeLocalFileHeader((ZipArchiveEntry) archiveEntry);\n     }\n \n     /**\n             throw new IllegalStateException(\"No current entry\");\n         }\n         ZipUtil.checkRequestedFeatures(entry.entry);\n-        entry.hasWritten = true;\n-        if (entry.entry.getMethod() == DEFLATED) {\n-            writeDeflated(b, offset, length);\n-        } else {\n-            writeOut(b, offset, length);\n-            written += length;\n-        }\n-        crc.update(b, offset, length);\n-        count(length);\n-    }\n+        long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\n+        count(writtenThisTime);\n+    }\n+\n+    /**\n+     * Write bytes to output or random access file.\n+     * @param data the byte array to write\n+     * @throws IOException on error\n+     */\n+    private void writeCounted(byte[] data) throws IOException {\n+        streamCompressor.writeCounted(data);\n+    }\n+\n+\n+\n+\n \n     private void copyFromZipInputStream(InputStream src) throws IOException {\n         if (entry == null) {\n         ZipUtil.checkRequestedFeatures(entry.entry);\n         entry.hasWritten = true;\n         byte[] tmpBuf = new byte[4096];\n-        int length = src.read( tmpBuf );\n-        while ( length >= 0 )\n+        int length;\n+        while ((length = src.read( tmpBuf )) >= 0 )\n         {\n-            writeOut( tmpBuf, 0, length );\n-            written += length;\n-            crc.update( tmpBuf, 0, length );\n-\n+            streamCompressor.writeCounted(tmpBuf, 0, length);\n             count( length );\n-            length = src.read( tmpBuf );\n-        }\n-    }\n-\n-    /**\n-     * write implementation for DEFLATED entries.\n-     */\n-    private void writeDeflated(byte[]b, int offset, int length)\n-        throws IOException {\n-        if (length > 0 && !def.finished()) {\n-            entry.bytesRead += length;\n-            if (length <= DEFLATER_BLOCK_SIZE) {\n-                def.setInput(b, offset, length);\n-                deflateUntilInputIsNeeded();\n-            } else {\n-                final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n-                for (int i = 0; i < fullblocks; i++) {\n-                    def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n-                                 DEFLATER_BLOCK_SIZE);\n-                    deflateUntilInputIsNeeded();\n-                }\n-                final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n-                if (done < length) {\n-                    def.setInput(b, offset + done, length - done);\n-                    deflateUntilInputIsNeeded();\n-                }\n-            }\n         }\n     }\n \n     static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n \n     /**\n-     * Writes next block of compressed data to the output stream.\n-     * @throws IOException on error\n-     */\n-    protected final void deflate() throws IOException {\n-        int len = def.deflate(buf, 0, buf.length);\n-        if (len > 0) {\n-            writeOut(buf, 0, len);\n-            written += len;\n-        }\n-    }\n-\n-    /**\n      * Writes the local file header entry\n      * @param ze the entry to write\n      * @throws IOException on error\n         }\n \n         final byte[] localHeader = createLocalFileHeader(ze, name, encodable);\n-        offsets.put(ze, written);\n-        entry.localDataStart = written + 14; // Right before crc\n-        writeOut( localHeader);\n-        written += localHeader.length;\n-        entry.dataStart = written;\n+        long localHeaderStart = streamCompressor.getTotalBytesWritten();\n+        offsets.put(ze, localHeaderStart);\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n+        writeCounted(localHeader);\n+        entry.dataStart = streamCompressor.getTotalBytesWritten();\n     }\n \n \n         if (ze.getMethod() != DEFLATED || raf != null) {\n             return;\n         }\n-        writeOut(DD_SIG);\n-        writeOut(ZipLong.getBytes(ze.getCrc()));\n-        int sizeFieldSize = WORD;\n+        writeCounted(DD_SIG);\n+        writeCounted(ZipLong.getBytes(ze.getCrc()));\n         if (!hasZip64Extra(ze)) {\n-            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n+            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipLong.getBytes(ze.getSize()));\n         } else {\n-            sizeFieldSize = DWORD;\n-            writeOut(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-            writeOut(ZipEightByteInteger.getBytes(ze.getSize()));\n-        }\n-        written += 2 * WORD + 2 * sizeFieldSize;\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+        }\n     }\n \n     /**\n \n         handleZip64Extra(ze, lfhOffset, needsZip64Extra);\n \n-        byte[] centralFileHeader = createCentralFileHeader(ze, getName(ze), lfhOffset,\n-                                                           needsZip64Extra);\n-        writeOut(centralFileHeader);\n-        written += centralFileHeader.length;\n+        byte[] centralFileHeader = createCentralFileHeader(ze, getName(ze), lfhOffset, needsZip64Extra);\n+        writeCounted(centralFileHeader);\n     }\n \n     /**\n      * and {@link Zip64Mode #setUseZip64} is {@link Zip64Mode#Never}.\n      */\n     protected void writeCentralDirectoryEnd() throws IOException {\n-        writeOut(EOCD_SIG);\n+        writeCounted(EOCD_SIG);\n \n         // disk numbers\n-        writeOut(ZERO);\n-        writeOut(ZERO);\n+        writeCounted(ZERO);\n+        writeCounted(ZERO);\n \n         // number of entries\n         int numberOfEntries = entries.size();\n \n         byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n                                                 ZIP64_MAGIC_SHORT));\n-        writeOut(num);\n-        writeOut(num);\n+        writeCounted(num);\n+        writeCounted(num);\n \n         // length and location of CD\n-        writeOut(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\n-        writeOut(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n+        writeCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\n+        writeCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n \n         // ZIP file comment\n         ByteBuffer data = this.zipEncoding.encode(comment);\n-        writeOut(ZipShort.getBytes(data.limit()));\n-        writeOut(data.array(), data.arrayOffset(),\n-                 data.limit() - data.position());\n+        writeCounted(ZipShort.getBytes(data.limit()));\n+        streamCompressor.writeCounted(data.array(), data.arrayOffset(), data.limit() - data.position());\n     }\n \n     private static final byte[] ONE = ZipLong.getBytes(1L);\n             return;\n         }\n \n-        long offset = written;\n+        long offset = streamCompressor.getBytesWritten();\n \n         writeOut(ZIP64_EOCD_SIG);\n         // size, we don't have any variable length as we don't support\n      * @throws IOException on error\n      */\n     protected final void writeOut(byte[] data) throws IOException {\n-        writeOut(data, 0, data.length);\n-    }\n+        streamCompressor.writeOut(data, 0, data.length);\n+    }\n+\n \n     /**\n      * Write bytes to output or random access file.\n      * @throws IOException on error\n      */\n     protected final void writeOut(byte[] data, int offset, int length)\n-        throws IOException {\n-        if (raf != null) {\n-            raf.write(data, offset, length);\n-        } else {\n-            out.write(data, offset, length);\n-        }\n-    }\n-\n-    private void deflateUntilInputIsNeeded() throws IOException {\n-        while (!def.needsInput()) {\n-            deflate();\n-        }\n-    }\n+            throws IOException {\n+        streamCompressor.writeOut(data, offset, length);\n+    }\n+\n \n     private GeneralPurposeBit getGeneralPurposeBits(final int zipMethod, final boolean utfFallback) {\n         GeneralPurposeBit b = new GeneralPurposeBit();", "timestamp": 1419967423, "metainfo": ""}