{"sha": "e646770cfbaf617eb9183d94ac5002f736218013", "log": "javadocs", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/brotli/BrotliCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/brotli/BrotliCompressorInputStream.java\n         this.decIS = new org.brotli.dec.BrotliInputStream(in);\n     }\n \n-    /**\n-     * @return\n-     * @throws IOException\n-     * @see java.io.InputStream#available()\n-     */\n     @Override\n     public int available() throws IOException {\n         return decIS.available();\n     }\n \n-    /**\n-     * @throws IOException\n-     * @see org.brotli.dec.BrotliInputStream#close()\n-     */\n     @Override\n     public void close() throws IOException {\n         decIS.close();\n     }\n \n-    /**\n-     * @return\n-     * @see java.lang.Object#hashCode()\n-     */\n     @Override\n     public int hashCode() {\n         return decIS.hashCode();\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int read(final byte[] b) throws IOException {\n         return decIS.read(b);\n     }\n \n-    /**\n-     * @param obj\n-     * @return\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     */\n     @Override\n     public boolean equals(final Object obj) {\n         return decIS.equals(obj);\n     }\n \n-    /**\n-     * @param n\n-     * @return\n-     * @throws IOException\n-     * @see java.io.InputStream#skip(long)\n-     */\n     @Override\n     public long skip(final long n) throws IOException {\n         return decIS.skip(n);\n     }\n \n-    /**\n-     * @param readlimit\n-     * @see java.io.InputStream#mark(int)\n-     */\n     @Override\n     public void mark(final int readlimit) {\n         decIS.mark(readlimit);\n     }\n \n-    /**\n-     * @return\n-     * @see java.io.InputStream#markSupported()\n-     */\n     @Override\n     public boolean markSupported() {\n         return decIS.markSupported();\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int read() throws IOException {\n         final int ret = decIS.read();\n         return ret;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n         final int ret = decIS.read(buf, off, len);\n         return ret;\n     }\n \n-    /**\n-     * @return\n-     * @see java.lang.Object#toString()\n-     */\n     @Override\n     public String toString() {\n         return decIS.toString();\n     }\n \n-    /**\n-     * @throws IOException\n-     * @see java.io.InputStream#reset()\n-     */\n     @Override\n     public void reset() throws IOException {\n         decIS.reset();\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n \n     /**\n      * Returns a builder correctly configured for the LZ4 algorithm.\n+     * @return a builder correctly configured for the LZ4 algorithm\n      */\n     public static Parameters.Builder createParameterBuilder() {\n         int maxLen = BlockLZ4CompressorInputStream.WINDOW_SIZE - 1;\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n      * determines the maximum offset a back-reference can take. Must\n      * be a power of two.\n      * @throws IllegalArgumentException if windowSize is not a power of two.\n+     * @return a builder configured for the given window size\n      */\n     public static Builder builder(int windowSize) {\n         return new Builder(windowSize);\n          * but bigger lengths can be configured.\n          * @throws IllegalArgumentException if <code>windowSize</code>\n          * is smaller than <code>minBackReferenceLength</code>.\n+         * @return the builder\n          */\n         public Builder withMinBackReferenceLength(int minBackReferenceLength) {\n             this.minBackReferenceLength = Math.max(TRUE_MIN_BACK_REFERENCE_LENGTH, minBackReferenceLength);\n          * <code>minBackReferenceLength</code> is interpreted as\n          * <code>minBackReferenceLength</code>. <code>maxBackReferenceLength</code>\n          * is capped at <code>windowSize - 1</code>.\n+         * @return the builder\n          */\n         public Builder withMaxBackReferenceLength(int maxBackReferenceLength) {\n             this.maxBackReferenceLength = maxBackReferenceLength < minBackReferenceLength ? minBackReferenceLength\n          * non-positive value as well as values bigger than\n          * <code>windowSize - 1</code> are interpreted as <code>windowSize\n          * - 1</code>.\n+         * @return the builder\n          */\n         public Builder withMaxOffset(int maxOffset) {\n             this.maxOffset = maxOffset < 1 ? windowSize - 1 : Math.min(maxOffset, windowSize - 1);\n          * block. Negative numbers and 0 as well as values bigger than\n          * <code>windowSize</code> are interpreted as\n          * <code>windowSize</code>.\n+         * @return the builder\n          */\n         public Builder withMaxLiteralLength(int maxLiteralLength) {\n             this.maxLiteralLength = maxLiteralLength < 1 ? windowSize\n          * <p>When a back-references if this size has been found, stop searching for longer back-references.</p>\n          *\n          * <p>This settings can be used to tune the tradeoff between compression speed and compression ratio.</p>\n+         * @param niceLen the \"nice length\" of a back-reference\n+         * @return the builder\n          */\n         public Builder withNiceBackReferenceLength(int niceLen) {\n             niceBackReferenceLength = niceLen;\n          * Sets the maximum number of back-reference candidates that should be consulted.\n          *\n          * <p>This settings can be used to tune the tradeoff between compression speed and compression ratio.</p>\n+         * @param maxCandidates maximum number of back-reference candidates\n+         * @return the builder\n          */\n         public Builder withMaxNumberOfCandidates(int maxCandidates) {\n             this.maxCandidates = maxCandidates;\n          * try to find a longer match for the next position.</p>\n          *\n          * <p>Lazy matching is enabled by default and disabled when tuning for speed.</p>\n+         * @param lazy whether lazy matching should be performed\n+         * @return the builder\n          */\n         public Builder withLazyMatching(boolean lazy) {\n             lazyMatches = lazy;\n          *\n          * <p>Even if lazy matching is enabled it will not be performed if the length of the back-reference found for\n          * the current position is longer than this value.</p>\n+         * @param threshold the threshold for lazy matching\n+         * @return the builder\n          */\n         public Builder withLazyThreshold(int threshold) {\n             lazyThreshold = threshold;\n          * compression speed at the cost of compression ratio.\n          *\n          * <p>Use this method after configuring \"maximum back-reference length\".</p>\n+         * @return the builder\n          */\n         public Builder tunedForSpeed() {\n             niceBackReferenceLength = Math.max(minBackReferenceLength, maxBackReferenceLength / 8);\n          * compression ratio at the cost of compression speed.\n          *\n          * <p>Use this method after configuring \"maximum back-reference length\".</p>\n+         * @return the builder\n          */\n         public Builder tunedForCompressionRatio() {\n             niceBackReferenceLength = lazyThreshold = maxBackReferenceLength;\n \n     /**\n      * Gets the length of a back-reference that is considered nice enough to stop searching for longer ones.\n+     * @return the length of a back-reference that is considered nice enough to stop searching\n      */\n     public int getNiceBackReferenceLength() {\n         return niceBackReferenceLength;\n \n     /**\n      * Gets the maximum number of back-reference candidates to consider.\n+     * @return the maximum number of back-reference candidates to consider\n      */\n     public int getMaxCandidates() {\n         return maxCandidates;\n \n     /**\n      * Gets whether to perform lazy matching.\n+     * @return whether to perform lazy matching\n      */\n     public boolean getLazyMatching() {\n         return lazyMatching;\n \n     /**\n      * Gets the threshold for lazy matching.\n+     * @return the threshold for lazy matching\n      */\n     public int getLazyMatchingThreshold() {\n         return lazyThreshold;\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorOutputStream.java\n     /**\n      * Returns a builder correctly configured for the Snappy algorithm using the gven block size.\n      * @param blockSize the block size.\n+     * @return a builder correctly configured for the Snappy algorithm using the gven block size\n      */\n     public static Parameters.Builder createParameterBuilder(int blockSize) {\n         // the max offset and max literal length defined by the format", "timestamp": 1494527377, "metainfo": ""}