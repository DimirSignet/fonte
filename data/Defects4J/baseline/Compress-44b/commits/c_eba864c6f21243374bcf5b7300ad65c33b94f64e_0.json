{"sha": "eba864c6f21243374bcf5b7300ad65c33b94f64e", "log": "size -> length", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n  *  buffer of twice of <code>windowSize</code> - real world values are\n  *  in the area of 32k.</dd>\n  *\n- *  <dt><code>minMatchSize</code></dt>\n- *  <dd>Minimal size of a match found. A true minimum of 3 is\n- *  hard-coded inside of this implemention but bigger sizes can be\n+ *  <dt><code>minMatchLength</code></dt>\n+ *  <dd>Minimal length of a match found. A true minimum of 3 is\n+ *  hard-coded inside of this implemention but bigger lengths can be\n  *  configured.</dd>\n  *\n- *  <dt><code>maxMatchSize</code></dt>\n- *  <dd>Maximal size of a match found.</dd>\n+ *  <dt><code>maxMatchLength</code></dt>\n+ *  <dd>Maximal length of a match found.</dd>\n  *\n  *  <dt><code>maxOffset</code></dt>\n  *  <dd>Maximal offset of a back-reference.</dd>\n  *\n- *  <dt><code>maxLiteralSize</code></dt>\n- *  <dd>Maximal size of a literal block.</dd>\n+ *  <dt><code>maxLiteralLength</code></dt>\n+ *  <dd>Maximal length of a literal block.</dd>\n  * </dl>\n  *\n  * @see \"https://tools.ietf.org/html/rfc1951#section-4\"\n         }\n         System.arraycopy(data, off, window, currentPosition + lookahead, len);\n         lookahead += len;\n-        if (!initialized && lookahead >= params.getMinMatchSize()) {\n+        if (!initialized && lookahead >= params.getMinMatchLength()) {\n             initialize();\n         }\n         if (initialized) {\n     }\n \n     private void compress() {\n-        final int minMatch = params.getMinMatchSize();\n+        final int minMatch = params.getMinMatchLength();\n \n         while (lookahead >= minMatch) {\n             catchUpMissedInserts();\n                 // no match, append to current or start a new literal\n                 lookahead--;\n                 currentPosition++;\n-                if (currentPosition - blockStart >= params.getMaxLiteralSize()) {\n+                if (currentPosition - blockStart >= params.getMaxLiteralLength()) {\n                     flushLiteralBlock();\n                     blockStart = currentPosition;\n                 }\n      * longest match as a side effect.</p>\n      */\n     private int longestMatch(int matchHead) {\n-        final int minLength = params.getMinMatchSize();\n+        final int minLength = params.getMinMatchLength();\n         int longestMatchLength = minLength - 1;\n-        final int maxPossibleLength = Math.min(params.getMaxMatchSize(), lookahead);\n+        final int maxPossibleLength = Math.min(params.getMaxMatchLength(), lookahead);\n         final int minIndex = Math.max(0, currentPosition - params.getMaxOffset());\n         while (matchHead >= minIndex) {\n             int currentLength = 0;\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n  * Parameters of the {@link LZ77Compressor compressor}.\n  */\n public final class Parameters {\n-    public static final int TRUE_MIN_MATCH_SIZE = LZ77Compressor.NUMBER_OF_BYTES_IN_HASH;\n-    private final int windowSize, minMatchSize, maxMatchSize, maxOffset, maxLiteralSize;\n+    public static final int TRUE_MIN_MATCH_LENGTH = LZ77Compressor.NUMBER_OF_BYTES_IN_HASH;\n+    private final int windowSize, minMatchLength, maxMatchLength, maxOffset, maxLiteralLength;\n \n     /**\n      * Initializes the compressor's parameters with a\n-     * <code>minMatchSize</code> of 3 and <code>max*Size</code>\n+     * <code>minMatchLength</code> of 3 and <code>max*Length</code>\n      * equal to <code>windowSize</code>.\n      *\n      * @param windowSize the size of the sliding window - this\n      * determines the maximum offset a back-reference can take.\n      * @throws IllegalArgumentException if <code>windowSize</code>\n-     * is smaller than <code>minMatchSize</code>.\n+     * is smaller than <code>minMatchLength</code>.\n      */\n     public Parameters(int windowSize) {\n-        this(windowSize, TRUE_MIN_MATCH_SIZE, windowSize, windowSize, windowSize);\n+        this(windowSize, TRUE_MIN_MATCH_LENGTH, windowSize, windowSize, windowSize);\n     }\n \n     /**\n      * @param windowSize the size of the sliding window, must be a\n      * power of two - this determines the maximum offset a\n      * back-reference can take.\n-     * @param minMatchSize the minimal size of a match found. A\n+     * @param minMatchLength the minimal length of a match found. A\n      * true minimum of 3 is hard-coded inside of this implemention\n-     * but bigger sizes can be configured.\n-     * @param maxMatchSize maximal site of a match found. A value\n-     * smaller than <code>minMatchSize</code> is interpreted as\n+     * but bigger lengths can be configured.\n+     * @param maxMatchLength maximal site of a match found. A value\n+     * smaller than <code>minMatchLength</code> is interpreted as\n      * infinite (actually {@link Integer.MAX_VALUE}).\n      * @param maxOffset maximal offset of a back-reference. A\n      * non-positive value is interpreted as <code>windowSize</code>.\n-     * @param maxLiteralSize maximal size of a literal block. Negative\n+     * @param maxLiteralLength maximal length of a literal block. Negative\n      * numbers and 0 as well as values bigger than <code>2 *\n      * windowSize</code> are interpreted as <code>windowSize</code>.\n      * @throws IllegalArgumentException if <code>windowSize</code> is\n-     * smaller than <code>minMatchSize</code> or not a power of two.\n+     * smaller than <code>minMatchLength</code> or not a power of two.\n      */\n-    public Parameters(int windowSize, int minMatchSize, int maxMatchSize,\n-                      int maxOffset, int maxLiteralSize) {\n-        this.minMatchSize = Math.max(TRUE_MIN_MATCH_SIZE, minMatchSize);\n-        if (windowSize < this.minMatchSize) {\n-            throw new IllegalArgumentException(\"windowSize must be at least as big as minMatchSize\");\n+    public Parameters(int windowSize, int minMatchLength, int maxMatchLength,\n+                      int maxOffset, int maxLiteralLength) {\n+        this.minMatchLength = Math.max(TRUE_MIN_MATCH_LENGTH, minMatchLength);\n+        if (windowSize < this.minMatchLength) {\n+            throw new IllegalArgumentException(\"windowSize must be at least as big as minMatchLength\");\n         }\n         if (!isPowerOfTwo(windowSize)) {\n             throw new IllegalArgumentException(\"windowSize must be a power of two\");\n         this.windowSize = windowSize;\n         this.maxOffset = maxOffset < 1 ? this.windowSize\n             : Math.min(maxOffset, this.windowSize);\n-        this.maxMatchSize = maxMatchSize < this.minMatchSize ? Integer.MAX_VALUE\n-            : maxMatchSize;\n-        this.maxLiteralSize = maxLiteralSize < 1 || maxLiteralSize > 2 * windowSize\n-            ? windowSize : maxLiteralSize;\n+        this.maxMatchLength = maxMatchLength < this.minMatchLength ? Integer.MAX_VALUE\n+            : maxMatchLength;\n+        this.maxLiteralLength = maxLiteralLength < 1 || maxLiteralLength > 2 * windowSize\n+            ? windowSize : maxLiteralLength;\n     }\n \n     /**\n         return windowSize;\n     }\n     /**\n-     * Gets the minimal size of a match found.\n+     * Gets the minimal length of a match found.\n      */\n-    public int getMinMatchSize() {\n-        return minMatchSize;\n+    public int getMinMatchLength() {\n+        return minMatchLength;\n     }\n     /**\n-     * Gets the maximal size of a match found.\n+     * Gets the maximal length of a match found.\n      */\n-    public int getMaxMatchSize() {\n-        return maxMatchSize;\n+    public int getMaxMatchLength() {\n+        return maxMatchLength;\n     }\n     /**\n      * Gets the maximal offset of a match found.\n         return maxOffset;\n     }\n     /**\n-     * Gets the maximal size of a literal block.\n+     * Gets the maximal length of a literal block.\n      */\n-    public int getMaxLiteralSize() {\n-        return maxLiteralSize;\n+    public int getMaxLiteralLength() {\n+        return maxLiteralLength;\n     }\n \n     private static final boolean isPowerOfTwo(int x) {\n--- a/src/test/java/org/apache/commons/compress/compressors/lz77support/ParametersTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/ParametersTest.java\n     public void defaultConstructor() {\n         Parameters p = new Parameters(128);\n         assertEquals(128, p.getWindowSize());\n-        assertEquals(3, p.getMinMatchSize());\n-        assertEquals(128, p.getMaxMatchSize());\n+        assertEquals(3, p.getMinMatchLength());\n+        assertEquals(128, p.getMaxMatchLength());\n         assertEquals(128, p.getMaxOffset());\n-        assertEquals(128, p.getMaxLiteralSize());\n+        assertEquals(128, p.getMaxLiteralLength());\n     }\n \n     @Test\n-    public void minMatchSizeIsAtLeastThree() {\n+    public void minMatchLengthIsAtLeastThree() {\n         Parameters p = new Parameters(128, 2, 3, 4, 5);\n-        assertEquals(3, p.getMinMatchSize());\n+        assertEquals(3, p.getMinMatchLength());\n     }\n \n     @Test\n-    public void maxMatchSizeIsInfiniteWhenSmallerThanMinMatchSize() {\n+    public void maxMatchLengthIsInfiniteWhenSmallerThanMinMatchLength() {\n         Parameters p = new Parameters(128, 2, 2, 4, 5);\n-        assertEquals(Integer.MAX_VALUE, p.getMaxMatchSize());\n+        assertEquals(Integer.MAX_VALUE, p.getMaxMatchLength());\n     }\n \n     @Test\n-    public void maxMatchSizeIsMinMatchSizeIfBothAreEqual() {\n+    public void maxMatchLengthIsMinMatchLengthIfBothAreEqual() {\n         Parameters p = new Parameters(128, 2, 3, 4, 5);\n-        assertEquals(3, p.getMaxMatchSize());\n+        assertEquals(3, p.getMaxMatchLength());\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void maxLiteralSizeIsWindowSizeIfSetTo0() {\n+    public void maxLiteralLengthIsWindowSizeIfSetTo0() {\n         Parameters p = new Parameters(128, 2, 3, 4, 0);\n-        assertEquals(128, p.getMaxLiteralSize());\n+        assertEquals(128, p.getMaxLiteralLength());\n     }\n \n     @Test\n-    public void maxLiteralSizeIsWindowSizeIfSetToANegativeValue() {\n+    public void maxLiteralLengthIsWindowSizeIfSetToANegativeValue() {\n         Parameters p = new Parameters(128, 2, 3, 0, -1);\n-        assertEquals(128, p.getMaxLiteralSize());\n+        assertEquals(128, p.getMaxLiteralLength());\n     }\n \n     @Test\n-    public void maxLiteralSizeIsWindowSizeIfSetToAValueTooBigToHoldInSlidingWindow() {\n+    public void maxLiteralLengthIsWindowSizeIfSetToAValueTooBigToHoldInSlidingWindow() {\n         Parameters p = new Parameters(128, 2, 3, 0, 259);\n-        assertEquals(128, p.getMaxLiteralSize());\n+        assertEquals(128, p.getMaxLiteralLength());\n     }\n \n     @Test\n     public void allParametersUsuallyTakeTheirSpecifiedValues() {\n         Parameters p = new Parameters(256, 4, 5, 6, 7);\n         assertEquals(256, p.getWindowSize());\n-        assertEquals(4, p.getMinMatchSize());\n-        assertEquals(5, p.getMaxMatchSize());\n+        assertEquals(4, p.getMinMatchLength());\n+        assertEquals(5, p.getMaxMatchLength());\n         assertEquals(6, p.getMaxOffset());\n-        assertEquals(7, p.getMaxLiteralSize());\n+        assertEquals(7, p.getMaxLiteralLength());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void windowSizeMustNotBeSmallerThanMinMatchSize() {\n+    public void windowSizeMustNotBeSmallerThanMinMatchLength() {\n         new Parameters(128, 200, 300, 400, 500);\n     }\n ", "timestamp": 1483809023, "metainfo": ""}