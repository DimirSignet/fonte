{"sha": "63aa078caa660f235efb28e17b618411057ad8e1", "log": "perform works on a copy of the actual changeset. This enables multiple uses of the same changset on different streams  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n \n /**\n  * ChangeSet collects and performs changes to an archive.\n+ * Putting delete changes in this ChangeSet from multiple threads can\n+ * cause conflicts.\n+ * \n+ * @NotThreadSafe\n  */\n public final class ChangeSet {\n \n     private final Set changes = new LinkedHashSet();\n \n     /**\n-     * Deletes the file with the filename from the archive\n+     * Deletes the file with the filename from the archive. \n+     * This method is not thread safe.\n      * \n      * @param pFilename\n      *            the filename of the file to delete\n \n     /**\n      * Performs all changes collected in this ChangeSet on the input stream and\n-     * streams the result to the output stream.\n+     * streams the result to the output stream. Since this method works on a copy\n+     * of the actual ChangSet, perform may be called more than once.\n      * \n      * @param in\n      *            the InputStream to perform the changes on\n      * @param out\n      *            the resulting OutputStream with all modifications\n      * @throws IOException\n-     *             if an read/write error occurs\n+     *             if an read/write error occurs\n      */\n     public void perform(ArchiveInputStream in, ArchiveOutputStream out)\n             throws IOException {\n-        for (Iterator it = changes.iterator(); it.hasNext();) {\n+        Set workingSet = new LinkedHashSet(changes);\n+        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n             Change change = (Change) it.next();\n \n             if (change.type() == Change.TYPE_ADD) {\n         while ((entry = in.getNextEntry()) != null) {\n             boolean copy = true;\n \n-            for (Iterator it = changes.iterator(); it.hasNext();) {\n+            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                 Change change = (Change) it.next();\n \n                 if (change.type() == Change.TYPE_DELETE\n             }\n \n             if (copy) {\n-                if (!isDeletedLater(entry)) {\n+                if (!isDeletedLater(workingSet, entry)) {\n                     copyStream(in, out, entry);\n                 }\n             }\n     }\n \n     /**\n-     * Adds an delete change\n+     * Adds an delete change. This method is not thread safe.\n      * \n      * @param pChange\n      *            the change which should result in a deletion\n      *            the entry to check\n      * @return true, if this entry has an deletion change later, false otherwise\n      */\n-    private boolean isDeletedLater(ArchiveEntry entry) {\n+    private boolean isDeletedLater(Set workingSet, ArchiveEntry entry) {\n         String source = entry.getName();\n \n-        if (!changes.isEmpty()) {\n-            for (Iterator it = changes.iterator(); it.hasNext();) {\n+        if (!workingSet.isEmpty()) {\n+            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                 Change change = (Change) it.next();\n                 if (change.type() == Change.TYPE_DELETE) {\n                     String target = change.targetFile();", "timestamp": 1239273747, "metainfo": ""}