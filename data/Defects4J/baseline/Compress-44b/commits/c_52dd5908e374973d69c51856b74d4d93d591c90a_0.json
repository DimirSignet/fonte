{"sha": "52dd5908e374973d69c51856b74d4d93d591c90a", "log": "COMPRESS-363 properly handle overflow inside BitInputStream", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n         }\n-        while (bitsCachedSize < count) {\n+        while (bitsCachedSize < count && bitsCachedSize < 57) {\n             final long nextByte = in.read();\n             if (nextByte < 0) {\n                 return nextByte;\n             }\n             bitsCachedSize += 8;\n         }\n+        int overflowBits = 0;\n+        long overflow = 0l;\n+        if (bitsCachedSize < count) {\n+            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n+            int bitsToAddCount = count - bitsCachedSize;\n+            overflowBits = 8 - bitsToAddCount;\n+            final long nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n+                bitsCached |= (bitsToAdd << bitsCachedSize);\n+                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n+            } else {\n+                bitsCached <<= bitsToAddCount;\n+                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n+                bitsCached |= bitsToAdd;\n+                overflow = nextByte & MASKS[overflowBits];\n+            }\n+            bitsCachedSize = count;\n+        }\n         \n         final long bitsOut;\n-        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-            bitsOut = (bitsCached & MASKS[count]);\n-            bitsCached >>>= count;\n+        if (overflowBits == 0) {\n+            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+                bitsOut = (bitsCached & MASKS[count]);\n+                bitsCached >>>= count;\n+            } else {\n+                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n+            }\n+            bitsCachedSize -= count;\n         } else {\n-            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n+            bitsOut = bitsCached & MASKS[count];\n+            bitsCached = overflow;\n+            bitsCachedSize = overflowBits;\n         }\n-        bitsCachedSize -= count;\n         return bitsOut;\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n         bis.close();\n     }\n \n+    /**\n+     * @see \"https://issues.apache.org/jira/browse/COMPRESS-363\"\n+     */\n+    @Test\n+    public void littleEndianWithOverflow() throws Exception {\n+        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n+                87, // 01010111\n+                45, // 00101101\n+                66, // 01000010\n+                15, // 00001111\n+                90, // 01011010\n+                29, // 00011101\n+                88, // 01011000\n+                61, // 00111101\n+                33, // 00100001\n+                74  // 01001010\n+            });\n+        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n+        assertEquals(23, // 10111\n+                     bin.readBits(5));\n+        assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010\n+                     bin.readBits(63));\n+        assertEquals(1186, // 01001010-0010\n+                     bin.readBits(12));\n+        assertEquals(-1 , bin.readBits(1));\n+    }\n+\n+    @Test\n+    public void bigEndianWithOverflow() throws Exception {\n+        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n+                87, // 01010111\n+                45, // 00101101\n+                66, // 01000010\n+                15, // 00001111\n+                90, // 01011010\n+                29, // 00011101\n+                88, // 01011000\n+                61, // 00111101\n+                33, // 00100001\n+                74  // 01001010\n+            });\n+        BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n+        assertEquals(10, // 01010\n+                     bin.readBits(5));\n+        assertEquals(8274274654740644818l, //111-00101101-01000010-00001111-01011010-00011101-01011000-00111101-0010\n+                     bin.readBits(63));\n+        assertEquals(330, // 0001-01001010\n+                     bin.readBits(12));\n+        assertEquals(-1 , bin.readBits(1));\n+    }\n+\n     private ByteArrayInputStream getStream() {\n         return new ByteArrayInputStream(new byte[] {\n                 (byte) 0xF8,  // 11111000", "timestamp": 1467401844, "metainfo": ""}