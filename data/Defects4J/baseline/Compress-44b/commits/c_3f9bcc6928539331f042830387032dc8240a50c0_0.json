{"sha": "3f9bcc6928539331f042830387032dc8240a50c0", "log": "fix whitespace  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n \n public abstract class ArchiveInputStream extends InputStream {\n \n-\t/**\n+    /**\n      * Returns the next Archive Entry in this Stream.\n      * @return the next entry\n      * @throws IOException if the next entry could not be read\n      */\n     public abstract ArchiveEntry getNextEntry() throws IOException;\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n     }\n \n     public abstract void putArchiveEntry(ArchiveEntry entry) throws IOException;\n-\t\n+\n     public abstract void closeArchiveEntry() throws IOException;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n \n     private final InputStream input;\n     private long offset = 0;\n-        \n+\n     public ArArchiveInputStream( final InputStream pInput ) {\n         input = pInput;\n     }\n-        \n+\n     public ArchiveEntry getNextEntry() throws IOException {\n-                \n+\n         if (offset == 0) {\n-            final byte[] expected = \"!<arch>\\n\".getBytes();                     \n+            final byte[] expected = \"!<arch>\\n\".getBytes();\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n         if (input.available() == 0) {\n             return null;\n         }\n-                                \n+\n         if (offset % 2 != 0) {\n             read();\n         }\n         final byte[] groupid = new byte[6];\n         final byte[] filemode = new byte[8];\n         final byte[] length = new byte[10];\n-                \n+\n         read(name);\n         read(lastmodified);\n         read(userid);\n         read(length);\n \n         {\n-            final byte[] expected = \"`\\012\".getBytes();                 \n+            final byte[] expected = \"`\\012\".getBytes();\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n                 }\n             }\n         }\n-                \n+\n         return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\n-        \n+\n     }\n-        \n-        \n+\n+\n     public int read() throws IOException {\n         final int ret = input.read();\n         offset++;\n         return ret;\n     }\n-        \n+\n     public int read(byte b[]) throws IOException {\n         final int ret = read(b, 0, b.length);\n         offset = offset + b.length;\n         offset = offset + off;\n         return ret;\n     }\n-        \n+\n     public static boolean matches(byte[] signature, int length) {\n         // 3c21 7261 6863 0a3e\n-        \n+\n         if (length < 8) {\n             return false;\n         }\n         if (signature[7] != 0x0a) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n \n public class ArArchiveOutputStream extends ArchiveOutputStream {\n \n-\tprivate long archiveOffset = 0;\n-\tprivate long entryOffset = 0;\n-\tprivate ArArchiveEntry prevEntry;\n+    private long archiveOffset = 0;\n+    private long entryOffset = 0;\n+    private ArArchiveEntry prevEntry;\n \n-\tpublic ArArchiveOutputStream( final OutputStream pOut ) {\n-            super(pOut);\n-\t}\n+    public ArArchiveOutputStream( final OutputStream pOut ) {\n+        super(pOut);\n+    }\n \n-\tprivate long writeArchiveHeader() throws IOException {\t\t\n-\t\tfinal String header = \"!<arch>\\n\";\n-\t\tout.write(header.getBytes());\n-\t\treturn header.length();\n-\t}\n+    private long writeArchiveHeader() throws IOException {\n+        final String header = \"!<arch>\\n\";\n+        out.write(header.getBytes());\n+        return header.length();\n+    }\n \n-\tpublic void closeArchiveEntry() throws IOException {\n-\t\tif ((entryOffset % 2) != 0) {\n-        \tout.write('\\n');\n-        \tarchiveOffset++;\n-        }\t\t\n-\t}\n-\t\n-\tpublic void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\n-\t\tArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\n-\t\tif (prevEntry == null) {\n-\t\t\tarchiveOffset += writeArchiveHeader();\t\t\t\n-\t\t} else {\n-\t\t\tif (prevEntry.getLength() != entryOffset) {\n-\t\t\t\tthrow new IOException(\"length does not match entry (\" + prevEntry.getLength() + \" != \" + entryOffset);\n-\t\t\t}\n-\t\t\t\n-\t\t\tcloseArchiveEntry();\n-\t\t}\n-\t\t\n-\t\tprevEntry = pArEntry;\n-\t\t\n-\t\tarchiveOffset += writeEntryHeader(pArEntry);\n+    public void closeArchiveEntry() throws IOException {\n+        if ((entryOffset % 2) != 0) {\n+            out.write('\\n');\n+            archiveOffset++;\n+        }\n+    }\n \n-\t\tentryOffset = 0;\n-\t}\n+    public void putArchiveEntry( final ArchiveEntry pEntry ) throws IOException {\n+        ArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\n+        if (prevEntry == null) {\n+            archiveOffset += writeArchiveHeader();\n+        } else {\n+            if (prevEntry.getLength() != entryOffset) {\n+                throw new IOException(\"length does not match entry (\" + prevEntry.getLength() + \" != \" + entryOffset);\n+            }\n \n-\tprivate long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException { \n-\t\tfinal long diff = pNewOffset - pOffset;\n-\t\n-\t\tif (diff > 0) {\n-\t\t\tfor (int i = 0; i < diff; i++) {\n-\t\t\t\twrite(pFill);\n-\t\t\t}\n-\t\t}\n+            closeArchiveEntry();\n+        }\n \n-\t\treturn pNewOffset;\n-\t}\n-\t\n-\tprivate long write( final String data ) throws IOException {\n-\t\tfinal byte[] bytes = data.getBytes(\"ascii\");\n-\t\twrite(bytes);\n-\t\treturn bytes.length;\n-\t}\n-\t\n-\tprivate long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\n-\t\t\n-\t\tlong offset = 0;\n-\t\t\n-\t\tfinal String n = pEntry.getName();\n-\t\tif (n.length() > 16) {\n-\t\t\tthrow new IOException(\"filename too long\");\n-\t\t}\t\t\n-\t\toffset += write(n);\n-\t\t\n-\t\toffset = fill(offset, 16, ' ');\n-\t\tfinal String m = \"\" + (pEntry.getLastModified() / 1000);\n-\t\tif (m.length() > 12) {\n-\t\t\tthrow new IOException(\"modified too long\");\n-\t\t}\t\t\n-\t\toffset += write(m);\t\t\n+        prevEntry = pArEntry;\n \n-\t\toffset = fill(offset, 28, ' ');\n-\t\tfinal String u = \"\" + pEntry.getUserId();\n-\t\tif (u.length() > 6) {\n-\t\t\tthrow new IOException(\"userid too long\");\n-\t\t}\t\t\n-\t\toffset += write(u);\n+        archiveOffset += writeEntryHeader(pArEntry);\n \n-\t\toffset = fill(offset, 34, ' ');\n-\t\tfinal String g = \"\" + pEntry.getGroupId();\n-\t\tif (g.length() > 6) {\n-\t\t\tthrow new IOException(\"groupid too long\");\n-\t\t}\t\t\n-\t\toffset += write(g);\n+        entryOffset = 0;\n+    }\n \n-\t\toffset = fill(offset, 40, ' ');\n-\t\tfinal String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\n-\t\tif (fm.length() > 8) {\n-\t\t\tthrow new IOException(\"filemode too long\");\n-\t\t}\t\t\n-\t\toffset += write(fm);\n+    private long fill( final long pOffset, final long pNewOffset, final char pFill ) throws IOException { \n+        final long diff = pNewOffset - pOffset;\n \n-\t\toffset = fill(offset, 48, ' ');\n-\t\tfinal String s = \"\" + pEntry.getLength();\n-\t\tif (s.length() > 10) {\n-\t\t\tthrow new IOException(\"size too long\");\n-\t\t}\t\t\n-\t\toffset += write(s);\n+        if (diff > 0) {\n+            for (int i = 0; i < diff; i++) {\n+                write(pFill);\n+            }\n+        }\n \n-\t\toffset = fill(offset, 58, ' ');\n+        return pNewOffset;\n+    }\n \n-\t\toffset += write(\"`\\012\");\n-\t\t\n-\t\treturn offset;\n-\t}\t\t\n-\t\n-\tpublic void write(int b) throws IOException {\n-\t\tout.write(b);\n-\t\tentryOffset++;\n-\t}\n+    private long write( final String data ) throws IOException {\n+        final byte[] bytes = data.getBytes(\"ascii\");\n+        write(bytes);\n+        return bytes.length;\n+    }\n \n-\tpublic void write(byte[] b, int off, int len) throws IOException {\n-\t\tout.write(b, off, len);\n-\t\tentryOffset += len;\n-\t}\n+    private long writeEntryHeader( final ArArchiveEntry pEntry ) throws IOException {\n \n-\tpublic void write(byte[] b) throws IOException {\n-\t\tout.write(b);\n-\t\tentryOffset += b.length;\n-\t}\n+        long offset = 0;\n \n-\tpublic void close() throws IOException {\n-\t\tcloseArchiveEntry();\n-\t\tout.close();\n-\t\tprevEntry = null;\n-\t}\n+        final String n = pEntry.getName();\n+        if (n.length() > 16) {\n+            throw new IOException(\"filename too long\");\n+        }\n+        offset += write(n);\n+\n+        offset = fill(offset, 16, ' ');\n+        final String m = \"\" + (pEntry.getLastModified() / 1000);\n+        if (m.length() > 12) {\n+            throw new IOException(\"modified too long\");\n+        }\n+        offset += write(m);\n+\n+        offset = fill(offset, 28, ' ');\n+        final String u = \"\" + pEntry.getUserId();\n+        if (u.length() > 6) {\n+            throw new IOException(\"userid too long\");\n+        }\n+        offset += write(u);\n+\n+        offset = fill(offset, 34, ' ');\n+        final String g = \"\" + pEntry.getGroupId();\n+        if (g.length() > 6) {\n+            throw new IOException(\"groupid too long\");\n+        }\n+        offset += write(g);\n+\n+        offset = fill(offset, 40, ' ');\n+        final String fm = \"\" + Integer.toString(pEntry.getMode(), 8);\n+        if (fm.length() > 8) {\n+            throw new IOException(\"filemode too long\");\n+        }\n+        offset += write(fm);\n+\n+        offset = fill(offset, 48, ' ');\n+        final String s = \"\" + pEntry.getLength();\n+        if (s.length() > 10) {\n+            throw new IOException(\"size too long\");\n+        }\n+        offset += write(s);\n+\n+        offset = fill(offset, 58, ' ');\n+\n+        offset += write(\"`\\012\");\n+\n+        return offset;\n+    }\n+\n+    public void write(int b) throws IOException {\n+        out.write(b);\n+        entryOffset++;\n+    }\n+\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        out.write(b, off, len);\n+        entryOffset += len;\n+    }\n+\n+    public void write(byte[] b) throws IOException {\n+        out.write(b);\n+        entryOffset += b.length;\n+    }\n+\n+    public void close() throws IOException {\n+        closeArchiveEntry();\n+        out.close();\n+        prevEntry = null;\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n  */\n \n public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants {\n-        \n+\n     private boolean closed = false;\n \n     private CpioArchiveEntry entry;\n     private byte tmpbuf[] = new byte[4096];\n \n     private long crc = 0;\n-    \n+\n     private InputStream in = null;\n \n     /**\n         }\n         return (ArchiveEntry)entry;\n     }\n-        \n+\n     public static boolean matches(byte[] signature, int length) {\n         // 3037 3037 30\n-        \n+\n         if (length < 5) {\n             return false;\n         }\n         if (signature[4] != 0x30) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n  * based on code from the jRPM project (jrpm.sourceforge.net) \n  */\n public class CpioArchiveOutputStream extends ArchiveOutputStream implements CpioConstants {\n-\t\n+\n     private CpioArchiveEntry cpioEntry;\n \n     private boolean closed = false;\n     private long crc = 0;\n \n     private long written;\n-    \n+\n     /**\n      * Check to make sure that this stream has not been closed\n      *\n      */\n     public void setFormat(final short format) {\n         switch (format) {\n-            case FORMAT_NEW:\n-            case FORMAT_NEW_CRC:\n-            case FORMAT_OLD_ASCII:\n-            case FORMAT_OLD_BINARY:\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unknown header type\");\n+        case FORMAT_NEW:\n+        case FORMAT_NEW_CRC:\n+        case FORMAT_OLD_ASCII:\n+        case FORMAT_OLD_BINARY:\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"Unknown header type\");\n \n         }\n         synchronized (this) {\n \n     private void writeHeader(final CpioArchiveEntry e) throws IOException {\n         switch (e.getFormat()) {\n-            case FORMAT_NEW:\n-            \tout.write(MAGIC_NEW.getBytes());\n-                writeNewEntry(e);\n-                break;\n-            case FORMAT_NEW_CRC:\n-            \tout.write(MAGIC_NEW_CRC.getBytes());\n-                writeNewEntry(e);\n-                break;\n-            case FORMAT_OLD_ASCII:\n-            \tout.write(MAGIC_OLD_ASCII.getBytes());\n-                writeOldAsciiEntry(e);\n-                break;\n-            case FORMAT_OLD_BINARY:\n-                boolean swapHalfWord = true;\n-                writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n-                writeOldBinaryEntry(e, swapHalfWord);\n-                break;\n+        case FORMAT_NEW:\n+            out.write(MAGIC_NEW.getBytes());\n+            writeNewEntry(e);\n+            break;\n+        case FORMAT_NEW_CRC:\n+            out.write(MAGIC_NEW_CRC.getBytes());\n+            writeNewEntry(e);\n+            break;\n+        case FORMAT_OLD_ASCII:\n+            out.write(MAGIC_OLD_ASCII.getBytes());\n+            writeOldAsciiEntry(e);\n+            break;\n+        case FORMAT_OLD_BINARY:\n+            boolean swapHalfWord = true;\n+            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n+            writeOldBinaryEntry(e, swapHalfWord);\n+            break;\n         }\n     }\n \n \n         if (this.cpioEntry.getSize() != this.written) {\n             throw new IOException(\"invalid entry size (expected \"\n-                    + this.cpioEntry.getSize() + \" but got \" + this.written\n-                    + \" bytes)\");\n+                                  + this.cpioEntry.getSize() + \" but got \" + this.written\n+                                  + \" bytes)\");\n         }\n         if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n             pad(this.cpioEntry.getSize(), 4);\n      *                     occurred\n      */\n     public synchronized void write(final byte[] b, final int off, final int len)\n-            throws IOException {\n+        throws IOException {\n         ensureOpen();\n         if (off < 0 || len < 0 || off > b.length - len) {\n             throw new IndexOutOfBoundsException();\n     }\n \n     private void writeCString(final String str) throws IOException {\n-    \tout.write(str.getBytes());\n-    \tout.write('\\0');\n+        out.write(str.getBytes());\n+        out.write('\\0');\n     }\n \n     /**\n         return ret;\n     }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry()\n-\t */\n-\tpublic void closeArchiveEntry() throws IOException {\n-\t\tthis.closeEntry();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry(org.apache.commons.compress.archivers.ArchiveEntry)\n-\t */\n-\tpublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-\t\tthis.putNextEntry((CpioArchiveEntry)entry);\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see java.io.OutputStream#write(int)\n-\t */\n-\tpublic void write(int b) throws IOException {\n-\t\tout.write(b);\n-\t}\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry()\n+     */\n+    public void closeArchiveEntry() throws IOException {\n+        this.closeEntry();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry(org.apache.commons.compress.archivers.ArchiveEntry)\n+     */\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        this.putNextEntry((CpioArchiveEntry)entry);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.io.OutputStream#write(int)\n+     */\n+    public void write(int b) throws IOException {\n+        out.write(b);\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n     public JarArchiveInputStream( final InputStream inputStream ) {\n         super(inputStream);\n     }\n-        \n+\n     public ArchiveEntry getNextEntry() throws IOException {\n         ZipArchiveEntry entry = (ZipArchiveEntry)super.getNextEntry();\n         if(entry == null) {\n             return (ArchiveEntry)new JarArchiveEntry(entry);\n         }\n     }\n-        \n+\n     public static boolean matches(byte[] signature, int length ) {\n         // 4b50 0403 0014 0008\n \n         if (signature[7] != 0x00) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n \n public class JarArchiveOutputStream extends ZipArchiveOutputStream {\n \n-\tpublic JarArchiveOutputStream( final OutputStream out ) {\n-\t\tsuper(out);\n-                setEncoding(\"UTF8\");\n-\t}\n+    public JarArchiveOutputStream( final OutputStream out ) {\n+        super(out);\n+        setEncoding(\"UTF8\");\n+    }\n \n-\tpublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-\t\t// TODO special jar stuff\n-\t\tsuper.putArchiveEntry((ZipArchiveEntry) entry);\n-\t}\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        // TODO special jar stuff\n+        super.putArchiveEntry((ZipArchiveEntry) entry);\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n \n             if (debug) {\n                 System.err.println(\"TarInputStream: SKIP currENTRY '\"\n-                        + currEntry.getName() + \"' SZ \"\n-                        + entrySize + \" OFF \"\n-                        + entryOffset + \"  skipping \"\n-                        + numToSkip + \" bytes\");\n+                                   + currEntry.getName() + \"' SZ \"\n+                                   + entrySize + \" OFF \"\n+                                   + entryOffset + \"  skipping \"\n+                                   + numToSkip + \" bytes\");\n             }\n \n             while (numToSkip > 0) {\n \n             if (debug) {\n                 System.err.println(\"TarInputStream: SET CURRENTRY '\"\n-                        + currEntry.getName()\n-                        + \"' size = \"\n-                        + currEntry.getSize());\n+                                   + currEntry.getName()\n+                                   + \"' size = \"\n+                                   + currEntry.getSize());\n             }\n \n             entryOffset = 0;\n \n         if (readBuf != null) {\n             int sz = (numToRead > readBuf.length) ? readBuf.length\n-                    : numToRead;\n+                : numToRead;\n \n             System.arraycopy(readBuf, 0, buf, offset, sz);\n \n             if (rec == null) {\n                 // Unexpected EOF!\n                 throw new IOException(\"unexpected EOF with \" + numToRead\n-                        + \" bytes unread\");\n+                                      + \" bytes unread\");\n             }\n \n             int sz = numToRead;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n                 // create a TarEntry for the LongLink, the contents\n                 // of which are the entry's name\n                 TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n-                                                      TarConstants.LF_GNUTYPE_LONGNAME);\n+                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n \n                 longLinkEntry.setSize(entry.getName().length() + 1);\n                 putNextEntry(longLinkEntry);\n                 closeEntry();\n             } else if (longFileMode != LONGFILE_TRUNCATE) {\n                 throw new RuntimeException(\"file name '\" + entry.getName()\n-                                             + \"' is too long ( > \"\n-                                             + TarConstants.NAMELEN + \" bytes)\");\n+                                           + \"' is too long ( > \"\n+                                           + TarConstants.NAMELEN + \" bytes)\");\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n     public int read(byte[] b, int off, int len) throws IOException {\n         return input.read(b, off, len);\n     }\n-    \n+\n     public int read() throws IOException {\n         return input.read();\n     }\n \n-    \n+\n     public static boolean matches( byte[] signature, int length ) {\n         // 4b50 0403 0014 0000\n \n         if (signature[7] != 0x00) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         if (level < Deflater.DEFAULT_COMPRESSION\n             || level > Deflater.BEST_COMPRESSION) {\n             throw new IllegalArgumentException(\n-                \"Invalid compression level: \" + level);\n+                                               \"Invalid compression level: \" + level);\n         }\n         hasCompressionLevelChanged = (this.level != level);\n         this.level = level;\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n import java.io.InputStream;\n \n public abstract class CompressorInputStream extends InputStream {\n-\t// TODO \n+    // TODO \n }\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorOutputStream.java\n import java.io.OutputStream;\n \n public abstract class CompressorOutputStream extends OutputStream {\n-\t// TODO\n+    // TODO\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n                 weight[nNodes] = ((weight[n1] & 0xffffff00)\n                                   + (weight[n2] & 0xffffff00))\n                     | (1 + (((weight[n1] & 0x000000ff)\n-                            > (weight[n2] & 0x000000ff))\n+                             > (weight[n2] & 0x000000ff))\n                             ? (weight[n1] & 0x000000ff)\n                             : (weight[n2] & 0x000000ff)));\n \n         finish();\n         super.close();\n         bsStream.close();\n-        closed = true;    \t\n-    }\n-    \n+        closed = true;\n+    }\n+\n     protected void finish() throws IOException {\n         if (closed) {\n             return;\n         // If the stream was empty we must skip the rest of this method.\n         // See bug#32200.\n         if (last == -1) {\n-\t    return;\n-        }\n-        \n+            return;\n+        }\n+\n         /* sort the block and establish posn of original string */\n         doReversibleTransformation();\n \n                         j = i;\n                         while ((ftab[((runningOrder[j - h]) + 1) << 8]\n                                 - ftab[(runningOrder[j - h]) << 8])\n-                                > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n+                               > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                             runningOrder[j] = runningOrder[j - h];\n                             j = j - h;\n                             if (j <= (h - 1)) {\n       usually small, typically <= 20.\n     */\n     private int[] incs = {1, 4, 13, 40, 121, 364, 1093, 3280,\n-                           9841, 29524, 88573, 265720,\n-                           797161, 2391484};\n+                          9841, 29524, 88573, 265720,\n+                          797161, 2391484};\n \n     private void allocateCompressStructures () {\n         int n = baseBlockSize * blockSize100k;\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n \n public class GzipCompressorInputStream extends CompressorInputStream {\n \n-\tprivate final GZIPInputStream in;\n-\t\n-\tpublic GzipCompressorInputStream(InputStream inputStream) throws IOException {\n-\t\tin = new GZIPInputStream(inputStream);\n-\t}\n+    private final GZIPInputStream in; \n \n-\tpublic int read() throws IOException {\n-\t\treturn in.read();\n-\t}\n+    public GzipCompressorInputStream(InputStream inputStream) throws IOException {\n+        in = new GZIPInputStream(inputStream);\n+    }\n+\n+    public int read() throws IOException {\n+        return in.read();\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n import org.apache.commons.compress.compressors.CompressorOutputStream;\n \n public class GzipCompressorOutputStream extends CompressorOutputStream {\n-\t\n-\tprivate final GZIPOutputStream out;\n-\t\n-\tpublic GzipCompressorOutputStream( final OutputStream outputStream ) throws IOException {\n-\t\tout = new GZIPOutputStream(outputStream);\n-\t}\n \n-\tpublic void write(int b) throws IOException {\n-\t\tout.write(b);\n-\t}\n+    private final GZIPOutputStream out;\n \n-\tpublic void close() throws IOException {\n-\t\tout.close();\n-\t}\n+    public GzipCompressorOutputStream( final OutputStream outputStream ) throws IOException {\n+        out = new GZIPOutputStream(outputStream);\n+    }\n+\n+    public void write(int b) throws IOException {\n+        out.write(b);\n+    }\n+\n+    public void close() throws IOException {\n+        out.close();\n+    }\n \n }", "timestamp": 1234275605, "metainfo": ""}