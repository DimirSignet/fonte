{"sha": "30fce9d42c5675e9cae0db0401181f84a73a293b", "log": "COMPRESS-385, first draft", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n     }\n \n     /**\n+     * Try to detect the type of compressor stream.\n+     *\n+     * @param in input stream\n+     * @return type of compressor stream detected\n+     * @throws CompressorException if no compressor stream type was detected\n+     *                             or if something else went wrong\n+     * @throws IllegalArgumentException if stream is null or does not support mark\n+     *\n+     * @since 1.14\n+     */\n+    public static String detect(final InputStream in) throws CompressorException {\n+        if (in == null) {\n+            throw new IllegalArgumentException(\"Stream must not be null.\");\n+        }\n+\n+        if (!in.markSupported()) {\n+            throw new IllegalArgumentException(\"Mark is not supported.\");\n+        }\n+\n+        final byte[] signature = new byte[12];\n+        in.mark(signature.length);\n+        int signatureLength = -1;\n+        try {\n+            signatureLength = IOUtils.readFully(in, signature);\n+            in.reset();\n+        } catch (IOException e) {\n+            throw new CompressorException(\"Failed while reading signature from InputStream.\", e);\n+        }\n+\n+        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n+            return BZIP2;\n+        }\n+\n+        if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n+            return GZIP;\n+        }\n+\n+        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n+            return PACK200;\n+        }\n+\n+        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n+            return SNAPPY_FRAMED;\n+        }\n+\n+        if (ZCompressorInputStream.matches(signature, signatureLength)) {\n+            return Z;\n+        }\n+\n+        if (DeflateCompressorInputStream.matches(signature, signatureLength)) {\n+            return DEFLATE;\n+        }\n+\n+        if (XZUtils.matches(signature, signatureLength)) {\n+            return XZ;\n+        }\n+\n+        if (LZMAUtils.matches(signature, signatureLength)) {\n+            return LZMA;\n+        }\n+\n+        if (FramedLZ4CompressorInputStream.matches(signature, signatureLength)) {\n+            return LZ4_FRAMED;\n+        }\n+\n+        throw new CompressorException(\"No Compressor found for the stream signature.\");\n+    }\n+    /**\n      * Create an compressor input stream from an input stream, autodetecting the\n      * compressor type from the first few bytes of the stream. The InputStream\n      * must support marks, like BufferedInputStream.\n      * @since 1.1\n      */\n     public CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {\n-        if (in == null) {\n-            throw new IllegalArgumentException(\"Stream must not be null.\");\n-        }\n-\n-        if (!in.markSupported()) {\n-            throw new IllegalArgumentException(\"Mark is not supported.\");\n-        }\n-\n-        final byte[] signature = new byte[12];\n-        in.mark(signature.length);\n-        try {\n-            final int signatureLength = IOUtils.readFully(in, signature);\n-            in.reset();\n-\n-            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n-                return new BZip2CompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n-                return new GzipCompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n-                return new Pack200CompressorInputStream(in);\n-            }\n-\n-            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n-                return new FramedSnappyCompressorInputStream(in);\n-            }\n-\n-            if (ZCompressorInputStream.matches(signature, signatureLength)) {\n-                return new ZCompressorInputStream(in);\n-            }\n-\n-            if (DeflateCompressorInputStream.matches(signature, signatureLength)) {\n-                return new DeflateCompressorInputStream(in);\n-            }\n-\n-            if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {\n-                return new XZCompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {\n-                return new LZMACompressorInputStream(in);\n-            }\n-\n-            if (FramedLZ4CompressorInputStream.matches(signature, signatureLength)) {\n-                return new FramedLZ4CompressorInputStream(in);\n-            }\n-\n-        } catch (final IOException e) {\n-            throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n-        }\n-\n-        throw new CompressorException(\"No Compressor found for the stream signature.\");\n+        return createCompressorInputStream(detect(in), in);\n     }\n \n     /**\n      *            the input stream\n      * @return compressor input stream\n      * @throws CompressorException\n-     *             if the compressor name is not known\n+     *             if the compressor name is not known or not available\n      * @throws IllegalArgumentException\n      *             if the name or input stream is null\n      */\n             }\n \n             if (XZ.equalsIgnoreCase(name)) {\n+                if (! XZUtils.isXZCompressionAvailable()) {\n+                    throw new CompressorException(\"XZ compression is not available.\");\n+                }\n                 return new XZCompressorInputStream(in, actualDecompressConcatenated);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n+                if (! LZMAUtils.isLZMACompressionAvailable()) {\n+                    throw new CompressorException(\"LZMA compression is not available\");\n+                }\n                 return new LZMACompressorInputStream(in);\n             }\n \n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n package org.apache.commons.compress.compressors;\n \n import static org.apache.commons.compress.AbstractTestCase.getFile;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import java.io.BufferedInputStream;\n import java.io.ByteArrayInputStream;\n import java.io.FileInputStream;\n import java.io.IOException;\n-\n-import org.apache.commons.compress.compressors.CompressorException;\n-import org.apache.commons.compress.compressors.CompressorInputStream;\n-import org.apache.commons.compress.compressors.CompressorStreamFactory;\n+import java.io.InputStream;\n+\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n         } catch (final CompressorException e) {\n             // expected\n         }\n+    }\n+\n+    @Test\n+    public void testDetect() throws Exception {\n+        assertEquals(CompressorStreamFactory.BZIP2, detect(\"bla.txt.bz2\"));\n+        assertEquals(CompressorStreamFactory.GZIP, detect(\"bla.tgz\"));\n+        assertEquals(CompressorStreamFactory.PACK200, detect(\"bla.pack\"));\n+        assertEquals(CompressorStreamFactory.XZ, detect(\"bla.tar.xz\"));\n+        assertEquals(CompressorStreamFactory.DEFLATE, detect(\"bla.tar.deflatez\"));\n+\n+        try {\n+            CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n+            fail(\"shouldn't be able to detect empty stream\");\n+        } catch (CompressorException e) {\n+            assertTrue(e.getMessage().contains(\"No Compressor found\"));\n+        }\n+\n+        try {\n+            CompressorStreamFactory.detect(null);\n+            fail(\"shouldn't be able to detect null stream\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Stream must not be null.\", e.getMessage());\n+        }\n+\n+        try {\n+            CompressorStreamFactory.detect(new BufferedInputStream(new BadInputStream()));\n+            fail(\"Expected IOException\");\n+        } catch (CompressorException e) {\n+            assertEquals(\"Failed while reading signature from InputStream.\", e.getMessage());\n+        }\n+\n+\n+    }\n+\n+    private String detect(String testFileName) throws IOException, CompressorException {\n+        String name = null;\n+        try (InputStream is = new BufferedInputStream(\n+                new FileInputStream(getFile(testFileName)))) {\n+            name = CompressorStreamFactory.detect(is);\n+        }\n+        return name;\n     }\n \n     @Test\n                        getFile(resource))));\n     }\n \n+    private static class BadInputStream extends InputStream {\n+        @Override\n+        public int read() throws IOException {\n+            throw new IOException(\"Bad\");\n+        }\n+\n+        @Override\n+        public int read(byte[] bytes, int offset, int length) throws IOException {\n+            throw new IOException(\"Bad\");\n+        }\n+    }\n+\n }", "timestamp": 1492519225, "metainfo": ""}