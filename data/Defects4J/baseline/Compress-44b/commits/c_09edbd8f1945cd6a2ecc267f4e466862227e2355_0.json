{"sha": "09edbd8f1945cd6a2ecc267f4e466862227e2355", "log": "COMPRESS-327 write support for in memory SeekableByteChannel", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n+++ b/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n import java.nio.channels.ClosedChannelException;\n import java.nio.channels.NonWritableChannelException;\n import java.nio.channels.SeekableByteChannel;\n+import java.util.Arrays;\n \n /**\n  * A {@link SeekableByteChannel} implementation that wraps a byte[].\n+ * @since 1.13\n  */\n public class SeekableInMemoryByteChannel implements SeekableByteChannel {\n \n-    private final byte[] data;\n+    private volatile byte[] data;\n     private volatile boolean closed;\n-    private volatile long position, size;\n+    private volatile int position, size;\n \n     public SeekableInMemoryByteChannel(byte[] data) {\n         this.data = data;\n         size = data.length;\n+    }\n+\n+    public SeekableInMemoryByteChannel() {\n+        this(new byte[0]);\n     }\n \n     @Override\n \n     @Override\n     public SeekableByteChannel position(long newPosition) {\n-        position = newPosition;\n+        if (newPosition > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Position cannot exceed \" + Integer.MAX_VALUE);\n+        }\n+        position = (int) newPosition;\n         return this;\n     }\n \n \n     @Override\n     public SeekableByteChannel truncate(long newSize) {\n-        size = newSize;\n+        if (size > newSize) {\n+            size = (int) newSize;\n+        }\n+        if (position > size) {\n+            position = size;\n+        }\n         return this;\n     }\n \n         if (!isOpen()) {\n             throw new ClosedChannelException();\n         }\n-        long pos = position;\n-        long sz = size;\n+        int pos = position;\n+        int sz = size;\n         int wanted = buf.remaining();\n-        long possible = sz - pos;\n+        int possible = sz - pos;\n         if (wanted > possible) {\n-            wanted = (int) possible;\n+            wanted = possible;\n         }\n-        buf.put(data, (int) pos, wanted);\n+        buf.put(data, pos, wanted);\n         position = pos + wanted;\n         return wanted;\n     }\n         return !closed;\n     }\n \n-    // TODO implement writing\n     @Override\n     public int write(ByteBuffer b) throws IOException {\n-        throw new NonWritableChannelException();\n+        if (!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+        int pos = position;\n+        int sz = data.length;\n+        int wanted = b.remaining();\n+        int possibleWithoutResize = sz - pos;\n+        if (wanted > possibleWithoutResize) {\n+            resize(pos + wanted);\n+        }\n+        b.get(data, pos, wanted);\n+        position = pos + wanted;\n+        if (size < position) {\n+            size = position;\n+        }\n+        return wanted;\n     }\n+\n+    /**\n+     * Obtains the array backing this channel.\n+     */\n+    public byte[] array() {\n+        return data;\n+    }\n+\n+    private void resize(int newLength) {\n+        int len = data.length;\n+        if (len <= 0) {\n+            len = 1;\n+        }\n+        while (len < newLength) {\n+            len <<= 1;\n+        }\n+        data = Arrays.copyOf(data, len);\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n import org.apache.commons.compress.archivers.zip.ZipFile; \t\n import org.apache.commons.compress.archivers.zip.ZipMethod;\n import org.apache.commons.compress.utils.IOUtils;\n+import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;\n import org.junit.Assert;\n import org.junit.Test;\n \n             }\n         }\n         is.close();\n+\n+        assertEquals(results.size(), 2);\n+        File result = results.get(0);\n+        assertEquals(file1.length(), result.length());\n+        result = results.get(1);\n+        assertEquals(file2.length(), result.length());\n+    }\n+\n+    /**\n+     * Archives 2 files and unarchives it again. If the file length of result\n+     * and source is the same, it looks like the operations have worked\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testZipArchiveCreationInMemory() throws Exception {\n+        final File file1 = getFile(\"test1.xml\");\n+        final File file2 = getFile(\"test2.xml\");\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        try (ZipArchiveOutputStream os = new ZipArchiveOutputStream(c)) {\n+            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n+            IOUtils.copy(new FileInputStream(file1), os);\n+            os.closeArchiveEntry();\n+\n+            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n+            IOUtils.copy(new FileInputStream(file2), os);\n+            os.closeArchiveEntry();\n+        }\n+\n+        // Unarchive the same\n+        final List<File> results = new ArrayList<>();\n+\n+        try (ArchiveInputStream in = new ArchiveStreamFactory()\n+             .createArchiveInputStream(\"zip\", new ByteArrayInputStream(c.array()))) {\n+\n+            ZipArchiveEntry entry = null;\n+            while((entry = (ZipArchiveEntry)in.getNextEntry()) != null) {\n+                final File outfile = new File(resultDir.getCanonicalPath() + \"/result/\" + entry.getName());\n+                outfile.getParentFile().mkdirs();\n+                try (OutputStream o = new FileOutputStream(outfile)) {\n+                    IOUtils.copy(in, o);\n+                }\n+                results.add(outfile);\n+            }\n+        }\n \n         assertEquals(results.size(), 2);\n         File result = results.get(0);\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n import java.util.Date;\n import java.util.Iterator;\n import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;\n import org.tukaani.xz.LZMA2Options;\n \n public class SevenZOutputFileTest extends AbstractTestCase {\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.DEFLATE));\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.BZIP2));\n         createAndReadBack(output, methods);\n+    }\n+\n+    @Test\n+    public void testStackOfContentCompressionsInMemory() throws Exception {\n+        final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<>();\n+        methods.add(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n+        methods.add(new SevenZMethodConfiguration(SevenZMethod.COPY));\n+        methods.add(new SevenZMethodConfiguration(SevenZMethod.DEFLATE));\n+        methods.add(new SevenZMethodConfiguration(SevenZMethod.BZIP2));\n+        createAndReadBack(new SeekableInMemoryByteChannel(), methods);\n     }\n \n     @Test\n         }\n     }\n \n+    private void createAndReadBack(final SeekableInMemoryByteChannel output, final Iterable<SevenZMethodConfiguration> methods) throws Exception {\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        outArchive.setContentMethods(methods);\n+        try {\n+            addFile(outArchive, 0, true);\n+        } finally {\n+            outArchive.close();\n+        }\n+        try (SevenZFile archive =\n+             new SevenZFile(new SeekableInMemoryByteChannel(output.array()), \"in memory\",\n+                            null)) {\n+            assertEquals(Boolean.TRUE, verifyFile(archive, 0, methods));\n+        }\n+    }\n+\n     private static void assertContentMethodsEquals(final Iterable<? extends SevenZMethodConfiguration> expected,\n                                                    final Iterable<? extends SevenZMethodConfiguration> actual) {\n         assertNotNull(actual);", "timestamp": 1476378357, "metainfo": ""}