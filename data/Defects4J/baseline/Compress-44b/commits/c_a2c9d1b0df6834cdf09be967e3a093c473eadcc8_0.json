{"sha": "a2c9d1b0df6834cdf09be967e3a093c473eadcc8", "log": "sync with trunk (one last time?)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     /**\n      * Static registry of known extra fields.\n      */\n-    private static final Map implementations;\n+    private static final Map<ZipShort, Class<?>> implementations;\n \n     static {\n-        implementations = new HashMap();\n+        implementations = new HashMap<ZipShort, Class<?>>();\n         register(AsiExtraField.class);\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n     }\n \n     /**\n      * the {@link ZipExtraField ZipExtraField interface}.</p>\n      * @param c the class to register\n      */\n-    public static void register(Class c) {\n+    public static void register(Class<?> c) {\n         try {\n             ZipExtraField ze = (ZipExtraField) c.newInstance();\n             implementations.put(ze.getHeaderId(), c);\n      */\n     public static ZipExtraField createExtraField(ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n-        Class c = (Class) implementations.get(headerId);\n+        Class<?> c = implementations.get(headerId);\n         if (c != null) {\n             return (ZipExtraField) c.newInstance();\n         }\n     public static ZipExtraField[] parse(byte[] data, boolean local,\n                                         UnparseableExtraField onUnparseableData)\n         throws ZipException {\n-        List v = new ArrayList();\n+        List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n         int start = 0;\n         LOOP:\n         while (start <= data.length - WORD) {\n         }\n \n         ZipExtraField[] result = new ZipExtraField[v.size()];\n-        return (ZipExtraField[]) v.toArray(result);\n+        return v.toArray(result);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n         return b;\n     }\n \n+    @Override\n     public int hashCode() {\n         return 3 * (7 * (13 * (17 * (encryptionFlag ? 1 : 0)\n                                + (strongEncryptionFlag ? 1 : 0))\n                     + (dataDescriptorFlag ? 1 : 0));\n     }\n \n+    @Override\n     public boolean equals(Object o) {\n         if (!(o instanceof GeneralPurposeBit)) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n      * field.  This list is used to binary search reverse mapping of\n      * unicode characters with a character code greater than 127.\n      */\n-    private final List reverseMapping;\n+    private final List<Simple8BitChar> reverseMapping;\n \n     /**\n      * @param highChars The characters for byte values of 128 to 255\n      */\n     public Simple8BitZipEncoding(char[] highChars) {\n         this.highChars = (char[]) highChars.clone();\n-        List temp = new ArrayList(this.highChars.length);\n+        List temp = new ArrayList<Simple8BitChar>(this.highChars.length);\n \n         byte code = 127;\n \n \n             int i = i0 + (i1 - i0) / 2;\n \n-            Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n+            Simple8BitChar m = this.reverseMapping.get(i);\n \n             if (m.unicode == c) {\n                 return m;\n             return null;\n         }\n \n-        Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n+        Simple8BitChar r = this.reverseMapping.get(i0);\n \n         if (r.unicode != c) {\n             return null;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.util.zip.ZipException;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n \n /**\n  * Holds size and other extended information for entries that use Zip64\n  * @NotThreadSafe\n  */\n public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n-    // TODO: the LFH should probably not contain relativeHeaderOffset\n-    // and diskStart but then ZipArchivePOutputStream won't write it to\n-    // the CD either - need to test interop with other implementations\n-    // to see whether they do have a problem with the extraneous\n-    // information inside the LFH\n-\n-    private static final ZipShort HEADER_ID = new ZipShort(0x0001);\n-\n-    private static final int WORD = 4, DWORD = 8;\n+\n+    static final ZipShort HEADER_ID = new ZipShort(0x0001);\n+\n+    private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n+        \"Zip64 extended information must contain\"\n+        + \" both size values in the local file header.\";\n \n     private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n     private ZipLong diskStart;\n                                               ZipEightByteInteger compressedSize,\n                                               ZipEightByteInteger relativeHeaderOffset,\n                                               ZipLong diskStart) {\n-        if (size == null) {\n-            throw new IllegalArgumentException(\"size must not be null\");\n-        }\n-        if (compressedSize == null) {\n-            throw new IllegalArgumentException(\"compressedSize must not be null\");\n-        }\n         this.size = size;\n         this.compressedSize = compressedSize;\n         this.relativeHeaderOffset = relativeHeaderOffset;\n \n     /** {@inheritDoc} */\n     public ZipShort getLocalFileDataLength() {\n-        return getCentralDirectoryLength();\n+        return new ZipShort(size != null ? 2 * DWORD : 0);\n     }\n \n     /** {@inheritDoc} */\n     public ZipShort getCentralDirectoryLength() {\n-        return new ZipShort(2 * DWORD  // both size fields\n+        return new ZipShort((size != null ? DWORD : 0)\n+                            + (compressedSize != null ? DWORD : 0)\n                             + (relativeHeaderOffset != null ? DWORD : 0)\n                             + (diskStart != null ? WORD : 0));\n     }\n \n     /** {@inheritDoc} */\n     public byte[] getLocalFileDataData() {\n-        return getCentralDirectoryData();\n+        if (size != null || compressedSize != null) {\n+            if (size == null || compressedSize == null) {\n+                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n+            }\n+            byte[] data = new byte[2 * DWORD];\n+            addSizes(data);\n+            return data;\n+        }\n+        return new byte[0];\n     }\n \n     /** {@inheritDoc} */\n     public byte[] getCentralDirectoryData() {\n         byte[] data = new byte[getCentralDirectoryLength().getValue()];\n-        addSizes(data);\n-        int off = 2 * DWORD;\n+        int off = addSizes(data);\n         if (relativeHeaderOffset != null) {\n             System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n             off += DWORD;\n     public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n         throws ZipException {\n         if (length < 2 * DWORD) {\n-            throw new ZipException(\"Zip64 extended information must contain\"\n-                                   + \" both size values in the local file\"\n-                                   + \" header.\");\n+            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n         }\n         size = new ZipEightByteInteger(buffer, offset);\n         offset += DWORD;\n         // can only hope things will get resolved by LFH data later\n         // But there are some cases that can be detected\n         // * all data is there\n+        // * length == 24 -> both sizes and offset\n         // * length % 8 == 4 -> at least we can identify the diskStart field\n         if (length >= 3 * DWORD + WORD) {\n             parseFromLocalFileData(buffer, offset, length);\n+        } else if (length == 3 * DWORD) {\n+            size = new ZipEightByteInteger(buffer, offset);\n+            offset += DWORD;\n+            compressedSize = new ZipEightByteInteger(buffer, offset);\n+            offset += DWORD;\n+            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n         } else if (length % DWORD == WORD) {\n             diskStart = new ZipLong(buffer, offset + length - WORD);\n         }\n     }\n \n     /**\n+     * The uncompressed size stored in this extra field.\n+     */\n+    public void setSize(ZipEightByteInteger size) {\n+        this.size = size;\n+    }\n+\n+    /**\n      * The compressed size stored in this extra field.\n      */\n     public ZipEightByteInteger getCompressedSize() {\n     }\n \n     /**\n+     * The uncompressed size stored in this extra field.\n+     */\n+    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n+        this.compressedSize = compressedSize;\n+    }\n+\n+    /**\n      * The relative header offset stored in this extra field.\n      */\n     public ZipEightByteInteger getRelativeHeaderOffset() {\n     }\n \n     /**\n+     * The relative header offset stored in this extra field.\n+     */\n+    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n+        relativeHeaderOffset = rho;\n+    }\n+\n+    /**\n      * The disk start number stored in this extra field.\n      */\n     public ZipLong getDiskStartNumber() {\n         return diskStart;\n     }\n \n-    private void addSizes(byte[] data) {\n-        System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n-        System.arraycopy(compressedSize.getBytes(), 0, data, DWORD, DWORD);\n+    /**\n+     * The disk start number stored in this extra field.\n+     */\n+    public void setDiskStartNumber(ZipLong ds) {\n+        diskStart = ds;\n+    }\n+\n+    private int addSizes(byte[] data) {\n+        int off = 0;\n+        if (size != null) {\n+            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n+            off += DWORD;\n+        }\n+        if (compressedSize != null) {\n+            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n+            off += DWORD;\n+        }\n+        return off;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     private int method = -1;\n \n+    /**\n+     * The {@link java.util.zip.ZipEntry#setSize} method in the base\n+     * class throws an IllegalArgumentException if the size is bigger\n+     * than 2GB for Java versions < 7.  Need to keep our own size\n+     * information for Zip64 support.\n+     */\n+    private long size = SIZE_UNKNOWN;\n+\n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n-    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n+    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n     private byte[] rawName = null;\n             setExtra();\n         }\n         setMethod(entry.getMethod());\n+        this.size = entry.getSize();\n     }\n \n     /**\n      * Overwrite clone.\n      * @return a cloned copy of this ZipArchiveEntry\n      */\n+    @Override\n     public Object clone() {\n         ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n \n      * @param fields an array of extra fields\n      */\n     public void setExtraFields(ZipExtraField[] fields) {\n-        extraFields = new LinkedHashMap();\n+        extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n         for (int i = 0; i < fields.length; i++) {\n             if (fields[i] instanceof UnparseableExtraFieldData) {\n                 unparseableExtra = (UnparseableExtraFieldData) fields[i];\n                 ? new ZipExtraField[0]\n                 : new ZipExtraField[] { unparseableExtra };\n         }\n-        List result = new ArrayList(extraFields.values());\n+        List<ZipExtraField> result =\n+            new ArrayList<ZipExtraField>(extraFields.values());\n         if (includeUnparseable && unparseableExtra != null) {\n             result.add(unparseableExtra);\n         }\n-        return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);\n+        return result.toArray(new ZipExtraField[0]);\n     }\n \n     /**\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n             if (extraFields == null) {\n-                extraFields = new LinkedHashMap();\n+                extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n             }\n             extraFields.put(ze.getHeaderId(), ze);\n         }\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n             LinkedHashMap copy = extraFields;\n-            extraFields = new LinkedHashMap();\n+            extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n             extraFields.put(ze.getHeaderId(), ze);\n             if (copy != null) {\n                 copy.remove(ze.getHeaderId());\n      */\n     public ZipExtraField getExtraField(ZipShort type) {\n         if (extraFields != null) {\n-            return (ZipExtraField) extraFields.get(type);\n+            return extraFields.get(type);\n         }\n         return null;\n     }\n      * @throws RuntimeException if the bytes cannot be parsed\n      * @throws RuntimeException on error\n      */\n+    @Override\n     public void setExtra(byte[] extra) throws RuntimeException {\n         try {\n             ZipExtraField[] local =\n                                       ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(local, true);\n         } catch (ZipException e) {\n-            // actually this is not be possible as of Commons Compress 1.1\n+            // actually this is not possible as of Commons Compress 1.1\n             throw new RuntimeException(\"Error parsing extra fields for entry: \"\n                                        + getName() + \" - \" + e.getMessage(), e);\n         }\n      * Get the name of the entry.\n      * @return the entry name\n      */\n+    @Override\n     public String getName() {\n         return name == null ? super.getName() : name;\n     }\n      */\n     protected void setName(String name) {\n         this.name = name;\n+    }\n+\n+    /**\n+     * Gets the uncompressed size of the entry data.\n+     * @return the entry size\n+     */\n+    @Override\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Sets the uncompressed size of the entry data.\n+     * @param size the uncompressed size in bytes\n+     * @exception IllegalArgumentException if the specified size is less\n+     *            than 0\n+     */\n+    @Override\n+    public void setSize(long size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"invalid entry size\");\n+        }\n+        this.size = size;\n     }\n \n     /**\n      * This uses the name as the hashcode.\n      * @return a hashcode.\n      */\n+    @Override\n     public int hashCode() {\n         // this method has severe consequences on performance. We cannot rely\n         // on the super.hashCode() method since super.getName() always return\n     /* (non-Javadoc)\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n+    @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+\n /**\n  * Implements an input stream that can read Zip archives.\n  * <p>\n  */\n public class ZipArchiveInputStream extends ArchiveInputStream {\n \n-    private static final int SHORT = 2;\n-    private static final int WORD = 4;\n-\n     /**\n      * The zip encoding to use for filenames and the file comment.\n      */\n     private long readBytesOfEntry = 0, bytesReadFromStream = 0;\n     private int lengthOfLastRead = 0;\n     private boolean hasDataDescriptor = false;\n+    private boolean usesZip64 = false;\n     private ByteArrayInputStream lastStoredEntry = null;\n \n     private boolean allowStoredEntriesWithDataDescriptor = false;\n         current.setTime(time);\n         off += WORD;\n \n+        ZipLong size = null, cSize = null;\n         if (!hasDataDescriptor) {\n             current.setCrc(ZipLong.getValue(lfh, off));\n             off += WORD;\n \n-            current.setCompressedSize(ZipLong.getValue(lfh, off));\n+            cSize = new ZipLong(lfh, off);\n             off += WORD;\n \n-            current.setSize(ZipLong.getValue(lfh, off));\n+            size = new ZipLong(lfh, off);\n             off += WORD;\n         } else {\n             off += 3 * WORD;\n         if (!hasUTF8Flag && useUnicodeExtraFields) {\n             ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n         }\n+\n+        Zip64ExtendedInformationExtraField z64 =  \n+            (Zip64ExtendedInformationExtraField)\n+            current.getExtraField(Zip64ExtendedInformationExtraField\n+                                  .HEADER_ID);\n+        usesZip64 = z64 != null;\n+        if (!hasDataDescriptor) {\n+            if (usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\n+                              || size.equals(ZipLong.ZIP64_MAGIC))\n+                ) {\n+                current.setCompressedSize(z64.getCompressedSize()\n+                                          .getLongValue());\n+                current.setSize(z64.getSize().getLongValue());\n+            } else {\n+                current.setCompressedSize(cSize.getValue());\n+                current.setSize(size.getValue());\n+            }\n+        }\n         return current;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextZipEntry();\n     }\n      * compression method that hasn't been implemented yet.</p>\n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public boolean canReadEntryData(ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n         return false;\n     }\n \n+    @Override\n     public int read(byte[] buffer, int start, int length) throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         throw new ArrayIndexOutOfBoundsException();\n     }\n \n+    @Override\n     public void close() throws IOException {\n         if (!closed) {\n             closed = true;\n      * @throws IOException - if an I/O error occurs.\n      * @throws IllegalArgumentException - if value is negative.\n      */\n+    @Override\n     public long skip(long value) throws IOException {\n         if (value >= 0) {\n             long skipped = 0;\n \n             long inB;\n             if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n-                inB = ZipUtil.adjustToLong(inf.getTotalIn());\n+                inB = inf.getBytesRead();\n             } else {\n                 inB = readBytesOfEntry;\n             }\n             val = new ZipLong(b);\n         }\n         current.setCrc(val.getValue());\n-        readFully(b);\n-        current.setCompressedSize(new ZipLong(b).getValue());\n-        readFully(b);\n-        current.setSize(new ZipLong(b).getValue());\n+        if (!usesZip64) {\n+            readFully(b);\n+            current.setCompressedSize(ZipLong.getValue(b));\n+            readFully(b);\n+            current.setSize(ZipLong.getValue(b));\n+        } else {\n+            byte[] b8 = new byte[DWORD];\n+            readFully(b8);\n+            current.setCompressedSize(ZipEightByteInteger.getLongValue(b8));\n+            readFully(b8);\n+            current.setSize(ZipEightByteInteger.getLongValue(b8));\n+        }\n     }\n \n     /**\n         int off = 0;\n         boolean done = false;\n \n+        // length of DD without signature\n+        int ddLen = usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n+\n         while (!done) {\n             int r = in.read(buf, off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                     if ((buf[i + 2] == LFH[2] && buf[i + 3] == LFH[3])\n                         || (buf[i] == CFH[2] && buf[i + 3] == CFH[3])) {\n                         // found a LFH or CFH:\n-                        readTooMuch = off + r - i - 12 /* dd without signature */;\n+                        readTooMuch = off + r - i - ddLen;\n                         done = true;\n                     }\n                     else if (buf[i + 2] == DD[2] && buf[i + 3] == DD[3]) {\n             }\n             if (!done) {\n                 // worst case we've read a data descriptor without a\n-                // signature (12 bytes) plus the first three bytes of\n+                // signature (up to 20 bytes) plus the first three bytes of\n                 // a LFH or CFH signature\n-                // save the last 15 bytes in the buffer, cache\n+                // save the last ddLen + 3 bytes in the buffer, cache\n                 // anything in front of that, read on\n-                if (off + r > 15) {\n-                    bos.write(buf, 0, off + r - 15);\n-                    System.arraycopy(buf, off + r - 15, buf, 0, 15);\n-                    off = 15;\n+                if (off + r > ddLen + 3) {\n+                    bos.write(buf, 0, off + r - ddLen - 3);\n+                    System.arraycopy(buf, off + r - ddLen - 3, buf, 0,\n+                                     ddLen + 3);\n+                    off = ddLen + 3;\n                 } else {\n                     off += r;\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DEFLATE_MIN_VERSION;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION;\n \n /**\n  * Reimplementation of {@link java.util.zip.ZipOutputStream\n  */\n public class ZipArchiveOutputStream extends ArchiveOutputStream {\n \n-    static final int BYTE_MASK = 0xFF;\n-    private static final int SHORT = 2;\n-    private static final int WORD = 4;\n     static final int BUFFER_SIZE = 512;\n \n     /** indicates if this archive is finished. protected for use in Jar implementation */\n     /**\n      * List of ZipArchiveEntries written so far.\n      */\n-    private final List entries = new LinkedList();\n+    private final List<ZipArchiveEntry> entries =\n+        new LinkedList<ZipArchiveEntry>();\n \n     /**\n      * CRC instance to avoid parsing DEFLATED data twice.\n     private long cdLength = 0;\n \n     /**\n+     * Number of bytes read for the current entry (can't rely on\n+     * Deflater#getBytesRead) when using DEFLATED.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private long bytesRead = 0;\n+\n+    /**\n      * Helper, a 0 as ZipShort.\n      */\n     private static final byte[] ZERO = {0, 0};\n     /**\n      * Holds the offsets of the LFH starts for each entry.\n      */\n-    private final Map offsets = new HashMap();\n+    private final Map<ZipArchiveEntry, Long> offsets =\n+        new HashMap<ZipArchiveEntry, Long>();\n \n     /**\n      * The encoding to use for filenames and the file comment.\n      * whether to create UnicodePathExtraField-s for each entry.\n      */\n     private UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\n+\n+    /**\n+     * Whether anything inside this archive has used a ZIP64 feature.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean hasUsedZip64 = false;\n \n     /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void finish() throws IOException {\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n \n         cdOffset = written;\n-        for (Iterator i = entries.iterator(); i.hasNext(); ) {\n-            writeCentralFileHeader((ZipArchiveEntry) i.next());\n+        for (ZipArchiveEntry ze : entries) {\n+            writeCentralFileHeader(ze);\n         }\n         cdLength = written - cdOffset;\n+        writeZip64CentralDirectory();\n         writeCentralDirectoryEnd();\n         offsets.clear();\n         entries.clear();\n      * Writes all necessary data for this entry.\n      * @throws IOException on error\n      */\n+    @Override\n     public void closeArchiveEntry() throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n                 deflate();\n             }\n \n-            entry.setSize(ZipUtil.adjustToLong(def.getTotalIn()));\n-            entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut()));\n+            /* It turns out def.getBytesRead() returns wrong values if\n+             * the size exceeds 4 GB - no idea whether one can trust\n+             * def.getBytesWritten()\n+            entry.setSize(def.getBytesRead());\n+            */\n+            entry.setSize(bytesRead);\n+            entry.setCompressedSize(def.getBytesWritten());\n             entry.setCrc(realCrc);\n \n             def.reset();\n \n             raf.seek(localDataStart);\n             writeOut(ZipLong.getBytes(entry.getCrc()));\n-            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n-            writeOut(ZipLong.getBytes(entry.getSize()));\n+            if (!hasZip64Extra(entry)) {\n+                writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+                writeOut(ZipLong.getBytes(entry.getSize()));\n+            } else {\n+                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+\n+                // seek to ZIP64 extra, skip header and size information\n+                raf.seek(localDataStart + 3 * WORD + 2 * SHORT\n+                         + getName(entry).limit() + 2 * SHORT);\n+                // inside the ZIP64 extra uncompressed size comes\n+                // first, unlike the LFH, CD or data descriptor\n+                writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n+                writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n+            }\n             raf.seek(save);\n         }\n \n         writeDataDescriptor(entry);\n         entry = null;\n+        bytesRead = 0;\n     }\n \n     /**\n      * {@inheritDoc} \n      * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n      */\n+    @Override\n     public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n \n         // Size/CRC not required if RandomAccessFile is used\n         if (entry.getMethod() == STORED && raf == null) {\n-            if (entry.getSize() == -1) {\n+            if (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                 throw new ZipException(\"uncompressed size is required for\"\n                                        + \" STORED method when not writing to a\"\n                                        + \" file\");\n                                        + \" method when not writing to a file\");\n             }\n             entry.setCompressedSize(entry.getSize());\n+        }\n+\n+        // add a ZIP64 extended information extra field if we already\n+        // know it is going to be needed\n+        if (entry.getSize() >= ZIP64_MAGIC\n+            || entry.getCompressedSize() >= ZIP64_MAGIC) {\n+\n+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry);\n+            if (entry.getMethod() == STORED) {\n+                ZipEightByteInteger size =\n+                    new ZipEightByteInteger(entry.getSize());\n+                z64.setSize(size);\n+                z64.setCompressedSize(size);\n+            } else {\n+                // just a placeholder, real data will be in data\n+                // descriptor or inserted later via RandomAccessFile\n+                z64.setSize(ZipEightByteInteger.ZERO);\n+                z64.setCompressedSize(ZipEightByteInteger.ZERO);\n+            }\n+            entry.setExtra();\n         }\n \n         if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n      * compression method that hasn't been implemented yet.</p>\n      * @since Apache Commons Compress 1.1\n      */\n+    @Override\n     public boolean canWriteEntryData(ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             return ZipUtil.canHandleEntryData((ZipArchiveEntry) ae);\n      * @param length the number of bytes to write\n      * @throws IOException on error\n      */\n+    @Override\n     public void write(byte[] b, int offset, int length) throws IOException {\n         ZipUtil.checkRequestedFeatures(entry);\n         if (entry.getMethod() == DEFLATED) {\n             if (length > 0 && !def.finished()) {\n+                bytesRead += length;\n                 if (length <= DEFLATER_BLOCK_SIZE) {\n                     def.setInput(b, offset, length);\n                     deflateUntilInputIsNeeded();\n      *\n      * @exception  IOException  if an I/O error occurs.\n      */\n+    @Override\n     public void close() throws IOException {\n         if (!finished) {\n             finish();\n      *\n      * @exception  IOException  if an I/O error occurs.\n      */\n+    @Override\n     public void flush() throws IOException {\n         if (out != null) {\n             out.flush();\n      * end of central dir signature\n      */\n     static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n+    /**\n+     * ZIP64 end of central dir signature\n+     */\n+    static final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\n+    /**\n+     * ZIP64 end of central dir locator signature\n+     */\n+    static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n \n     /**\n      * Writes next block of compressed data to the output stream.\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n         boolean encodable = zipEncoding.canEncode(ze.getName());\n-\n-        final ZipEncoding entryEncoding;\n-\n-        if (!encodable && fallbackToUTF8) {\n-            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n-        } else {\n-            entryEncoding = zipEncoding;\n-        }\n-\n-        ByteBuffer name = entryEncoding.encode(ze.getName());\n+        ByteBuffer name = getName(ze);\n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n \n             String comm = ze.getComment();\n             if (comm != null && !\"\".equals(comm)) {\n \n-                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n+                boolean commentEncodable = zipEncoding.canEncode(comm);\n \n                 if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                     || !commentEncodable) {\n-                    ByteBuffer commentB = entryEncoding.encode(comm);\n+                    ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n                     ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                   commentB.array(),\n                                                                   commentB.arrayOffset(),\n             }\n         }\n \n-        offsets.put(ze, ZipLong.getBytes(written));\n+        offsets.put(ze, Long.valueOf(written));\n \n         writeOut(LFH_SIG);\n         written += WORD;\n \n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n-                                                         && fallbackToUTF8);\n+                                                         && fallbackToUTF8,\n+                                                         hasZip64Extra(ze));\n         written += WORD;\n \n         // compression method\n             writeOut(LZERO);\n         } else {\n             writeOut(ZipLong.getBytes(ze.getCrc()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n+            byte[] size = ZipLong.getBytes(Math.min(ze.getSize(), ZIP64_MAGIC));\n+            writeOut(size);\n+            writeOut(size);\n         }\n         // CheckStyle:MagicNumber OFF\n         written += 12;\n             return;\n         }\n         writeOut(DD_SIG);\n-        writeOut(ZipLong.getBytes(entry.getCrc()));\n-        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n-        writeOut(ZipLong.getBytes(entry.getSize()));\n-        // CheckStyle:MagicNumber OFF\n-        written += 16;\n-        // CheckStyle:MagicNumber ON\n+        writeOut(ZipLong.getBytes(ze.getCrc()));\n+        int sizeFieldSize = WORD;\n+        if (!hasZip64Extra(ze)) {\n+            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+        } else {\n+            sizeFieldSize = DWORD;\n+            writeOut(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipEightByteInteger.getBytes(ze.getSize()));\n+        }\n+        written += 2 * WORD + 2 * sizeFieldSize;\n     }\n \n     /**\n         writeOut(CFH_SIG);\n         written += WORD;\n \n+        final long lfhOffset = offsets.get(ze).longValue();\n+        final boolean needsZip64Extra = ze.getCompressedSize() >= ZIP64_MAGIC\n+            || ze.getSize() >= ZIP64_MAGIC\n+            || lfhOffset >= ZIP64_MAGIC;\n+\n+        if (needsZip64Extra) {\n+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n+            if (ze.getCompressedSize() >= ZIP64_MAGIC\n+                || ze.getSize() >= ZIP64_MAGIC) {\n+                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            } else {\n+                // reset value that may have been set for LFH\n+                z64.setCompressedSize(null);\n+                z64.setSize(null);\n+            }\n+            if (lfhOffset >= ZIP64_MAGIC) {\n+                z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n+            }\n+            ze.setExtra();\n+        }\n+\n         // version made by\n         // CheckStyle:MagicNumber OFF\n-        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n+        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n+                                   (!hasUsedZip64 ? DEFLATE_MIN_VERSION\n+                                                  : ZIP64_MIN_VERSION)));\n         written += SHORT;\n \n         final int zipMethod = ze.getMethod();\n         final boolean encodable = zipEncoding.canEncode(ze.getName());\n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n-                                                         && fallbackToUTF8);\n+                                                         && fallbackToUTF8,\n+                                                         needsZip64Extra);\n         written += WORD;\n \n         // compression method\n         // compressed length\n         // uncompressed length\n         writeOut(ZipLong.getBytes(ze.getCrc()));\n-        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n-        writeOut(ZipLong.getBytes(ze.getSize()));\n+        if (ze.getCompressedSize() >= ZIP64_MAGIC\n+            || ze.getSize() >= ZIP64_MAGIC) {\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+        } else {\n+            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+        }\n         // CheckStyle:MagicNumber OFF\n         written += 12;\n         // CheckStyle:MagicNumber ON\n \n-        // file name length\n-        final ZipEncoding entryEncoding;\n-\n-        if (!encodable && fallbackToUTF8) {\n-            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n-        } else {\n-            entryEncoding = zipEncoding;\n-        }\n-\n-        ByteBuffer name = entryEncoding.encode(ze.getName());\n+        ByteBuffer name = getName(ze);\n \n         writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n             comm = \"\";\n         }\n \n-        ByteBuffer commentB = entryEncoding.encode(comm);\n+        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n \n         writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n         written += WORD;\n \n         // relative offset of LFH\n-        writeOut((byte[]) offsets.get(ze));\n+        writeOut(ZipLong.getBytes(Math.min(lfhOffset, ZIP64_MAGIC)));\n         written += WORD;\n \n         // file name\n         writeOut(ZERO);\n \n         // number of entries\n-        byte[] num = ZipShort.getBytes(entries.size());\n+        byte[] num = ZipShort.getBytes(Math.min(entries.size(),\n+                                                ZIP64_MAGIC_SHORT));\n         writeOut(num);\n         writeOut(num);\n \n         // length and location of CD\n-        writeOut(ZipLong.getBytes(cdLength));\n-        writeOut(ZipLong.getBytes(cdOffset));\n+        writeOut(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\n+        writeOut(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n \n         // ZIP file comment\n         ByteBuffer data = this.zipEncoding.encode(comment);\n         writeOut(ZipShort.getBytes(data.limit()));\n         writeOut(data.array(), data.arrayOffset(), data.limit());\n+    }\n+\n+    private static final byte[] ONE = ZipLong.getBytes(1L);\n+\n+    /**\n+     * Writes the &quot;ZIP64 End of central dir record&quot; and\n+     * &quot;ZIP64 End of central dir locator&quot;.\n+     * @throws IOException on error\n+     * @since Apache Commons Compress 1.3\n+     */\n+    protected void writeZip64CentralDirectory() throws IOException {\n+        if (!hasUsedZip64) {\n+            if (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n+                || entries.size() >= ZIP64_MAGIC_SHORT) {\n+                // actually \"will use\"\n+                hasUsedZip64 = true;\n+            }\n+        }\n+\n+        if (!hasUsedZip64) {\n+            return;\n+        }\n+\n+        long offset = written;\n+\n+        writeOut(ZIP64_EOCD_SIG);\n+        // size, we don't have any variable length as we don't support\n+        // the extensible data sector, yet\n+        writeOut(ZipEightByteInteger\n+                 .getBytes(SHORT   /* version made by */\n+                           + SHORT /* version needed to extract */\n+                           + WORD  /* disk number */\n+                           + WORD  /* disk with central directory */\n+                           + DWORD /* number of entries in CD on this disk */\n+                           + DWORD /* total number of entries */\n+                           + DWORD /* size of CD */\n+                           + DWORD /* offset of CD */\n+                           ));\n+\n+        // version made by and version needed to extract\n+        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n+        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n+\n+        // disk numbers - four bytes this time\n+        writeOut(LZERO);\n+        writeOut(LZERO);\n+\n+        // number of entries\n+        byte[] num = ZipEightByteInteger.getBytes(entries.size());\n+        writeOut(num);\n+        writeOut(num);\n+\n+        // length and location of CD\n+        writeOut(ZipEightByteInteger.getBytes(cdLength));\n+        writeOut(ZipEightByteInteger.getBytes(cdOffset));\n+\n+        // no \"zip64 extensible data sector\" for now\n+\n+        // and now the \"ZIP64 end of central directory locator\"\n+        writeOut(ZIP64_EOCD_LOC_SIG);\n+\n+        // disk number holding the ZIP64 EOCD record\n+        writeOut(LZERO);\n+        // relative offset of ZIP64 EOCD record\n+        writeOut(ZipEightByteInteger.getBytes(offset));\n+        // total number of disks\n+        writeOut(ONE);\n     }\n \n     /**\n     private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n                                                                   zipMethod,\n                                                                   final boolean\n-                                                                  utfFallback)\n+                                                                  utfFallback,\n+                                                                  final boolean\n+                                                                  zip64)\n         throws IOException {\n \n         // CheckStyle:MagicNumber OFF\n         if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n-            versionNeededToExtract =  20;\n+            versionNeededToExtract = DEFLATE_MIN_VERSION;\n             b.useDataDescriptor(true);\n+        }\n+        if (zip64) {\n+            versionNeededToExtract = ZIP64_MIN_VERSION;\n         }\n         // CheckStyle:MagicNumber ON\n \n      *\n      * <p>Must not be used if the stream has already been closed.</p>\n      */\n+    @Override\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n             throws IOException {\n         if (finished) {\n         }\n         return new ZipArchiveEntry(inputFile, entryName);\n     }\n+\n+    /**\n+     * Get the existing ZIP64 extended information extra field or\n+     * create a new one and add it to the entry.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private Zip64ExtendedInformationExtraField\n+        getZip64Extra(ZipArchiveEntry ze) {\n+        hasUsedZip64 = true;\n+        Zip64ExtendedInformationExtraField z64 =\n+            (Zip64ExtendedInformationExtraField)\n+            ze.getExtraField(Zip64ExtendedInformationExtraField\n+                             .HEADER_ID);\n+        if (z64 == null) {\n+            /*\n+            System.err.println(\"Adding z64 for \" + ze.getName()\n+                               + \", method: \" + ze.getMethod()\n+                               + \" (\" + (ze.getMethod() == STORED) + \")\"\n+                               + \", raf: \" + (raf != null));\n+            */\n+            z64 = new Zip64ExtendedInformationExtraField();\n+        }\n+\n+        // even if the field is there already, make sure it is the first one\n+        ze.addAsFirstExtraField(z64);\n+\n+        return z64;\n+    }\n+\n+    /**\n+     * Is there a ZIP64 extended information extra field for the\n+     * entry?\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean hasZip64Extra(ZipArchiveEntry ze) {\n+        return ze.getExtraField(Zip64ExtendedInformationExtraField\n+                                .HEADER_ID)\n+            != null;\n+    }\n+\n+    private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {\n+        boolean encodable = zipEncoding.canEncode(ze.getName());\n+        return !encodable && fallbackToUTF8\n+            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+    }\n+\n+    private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n+        return getEntryEncoding(ze).encode(ze.getName());\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Various constants used throughout the package.\n+ *\n+ * @since Apache Commons Compress 1.3\n+ */\n+final class ZipConstants {\n+    private ZipConstants() { }\n+\n+    /** Masks last eight bits */\n+    static final int BYTE_MASK = 0xFF;\n+\n+    /** length of a ZipShort in bytes */\n+    static final int SHORT = 2;\n+\n+    /** length of a ZipLong in bytes */\n+    static final int WORD = 4;\n+\n+    /** length of a ZipEightByteInteger in bytes */\n+    static final int DWORD = 8;\n+\n+    /** ZIP specification version that introduced DEFLATE method */\n+    static final int DEFLATE_MIN_VERSION = 20;\n+\n+    /** ZIP specification version that introduced ZIP64 */\n+    static final int ZIP64_MIN_VERSION = 45;\n+\n+    /**\n+     * Value stored in two-byte size and similar fields if ZIP64\n+     * extensions are used.\n+     */\n+    static final int ZIP64_MAGIC_SHORT = 0xFFFF;\n+\n+    /**\n+     * Value stored in four-byte size and similar fields if ZIP64\n+     * extensions are used.\n+     */\n+    static final long ZIP64_MAGIC = 0xFFFFFFFFL;\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n \n import java.math.BigInteger;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+\n /**\n  * Utility class that represents an eight byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  */\n public final class ZipEightByteInteger {\n \n-    private static final int BYTE_MASK = 0xFF;\n-\n     private static final int BYTE_1 = 1;\n     private static final int BYTE_1_MASK = 0xFF00;\n     private static final int BYTE_1_SHIFT = 8;\n     private static final byte LEFTMOST_BIT = (byte) 0x80;\n \n     private final BigInteger value;\n+\n+    public static ZipEightByteInteger ZERO = new ZipEightByteInteger(0);\n \n     /**\n      * Create instance from a number.\n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipEightByteInteger)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the hashCode of the value stored in the ZipEightByteInteger\n      */\n+    @Override\n     public int hashCode() {\n         return value.hashCode();\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipEightByteInteger value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n         }\n     }\n \n-    private static final Map simpleEncodings;\n+    private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n \n     static {\n-        simpleEncodings = new HashMap();\n+        simpleEncodings = new HashMap<String, SimpleEncodingHolder>();\n \n         char[] cp437_high_chars =\n             new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n             return new FallbackZipEncoding();\n         }\n \n-        SimpleEncodingHolder h =\n-            (SimpleEncodingHolder) simpleEncodings.get(name);\n+        SimpleEncodingHolder h = simpleEncodings.get(name);\n \n         if (h!=null) {\n             return h.getEncoding();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+\n /**\n  * Utility class that represents a four byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  */\n public final class ZipLong implements Cloneable {\n \n-    private static final int WORD = 4;\n     //private static final int BYTE_BIT_SIZE = 8;\n-    private static final int BYTE_MASK = 0xFF;\n \n     private static final int BYTE_1 = 1;\n     private static final int BYTE_1_MASK = 0xFF00;\n      * @since Apache Commons Compress 1.1\n      */\n     public static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n+\n+    /**\n+     * Value stored in size and similar fields if ZIP64 extensions are\n+     * used.\n+     * @since Apache Commons Compress 1.3\n+     */\n+    static final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n \n     /**\n      * Create instance from a number.\n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipLong)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipLong\n      */\n+    @Override\n     public int hashCode() {\n         return (int) value;\n     }\n \n+    @Override\n     public Object clone() {\n         try {\n             return super.clone();\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipLong value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+\n /**\n  * Utility class that represents a two byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n  * @Immutable\n  */\n public final class ZipShort implements Cloneable {\n-    private static final int BYTE_MASK = 0xFF;\n     private static final int BYTE_1_MASK = 0xFF00;\n     private static final int BYTE_1_SHIFT = 8;\n \n      * @param o an object to compare\n      * @return true if the objects are equal\n      */\n+    @Override\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipShort)) {\n             return false;\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipShort\n      */\n+    @Override\n     public int hashCode() {\n         return value;\n     }\n \n+    @Override\n     public Object clone() {\n         try {\n             return super.clone();\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"ZipShort value: \" + value;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n     /**\n      * Assumes a negative integer really is a positive integer that\n      * has wrapped around and re-creates the original value.\n+     *\n+     * <p>This methods is no longer used as of Apache Commons Compress\n+     * 1.3</p>\n+     *\n      * @param i the value to treat as unsigned int.\n      * @return the unsigned int as a long.\n      */\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n         assertEquals(DISK, f.getDiskStartNumber());\n     }\n \n+    public void testReadCDSizesAndOffset() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[24];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n+        f.parseFromCentralDirectoryData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertEquals(OFF, f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+    }\n+\n     public void testReadCDSomethingAndDisk() throws ZipException {\n         Zip64ExtendedInformationExtraField f =\n             new Zip64ExtendedInformationExtraField();\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Random;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assume.assumeNotNull;\n+import static org.junit.Assume.assumeTrue;\n+\n+public class Zip64SupportTest {\n+\n+    private static final long FIVE_BILLION = 5000000000l;\n+    private static final int ONE_HUNDRED_THOUSAND = 100000;\n+\n+    @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n+        read5GBOfZerosImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n+    }\n+\n+    @Test public void read100KFilesUsingInputStream() throws Throwable {\n+        FileInputStream fin = new FileInputStream(get100KFileFile());\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(fin);\n+            int files = 0;\n+            ZipArchiveEntry zae = null;\n+            while ((zae = zin.getNextZipEntry()) != null) {\n+                if (!zae.isDirectory()) {\n+                    files++;\n+                    assertEquals(0, zae.getSize());\n+                }\n+            }\n+            assertEquals(ONE_HUNDRED_THOUSAND, files);\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+            fin.close();\n+        }\n+    }\n+\n+    private static final ZipOutputTest write100KFiles =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n+                    ZipArchiveEntry zae =\n+                        new ZipArchiveEntry(String.valueOf(i));\n+                    zae.setSize(0);\n+                    zos.putArchiveEntry(zae);\n+                    zos.closeArchiveEntry();\n+                }\n+                zos.close();\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = a.length();\n+\n+                    // validate \"end of central directory\" is at\n+                    // the end of the file and contains the magic\n+                    // value 0xFFFF as \"number of entries\".\n+                    a.seek(end\n+                           - 22 /* length of EOCD without file comment */);\n+                    byte[] eocd = new byte[12];\n+                    a.readFully(eocd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 5, 6,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // entries\n+                            (byte) 0xff, (byte) 0xff,\n+                            (byte) 0xff, (byte) 0xff,\n+                        }, eocd); \n+\n+                    // validate \"Zip64 end of central directory\n+                    // locator\" is right in front of the EOCD and\n+                    // the location of the \"Zip64 end of central\n+                    // directory record\" seems correct\n+                    long expectedZ64EocdOffset = end - 22 /* eocd.length */\n+                        - 20 /* z64 eocd locator.length */\n+                        - 56 /* z64 eocd without extensible data sector */;\n+                    byte[] loc =\n+                        ZipEightByteInteger.getBytes(expectedZ64EocdOffset);\n+                    a.seek(end - 22 - 20);\n+                    byte[] z64EocdLoc = new byte[20];\n+                    a.readFully(z64EocdLoc);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 7,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // location of Zip64 EOCD,\n+                            loc[0], loc[1], loc[2], loc[3],\n+                            loc[4], loc[5], loc[6], loc[7],\n+                            // total number of disks\n+                            1, 0, 0, 0,\n+                        }, z64EocdLoc);\n+\n+                    // validate \"Zip64 end of central directory\n+                    // record\" is where it is supposed to be, the\n+                    // known values are fine and read the location\n+                    // of the central directory from it\n+                    a.seek(expectedZ64EocdOffset);\n+                    byte[] z64EocdStart = new byte[40];\n+                    a.readFully(z64EocdStart);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 6,\n+                            // size of z64 EOCD\n+                            44, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // number of entries 100k = 0x186A0\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                        }, z64EocdStart);\n+                    a.seek(expectedZ64EocdOffset + 48 /* skip size */);\n+                    byte[] cdOffset = new byte[8];\n+                    a.readFully(cdOffset);\n+                    long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n+\n+                    // finally verify there really is a central\n+                    // directory entry where the Zip64 EOCD claims\n+                    a.seek(cdLoc);\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+\n+    @Test public void write100KFilesFile() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesFile\", write100KFiles, true);\n+    }\n+\n+    @Test public void write100KFilesStream() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesStream\", write100KFiles, false);\n+    }\n+\n+    /*\n+     * Individual sizes don't require ZIP64 but the offset of the\n+     * third entry is bigger than 0xFFFFFFFF so a ZIP64 extended\n+     * information is needed inside the central directory.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */\n+    private static final ZipOutputTest write3EntriesCreatingBigArchive =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[1000 * 1000];\n+                ZipArchiveEntry zae = null;\n+                for (int i = 0; i < 2; i++) {\n+                    zae = new ZipArchiveEntry(String.valueOf(i));\n+                    zae.setSize(FIVE_BILLION / 2);\n+                    zae.setMethod(ZipArchiveEntry.STORED);\n+                    zae.setCrc(0x8a408f16L);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0; j < FIVE_BILLION / 2 / 1000 / 1000;\n+                         j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                }\n+                zae = new ZipArchiveEntry(String.valueOf(2));\n+                zae.setSize(0);\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zae.setCrc(0);\n+                zos.putArchiveEntry(zae);\n+                zos.write(new byte[0]);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+                    // skip first two entries\n+                    a.skipBytes(2 * 47 /* CD entry of file with\n+                                          file name length 1 and no\n+                                          extra data */);\n+\n+                    // grab third entry, verify offset is\n+                    // 0xFFFFFFFF and it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp, CRC, compressed size\n+                    a.skipBytes(12);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            0, 0, 0, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            12, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            // file name\n+                            (byte) '2'\n+                        }, rest);\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size\n+                            8, 0\n+                        }, extra);\n+\n+                    // read offset of LFH\n+                    byte[] offset = new byte[8];\n+                    a.readFully(offset);\n+                    // verify there is a LFH where the CD claims it\n+                    a.seek(ZipEightByteInteger.getLongValue(offset));\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+\n+    @Ignore\n+    @Test public void write3EntriesCreatingBigArchiveFile() throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveFile\",\n+                             write3EntriesCreatingBigArchive,\n+                             true);\n+    }\n+\n+    @Ignore\n+    @Test public void write3EntriesCreatingBigArchiveStream() throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\",\n+                             write3EntriesCreatingBigArchive,\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written without\n+     * compression.\n+     *\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */\n+    private static ZipOutputTest writeBigStoredEntry(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[1000 * 1000];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(FIVE_BILLION);\n+                    zae.setCrc(0x5c316f50L);\n+                }\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zos.putArchiveEntry(zae);\n+                for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                    zos.write(buf);\n+                }\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    // grab first entry, verify sizes are 0xFFFFFFFF\n+                    // and it has a ZIP64 extended information extra\n+                    // field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    byte[] extra = new byte[20];\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                        }, extra);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // compressed size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    /*\n+     * No Compression + Stream => sizes must be known before data is\n+     * written.\n+     */\n+    @Ignore\n+    @Test public void writeBigStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStream\",\n+                             writeBigStoredEntry(true),\n+                             false);\n+    }\n+\n+    @Ignore\n+    @Test public void writeBigStoredEntryKnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFile\",\n+                             writeBigStoredEntry(true),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH and ZIP64\n+     * entry, real values are inside the data descriptor.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    @Ignore\n+    @Test public void writeBigDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     byte[] buf = new byte[1000 * 1000];\n+                                     ZipArchiveEntry zae =\n+                                         new ZipArchiveEntry(\"0\");\n+                                     zae.setSize(FIVE_BILLION);\n+                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                     zos.putArchiveEntry(zae);\n+                                     for (int j = 0;\n+                                          j < FIVE_BILLION / 1000 / 1000;\n+                                          j++) {\n+                                         zos.write(buf);\n+                                     }\n+                                     zos.closeArchiveEntry();\n+                                     zos.close();\n+\n+                                     RandomAccessFile a =\n+                                         new RandomAccessFile(f, \"r\");\n+                                     try {\n+                                         final long end =\n+                                             getLengthAndPositionAtCentralDirectory(a);\n+\n+                                         long cfhPos = a.getFilePointer();\n+                                         // grab first entry, verify\n+                                         // sizes are 0xFFFFFFFF and\n+                                         // it has a ZIP64 extended\n+                                         // information extra field\n+                                         byte[] header = new byte[12];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                                 // version made by\n+                                                 45, 0,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB (EFS + Data Descriptor)\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         byte[] rest = new byte[31];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // comment length\n+                                                 0, 0,\n+                                                 // disk number\n+                                                 0, 0,\n+                                                 // attributes\n+                                                 0, 0,\n+                                                 0, 0, 0, 0,\n+                                                 // offset\n+                                                 0, 0, 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         byte[] extra = new byte[12];\n+                                         a.readFully(extra);\n+                                         // 5e9 == 0x12A05F200\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                                 // don't know the\n+                                                 // compressed size,\n+                                                 // don't want to\n+                                                 // hard-code it\n+                                             }, extra);\n+\n+                                         // validate data descriptor\n+                                         a.seek(cfhPos - 24);\n+                                         byte[] dd = new byte[8];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 7, 8,\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                             }, dd);\n+                                         // skip uncompressed size\n+                                         a.skipBytes(8);\n+                                         dd = new byte[8];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                             }, dd);\n+\n+                                         // and now validate local file header\n+                                         a.seek(0);\n+                                         header = new byte[10];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB (EFS + Data Descriptor)\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         rest = new byte[17];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 0, 0, 0, 0,\n+                                                 // Compressed Size\n+                                                 0, 0, 0, 0,\n+                                                 // Original Size\n+                                                 0, 0, 0, 0,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         a.readFully(extra);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, 0, 0, 0,\n+                                                 // compressed size\n+                                                 0, 0, 0, 0,\n+                                             }, extra);\n+                                     } finally {\n+                                         a.close();\n+                                     }\n+                                 }\n+                             },\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    @Test public void writeBigDeflatedEntryKnownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     byte[] buf = new byte[1000 * 1000];\n+                                     ZipArchiveEntry zae =\n+                                         new ZipArchiveEntry(\"0\");\n+                                     zae.setSize(FIVE_BILLION);\n+                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                     zos.putArchiveEntry(zae);\n+                                     for (int j = 0;\n+                                          j < FIVE_BILLION / 1000 / 1000;\n+                                          j++) {\n+                                         zos.write(buf);\n+                                     }\n+                                     zos.closeArchiveEntry();\n+                                     zos.close();\n+\n+                                     RandomAccessFile a =\n+                                         new RandomAccessFile(f, \"r\");\n+                                     try {\n+                                         final long end =\n+                                             getLengthAndPositionAtCentralDirectory(a);\n+\n+                                         long cfhPos = a.getFilePointer();\n+                                         // grab first entry, verify\n+                                         // sizes are 0xFFFFFFFF and\n+                                         // it has a ZIP64 extended\n+                                         // information extra field\n+                                         byte[] header = new byte[12];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                                 // version made by\n+                                                 45, 0,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB (EFS + *no* Data\n+                                                 //            Descriptor)\n+                                                 0, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         byte[] rest = new byte[31];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // comment length\n+                                                 0, 0,\n+                                                 // disk number\n+                                                 0, 0,\n+                                                 // attributes\n+                                                 0, 0,\n+                                                 0, 0, 0, 0,\n+                                                 // offset\n+                                                 0, 0, 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         byte[] extra = new byte[12];\n+                                         a.readFully(extra);\n+                                         // 5e9 == 0x12A05F200\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                                 // don't know the\n+                                                 // compressed size,\n+                                                 // don't want to\n+                                                 // hard-code it\n+                                             }, extra);\n+\n+                                         // and now validate local file header\n+                                         a.seek(0);\n+                                         header = new byte[10];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n+                                                 // version needed to extract\n+                                                 45, 0,\n+                                                 // GPB (EFS bit, no DD)\n+                                                 0, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         rest = new byte[17];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // Original Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 20, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                         extra = new byte[12];\n+                                         a.readFully(extra);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Header-ID\n+                                                 1, 0,\n+                                                 // size of extra\n+                                                 16, 0,\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                                 // don't know the\n+                                                 // compressed size,\n+                                                 // don't want to\n+                                                 // hard-code it\n+                                             }, extra);\n+                                     } finally {\n+                                         a.close();\n+                                     }\n+                                 }\n+                             },\n+                             true);\n+    }\n+\n+    static interface ZipOutputTest {\n+        void test(File f, ZipArchiveOutputStream zos) throws IOException;\n+    }\n+\n+    private static void withTemporaryArchive(String testName,\n+                                             ZipOutputTest test,\n+                                             boolean useRandomAccessFile)\n+        throws Throwable {\n+        File f = getTempFile(testName);\n+        BufferedOutputStream os = null;\n+        ZipArchiveOutputStream zos = useRandomAccessFile\n+            ? new ZipArchiveOutputStream(f)\n+            : new ZipArchiveOutputStream(os = new BufferedOutputStream(new FileOutputStream(f)));\n+        try {\n+            test.test(f, zos);\n+        } catch (IOException ex) {\n+            System.err.println(\"Failed to write archive because of: \"\n+                               + ex.getMessage()\n+                               + \" - likely not enough disk space.\");\n+            assumeTrue(false);\n+        } finally {\n+            try {\n+                zos.close();\n+            } finally {\n+                if (os != null) {\n+                    os.close();\n+                }\n+            }\n+        }\n+        f.delete();\n+    }\n+\n+    private static File getFile(String name) throws Throwable {\n+        URL url = Zip64SupportTest.class.getResource(name);\n+        assumeNotNull(url);\n+        File file = new File(new URI(url.toString()));\n+        assumeTrue(file.exists());\n+        return file;\n+    }\n+\n+    private static File get5GBZerosFile() throws Throwable {\n+        return getFile(\"/5GB_of_Zeros.zip\");\n+    }\n+\n+    private static File get100KFileFile() throws Throwable {\n+        return getFile(\"/100k_Files.zip\");\n+    }\n+\n+    private static File getTempFile(String testName) throws Throwable {\n+        File f = File.createTempFile(\"commons-compress-\" + testName, \".zip\");\n+        f.deleteOnExit();\n+        return f;\n+    }\n+\n+    private static void read5GBOfZerosImpl(File f, String expectedName)\n+        throws IOException {\n+        FileInputStream fin = new FileInputStream(f);\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(fin);\n+            ZipArchiveEntry zae = zin.getNextZipEntry();\n+            assertEquals(expectedName, zae.getName());\n+            byte[] buf = new byte[1024 * 1024];\n+            long read = 0;\n+            Random r = new Random(System.currentTimeMillis());\n+            int readNow;\n+            while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n+                // testing all bytes for a value of 0 is going to take\n+                // too long, just pick a few ones randomly\n+                for (int i = 0; i < 1024; i++) {\n+                    int idx = r.nextInt(readNow);\n+                    assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n+                }\n+                read += readNow;\n+            }\n+            assertEquals(FIVE_BILLION, read);\n+            assertEquals(FIVE_BILLION, zae.getSize());\n+            assertNull(zin.getNextZipEntry());\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+            if (fin != null) {\n+                fin.close();\n+            }\n+        }\n+    }\n+\n+    private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n+        throws IOException {\n+        final long end = a.length();\n+        long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n+        // seek to central directory locator\n+        a.seek(cdOffsetLoc);\n+        byte[] cdOffset = new byte[8];\n+        a.readFully(cdOffset);\n+        a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+        return end;\n+    }\n+}", "timestamp": 1312091922, "metainfo": ""}