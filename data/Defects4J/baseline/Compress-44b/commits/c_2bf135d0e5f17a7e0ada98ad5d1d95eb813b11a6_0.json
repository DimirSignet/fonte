{"sha": "2bf135d0e5f17a7e0ada98ad5d1d95eb813b11a6", "log": "Changed from nThreads to receiving an ExecutorService  There are a lot of different models/versions of executorservices, also varying according to client JDK level. Give client full control of how the executor service is created and also possibly how to schedule tasks through a slightly lower-level cerateCallable/submit api.  Termination of ExecutorService is still controlled by ParallelScatterZipCreator, as must be.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n  * the output file. Things that need to come in a specific order (manifests, directories)\n  * must be handled by the client of this class, usually by writing these things to the\n  * #ZipArchiveOutputStream *before* calling #writeTo on this class.</p>\n+ * <p>\n+ * The client can supply an ExecutorService, but for reasons of memory model consistency,\n+ * this will be shut down by this class prior to completion.\n+ * </p>\n  */\n public class ParallelScatterZipCreator {\n     private final List<ScatterZipOutputStream> streams = synchronizedList(new ArrayList<ScatterZipOutputStream>());\n     private final ExecutorService es;\n-    private final ScatterGatherBackingStoreSupplier supplier;\n+    private final ScatterGatherBackingStoreSupplier backingStoreSupplier;\n     private final List<Future> futures = new ArrayList<Future>();\n \n     private final long startedAt = System.currentTimeMillis();\n     private long compressionDoneAt = 0;\n     private long scatterDoneAt;\n \n-    private static class DefaultSupplier implements ScatterGatherBackingStoreSupplier {\n+    private static class DefaultBackingStoreSupplier implements ScatterGatherBackingStoreSupplier {\n         final AtomicInteger storeNum = new AtomicInteger(0);\n \n         public ScatterGatherBackingStore get() throws IOException {\n         @Override\n         protected ScatterZipOutputStream initialValue() {\n             try {\n-                ScatterZipOutputStream scatterStream = createDeferred(supplier);\n+                ScatterZipOutputStream scatterStream = createDeferred(backingStoreSupplier);\n                 streams.add(scatterStream);\n                 return scatterStream;\n             } catch (IOException e) {\n      * Create a ParallelScatterZipCreator with default threads\n      */\n     public ParallelScatterZipCreator() {\n-        this(Runtime.getRuntime().availableProcessors());\n+        this(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));\n     }\n \n     /**\n      * Create a ParallelScatterZipCreator\n      *\n-     * @param nThreads the number of threads to use in parallel.\n-     */\n-    public ParallelScatterZipCreator(int nThreads) {\n-        this( nThreads, new DefaultSupplier());\n+     * @param executorService The executorService to use for parallel scheduling. For technical reasons,\n+     *                        this will be shut down by this class.\n+     */\n+    public ParallelScatterZipCreator(ExecutorService executorService) {\n+        this(executorService, new DefaultBackingStoreSupplier());\n     }\n \n     /**\n      * Create a ParallelScatterZipCreator\n      *\n-     * @param nThreads the number of threads to use in parallel.\n+     * @param executorService The executorService to use. For technical reasons, this will be shut down\n+     *                        by this class.\n      * @param backingStoreSupplier The supplier of backing store which shall be used\n      */\n-    public ParallelScatterZipCreator(int nThreads, ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n-        supplier = backingStoreSupplier;\n-        es = Executors.newFixedThreadPool(nThreads);\n+    public ParallelScatterZipCreator(ExecutorService executorService,\n+                                     ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n+        this.backingStoreSupplier = backingStoreSupplier;\n+        es = executorService;\n     }\n \n     /**\n      * This method is expected to be called from a single client thread\n      * </p>\n      *\n-     * @param zipArchiveEntry The entry to add. Compression method\n+     * @param zipArchiveEntry The entry to add.\n      * @param source          The source input stream supplier\n      */\n \n     public void addArchiveEntry(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n+        submit(createCallable(zipArchiveEntry, source));\n+    }\n+\n+    /**\n+     * Submit a callable for compression\n+     * @param callable The callable to run\n+     */\n+    public void submit(Callable<Object> callable) {\n+        futures.add(es.submit(callable));\n+    }\n+\n+    /**\n+     * Create a callable that will compress the given archive entry.\n+     *\n+     * <p>This method is expected to be called from a single client thread.</p>\n+     * <p>\n+     * This method is used by clients that want finer grained control over how the callable is\n+     * created, possibly wanting to wrap this callable in a different callable</p>\n+     *\n+     * @param zipArchiveEntry The entry to add.\n+     * @param source    The source input stream supplier\n+     * @return   A callable that will be used to check for errors\n+     */\n+\n+    public Callable<Object> createCallable(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n         final int method = zipArchiveEntry.getMethod();\n         if (method == ZipMethod.UNKNOWN_CODE) {\n             throw new IllegalArgumentException(\"Method must be set on the supplied zipArchiveEntry\");\n         }\n-        // Consider if we want to constrain the number of items that can enqueue here.\n-        Future<Object> future = es.submit(new Callable<Object>() {\n-            public Void call() throws Exception {\n-                ScatterZipOutputStream streamToUse = tlScatterStreams.get();\n+        return new Callable<Object>() {\n+            public Object call() throws Exception {\n+                final ScatterZipOutputStream streamToUse = tlScatterStreams.get();\n                 InputStream payload = source.get();\n                 try {\n                     streamToUse.addArchiveEntry(zipArchiveEntry, payload, method);\n                 }\n                 return null;\n             }\n-\n-        });\n-        futures.add( future);\n+        };\n     }\n \n \n         }\n \n         es.shutdown();\n-        es.awaitTermination(1000 * 60, TimeUnit.SECONDS);\n+        es.awaitTermination(1000 * 60, TimeUnit.SECONDS);  // == Infinity. We really *must* wait for this to complete\n \n         // It is important that all threads terminate before we go on, ensure happens-before relationship\n         compressionDoneAt = System.currentTimeMillis();\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n \n import static org.junit.Assert.*;\n \n @SuppressWarnings(\"OctalInteger\")\n public class ParallelScatterZipCreatorTest {\n+\n+    private final int NUMITEMS = 5000;\n \n     @Test\n     public void concurrent()\n         Map<String, byte[]> entries = writeEntries(zipCreator);\n         zipCreator.writeTo(zos);\n         zos.close();\n+        removeEntriesFoundInZipFile(result, entries);\n+        assertTrue(entries.size() == 0);\n+        assertNotNull( zipCreator.getStatisticsMessage());\n+    }\n+\n+    @Test\n+    public void callableApi()\n+            throws Exception {\n+        File result = File.createTempFile(\"parallelScatterGather2\", \"\");\n+        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n+        zos.setEncoding(\"UTF-8\");\n+        ExecutorService es = Executors.newFixedThreadPool(1);\n+\n+        ScatterGatherBackingStoreSupplier supp = new ScatterGatherBackingStoreSupplier() {\n+            public ScatterGatherBackingStore get() throws IOException {\n+                return new FileBasedScatterGatherBackingStore(File.createTempFile(\"parallelscatter\", \"n1\"));\n+            }\n+        };\n+\n+        ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator(es, supp);\n+        Map<String, byte[]> entries = writeEntriesAsCallable(zipCreator);\n+        zipCreator.writeTo(zos);\n+        zos.close();\n+\n \n         removeEntriesFoundInZipFile(result, entries);\n         assertTrue(entries.size() == 0);\n-        assertNotNull( zipCreator.getStatisticsMessage());\n+        assertNotNull(zipCreator.getStatisticsMessage());\n     }\n \n     private void removeEntriesFoundInZipFile(File result, Map<String, byte[]> entries) throws IOException {\n             InputStream inputStream = zf.getInputStream(zipArchiveEntry);\n             byte[] actual = IOUtils.toByteArray(inputStream);\n             byte[] expected = entries.remove(zipArchiveEntry.getName());\n-            assertArrayEquals( expected, actual);\n+            assertArrayEquals( \"For \" + zipArchiveEntry.getName(),  expected, actual);\n         }\n         zf.close();\n     }\n \n     private Map<String, byte[]> writeEntries(ParallelScatterZipCreator zipCreator) {\n         Map<String, byte[]> entries = new HashMap<String, byte[]>();\n-        for (int i = 0; i < 10000; i++){\n-            ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n-            final String payload = \"content\" + i;\n-            final byte[] payloadBytes = payload.getBytes();\n-            entries.put( za.getName(), payloadBytes);\n-            za.setMethod(ZipArchiveEntry.DEFLATED);\n-            za.setSize(payload.length());\n-            za.setUnixMode(UnixStat.FILE_FLAG | 0664);\n+        for (int i = 0; i < NUMITEMS; i++){\n+            final byte[] payloadBytes = (\"content\" + i).getBytes();\n+            ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n             zipCreator.addArchiveEntry(za, new InputStreamSupplier() {\n                 public InputStream get() {\n                     return new ByteArrayInputStream(payloadBytes);\n         }\n         return entries;\n     }\n+\n+    private Map<String, byte[]> writeEntriesAsCallable(ParallelScatterZipCreator zipCreator) {\n+        Map<String, byte[]> entries = new HashMap<String, byte[]>();\n+        for (int i = 0; i < NUMITEMS; i++){\n+            final byte[] payloadBytes = (\"content\" + i).getBytes();\n+            ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n+            final Callable<Object> callable = zipCreator.createCallable(za, new InputStreamSupplier() {\n+                public InputStream get() {\n+                    return new ByteArrayInputStream(payloadBytes);\n+                }\n+            });\n+            zipCreator.submit(callable);\n+        }\n+        return entries;\n+    }\n+\n+    private ZipArchiveEntry createZipArchiveEntry(Map<String, byte[]> entries, int i, byte[] payloadBytes) {\n+        ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n+        entries.put( za.getName(), payloadBytes);\n+        za.setMethod(ZipArchiveEntry.DEFLATED);\n+        za.setSize(payloadBytes.length);\n+        za.setUnixMode(UnixStat.FILE_FLAG | 0664);\n+        return za;\n+    }\n }", "timestamp": 1421132364, "metainfo": ""}