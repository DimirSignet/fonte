{"sha": "cbbeae7719943308494825574a0002ea649b3de3", "log": "Modified ZipOutputStream to be able to avoid seeking and rewriting headers when operating through addRaw.  The basic idea is that an entry added through addRaw is fully known at the time we call add, so we do not need to go back in the file to rewrite fields.  Adding this third mode increases the pain of multiple code paths, and we should probably consider a ground-up rewrite at some point.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n         long realCrc = streamCompressor.getCrc32();\n         entry.bytesRead = streamCompressor.getBytesRead();\n-        doCloseEntry(realCrc, bytesWritten);\n+        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n+        final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n+        closeEntry(actuallyNeedsZip64, false);\n         streamCompressor.reset();\n     }\n \n      * @throws Zip64RequiredException if the entry's uncompressed or\n      *                                compressed size exceeds 4 GByte and {@link #setUseZip64}\n      *                                is {@link Zip64Mode#Never}.\n-     */\n-    private void closeCopiedEntry() throws IOException {\n+     * @param phased              This entry is second phase of a 2-phase zip creation, size, compressed size and crc\n+     *                            are known in ZipArchiveEntry\n+     */\n+    private void closeCopiedEntry(boolean phased) throws IOException {\n         preClose();\n         entry.bytesRead = entry.entry.getSize();\n-        doCloseCopiedEntry();\n-    }\n-\n-    private void doCloseEntry(long realCrc, long bytesWritten) throws IOException {\n-        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n-        final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n-\n-        closeEntry(actuallyNeedsZip64);\n-    }\n-\n-    private void doCloseCopiedEntry() throws IOException {\n         Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n         boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n-        closeEntry(actuallyNeedsZip64);\n-    }\n-\n-    private void closeEntry(boolean actuallyNeedsZip64) throws IOException {\n-        if (raf != null) {\n+        closeEntry(actuallyNeedsZip64, phased);\n+    }\n+\n+\n+    private void closeEntry(boolean actuallyNeedsZip64, boolean phased) throws IOException {\n+        if (!phased && raf != null) {\n             rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n \n     /**\n      * Adds an archive entry with a raw input stream.\n      *\n+     * If crc, size and compressed size are supplied on the entry, these values will be used as-is.\n+     * Zip64 status is re-established based on the settings in this stream, and the supplied value\n+     * is ignored.\n+     *\n      * The entry is put and closed immediately.\n      *\n      * @param entry The archive entry to add\n     public void addRawArchiveEntry(ZipArchiveEntry entry, InputStream rawStream)\n             throws IOException {\n         ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n-        putArchiveEntry(ae);\n+        if (hasZip64Extra(ae)) {\n+            // Will be re-added as required. this may make the file generated with this method\n+            // somewhat smaller than standard mode,\n+            // since standard mode is unable to remove the zip 64 header.\n+            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        }\n+        boolean is2PhaseSource = ae.getCrc() != -1\n+                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n+                && ae.getCompressedSize() != -1;\n+        putArchiveEntry(ae, is2PhaseSource);\n         copyFromZipInputStream(rawStream);\n-        closeCopiedEntry();\n+        closeCopiedEntry(is2PhaseSource);\n     }\n \n     /**\n      */\n     private boolean checkIfNeedsZip64(Zip64Mode effectiveMode)\n             throws ZipException {\n-        final boolean actuallyNeedsZip64 = effectiveMode == Zip64Mode.Always\n-                || entry.entry.getSize() >= ZIP64_MAGIC\n-                || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n+        final boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(entry.entry));\n         }\n         return actuallyNeedsZip64;\n+    }\n+\n+    private boolean isZip64Required(ZipArchiveEntry entry1, Zip64Mode requestedMode) {\n+        return requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n+    }\n+\n+    private boolean isTooLageForZip32(ZipArchiveEntry zipArchiveEntry){\n+        return zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n     }\n     /**\n      * When using random access output, write the local file header\n      */\n     @Override\n     public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n+        putArchiveEntry(archiveEntry, false);\n+    }\n+\n+    /**\n+     * Writes the headers for an archive entry to the output stream.\n+     * The caller must then write the content to the stream and call\n+     * {@link #closeArchiveEntry()} to complete the process.\n+\n+     * @param archiveEntry The archiveEntry\n+     * @param phased If true size, compressedSize and crc required to be known up-front in the archiveEntry\n+     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n+     * @throws Zip64RequiredException if the entry's uncompressed or\n+     * compressed size is known to exceed 4 GByte and {@link #setUseZip64}\n+     * is {@link Zip64Mode#Never}.\n+     */\n+    private void putArchiveEntry(ArchiveEntry archiveEntry, boolean phased) throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n             // just a placeholder, real data will be in data\n             // descriptor or inserted later via RandomAccessFile\n             ZipEightByteInteger size = ZipEightByteInteger.ZERO;\n-            if (entry.entry.getMethod() == STORED\n-                && entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n+            ZipEightByteInteger compressedSize = ZipEightByteInteger.ZERO;\n+            if (phased){\n+                size = new ZipEightByteInteger(entry.entry.getSize());\n+                compressedSize = new ZipEightByteInteger(entry.entry.getCompressedSize());\n+            } else if (entry.entry.getMethod() == STORED\n+                    && entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n                 // actually, we already know the sizes\n                 size = new ZipEightByteInteger(entry.entry.getSize());\n+                compressedSize = size;\n             }\n             z64.setSize(size);\n-            z64.setCompressedSize(size);\n+            z64.setCompressedSize(compressedSize);\n             entry.entry.setExtra();\n         }\n \n             def.setLevel(level);\n             hasCompressionLevelChanged = false;\n         }\n-        writeLocalFileHeader((ZipArchiveEntry) archiveEntry);\n+        writeLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n     }\n \n     /**\n      * @throws IOException on error\n      */\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n+        writeLocalFileHeader(ze, false);\n+    }\n+\n+    private void writeLocalFileHeader(ZipArchiveEntry ze, boolean phased) throws IOException {\n         boolean encodable = zipEncoding.canEncode(ze.getName());\n         ByteBuffer name = getName(ze);\n \n             addUnicodeExtraFields(ze, encodable, name);\n         }\n \n-        final byte[] localHeader = createLocalFileHeader(ze, name, encodable);\n+        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased);\n         long localHeaderStart = streamCompressor.getTotalBytesWritten();\n         offsets.put(ze, localHeaderStart);\n         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n     }\n \n \n-    private byte[] createLocalFileHeader(ZipArchiveEntry ze, ByteBuffer name, boolean encodable)  {\n-\n+    private byte[] createLocalFileHeader(ZipArchiveEntry ze, ByteBuffer name, boolean encodable,\n+                                         boolean phased)  {\n         byte[] extra = ze.getLocalFileDataExtra();\n         final int nameLen = name.limit() - name.position();\n         int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n \n-        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n+        if (phased &&  !isZip64Required(entry.entry, zip64Mode)){\n+            putShort(INITIAL_VERSION, buf, LFH_VERSION_NEEDED_OFFSET);\n+        } else {\n+            putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n+        }\n \n         GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod,\n                 !encodable\n         ZipUtil.toDosTime(ze.getTime(), buf, LFH_TIME_OFFSET);\n \n         // CRC\n+        if (phased){\n+            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+        } else if (zipMethod == DEFLATED || raf != null) {\n+            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+        } else {\n+            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+        }\n+\n         // compressed length\n         // uncompressed length\n-        if (zipMethod == DEFLATED || raf != null) {\n-            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-            if (hasZip64Extra(entry.entry)) {\n-                // point to ZIP64 extended information extra field for\n-                // sizes, may get rewritten once sizes are known if\n-                // stream is seekable\n-                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-            } else {\n-                System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-                System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n-            }\n-        } else {\n-            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-            if (!hasZip64Extra(ze)) {\n-                putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-                putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-            } else {\n-                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-            }\n+        if (hasZip64Extra(entry.entry)){\n+            // point to ZIP64 extended information extra field for\n+            // sizes, may get rewritten once sizes are known if\n+            // stream is seekable\n+            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        } else if (phased) {\n+            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        } else if (zipMethod == DEFLATED || raf != null) {\n+            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n+            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+        } else { // Stored\n+            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n         }\n         // file name length\n         putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n import java.util.zip.ZipEntry;\n \n import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.zip.Zip64Mode;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntryPredicate;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream; \t\n             throws IOException {\n \n         File[] tmp = createTempDirAndFile();\n-        File reference = createReferenceFile(tmp[0]);\n+        File reference = createReferenceFile(tmp[0], Zip64Mode.Never, \"expected.\");\n \n         File a1 = File.createTempFile(\"src1.\", \".zip\", tmp[0]);\n-        createFirstEntry(new ZipArchiveOutputStream(a1)).close();\n+        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n+        zos.setUseZip64(Zip64Mode.Never);\n+        createFirstEntry(zos).close();\n \n         File a2 = File.createTempFile(\"src2.\", \".zip\", tmp[0]);\n-        createSecondEntry(new ZipArchiveOutputStream(a2)).close();\n+        ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(a2);\n+        zos1.setUseZip64(Zip64Mode.Never);\n+        createSecondEntry(zos1).close();\n \n         ZipFile zf1 = new ZipFile(a1);\n         ZipFile zf2 = new ZipFile(a2);\n         zf1.copyRawEntries(zos2, allFilesPredicate);\n         zf2.copyRawEntries(zos2, allFilesPredicate);\n         zos2.close();\n+        // copyRawEntries does not add superfluous zip64 header like regular zip output stream\n+        // does when using Zip64Mode.AsNeeded so all the source material has to be Zip64Mode.Never,\n+        // if exact binary equality is to be achieved\n         assertSameFileContents(reference, fileResult);\n         zf1.close();\n         zf2.close();\n     }\n \n+    public void testCopyRawZip64EntryFromFile()\n+            throws IOException {\n+\n+        File[] tmp = createTempDirAndFile();\n+        File reference = File.createTempFile(\"z64reference.\", \".zip\", tmp[0]);\n+        ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(reference);\n+        zos1.setUseZip64(Zip64Mode.Always);\n+        createFirstEntry(zos1);\n+        zos1.close();\n+\n+        File a1 = File.createTempFile(\"zip64src.\", \".zip\", tmp[0]);\n+        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n+        zos.setUseZip64(Zip64Mode.Always);\n+        createFirstEntry(zos).close();\n+\n+        ZipFile zf1 = new ZipFile(a1);\n+        File fileResult = File.createTempFile(\"file-actual.\", \".zip\", tmp[0]);\n+        ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult);\n+        zos2.setUseZip64(Zip64Mode.Always);\n+        zf1.copyRawEntries(zos2, allFilesPredicate);\n+        zos2.close();\n+        assertSameFileContents(reference, fileResult);\n+        zf1.close();\n+    }\n     public void testUnixModeInAddRaw() throws IOException {\n \n         File[] tmp = createTempDirAndFile();\n         zf1.close();\n     }\n \n-    private File createReferenceFile(File directory) throws IOException {\n-        File reference = File.createTempFile(\"expected.\", \".zip\", directory);\n+    private File createReferenceFile(File directory, Zip64Mode zipMode, String prefix) throws IOException {\n+        File reference = File.createTempFile(prefix, \".zip\", directory);\n         ZipArchiveOutputStream zos = new ZipArchiveOutputStream(reference);\n+        zos.setUseZip64(zipMode);\n         createFirstEntry(zos);\n         createSecondEntry(zos);\n         zos.close();", "timestamp": 1420665064, "metainfo": ""}