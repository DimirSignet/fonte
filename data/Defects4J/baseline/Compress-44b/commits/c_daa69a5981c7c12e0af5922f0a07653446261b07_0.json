{"sha": "daa69a5981c7c12e0af5922f0a07653446261b07", "log": "COMPRESS-388: Improve stream performance with wrapped buffers", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * range can be read.\n      */\n     private class BoundedInputStream extends InputStream {\n-        protected static final int MAX_BUF_LEN = 8192;\n-        protected final ByteBuffer buffer;\n-        protected long remaining;\n-        protected long loc;\n-        protected boolean addDummyByte = false;\n+        private ByteBuffer singleByteBuffer;\n+        private final long end;\n+        private long loc;\n+        private boolean addDummy = false;\n \n         BoundedInputStream(final long start, final long remaining) {\n-            this.remaining = remaining;\n+            this.end = start+remaining;\n+            if (this.end < start) {\n+                // check for potential vulnerability due to overflow\n+                throw new IllegalArgumentException(\"Invalid length of stream at offset=\"+start+\", length=\"+remaining);\n+            }\n             loc = start;\n-            if (remaining < MAX_BUF_LEN && remaining > 0) {\n-                buffer = ByteBuffer.allocate((int) remaining);\n-            } else {\n-                buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n-            }\n         }\n \n         @Override\n-        public int read() throws IOException {\n-            if (remaining-- <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n+        public synchronized int read() throws IOException {\n+            if (loc >= end) {\n+                if (loc == end && addDummy) {\n+                    ++loc;\n                     return 0;\n                 }\n                 return -1;\n             }\n-            int read = read(loc++, 1);\n+            if (singleByteBuffer == null) {\n+                singleByteBuffer = ByteBuffer.allocate(1);\n+            }\n+            else {\n+                singleByteBuffer.rewind();\n+            }\n+            int read = read(loc++, singleByteBuffer);\n             if (read < 0) {\n                 return read;\n             }\n-            return buffer.get() & 0xff;\n+            return singleByteBuffer.get() & 0xff;\n         }\n \n         @Override\n-        public int read(final byte[] b, final int off, int len) throws IOException {\n-            if (remaining <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n-                    b[off] = 0;\n-                    return 1;\n-                }\n-                return -1;\n-            }\n-\n+        public synchronized int read(final byte[] b, final int off, int len) throws IOException {\n             if (len <= 0) {\n                 return 0;\n             }\n \n-            if (len > remaining) {\n-                len = (int) remaining;\n-            }\n+            if (len > end-loc) {\n+                if (loc >= end) {\n+                    if (loc == end && addDummy) {\n+                        ++loc;\n+                        b[off] = 0;\n+                        return 1;\n+                    }\n+                    return -1;\n+                }\n+                len = (int)(end-loc);\n+            }\n+\n             ByteBuffer buf;\n-            int ret = -1;\n-            if (len <= buffer.capacity()) {\n-                buf = buffer;\n-                ret = read(loc, len);\n-            } else {\n-                buf = ByteBuffer.allocate(len);\n-                ret = read(loc, buf);\n-            }\n+            buf = ByteBuffer.wrap(b, off, len);\n+            int ret = read(loc, buf);\n             if (ret > 0) {\n-                buf.get(b, off, ret);\n                 loc += ret;\n-                remaining -= ret;\n+                return ret;\n             }\n             return ret;\n         }\n             return read;\n         }\n \n-        protected int read(long pos, int len) throws IOException {\n-            int read;\n-            buffer.rewind().limit(len);\n-            synchronized (archive) {\n-                archive.position(pos);\n-                read = archive.read(buffer);\n-            }\n-            buffer.flip();\n-            return read;\n-        }\n-\n-        /**\n-         * Inflater needs an extra dummy byte for nowrap - see\n-         * Inflater's javadocs.\n-         */\n         void addDummy() {\n-            addDummyByte = true;\n+            this.addDummy = true;\n         }\n     }\n \n         protected int read(long pos, ByteBuffer buf) throws IOException {\n             int read = archive.read(buf, pos);\n             buf.flip();\n-            return read;\n-        }\n-\n-        @Override\n-        protected int read(long position, int len) throws IOException {\n-            buffer.rewind().limit(len);\n-            int read = archive.read(buffer, position);\n-            buffer.flip();\n             return read;\n         }\n     }", "timestamp": 1493143338, "metainfo": ""}