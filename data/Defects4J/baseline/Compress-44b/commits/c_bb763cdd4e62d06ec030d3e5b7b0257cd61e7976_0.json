{"sha": "bb763cdd4e62d06ec030d3e5b7b0257cd61e7976", "log": "Some fixes for GZipCompressorInputStream", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n     // Compressed input stream, possibly wrapped in a BufferedInputStream\n     private final InputStream in;\n \n-    // True if decompressing multimember streams.\n+    // True if decompressing multi member streams.\n     private final boolean decompressConcatenated;\n \n     // Buffer to hold the input data\n     private final byte[] buf = new byte[8192];\n \n     // Amount of data in buf.\n-    private int bufUsed = 0;\n+    private int bufUsed;\n \n     // Decompressor\n     private Inflater inf = new Inflater(true);\n         return true;\n     }\n \n-    private byte[] readToNull(final DataInputStream inData) throws IOException {\n+    private static byte[] readToNull(final DataInputStream inData) throws IOException {\n         final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int b = 0;\n         while ((b = inData.readUnsignedByte()) != 0x00) { // NOPMD\n         return bos.toByteArray();\n     }\n \n-    private long readLittleEndianInt(final DataInputStream inData) throws IOException {\n+    private static long readLittleEndianInt(final DataInputStream inData) throws IOException {\n         return inData.readUnsignedByte()\n             | (inData.readUnsignedByte() << 8)\n             | (inData.readUnsignedByte() << 16)\n                 // position to match the actual amount used.\n                 //\n                 // NOTE: The \"if\" is there just in case. Since we used\n-                // in.mark earler, it should always skip enough.\n+                // in.mark earlier, it should always skip enough.\n                 in.reset();\n \n                 final int skipAmount = bufUsed - inf.getRemaining();", "timestamp": 1484889860, "metainfo": ""}