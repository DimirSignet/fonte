{"sha": "d09177b98f4e956c1d366110f73c3341ea110bee", "log": "chunking of input by entries in AR-Input, COMPRESS-11  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n     private final InputStream input;\n     private long offset = 0;\n     private boolean closed;\n+    /*\n+     * If getNextEnxtry has been called, the entry metadata is stored in\n+     * currentEntry.\n+     */\n+    private ArArchiveEntry currentEntry = null;\n+    /*\n+     * The offset where the current entry started. -1 if no entry has been\n+     * called\n+     */\n+    private long entryOffset = -1;\n \n     public ArArchiveInputStream( final InputStream pInput ) {\n         input = pInput;\n         closed = false;\n     }\n \n+    /**\n+     * Returns the next AR entry in this stream.\n+     * \n+     * @return the next AR entry.\n+     * @throws IOException\n+     *             if the entry could not be read\n+     */\n     public ArArchiveEntry getNextArEntry() throws IOException {\n+        if (currentEntry != null) {\n+            final long entryEnd = entryOffset + currentEntry.getLength();\n+            while (offset < entryEnd) {\n+                int x = read();\n+                if (x == -1) {\n+                    // hit EOF before previous entry was complete\n+                    // TODO: throw an exception instead?\n+                    return null;\n+                }\n+            }\n+            currentEntry = null;\n+        }\n \n         if (offset == 0) {\n             final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n             }\n         }\n \n+        if (offset % 2 != 0) {\n+            if (read() < 0) {\n+                // hit eof\n+                return null;\n+            }\n+        }\n+\n         if (input.available() == 0) {\n             return null;\n-        }\n-\n-        if (offset % 2 != 0) {\n-            read();\n         }\n \n         final byte[] name = new byte[16];\n             }\n         }\n \n-        return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\n-\n+        entryOffset = offset;\n+        currentEntry = new ArArchiveEntry(new String(name).trim(),\n+                                          Long.parseLong(new String(length)\n+                                                         .trim()));\n+        return currentEntry;\n     }\n \n \n             closed = true;\n             input.close();\n         }\n+        currentEntry = null;\n     }\n \n     public int read() throws IOException {\n-        final int ret = input.read();\n-        offset += (ret > 0 ? 1 : 0);\n-        return ret;\n-    }\n-\n-    public int read(byte b[]) throws IOException {\n+        byte[] single = new byte[1];\n+        int num = read(single, 0, 1);\n+        return num == -1 ? -1 : single[0] & 0xff;\n+    }\n+\n+    public int read(byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n \n-    public int read(byte[] b, int off, int len) throws IOException {\n-        final int ret = this.input.read(b, off, len);\n+    public int read(byte[] b, final int off, final int len) throws IOException {\n+        int toRead = len;\n+        if (currentEntry != null) {\n+            final long entryEnd = entryOffset + currentEntry.getLength();\n+            if (len > 0 && entryEnd > offset) {\n+                toRead = (int) Math.min(len, entryEnd - offset);\n+            } else {\n+                return -1;\n+            }\n+        }\n+        final int ret = this.input.read(b, off, toRead);\n         offset += (ret > 0 ? ret : 0);\n         return ret;\n     }", "timestamp": 1238430675, "metainfo": ""}