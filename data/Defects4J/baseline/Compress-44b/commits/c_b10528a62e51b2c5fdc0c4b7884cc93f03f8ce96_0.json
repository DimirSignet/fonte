{"sha": "b10528a62e51b2c5fdc0c4b7884cc93f03f8ce96", "log": "COMPRESS-382 and COMPRESS-386 -- break out unit tests; add memory limit for xz.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/MemoryLimitException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.IOException;\n+\n+/**\n+ * If a stream checks for estimated memory allocation, and the estimate\n+ * goes above the memory limit, this is thrown.  This can also be thrown\n+ * if a stream tries to allocate a byte array that is larger than\n+ * the allowable limit.\n+ *\n+ * @since 1.14\n+ */\n+public class MemoryLimitException extends IOException {\n+\n+    public MemoryLimitException(String message) {\n+        super(message);\n+    }\n+\n+    public MemoryLimitException(String message, Exception e) {\n+        super(message, e);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.utils.Lists;\n import org.apache.commons.compress.utils.ServiceLoaderIterator;\n import org.apache.commons.compress.utils.Sets;\n-import org.tukaani.xz.MemoryLimitException;\n \n /**\n  * <p>\n      *            the input stream\n      * @return compressor input stream\n      * @throws CompressorException\n-     *             if the compressor name is not known or not available\n+     *             if the compressor name is not known or not available,\n+     *             or if there's an IOException or MemoryLimitException thrown\n+     *             during initialization\n      * @throws IllegalArgumentException\n      *             if the name or input stream is null\n      */\n                 if (!XZUtils.isXZCompressionAvailable()) {\n                     throw new CompressorException(\"XZ compression is not available.\");\n                 }\n-                return new XZCompressorInputStream(in, actualDecompressConcatenated);\n+                return new XZCompressorInputStream(in, actualDecompressConcatenated, memoryLimitInKb);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                try {\n-                    return new LZMACompressorInputStream(in, memoryLimitInKb);\n-                } catch (MemoryLimitException e) {\n-                    throw new CompressorMemoryLimitException(\"exceeded calculated memory limit\", e);\n-                }\n+                return new LZMACompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                try {\n-                    return new ZCompressorInputStream(in, memoryLimitInKb);\n-                } catch (ZCompressorInputStream.IOExceptionWrappingMemoryLimitException e) {\n-                    throw new CompressorMemoryLimitException(e.getMessage());\n-                }\n+                return new ZCompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+\n+import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.LZMAInputStream;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n      */\n     public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n             throws IOException {\n-        in = new LZMAInputStream(inputStream, memoryLimitInKb);\n+        try {\n+            in = new LZMAInputStream(inputStream, memoryLimitInKb);\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress exception\n+            throw new MemoryLimitException(\"exceeded calculated memory limit\", e);\n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n+import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.compressors.CompressorInputStream;\n-import org.apache.commons.compress.compressors.CompressorMemoryLimitException;\n import org.apache.commons.compress.utils.BitInputStream;\n \n /**\n      * Initializes the arrays based on the maximum code size.\n      * @param maxCodeSize maximum code size\n      * @param memoryLimitInKb maximum allowed table size in Kb\n-     * @throws CompressorMemoryLimitException if maxTableSize is > memoryLimitInKb\n+     * @throws MemoryLimitException if maxTableSize is > memoryLimitInKb\n      */\n     protected void initializeTables(final int maxCodeSize, final int memoryLimitInKb)\n-            throws CompressorMemoryLimitException {\n+            throws MemoryLimitException {\n         final int maxTableSize = 1 << maxCodeSize;\n         if (memoryLimitInKb > -1 && maxTableSize > memoryLimitInKb*1024) {\n-            throw new CompressorMemoryLimitException(\"Tried to allocate \"+maxTableSize +\n+            throw new MemoryLimitException(\"Tried to allocate \"+maxTableSize +\n                     \" but memoryLimitInKb only allows \"+(memoryLimitInKb*1024));\n         }\n         initializeTables(maxCodeSize);\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+\n+import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.XZ;\n import org.tukaani.xz.SingleXZInputStream;\n import org.tukaani.xz.XZInputStream;\n     public XZCompressorInputStream(final InputStream inputStream,\n                                    final boolean decompressConcatenated)\n             throws IOException {\n+        this(inputStream, decompressConcatenated, -1);\n+    }\n+\n+    /**\n+     * Creates a new input stream that decompresses XZ-compressed data\n+     * from the specified input stream.\n+     *\n+     * @param       inputStream where to read the compressed data\n+     * @param       decompressConcatenated\n+     *                          if true, decompress until the end of the\n+     *                          input; if false, stop after the first .xz\n+     *                          stream and leave the input position to point\n+     *                          to the next byte after the .xz stream\n+     * @param       memoryLimitInKb memory limit used when reading blocks.  If\n+     *                          the estimated memory limit is exceeded on {@link #read()},\n+     *                          a {@link MemoryLimitException} is thrown.\n+     *\n+     * @throws      IOException if the input is not in the .xz format,\n+     *                          the input is corrupt or truncated, the .xz\n+     *                          headers specify options that are not supported\n+     *                          by this implementation,\n+     *                          or the underlying <code>inputStream</code> throws an exception\n+     *\n+     * @since 1.14\n+     */\n+    public XZCompressorInputStream(InputStream inputStream,\n+                                   boolean decompressConcatenated, int memoryLimitInKb)\n+            throws IOException {\n         if (decompressConcatenated) {\n-            in = new XZInputStream(inputStream);\n+            in = new XZInputStream(inputStream, memoryLimitInKb);\n         } else {\n-            in = new SingleXZInputStream(inputStream);\n+            in = new SingleXZInputStream(inputStream, memoryLimitInKb);\n         }\n     }\n \n     @Override\n     public int read() throws IOException {\n-        final int ret = in.read();\n-        count(ret == -1 ? -1 : 1);\n-        return ret;\n+        try {\n+            final int ret = in.read();\n+            count(ret == -1 ? -1 : 1);\n+            return ret;\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            throw new MemoryLimitException(\"Exceeded memory limit\", e);\n+        }\n     }\n \n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n-        final int ret = in.read(buf, off, len);\n-        count(ret);\n-        return ret;\n+        try {\n+            final int ret = in.read(buf, off, len);\n+            count(ret);\n+            return ret;\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress MemoryLimtException\n+            throw new MemoryLimitException(\"Exceeded memory limit\", e);\n+        }\n     }\n \n     @Override\n     public long skip(final long n) throws IOException {\n-        return in.skip(n);\n+        try {\n+            return in.skip(n);\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress MemoryLimtException\n+            throw new MemoryLimitException(\"Excedded memory limit\", e);\n+        }\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n-import org.apache.commons.compress.compressors.CompressorMemoryLimitException;\n import org.apache.commons.compress.compressors.lzw.LZWInputStream;\n \n /**\n         if (blockMode) {\n             setClearCode(DEFAULT_CODE_SIZE);\n         }\n-        try {\n-            initializeTables(maxCodeSize, memoryLimitInKb);\n-        } catch (CompressorMemoryLimitException e) {\n-            throw new IOExceptionWrappingMemoryLimitException(e.getMessage());\n-        }\n+        initializeTables(maxCodeSize, memoryLimitInKb);\n         clearEntries();\n     }\n \n         return length > 3 && signature[0] == MAGIC_1 && signature[1] == (byte) MAGIC_2;\n     }\n \n-    /**\n-     * Wrapper that subclasses IOException to wrap a MemoryLimitException\n-     */\n-    public static class IOExceptionWrappingMemoryLimitException extends IOException {\n-        public IOExceptionWrappingMemoryLimitException(String message) {\n-            super(message);\n-        }\n-    }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;\n         return name;\n     }\n \n-    @Test\n-    public void testMemoryLimit() throws Exception {\n-        testMemoryLimit(\"COMPRESS-382\");\n-        testMemoryLimit(\"COMPRESS-386\");\n-    }\n-\n-    private void testMemoryLimit(String fileName) throws IOException, CompressorException {\n+    @Test(expected = MemoryLimitException.class)\n+    public void testLZMAMemoryLimit() throws Exception {\n+        getStreamFor(\"COMPRESS-382\", 100);\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testZMemoryLimit() throws Exception {\n+        getStreamFor(\"COMPRESS-386\", 100);\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testXZMemoryLimitOnRead() throws Exception {\n+        //Even though the file is very small, the memory limit\n+        //has to be quite large (8296 KiB) because of the dictionary size\n+\n+        //This is triggered on read(); not during initialization.\n+        //This test is here instead of the xz unit test to make sure\n+        //that the parameter is properly passed via the CompressorStreamFactory\n+        try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n+            int c = compressorIs.read();\n+        }\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testXZMemoryLimitOnSkip() throws Exception {\n+        try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n+            compressorIs.skip(10);\n+        }\n+    }\n+\n+    private InputStream getStreamFor(final String fileName, final int memoryLimitInKb) throws Exception {\n         CompressorStreamFactory fac = new CompressorStreamFactory(true,\n-                100);\n-        try (InputStream is = new BufferedInputStream(\n-                new FileInputStream(getFile(fileName)))) {\n-            InputStream compressorInputStream = fac.createCompressorInputStream(is);\n-            fail(\"Should have thrown CompressorMemoryLimitException\");\n-        } catch (CompressorMemoryLimitException e) {\n-\n+                memoryLimitInKb);\n+        InputStream is = new BufferedInputStream(\n+                new FileInputStream(getFile(fileName)));\n+        try {\n+            return fac.createCompressorInputStream(is);\n+        } catch (CompressorException e) {\n+            if (e.getCause() != null && e.getCause() instanceof Exception) {\n+                //unwrap cause to reveal MemoryLimiteException\n+                throw (Exception)e.getCause();\n+            } else {\n+                throw e;\n+            }\n         }\n \n     }", "timestamp": 1493043030, "metainfo": ""}