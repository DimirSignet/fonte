{"sha": "6a5014ed5847a99b9574a2dd1332c1f91d36defb", "log": "COMPRESS-327 optimize a little  also, take advantage of ByteBuffers byte order handling", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.io.BufferedInputStream;\n import java.io.ByteArrayInputStream;\n import java.io.Closeable;\n-import java.io.DataInput;\n import java.io.DataInputStream;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n     }\n \n     private Archive readHeaders(final byte[] password) throws IOException {\n-        ByteBuffer buf = ByteBuffer.allocate(12 /* signature + 2 bytes version + 4 bytes CRC */);\n+        ByteBuffer buf = ByteBuffer.allocate(12 /* signature + 2 bytes version + 4 bytes CRC */)\n+            .order(ByteOrder.LITTLE_ENDIAN);\n         readFully(buf);\n         final byte[] signature = new byte[6];\n         buf.get(signature);\n                     archiveVersionMajor, archiveVersionMinor));\n         }\n \n-        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(buf.getInt());\n+        final long startHeaderCrc = 0xffffFFFFL & buf.getInt();\n         final StartHeader startHeader = readStartHeader(startHeaderCrc);\n \n         final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n             throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n         }\n         channel.position(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n-        buf = ByteBuffer.allocate(nextHeaderSizeInt);\n-        // TODO rewrite to use ByteBuffer directly rather than DataInputStream\n-        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n+        buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);\n         readFully(buf);\n-        buf.get(nextHeader);\n         final CRC32 crc = new CRC32();\n-        crc.update(nextHeader);\n+        crc.update(buf.array());\n         if (startHeader.nextHeaderCrc != crc.getValue()) {\n             throw new IOException(\"NextHeader CRC mismatch\");\n         }\n \n-        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n-        DataInputStream nextHeaderInputStream = new DataInputStream(\n-                byteStream);\n         Archive archive = new Archive();\n-        int nid = nextHeaderInputStream.readUnsignedByte();\n+        int nid = getUnsignedByte(buf);\n         if (nid == NID.kEncodedHeader) {\n-            nextHeaderInputStream =\n-                readEncodedHeader(nextHeaderInputStream, archive, password);\n+            buf = readEncodedHeader(buf, archive, password);\n             // Archive gets rebuilt with the new header\n             archive = new Archive();\n-            nid = nextHeaderInputStream.readUnsignedByte();\n+            nid = getUnsignedByte(buf);\n         }\n         if (nid == NID.kHeader) {\n-            readHeader(nextHeaderInputStream, archive);\n-            nextHeaderInputStream.close();\n+            readHeader(buf, archive);\n         } else {\n             throw new IOException(\"Broken or unsupported archive: no Header\");\n         }\n \n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n-        // TODO rewrite to use ByteBuffer directly rather than DataInputStream\n+        // using Stream rather than ByteBuffer for the benefit of the\n+        // built-in CRC check\n         try (DataInputStream dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n                 new BoundedSeekableByteChannelInputStream(channel, 20), 20, startHeaderCrc))) {\n              startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n         }\n     }\n \n-    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n-        int nid = header.readUnsignedByte();\n+    private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {\n+        int nid = getUnsignedByte(header);\n \n         if (nid == NID.kArchiveProperties) {\n             readArchiveProperties(header);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid == NID.kAdditionalStreamsInfo) {\n \n         if (nid == NID.kMainStreamsInfo) {\n             readStreamsInfo(header, archive);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid == NID.kFilesInfo) {\n             readFilesInfo(header, archive);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid != NID.kEnd) {\n         }\n     }\n \n-    private void readArchiveProperties(final DataInput input) throws IOException {\n+    private void readArchiveProperties(final ByteBuffer input) throws IOException {\n         // FIXME: the reference implementation just throws them away?\n-        int nid =  input.readUnsignedByte();\n+        int nid =  getUnsignedByte(input);\n         while (nid != NID.kEnd) {\n             final long propertySize = readUint64(input);\n             final byte[] property = new byte[(int)propertySize];\n-            input.readFully(property);\n-            nid = input.readUnsignedByte();\n-        }\n-    }\n-\n-    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\n-                                              final byte[] password) throws IOException {\n+            input.get(property);\n+            nid = getUnsignedByte(input);\n+        }\n+    }\n+\n+    private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive,\n+                                         final byte[] password) throws IOException {\n         readStreamsInfo(header, archive);\n \n         // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n         try (DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack)) {\n             nextHeaderInputStream.readFully(nextHeader);\n         }\n-        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n-    }\n-\n-    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n-        int nid = header.readUnsignedByte();\n+        return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n+        int nid = getUnsignedByte(header);\n \n         if (nid == NID.kPackInfo) {\n             readPackInfo(header, archive);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid == NID.kUnpackInfo) {\n             readUnpackInfo(header, archive);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         } else {\n             // archive without unpack/coders info\n             archive.folders = new Folder[0];\n \n         if (nid == NID.kSubStreamsInfo) {\n             readSubStreamsInfo(header, archive);\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid != NID.kEnd) {\n         }\n     }\n \n-    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n+    private void readPackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         archive.packPos = readUint64(header);\n         final long numPackStreams = readUint64(header);\n-        int nid = header.readUnsignedByte();\n+        int nid = getUnsignedByte(header);\n         if (nid == NID.kSize) {\n             archive.packSizes = new long[(int)numPackStreams];\n             for (int i = 0; i < archive.packSizes.length; i++) {\n                 archive.packSizes[i] = readUint64(header);\n             }\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid == NID.kCRC) {\n             archive.packCrcs = new long[(int)numPackStreams];\n             for (int i = 0; i < (int)numPackStreams; i++) {\n                 if (archive.packCrcsDefined.get(i)) {\n-                    archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n-                }\n-            }\n-\n-            nid = header.readUnsignedByte();\n+                    archive.packCrcs[i] = 0xffffFFFFL & header.getInt();\n+                }\n+            }\n+\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid != NID.kEnd) {\n         }\n     }\n \n-    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n-        int nid = header.readUnsignedByte();\n+    private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {\n+        int nid = getUnsignedByte(header);\n         if (nid != NID.kFolder) {\n             throw new IOException(\"Expected kFolder, got \" + nid);\n         }\n         final long numFolders = readUint64(header);\n         final Folder[] folders = new Folder[(int)numFolders];\n         archive.folders = folders;\n-        final int external = header.readUnsignedByte();\n+        final int external = getUnsignedByte(header);\n         if (external != 0) {\n             throw new IOException(\"External unsupported\");\n         }\n             folders[i] = readFolder(header);\n         }\n \n-        nid = header.readUnsignedByte();\n+        nid = getUnsignedByte(header);\n         if (nid != NID.kCodersUnpackSize) {\n             throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n         }\n             }\n         }\n \n-        nid = header.readUnsignedByte();\n+        nid = getUnsignedByte(header);\n         if (nid == NID.kCRC) {\n             final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n             for (int i = 0; i < (int)numFolders; i++) {\n                 if (crcsDefined.get(i)) {\n                     folders[i].hasCrc = true;\n-                    folders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n+                    folders[i].crc = 0xffffFFFFL & header.getInt();\n                 } else {\n                     folders[i].hasCrc = false;\n                 }\n             }\n \n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid != NID.kEnd) {\n         }\n     }\n \n-    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n+    private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         for (final Folder folder : archive.folders) {\n             folder.numUnpackSubStreams = 1;\n         }\n         int totalUnpackStreams = archive.folders.length;\n \n-        int nid = header.readUnsignedByte();\n+        int nid = getUnsignedByte(header);\n         if (nid == NID.kNumUnpackStream) {\n             totalUnpackStreams = 0;\n             for (final Folder folder : archive.folders) {\n                 folder.numUnpackSubStreams = (int)numStreams;\n                 totalUnpackStreams += numStreams;\n             }\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n             subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n         }\n         if (nid == NID.kSize) {\n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         int numDigests = 0;\n             final long[] missingCrcs = new long[numDigests];\n             for (int i = 0; i < numDigests; i++) {\n                 if (hasMissingCrc.get(i)) {\n-                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n+                    missingCrcs[i] = 0xffffFFFFL & header.getInt();\n                 }\n             }\n             int nextCrc = 0;\n                 }\n             }\n \n-            nid = header.readUnsignedByte();\n+            nid = getUnsignedByte(header);\n         }\n \n         if (nid != NID.kEnd) {\n         archive.subStreamsInfo = subStreamsInfo;\n     }\n \n-    private Folder readFolder(final DataInput header) throws IOException {\n+    private Folder readFolder(final ByteBuffer header) throws IOException {\n         final Folder folder = new Folder();\n \n         final long numCoders = readUint64(header);\n         long totalOutStreams = 0;\n         for (int i = 0; i < coders.length; i++) {\n             coders[i] = new Coder();\n-            final int bits = header.readUnsignedByte();\n+            final int bits = getUnsignedByte(header);\n             final int idSize = bits & 0xf;\n             final boolean isSimple = (bits & 0x10) == 0;\n             final boolean hasAttributes = (bits & 0x20) != 0;\n             final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n \n             coders[i].decompressionMethodId = new byte[idSize];\n-            header.readFully(coders[i].decompressionMethodId);\n+            header.get(coders[i].decompressionMethodId);\n             if (isSimple) {\n                 coders[i].numInStreams = 1;\n                 coders[i].numOutStreams = 1;\n             if (hasAttributes) {\n                 final long propertiesSize = readUint64(header);\n                 coders[i].properties = new byte[(int)propertiesSize];\n-                header.readFully(coders[i].properties);\n+                header.get(coders[i].properties);\n             }\n             // would need to keep looping as above:\n             while (moreAlternativeMethods) {\n         return folder;\n     }\n \n-    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n-        final int areAllDefined = header.readUnsignedByte();\n+    private BitSet readAllOrBits(final ByteBuffer header, final int size) throws IOException {\n+        final int areAllDefined = getUnsignedByte(header);\n         final BitSet bits;\n         if (areAllDefined != 0) {\n             bits = new BitSet(size);\n         return bits;\n     }\n \n-    private BitSet readBits(final DataInput header, final int size) throws IOException {\n+    private BitSet readBits(final ByteBuffer header, final int size) throws IOException {\n         final BitSet bits = new BitSet(size);\n         int mask = 0;\n         int cache = 0;\n         for (int i = 0; i < size; i++) {\n             if (mask == 0) {\n                 mask = 0x80;\n-                cache = header.readUnsignedByte();\n+                cache = getUnsignedByte(header);\n             }\n             bits.set(i, (cache & mask) != 0);\n             mask >>>= 1;\n         return bits;\n     }\n \n-    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n+    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {\n         final long numFiles = readUint64(header);\n         final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n         for (int i = 0; i < files.length; i++) {\n         BitSet isEmptyFile = null; \n         BitSet isAnti = null;\n         while (true) {\n-            final int propertyType = header.readUnsignedByte();\n+            final int propertyType = getUnsignedByte(header);\n             if (propertyType == 0) {\n                 break;\n             }\n                     break;\n                 }\n                 case NID.kName: {\n-                    final int external = header.readUnsignedByte();\n+                    final int external = getUnsignedByte(header);\n                     if (external != 0) {\n                         throw new IOException(\"Not implemented\");\n                     }\n                         throw new IOException(\"File names length invalid\");\n                     }\n                     final byte[] names = new byte[(int)(size - 1)];\n-                    header.readFully(names);\n+                    header.get(names);\n                     int nextFile = 0;\n                     int nextName = 0;\n                     for (int i = 0; i < names.length; i += 2) {\n                 }\n                 case NID.kCTime: {\n                     final BitSet timesDefined = readAllOrBits(header, files.length);\n-                    final int external = header.readUnsignedByte();\n+                    final int external = getUnsignedByte(header);\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n                     for (int i = 0; i < files.length; i++) {\n                         files[i].setHasCreationDate(timesDefined.get(i));\n                         if (files[i].getHasCreationDate()) {\n-                            files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n+                            files[i].setCreationDate(header.getLong());\n                         }\n                     }\n                     break;\n                 }\n                 case NID.kATime: {\n                     final BitSet timesDefined = readAllOrBits(header, files.length);\n-                    final int external = header.readUnsignedByte();\n+                    final int external = getUnsignedByte(header);\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n                     for (int i = 0; i < files.length; i++) {\n                         files[i].setHasAccessDate(timesDefined.get(i));\n                         if (files[i].getHasAccessDate()) {\n-                            files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n+                            files[i].setAccessDate(header.getLong());\n                         }\n                     }\n                     break;\n                 }\n                 case NID.kMTime: {\n                     final BitSet timesDefined = readAllOrBits(header, files.length);\n-                    final int external = header.readUnsignedByte();\n+                    final int external = getUnsignedByte(header);\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n                     for (int i = 0; i < files.length; i++) {\n                         files[i].setHasLastModifiedDate(timesDefined.get(i));\n                         if (files[i].getHasLastModifiedDate()) {\n-                            files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n+                            files[i].setLastModifiedDate(header.getLong());\n                         }\n                     }\n                     break;\n                 }\n                 case NID.kWinAttributes: {\n                     final BitSet attributesDefined = readAllOrBits(header, files.length);\n-                    final int external = header.readUnsignedByte();\n+                    final int external = getUnsignedByte(header);\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n                     }\n                     for (int i = 0; i < files.length; i++) {\n                         files[i].setHasWindowsAttributes(attributesDefined.get(i));\n                         if (files[i].getHasWindowsAttributes()) {\n-                            files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n+                            files[i].setWindowsAttributes(header.getInt());\n                         }\n                     }\n                     break;\n         return getCurrentStream().read(b, off, len);\n     }\n \n-    private static long readUint64(final DataInput in) throws IOException {\n+    private static long readUint64(final ByteBuffer in) throws IOException {\n         // long rather than int as it might get shifted beyond the range of an int\n-        final long firstByte = in.readUnsignedByte();\n+        final long firstByte = getUnsignedByte(in);\n         int mask = 0x80;\n         long value = 0;\n         for (int i = 0; i < 8; i++) {\n             if ((firstByte & mask) == 0) {\n                 return value | ((firstByte & (mask - 1)) << (8 * i));\n             }\n-            final long nextByte = in.readUnsignedByte();\n+            final long nextByte = getUnsignedByte(in);\n             value |= nextByte << (8 * i);\n             mask >>>= 1;\n         }\n         return value;\n+    }\n+\n+    private static int getUnsignedByte(ByteBuffer buf) {\n+        return buf.get() & 0xff;\n     }\n \n     /**\n         return true;\n     }\n \n-    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n+    private static long skipBytesFully(final ByteBuffer input, long bytesToSkip) throws IOException {\n         if (bytesToSkip < 1) {\n             return 0;\n         }\n-        long skipped = 0;\n-        while (bytesToSkip > Integer.MAX_VALUE) {\n-            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n-            if (skippedNow == 0) {\n-                return skipped;\n-            }\n-            skipped += skippedNow;\n-            bytesToSkip -= skippedNow;\n-        }\n-        while (bytesToSkip > 0) {\n-            final int skippedNow = input.skipBytes((int) bytesToSkip);\n-            if (skippedNow == 0) {\n-                return skipped;\n-            }\n-            skipped += skippedNow;\n-            bytesToSkip -= skippedNow;\n-        }\n-        return skipped;\n+        int current = input.position();\n+        int maxSkip = input.remaining();\n+        if (maxSkip < bytesToSkip) {\n+            bytesToSkip = maxSkip;\n+        }\n+        input.position(current + (int) bytesToSkip);\n+        return bytesToSkip;\n     }\n \n     private void readFully(ByteBuffer buf) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n import java.io.IOException;\n import java.io.OutputStream;\n import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n \n         final long headerPosition = channel.position();\n \n-        // TODO use a properly sized buffer for both write operations\n-        // and re-write writeHeader and the startHeaderStream\n-        // operations to work on ByteBuffer directly.\n         final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n         final DataOutputStream header = new DataOutputStream(headerBaos);\n \n         channel.write(ByteBuffer.wrap(headerBytes));\n \n         final CRC32 crc32 = new CRC32();\n-\n+        crc32.update(headerBytes);\n+\n+        ByteBuffer bb = ByteBuffer.allocate(SevenZFile.sevenZSignature.length\n+                                            + 2 /* version */\n+                                            + 4 /* start header CRC */\n+                                            + 8 /* next header position */\n+                                            + 8 /* next header length */\n+                                            + 4 /* next header CRC */)\n+            .order(ByteOrder.LITTLE_ENDIAN);\n         // signature header\n         channel.position(0);\n-        ByteBuffer bb = ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2);\n         bb.put(SevenZFile.sevenZSignature);\n         // version\n         bb.put((byte) 0).put((byte) 2);\n-        bb.flip();\n-        channel.write(bb);\n+\n+        // placeholder for start header CRC\n+        bb.putInt(0);\n \n         // start header\n-        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n-        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n-        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n-        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n+        bb.putLong(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE)\n+            .putLong(0xffffFFFFL & headerBytes.length)\n+            .putInt((int) crc32.getValue());\n         crc32.reset();\n-        crc32.update(headerBytes);\n-        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n-        startHeaderStream.flush();\n-        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n-        crc32.reset();\n-        crc32.update(startHeaderBytes);\n-        bb = ByteBuffer.allocate(startHeaderBytes.length + 4);\n-        bb.putInt(Integer.reverseBytes((int) crc32.getValue()));\n-        bb.put(startHeaderBytes);\n+        crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);\n+        bb.putInt(SevenZFile.sevenZSignature.length + 2, (int) crc32.getValue());\n         bb.flip();\n         channel.write(bb);\n     }\n     }\n \n     private class OutputStreamWrapper extends OutputStream {\n+        private static final int BUF_SIZE = 8192;\n+        private final ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);\n         @Override\n         public void write(final int b) throws IOException {\n-            // TODO use a cached ByteBuffer\n-            channel.write(ByteBuffer.wrap(new byte[] {(byte) b }));\n+            buffer.clear();\n+            buffer.put((byte) b).flip();\n+            channel.write(buffer);\n             compressedCrc32.update(b);\n             fileBytesWritten++;\n         }\n         @Override\n         public void write(final byte[] b, final int off, final int len)\n             throws IOException {\n-            // TODO use a cached ByteBuffer\n-            channel.write(ByteBuffer.wrap(b, off, len));\n+            if (len > BUF_SIZE) {\n+                channel.write(ByteBuffer.wrap(b, off, len));\n+            } else {\n+                buffer.clear();\n+                buffer.put(b, off, len).flip();\n+                channel.write(buffer);\n+            }\n             compressedCrc32.update(b, off, len);\n             fileBytesWritten += len;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n             final OffsetEntry offsetEntry = ze.getOffsetEntry();\n             final long offset = offsetEntry.headerOffset;\n             archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n-            SHORT_BBUF.rewind();\n-            IOUtils.readFully(archive, SHORT_BBUF);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n+            WORD_BBUF.flip();\n+            WORD_BBUF.get(SHORT_BUF);\n             final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n-            SHORT_BBUF.rewind();\n-            IOUtils.readFully(archive, SHORT_BBUF);\n+            WORD_BBUF.get(SHORT_BUF);\n             final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n             skipBytes(fileNameLen);\n             final byte[] localExtraData = new byte[extraFieldLen];", "timestamp": 1476353563, "metainfo": ""}