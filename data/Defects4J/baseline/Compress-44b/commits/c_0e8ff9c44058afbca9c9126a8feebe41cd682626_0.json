{"sha": "0e8ff9c44058afbca9c9126a8feebe41cd682626", "log": "COMPRESS-382 and COMPRESS-386 -- take 3, create static MemoryLimit and remove new ctors.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/MemoryLimit.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+/**\n+ *\n+ * During initialization, some streams compute expected memory use.\n+ * They should check this value and throw a MemoryLimitException if the\n+ * estimated memory use is greater that {@link MemoryLimit#MEMORY_LIMIT_IN_KB}.\n+ * <p/>\n+ * During compression/archiving, streams can allocate byte arrays based\n+ * on a value read in from the stream.  Corrupt files can cause compressors/archivers\n+ * to cause {@link OutOfMemoryError}s.  Compressors/archivers should check\n+ * this maximum threshold before allocating memory and throw a {@link MemoryLimitException}\n+ * if the allocation would exceed this limit.\n+ * <p/>\n+ * To avoid changes in legacy behavior, {@link MemoryLimit#MEMORY_LIMIT_IN_KB}\n+ * is set to {@link MemoryLimit#NO_LIMIT}.  However, in applications that might\n+ * encounter untrusted/corrupt files, we encourage setting the limit to something\n+ * reasonable for the application.\n+ * <p/>\n+ * As of 1.14, this limit should be observed when instantiating CompressorStreams.\n+ * Work remains to propagate memory limit checks throughout the codebase.\n+ *\n+ * @since 1.14\n+ */\n+public class MemoryLimit {\n+\n+    public static final int NO_LIMIT = -1;\n+    public static volatile int MEMORY_LIMIT_IN_KB = NO_LIMIT;\n+\n+    /**\n+     * Sets {@link MemoryLimit#MEMORY_LIMIT_IN_KB}.\n+     * @param memoryLimitInKb limit in kilobytes\n+     *\n+     * @throws IllegalArgumentException if value is &lt; -1\n+     */\n+    public static void setMemoryLimitInKb(int memoryLimitInKb) {\n+        if (memoryLimitInKb < -1) {\n+            throw new IllegalArgumentException(\"MemoryLimit must be > -2\");\n+        }\n+        //TODO: do we want to set an absolute upper limit?!\n+        MEMORY_LIMIT_IN_KB = memoryLimitInKb;\n+    }\n+\n+    public static int getMemoryLimitInKb() {\n+        return MEMORY_LIMIT_IN_KB;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      */\n     private volatile boolean decompressConcatenated = false;\n \n-    private final int memoryLimitInKb;\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n         this.decompressUntilEOF = null;\n-        this.memoryLimitInKb = -1;\n-    }\n-\n-    /**\n-     * Create an instance with the provided decompress Concatenated option.\n-     *\n-     * @param decompressUntilEOF\n-     *            if true, decompress until the end of the input; if false, stop\n-     *            after the first stream and leave the input position to point\n-     *            to the next byte after the stream. This setting applies to the\n-     *            gzip, bzip2 and xz formats only.\n-     *\n-     * @param memoryLimitInKb\n-     *            Some streams require allocation of potentially significant\n-     *            byte arrays/tables, and they can offer checks to prevent OOMs\n-     *            on corrupt files.  Set the maximum allowed memory allocation in KBs.\n-     *\n-     * @since 1.14\n-     */\n-    public CompressorStreamFactory(final boolean decompressUntilEOF, final int memoryLimitInKb) {\n-        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the\n-        // current value\n-        this.decompressConcatenated = decompressUntilEOF;\n-        this.memoryLimitInKb = memoryLimitInKb;\n-    }\n-\n+    }\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n-        this(decompressUntilEOF, -1);\n+        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n+        this.decompressConcatenated = decompressUntilEOF;\n     }\n \n     /**\n                 if (!XZUtils.isXZCompressionAvailable()) {\n                     throw new CompressorException(\"XZ compression is not available.\");\n                 }\n-                return new XZCompressorInputStream(in, actualDecompressConcatenated, memoryLimitInKb);\n+                return new XZCompressorInputStream(in, actualDecompressConcatenated);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                return new LZMACompressorInputStream(in, memoryLimitInKb);\n+                return new LZMACompressorInputStream(in);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                return new ZCompressorInputStream(in, memoryLimitInKb);\n+                return new ZCompressorInputStream(in);\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.LZMAInputStream;\n \n public class LZMACompressorInputStream extends CompressorInputStream {\n     private final InputStream in;\n \n-    public LZMACompressorInputStream(final InputStream inputStream)\n-            throws IOException {\n-        in = new LZMAInputStream(inputStream, -1);\n-    }\n-\n     /**\n      * Creates a new input stream that decompresses LZMA-compressed data\n      * from the specified input stream.\n      *\n      * @param       inputStream where to read the compressed data\n      *\n-     * @param       memoryLimitInKb calculated memory use threshold.  Throws MemoryLimitException\n-     *                            if calculate memory use is above this threshold\n-     *\n      * @throws      IOException if the input is not in the .lzma format,\n      *                          the input is corrupt or truncated, the .lzma\n      *                          headers specify sizes that are not supported\n-     *                          by this implementation, or the underlying\n-     *                          <code>inputStream</code> throws an exception\n+     *                          by this implementation, the underlying\n+     *                          <code>inputStream</code> throws an exception or\n+     *                          if the calculated memory usage\n+     *                          is &gt; {@link MemoryLimit#MEMORY_LIMIT_IN_KB}.\n      *\n      * @since 1.14\n      */\n-    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n+    public LZMACompressorInputStream(final InputStream inputStream)\n             throws IOException {\n         try {\n-            in = new LZMAInputStream(inputStream, memoryLimitInKb);\n+            in = new LZMAInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n         } catch (org.tukaani.xz.MemoryLimitException e) {\n             //convert to commons-compress exception\n             throw new MemoryLimitException(\"exceeded calculated memory limit\", e);\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.XZ;\n import org.tukaani.xz.SingleXZInputStream;\n     public XZCompressorInputStream(final InputStream inputStream,\n                                    final boolean decompressConcatenated)\n             throws IOException {\n-        this(inputStream, decompressConcatenated, -1);\n-    }\n \n-    /**\n-     * Creates a new input stream that decompresses XZ-compressed data\n-     * from the specified input stream.\n-     *\n-     * @param       inputStream where to read the compressed data\n-     * @param       decompressConcatenated\n-     *                          if true, decompress until the end of the\n-     *                          input; if false, stop after the first .xz\n-     *                          stream and leave the input position to point\n-     *                          to the next byte after the .xz stream\n-     * @param       memoryLimitInKb memory limit used when reading blocks.  If\n-     *                          the estimated memory limit is exceeded on {@link #read()},\n-     *                          a {@link MemoryLimitException} is thrown.\n-     *\n-     * @throws      IOException if the input is not in the .xz format,\n-     *                          the input is corrupt or truncated, the .xz\n-     *                          headers specify options that are not supported\n-     *                          by this implementation,\n-     *                          or the underlying <code>inputStream</code> throws an exception\n-     *\n-     * @since 1.14\n-     */\n-    public XZCompressorInputStream(InputStream inputStream,\n-                                   boolean decompressConcatenated, int memoryLimitInKb)\n-            throws IOException {\n         if (decompressConcatenated) {\n-            in = new XZInputStream(inputStream, memoryLimitInKb);\n+            in = new XZInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n         } else {\n-            in = new SingleXZInputStream(inputStream, memoryLimitInKb);\n+            in = new SingleXZInputStream(inputStream, MemoryLimit.getMemoryLimitInKb());\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n+import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.compressors.lzw.LZWInputStream;\n \n /**\n     private final int maxCodeSize;\n     private long totalCodesRead = 0;\n \n-    public ZCompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n-            throws IOException {\n+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         final int firstByte = (int) in.readBits(8);\n         final int secondByte = (int) in.readBits(8);\n         if (blockMode) {\n             setClearCode(DEFAULT_CODE_SIZE);\n         }\n-        initializeTables(maxCodeSize, memoryLimitInKb);\n+        initializeTables(maxCodeSize, MemoryLimit.getMemoryLimitInKb());\n         clearEntries();\n-    }\n-\n-    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n-        this(inputStream, -1);\n     }\n     \n     private void clearEntries() {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/MemoryLimitTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.compress;\n+\n+import org.junit.Test;\n+\n+public class MemoryLimitTest {\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testRangeCheck() throws Exception {\n+        MemoryLimit.setMemoryLimitInKb(-2);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n import org.junit.Test;\n \n @SuppressWarnings(\"deprecation\") // deliberately tests setDecompressConcatenated\n         }\n     }\n \n+    @Before\n+    public void setUp() {\n+        //make sure to reset this before each test\n+        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        //make sure this is really, truly reset after all the tests\n+        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n+    }\n+\n     private final TestData[] tests = {\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factoryTrue, true),\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factorySetTrue, true),\n         //This test is here instead of the xz unit test to make sure\n         //that the parameter is properly passed via the CompressorStreamFactory\n         try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n-            int c = compressorIs.read();\n+            compressorIs.read();\n         }\n     }\n \n     }\n \n     private InputStream getStreamFor(final String fileName, final int memoryLimitInKb) throws Exception {\n-        CompressorStreamFactory fac = new CompressorStreamFactory(true,\n-                memoryLimitInKb);\n+        MemoryLimit.setMemoryLimitInKb(memoryLimitInKb);\n+        CompressorStreamFactory fac = new CompressorStreamFactory(true);\n         InputStream is = new BufferedInputStream(\n                 new FileInputStream(getFile(fileName)));\n         try {", "timestamp": 1493082395, "metainfo": ""}