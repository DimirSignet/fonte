{"sha": "f015344879f1bc3505bc616fc7ae517cf9f60838", "log": "COMPRESS-367 Throw ZipException on invalid entry with ZipArchiveInputStream  ZipArchiveInputStream.getNextZipEntry() throws a ZipException rather than returning null if an invalid entry is encountered in order to differentiate between \"no more entries\" and \"error\" conditions.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n             hitCentralDirectory = true;\n             skipRemainderOfArchive();\n+            return null;\n         }\n         if (!sig.equals(ZipLong.LFH_SIG)) {\n-            return null;\n+            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n         }\n \n         int off = WORD;\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n import java.util.Enumeration;\n import java.util.List;\n import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.zip.Zip64Mode;\n         final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n \n         final List<String> results = new ArrayList<>();\n+        final List<ZipException> expectedExceptions = new ArrayList<>();\n \n         final InputStream is = new FileInputStream(input);\n         ArchiveInputStream in = null;\n             in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n \n             ZipArchiveEntry entry = null;\n-            while((entry = (ZipArchiveEntry)in.getNextEntry()) != null) {\n+            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n                 results.add(entry.getName());\n \n                 final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n-                ZipArchiveEntry nestedEntry = null;\n-                while((nestedEntry = (ZipArchiveEntry)nestedIn.getNextEntry()) != null) {\n-                    results.add(nestedEntry.getName());\n+                try {\n+                    ZipArchiveEntry nestedEntry = null;\n+                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n+                        results.add(nestedEntry.getName());\n+                    }\n+                } catch (ZipException ex) {\n+                    // expected since you cannot create a final ArchiveInputStream from test3.xml\n+                    expectedExceptions.add(ex);\n                 }\n-               // nested stream must not be closed here\n+                // nested stream must not be closed here\n             }\n         } finally {\n             if (in != null) {\n         }\n         is.close();\n \n-        results.contains(\"NestedArchiv.zip\");\n-        results.contains(\"test1.xml\");\n-        results.contains(\"test2.xml\");\n-        results.contains(\"test3.xml\");\n+        assertTrue(results.contains(\"NestedArchiv.zip\"));\n+        assertTrue(results.contains(\"test1.xml\"));\n+        assertTrue(results.contains(\"test2.xml\"));\n+        assertTrue(results.contains(\"test3.xml\"));\n+        assertEquals(1, expectedExceptions.size());\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n+import java.util.zip.ZipException;\n \n import org.apache.commons.compress.utils.IOUtils;\n import org.junit.Test;\n         }\n     }\n \n+    /**\n+     * <code>getNextZipEntry()</code> should throw a <code>ZipException</code> rather than return\n+     * <code>null</code> when an unexpected structure is encountered.\n+     */\n+    @Test\n+    public void testThrowOnInvalidEntry() throws Exception {\n+        final InputStream is = ZipArchiveInputStreamTest.class\n+                .getResourceAsStream(\"/invalid-zip.zip\");\n+        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n+\n+        try {\n+            zip.getNextZipEntry();\n+            fail(\"IOException expected\");\n+        } catch (ZipException expected) {\n+            assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n+        } finally {\n+            zip.close();\n+        }\n+    }\n+\n     private static byte[] readEntry(ZipArchiveInputStream zip, ZipArchiveEntry zae) throws IOException {\n         final int len = (int)zae.getSize();\n         final byte[] buff = new byte[len];", "timestamp": 1481320902, "metainfo": ""}