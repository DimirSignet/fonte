{"sha": "8c34dc5576759fb36d4ac1fa7dcfea3fb5907ca5", "log": "count bytes read in ArjArchiveInputStream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n         System.out.println(message);\n     }\n \n-    private static int read16(final DataInputStream in) throws IOException {\n+    private int read8(final DataInputStream in) throws IOException {\n+        int value = in.readUnsignedByte();\n+        count(1);\n+        return value;\n+    }\n+\n+    private int read16(final DataInputStream in) throws IOException {\n         final int value = in.readUnsignedShort();\n+        count(2);\n         return Integer.reverseBytes(value) >>> 16;\n+    }\n+\n+    private int read32(final DataInputStream in) throws IOException {\n+        final int value = in.readInt();\n+        count(4);\n+        return Integer.reverseBytes(value);\n     }\n     \n     private String readString(final DataInputStream in) throws IOException {\n         return new String(buffer.toByteArray(), charset);\n     }\n     \n+    private void readFully(final DataInputStream in, byte[] b)\n+        throws IOException {\n+        in.readFully(b);\n+        count(b.length);\n+    }\n+    \n     private byte[] readHeader() throws IOException {\n         boolean found = false;\n         byte[] basicHeaderBytes = null;\n         do {\n             int first = 0;\n-            int second = in.readUnsignedByte();\n+            int second = read8(in);\n             do {\n                 first = second;\n-                second = in.readUnsignedByte();\n+                second = read8(in);\n             } while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\n             final int basicHeaderSize = read16(in);\n             if (basicHeaderSize == 0) {\n             }\n             if (basicHeaderSize <= 2600) {\n                 basicHeaderBytes = new byte[basicHeaderSize];\n-                in.readFully(basicHeaderBytes);\n-                final int basicHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+                readFully(in, basicHeaderBytes);\n+                final int basicHeaderCrc32 = read32(in);\n                 final CRC32 crc32 = new CRC32();\n                 crc32.update(basicHeaderBytes);\n                 if (basicHeaderCrc32 == (int)crc32.getValue()) {\n         mainHeader.securityVersion = firstHeader.readUnsignedByte();\n         mainHeader.fileType = firstHeader.readUnsignedByte();\n         mainHeader.reserved = firstHeader.readUnsignedByte();\n-        mainHeader.dateTimeCreated = Integer.reverseBytes(firstHeader.readInt());\n-        mainHeader.dateTimeModified = Integer.reverseBytes(firstHeader.readInt());\n-        mainHeader.archiveSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n-        mainHeader.securityEnvelopeFilePosition = Integer.reverseBytes(firstHeader.readInt());\n+        mainHeader.dateTimeCreated = read32(firstHeader);\n+        mainHeader.dateTimeModified = read32(firstHeader);\n+        mainHeader.archiveSize = 0xffffFFFFL & read32(firstHeader);\n+        mainHeader.securityEnvelopeFilePosition = read32(firstHeader);\n         mainHeader.fileSpecPosition = read16(firstHeader);\n         mainHeader.securityEnvelopeLength = read16(firstHeader);\n+        pushedBackBytes(20); // count has already counted them via readFully\n         mainHeader.encryptionVersion = firstHeader.readUnsignedByte();\n         mainHeader.lastChapter = firstHeader.readUnsignedByte();\n         \n         final  int extendedHeaderSize = read16(in);\n         if (extendedHeaderSize > 0) {\n             mainHeader.extendedHeaderBytes = new byte[extendedHeaderSize];\n-            in.readFully(mainHeader.extendedHeaderBytes);\n-            final int extendedHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+            readFully(in, mainHeader.extendedHeaderBytes);\n+            final int extendedHeaderCrc32 = read32(in);\n             final CRC32 crc32 = new CRC32();\n             crc32.update(mainHeader.extendedHeaderBytes);\n             if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n         localFileHeader.method = firstHeader.readUnsignedByte();\n         localFileHeader.fileType = firstHeader.readUnsignedByte();\n         localFileHeader.reserved = firstHeader.readUnsignedByte();\n-        localFileHeader.dateTimeModified = Integer.reverseBytes(firstHeader.readInt());\n-        localFileHeader.compressedSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n-        localFileHeader.originalSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n-        localFileHeader.originalCrc32 = Integer.reverseBytes(firstHeader.readInt());\n+        localFileHeader.dateTimeModified = read32(firstHeader);\n+        localFileHeader.compressedSize = 0xffffFFFFL & read32(firstHeader);\n+        localFileHeader.originalSize = 0xffffFFFFL & read32(firstHeader);\n+        localFileHeader.originalCrc32 = read32(firstHeader);\n         localFileHeader.fileSpecPosition = read16(firstHeader);\n         localFileHeader.fileAccessMode = read16(firstHeader);\n+        pushedBackBytes(20);\n         localFileHeader.firstChapter = firstHeader.readUnsignedByte();\n         localFileHeader.lastChapter = firstHeader.readUnsignedByte();\n         \n         try {\n-            localFileHeader.extendedFilePosition = Integer.reverseBytes(firstHeader.readInt());\n-            localFileHeader.dateTimeAccessed = Integer.reverseBytes(firstHeader.readInt());\n-            localFileHeader.dateTimeCreated = Integer.reverseBytes(firstHeader.readInt());\n-            localFileHeader.originalSizeEvenForVolumes = Integer.reverseBytes(firstHeader.readInt());\n+            localFileHeader.extendedFilePosition = read32(firstHeader);\n+            localFileHeader.dateTimeAccessed = read32(firstHeader);\n+            localFileHeader.dateTimeCreated = read32(firstHeader);\n+            localFileHeader.originalSizeEvenForVolumes = read32(firstHeader);\n+            pushedBackBytes(16);\n         } catch (EOFException eof) {\n         }\n         \n         int extendedHeaderSize;\n         while ((extendedHeaderSize = read16(in)) > 0) {\n             final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n-            in.readFully(extendedHeaderBytes);\n-            final int extendedHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+            readFully(in, extendedHeaderBytes);\n+            final int extendedHeaderCrc32 = read32(in);\n             final CRC32 crc32 = new CRC32();\n             crc32.update(extendedHeaderBytes);\n             if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n     }\n     \n     @Override\n-    public int read() throws IOException {\n-        if (currentLocalFileHeader.method != LocalFileHeader.Methods.STORED) {\n-            throw new IOException(\"Unsupported compression method \" + currentLocalFileHeader.method);\n-        }\n-        return currentInputStream.read();\n-    }\n-    \n-    @Override\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (currentLocalFileHeader.method != LocalFileHeader.Methods.STORED) {\n             throw new IOException(\"Unsupported compression method \" + currentLocalFileHeader.method);", "timestamp": 1376768770, "metainfo": ""}