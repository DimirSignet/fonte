{"sha": "4e19109ad8004d94a7331c108ac555a650f85e47", "log": "Add an UnshrinkingInputStream based on ZCompressorInputStream, to decompress ZIP method 1.    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * Input stream that decompresses ZIP method 1 (unshrinking). A variation of the LZW algorithm, with some twists.\n+ * @NotThreadSafe\n+ * @since 1.7\n+ */\n+public class UnshrinkingInputStream extends CompressorInputStream {\n+    private final InputStream in;\n+    private final int clearCode;\n+    private final int MAX_CODE_SIZE = 13;\n+    private int codeSize = 9;\n+    private int bitsCached = 0;\n+    private int bitsCachedSize = 0;\n+    private int previousCode = -1;\n+    private int tableSize = 0;\n+    private final int[] prefixes;\n+    private final byte[] characters;\n+    private final boolean[] isUsed;\n+    private final byte[] outputStack;\n+    private int outputStackLocation;\n+    \n+    public UnshrinkingInputStream(InputStream inputStream) throws IOException {\n+        this.in = inputStream;\n+        clearCode = (1 << (codeSize - 1));\n+        final int maxTableSize = 1 << MAX_CODE_SIZE;\n+        prefixes = new int[maxTableSize];\n+        characters = new byte[maxTableSize];\n+        isUsed = new boolean[maxTableSize];\n+        outputStack = new byte[maxTableSize];\n+        outputStackLocation = maxTableSize;\n+        for (int i = 0; i < (1 << 8); i++) {\n+            prefixes[i] = -1;\n+            characters[i] = (byte)i;\n+            isUsed[i] = true;\n+        }\n+        tableSize = clearCode + 1;\n+    }\n+    \n+    public void close() throws IOException {\n+        in.close();\n+    }\n+    \n+    private int readNextCode() throws IOException {\n+        while (bitsCachedSize < codeSize) {\n+            final int nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            bitsCached |= (nextByte << bitsCachedSize);\n+            bitsCachedSize += 8;\n+        }\n+        final int mask = (1 << codeSize) - 1;\n+        final int code = (bitsCached & mask);\n+        bitsCached >>>= codeSize;\n+        bitsCachedSize -= codeSize;\n+        return code;\n+    }\n+    \n+    private int addEntry(int previousCode, byte character) throws IOException {\n+        final int maxTableSize = 1 << MAX_CODE_SIZE;\n+        while ((tableSize < maxTableSize) && isUsed[tableSize]) {\n+            tableSize++;\n+        }\n+        if (tableSize < maxTableSize) {\n+            final int index = tableSize;\n+            prefixes[tableSize] = previousCode;\n+            characters[tableSize] = character;\n+            isUsed[tableSize] = true;\n+            tableSize++;\n+            return index;\n+        } else {\n+            return -1;\n+        }\n+    }\n+    \n+    private void partialClear() throws IOException {\n+        final boolean[] isParent = new boolean[1 << MAX_CODE_SIZE];\n+        for (int i = 0; i < isUsed.length; i++) {\n+            if (isUsed[i] && prefixes[i] != -1) {\n+                isParent[prefixes[i]] = true;\n+            }\n+        }\n+        for (int i = clearCode + 1; i < isParent.length; i++) {\n+            if (!isParent[i]) {\n+                isUsed[i] = false;\n+                prefixes[i] = -1;\n+            }\n+        }\n+    }\n+\n+    private int decompressNextSymbol() throws IOException {\n+        //\n+        //                   table entry    table entry\n+        //                  _____________   _____\n+        //    table entry  /             \\ /     \\\n+        //    ____________/               \\       \\\n+        //   /           / \\             / \\       \\\n+        //  +---+---+---+---+---+---+---+---+---+---+\n+        //  | . | . | . | . | . | . | . | . | . | . |\n+        //  +---+---+---+---+---+---+---+---+---+---+\n+        //  |<--------->|<------------->|<----->|<->|\n+        //     symbol        symbol      symbol  symbol\n+        //\n+        final int code = readNextCode();\n+        if (code < 0) {\n+            return -1;\n+        } else if (code == clearCode) {\n+            final int subCode = readNextCode();\n+            if (subCode < 0) {\n+                throw new IOException(\"Unexpected EOF;\");\n+            } else if (subCode == 1) {\n+                if (codeSize < MAX_CODE_SIZE) {\n+                    codeSize++;\n+                } else {\n+                    throw new IOException(\"Attempt to increase code size beyond maximum\");\n+                }\n+            } else if (subCode == 2) {\n+                partialClear();\n+                tableSize = clearCode + 1;\n+            } else {\n+                throw new IOException(\"Invalid clear code subcode \" + subCode);\n+            }\n+            return 0;\n+        } else {\n+            boolean addedUnfinishedEntry = false;\n+            final int effectiveCode;\n+            if (isUsed[code]) {\n+                effectiveCode = code;\n+            } else {\n+                // must be a repeat of the previous entry we haven't added yet\n+                if (previousCode == -1) {\n+                    // ... which isn't possible for the very first code\n+                    throw new IOException(\"The first code can't be a reference to its preceding code\");\n+                }\n+                byte firstCharacter = 0;\n+                for (int last = previousCode; last >= 0; last = prefixes[last]) {\n+                    firstCharacter = characters[last];\n+                }\n+                effectiveCode = addEntry(previousCode, firstCharacter);\n+                addedUnfinishedEntry = true;\n+            }\n+            for (int entry = effectiveCode; entry >= 0; entry = prefixes[entry]) {\n+                outputStack[--outputStackLocation] = characters[entry];\n+            }\n+            if (previousCode != -1 && !addedUnfinishedEntry) {\n+                addEntry(previousCode, outputStack[outputStackLocation]);\n+            }\n+            previousCode = code;\n+            return outputStackLocation;\n+        }\n+    }\n+    \n+    public int read() throws IOException {\n+        byte[] b = new byte[1];\n+        int ret;\n+        while ((ret = read(b)) == 0) {\n+        }\n+        if (ret < 0) {\n+            return ret;\n+        }\n+        return 0xff & b[0];\n+    }\n+    \n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int bytesRead = 0;\n+        int remainingInStack = outputStack.length - outputStackLocation;\n+        if (remainingInStack > 0) {\n+            int maxLength = Math.min(remainingInStack, len);\n+            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+            outputStackLocation += maxLength;\n+            off += maxLength;\n+            len -= maxLength;\n+            bytesRead += maxLength;\n+        }\n+        while (len > 0) {\n+            int result = decompressNextSymbol();\n+            if (result < 0) {\n+                if (bytesRead > 0) {\n+                    count(bytesRead);\n+                    return bytesRead;\n+                } else {\n+                    return result;\n+                }\n+            }\n+            remainingInStack = outputStack.length - outputStackLocation;\n+            if (remainingInStack > 0) {\n+                int maxLength = Math.min(remainingInStack, len);\n+                System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+                outputStackLocation += maxLength;\n+                off += maxLength;\n+                len -= maxLength;\n+                bytesRead += maxLength;\n+            }\n+        }\n+        count(bytesRead);\n+        return bytesRead;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n         long start = offsetEntry.dataOffset;\n         BoundedInputStream bis =\n             new BoundedInputStream(start, ze.getCompressedSize());\n-        switch (ze.getMethod()) {\n-            case ZipEntry.STORED:\n+        switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n+            case STORED:\n                 return bis;\n-            case ZipEntry.DEFLATED:\n+            case UNSHRINKING:\n+                return new UnshrinkingInputStream(bis);\n+            case DEFLATED:\n                 bis.addDummy();\n                 final Inflater inflater = new Inflater(true);\n                 return new InflaterInputStream(bis, inflater) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n      */\n     private static boolean supportsMethodOf(ZipArchiveEntry entry) {\n         return entry.getMethod() == ZipEntry.STORED\n+            || entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n             || entry.getMethod() == ZipEntry.DEFLATED;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n                 // must be a repeat of the previous entry we haven't added yet\n                 if (previousCode == -1) {\n                     // ... which isn't possible for the very first code\n-                    throw new IOException(\"The first code can't be a reference to code before itself\");\n+                    throw new IOException(\"The first code can't be a reference to its preceding code\");\n                 }\n                 byte firstCharacter = 0;\n                 for (int last = previousCode; last >= 0; last = prefixes[last]) {", "timestamp": 1386357600, "metainfo": ""}