{"sha": "76d913a3cd2224a1e6a13af77f77709ee1b265c6", "log": "COMPRESS-271 frame header checksums", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n     private InputStream currentBlock;\n     private boolean endReached, inUncompressed;\n \n+    // used for frame header checksum and content checksum, if present\n+    private final XXHash32 contentHash = new XXHash32();\n+\n     /**\n      * Creates a new input stream that decompresses streams compressed\n      * using the LZ4 frame format.\n         if (flags == -1) {\n             throw new IOException(\"Premature end of stream while reading frame flags\");\n         }\n+        contentHash.update(flags);\n         if ((flags & VERSION_MASK) != SUPPORTED_VERSION) {\n             throw new IOException(\"Unsupported version \" + (flags >> 6));\n         }\n         expectBlockChecksum = (flags & BLOCK_CHECKSUM_MASK) != 0;\n         expectContentSize = (flags & CONTENT_SIZE_MASK) != 0;\n         expectContentChecksum = (flags & CONTENT_CHECKSUM_MASK) != 0;\n-        if (readOneByte() == -1) { // max size is irrelevant for this implementation\n+        int bdByte = readOneByte();\n+        if (bdByte == -1) { // max size is irrelevant for this implementation\n             throw new IOException(\"Premature end of stream while reading frame BD byte\");\n         }\n+        contentHash.update(bdByte);\n         if (expectContentSize) { // for now we don't care, contains the uncompressed size\n-            int skipped = (int) IOUtils.skip(in, 8);\n+            byte[] contentSize = new byte[8];\n+            int skipped = (int) IOUtils.readFully(in, contentSize);\n             count(skipped);\n             if (8 != skipped) {\n                 throw new IOException(\"Premature end of stream while reading content size\");\n             }\n-        }\n-        if (readOneByte() == -1) { // partial hash of header. not supported, yet\n+            contentHash.update(contentSize, 0, contentSize.length);\n+        }\n+        int headerHash = readOneByte();\n+        if (headerHash == -1) { // partial hash of header.\n             throw new IOException(\"Premature end of stream while reading frame header checksum\");\n+        }\n+        int expectedHash = (int) ((contentHash.getValue() >> 8) & 0xff);\n+        contentHash.reset();\n+        if (headerHash != expectedHash) {\n+            throw new IOException(\"frame header checksum mismatch.\");\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorOutputStream.java\n     /*\n      * TODO before releasing 1.14:\n      *\n-     * + xxhash32 checksum creation for headers, content, blocks\n+     * + xxhash32 checksum creation for content, blocks\n      * + block dependence\n      */\n \n     private final OutputStream out;\n     private boolean finished = false;\n     private int currentIndex = 0;\n+\n+    // used for frame header checksum and content checksum, if present\n+    private final XXHash32 contentHash = new XXHash32();\n \n     /**\n      * Constructs a new output stream that compresses data using the\n     }\n \n     private void writeFrameDescriptor() throws IOException {\n-        out.write(FramedLZ4CompressorInputStream.SUPPORTED_VERSION\n-            | FramedLZ4CompressorInputStream.BLOCK_INDEPENDENCE_MASK);\n-        out.write(BLOCK_SIZES.indexOf(blockData.length) << 4);\n-        out.write(0); // TODO header checksum\n+        int flags = FramedLZ4CompressorInputStream.SUPPORTED_VERSION\n+            | FramedLZ4CompressorInputStream.BLOCK_INDEPENDENCE_MASK;\n+        out.write(flags);\n+        contentHash.update(flags);\n+        int bd = BLOCK_SIZES.indexOf(blockData.length) << 4;\n+        out.write(bd);\n+        contentHash.update(bd);\n+        out.write((int) ((contentHash.getValue() >> 8) & 0xff));\n+        contentHash.reset();\n     }\n \n     private void flushBlock() throws IOException {\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n     }\n \n     @Test\n+    public void rejectsFileWithBadHeaderChecksum() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x64, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\n+            0x70, // block size 4MB\n+            0,\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input))) {\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"header checksum mismatch\"));\n+        }\n+    }\n+\n+    @Test\n     public void readsUncompressedBlocks() throws IOException {\n         byte[] input = new byte[] {\n             4, 0x22, 0x4d, 0x18, // signature\n             0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n             0x70, // block size 4MB\n-            0x00, // checksum, revisit once it gets validated\n+            115, // checksum\n             13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n             0, 0, 0, 0, // empty block marker\n             4, 0x22, 0x4d, 0x18, // signature\n             0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n             0x70, // block size 4MB\n-            0x00, // checksum, revisit once it gets validated\n+            115, // checksum\n             13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n             0, 0, 0, 0, // empty block marker\n             4, 0x22, 0x4d, 0x18, // signature\n             0x70, // flag - Version 01, block independent, with block checksum, no content size, no content checksum\n             0x70, // block size 4MB\n-            0x00, // checksum, revisit once it gets validated\n+            114, // checksum\n             13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n         };\n             4, 0x22, 0x4d, 0x18, // signature\n             0x64, // flag - Version 01, block independent, no block checksum, no content size, with content checksum\n             0x70, // block size 4MB\n-            0x00, // checksum, revisit once it gets validated\n+            (byte) 185, // checksum\n             13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n             0, 0, 0, 0, // empty block marker", "timestamp": 1485322572, "metainfo": ""}