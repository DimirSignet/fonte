{"sha": "daeb07457183232eb9a9fb71bfb31a3700404427", "log": "COMPRESS-327 read 7z archives from arbitrary SeekableByteChannels - needs optimization", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedSeekableByteChannelInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+\n+class BoundedSeekableByteChannelInputStream extends InputStream {\n+    private static final int MAX_BUF_LEN = 8192;\n+    private final ByteBuffer buffer;\n+    private final SeekableByteChannel channel;\n+    private long bytesRemaining;\n+\n+    public BoundedSeekableByteChannelInputStream(final SeekableByteChannel channel,\n+            final long size) {\n+        this.channel = channel;\n+        this.bytesRemaining = size;\n+        if (size < MAX_BUF_LEN && size > 0) {\n+            buffer = ByteBuffer.allocate((int) size);\n+        } else {\n+            buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n+        }\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        if (bytesRemaining > 0) {\n+            --bytesRemaining;\n+            int read = read(1);\n+            if (read < 0) {\n+                return read;\n+            }\n+            return buffer.get() & 0xff;\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        if (bytesRemaining == 0) {\n+            return -1;\n+        }\n+        int bytesToRead = len;\n+        if (bytesToRead > bytesRemaining) {\n+            bytesToRead = (int) bytesRemaining;\n+        }\n+        int bytesRead;\n+        ByteBuffer buf;\n+        if (bytesToRead <= buffer.capacity()) {\n+            buf = buffer;\n+            bytesRead = read(bytesToRead);\n+        } else {\n+            buf = ByteBuffer.allocate(bytesToRead);\n+            bytesRead = channel.read(buf);\n+            buf.flip();\n+        }\n+        if (bytesRead >= 0) {\n+            buf.get(b, off, bytesRead);\n+            bytesRemaining -= bytesRead;\n+        }\n+        return bytesRead;\n+    }\n+\n+    private int read(int len) throws IOException {\n+        buffer.rewind().limit(len);\n+        int read = channel.read(buffer);\n+        buffer.flip();\n+        return read;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // the nested channel is controlled externally\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n+import java.util.EnumSet;\n import java.util.LinkedList;\n import java.util.zip.CRC32;\n \n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n- * Reads a 7z file, using RandomAccessFile under\n+ * Reads a 7z file, using SeekableByteChannel under\n  * the covers.\n  * <p>\n  * The 7z file format is a flexible container\n  * Hence the official tools recommend against\n  * using it for backup purposes on *nix, and\n  * recommend .tar.7z or .tar.lzma or .tar.xz\n- * instead.  \n+ * instead.\n  * <p>\n  * Both the header and file contents may be\n  * compressed and/or encrypted. With both\n     static final int SIGNATURE_HEADER_SIZE = 32;\n \n     private final String fileName;\n-    private RandomAccessFile file;\n+    private SeekableByteChannel channel;\n     private final Archive archive;\n     private int currentEntryIndex = -1;\n     private int currentFolderIndex = -1;\n     static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n-    \n+\n     /**\n      * Reads a file as 7z archive\n      *\n      * @throws IOException if reading the archive fails\n      */\n     public SevenZFile(final File filename, final byte[] password) throws IOException {\n+        this(Files.newByteChannel(filename.toPath(), EnumSet.of(StandardOpenOption.READ)),\n+             filename.getAbsolutePath(), password, true);\n+    }\n+\n+    /**\n+     * Reads a SeekableByteChannel as 7z archive\n+     *\n+     * @param channel the channel to read\n+     * @param filename name of the archive - only used for error reporting\n+     * @param password optional password if the archive is encrypted -\n+     * the byte array is supposed to be the UTF16-LE encoded\n+     * representation of the password.\n+     * @throws IOException if reading the archive fails\n+     */\n+    public SevenZFile(final SeekableByteChannel channel, String filename,\n+                      final byte[] password) throws IOException {\n+        this(channel, filename, password, false);\n+    }\n+\n+    private SevenZFile(final SeekableByteChannel channel, String filename,\n+                       final byte[] password, boolean closeOnError) throws IOException {\n         boolean succeeded = false;\n-        this.file = new RandomAccessFile(filename, \"r\");\n-        this.fileName = filename.getAbsolutePath();\n+        this.channel = channel;\n+        this.fileName = filename;\n         try {\n             archive = readHeaders(password);\n             if (password != null) {\n             }\n             succeeded = true;\n         } finally {\n-            if (!succeeded) {\n-                this.file.close();\n-            }\n-        }\n-    }\n-    \n+            if (!succeeded && closeOnError) {\n+                this.channel.close();\n+            }\n+        }\n+    }\n+\n     /**\n      * Reads a file as unencrypted 7z archive\n      *\n      */\n     @Override\n     public void close() throws IOException {\n-        if (file != null) {\n+        if (channel != null) {\n             try {\n-                file.close();\n+                channel.close();\n             } finally {\n-                file = null;\n+                channel = null;\n                 if (password != null) {\n                     Arrays.fill(password, (byte) 0);\n                 }\n             }\n         }\n     }\n-    \n+\n     /**\n      * Returns the next Archive Entry in this archive.\n      *\n         buildDecodingStream();\n         return entry;\n     }\n-    \n+\n     /**\n      * Returns meta-data of all archive entries.\n      *\n     public Iterable<SevenZArchiveEntry> getEntries() {\n         return Arrays.asList(archive.files);\n     }\n-    \n+\n     private Archive readHeaders(final byte[] password) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(12 /* signature + 2 bytes version + 4 bytes CRC */);\n+        readFully(buf);\n         final byte[] signature = new byte[6];\n-        file.readFully(signature);\n+        buf.get(signature);\n         if (!Arrays.equals(signature, sevenZSignature)) {\n             throw new IOException(\"Bad 7z signature\");\n         }\n         // 7zFormat.txt has it wrong - it's first major then minor\n-        final byte archiveVersionMajor = file.readByte();\n-        final byte archiveVersionMinor = file.readByte();\n+        final byte archiveVersionMajor = buf.get();\n+        final byte archiveVersionMinor = buf.get();\n         if (archiveVersionMajor != 0) {\n             throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\n                     archiveVersionMajor, archiveVersionMinor));\n         }\n \n-        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n+        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(buf.getInt());\n         final StartHeader startHeader = readStartHeader(startHeaderCrc);\n-        \n+\n         final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n         if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n             throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n         }\n-        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n+        channel.position(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n+        buf = ByteBuffer.allocate(nextHeaderSizeInt);\n+        // TODO rewrite to use ByteBuffer directly rather than DataInputStream\n         final byte[] nextHeader = new byte[nextHeaderSizeInt];\n-        file.readFully(nextHeader);\n+        readFully(buf);\n+        buf.get(nextHeader);\n         final CRC32 crc = new CRC32();\n         crc.update(nextHeader);\n         if (startHeader.nextHeaderCrc != crc.getValue()) {\n             throw new IOException(\"NextHeader CRC mismatch\");\n         }\n-        \n+\n         final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n         DataInputStream nextHeaderInputStream = new DataInputStream(\n                 byteStream);\n         }\n         return archive;\n     }\n-    \n+\n     private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n+        // TODO rewrite to use ByteBuffer directly rather than DataInputStream\n         try (DataInputStream dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n-                new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc))) {\n+                new BoundedSeekableByteChannelInputStream(channel, 20), 20, startHeaderCrc))) {\n              startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n              startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n              startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n              return startHeader;\n         }\n     }\n-    \n+\n     private void readHeader(final DataInput header, final Archive archive) throws IOException {\n         int nid = header.readUnsignedByte();\n-        \n+\n         if (nid == NID.kArchiveProperties) {\n             readArchiveProperties(header);\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid == NID.kAdditionalStreamsInfo) {\n             throw new IOException(\"Additional streams unsupported\");\n             //nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid == NID.kMainStreamsInfo) {\n             readStreamsInfo(header, archive);\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid == NID.kFilesInfo) {\n             readFilesInfo(header, archive);\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid != NID.kEnd) {\n             throw new IOException(\"Badly terminated header, found \" + nid);\n         }\n     }\n-    \n+\n     private void readArchiveProperties(final DataInput input) throws IOException {\n         // FIXME: the reference implementation just throws them away?\n         int nid =  input.readUnsignedByte();\n             nid = input.readUnsignedByte();\n         }\n     }\n-    \n+\n     private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\n                                               final byte[] password) throws IOException {\n         readStreamsInfo(header, archive);\n-        \n+\n         // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n         final Folder folder = archive.folders[0];\n         final int firstPackStreamIndex = 0;\n         final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                 0;\n-        \n-        file.seek(folderOffset);\n-        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n+\n+        channel.position(folderOffset);\n+        InputStream inputStreamStack = new BoundedSeekableByteChannelInputStream(channel,\n                 archive.packSizes[firstPackStreamIndex]);\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n         }\n         return new DataInputStream(new ByteArrayInputStream(nextHeader));\n     }\n-    \n+\n     private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n         int nid = header.readUnsignedByte();\n-        \n+\n         if (nid == NID.kPackInfo) {\n             readPackInfo(header, archive);\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid == NID.kUnpackInfo) {\n             readUnpackInfo(header, archive);\n             nid = header.readUnsignedByte();\n             // archive without unpack/coders info\n             archive.folders = new Folder[0];\n         }\n-        \n+\n         if (nid == NID.kSubStreamsInfo) {\n             readSubStreamsInfo(header, archive);\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid != NID.kEnd) {\n             throw new IOException(\"Badly terminated StreamsInfo\");\n         }\n     }\n-    \n+\n     private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n         archive.packPos = readUint64(header);\n         final long numPackStreams = readUint64(header);\n             }\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         if (nid == NID.kCRC) {\n             archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n             archive.packCrcs = new long[(int)numPackStreams];\n                     archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                 }\n             }\n-            \n-            nid = header.readUnsignedByte();\n-        }\n-        \n+\n+            nid = header.readUnsignedByte();\n+        }\n+\n         if (nid != NID.kEnd) {\n             throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n         }\n     }\n-    \n+\n     private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n         int nid = header.readUnsignedByte();\n         if (nid != NID.kFolder) {\n         for (int i = 0; i < (int)numFolders; i++) {\n             folders[i] = readFolder(header);\n         }\n-        \n+\n         nid = header.readUnsignedByte();\n         if (nid != NID.kCodersUnpackSize) {\n             throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n                 folder.unpackSizes[i] = readUint64(header);\n             }\n         }\n-        \n+\n         nid = header.readUnsignedByte();\n         if (nid == NID.kCRC) {\n             final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n                     folders[i].hasCrc = false;\n                 }\n             }\n-            \n-            nid = header.readUnsignedByte();\n-        }\n-        \n+\n+            nid = header.readUnsignedByte();\n+        }\n+\n         if (nid != NID.kEnd) {\n             throw new IOException(\"Badly terminated UnpackInfo\");\n         }\n     }\n-    \n+\n     private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n         for (final Folder folder : archive.folders) {\n             folder.numUnpackSubStreams = 1;\n         }\n         int totalUnpackStreams = archive.folders.length;\n-        \n+\n         int nid = header.readUnsignedByte();\n         if (nid == NID.kNumUnpackStream) {\n             totalUnpackStreams = 0;\n             }\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n         subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n         subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n         subStreamsInfo.crcs = new long[totalUnpackStreams];\n-        \n+\n         int nextUnpackStream = 0;\n         for (final Folder folder : archive.folders) {\n             if (folder.numUnpackSubStreams == 0) {\n         if (nid == NID.kSize) {\n             nid = header.readUnsignedByte();\n         }\n-        \n+\n         int numDigests = 0;\n         for (final Folder folder : archive.folders) {\n             if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n                 numDigests += folder.numUnpackSubStreams;\n             }\n         }\n-        \n+\n         if (nid == NID.kCRC) {\n             final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n             final long[] missingCrcs = new long[numDigests];\n                     }\n                 }\n             }\n-            \n-            nid = header.readUnsignedByte();\n-        }\n-        \n+\n+            nid = header.readUnsignedByte();\n+        }\n+\n         if (nid != NID.kEnd) {\n             throw new IOException(\"Badly terminated SubStreamsInfo\");\n         }\n-        \n+\n         archive.subStreamsInfo = subStreamsInfo;\n     }\n-    \n+\n     private Folder readFolder(final DataInput header) throws IOException {\n         final Folder folder = new Folder();\n-        \n+\n         final long numCoders = readUint64(header);\n         final Coder[] coders = new Coder[(int)numCoders];\n         long totalInStreams = 0;\n             final boolean isSimple = (bits & 0x10) == 0;\n             final boolean hasAttributes = (bits & 0x20) != 0;\n             final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n-            \n+\n             coders[i].decompressionMethodId = new byte[idSize];\n             header.readFully(coders[i].decompressionMethodId);\n             if (isSimple) {\n         folder.coders = coders;\n         folder.totalInputStreams = totalInStreams;\n         folder.totalOutputStreams = totalOutStreams;\n-        \n+\n         if (totalOutStreams == 0) {\n             throw new IOException(\"Total output streams can't be 0\");\n         }\n             bindPairs[i].outIndex = readUint64(header);\n         }\n         folder.bindPairs = bindPairs;\n-        \n+\n         if (totalInStreams < numBindPairs) {\n             throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n         }\n             }\n         }\n         folder.packedStreams = packedStreams;\n-        \n+\n         return folder;\n     }\n-    \n+\n     private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n         final int areAllDefined = header.readUnsignedByte();\n         final BitSet bits;\n         }\n         return bits;\n     }\n-    \n+\n     private BitSet readBits(final DataInput header, final int size) throws IOException {\n         final BitSet bits = new BitSet(size);\n         int mask = 0;\n         }\n         return bits;\n     }\n-    \n+\n     private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n         final long numFiles = readUint64(header);\n         final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n                 case NID.kDummy: {\n                     // 7z 9.20 asserts the content is all zeros and ignores the property\n                     // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n-                    \n+\n                     if (skipBytesFully(header, size) < size) {\n                         throw new IOException(\"Incomplete kDummy property\");\n                     }\n         archive.files = files;\n         calculateStreamMap(archive);\n     }\n-    \n+\n     private void calculateStreamMap(final Archive archive) throws IOException {\n         final StreamMap streamMap = new StreamMap();\n-        \n+\n         int nextFolderPackStreamIndex = 0;\n         final int numFolders = archive.folders != null ? archive.folders.length : 0;\n         streamMap.folderFirstPackStreamIndex = new int[numFolders];\n             streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n             nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n         }\n-        \n+\n         long nextPackStreamOffset = 0;\n         final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n         streamMap.packStreamOffsets = new long[numPackSizes];\n             streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n             nextPackStreamOffset += archive.packSizes[i]; \n         }\n-        \n+\n         streamMap.folderFirstFileIndex = new int[numFolders];\n         streamMap.fileFolderIndex = new int[archive.files.length];\n         int nextFolderIndex = 0;\n                 nextFolderUnpackStreamIndex = 0;\n             }\n         }\n-        \n+\n         archive.streamMap = streamMap;\n     }\n-    \n+\n     private void buildDecodingStream() throws IOException {\n         final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n         if (folderIndex < 0) {\n                 currentFolderInputStream.close();\n                 currentFolderInputStream = null;\n             }\n-            \n+\n             final Folder folder = archive.folders[folderIndex];\n             final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n             final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n         if (file.getHasCrc()) {\n             fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n         }\n-        \n+\n         deferredBlockStreams.add(fileStream);\n     }\n \n     private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n                 final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n-        file.seek(folderOffset);\n+        channel.position(folderOffset);\n         InputStream inputStreamStack =\n             new BufferedInputStream(\n-              new BoundedRandomAccessFileInputStream(file,\n+              new BoundedSeekableByteChannelInputStream(channel,\n                   archive.packSizes[firstPackStreamIndex]));\n         final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<>();\n         for (final Coder coder : folder.getOrderedCoders()) {\n         }\n         return inputStreamStack;\n     }\n-    \n+\n     /**\n      * Reads a byte of data.\n      * \n     public int read() throws IOException {\n         return getCurrentStream().read();\n     }\n-    \n+\n     private InputStream getCurrentStream() throws IOException {\n         if (archive.files[currentEntryIndex].getSize() == 0) {\n             return new ByteArrayInputStream(new byte[0]);\n         if (deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n-        \n+\n         while (deferredBlockStreams.size() > 1) {\n             // In solid compression mode we need to decompress all leading folder'\n             // streams to get access to an entry. We defer this until really needed\n     public int read(final byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n-    \n+\n     /**\n      * Reads data into an array of bytes.\n      * \n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         return getCurrentStream().read(b, off, len);\n     }\n-    \n+\n     private static long readUint64(final DataInput in) throws IOException {\n         // long rather than int as it might get shifted beyond the range of an int\n         final long firstByte = in.readUnsignedByte();\n         }\n         return skipped;\n     }\n-    \n+\n+    private int readFully(ByteBuffer buf) throws IOException {\n+        final int expectedLength = buf.rewind().remaining();\n+        int read = 0;\n+        while (read < expectedLength) {\n+            int readNow = channel.read(buf);\n+            if (readNow <= 0) {\n+                break;\n+            }\n+            read += readNow;\n+        }\n+        buf.flip();\n+        return read;\n+    }\n+\n     @Override\n     public String toString() {\n       return archive.toString();", "timestamp": 1476284788, "metainfo": ""}