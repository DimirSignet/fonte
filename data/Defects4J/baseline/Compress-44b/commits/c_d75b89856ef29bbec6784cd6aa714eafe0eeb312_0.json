{"sha": "d75b89856ef29bbec6784cd6aa714eafe0eeb312", "log": "COMPRESS-394/395 use same \"version needed to extract\" in LFH and CDH  ... and skip data descriptor when copying raw entries", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private static final byte[] ONE = ZipLong.getBytes(1L);\n \n     /**\n-     * Holds the offsets of the LFH starts for each entry.\n-     */\n-    private final Map<ZipArchiveEntry, Long> offsets =\n+     * Holds some book-keeping data for each entry.\n+     */\n+    private final Map<ZipArchiveEntry, EntryMetaData> metaData =\n         new HashMap<>();\n \n     /**\n         cdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\n         writeZip64CentralDirectory();\n         writeCentralDirectoryEnd();\n-        offsets.clear();\n+        metaData.clear();\n         entries.clear();\n         streamCompressor.close();\n         finished = true;\n             rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n \n-        writeDataDescriptor(entry.entry);\n+        if (!phased) {\n+            writeDataDescriptor(entry.entry);\n+        }\n         entry = null;\n     }\n \n                 // do some cleanup:\n                 // * rewrite version needed to extract\n                 channel.position(entry.localDataStart  - 5 * SHORT);\n-                writeOut(ZipShort.getBytes(versionNeededToExtractMethod(entry.entry.getMethod())));\n+                writeOut(ZipShort.getBytes(versionNeededToExtract(entry.entry.getMethod(), false, false)));\n \n                 // * remove ZIP64 extra so it doesn't get written\n                 //   to the central directory\n \n         final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        offsets.put(ze, localHeaderStart);\n+        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n         writeCounted(localHeader);\n         entry.dataStart = streamCompressor.getTotalBytesWritten();\n \n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n-\n-        if (phased &&  !isZip64Required(entry.entry, zip64Mode)){\n-            putShort(versionNeededToExtractMethod(zipMethod), buf, LFH_VERSION_NEEDED_OFFSET);\n-        } else {\n-            putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n-        }\n-\n-        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n+        final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n+\n+        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n+\n+        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n         generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n \n         // compression method\n      * @throws IOException on error\n      */\n     protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-        if (ze.getMethod() != DEFLATED || channel != null) {\n+        if (!usesDataDescriptor(ze.getMethod(), false)) {\n             return;\n         }\n         writeCounted(DD_SIG);\n \n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n \n-        final long lfhOffset = offsets.get(ze);\n+        final EntryMetaData entryMetaData = metaData.get(ze);\n         final boolean needsZip64Extra = hasZip64Extra(ze)\n                 || ze.getCompressedSize() >= ZIP64_MAGIC\n                 || ze.getSize() >= ZIP64_MAGIC\n-                || lfhOffset >= ZIP64_MAGIC\n+                || entryMetaData.offset >= ZIP64_MAGIC\n                 || zip64Mode == Zip64Mode.Always;\n \n         if (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n         }\n \n \n-        handleZip64Extra(ze, lfhOffset, needsZip64Extra);\n-\n-        return createCentralFileHeader(ze, getName(ze), lfhOffset, needsZip64Extra);\n+        handleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\n+\n+        return createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n     }\n \n     /**\n      * Writes the central file header entry.\n      * @param ze the entry to write\n      * @param name The encoded name\n-     * @param lfhOffset Local file header offset for this file\n+     * @param entryMetaData meta data for this file\n      * @throws IOException on error\n      */\n-    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final long lfhOffset,\n+    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name,\n+                                           final EntryMetaData entryMetaData,\n                                            final boolean needsZip64Extra) throws IOException {\n         final byte[] extra = ze.getCentralDirectoryExtra();\n \n \n         final int zipMethod = ze.getMethod();\n         final boolean encodable = zipEncoding.canEncode(ze.getName());\n-        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n-        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n+        putShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\n+            buf, CFH_VERSION_NEEDED_OFFSET);\n+        getGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\n \n         // compression method\n         putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n         putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n \n         // relative offset of LFH\n-        if (lfhOffset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n+        if (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\n             putLong(ZIP64_MAGIC, buf, CFH_LFH_OFFSET);\n         } else {\n-            putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n+            putLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n         }\n \n         // file name\n     }\n \n \n-    private GeneralPurposeBit getGeneralPurposeBits(final int zipMethod, final boolean utfFallback) {\n+    private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\n         final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useUTF8ForNames(useUTF8Flag || utfFallback);\n-        if (isDeflatedToOutputStream(zipMethod)) {\n+        if (usesDataDescriptor) {\n             b.useDataDescriptor(true);\n         }\n         return b;\n     }\n \n-    private int versionNeededToExtract(final int zipMethod, final boolean zip64) {\n+    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n         if (zip64) {\n             return ZIP64_MIN_VERSION;\n         }\n-        // requires version 2 as we are going to store length info\n-        // in the data descriptor\n-        return isDeflatedToOutputStream(zipMethod)\n-            ? DATA_DESCRIPTOR_MIN_VERSION\n-            : versionNeededToExtractMethod(zipMethod);\n-    }\n-\n-    private boolean isDeflatedToOutputStream(final int zipMethod) {\n-        return zipMethod == DEFLATED && channel == null;\n+        if (usedDataDescriptor) {\n+            return DATA_DESCRIPTOR_MIN_VERSION;\n+        }\n+        return versionNeededToExtractMethod(zipMethod);\n+    }\n+\n+    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n+        return !phased && zipMethod == DEFLATED && channel == null;\n     }\n \n     private int versionNeededToExtractMethod(int zipMethod) {\n         private boolean hasWritten;\n     }\n \n+    private static final class EntryMetaData {\n+        private final long offset;\n+        private final boolean usesDataDescriptor;\n+        private EntryMetaData(long offset, boolean usesDataDescriptor) {\n+            this.offset = offset;\n+            this.usesDataDescriptor = usesDataDescriptor;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/DataDescriptorTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.apache.commons.compress.AbstractTestCase.mkdir;\n+import static org.apache.commons.compress.AbstractTestCase.rmdir;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+\n+public class DataDescriptorTest {\n+\n+    private File dir;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        dir = mkdir(\"ddtest\");\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        rmdir(dir);\n+    }\n+\n+    @Test\n+    public void writesDataDescriptorForDeflatedEntryOnUnseekableOutput() throws IOException {\n+        ByteArrayOutputStream o = new ByteArrayOutputStream();\n+        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n+            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n+            zos.write(\"foo\".getBytes(\"UTF-8\"));\n+            zos.closeArchiveEntry();\n+        }\n+        byte[] data = o.toByteArray();\n+\n+        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n+        // 2.0 because of DD\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n+        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n+        // DD and EFS flags\n+        assertArrayEquals(new byte[] { 8, 8 }, gpbInLFH);\n+        byte[] crcAndSizedInLFH = Arrays.copyOfRange(data, 14, 26);\n+        assertArrayEquals(new byte[12], crcAndSizedInLFH);\n+\n+        int cdhStart = findCentralDirectory(data);\n+        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n+        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n+        assertArrayEquals(new byte[] { 8, 8 }, gpbInCDH);\n+\n+        int ddStart = cdhStart - 16;\n+        assertEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n+        long crcFromDD = ZipLong.getValue(data, ddStart + 4);\n+        long cSizeFromDD = ZipLong.getValue(data, ddStart + 8);\n+        long sizeFromDD = ZipLong.getValue(data, ddStart + 12);\n+        assertEquals(3, sizeFromDD);\n+\n+        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n+        assertEquals(crcFromDD, crcFromCDH);\n+        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n+        assertEquals(cSizeFromDD, cSizeFromCDH);\n+        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n+        assertEquals(sizeFromDD, sizeFromCDH);\n+    }\n+\n+    @Test\n+    public void doesntWriteDataDescriptorForDeflatedEntryOnSeekableOutput() throws IOException {\n+        File f = new File(dir, \"test.zip\");\n+        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(f)) {\n+            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n+            zos.write(\"foo\".getBytes(\"UTF-8\"));\n+            zos.closeArchiveEntry();\n+        }\n+\n+        byte[] data;\n+        try (FileInputStream fis = new FileInputStream(f)) {\n+            data = IOUtils.toByteArray(fis);\n+        }\n+\n+        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n+        // still 2.0 because of Deflate\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n+        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n+        // no DD but EFS flag\n+        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n+\n+        int cdhStart = findCentralDirectory(data);\n+        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n+        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n+        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n+\n+        int ddStart = cdhStart - 16;\n+        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n+        long crcFromLFH = ZipLong.getValue(data, 14);\n+        long cSizeFromLFH = ZipLong.getValue(data, 18);\n+        long sizeFromLFH = ZipLong.getValue(data, 22);\n+        assertEquals(3, sizeFromLFH);\n+\n+        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n+        assertEquals(crcFromLFH, crcFromCDH);\n+        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n+        assertEquals(cSizeFromLFH, cSizeFromCDH);\n+        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n+        assertEquals(sizeFromLFH, sizeFromCDH);\n+    }\n+\n+    @Test\n+    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n+        ByteArrayOutputStream init = new ByteArrayOutputStream();\n+        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n+            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n+            zos.write(\"foo\".getBytes(\"UTF-8\"));\n+            zos.closeArchiveEntry();\n+        }\n+\n+        File f = new File(dir, \"test.zip\");\n+        try (FileOutputStream fos = new FileOutputStream(f)) {\n+            fos.write(init.toByteArray());\n+        }\n+\n+        ByteArrayOutputStream o = new ByteArrayOutputStream();\n+        ZipArchiveEntry zae;\n+        try (ZipFile zf = new ZipFile(f);\n+             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n+            zae = zf.getEntry(\"test1.txt\");\n+            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n+        }\n+\n+        byte[] data = o.toByteArray();\n+        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n+        // still 2.0 because of Deflate\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n+        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n+        // no DD but EFS flag\n+        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n+\n+        int cdhStart = findCentralDirectory(data);\n+        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n+        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n+        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n+        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n+\n+        int ddStart = cdhStart - 16;\n+        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n+        long crcFromLFH = ZipLong.getValue(data, 14);\n+        long cSizeFromLFH = ZipLong.getValue(data, 18);\n+        long sizeFromLFH = ZipLong.getValue(data, 22);\n+        assertEquals(3, sizeFromLFH);\n+\n+        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n+        assertEquals(crcFromLFH, crcFromCDH);\n+        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n+        assertEquals(cSizeFromLFH, cSizeFromCDH);\n+        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n+        assertEquals(sizeFromLFH, sizeFromCDH);\n+    }\n+\n+    private int findCentralDirectory(byte[] data) {\n+        // not a ZIP64 archive, no comment, \"End of central directory record\" at the end\n+        return (int) ZipLong.getValue(data, data.length - 22 + 16);\n+    }\n+}", "timestamp": 1495469466, "metainfo": ""}