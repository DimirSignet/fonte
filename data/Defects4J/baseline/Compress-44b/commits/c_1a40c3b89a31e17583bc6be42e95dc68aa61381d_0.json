{"sha": "1a40c3b89a31e17583bc6be42e95dc68aa61381d", "log": "COMPRESS-271 implement write support for LZ4 block format  needs more tests to cover the different cases of \"rewriting the last blocks\"", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorInputStream;\n+import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorOutputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorOutputStream;\n import org.apache.commons.compress.compressors.lzma.LZMAUtils;\n      * \n      * @param name\n      *            the compressor name, i.e. {@value #GZIP}, {@value #BZIP2},\n-     *            {@value #XZ}, {@value #PACK200}, {@value SNAPPY_FRAMED}\n+     *            {@value #XZ}, {@value #PACK200}, {@value SNAPPY_FRAMED},\n+     *            {@value LZ4_BLOCK}\n      *            or {@value #DEFLATE}\n      * @param out\n      *            the output stream\n                 return new FramedSnappyCompressorOutputStream(out);\n             }\n \n+            if (LZ4_BLOCK.equalsIgnoreCase(name)) {\n+                return new BlockLZ4CompressorOutputStream(out);\n+            }\n+\n         } catch (final IOException e) {\n             throw new CompressorException(\"Could not create CompressorOutputStream\", e);\n         }\n \n     @Override\n     public Set<String> getInputStreamCompressorNames() {\n-        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, SNAPPY_RAW, SNAPPY_FRAMED, Z, DEFLATE);\n+        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, SNAPPY_RAW, SNAPPY_FRAMED, Z, DEFLATE, LZ4_BLOCK);\n     }\n \n     @Override\n     public Set<String> getOutputStreamCompressorNames() {\n-        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, DEFLATE, SNAPPY_FRAMED);\n+        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, DEFLATE, SNAPPY_FRAMED, LZ4_BLOCK);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n     private boolean finished = false;\n \n     private Deque<Pair> pairs = new LinkedList<>();\n+    // keeps track of the last window-size bytes (64k) in order to be\n+    // able to expand back-references when needed\n+    private Deque<byte[]> expandedBlocks = new LinkedList<>();\n \n     /**\n      * Creates a new LZ4 output stream.\n \n     private void addLiteralBlock(LZ77Compressor.LiteralBlock block) throws IOException {\n         Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());\n-        last.addLiteral(block);\n+        recordLiteral(last.addLiteral(block));\n+        clearUnusedBlocksAndPairs();\n     }\n \n     private void addBackReference(LZ77Compressor.BackReference block) throws IOException {\n         Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());\n         last.setBackReference(block);\n+        recordBackReference(block);\n+        clearUnusedBlocksAndPairs();\n     }\n \n     private Pair writeBlocksAndReturnUnfinishedPair(int length) throws IOException {\n         return last;\n     }\n \n+    private void recordLiteral(byte[] b) {\n+        expandedBlocks.addFirst(b);\n+    }\n+\n+    private void clearUnusedBlocksAndPairs() {\n+        clearUnusedBlocks();\n+        clearUnusedPairs();\n+    }\n+\n+    private void clearUnusedBlocks() {\n+        int blockLengths = 0;\n+        int blocksToKeep = 0;\n+        for (byte[] b : expandedBlocks) {\n+            blocksToKeep++;\n+            blockLengths += b.length;\n+            if (blockLengths >= BlockLZ4CompressorInputStream.WINDOW_SIZE) {\n+                break;\n+            }\n+        }\n+        final int size = expandedBlocks.size();\n+        for (int i = blocksToKeep; i < size; i++) {\n+            expandedBlocks.removeLast();\n+        }\n+    }\n+\n+    private void recordBackReference(LZ77Compressor.BackReference block) {\n+        expandedBlocks.addFirst(expand(block.getOffset(), block.getLength()));\n+    }\n+\n+    private byte[] expand(final int offset, final int length) {\n+        byte[] expanded = new byte[length];\n+        if (offset == 1) { // surprisingly common special case\n+            byte[] block = expandedBlocks.peekFirst();\n+            byte b = block[block.length - 1];\n+            for (int i = 0; i < expanded.length; i++) {\n+                expanded[i] = b;\n+            }\n+        } else {\n+            expandFromList(expanded, offset, length);\n+        }\n+        return expanded;\n+    }\n+\n+    private void expandFromList(final byte[] expanded, int offset, int length) {\n+        int offsetRemaining = offset;\n+        int lengthRemaining = length;\n+        int writeOffset = 0;\n+        while (lengthRemaining > 0) {\n+            // find block that contains offsetRemaining\n+            byte[] block = null;\n+            int copyLen, copyOffset;\n+            if (offsetRemaining > 0) {\n+                int blockOffset = 0;\n+                for (byte[] b : expandedBlocks) {\n+                    if (b.length + blockOffset >= offsetRemaining) {\n+                        block = b;\n+                        break;\n+                    }\n+                    blockOffset += b.length;\n+                }\n+                copyOffset = blockOffset + block.length - offsetRemaining;\n+                copyLen = Math.min(lengthRemaining, block.length - copyOffset);\n+            } else {\n+                // offsetRemaining is negative and points into the expanded bytes\n+                block = expanded;\n+                copyOffset = writeOffset  + offsetRemaining;\n+                copyLen = Math.min(lengthRemaining, writeOffset + offsetRemaining);\n+            }\n+            if (copyLen < 1) {\n+                throw new IllegalStateException(\"zero copy\");\n+            }\n+            System.arraycopy(block, copyOffset, expanded, writeOffset, copyLen);\n+            offsetRemaining -= copyLen;\n+            lengthRemaining -= copyLen;\n+            writeOffset += copyLen;\n+        }\n+    }\n+\n+    private void clearUnusedPairs() {\n+        int pairLengths = 0;\n+        int pairsToKeep = 0;\n+        for (Iterator<Pair> it = pairs.descendingIterator(); it.hasNext(); ) {\n+            Pair p = it.next();\n+            pairsToKeep++;\n+            pairLengths += p.length();\n+            if (pairLengths >= BlockLZ4CompressorInputStream.WINDOW_SIZE) {\n+                break;\n+            }\n+        }\n+        final int size = pairs.size();\n+        for (int i = pairsToKeep; i < size; i++) {\n+            Pair p = pairs.peekFirst();\n+            if (p.hasBeenWritten()) {\n+                pairs.removeFirst();\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n     private void writeFinalLiteralBlock() throws IOException {\n         rewriteLastPairs();\n         for (Pair p : pairs) {\n     }\n \n     private void rewriteLastPairs() {\n+        LinkedList<Pair> lastPairs = new LinkedList<>();\n+        LinkedList<Integer> pairLength = new LinkedList<>();\n+        int offset = 0;\n+        for (Iterator<Pair> it = pairs.descendingIterator(); it.hasNext(); ) {\n+            Pair p = it.next();\n+            if (p.hasBeenWritten()) {\n+                break;\n+            }\n+            int len = p.length();\n+            pairLength.addFirst(len);\n+            lastPairs.addFirst(p);\n+            offset += len;\n+            if (offset >= MIN_OFFSET_OF_LAST_BACK_REFERENCE) {\n+                break;\n+            }\n+        }\n+        for (Pair p : lastPairs) {\n+            pairs.remove(p);\n+        }\n+        // lastPairs may contain between one and four Pairs:\n+        // * the last pair may be a one byte literal\n+        // * all other Pairs contain a back-reference which must be four bytes long at minimum\n+        // we could merge them all into a single literal block but\n+        // this may harm compression. For example compressing\n+        // \"bla.tar\" from our tests yields a last block containing a\n+        // back-reference of length > 2k and we'd end up with a last\n+        // literal of that size rather than a 2k back-reference and a\n+        // 12 byte literal at the end.\n+\n+        // Instead we merge all but the first of lastPairs into a new\n+        // literal-only Pair \"replacement\" and look at the\n+        // back-reference in the first of lastPairs and see if we can\n+        // split it. We can split it if it is longer than 16 -\n+        // replacement.length (i.e. the minimal length of four is kept\n+        // while making sure the last literal is at least twelve bytes\n+        // long). If we can't split it, we expand the first of the pairs\n+        // as well.\n+\n+        // this is not optimal, we could get better compression\n+        // results with more complex approaches as the last literal\n+        // only needs to be five bytes long if the previous\n+        // back-reference has an offset big enough\n+\n+        final int allButFirstOfLastPairs = lastPairs.size() - 1;\n+        int toExpand = 0;\n+        for (int i = 1; i < allButFirstOfLastPairs; i++) {\n+            toExpand += pairLength.get(i);\n+        }\n+        Pair replacement = new Pair();\n+        if (toExpand > 0) {\n+            replacement.prependLiteral(expand(toExpand, toExpand));\n+        }\n+        Pair splitCandidate = lastPairs.get(0);\n+        int splitLen = splitCandidate.length();\n+        int stillNeeded = MIN_OFFSET_OF_LAST_BACK_REFERENCE - toExpand;\n+        if (splitCandidate.hasBackReference()\n+            && splitCandidate.backReferenceLength() > MIN_BACK_REFERENCE_LENGTH + stillNeeded) {\n+            replacement.prependLiteral(expand(toExpand + stillNeeded, stillNeeded));\n+            pairs.add(splitCandidate.splitWithNewBackReferenceLengthOf(splitCandidate.backReferenceLength()\n+                - stillNeeded));\n+        } else {\n+            replacement.prependLiteral(expand(toExpand + splitLen, splitLen));\n+        }\n+        pairs.add(replacement);\n     }\n \n     final static class Pair {\n-        private final List<byte[]> literals = new LinkedList<>();\n+        private final Deque<byte[]> literals = new LinkedList<>();\n         private int brOffset, brLength;\n         private boolean written;\n \n-        void addLiteral(LZ77Compressor.LiteralBlock block) {\n-            literals.add(Arrays.copyOfRange(block.getData(), block.getOffset(),\n-                block.getOffset() + block.getLength()));\n+        private void prependLiteral(byte[] data) {\n+            literals.addFirst(data);\n+        }\n+        byte[] addLiteral(LZ77Compressor.LiteralBlock block) {\n+            byte[] copy = Arrays.copyOfRange(block.getData(), block.getOffset(),\n+                block.getOffset() + block.getLength());\n+            literals.add(copy);\n+            return copy;\n         }\n         void setBackReference(LZ77Compressor.BackReference block) {\n             if (hasBackReference()) {\n         int length() {\n             return literalLength() + brLength;\n         }\n-        boolean hasBeenWritten() {\n+        private boolean hasBeenWritten() {\n             return written;\n         }\n         void writeTo(OutputStream out) throws IOException {\n             }\n             out.write(length);\n         }\n+        private int backReferenceLength() {\n+            return brLength;\n+        }\n+        Pair splitWithNewBackReferenceLengthOf(int newBackReferenceLength) {\n+            Pair p = new Pair();\n+            p.literals.addAll(literals);\n+            p.brOffset = brOffset;\n+            p.brLength = newBackReferenceLength;\n+            return p;\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorRoundtripTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Random;\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.lz77support.Parameters;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public final class BlockLZ4CompressorRoundtripTest extends AbstractTestCase {\n+\n+    private void roundTripTest(String testFile) throws IOException {\n+        File input = getFile(testFile);\n+        long start = System.currentTimeMillis();\n+        final File outputSz = new File(dir, input.getName() + \".block.lz4\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             FileOutputStream os = new FileOutputStream(outputSz);\n+             BlockLZ4CompressorOutputStream los = new BlockLZ4CompressorOutputStream(os)) {\n+            IOUtils.copy(is, los);\n+        }\n+        System.err.println(input.getName() + \" written, uncompressed bytes: \" + input.length()\n+            + \", compressed bytes: \" + outputSz.length() + \" after \" + (System.currentTimeMillis() - start) + \"ms\");\n+        start = System.currentTimeMillis();\n+        try (FileInputStream is = new FileInputStream(input);\n+             BlockLZ4CompressorInputStream sis = new BlockLZ4CompressorInputStream(new FileInputStream(outputSz))) {\n+            byte[] expected = IOUtils.toByteArray(is);\n+            byte[] actual = IOUtils.toByteArray(sis);\n+            Assert.assertArrayEquals(expected, actual);\n+        }\n+        System.err.println(outputSz.getName() + \" read after \" + (System.currentTimeMillis() - start) + \"ms\");\n+    }\n+\n+    // should yield decent compression\n+    @Test\n+    public void blaTarRoundtrip() throws IOException {\n+        roundTripTest(\"bla.tar\");\n+    }\n+\n+    // yields no compression at all\n+    @Test\n+    public void gzippedLoremIpsumRoundtrip() throws IOException {\n+        roundTripTest(\"lorem-ipsum.txt.gz\");\n+    }\n+\n+    @Test\n+    public void biggerFileRoundtrip() throws IOException {\n+        roundTripTest(\"COMPRESS-256.7z\");\n+    }\n+\n+}", "timestamp": 1485031781, "metainfo": ""}