{"sha": "e7a0f70eb2de27343355b1c5e29eff5777dd7543", "log": "Moving all these over from inside the IO component. Currently the Tar test case fails to run, though the Zip one works fine. Possibly merge BZip2 component into this one.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarBuffer.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * The TarBuffer class implements the tar archive concept of a buffered input\n+ * stream. This concept goes back to the days of blocked tape drives and special\n+ * io devices. In the Java universe, the only real function that this class\n+ * performs is to ensure that files have the correct \"block\" size, or other tars\n+ * will complain. <p>\n+ *\n+ * You should never have a need to access this class directly. TarBuffers are\n+ * created by Tar IO Streams.\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ */\n+class TarBuffer\n+{\n+    public static final int DEFAULT_RECORDSIZE = ( 512 );\n+    public static final int DEFAULT_BLOCKSIZE = ( DEFAULT_RECORDSIZE * 20 );\n+\n+    private byte[] m_blockBuffer;\n+    private int m_blockSize;\n+    private int m_currBlkIdx;\n+    private int m_currRecIdx;\n+    private boolean m_debug;\n+\n+    private InputStream m_input;\n+    private OutputStream m_output;\n+    private int m_recordSize;\n+    private int m_recsPerBlock;\n+\n+    public TarBuffer( final InputStream input )\n+    {\n+        this( input, TarBuffer.DEFAULT_BLOCKSIZE );\n+    }\n+\n+    public TarBuffer( final InputStream input, final int blockSize )\n+    {\n+        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    public TarBuffer( final InputStream input,\n+                      final int blockSize,\n+                      final int recordSize )\n+    {\n+        m_input = input;\n+        initialize( blockSize, recordSize );\n+    }\n+\n+    public TarBuffer( final OutputStream output )\n+    {\n+        this( output, TarBuffer.DEFAULT_BLOCKSIZE );\n+    }\n+\n+    public TarBuffer( final OutputStream output, final int blockSize )\n+    {\n+        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    public TarBuffer( final OutputStream output,\n+                      final int blockSize,\n+                      final int recordSize )\n+    {\n+        m_output = output;\n+        initialize( blockSize, recordSize );\n+    }\n+\n+    /**\n+     * Set the debugging flag for the buffer.\n+     *\n+     * @param debug If true, print debugging output.\n+     */\n+    public void setDebug( final boolean debug )\n+    {\n+        m_debug = debug;\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's block size. Blocks consist of multiple records.\n+     *\n+     * @return The BlockSize value\n+     */\n+    public int getBlockSize()\n+    {\n+        return m_blockSize;\n+    }\n+\n+    /**\n+     * Get the current block number, zero based.\n+     *\n+     * @return The current zero based block number.\n+     */\n+    public int getCurrentBlockNum()\n+    {\n+        return m_currBlkIdx;\n+    }\n+\n+    /**\n+     * Get the current record number, within the current block, zero based.\n+     * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.\n+     *\n+     * @return The current zero based record number.\n+     */\n+    public int getCurrentRecordNum()\n+    {\n+        return m_currRecIdx - 1;\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's record size.\n+     *\n+     * @return The RecordSize value\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_recordSize;\n+    }\n+\n+    /**\n+     * Determine if an archive record indicate End of Archive. End of archive is\n+     * indicated by a record that consists entirely of null bytes.\n+     *\n+     * @param record The record data to check.\n+     * @return The EOFRecord value\n+     */\n+    public boolean isEOFRecord( final byte[] record )\n+    {\n+        final int size = getRecordSize();\n+        for( int i = 0; i < size; ++i )\n+        {\n+            if( record[ i ] != 0 )\n+            {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Close the TarBuffer. If this is an output buffer, also flush the current\n+     * block before closing.\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            debug( \"TarBuffer.closeBuffer().\" );\n+        }\n+\n+        if( null != m_output )\n+        {\n+            flushBlock();\n+\n+            if( m_output != System.out && m_output != System.err )\n+            {\n+                m_output.close();\n+                m_output = null;\n+            }\n+        }\n+        else if( m_input != null )\n+        {\n+            if( m_input != System.in )\n+            {\n+                m_input.close();\n+                m_input = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read a record from the input stream and return the data.\n+     *\n+     * @return The record data.\n+     * @exception IOException Description of Exception\n+     */\n+    public byte[] readRecord()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"ReadRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            if( !readBlock() )\n+            {\n+                return null;\n+            }\n+        }\n+\n+        final byte[] result = new byte[ m_recordSize ];\n+        System.arraycopy( m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          result,\n+                          0,\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Skip over a record on the input stream.\n+     */\n+    public void skipRecord()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"SkipRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading (via skip) from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            if( !readBlock() )\n+            {\n+                return;// UNDONE\n+            }\n+        }\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive.\n+     *\n+     * @param record The record data to write to the archive.\n+     */\n+    public void writeRecord( final byte[] record )\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( record.length != m_recordSize )\n+        {\n+            final String message = \"record to write has length '\" +\n+                record.length + \"' which is not the record size of '\" +\n+                m_recordSize + \"'\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy( record,\n+                          0,\n+                          m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive, where the record may be inside of\n+     * a larger array buffer. The buffer must be \"offset plus record size\" long.\n+     *\n+     * @param buffer The buffer containing the record data to write.\n+     * @param offset The offset of the record data within buf.\n+     */\n+    public void writeRecord( final byte[] buffer, final int offset )\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( ( offset + m_recordSize ) > buffer.length )\n+        {\n+            final String message = \"record has length '\" + buffer.length +\n+                \"' with offset '\" + offset + \"' which is less than the record size of '\" +\n+                m_recordSize + \"'\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy( buffer,\n+                          offset,\n+                          m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Flush the current data block if it has any data in it.\n+     */\n+    private void flushBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"TarBuffer.flushBlock() called.\";\n+            debug( message );\n+        }\n+\n+        if( m_output == null )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx > 0 )\n+        {\n+            writeBlock();\n+        }\n+    }\n+\n+    /**\n+     * Initialization common to all constructors.\n+     */\n+    private void initialize( final int blockSize, final int recordSize )\n+    {\n+        m_debug = false;\n+        m_blockSize = blockSize;\n+        m_recordSize = recordSize;\n+        m_recsPerBlock = ( m_blockSize / m_recordSize );\n+        m_blockBuffer = new byte[ m_blockSize ];\n+\n+        if( null != m_input )\n+        {\n+            m_currBlkIdx = -1;\n+            m_currRecIdx = m_recsPerBlock;\n+        }\n+        else\n+        {\n+            m_currBlkIdx = 0;\n+            m_currRecIdx = 0;\n+        }\n+    }\n+\n+    /**\n+     * @return false if End-Of-File, else true\n+     */\n+    private boolean readBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"ReadBlock: blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        m_currRecIdx = 0;\n+\n+        int offset = 0;\n+        int bytesNeeded = m_blockSize;\n+\n+        while( bytesNeeded > 0 )\n+        {\n+            final long numBytes = m_input.read( m_blockBuffer, offset, bytesNeeded );\n+\n+            //\n+            // NOTE\n+            // We have fit EOF, and the block is not full!\n+            //\n+            // This is a broken archive. It does not follow the standard\n+            // blocking algorithm. However, because we are generous, and\n+            // it requires little effort, we will simply ignore the error\n+            // and continue as if the entire block were read. This does\n+            // not appear to break anything upstream. We used to return\n+            // false in this case.\n+            //\n+            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n+            //\n+            if( numBytes == -1 )\n+            {\n+                break;\n+            }\n+\n+            offset += numBytes;\n+            bytesNeeded -= numBytes;\n+\n+            if( numBytes != m_blockSize )\n+            {\n+                if( m_debug )\n+                {\n+                    System.err.println( \"ReadBlock: INCOMPLETE READ \"\n+                                        + numBytes + \" of \" + m_blockSize\n+                                        + \" bytes read.\" );\n+                }\n+            }\n+        }\n+\n+        m_currBlkIdx++;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Write a TarBuffer block to the archive.\n+     *\n+     * @exception IOException Description of Exception\n+     */\n+    private void writeBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteBlock: blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        m_output.write( m_blockBuffer, 0, m_blockSize );\n+        m_output.flush();\n+\n+        m_currRecIdx = 0;\n+        m_currBlkIdx++;\n+    }\n+\n+    protected void debug( final String message )\n+    {\n+        if( m_debug )\n+        {\n+            System.err.println( message );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarConstants.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarConstants.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+/**\n+ * This interface contains all the definitions used in the package.\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ */\n+interface TarConstants\n+{\n+    /**\n+     * The length of the mode field in a header buffer.\n+     */\n+    int MODELEN = 8;\n+\n+    /**\n+     * The length of the user id field in a header buffer.\n+     */\n+    int UIDLEN = 8;\n+\n+    /**\n+     * The length of the group id field in a header buffer.\n+     */\n+    int GIDLEN = 8;\n+\n+    /**\n+     * The length of the checksum field in a header buffer.\n+     */\n+    int CHKSUMLEN = 8;\n+\n+    /**\n+     * The length of the size field in a header buffer.\n+     */\n+    int SIZELEN = 12;\n+\n+    /**\n+     * The length of the magic field in a header buffer.\n+     */\n+    int MAGICLEN = 8;\n+\n+    /**\n+     * The length of the modification time field in a header buffer.\n+     */\n+    int MODTIMELEN = 12;\n+\n+    /**\n+     * The length of the user name field in a header buffer.\n+     */\n+    int UNAMELEN = 32;\n+\n+    /**\n+     * The length of the group name field in a header buffer.\n+     */\n+    int GNAMELEN = 32;\n+\n+    /**\n+     * The length of the devices field in a header buffer.\n+     */\n+    int DEVLEN = 8;\n+\n+    /**\n+     * LF_ constants represent the \"link flag\" of an entry, or more commonly,\n+     * the \"entry type\". This is the \"old way\" of indicating a normal file.\n+     */\n+    byte LF_OLDNORM = 0;\n+\n+    /**\n+     * Normal file type.\n+     */\n+    byte LF_NORMAL = (byte)'0';\n+\n+    /**\n+     * Link file type.\n+     */\n+    byte LF_LINK = (byte)'1';\n+\n+    /**\n+     * Symbolic link file type.\n+     */\n+    byte LF_SYMLINK = (byte)'2';\n+\n+    /**\n+     * Character device file type.\n+     */\n+    byte LF_CHR = (byte)'3';\n+\n+    /**\n+     * Block device file type.\n+     */\n+    byte LF_BLK = (byte)'4';\n+\n+    /**\n+     * Directory file type.\n+     */\n+    byte LF_DIR = (byte)'5';\n+\n+    /**\n+     * FIFO (pipe) file type.\n+     */\n+    byte LF_FIFO = (byte)'6';\n+\n+    /**\n+     * Contiguous file type.\n+     */\n+    byte LF_CONTIG = (byte)'7';\n+\n+    /**\n+     * The magic tag representing a POSIX tar archive.\n+     */\n+    String TMAGIC = \"ustar\";\n+\n+    /**\n+     * The magic tag representing a GNU tar archive.\n+     */\n+    String GNU_TMAGIC = \"ustar  \";\n+\n+    /**\n+     * The namr of the GNU tar entry which contains a long name.\n+     */\n+    String GNU_LONGLINK = \"././@LongLink\";\n+\n+    /**\n+     * Identifies the *next* file on the tape as having a long name.\n+     */\n+    byte LF_GNUTYPE_LONGNAME = (byte)'L';\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarEntry.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarEntry.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import java.io.File;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+/**\n+ * This class represents an entry in a Tar archive. It consists of the entry's\n+ * header, as well as the entry's File. Entries can be instantiated in one of\n+ * three ways, depending on how they are to be used. <p>\n+ *\n+ * TarEntries that are created from the header bytes read from an archive are\n+ * instantiated with the TarEntry( byte[] ) constructor. These entries will be\n+ * used when extracting from or listing the contents of an archive. These\n+ * entries have their header filled in using the header bytes. They also set the\n+ * File to null, since they reference an archive entry not a file. <p>\n+ *\n+ * TarEntries that are created from Files that are to be written into an archive\n+ * are instantiated with the TarEntry( File ) constructor. These entries have\n+ * their header filled in using the File's information. They also keep a\n+ * reference to the File for convenience when writing entries. <p>\n+ *\n+ * Finally, TarEntries can be constructed from nothing but a name. This allows\n+ * the programmer to construct the entry by hand, for instance when only an\n+ * InputStream is available for writing to the archive, and the header\n+ * information is constructed from other information. In this case the header\n+ * fields are set to defaults and the File is set to null. <p>\n+ *\n+ * The C structure for a Tar Entry's header is: <pre>\n+ * struct header {\n+ * char name[NAMSIZ];\n+ * char mode[8];\n+ * char uid[8];\n+ * char gid[8];\n+ * char size[12];\n+ * char mtime[12];\n+ * char chksum[8];\n+ * char linkflag;\n+ * char linkname[NAMSIZ];\n+ * char magic[8];\n+ * char uname[TUNMLEN];\n+ * char gname[TGNMLEN];\n+ * char devmajor[8];\n+ * char devminor[8];\n+ * } header;\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ * @see TarInputStream\n+ * @see TarOutputStream\n+ */\n+public class TarEntry\n+{\n+    /**\n+     * The length of the name field in a header buffer.\n+     */\n+    public static final int NAMELEN = 100;\n+\n+    /**\n+     * The entry's modification time.\n+     */\n+    private int m_checkSum;\n+\n+    /**\n+     * The entry's group name.\n+     */\n+    private int m_devMajor;\n+\n+    /**\n+     * The entry's major device number.\n+     */\n+    private int m_devMinor;\n+\n+    /**\n+     * The entry's minor device number.\n+     */\n+    private File m_file;\n+\n+    /**\n+     * The entry's user id.\n+     */\n+    private int m_groupID;\n+\n+    /**\n+     * The entry's user name.\n+     */\n+    private StringBuffer m_groupName;\n+\n+    /**\n+     * The entry's checksum.\n+     */\n+    private byte m_linkFlag;\n+\n+    /**\n+     * The entry's link flag.\n+     */\n+    private StringBuffer m_linkName;\n+\n+    /**\n+     * The entry's link name.\n+     */\n+    private StringBuffer m_magic;\n+\n+    /**\n+     * The entry's size.\n+     */\n+    private long m_modTime;\n+\n+    /**\n+     * The entry's name.\n+     */\n+    private int m_mode;\n+\n+    private StringBuffer m_name;\n+\n+    /**\n+     * The entry's group id.\n+     */\n+    private long m_size;\n+\n+    /**\n+     * The entry's permission mode.\n+     */\n+    private int m_userID;\n+\n+    /**\n+     * The entry's magic tag.\n+     */\n+    private StringBuffer m_userName;\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer to\n+     * construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the name of the entry\n+     */\n+    public TarEntry( final String name )\n+    {\n+        this();\n+\n+        final boolean isDir = name.endsWith( \"/\" );\n+\n+        m_name = new StringBuffer( name );\n+        m_mode = isDir ? 040755 : 0100644;\n+        m_linkFlag = isDir ? TarConstants.LF_DIR : TarConstants.LF_NORMAL;\n+        m_modTime = ( new Date() ).getTime() / 1000;\n+        m_linkName = new StringBuffer( \"\" );\n+        m_userName = new StringBuffer( \"\" );\n+        m_groupName = new StringBuffer( \"\" );\n+    }\n+\n+    /**\n+     * Construct an entry with a name an a link flag.\n+     *\n+     * @param name Description of Parameter\n+     * @param linkFlag Description of Parameter\n+     */\n+    public TarEntry( final String name, final byte linkFlag )\n+    {\n+        this( name );\n+        m_linkFlag = linkFlag;\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the header is\n+     * constructed from information from the file.\n+     *\n+     * @param file The file that the entry represents.\n+     */\n+    public TarEntry( final File file )\n+    {\n+        this();\n+\n+        m_file = file;\n+\n+        String name = file.getPath();\n+\n+        // Strip off drive letters!\n+        final String osName =\n+            System.getProperty( \"os.name\" ).toLowerCase( Locale.US );\n+        if( -1 != osName.indexOf( \"netware\" ) )\n+        {\n+            if( name.length() > 2 )\n+            {\n+                final char ch1 = name.charAt( 0 );\n+                final char ch2 = name.charAt( 1 );\n+\n+                if( ch2 == ':' &&\n+                    ( ( ch1 >= 'a' && ch1 <= 'z' ) ||\n+                    ( ch1 >= 'A' && ch1 <= 'Z' ) ) )\n+                {\n+                    name = name.substring( 2 );\n+                }\n+            }\n+        }\n+        else if( -1 != osName.indexOf( \"netware\" ) )\n+        {\n+            final int colon = name.indexOf( ':' );\n+            if( colon != -1 )\n+            {\n+                name = name.substring( colon + 1 );\n+            }\n+        }\n+\n+        name = name.replace( File.separatorChar, '/' );\n+\n+        // No absolute pathnames\n+        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n+        // so we loop on starting /'s.\n+        while( name.startsWith( \"/\" ) )\n+        {\n+            name = name.substring( 1 );\n+        }\n+\n+        m_linkName = new StringBuffer( \"\" );\n+        m_name = new StringBuffer( name );\n+\n+        if( file.isDirectory() )\n+        {\n+            m_mode = 040755;\n+            m_linkFlag = TarConstants.LF_DIR;\n+\n+            if( m_name.charAt( m_name.length() - 1 ) != '/' )\n+            {\n+                m_name.append( \"/\" );\n+            }\n+        }\n+        else\n+        {\n+            m_mode = 0100644;\n+            m_linkFlag = TarConstants.LF_NORMAL;\n+        }\n+\n+        m_size = file.length();\n+        m_modTime = file.lastModified() / 1000;\n+        m_checkSum = 0;\n+        m_devMajor = 0;\n+        m_devMinor = 0;\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set to null.\n+     *\n+     * @param header The header bytes from a tar archive entry.\n+     */\n+    public TarEntry( final byte[] header )\n+    {\n+        this();\n+        parseTarHeader( header );\n+    }\n+\n+    /**\n+     * Construct an empty entry and prepares the header values.\n+     */\n+    private TarEntry()\n+    {\n+        m_magic = new StringBuffer( TarConstants.TMAGIC );\n+        m_name = new StringBuffer();\n+        m_linkName = new StringBuffer();\n+\n+        String user = System.getProperty( \"user.name\", \"\" );\n+        if( user.length() > 31 )\n+        {\n+            user = user.substring( 0, 31 );\n+        }\n+\n+        m_userName = new StringBuffer( user );\n+        m_groupName = new StringBuffer( \"\" );\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupID( final int groupId )\n+    {\n+        m_groupID = groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     * @deprecated Use setGroupID() instead\n+     * @see #setGroupID(int)\n+     */\n+    public void setGroupId( final int groupId )\n+    {\n+        m_groupID = groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group name.\n+     *\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setGroupName( final String groupName )\n+    {\n+        m_groupName = new StringBuffer( groupName );\n+    }\n+\n+    /**\n+     * Set this entry's modification time. The parameter passed to this method\n+     * is in \"Java time\".\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime( final long time )\n+    {\n+        m_modTime = time / 1000;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime( final Date time )\n+    {\n+        m_modTime = time.getTime() / 1000;\n+    }\n+\n+    /**\n+     * Set the mode for this entry\n+     *\n+     * @param mode The new Mode value\n+     */\n+    public void setMode( final int mode )\n+    {\n+        m_mode = mode;\n+    }\n+\n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n+    public void setName( final String name )\n+    {\n+        m_name = new StringBuffer( name );\n+    }\n+\n+    /**\n+     * Set this entry's file size.\n+     *\n+     * @param size This entry's new file size.\n+     */\n+    public void setSize( final long size )\n+    {\n+        m_size = size;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     */\n+    public void setUserID( final int userId )\n+    {\n+        m_userID = userId;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     * @deprecated Use setUserID() instead\n+     * @see #setUserID(int)\n+     */\n+    public void setUserId( final int userId )\n+    {\n+        m_userID = userId;\n+    }\n+\n+    /**\n+     * Set this entry's user name.\n+     *\n+     * @param userName This entry's new user name.\n+     */\n+    public void setUserName( final String userName )\n+    {\n+        m_userName = new StringBuffer( userName );\n+    }\n+\n+    /**\n+     * If this entry represents a file, and the file is a directory, return an\n+     * array of TarEntries for this entry's children.\n+     *\n+     * @return An array of TarEntry's for this entry's children.\n+     */\n+    public TarEntry[] getDirectoryEntries()\n+    {\n+        if( null == m_file || !m_file.isDirectory() )\n+        {\n+            return new TarEntry[ 0 ];\n+        }\n+\n+        final String[] list = m_file.list();\n+        final TarEntry[] result = new TarEntry[ list.length ];\n+\n+        for( int i = 0; i < list.length; ++i )\n+        {\n+            result[ i ] = new TarEntry( new File( m_file, list[ i ] ) );\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get this entry's file.\n+     *\n+     * @return This entry's file.\n+     */\n+    public File getFile()\n+    {\n+        return m_file;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     * @deprecated Use getGroupID() instead\n+     * @see #getGroupID()\n+     */\n+    public int getGroupId()\n+    {\n+        return m_groupID;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     */\n+    public int getGroupID()\n+    {\n+        return m_groupID;\n+    }\n+\n+    /**\n+     * Get this entry's group name.\n+     *\n+     * @return This entry's group name.\n+     */\n+    public String getGroupName()\n+    {\n+        return m_groupName.toString();\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @return The ModTime value\n+     */\n+    public Date getModTime()\n+    {\n+        return new Date( m_modTime * 1000 );\n+    }\n+\n+    /**\n+     * Get this entry's mode.\n+     *\n+     * @return This entry's mode.\n+     */\n+    public int getMode()\n+    {\n+        return m_mode;\n+    }\n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n+    public String getName()\n+    {\n+        return m_name.toString();\n+    }\n+\n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n+    public long getSize()\n+    {\n+        return m_size;\n+    }\n+\n+    /**\n+     * Get this entry's checksum.\n+     *\n+     * @return This entry's checksum.\n+     */\n+    public int getCheckSum()\n+    {\n+        return m_checkSum;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @deprecated Use getUserID() instead\n+     * @see #getUserID()\n+     */\n+    public int getUserId()\n+    {\n+        return m_userID;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     */\n+    public int getUserID()\n+    {\n+        return m_userID;\n+    }\n+\n+    /**\n+     * Get this entry's user name.\n+     *\n+     * @return This entry's user name.\n+     */\n+    public String getUserName()\n+    {\n+        return m_userName.toString();\n+    }\n+\n+    /**\n+     * Determine if the given entry is a descendant of this entry. Descendancy\n+     * is determined by the name of the descendant starting with this entry's\n+     * name.\n+     *\n+     * @param desc Entry to be checked as a descendent of\n+     * @return True if entry is a descendant of\n+     */\n+    public boolean isDescendent( final TarEntry desc )\n+    {\n+        return desc.getName().startsWith( getName() );\n+    }\n+\n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n+    public boolean isDirectory()\n+    {\n+        if( m_file != null )\n+        {\n+            return m_file.isDirectory();\n+        }\n+\n+        if( m_linkFlag == TarConstants.LF_DIR )\n+        {\n+            return true;\n+        }\n+\n+        if( getName().endsWith( \"/\" ) )\n+        {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long name block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongNameEntry()\n+    {\n+        return m_linkFlag == TarConstants.LF_GNUTYPE_LONGNAME &&\n+            m_name.toString().equals( TarConstants.GNU_LONGLINK );\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined by the\n+     * header names being equal.\n+     *\n+     * @param other Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals( final TarEntry other )\n+    {\n+        return getName().equals( other.getName() );\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     */\n+    private void parseTarHeader( final byte[] header )\n+    {\n+        int offset = 0;\n+\n+        m_name = TarUtils.parseName( header, offset, NAMELEN );\n+        offset += NAMELEN;\n+        m_mode = (int)TarUtils.parseOctal( header, offset, TarConstants.MODELEN );\n+        offset += TarConstants.MODELEN;\n+        m_userID = (int)TarUtils.parseOctal( header, offset, TarConstants.UIDLEN );\n+        offset += TarConstants.UIDLEN;\n+        m_groupID = (int)TarUtils.parseOctal( header, offset, TarConstants.GIDLEN );\n+        offset += TarConstants.GIDLEN;\n+        m_size = TarUtils.parseOctal( header, offset, TarConstants.SIZELEN );\n+        offset += TarConstants.SIZELEN;\n+        m_modTime = TarUtils.parseOctal( header, offset, TarConstants.MODTIMELEN );\n+        offset += TarConstants.MODTIMELEN;\n+        m_checkSum = (int)TarUtils.parseOctal( header, offset, TarConstants.CHKSUMLEN );\n+        offset += TarConstants.CHKSUMLEN;\n+        m_linkFlag = header[ offset++ ];\n+        m_linkName = TarUtils.parseName( header, offset, NAMELEN );\n+        offset += NAMELEN;\n+        m_magic = TarUtils.parseName( header, offset, TarConstants.MAGICLEN );\n+        offset += TarConstants.MAGICLEN;\n+        m_userName = TarUtils.parseName( header, offset, TarConstants.UNAMELEN );\n+        offset += TarConstants.UNAMELEN;\n+        m_groupName = TarUtils.parseName( header, offset, TarConstants.GNAMELEN );\n+        offset += TarConstants.GNAMELEN;\n+        m_devMajor = (int)TarUtils.parseOctal( header, offset, TarConstants.DEVLEN );\n+        offset += TarConstants.DEVLEN;\n+        m_devMinor = (int)TarUtils.parseOctal( header, offset, TarConstants.DEVLEN );\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param buffer The tar entry header buffer to fill in.\n+     */\n+    public void writeEntryHeader( final byte[] buffer )\n+    {\n+        int offset = 0;\n+\n+        offset = TarUtils.getNameBytes( m_name, buffer, offset, NAMELEN );\n+        offset = TarUtils.getOctalBytes( m_mode, buffer, offset, TarConstants.MODELEN );\n+        offset = TarUtils.getOctalBytes( m_userID, buffer, offset, TarConstants.UIDLEN );\n+        offset = TarUtils.getOctalBytes( m_groupID, buffer, offset, TarConstants.GIDLEN );\n+        offset = TarUtils.getLongOctalBytes( m_size, buffer, offset, TarConstants.SIZELEN );\n+        offset = TarUtils.getLongOctalBytes( m_modTime, buffer, offset, TarConstants.MODTIMELEN );\n+\n+        final int checkSumOffset = offset;\n+        for( int i = 0; i < TarConstants.CHKSUMLEN; ++i )\n+        {\n+            buffer[ offset++ ] = (byte)' ';\n+        }\n+\n+        buffer[ offset++ ] = m_linkFlag;\n+        offset = TarUtils.getNameBytes( m_linkName, buffer, offset, NAMELEN );\n+        offset = TarUtils.getNameBytes( m_magic, buffer, offset, TarConstants.MAGICLEN );\n+        offset = TarUtils.getNameBytes( m_userName, buffer, offset, TarConstants.UNAMELEN );\n+        offset = TarUtils.getNameBytes( m_groupName, buffer, offset, TarConstants.GNAMELEN );\n+        offset = TarUtils.getOctalBytes( m_devMajor, buffer, offset, TarConstants.DEVLEN );\n+        offset = TarUtils.getOctalBytes( m_devMinor, buffer, offset, TarConstants.DEVLEN );\n+\n+        while( offset < buffer.length )\n+        {\n+            buffer[ offset++ ] = 0;\n+        }\n+\n+        final long checkSum = TarUtils.computeCheckSum( buffer );\n+        TarUtils.getCheckSumOctalBytes( checkSum, buffer, checkSumOffset, TarConstants.CHKSUMLEN );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarInputStream.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarInputStream.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * The TarInputStream reads a UNIX tar archive as an InputStream. methods are\n+ * provided to position at each successive entry in the archive, and the read\n+ * each entry as a normal input stream using read().\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ * @see TarInputStream\n+ * @see TarEntry\n+ */\n+public class TarInputStream\n+    extends FilterInputStream\n+{\n+    private TarBuffer m_buffer;\n+    private TarEntry m_currEntry;\n+    private boolean m_debug;\n+    private int m_entryOffset;\n+    private int m_entrySize;\n+    private boolean m_hasHitEOF;\n+    private byte[] m_oneBuf;\n+    private byte[] m_readBuf;\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream and default block and record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @see TarBuffer#DEFAULT_BLOCKSIZE\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarInputStream( final InputStream input )\n+    {\n+        this( input, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream, block size and default record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @param blockSize the block size to use\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarInputStream( final InputStream input,\n+                           final int blockSize )\n+    {\n+        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream, block size and record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarInputStream( final InputStream input,\n+                           final int blockSize,\n+                           final int recordSize )\n+    {\n+        super( input );\n+\n+        m_buffer = new TarBuffer( input, blockSize, recordSize );\n+        m_oneBuf = new byte[ 1 ];\n+    }\n+\n+    /**\n+     * Sets the debugging flag.\n+     *\n+     * @param debug The new Debug value\n+     */\n+    public void setDebug( final boolean debug )\n+    {\n+        m_debug = debug;\n+        m_buffer.setDebug( debug );\n+    }\n+\n+    /**\n+     * Get the next entry in this tar archive. This will skip over any remaining\n+     * data in the current entry, if there is one, and place the input stream at\n+     * the header of the next entry, and read the header and instantiate a new\n+     * TarEntry from the header bytes and return that entry. If there are no\n+     * more entries in the archive, null will be returned to indicate that the\n+     * end of the archive has been reached.\n+     *\n+     * @return The next TarEntry in the archive, or null.\n+     * @exception IOException Description of Exception\n+     */\n+    public TarEntry getNextEntry()\n+        throws IOException\n+    {\n+        if( m_hasHitEOF )\n+        {\n+            return null;\n+        }\n+\n+        if( m_currEntry != null )\n+        {\n+            final int numToSkip = m_entrySize - m_entryOffset;\n+\n+            if( m_debug )\n+            {\n+                final String message = \"TarInputStream: SKIP currENTRY '\" +\n+                    m_currEntry.getName() + \"' SZ \" + m_entrySize +\n+                    \" OFF \" + m_entryOffset + \"  skipping \" + numToSkip + \" bytes\";\n+                debug( message );\n+            }\n+\n+            if( numToSkip > 0 )\n+            {\n+                skip( numToSkip );\n+            }\n+\n+            m_readBuf = null;\n+        }\n+\n+        final byte[] headerBuf = m_buffer.readRecord();\n+        if( headerBuf == null )\n+        {\n+            if( m_debug )\n+            {\n+                debug( \"READ NULL RECORD\" );\n+            }\n+            m_hasHitEOF = true;\n+        }\n+        else if( m_buffer.isEOFRecord( headerBuf ) )\n+        {\n+            if( m_debug )\n+            {\n+                debug( \"READ EOF RECORD\" );\n+            }\n+            m_hasHitEOF = true;\n+        }\n+\n+        if( m_hasHitEOF )\n+        {\n+            m_currEntry = null;\n+        }\n+        else\n+        {\n+            m_currEntry = new TarEntry( headerBuf );\n+\n+            if( !( headerBuf[ 257 ] == 'u' && headerBuf[ 258 ] == 's' &&\n+                headerBuf[ 259 ] == 't' && headerBuf[ 260 ] == 'a' &&\n+                headerBuf[ 261 ] == 'r' ) )\n+            {\n+                //Must be v7Format\n+            }\n+\n+            if( m_debug )\n+            {\n+                final String message = \"TarInputStream: SET CURRENTRY '\" +\n+                    m_currEntry.getName() + \"' size = \" + m_currEntry.getSize();\n+                debug( message );\n+            }\n+\n+            m_entryOffset = 0;\n+\n+            // REVIEW How do we resolve this discrepancy?!\n+            m_entrySize = (int)m_currEntry.getSize();\n+        }\n+\n+        if( null != m_currEntry && m_currEntry.isGNULongNameEntry() )\n+        {\n+            // read in the name\n+            final StringBuffer longName = new StringBuffer();\n+            final byte[] buffer = new byte[ 256 ];\n+            int length = 0;\n+            while( ( length = read( buffer ) ) >= 0 )\n+            {\n+                final String str = new String( buffer, 0, length );\n+                longName.append( str );\n+            }\n+            getNextEntry();\n+            m_currEntry.setName( longName.toString() );\n+        }\n+\n+        return m_currEntry;\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Get the available data that can be read from the current entry in the\n+     * archive. This does not indicate how much data is left in the entire\n+     * archive, only in the current entry. This value is determined from the\n+     * entry's size header field and the amount of data already read from the\n+     * current entry.\n+     *\n+     * @return The number of available bytes for the current entry.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int available()\n+        throws IOException\n+    {\n+        return m_entrySize - m_entryOffset;\n+    }\n+\n+    /**\n+     * Closes this stream. Calls the TarBuffer's close() method.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        m_buffer.close();\n+    }\n+\n+    /**\n+     * Copies the contents of the current tar archive entry directly into an\n+     * output stream.\n+     *\n+     * @param output The OutputStream into which to write the entry's data.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void copyEntryContents( final OutputStream output )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 32 * 1024 ];\n+        while( true )\n+        {\n+            final int numRead = read( buffer, 0, buffer.length );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            output.write( buffer, 0, numRead );\n+        }\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     *\n+     * @param markLimit The limit to mark.\n+     */\n+    public void mark( int markLimit )\n+    {\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we return false.\n+     *\n+     * @return False.\n+     */\n+    public boolean markSupported()\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * Reads a byte from the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @return The byte read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read()\n+        throws IOException\n+    {\n+        final int num = read( m_oneBuf, 0, 1 );\n+        if( num == -1 )\n+        {\n+            return num;\n+        }\n+        else\n+        {\n+            return (int)m_oneBuf[ 0 ];\n+        }\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @param buffer The buffer into which to place bytes read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read( final byte[] buffer )\n+        throws IOException\n+    {\n+        return read( buffer, 0, buffer.length );\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry. This method is aware of\n+     * the boundaries of the current entry in the archive and will deal with\n+     * them as if they were this stream's start and EOF.\n+     *\n+     * @param buffer The buffer into which to place bytes read.\n+     * @param offset The offset at which to place bytes read.\n+     * @param count The number of bytes to read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read( final byte[] buffer,\n+                     final int offset,\n+                     final int count )\n+        throws IOException\n+    {\n+        int position = offset;\n+        int numToRead = count;\n+        int totalRead = 0;\n+\n+        if( m_entryOffset >= m_entrySize )\n+        {\n+            return -1;\n+        }\n+\n+        if( ( numToRead + m_entryOffset ) > m_entrySize )\n+        {\n+            numToRead = ( m_entrySize - m_entryOffset );\n+        }\n+\n+        if( null != m_readBuf )\n+        {\n+            final int size =\n+                ( numToRead > m_readBuf.length ) ? m_readBuf.length : numToRead;\n+\n+            System.arraycopy( m_readBuf, 0, buffer, position, size );\n+\n+            if( size >= m_readBuf.length )\n+            {\n+                m_readBuf = null;\n+            }\n+            else\n+            {\n+                final int newLength = m_readBuf.length - size;\n+                final byte[] newBuffer = new byte[ newLength ];\n+\n+                System.arraycopy( m_readBuf, size, newBuffer, 0, newLength );\n+\n+                m_readBuf = newBuffer;\n+            }\n+\n+            totalRead += size;\n+            numToRead -= size;\n+            position += size;\n+        }\n+\n+        while( numToRead > 0 )\n+        {\n+            final byte[] rec = m_buffer.readRecord();\n+            if( null == rec )\n+            {\n+                // Unexpected EOF!\n+                final String message =\n+                    \"unexpected EOF with \" + numToRead + \" bytes unread\";\n+                throw new IOException( message );\n+            }\n+\n+            int size = numToRead;\n+            final int recordLength = rec.length;\n+\n+            if( recordLength > size )\n+            {\n+                System.arraycopy( rec, 0, buffer, position, size );\n+\n+                m_readBuf = new byte[ recordLength - size ];\n+\n+                System.arraycopy( rec, size, m_readBuf, 0, recordLength - size );\n+            }\n+            else\n+            {\n+                size = recordLength;\n+\n+                System.arraycopy( rec, 0, buffer, position, recordLength );\n+            }\n+\n+            totalRead += size;\n+            numToRead -= size;\n+            position += size;\n+        }\n+\n+        m_entryOffset += totalRead;\n+\n+        return totalRead;\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     */\n+    public void reset()\n+    {\n+    }\n+\n+    /**\n+     * Skip bytes in the input buffer. This skips bytes in the current entry's\n+     * data, not the entire archive, and will stop at the end of the current\n+     * entry's data if the number to skip extends beyond that point.\n+     *\n+     * @param numToSkip The number of bytes to skip.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void skip( final int numToSkip )\n+        throws IOException\n+    {\n+        // REVIEW\n+        // This is horribly inefficient, but it ensures that we\n+        // properly skip over bytes via the TarBuffer...\n+        //\n+        final byte[] skipBuf = new byte[ 8 * 1024 ];\n+        int num = numToSkip;\n+        while( num > 0 )\n+        {\n+            final int count = ( num > skipBuf.length ) ? skipBuf.length : num;\n+            final int numRead = read( skipBuf, 0, count );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            num -= numRead;\n+        }\n+    }\n+\n+    /**\n+     * Utility method to do debugging.\n+     * Capable of being overidden in sub-classes.\n+     *\n+     * @param message the message to use in debugging\n+     */\n+    protected void debug( final String message )\n+    {\n+        if( m_debug )\n+        {\n+            System.err.println( message );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarOutputStream.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarOutputStream.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are\n+ * provided to put entries, and then write their contents by writing to this\n+ * stream using write().\n+ *\n+ * @author Timothy Gerard Endres <a href=\"mailto:time@ice.com\">time@ice.com</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ * @see TarInputStream\n+ * @see TarEntry\n+ */\n+public class TarOutputStream\n+    extends FilterOutputStream\n+{\n+    /**\n+     * Flag to indicate that an error should be generated if\n+     * an attempt is made to write an entry that exceeds the 100 char\n+     * POSIX limit.\n+     */\n+    public static final int LONGFILE_ERROR = 0;\n+\n+    /**\n+     * Flag to indicate that entry name should be truncated if\n+     * an attempt is made to write an entry that exceeds the 100 char\n+     * POSIX limit.\n+     */\n+    public static final int LONGFILE_TRUNCATE = 1;\n+\n+    /**\n+     * Flag to indicate that entry name should be formatted\n+     * according to GNU tar extension if an attempt is made\n+     * to write an entry that exceeds the 100 char POSIX\n+     * limit. Note that this makes the jar unreadable by\n+     * non-GNU tar commands.\n+     */\n+    public static final int LONGFILE_GNU = 2;\n+\n+    private int m_longFileMode = LONGFILE_ERROR;\n+    private byte[] m_assemBuf;\n+    private int m_assemLen;\n+    private TarBuffer m_buffer;\n+    private int m_currBytes;\n+    private int m_currSize;\n+\n+    private byte[] m_oneBuf;\n+    private byte[] m_recordBuf;\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream and default block and record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @see TarBuffer#DEFAULT_BLOCKSIZE\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarOutputStream( final OutputStream output )\n+    {\n+        this( output, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream, block size and default record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @param blockSize the block size\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarOutputStream( final OutputStream output,\n+                            final int blockSize )\n+    {\n+        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream, block size and record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @param blockSize the block size\n+     * @param recordSize the record size\n+     */\n+    public TarOutputStream( final OutputStream output,\n+                            final int blockSize,\n+                            final int recordSize )\n+    {\n+        super( output );\n+\n+        m_buffer = new TarBuffer( output, blockSize, recordSize );\n+        m_assemLen = 0;\n+        m_assemBuf = new byte[ recordSize ];\n+        m_recordBuf = new byte[ recordSize ];\n+        m_oneBuf = new byte[ 1 ];\n+    }\n+\n+    /**\n+     * Sets the debugging flag in this stream's TarBuffer.\n+     *\n+     * @param debug The new BufferDebug value\n+     */\n+    public void setBufferDebug( boolean debug )\n+    {\n+        m_buffer.setDebug( debug );\n+    }\n+\n+    /**\n+     * Set the mode used to work with entrys exceeding\n+     * 100 chars (and thus break the POSIX standard).\n+     * Must be one of the LONGFILE_* constants.\n+     *\n+     * @param longFileMode the mode\n+     */\n+    public void setLongFileMode( final int longFileMode )\n+    {\n+        if( LONGFILE_ERROR != longFileMode &&\n+            LONGFILE_GNU != longFileMode &&\n+            LONGFILE_TRUNCATE != longFileMode )\n+        {\n+            throw new IllegalArgumentException( \"longFileMode\" );\n+        }\n+        m_longFileMode = longFileMode;\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Ends the TAR archive and closes the underlying OutputStream. This means\n+     * that finish() is called followed by calling the TarBuffer's close().\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        finish();\n+        m_buffer.close();\n+    }\n+\n+    /**\n+     * Close an entry. This method MUST be called for all file entries that\n+     * contain data. The reason is that we must buffer data written to the\n+     * stream in order to satisfy the buffer's record based writes. Thus, there\n+     * may be data fragments still being assembled that must be written to the\n+     * output stream before this entry is closed and the next entry written.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void closeEntry()\n+        throws IOException\n+    {\n+        if( m_assemLen > 0 )\n+        {\n+            for( int i = m_assemLen; i < m_assemBuf.length; ++i )\n+            {\n+                m_assemBuf[ i ] = 0;\n+            }\n+\n+            m_buffer.writeRecord( m_assemBuf );\n+\n+            m_currBytes += m_assemLen;\n+            m_assemLen = 0;\n+        }\n+\n+        if( m_currBytes < m_currSize )\n+        {\n+            final String message = \"entry closed at '\" + m_currBytes +\n+                \"' before the '\" + m_currSize +\n+                \"' bytes specified in the header were written\";\n+            throw new IOException( message );\n+        }\n+    }\n+\n+    /**\n+     * Ends the TAR archive without closing the underlying OutputStream. The\n+     * result is that the EOF record of nulls is written.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void finish()\n+        throws IOException\n+    {\n+        writeEOFRecord();\n+    }\n+\n+    /**\n+     * Put an entry on the output stream. This writes the entry's header record\n+     * and positions the output stream for writing the contents of the entry.\n+     * Once this method is called, the stream is ready for calls to write() to\n+     * write the entry's contents. Once the contents are written, closeEntry()\n+     * <B>MUST</B> be called to ensure that all buffered data is completely\n+     * written to the output stream.\n+     *\n+     * @param entry The TarEntry to be written to the archive.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void putNextEntry( final TarEntry entry )\n+        throws IOException\n+    {\n+        if( entry.getName().length() >= TarEntry.NAMELEN )\n+        {\n+            if( m_longFileMode == LONGFILE_GNU )\n+            {\n+                // create a TarEntry for the LongLink, the contents\n+                // of which are the entry's name\n+                final TarEntry longLinkEntry =\n+                    new TarEntry( TarConstants.GNU_LONGLINK,\n+                                  TarConstants.LF_GNUTYPE_LONGNAME );\n+\n+                longLinkEntry.setSize( entry.getName().length() );\n+                putNextEntry( longLinkEntry );\n+                write( entry.getName().getBytes() );\n+                //write( 0 );\n+                closeEntry();\n+            }\n+            else if( m_longFileMode != LONGFILE_TRUNCATE )\n+            {\n+                final String message = \"file name '\" + entry.getName() +\n+                    \"' is too long ( > \" + TarEntry.NAMELEN + \" bytes)\";\n+                throw new IOException( message );\n+            }\n+        }\n+\n+        entry.writeEntryHeader( m_recordBuf );\n+        m_buffer.writeRecord( m_recordBuf );\n+\n+        m_currBytes = 0;\n+\n+        if( entry.isDirectory() )\n+        {\n+            m_currSize = 0;\n+        }\n+        else\n+        {\n+            m_currSize = (int)entry.getSize();\n+        }\n+    }\n+\n+    /**\n+     * Copies the contents of the specified stream into current tar\n+     * archive entry.\n+     *\n+     * @param input The InputStream from which to read entrys data\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void copyEntryContents( final InputStream input )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 32 * 1024 ];\n+        while( true )\n+        {\n+            final int numRead = input.read( buffer, 0, buffer.length );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            write( buffer, 0, numRead );\n+        }\n+    }\n+\n+    /**\n+     * Writes a byte to the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @param data The byte written.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final int data )\n+        throws IOException\n+    {\n+        m_oneBuf[ 0 ] = (byte)data;\n+\n+        write( m_oneBuf, 0, 1 );\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method simply calls\n+     * write( byte[], int, int ).\n+     *\n+     * @param buffer The buffer to write to the archive.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer )\n+        throws IOException\n+    {\n+        write( buffer, 0, buffer.length );\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method is aware of\n+     * the current entry and will throw an exception if you attempt to write\n+     * bytes past the length specified for the current entry. The method is also\n+     * (painfully) aware of the record buffering required by TarBuffer, and\n+     * manages buffers that are not a multiple of recordsize in length,\n+     * including assembling records from small buffers.\n+     *\n+     * @param buffer The buffer to write to the archive.\n+     * @param offset The offset in the buffer from which to get bytes.\n+     * @param count The number of bytes to write.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer,\n+                       final int offset,\n+                       final int count )\n+        throws IOException\n+    {\n+        int position = offset;\n+        int numToWrite = count;\n+        if( ( m_currBytes + numToWrite ) > m_currSize )\n+        {\n+            final String message = \"request to write '\" + numToWrite +\n+                \"' bytes exceeds size in header of '\" + m_currSize + \"' bytes\";\n+            throw new IOException( message );\n+            //\n+            // We have to deal with assembly!!!\n+            // The programmer can be writing little 32 byte chunks for all\n+            // we know, and we must assemble complete records for writing.\n+            // REVIEW Maybe this should be in TarBuffer? Could that help to\n+            // eliminate some of the buffer copying.\n+            //\n+        }\n+\n+        if( m_assemLen > 0 )\n+        {\n+            if( ( m_assemLen + numToWrite ) >= m_recordBuf.length )\n+            {\n+                final int length = m_recordBuf.length - m_assemLen;\n+\n+                System.arraycopy( m_assemBuf, 0, m_recordBuf, 0,\n+                                  m_assemLen );\n+                System.arraycopy( buffer, position, m_recordBuf,\n+                                  m_assemLen, length );\n+                m_buffer.writeRecord( m_recordBuf );\n+\n+                m_currBytes += m_recordBuf.length;\n+                position += length;\n+                numToWrite -= length;\n+                m_assemLen = 0;\n+            }\n+            else\n+            {\n+                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n+                                  numToWrite );\n+\n+                position += numToWrite;\n+                m_assemLen += numToWrite;\n+                numToWrite -= numToWrite;\n+            }\n+        }\n+\n+        //\n+        // When we get here we have EITHER:\n+        // o An empty \"assemble\" buffer.\n+        // o No bytes to write (numToWrite == 0)\n+        //\n+        while( numToWrite > 0 )\n+        {\n+            if( numToWrite < m_recordBuf.length )\n+            {\n+                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n+                                  numToWrite );\n+\n+                m_assemLen += numToWrite;\n+\n+                break;\n+            }\n+\n+            m_buffer.writeRecord( buffer, position );\n+\n+            int num = m_recordBuf.length;\n+\n+            m_currBytes += num;\n+            numToWrite -= num;\n+            position += num;\n+        }\n+    }\n+\n+    /**\n+     * Write an EOF (end of archive) record to the tar archive. An EOF record\n+     * consists of a record of all zeros.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    private void writeEOFRecord()\n+        throws IOException\n+    {\n+        for( int i = 0; i < m_recordBuf.length; ++i )\n+        {\n+            m_recordBuf[ i ] = 0;\n+        }\n+\n+        m_buffer.writeRecord( m_recordBuf );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/tar/TarUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/tar/TarUtils.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.tar;\n+\n+/**\n+ * This class provides static utility methods to work with byte streams.\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:46 $\n+ */\n+class TarUtils\n+{\n+    /**\n+     * Parse the checksum octal integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param value Description of Parameter\n+     * @param buf Description of Parameter\n+     * @return The integer value of the entry's checksum.\n+     */\n+    public static int getCheckSumOctalBytes( final long value,\n+                                             final byte[] buf,\n+                                             final int offset,\n+                                             final int length )\n+    {\n+        getOctalBytes( value, buf, offset, length );\n+\n+        buf[ offset + length - 1 ] = (byte)' ';\n+        buf[ offset + length - 2 ] = 0;\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal long integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param value Description of Parameter\n+     * @param buf Description of Parameter\n+     * @return The long value of the octal bytes.\n+     */\n+    public static int getLongOctalBytes( final long value,\n+                                         final byte[] buf,\n+                                         final int offset,\n+                                         final int length )\n+    {\n+        byte[] temp = new byte[ length + 1 ];\n+\n+        getOctalBytes( value, temp, 0, length + 1 );\n+        System.arraycopy( temp, 0, buf, offset, length );\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Determine the number of bytes in an entry name.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param name Description of Parameter\n+     * @param buffer Description of Parameter\n+     * @return The number of bytes in a header's entry name.\n+     */\n+    public static int getNameBytes( final StringBuffer name,\n+                                    final byte[] buffer,\n+                                    final int offset,\n+                                    final int length )\n+    {\n+        int i;\n+\n+        for( i = 0; i < length && i < name.length(); ++i )\n+        {\n+            buffer[ offset + i ] = (byte)name.charAt( i );\n+        }\n+\n+        for( ; i < length; ++i )\n+        {\n+            buffer[ offset + i ] = 0;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the octal bytes.\n+     */\n+    public static int getOctalBytes( final long value,\n+                                     final byte[] buffer,\n+                                     final int offset,\n+                                     final int length )\n+    {\n+        int idx = length - 1;\n+\n+        buffer[ offset + idx ] = 0;\n+        --idx;\n+        buffer[ offset + idx ] = (byte)' ';\n+        --idx;\n+\n+        if( value == 0 )\n+        {\n+            buffer[ offset + idx ] = (byte)'0';\n+            --idx;\n+        }\n+        else\n+        {\n+            long val = value;\n+            while( idx >= 0 && val > 0 )\n+            {\n+                buffer[ offset + idx ] = (byte)( (byte)'0' + (byte)( val & 7 ) );\n+                val = val >> 3;\n+                idx--;\n+            }\n+        }\n+\n+        while( idx >= 0 )\n+        {\n+            buffer[ offset + idx ] = (byte)' ';\n+            idx--;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Compute the checksum of a tar entry header.\n+     *\n+     * @param buffer The tar entry's header buffer.\n+     * @return The computed checksum.\n+     */\n+    public static long computeCheckSum( final byte[] buffer )\n+    {\n+        long sum = 0;\n+\n+        for( int i = 0; i < buffer.length; ++i )\n+        {\n+            sum += 255 & buffer[ i ];\n+        }\n+\n+        return sum;\n+    }\n+\n+    /**\n+     * Parse an entry name from a header buffer.\n+     *\n+     * @param header The header buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The header's entry name.\n+     */\n+    public static StringBuffer parseName( final byte[] header,\n+                                          final int offset,\n+                                          final int length )\n+    {\n+        StringBuffer result = new StringBuffer( length );\n+        int end = offset + length;\n+\n+        for( int i = offset; i < end; ++i )\n+        {\n+            if( header[ i ] == 0 )\n+            {\n+                break;\n+            }\n+\n+            result.append( (char)header[ i ] );\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Parse an octal string from a header buffer. This is used for the file\n+     * permission mode value.\n+     *\n+     * @param header The header buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The long value of the octal string.\n+     */\n+    public static long parseOctal( final byte[] header,\n+                                   final int offset,\n+                                   final int length )\n+    {\n+        long result = 0;\n+        boolean stillPadding = true;\n+        int end = offset + length;\n+\n+        for( int i = offset; i < end; ++i )\n+        {\n+            if( header[ i ] == 0 )\n+            {\n+                break;\n+            }\n+\n+            if( header[ i ] == (byte)' ' || header[ i ] == '0' )\n+            {\n+                if( stillPadding )\n+                {\n+                    continue;\n+                }\n+\n+                if( header[ i ] == (byte)' ' )\n+                {\n+                    break;\n+                }\n+            }\n+\n+            stillPadding = false;\n+            result = ( result << 3 ) + ( header[ i ] - '0' );\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/AsiExtraField.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/AsiExtraField.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Adds Unix file permission and UID/GID fields as well as symbolic link\n+ * handling. <p>\n+ *\n+ * This class uses the ASi extra field in the format: <pre>\n+ *         Value         Size            Description\n+ *         -----         ----            -----------\n+ * (Unix3) 0x756e        Short           tag for this extra block type\n+ *         TSize         Short           total data size for this block\n+ *         CRC           Long            CRC-32 of the remaining data\n+ *         Mode          Short           file permissions\n+ *         SizDev        Long            symlink'd size OR major/minor dev num\n+ *         UID           Short           user ID\n+ *         GID           Short           group ID\n+ *         (var.)        variable        symbolic link filename\n+ * </pre> taken from appnote.iz (Info-ZIP note, 981119) found at <a\n+ * href=\"ftp://ftp.uu.net/pub/archiving/zip/doc/\">\n+ * ftp://ftp.uu.net/pub/archiving/zip/doc/</a> </p> <p>\n+ *\n+ * Short is two bytes and Long is four bytes in big endian byte and word order,\n+ * device numbers are currently not supported.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public class AsiExtraField\n+    implements ZipExtraField, UnixStat, Cloneable\n+{\n+    private static final ZipShort HEADER_ID = new ZipShort( 0x756E );\n+\n+    /**\n+     * Standard Unix stat(2) file mode.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_mode;\n+\n+    /**\n+     * User ID.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_uid;\n+\n+    /**\n+     * Group ID.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_gid;\n+\n+    /**\n+     * File this entry points to, if it is a symbolic link. <p>\n+     *\n+     * empty string - if entry is not a symbolic link.</p>\n+     *\n+     * @since 1.1\n+     */\n+    private String m_link = \"\";\n+\n+    /**\n+     * Is this an entry for a directory?\n+     *\n+     * @since 1.1\n+     */\n+    private boolean m_dirFlag;\n+\n+    /**\n+     * Instance used to calculate checksums.\n+     *\n+     * @since 1.1\n+     */\n+    private CRC32 m_crc = new CRC32();\n+\n+    /**\n+     * Indicate whether this entry is a directory.\n+     *\n+     * @param dirFlag The new Directory value\n+     * @since 1.1\n+     */\n+    public void setDirectory( final boolean dirFlag )\n+    {\n+        m_dirFlag = dirFlag;\n+        m_mode = getMode( m_mode );\n+    }\n+\n+    /**\n+     * Set the group id.\n+     *\n+     * @param gid The new GroupId value\n+     * @since 1.1\n+     */\n+    public void setGroupId( int gid )\n+    {\n+        m_gid = gid;\n+    }\n+\n+    /**\n+     * Indicate that this entry is a symbolic link to the given filename.\n+     *\n+     * @param name Name of the file this entry links to, empty String if it is\n+     *      not a symbolic link.\n+     * @since 1.1\n+     */\n+    public void setLinkedFile( final String name )\n+    {\n+        m_link = name;\n+        m_mode = getMode( m_mode );\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     *\n+     * @param mode The new Mode value\n+     * @since 1.1\n+     */\n+    public void setMode( final int mode )\n+    {\n+        m_mode = getMode( mode );\n+    }\n+\n+    /**\n+     * Set the user id.\n+     *\n+     * @param uid The new UserId value\n+     * @since 1.1\n+     * @deprecated Use setUserID(int)\n+     * @see #setUserID(int)\n+     */\n+    public void setUserId( final int uid )\n+    {\n+        m_uid = uid;\n+    }\n+\n+    /**\n+     * Set the user id.\n+     *\n+     * @param uid The new UserId value\n+     */\n+    public void setUserID( final int uid )\n+    {\n+        m_uid = uid;\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     *\n+     * @return The CentralDirectoryData value\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryData()\n+    {\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     *\n+     * @return The CentralDirectoryLength value\n+     * @since 1.1\n+     */\n+    public ZipShort getCentralDirectoryLength()\n+    {\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the group id.\n+     *\n+     * @return The GroupId value\n+     * @since 1.1\n+     */\n+    public int getGroupID()\n+    {\n+        return m_gid;\n+    }\n+\n+    /**\n+     * Get the group id.\n+     *\n+     * @return The GroupId value\n+     * @since 1.1\n+     * @deprecated Use getGroupID() instead\n+     * @see #getGroupID()\n+     */\n+    public int getGroupId()\n+    {\n+        return m_gid;\n+    }\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return The HeaderId value\n+     * @since 1.1\n+     */\n+    public ZipShort getHeaderID()\n+    {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Name of linked file\n+     *\n+     * @return name of the file this entry links to if it is a symbolic link,\n+     *      the empty string otherwise.\n+     * @since 1.1\n+     */\n+    public String getLinkedFile()\n+    {\n+        return m_link;\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The LocalFileDataData value\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataData()\n+    {\n+        // CRC will be added later\n+        byte[] data = new byte[ getLocalFileDataLength().getValue() - 4 ];\n+        System.arraycopy( ( new ZipShort( getMode() ) ).getBytes(), 0, data, 0, 2 );\n+\n+        byte[] linkArray = getLinkedFile().getBytes();\n+        System.arraycopy( ( new ZipLong( linkArray.length ) ).getBytes(),\n+                          0, data, 2, 4 );\n+\n+        System.arraycopy( ( new ZipShort( getUserID() ) ).getBytes(),\n+                          0, data, 6, 2 );\n+        System.arraycopy( ( new ZipShort( getGroupID() ) ).getBytes(),\n+                          0, data, 8, 2 );\n+\n+        System.arraycopy( linkArray, 0, data, 10, linkArray.length );\n+\n+        m_crc.reset();\n+        m_crc.update( data );\n+        long checksum = m_crc.getValue();\n+\n+        byte[] result = new byte[ data.length + 4 ];\n+        System.arraycopy( ( new ZipLong( checksum ) ).getBytes(), 0, result, 0, 4 );\n+        System.arraycopy( data, 0, result, 4, data.length );\n+        return result;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The LocalFileDataLength value\n+     * @since 1.1\n+     */\n+    public ZipShort getLocalFileDataLength()\n+    {\n+        return new ZipShort( 4 + // CRC\n+                             2 + // Mode\n+                             4 + // SizDev\n+                             2 + // UID\n+                             2 + // GID\n+                             getLinkedFile().getBytes().length );\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     *\n+     * @return The Mode value\n+     * @since 1.1\n+     */\n+    public int getMode()\n+    {\n+        return m_mode;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     *\n+     * @return The UserId value\n+     * @since 1.1\n+     * @deprecated Use getUserID()\n+     * @see #getUserID()\n+     */\n+    public int getUserId()\n+    {\n+        return m_uid;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     *\n+     * @return The UserID value\n+     */\n+    public int getUserID()\n+    {\n+        return m_uid;\n+    }\n+\n+    /**\n+     * Is this entry a directory?\n+     *\n+     * @return The Directory value\n+     * @since 1.1\n+     */\n+    public boolean isDirectory()\n+    {\n+        return m_dirFlag && !isLink();\n+    }\n+\n+    /**\n+     * Is this entry a symbolic link?\n+     *\n+     * @return The Link value\n+     * @since 1.1\n+     */\n+    public boolean isLink()\n+    {\n+        return getLinkedFile().length() != 0;\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param buffer the buffer\n+     * @param offset the offset into buffer\n+     * @param length the length of data in buffer\n+     * @throws ZipException on error\n+     * @since 1.1\n+     */\n+    public void parseFromLocalFileData( final byte[] buffer,\n+                                        final int offset,\n+                                        final int length )\n+        throws ZipException\n+    {\n+\n+        long givenChecksum = ( new ZipLong( buffer, offset ) ).getValue();\n+        byte[] tmp = new byte[ length - 4 ];\n+        System.arraycopy( buffer, offset + 4, tmp, 0, length - 4 );\n+        m_crc.reset();\n+        m_crc.update( tmp );\n+        long realChecksum = m_crc.getValue();\n+        if( givenChecksum != realChecksum )\n+        {\n+            throw new ZipException( \"bad CRC checksum \" + Long.toHexString( givenChecksum ) +\n+                                    \" instead of \" + Long.toHexString( realChecksum ) );\n+        }\n+\n+        int newMode = ( new ZipShort( tmp, 0 ) ).getValue();\n+        byte[] linkArray = new byte[ (int)( new ZipLong( tmp, 2 ) ).getValue() ];\n+        m_uid = ( new ZipShort( tmp, 6 ) ).getValue();\n+        m_gid = ( new ZipShort( tmp, 8 ) ).getValue();\n+\n+        if( linkArray.length == 0 )\n+        {\n+            m_link = \"\";\n+        }\n+        else\n+        {\n+            System.arraycopy( tmp, 10, linkArray, 0, linkArray.length );\n+            m_link = new String( linkArray );\n+        }\n+        setDirectory( ( newMode & DIR_FLAG ) != 0 );\n+        setMode( newMode );\n+    }\n+\n+    /**\n+     * Get the file mode for given permissions with the correct file type.\n+     *\n+     * @param mode Description of Parameter\n+     * @return The Mode value\n+     * @since 1.1\n+     */\n+    protected int getMode( final int mode )\n+    {\n+        int type = FILE_FLAG;\n+        if( isLink() )\n+        {\n+            type = LINK_FLAG;\n+        }\n+        else if( isDirectory() )\n+        {\n+            type = DIR_FLAG;\n+        }\n+        return type | ( mode & PERM_MASK );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ExtraFieldUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ExtraFieldUtils.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * ZipExtraField related methods\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public class ExtraFieldUtils\n+{\n+    /**\n+     * Static registry of known extra fields.\n+     *\n+     * @since 1.1\n+     */\n+    private static final Hashtable c_implementations;\n+\n+    static\n+    {\n+        c_implementations = new Hashtable();\n+        register( AsiExtraField.class );\n+    }\n+\n+    /**\n+     * Create an instance of the approriate ExtraField, falls back to {@link\n+     * UnrecognizedExtraField UnrecognizedExtraField}.\n+     *\n+     * Throws java.lang.IllegalAccessException if cant create implementation.\n+     *\n+     * @param headerID the header ID\n+     * @return the extra field implementation\n+     * @throws InstantiationException if cant create implementation\n+     * @throws IllegalAccessException if cant create implementation\n+     * @since 1.1\n+     */\n+    public static ZipExtraField createExtraField( final ZipShort headerID )\n+        throws InstantiationException, IllegalAccessException\n+    {\n+        final Class clazz =\n+            (Class)c_implementations.get( headerID );\n+        if( clazz != null )\n+        {\n+            return (ZipExtraField)clazz.newInstance();\n+        }\n+        final UnrecognizedExtraField unrecognized = new UnrecognizedExtraField();\n+        unrecognized.setHeaderID( headerID );\n+        return unrecognized;\n+    }\n+\n+    /**\n+     * Merges the central directory fields of the given ZipExtraFields.\n+     *\n+     * @param data the central directory data\n+     * @return the merged data\n+     * @since 1.1\n+     */\n+    public static byte[] mergeCentralDirectoryData( final ZipExtraField[] data )\n+    {\n+        int sum = 4 * data.length;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            sum += data[ i ].getCentralDirectoryLength().getValue();\n+        }\n+        byte[] result = new byte[ sum ];\n+        int start = 0;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n+                              0, result, start, 2 );\n+            System.arraycopy( data[ i ].getCentralDirectoryLength().getBytes(),\n+                              0, result, start + 2, 2 );\n+            byte[] local = data[ i ].getCentralDirectoryData();\n+            System.arraycopy( local, 0, result, start + 4, local.length );\n+            start += ( local.length + 4 );\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Merges the local file data fields of the given ZipExtraFields.\n+     *\n+     * @param data the data\n+     * @return the merged data\n+     * @since 1.1\n+     */\n+    public static byte[] mergeLocalFileDataData( final ZipExtraField[] data )\n+    {\n+        int sum = 4 * data.length;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            sum += data[ i ].getLocalFileDataLength().getValue();\n+        }\n+        byte[] result = new byte[ sum ];\n+        int start = 0;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n+                              0, result, start, 2 );\n+            System.arraycopy( data[ i ].getLocalFileDataLength().getBytes(),\n+                              0, result, start + 2, 2 );\n+            byte[] local = data[ i ].getLocalFileDataData();\n+            System.arraycopy( local, 0, result, start + 4, local.length );\n+            start += ( local.length + 4 );\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Split the array into ExtraFields and populate them with the give data.\n+     *\n+     * @param data the data to parse\n+     * @return the parsed fields\n+     * @exception ZipException on error\n+     * @since 1.1\n+     */\n+    public static ZipExtraField[] parse( final byte[] data )\n+        throws ZipException\n+    {\n+        ArrayList v = new ArrayList();\n+        int start = 0;\n+        while( start <= data.length - 4 )\n+        {\n+            final ZipShort headerID = new ZipShort( data, start );\n+            int length = ( new ZipShort( data, start + 2 ) ).getValue();\n+            if( start + 4 + length > data.length )\n+            {\n+                throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n+            }\n+            try\n+            {\n+                ZipExtraField ze = createExtraField( headerID );\n+                ze.parseFromLocalFileData( data, start + 4, length );\n+                v.add( ze );\n+            }\n+            catch( InstantiationException ie )\n+            {\n+                throw new ZipException( ie.getMessage() );\n+            }\n+            catch( IllegalAccessException iae )\n+            {\n+                throw new ZipException( iae.getMessage() );\n+            }\n+            start += ( length + 4 );\n+        }\n+        if( start != data.length )\n+        {// array not exhausted\n+            throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n+        }\n+\n+        final ZipExtraField[] result = new ZipExtraField[ v.size() ];\n+        return (ZipExtraField[])v.toArray( result );\n+    }\n+\n+    /**\n+     * Register a ZipExtraField implementation. <p>\n+     *\n+     * The given class must have a no-arg constructor and implement the {@link\n+     * ZipExtraField ZipExtraField interface}.</p>\n+     *\n+     * @param clazz The Class for particular implementation\n+     * @since 1.1\n+     */\n+    public static void register( final Class clazz )\n+    {\n+        try\n+        {\n+            ZipExtraField ze = (ZipExtraField)clazz.newInstance();\n+            c_implementations.put( ze.getHeaderID(), clazz );\n+        }\n+        catch( ClassCastException cc )\n+        {\n+            throw new RuntimeException( clazz +\n+                                        \" doesn\\'t implement ZipExtraField\" );\n+        }\n+        catch( InstantiationException ie )\n+        {\n+            throw new RuntimeException( clazz + \" is not a concrete class\" );\n+        }\n+        catch( IllegalAccessException ie )\n+        {\n+            throw new RuntimeException( clazz +\n+                                        \"\\'s no-arg constructor is not public\" );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/UnixStat.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/UnixStat.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+/**\n+ * Constants from stat.h on Unix systems.\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public interface UnixStat\n+{\n+    /**\n+     * Bits used for permissions (and sticky bit)\n+     *\n+     * @since 1.1\n+     */\n+    int PERM_MASK = 07777;\n+    /**\n+     * Indicates symbolic links.\n+     *\n+     * @since 1.1\n+     */\n+    int LINK_FLAG = 0120000;\n+    /**\n+     * Indicates plain files.\n+     *\n+     * @since 1.1\n+     */\n+    int FILE_FLAG = 0100000;\n+    /**\n+     * Indicates directories.\n+     *\n+     * @since 1.1\n+     */\n+    int DIR_FLAG = 040000;\n+\n+    // ----------------------------------------------------------\n+    // somewhat arbitrary choices that are quite common for shared\n+    // installations\n+    // -----------------------------------------------------------\n+\n+    /**\n+     * Default permissions for symbolic links.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_LINK_PERM = 0777;\n+\n+    /**\n+     * Default permissions for directories.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_DIR_PERM = 0755;\n+\n+    /**\n+     * Default permissions for plain files.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_FILE_PERM = 0644;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/UnrecognizedExtraField.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/UnrecognizedExtraField.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+/**\n+ * Simple placeholder for all those extra fields we don't want to deal with. <p>\n+ *\n+ * Assumes local file data and central directory entries are identical - unless\n+ * told the opposite.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public class UnrecognizedExtraField\n+    implements ZipExtraField\n+{\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     *\n+     * @since 1.1\n+     */\n+    private byte[] m_centralData;\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipShort m_headerID;\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @since 1.1\n+     */\n+    private byte[] m_localData;\n+\n+    /**\n+     * Set the central directory data\n+     *\n+     * @param centralData the central directory data\n+     */\n+    public void setCentralDirectoryData( final byte[] centralData )\n+    {\n+        m_centralData = centralData;\n+    }\n+\n+    /**\n+     * Set the header ID.\n+     *\n+     * @param headerID the header ID\n+     * @deprecated Use setHeaderID() instead\n+     * @see #setHeaderID(ZipShort)\n+     */\n+    public void setHeaderId( final ZipShort headerID )\n+    {\n+        setHeaderID( headerID );\n+    }\n+\n+    /**\n+     * Set the header ID.\n+     *\n+     * @param headerID the header ID\n+     */\n+    public void setHeaderID( final ZipShort headerID )\n+    {\n+        m_headerID = headerID;\n+    }\n+\n+    /**\n+     * Set the local file data.\n+     *\n+     * @param localData the local file data\n+     */\n+    public void setLocalFileDataData( final byte[] localData )\n+    {\n+        m_localData = localData;\n+    }\n+\n+    /**\n+     * Get the central directory data.\n+     *\n+     * @return the central directory data.\n+     */\n+    public byte[] getCentralDirectoryData()\n+    {\n+        if( m_centralData != null )\n+        {\n+            return m_centralData;\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Get the length of the central directory in bytes.\n+     *\n+     * @return the length of the central directory in bytes.\n+     */\n+    public ZipShort getCentralDirectoryLength()\n+    {\n+        if( m_centralData != null )\n+        {\n+            return new ZipShort( m_centralData.length );\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the HeaderID.\n+     *\n+     * @return the HeaderID\n+     * @deprecated Use getHeaderID() instead\n+     * @see #getHeaderID()\n+     */\n+    public ZipShort getHeaderId()\n+    {\n+        return m_headerID;\n+    }\n+\n+    /**\n+     * Get the HeaderID.\n+     *\n+     * @return the HeaderID\n+     */\n+    public ZipShort getHeaderID()\n+    {\n+        return m_headerID;\n+    }\n+\n+    /**\n+     * Get the local file data.\n+     *\n+     * @return the local file data\n+     */\n+    public byte[] getLocalFileDataData()\n+    {\n+        return m_localData;\n+    }\n+\n+    /**\n+     * Get the length of local file data in bytes.\n+     *\n+     * @return the length of local file data in bytes\n+     */\n+    public ZipShort getLocalFileDataLength()\n+    {\n+        return new ZipShort( m_localData.length );\n+    }\n+\n+    /**\n+     * Parse LocalFiledata out of supplied buffer.\n+     *\n+     * @param buffer the buffer to use\n+     * @param offset the offset into buffer\n+     * @param length then length of data\n+     */\n+    public void parseFromLocalFileData( final byte[] buffer,\n+                                        final int offset,\n+                                        final int length )\n+    {\n+        final byte[] fileData = new byte[ length ];\n+        System.arraycopy( buffer, offset, fileData, 0, length );\n+        setLocalFileDataData( fileData );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ZipEntry.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ZipEntry.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Extension that adds better handling of extra fields and provides access to\n+ * the internal and external file attributes.\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public class ZipEntry\n+    extends java.util.zip.ZipEntry\n+{\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static Method c_setCompressedSizeMethod;\n+\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static final Object c_lockReflection = new Object();\n+\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static boolean c_triedToGetMethod;\n+\n+    private final ArrayList m_extraFields = new ArrayList();\n+\n+    private int m_internalAttributes;\n+    private long m_externalAttributes;\n+\n+    /**\n+     * Helper for JDK 1.1 <-> 1.2 incompatibility.\n+     *\n+     * @since 1.2\n+     */\n+    private Long m_compressedSize;\n+\n+    /**\n+     * Creates a new zip entry with the specified name.\n+     *\n+     * @param name the name of entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     *\n+     * @param entry the JDK ZipEntry to adapt\n+     * @exception ZipException if can not create entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( java.util.zip.ZipEntry entry )\n+        throws ZipException\n+    {\n+        /*\n+         * REVISIT: call super(entry) instead of this stuff in Ant2,\n+         * \"copy constructor\" has not been available in JDK 1.1\n+         */\n+        super( entry.getName() );\n+\n+        setComment( entry.getComment() );\n+        setMethod( entry.getMethod() );\n+        setTime( entry.getTime() );\n+\n+        final long size = entry.getSize();\n+        if( size > 0 )\n+        {\n+            setSize( size );\n+        }\n+\n+        final long cSize = entry.getCompressedSize();\n+        if( cSize > 0 )\n+        {\n+            setComprSize( cSize );\n+        }\n+\n+        final long crc = entry.getCrc();\n+        if( crc > 0 )\n+        {\n+            setCrc( crc );\n+        }\n+\n+        final byte[] extra = entry.getExtra();\n+        if( extra != null )\n+        {\n+            setExtraFields( ExtraFieldUtils.parse( extra ) );\n+        }\n+        else\n+        {\n+            // initializes extra data to an empty byte array\n+            setExtra();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     *\n+     * @param entry the entry to adapt\n+     * @exception ZipException if can not create entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( final ZipEntry entry )\n+        throws ZipException\n+    {\n+        this( (java.util.zip.ZipEntry)entry );\n+        setInternalAttributes( entry.getInternalAttributes() );\n+        setExternalAttributes( entry.getExternalAttributes() );\n+        setExtraFields( entry.getExtraFields() );\n+    }\n+\n+    /**\n+     * Try to get a handle to the setCompressedSize method.\n+     *\n+     * @since 1.2\n+     */\n+    private static void checkSCS()\n+    {\n+        if( !c_triedToGetMethod )\n+        {\n+            synchronized( c_lockReflection )\n+            {\n+                c_triedToGetMethod = true;\n+                try\n+                {\n+                    c_setCompressedSizeMethod =\n+                        java.util.zip.ZipEntry.class.getMethod( \"setCompressedSize\",\n+                                                                new Class[]{Long.TYPE} );\n+                }\n+                catch( NoSuchMethodException nse )\n+                {\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Are we running JDK 1.2 or higher?\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.2\n+     */\n+    private static boolean haveSetCompressedSize()\n+    {\n+        checkSCS();\n+        return c_setCompressedSizeMethod != null;\n+    }\n+\n+    /**\n+     * Invoke setCompressedSize via reflection.\n+     *\n+     * @param entry Description of Parameter\n+     * @param size Description of Parameter\n+     * @since 1.2\n+     */\n+    private static void performSetCompressedSize( final ZipEntry entry,\n+                                                  final long size )\n+    {\n+        final Long[] s = {new Long( size )};\n+        try\n+        {\n+            c_setCompressedSizeMethod.invoke( entry, s );\n+        }\n+        catch( final InvocationTargetException ite )\n+        {\n+            final Throwable nested = ite.getTargetException();\n+            final String message = \"Exception setting the compressed size \" +\n+                \"of \" + entry + \": \" + nested.getMessage();\n+            throw new RuntimeException( message );\n+        }\n+        catch( final Throwable t )\n+        {\n+            final String message = \"Exception setting the compressed size \" +\n+                \"of \" + entry + \": \" + t.getMessage();\n+            throw new RuntimeException( message );\n+        }\n+    }\n+\n+    /**\n+     * Make this class work in JDK 1.1 like a 1.2 class. <p>\n+     *\n+     * This either stores the size for later usage or invokes setCompressedSize\n+     * via reflection.</p>\n+     *\n+     * @param size The new ComprSize value\n+     * @since 1.2\n+     */\n+    public void setComprSize( final long size )\n+    {\n+        if( haveSetCompressedSize() )\n+        {\n+            performSetCompressedSize( this, size );\n+        }\n+        else\n+        {\n+            m_compressedSize = new Long( size );\n+        }\n+    }\n+\n+    /**\n+     * Sets the external file attributes.\n+     *\n+     * @param externalAttributes The new ExternalAttributes value\n+     * @since 1.1\n+     */\n+    public void setExternalAttributes( final long externalAttributes )\n+    {\n+        m_externalAttributes = externalAttributes;\n+    }\n+\n+    /**\n+     * Throws an Exception if extra data cannot be parsed into extra fields.\n+     *\n+     * @param extra The new Extra value\n+     * @throws RuntimeException if fail to set extra data\n+     * @since 1.1\n+     */\n+    public void setExtra( final byte[] extra )\n+        throws RuntimeException\n+    {\n+        try\n+        {\n+            setExtraFields( ExtraFieldUtils.parse( extra ) );\n+        }\n+        catch( final Exception e )\n+        {\n+            throw new RuntimeException( e.getMessage() );\n+        }\n+    }\n+\n+    /**\n+     * Replaces all currently attached extra fields with the new array.\n+     *\n+     * @param fields The new ExtraFields value\n+     * @since 1.1\n+     */\n+    public void setExtraFields( final ZipExtraField[] fields )\n+    {\n+        m_extraFields.clear();\n+        for( int i = 0; i < fields.length; i++ )\n+        {\n+            m_extraFields.add( fields[ i ] );\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Sets the internal file attributes.\n+     *\n+     * @param value The new InternalAttributes value\n+     * @since 1.1\n+     */\n+    public void setInternalAttributes( final int value )\n+    {\n+        m_internalAttributes = value;\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the central directory.\n+     *\n+     * @return The CentralDirectoryExtra value\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryExtra()\n+    {\n+        return ExtraFieldUtils.mergeCentralDirectoryData( getExtraFields() );\n+    }\n+\n+    /**\n+     * Override to make this class work in JDK 1.1 like a 1.2 class.\n+     *\n+     * @return The CompressedSize value\n+     * @since 1.2\n+     */\n+    public long getCompressedSize()\n+    {\n+        if( m_compressedSize != null )\n+        {\n+            // has been set explicitly and we are running in a 1.1 VM\n+            return m_compressedSize.longValue();\n+        }\n+        return super.getCompressedSize();\n+    }\n+\n+    /**\n+     * Retrieves the external file attributes.\n+     *\n+     * @return The ExternalAttributes value\n+     * @since 1.1\n+     */\n+    public long getExternalAttributes()\n+    {\n+        return m_externalAttributes;\n+    }\n+\n+    /**\n+     * Retrieves extra fields.\n+     *\n+     * @return The ExtraFields value\n+     * @since 1.1\n+     */\n+    public ZipExtraField[] getExtraFields()\n+    {\n+        final ZipExtraField[] result = new ZipExtraField[ m_extraFields.size() ];\n+        return (ZipExtraField[])m_extraFields.toArray( result );\n+    }\n+\n+    /**\n+     * Retrieves the internal file attributes.\n+     *\n+     * @return The InternalAttributes value\n+     * @since 1.1\n+     */\n+    public int getInternalAttributes()\n+    {\n+        return m_internalAttributes;\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the local file data.\n+     *\n+     * @return The LocalFileDataExtra value\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataExtra()\n+    {\n+        byte[] extra = getExtra();\n+        return extra != null ? extra : new byte[ 0 ];\n+    }\n+\n+    /**\n+     * Adds an extra fields - replacing an already present extra field of the\n+     * same type.\n+     *\n+     * @param extraField The feature to be added to the ExtraField attribute\n+     * @since 1.1\n+     */\n+    public void addExtraField( final ZipExtraField extraField )\n+    {\n+        final ZipShort type = extraField.getHeaderID();\n+        boolean done = false;\n+        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n+        {\n+            final ZipExtraField other = (ZipExtraField)m_extraFields.get( i );\n+            if( other.getHeaderID().equals( type ) )\n+            {\n+                m_extraFields.set( i, extraField );\n+                done = true;\n+            }\n+        }\n+        if( !done )\n+        {\n+            m_extraFields.add( extraField );\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Overwrite clone\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public Object clone()\n+    {\n+        ZipEntry entry = null;\n+        try\n+        {\n+            entry = new ZipEntry( (java.util.zip.ZipEntry)super.clone() );\n+        }\n+        catch( final Exception e )\n+        {\n+            // impossible as extra data is in correct format\n+            e.printStackTrace();\n+            return null;\n+        }\n+\n+        entry.setInternalAttributes( getInternalAttributes() );\n+        entry.setExternalAttributes( getExternalAttributes() );\n+        entry.setExtraFields( getExtraFields() );\n+        return entry;\n+    }\n+\n+    /**\n+     * Remove an extra fields.\n+     *\n+     * @param type Description of Parameter\n+     * @since 1.1\n+     */\n+    public void removeExtraField( final ZipShort type )\n+    {\n+        boolean done = false;\n+        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n+        {\n+            if( ( (ZipExtraField)m_extraFields.get( i ) ).getHeaderID().equals( type ) )\n+            {\n+                m_extraFields.remove( i );\n+                done = true;\n+            }\n+        }\n+        if( !done )\n+        {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Unfortunately {@link java.util.zip.ZipOutputStream\n+     * java.util.zip.ZipOutputStream} seems to access the extra data directly,\n+     * so overriding getExtra doesn't help - we need to modify super's data\n+     * directly.\n+     *\n+     * @since 1.1\n+     */\n+    protected void setExtra()\n+    {\n+        super.setExtra( ExtraFieldUtils.mergeLocalFileDataData( getExtraFields() ) );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ZipExtraField.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ZipExtraField.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.util.zip.ZipException;\n+\n+/**\n+ * General format of extra field data. <p>\n+ *\n+ * Extra fields usually appear twice per file, once in the local file data and\n+ * once in the central directory. Usually they are the same, but they don't have\n+ * to be. {@link java.util.zip.ZipOutputStream java.util.zip.ZipOutputStream}\n+ * will only use the local file data in both places.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public interface ZipExtraField\n+{\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return The HeaderId value\n+     * @since 1.1\n+     */\n+    ZipShort getHeaderID();\n+\n+    /**\n+     * Length of the extra field in the local file data - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The LocalFileDataLength value\n+     * @since 1.1\n+     */\n+    ZipShort getLocalFileDataLength();\n+\n+    /**\n+     * Length of the extra field in the central directory - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The CentralDirectoryLength value\n+     * @since 1.1\n+     */\n+    ZipShort getCentralDirectoryLength();\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The LocalFileDataData value\n+     * @since 1.1\n+     */\n+    byte[] getLocalFileDataData();\n+\n+    /**\n+     * The actual data to put central directory - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The CentralDirectoryData value\n+     * @since 1.1\n+     */\n+    byte[] getCentralDirectoryData();\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n+     * @exception ZipException on error\n+     * @since 1.1\n+     */\n+    void parseFromLocalFileData( byte[] buffer, int offset, int length )\n+        throws ZipException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ZipLong.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ZipLong.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+/**\n+ * Utility class that represents a four byte integer with conversion rules for\n+ * the big endian byte order of ZIP files.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public final class ZipLong\n+    implements Cloneable\n+{\n+    private long m_value;\n+\n+    /**\n+     * Create instance from a number.\n+     *\n+     * @param value the value\n+     * @since 1.1\n+     */\n+    public ZipLong( final long value )\n+    {\n+        m_value = value;\n+    }\n+\n+    /**\n+     * Create instance from bytes.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @since 1.1\n+     */\n+    public ZipLong( final byte[] buffer )\n+    {\n+        this( buffer, 0 );\n+    }\n+\n+    /**\n+     * Create instance from the four bytes starting at offset.\n+     *\n+     * @param buffer buffer to read data from\n+     * @param offset offset into buffer\n+     * @since 1.1\n+     */\n+    public ZipLong( final byte[] buffer, final int offset )\n+    {\n+        m_value = ( buffer[ offset + 3 ] << 24 ) & 0xFF000000l;\n+        m_value += ( buffer[ offset + 2 ] << 16 ) & 0xFF0000;\n+        m_value += ( buffer[ offset + 1 ] << 8 ) & 0xFF00;\n+        m_value += ( buffer[ offset ] & 0xFF );\n+    }\n+\n+    /**\n+     * Get value as two bytes in big endian byte order.\n+     *\n+     * @return The value as bytes\n+     * @since 1.1\n+     */\n+    public byte[] getBytes()\n+    {\n+        byte[] result = new byte[ 4 ];\n+        result[ 0 ] = (byte)( ( m_value & 0xFF ) );\n+        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n+        result[ 2 ] = (byte)( ( m_value & 0xFF0000 ) >> 16 );\n+        result[ 3 ] = (byte)( ( m_value & 0xFF000000l ) >> 24 );\n+        return result;\n+    }\n+\n+    /**\n+     * Get value as Java int.\n+     *\n+     * @return The value\n+     * @since 1.1\n+     */\n+    public long getValue()\n+    {\n+        return m_value;\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @param o the object to compare against\n+     * @return true if equyal, false otherwise\n+     * @since 1.1\n+     */\n+    public boolean equals( final Object o )\n+    {\n+        if( o == null || !( o instanceof ZipLong ) )\n+        {\n+            return false;\n+        }\n+        return m_value == ( (ZipLong)o ).getValue();\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @return the hashcode\n+     * @since 1.1\n+     */\n+    public int hashCode()\n+    {\n+        return (int)m_value;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ZipOutputStream.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ZipOutputStream.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Calendar;\n+import java.util.Hashtable;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Reimplementation of {@link java.util.zip.ZipOutputStream\n+ * java.util.zip.ZipOutputStream} that does handle the extended functionality of\n+ * this package, especially internal/external file attributes and extra fields\n+ * with different layouts for local file data and central directory entries. <p>\n+ *\n+ * This implementation will use a Data Descriptor to store size and CRC\n+ * information for DEFLATED entries, this means, you don't need to calculate\n+ * them yourself. Unfortunately this is not possible for the STORED method, here\n+ * setting the CRC and uncompressed size information is required before {@link\n+ * #putNextEntry putNextEntry} will be called.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public class ZipOutputStream\n+    extends DeflaterOutputStream\n+{\n+    /**\n+     * Helper, a 0 as ZipShort.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] ZERO = {0, 0};\n+\n+    /**\n+     * Helper, a 0 as ZipLong.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] LZERO = {0, 0, 0, 0};\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int DEFLATED = ZipEntry.DEFLATED;\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int STORED = ZipEntry.STORED;\n+\n+    /*\n+     * Various ZIP constants\n+     */\n+    /**\n+     * local file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong LFH_SIG = new ZipLong( 0X04034B50L );\n+    /**\n+     * data descriptor signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong DD_SIG = new ZipLong( 0X08074B50L );\n+    /**\n+     * central file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong CFH_SIG = new ZipLong( 0X02014B50L );\n+    /**\n+     * end of central dir signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong EOCD_SIG = new ZipLong( 0X06054B50L );\n+\n+    /**\n+     * Smallest date/time ZIP can handle.\n+     *\n+     * @since 1.1\n+     */\n+    private static final ZipLong DOS_TIME_MIN = new ZipLong( 0x00002100L );\n+\n+    /**\n+     * The file comment.\n+     *\n+     * @since 1.1\n+     */\n+    private String m_comment = \"\";\n+\n+    /**\n+     * Compression level for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_level = Deflater.DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Default compression method for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_method = DEFLATED;\n+\n+    /**\n+     * List of ZipEntries written so far.\n+     *\n+     * @since 1.1\n+     */\n+    private final ArrayList m_entries = new ArrayList();\n+\n+    /**\n+     * CRC instance to avoid parsing DEFLATED data twice.\n+     *\n+     * @since 1.1\n+     */\n+    private final CRC32 m_crc = new CRC32();\n+\n+    /**\n+     * Count the bytes written to out.\n+     *\n+     * @since 1.1\n+     */\n+    private long m_written;\n+\n+    /**\n+     * Data for current entry started here.\n+     *\n+     * @since 1.1\n+     */\n+    private long m_dataStart;\n+\n+    /**\n+     * Start of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipLong m_cdOffset = new ZipLong( 0 );\n+\n+    /**\n+     * Length of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipLong m_cdLength = new ZipLong( 0 );\n+\n+    /**\n+     * Holds the offsets of the LFH starts for each entry\n+     *\n+     * @since 1.1\n+     */\n+    private final Hashtable m_offsets = new Hashtable();\n+\n+    /**\n+     * The encoding to use for filenames and the file comment. <p>\n+     *\n+     * For a list of possible values see <a\n+     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n+     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n+     * </a>. Defaults to the platform's default character encoding.</p>\n+     *\n+     * @since 1.3\n+     */\n+    private String m_encoding;\n+\n+    /**\n+     * Current entry.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipEntry m_entry;\n+\n+    /**\n+     * Creates a new ZIP OutputStream filtering the underlying stream.\n+     *\n+     * @param output the output stream to write to\n+     * @since 1.1\n+     */\n+    public ZipOutputStream( final OutputStream output )\n+    {\n+        super( output, new Deflater( Deflater.DEFAULT_COMPRESSION, true ) );\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field. <p>\n+     *\n+     * Stolen from InfoZip's <code>fileio.c</code></p>\n+     *\n+     * @param time Description of Parameter\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    protected static ZipLong toDosTime( Date time )\n+    {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime( time );\n+        int year = cal.get(Calendar.YEAR);\n+        int month = cal.get(Calendar.MONTH) + 1;\n+        if( year < 1980 )\n+        {\n+            return DOS_TIME_MIN;\n+        }\n+        long value = ( ( year - 1980 ) << 25 )\n+            | ( month << 21 )\n+            | ( cal.get(Calendar.DAY_OF_MONTH) << 16 )\n+            | ( cal.get(Calendar.HOUR_OF_DAY) << 11 )\n+            | ( cal.get(Calendar.MINUTE) << 5 )\n+            | ( cal.get(Calendar.SECOND) >> 1 );\n+\n+        byte[] result = new byte[ 4 ];\n+        result[ 0 ] = (byte)( ( value & 0xFF ) );\n+        result[ 1 ] = (byte)( ( value & 0xFF00 ) >> 8 );\n+        result[ 2 ] = (byte)( ( value & 0xFF0000 ) >> 16 );\n+        result[ 3 ] = (byte)( ( value & 0xFF000000l ) >> 24 );\n+        return new ZipLong( result );\n+    }\n+\n+    /**\n+     * Set the file comment.\n+     *\n+     * @param comment The new Comment value\n+     * @since 1.1\n+     */\n+    public void setComment( String comment )\n+    {\n+        m_comment = comment;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment. <p>\n+     *\n+     * For a list of possible values see <a\n+     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n+     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n+     * </a>. Defaults to the platform's default character encoding.</p>\n+     *\n+     * @param encoding The new Encoding value\n+     * @since 1.3\n+     */\n+    public void setEncoding( String encoding )\n+    {\n+        m_encoding = encoding;\n+    }\n+\n+    /**\n+     * Sets the compression level for subsequent entries. <p>\n+     *\n+     * Default is Deflater.DEFAULT_COMPRESSION.</p>\n+     *\n+     * @param level The new Level value\n+     * @since 1.1\n+     */\n+    public void setLevel( int level )\n+    {\n+        m_level = level;\n+    }\n+\n+    /**\n+     * Sets the default compression method for subsequent entries. <p>\n+     *\n+     * Default is DEFLATED.</p>\n+     *\n+     * @param method The new Method value\n+     * @since 1.1\n+     */\n+    public void setMethod( final int method )\n+    {\n+        m_method = method;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     * @since 1.3\n+     */\n+    public String getEncoding()\n+    {\n+        return m_encoding;\n+    }\n+\n+    /**\n+     * Writes all necessary data for this entry.\n+     *\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void closeEntry()\n+        throws IOException\n+    {\n+        if( m_entry == null )\n+        {\n+            return;\n+        }\n+\n+        long realCrc = m_crc.getValue();\n+        m_crc.reset();\n+\n+        if( m_entry.getMethod() == DEFLATED )\n+        {\n+            def.finish();\n+            while( !def.finished() )\n+            {\n+                deflate();\n+            }\n+\n+            m_entry.setSize( def.getTotalIn() );\n+            m_entry.setComprSize( def.getTotalOut() );\n+            m_entry.setCrc( realCrc );\n+\n+            def.reset();\n+\n+            m_written += m_entry.getCompressedSize();\n+        }\n+        else\n+        {\n+            if( m_entry.getCrc() != realCrc )\n+            {\n+                throw new ZipException( \"bad CRC checksum for entry \"\n+                                        + m_entry.getName() + \": \"\n+                                        + Long.toHexString( m_entry.getCrc() )\n+                                        + \" instead of \"\n+                                        + Long.toHexString( realCrc ) );\n+            }\n+\n+            if( m_entry.getSize() != m_written - m_dataStart )\n+            {\n+                throw new ZipException( \"bad size for entry \"\n+                                        + m_entry.getName() + \": \"\n+                                        + m_entry.getSize()\n+                                        + \" instead of \"\n+                                        + ( m_written - m_dataStart ) );\n+            }\n+\n+        }\n+\n+        writeDataDescriptor( m_entry );\n+        m_entry = null;\n+    }\n+\n+    /*\n+     * Found out by experiment, that DeflaterOutputStream.close()\n+     * will call finish() - so we don't need to override close\n+     * ourselves.\n+     */\n+    /**\n+     * Finishs writing the contents and closes this as well as the underlying\n+     * stream.\n+     *\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void finish()\n+        throws IOException\n+    {\n+        closeEntry();\n+        m_cdOffset = new ZipLong( m_written );\n+        final int size = m_entries.size();\n+        for( int i = 0; i < size; i++ )\n+        {\n+            final ZipEntry entry = (ZipEntry)m_entries.get( i );\n+            writeCentralFileHeader( entry );\n+        }\n+        m_cdLength = new ZipLong( m_written - m_cdOffset.getValue() );\n+        writeCentralDirectoryEnd();\n+        m_offsets.clear();\n+        m_entries.clear();\n+    }\n+\n+    /**\n+     * Begin writing next entry.\n+     *\n+     * @param entry the entry\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void putNextEntry( final ZipEntry entry )\n+        throws IOException\n+    {\n+        closeEntry();\n+\n+        m_entry = entry;\n+        m_entries.add( m_entry );\n+\n+        if( m_entry.getMethod() == -1 )\n+        {// not specified\n+            m_entry.setMethod( m_method );\n+        }\n+\n+        if( m_entry.getTime() == -1 )\n+        {// not specified\n+            m_entry.setTime( System.currentTimeMillis() );\n+        }\n+\n+        if( m_entry.getMethod() == STORED )\n+        {\n+            if( m_entry.getSize() == -1 )\n+            {\n+                throw new ZipException( \"uncompressed size is required for STORED method\" );\n+            }\n+            if( m_entry.getCrc() == -1 )\n+            {\n+                throw new ZipException( \"crc checksum is required for STORED method\" );\n+            }\n+            m_entry.setComprSize( m_entry.getSize() );\n+        }\n+        else\n+        {\n+            def.setLevel( m_level );\n+        }\n+        writeLocalFileHeader( m_entry );\n+    }\n+\n+    /**\n+     * Writes bytes to ZIP entry. <p>\n+     *\n+     * Override is necessary to support STORED entries, as well as calculationg\n+     * CRC automatically for DEFLATED entries.</p>\n+     *\n+     * @param buffer the buffer to write to\n+     * @param offset the offset to write to\n+     * @param length the length of data to write\n+     * @exception IOException if an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer,\n+                       final int offset,\n+                       final int length )\n+        throws IOException\n+    {\n+        if( m_entry.getMethod() == DEFLATED )\n+        {\n+            super.write( buffer, offset, length );\n+        }\n+        else\n+        {\n+            out.write( buffer, offset, length );\n+            m_written += length;\n+        }\n+        m_crc.update( buffer, offset, length );\n+    }\n+\n+    /**\n+     * Retrieve the bytes for the given String in the encoding set for this\n+     * Stream.\n+     *\n+     * @param name the name to decode\n+     * @return the bytes for string\n+     * @exception ZipException if fail to retrieve bytes for specified string\n+     * @since 1.3\n+     */\n+    protected byte[] getBytes( String name )\n+        throws ZipException\n+    {\n+        if( m_encoding == null )\n+        {\n+            return name.getBytes();\n+        }\n+        else\n+        {\n+            try\n+            {\n+                return name.getBytes( m_encoding );\n+            }\n+            catch( UnsupportedEncodingException uee )\n+            {\n+                throw new ZipException( uee.getMessage() );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Writes the &quot;End of central dir record&quot;\n+     *\n+     * @exception IOException when an IO erro causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeCentralDirectoryEnd()\n+        throws IOException\n+    {\n+        out.write( EOCD_SIG.getBytes() );\n+\n+        // disk numbers\n+        out.write( ZERO );\n+        out.write( ZERO );\n+\n+        // number of entries\n+        byte[] num = ( new ZipShort( m_entries.size() ) ).getBytes();\n+        out.write( num );\n+        out.write( num );\n+\n+        // length and location of CD\n+        out.write( m_cdLength.getBytes() );\n+        out.write( m_cdOffset.getBytes() );\n+\n+        // ZIP file comment\n+        byte[] data = getBytes( m_comment );\n+        out.write( ( new ZipShort( data.length ) ).getBytes() );\n+        out.write( data );\n+    }\n+\n+    /**\n+     * Writes the central file header entry\n+     *\n+     * @param entry the zip entry\n+     * @throws IOException when an IO error causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeCentralFileHeader( final ZipEntry entry )\n+        throws IOException\n+    {\n+        out.write( CFH_SIG.getBytes() );\n+        m_written += 4;\n+\n+        // version made by\n+        out.write( ( new ZipShort( 20 ) ).getBytes() );\n+        m_written += 2;\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+\n+            // bit3 set to signal, we use a data descriptor\n+            out.write( ( new ZipShort( 8 ) ).getBytes() );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipShort( 10 ) ).getBytes() );\n+            out.write( ZERO );\n+        }\n+        m_written += 4;\n+\n+        // compression method\n+        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // last mod. time and date\n+        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n+        out.write( ( new ZipLong( entry.getCompressedSize() ) ).getBytes() );\n+        out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+        m_written += 12;\n+\n+        // file name length\n+        byte[] name = getBytes( entry.getName() );\n+        out.write( ( new ZipShort( name.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // extra field length\n+        byte[] extra = entry.getCentralDirectoryExtra();\n+        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // file comment length\n+        String comm = entry.getComment();\n+        if( comm == null )\n+        {\n+            comm = \"\";\n+        }\n+        byte[] comment = getBytes( comm );\n+        out.write( ( new ZipShort( comment.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // disk number start\n+        out.write( ZERO );\n+        m_written += 2;\n+\n+        // internal file attributes\n+        out.write( ( new ZipShort( entry.getInternalAttributes() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // external file attributes\n+        out.write( ( new ZipLong( entry.getExternalAttributes() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // relative offset of LFH\n+        out.write( ( (ZipLong)m_offsets.get( entry ) ).getBytes() );\n+        m_written += 4;\n+\n+        // file name\n+        out.write( name );\n+        m_written += name.length;\n+\n+        // extra field\n+        out.write( extra );\n+        m_written += extra.length;\n+\n+        // file comment\n+        out.write( comment );\n+        m_written += comment.length;\n+    }\n+\n+    /**\n+     * Writes the data descriptor entry\n+     *\n+     * @param ze Description of Parameter\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeDataDescriptor( ZipEntry ze )\n+        throws IOException\n+    {\n+        if( ze.getMethod() != DEFLATED )\n+        {\n+            return;\n+        }\n+        out.write( DD_SIG.getBytes() );\n+        out.write( ( new ZipLong( m_entry.getCrc() ) ).getBytes() );\n+        out.write( ( new ZipLong( m_entry.getCompressedSize() ) ).getBytes() );\n+        out.write( ( new ZipLong( m_entry.getSize() ) ).getBytes() );\n+        m_written += 16;\n+    }\n+\n+    /**\n+     * Writes the local file header entry\n+     *\n+     * @param entry the zip entry\n+     * @exception IOException when an IO error causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeLocalFileHeader( final ZipEntry entry )\n+        throws IOException\n+    {\n+        m_offsets.put( entry, new ZipLong( m_written ) );\n+\n+        out.write( LFH_SIG.getBytes() );\n+        m_written += 4;\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+\n+            // bit3 set to signal, we use a data descriptor\n+            out.write( ( new ZipShort( 8 ) ).getBytes() );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipShort( 10 ) ).getBytes() );\n+            out.write( ZERO );\n+        }\n+        m_written += 4;\n+\n+        // compression method\n+        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // last mod. time and date\n+        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            out.write( LZERO );\n+            out.write( LZERO );\n+            out.write( LZERO );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n+            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+        }\n+        m_written += 12;\n+\n+        // file name length\n+        byte[] name = getBytes( entry.getName() );\n+        out.write( ( new ZipShort( name.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // extra field length\n+        byte[] extra = entry.getLocalFileDataExtra();\n+        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // file name\n+        out.write( name );\n+        m_written += name.length;\n+\n+        // extra field\n+        out.write( extra );\n+        m_written += extra.length;\n+\n+        m_dataStart = m_written;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/zip/ZipShort.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons-sandbox//compress/src/java/org/apache/commons/compress/zip/ZipShort.java,v 1.1 2003/11/23 20:07:46 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/11/23 20:07:46 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.compress.zip;\n+\n+/**\n+ * Utility class that represents a two byte integer with conversion rules for\n+ * the big endian byte order of ZIP files.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 1.1 $\n+ */\n+public final class ZipShort\n+    implements Cloneable\n+{\n+    private int m_value;\n+\n+    /**\n+     * Create instance from a number.\n+     *\n+     * @param value Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( int value )\n+    {\n+        this.m_value = value;\n+    }\n+\n+    /**\n+     * Create instance from bytes.\n+     *\n+     * @param bytes Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( byte[] bytes )\n+    {\n+        this( bytes, 0 );\n+    }\n+\n+    /**\n+     * Create instance from the two bytes starting at offset.\n+     *\n+     * @param bytes Description of Parameter\n+     * @param offset Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( byte[] bytes, int offset )\n+    {\n+        m_value = ( bytes[ offset + 1 ] << 8 ) & 0xFF00;\n+        m_value += ( bytes[ offset ] & 0xFF );\n+    }\n+\n+    /**\n+     * Get value as two bytes in big endian byte order.\n+     *\n+     * @return The Bytes value\n+     * @since 1.1\n+     */\n+    public byte[] getBytes()\n+    {\n+        byte[] result = new byte[ 2 ];\n+        result[ 0 ] = (byte)( m_value & 0xFF );\n+        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n+        return result;\n+    }\n+\n+    /**\n+     * Get value as Java int.\n+     *\n+     * @return The Value value\n+     * @since 1.1\n+     */\n+    public int getValue()\n+    {\n+        return m_value;\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @param o Description of Parameter\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public boolean equals( Object o )\n+    {\n+        if( o == null || !( o instanceof ZipShort ) )\n+        {\n+            return false;\n+        }\n+        return m_value == ( (ZipShort)o ).getValue();\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public int hashCode()\n+    {\n+        return m_value;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/tar/TarTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test case for all tar resources.\n+ *\n+ * @todo Find V7 tar and do tests against it\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 20:07:47 $\n+ */\n+public final class TarTestCase\n+    extends TestCase\n+{\n+    private static final char SP = File.separatorChar;\n+    private static final String BASE_DATA_NAME = \"data.txt\";\n+    private static final String LFN_PART = \"a-b-c-d-e-f-g-h-i-j/\";\n+    private static final String LONG_FILE_NAME =\n+        LFN_PART + LFN_PART + LFN_PART + LFN_PART + LFN_PART + \"a\";\n+\n+    private static final String BASEDIR = calcBaseDir();\n+\n+    private static final File BASEDIR_FILE = new File( BASEDIR );\n+    private static final File POSIX_TAR_FILE =\n+        new File( BASEDIR_FILE, \"posix.tar\" );\n+    //    private static final File V7_TAR_FILE =\n+    //        new File( BASEDIR_FILE, \"v7.tar\" );\n+    private static final File GNU_TAR_FILE =\n+        new File( BASEDIR_FILE, \"gnu.tar\" );\n+    private static final File DATA_FILE1 =\n+        new File( BASEDIR_FILE, BASE_DATA_NAME );\n+    private static final String USER_NAME = \"avalon\";\n+    private static final String GROUP_NAME = \"excalibur\";\n+    private static final long SIZE = DATA_FILE1.length();\n+    private static final int GROUP_ID = 0;\n+    private static final int USER_ID = 0;\n+    private static final int MODE = 0100000;\n+    private static final int MOD_TIME = 0;\n+\n+    public TarTestCase()\n+    {\n+        this( \"Tar Test Case\" );\n+    }\n+\n+    public TarTestCase( String name )\n+    {\n+        super( name );\n+    }\n+\n+    private static String calcBaseDir()\n+    {\n+        final String name = TarTestCase.class.getName();\n+        final int size = name.length();\n+        final String filename =\n+            name.substring( 0, size - 11 ).replace( '.', SP );\n+        return \"target\" + SP + \"tests\" + SP +\n+                SP + filename + SP;\n+    }\n+\n+    public void testReadPosixTar()\n+        throws Exception\n+    {\n+        compareTar( BASE_DATA_NAME, POSIX_TAR_FILE );\n+    }\n+\n+    public void testReadGnuTar()\n+        throws Exception\n+    {\n+        compareTar( LONG_FILE_NAME, GNU_TAR_FILE );\n+    }\n+\n+    public void testWritePosixTar()\n+        throws Exception\n+    {\n+        //final File temp = new File( BASEDIR_FILE, \"posix2.tar\" );\n+        final File temp = File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream fileOutput = new FileOutputStream( temp );\n+        final TarOutputStream output = new TarOutputStream( fileOutput );\n+        //output.setBufferDebug( true );\n+        final TarEntry entry = new TarEntry( BASE_DATA_NAME );\n+        setupEntry( entry );\n+        output.putNextEntry( entry );\n+\n+        final FileInputStream fileInput = new FileInputStream( DATA_FILE1 );\n+        output.copyEntryContents( fileInput );\n+        output.closeEntry();\n+        shutdownStream( fileInput );\n+        shutdownStream( output );\n+        shutdownStream( fileOutput );\n+\n+        assertTrue( \"Tar files Equal\", contentEquals( temp, POSIX_TAR_FILE ) );\n+        temp.delete();\n+    }\n+\n+    public void testWriteGnuTar()\n+        throws Exception\n+    {\n+        //final File temp = new File( BASEDIR_FILE, \"gnu2.tar\" );\n+        final File temp = File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream fileOutput = new FileOutputStream( temp );\n+        final TarOutputStream output = new TarOutputStream( fileOutput );\n+        //output.setBufferDebug( true );\n+        output.setLongFileMode( TarOutputStream.LONGFILE_GNU );\n+        final TarEntry entry = new TarEntry( LONG_FILE_NAME );\n+        setupEntry( entry );\n+        output.putNextEntry( entry );\n+\n+        final FileInputStream fileInput = new FileInputStream( DATA_FILE1 );\n+        output.copyEntryContents( fileInput );\n+        output.closeEntry();\n+        shutdownStream( fileInput );\n+        shutdownStream( output );\n+        shutdownStream( fileOutput );\n+\n+        //Have to compare it this way as the contents will differ\n+        //due to entry created for second part of name\n+        compareTar( LONG_FILE_NAME, temp );\n+        temp.delete();\n+    }\n+\n+    private void setupEntry( final TarEntry entry )\n+    {\n+        entry.setModTime( MOD_TIME );\n+        entry.setSize( SIZE );\n+        entry.setUserID( USER_ID );\n+        entry.setGroupID( GROUP_ID );\n+        entry.setUserName( USER_NAME );\n+        entry.setGroupName( GROUP_NAME );\n+        entry.setMode( MODE );\n+    }\n+\n+    private void checkEntry( final TarEntry entry )\n+    {\n+        assertEquals( \"Entry size\", SIZE, entry.getSize() );\n+        assertEquals( \"Entry User ID\", USER_ID, entry.getUserID() );\n+        assertEquals( \"Entry Group ID\", GROUP_ID, entry.getGroupID() );\n+        assertEquals( \"Entry User name\", USER_NAME, entry.getUserName() );\n+        assertEquals( \"Entry group name\", GROUP_NAME, entry.getGroupName() );\n+        assertEquals( \"Entry mode\", MODE, entry.getMode() );\n+        assertEquals( \"Entry mode\", MOD_TIME, entry.getModTime().getTime() / 1000 );\n+    }\n+\n+    /**\n+     * Read tar entry with specified name from tar file1 and compare\n+     * against data file DATA_FILE1.\n+     *\n+     * @param entryName the expected name of entry\n+     * @param file1 the tar file comparing\n+     * @throws IOException if an error occurs\n+     */\n+    private void compareTar( final String entryName,\n+                             final File file1 )\n+        throws IOException\n+    {\n+        final FileInputStream fileInput = new FileInputStream( file1 );\n+        final TarInputStream input = new TarInputStream( fileInput );\n+        //input.setDebug( true );\n+        final TarEntry entry = input.getNextEntry();\n+\n+        assertEquals( \"Entry name\", entryName, entry.getName() );\n+        checkEntry( entry );\n+\n+        final File temp = new File( BASEDIR_FILE, entryName.length() + \"data.txt\" );//File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream output = new FileOutputStream( temp );\n+        input.copyEntryContents( output );\n+        shutdownStream( output );\n+\n+        assertNull( \"Next Entry\", input.getNextEntry() );\n+\n+        shutdownStream( input );\n+\n+        assertTrue( \"Data Equals\", contentEquals( temp, DATA_FILE1 ) );\n+        temp.delete();\n+    }\n+\n+    /**\n+     * Compare the contents of two files to determine if they are equal or not.\n+     *\n+     * @param file1 the first file\n+     * @param file2 the second file\n+     * @return true if the content of the files are equal or they both don't exist, false otherwise\n+     */\n+    private boolean contentEquals( final File file1, final File file2 )\n+        throws IOException\n+    {\n+        final boolean file1Exists = file1.exists();\n+        if( file1Exists != file2.exists() )\n+        {\n+            return false;\n+        }\n+\n+        if( !file1Exists )\n+        {\n+            // two not existing files are equal\n+            return true;\n+        }\n+\n+        if( file1.isDirectory() || file2.isDirectory() )\n+        {\n+            // don't want to compare directory contents\n+            return false;\n+        }\n+\n+        InputStream input1 = null;\n+        InputStream input2 = null;\n+        try\n+        {\n+            input1 = new FileInputStream( file1 );\n+            input2 = new FileInputStream( file2 );\n+            return contentEquals( input1, input2 );\n+\n+        }\n+        finally\n+        {\n+            shutdownStream( input1 );\n+            shutdownStream( input2 );\n+        }\n+    }\n+\n+    /**\n+     * Compare the contents of two Streams to determine if they are equal or not.\n+     *\n+     * @param input1 the first stream\n+     * @param input2 the second stream\n+     * @return true if the content of the streams are equal or they both don't exist, false otherwise\n+     */\n+    private boolean contentEquals( final InputStream input1,\n+                                   final InputStream input2 )\n+        throws IOException\n+    {\n+        final InputStream bufferedInput1 = new BufferedInputStream( input1 );\n+        final InputStream bufferedInput2 = new BufferedInputStream( input2 );\n+\n+        int count = 0;\n+        int ch = bufferedInput1.read();\n+        while( -1 != ch )\n+        {\n+            final int ch2 = bufferedInput2.read();\n+            count++;\n+            if( ch != ch2 )\n+            {\n+                System.out.println( \"count = \" + count );\n+                System.out.println( \"ch2 = \" + ch2 );\n+                System.out.println( \"ch = \" + ch );\n+                return false;\n+            }\n+            ch = bufferedInput1.read();\n+        }\n+\n+        final int ch2 = bufferedInput2.read();\n+        if( -1 != ch2 )\n+        {\n+            return false;\n+        }\n+        else\n+        {\n+            return true;\n+        }\n+    }\n+\n+    private void shutdownStream( final InputStream input )\n+    {\n+        if( null == input )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            input.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+\n+    private void shutdownStream( final OutputStream output )\n+    {\n+        if( null == output )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            output.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/tar/TarTestSuite.java\n+/*\n+ * Copyright  The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.tar;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * A basic test suite that tests all the tar package.\n+ */\n+public class TarTestSuite\n+{\n+    public static Test suite()\n+    {\n+        final TestSuite suite = new TestSuite( \"Tar Utilities\" );\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/zip/AsiExtraFieldTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.util.zip.ZipException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit testcases AsiExtraField.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class AsiExtraFieldTestCase\n+    extends TestCase\n+    implements UnixStat\n+{\n+    public AsiExtraFieldTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test file mode magic.\n+     */\n+    public void testModes()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setMode( 0123 );\n+        assertEquals( \"plain file\", 0100123, field.getMode() );\n+        field.setDirectory( true );\n+        assertEquals( \"directory\", 040123, field.getMode() );\n+        field.setLinkedFile( \"test\" );\n+        assertEquals( \"symbolic link\", 0120123, field.getMode() );\n+    }\n+\n+    private AsiExtraField createField()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setMode( 0123 );\n+        field.setUserId( 5 );\n+        field.setGroupId( 6 );\n+        return field;\n+    }\n+\n+    public void testContent1()\n+    {\n+        final AsiExtraField field = createField();\n+        final byte[] data = field.getLocalFileDataData();\n+\n+        // CRC manually calculated, sorry\n+        final byte[] expect = {(byte)0xC6, 0x02, 0x78, (byte)0xB6, // CRC\n+                               0123, (byte)0x80, // mode\n+                               0, 0, 0, 0, // link length\n+                               5, 0, 6, 0};                        // uid, gid\n+        assertEquals( \"no link\", expect.length, data.length );\n+        for( int i = 0; i < expect.length; i++ )\n+        {\n+            assertEquals( \"no link, byte \" + i, expect[ i ], data[ i ] );\n+        }\n+\n+        field.setLinkedFile( \"test\" );\n+    }\n+\n+    public void testContent2()\n+    {\n+        final AsiExtraField field = createField();\n+        field.setLinkedFile( \"test\" );\n+\n+        final byte[] data = field.getLocalFileDataData();\n+        final byte[] expect = new byte[]{0x75, (byte)0x8E, 0x41, (byte)0xFD, // CRC\n+                                         0123, (byte)0xA0, // mode\n+                                         4, 0, 0, 0, // link length\n+                                         5, 0, 6, 0, // uid, gid\n+                                         (byte)'t', (byte)'e', (byte)'s', (byte)'t'};\n+        assertEquals( \"no link\", expect.length, data.length );\n+        for( int i = 0; i < expect.length; i++ )\n+        {\n+            assertEquals( \"no link, byte \" + i, expect[ i ], data[ i ] );\n+        }\n+\n+    }\n+\n+    public void testReparse1()\n+        throws ZipException\n+    {\n+        // CRC manually calculated, sorry\n+        final byte[] data = {(byte)0xC6, 0x02, 0x78, (byte)0xB6, // CRC\n+                             0123, (byte)0x80, // mode\n+                             0, 0, 0, 0, // link length\n+                             5, 0, 6, 0};                        // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+\n+        assertEquals( \"length plain file\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"plain file, no link\", !field.isLink() );\n+        assertTrue( \"plain file, no dir\", !field.isDirectory() );\n+        assertEquals( \"mode plain file\", FILE_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid plain file\", 5, field.getUserId() );\n+        assertEquals( \"gid plain file\", 6, field.getGroupID() );\n+    }\n+\n+    public void testReparse2()\n+        throws ZipException\n+    {\n+        final byte[] data = new byte[]{0x75, (byte)0x8E, 0x41, (byte)0xFD, // CRC\n+                                       0123, (byte)0xA0, // mode\n+                                       4, 0, 0, 0, // link length\n+                                       5, 0, 6, 0, // uid, gid\n+                                       (byte)'t', (byte)'e', (byte)'s', (byte)'t'};\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+        assertEquals( \"length link\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"link, is link\", field.isLink() );\n+        assertTrue( \"link, no dir\", !field.isDirectory() );\n+        assertEquals( \"mode link\", LINK_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid link\", 5, field.getUserId() );\n+        assertEquals( \"gid link\", 6, field.getGroupID() );\n+        assertEquals( \"test\", field.getLinkedFile() );\n+    }\n+\n+    public void testReparse3()\n+        throws ZipException\n+    {\n+        final byte[] data = new byte[]{(byte)0x8E, 0x01, (byte)0xBF, (byte)0x0E, // CRC\n+                                       0123, (byte)0x40, // mode\n+                                       0, 0, 0, 0, // link\n+                                       5, 0, 6, 0};                          // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+        assertEquals( \"length dir\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"dir, no link\", !field.isLink() );\n+        assertTrue( \"dir, is dir\", field.isDirectory() );\n+        assertEquals( \"mode dir\", DIR_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid dir\", 5, field.getUserId() );\n+        assertEquals( \"gid dir\", 6, field.getGroupID() );\n+    }\n+\n+    public void testReparse4()\n+        throws Exception\n+    {\n+        final byte[] data = new byte[]{0, 0, 0, 0, // bad CRC\n+                                       0123, (byte)0x40, // mode\n+                                       0, 0, 0, 0, // link\n+                                       5, 0, 6, 0};                          // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        try\n+        {\n+            field.parseFromLocalFileData( data, 0, data.length );\n+            fail( \"should raise bad CRC exception\" );\n+        }\n+        catch( Exception e )\n+        {\n+            assertEquals( \"bad CRC checksum 0 instead of ebf018e\",\n+                          e.getMessage() );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/zip/ExtraFieldUtilsTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import junit.framework.TestCase;\n+/**\n+ * JUnit testcases ExtraFieldUtils.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ExtraFieldUtilsTestCase\n+    extends TestCase\n+    implements UnixStat\n+{\n+    private AsiExtraField m_field;\n+    private UnrecognizedExtraField m_dummy;\n+    private byte[] m_data;\n+    private byte[] m_local;\n+\n+    public ExtraFieldUtilsTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void setUp()\n+    {\n+        m_field = new AsiExtraField();\n+        m_field.setMode( 0755 );\n+        m_field.setDirectory( true );\n+        m_dummy = new UnrecognizedExtraField();\n+        m_dummy.setHeaderId( new ZipShort( 1 ) );\n+        m_dummy.setLocalFileDataData( new byte[ 0 ] );\n+        m_dummy.setCentralDirectoryData( new byte[]{0} );\n+\n+        m_local = m_field.getLocalFileDataData();\n+        final byte[] dummyLocal = m_dummy.getLocalFileDataData();\n+        m_data = new byte[ 4 + m_local.length + 4 + dummyLocal.length ];\n+        System.arraycopy( m_field.getHeaderID().getBytes(), 0, m_data, 0, 2 );\n+        System.arraycopy( m_field.getLocalFileDataLength().getBytes(), 0, m_data, 2, 2 );\n+        System.arraycopy( m_local, 0, m_data, 4, m_local.length );\n+        System.arraycopy( m_dummy.getHeaderID().getBytes(), 0, m_data,\n+                          4 + m_local.length, 2 );\n+        System.arraycopy( m_dummy.getLocalFileDataLength().getBytes(), 0, m_data,\n+                          4 + m_local.length + 2, 2 );\n+        System.arraycopy( dummyLocal, 0, m_data,\n+                          4 + m_local.length + 4, dummyLocal.length );\n+\n+    }\n+\n+    /**\n+     * test parser.\n+     */\n+    public void testParse() throws Exception\n+    {\n+        final ZipExtraField[] extraField = ExtraFieldUtils.parse( m_data );\n+        assertEquals( \"number of fields\", 2, extraField.length );\n+        assertTrue( \"type field 1\", extraField[ 0 ] instanceof AsiExtraField );\n+        assertEquals( \"mode field 1\", 040755,\n+                      ( (AsiExtraField)extraField[ 0 ] ).getMode() );\n+        assertTrue( \"type field 2\", extraField[ 1 ] instanceof UnrecognizedExtraField );\n+        assertEquals( \"data length field 2\", 0,\n+                      extraField[ 1 ].getLocalFileDataLength().getValue() );\n+\n+        final byte[] data2 = new byte[ m_data.length - 1 ];\n+        System.arraycopy( m_data, 0, data2, 0, data2.length );\n+        try\n+        {\n+            ExtraFieldUtils.parse( data2 );\n+            fail( \"data should be invalid\" );\n+        }\n+        catch( Exception e )\n+        {\n+            assertEquals( \"message\",\n+                          \"data starting at \" + ( 4 + m_local.length ) + \" is in unknown format\",\n+                          e.getMessage() );\n+        }\n+    }\n+\n+    /**\n+     * Test merge methods\n+     */\n+    public void testMerge()\n+    {\n+        final byte[] local =\n+            ExtraFieldUtils.mergeLocalFileDataData( new ZipExtraField[]{m_field, m_dummy} );\n+        assertEquals( \"local length\", m_data.length, local.length );\n+        for( int i = 0; i < local.length; i++ )\n+        {\n+            assertEquals( \"local byte \" + i, m_data[ i ], local[ i ] );\n+        }\n+\n+        final byte[] dummyCentral = m_dummy.getCentralDirectoryData();\n+        final byte[] data2 = new byte[ 4 + m_local.length + 4 + dummyCentral.length ];\n+        System.arraycopy( m_data, 0, data2, 0, 4 + m_local.length + 2 );\n+        System.arraycopy( m_dummy.getCentralDirectoryLength().getBytes(), 0,\n+                          data2, 4 + m_local.length + 2, 2 );\n+        System.arraycopy( dummyCentral, 0, data2,\n+                          4 + m_local.length + 4, dummyCentral.length );\n+\n+        final byte[] central =\n+            ExtraFieldUtils.mergeCentralDirectoryData( new ZipExtraField[]{m_field, m_dummy} );\n+        assertEquals( \"central length\", data2.length, central.length );\n+        for( int i = 0; i < central.length; i++ )\n+        {\n+            assertEquals( \"central byte \" + i, data2[ i ], central[ i ] );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/zip/ZipEntryTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import java.util.NoSuchElementException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit testcases ZipEntry.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipEntryTestCase\n+    extends TestCase\n+{\n+    public ZipEntryTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * test handling of extra fields\n+     */\n+    public void testExtraFields()\n+    {\n+        final AsiExtraField field = createField();\n+        final UnrecognizedExtraField extraField = createExtraField();\n+\n+        final ZipEntry entry = new ZipEntry( \"test/\" );\n+        entry.setExtraFields( new ZipExtraField[]{field, extraField} );\n+        final byte[] data1 = entry.getExtra();\n+        ZipExtraField[] result = entry.getExtraFields();\n+        assertEquals( \"first pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( extraField, result[ 1 ] );\n+\n+        UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n+        u2.setHeaderId( new ZipShort( 1 ) );\n+        u2.setLocalFileDataData( new byte[]{1} );\n+\n+        entry.addExtraField( u2 );\n+        byte[] data2 = entry.getExtra();\n+        result = entry.getExtraFields();\n+        assertEquals( \"second pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( u2, result[ 1 ] );\n+        assertEquals( \"length second pass\", data1.length + 1, data2.length );\n+\n+        UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n+        u3.setHeaderId( new ZipShort( 2 ) );\n+        u3.setLocalFileDataData( new byte[]{1} );\n+        entry.addExtraField( u3 );\n+        result = entry.getExtraFields();\n+        assertEquals( \"third pass\", 3, result.length );\n+\n+        entry.removeExtraField( new ZipShort( 1 ) );\n+        byte[] data3 = entry.getExtra();\n+        result = entry.getExtraFields();\n+        assertEquals( \"fourth pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( u3, result[ 1 ] );\n+        assertEquals( \"length fourth pass\", data2.length, data3.length );\n+\n+        try\n+        {\n+            entry.removeExtraField( new ZipShort( 1 ) );\n+            fail( \"should be no such element\" );\n+        }\n+        catch( final NoSuchElementException nse )\n+        {\n+        }\n+    }\n+\n+    private UnrecognizedExtraField createExtraField()\n+    {\n+        UnrecognizedExtraField extraField = new UnrecognizedExtraField();\n+        extraField.setHeaderId( new ZipShort( 1 ) );\n+        extraField.setLocalFileDataData( new byte[ 0 ] );\n+        return extraField;\n+    }\n+\n+    private AsiExtraField createField()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setDirectory( true );\n+        field.setMode( 0755 );\n+        return field;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/zip/ZipLongTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit 3 testcases for org.apache.tools.zip.ZipLong.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipLongTestCase\n+    extends TestCase\n+{\n+\n+    public ZipLongTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testToBytes()\n+    {\n+        final ZipLong zipLong = new ZipLong( 0x12345678 );\n+        final byte[] result = zipLong.getBytes();\n+        assertEquals( \"length getBytes\", 4, result.length );\n+        assertEquals( \"first byte getBytes\", 0x78, result[ 0 ] );\n+        assertEquals( \"second byte getBytes\", 0x56, result[ 1 ] );\n+        assertEquals( \"third byte getBytes\", 0x34, result[ 2 ] );\n+        assertEquals( \"fourth byte getBytes\", 0x12, result[ 3 ] );\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testFromBytes()\n+    {\n+        final byte[] value = new byte[]{0x78, 0x56, 0x34, 0x12};\n+        final ZipLong zipLong = new ZipLong( value );\n+        assertEquals( \"value from bytes\", 0x12345678, zipLong.getValue() );\n+    }\n+\n+    /**\n+     * Test the contract of the equals method.\n+     */\n+    public void testEquals()\n+    {\n+        final ZipLong zipLong1 = new ZipLong( 0x12345678 );\n+        final ZipLong zipLong2 = new ZipLong( 0x12345678 );\n+        final ZipLong zipLong3 = new ZipLong( 0x87654321 );\n+\n+        assertTrue( \"reflexive\", zipLong1.equals( zipLong1 ) );\n+\n+        assertTrue( \"works\", zipLong1.equals( zipLong2 ) );\n+        assertTrue( \"works, part two\", !zipLong1.equals( zipLong3 ) );\n+\n+        assertTrue( \"symmetric\", zipLong2.equals( zipLong1 ) );\n+\n+        assertTrue( \"null handling\", !zipLong1.equals( null ) );\n+        assertTrue( \"non ZipLong handling\", !zipLong1.equals( new Integer( 0x1234 ) ) );\n+    }\n+\n+    /**\n+     * Test sign handling.\n+     */\n+    public void testSign()\n+    {\n+        final ZipLong zipLong =\n+            new ZipLong( new byte[]{(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF} );\n+        assertEquals( 0x00000000FFFFFFFFl, zipLong.getValue() );\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/zip/ZipShortTestCase.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.compress.zip;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit 3 testcases for org.apache.tools.zip.ZipShort.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipShortTestCase\n+    extends TestCase\n+{\n+    public ZipShortTestCase( String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testToBytes()\n+    {\n+        final ZipShort zipShort = new ZipShort( 0x1234 );\n+        byte[] result = zipShort.getBytes();\n+        assertEquals( \"length getBytes\", 2, result.length );\n+        assertEquals( \"first byte getBytes\", 0x34, result[ 0 ] );\n+        assertEquals( \"second byte getBytes\", 0x12, result[ 1 ] );\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testFromBytes()\n+    {\n+        byte[] val = new byte[]{0x34, 0x12};\n+        final ZipShort zipShort = new ZipShort( val );\n+        assertEquals( \"value from bytes\", 0x1234, zipShort.getValue() );\n+    }\n+\n+    /**\n+     * Test the contract of the equals method.\n+     */\n+    public void testEquals()\n+    {\n+        final ZipShort zipShort = new ZipShort( 0x1234 );\n+        final ZipShort zipShort2 = new ZipShort( 0x1234 );\n+        final ZipShort zipShort3 = new ZipShort( 0x5678 );\n+\n+        assertTrue( \"reflexive\", zipShort.equals( zipShort ) );\n+\n+        assertTrue( \"works\", zipShort.equals( zipShort2 ) );\n+        assertTrue( \"works, part two\", !zipShort.equals( zipShort3 ) );\n+\n+        assertTrue( \"symmetric\", zipShort2.equals( zipShort ) );\n+\n+        assertTrue( \"null handling\", !zipShort.equals( null ) );\n+        assertTrue( \"non ZipShort handling\", !zipShort.equals( new Integer( 0x1234 ) ) );\n+    }\n+\n+    /**\n+     * Test sign handling.\n+     */\n+    public void testSign()\n+    {\n+        final ZipShort zipShort = new ZipShort( new byte[]{(byte)0xFF, (byte)0xFF} );\n+        assertEquals( 0x0000FFFF, zipShort.getValue() );\n+    }\n+}", "timestamp": 1069618067, "metainfo": ""}