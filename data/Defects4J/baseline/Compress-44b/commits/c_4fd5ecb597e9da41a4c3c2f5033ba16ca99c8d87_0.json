{"sha": "4fd5ecb597e9da41a4c3c2f5033ba16ca99c8d87", "log": "whitespace changes and updated comments in test  ", "commit": "\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n     private static final int ONE_HUNDRED_THOUSAND = 100000;\n \n     @Ignore\n-    @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n+        @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n         read5GBOfZerosImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read5GBOfZerosGeneratedBy7ZIPUsingInputStream()\n+        @Test public void read5GBOfZerosGeneratedBy7ZIPUsingInputStream()\n         throws Throwable {\n         read5GBOfZerosImpl(get5GBZerosFileGeneratedBy7ZIP(), \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read5GBOfZerosGeneratedByJava7JarUsingInputStream()\n+        @Test public void read5GBOfZerosGeneratedByJava7JarUsingInputStream()\n         throws Throwable {\n         read5GBOfZerosImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read100KFilesUsingInputStream() throws Throwable {\n+        @Test public void read100KFilesUsingInputStream() throws Throwable {\n         read100KFilesImpl(get100KFileFile());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedBy7ZIPUsingInputStream() throws Throwable {\n+        @Test public void read100KFilesGeneratedBy7ZIPUsingInputStream() throws Throwable {\n         read100KFilesImpl(get100KFileFileGeneratedBy7ZIP());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedByWinCFUsingInputStream() throws Throwable {\n+        @Test public void read100KFilesGeneratedByWinCFUsingInputStream() throws Throwable {\n         read100KFilesImpl(get100KFileFileGeneratedByWinCF());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedByJava7JarUsingInputStream() throws Throwable {\n+        @Test public void read100KFilesGeneratedByJava7JarUsingInputStream() throws Throwable {\n         read100KFilesImpl(get100KFileFileGeneratedByJava7Jar());\n     }\n \n     @Ignore\n-    @Test public void read5GBOfZerosUsingZipFile() throws Throwable {\n+        @Test public void read5GBOfZerosUsingZipFile() throws Throwable {\n         read5GBOfZerosUsingZipFileImpl(get5GBZerosFile(), \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read5GBOfZerosGeneratedBy7ZIPUsingZipFile()\n+        @Test public void read5GBOfZerosGeneratedBy7ZIPUsingZipFile()\n         throws Throwable {\n         read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedBy7ZIP(),\n                                        \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read5GBOfZerosGeneratedByJava7JarUsingZipFile()\n+        @Test public void read5GBOfZerosGeneratedByJava7JarUsingZipFile()\n         throws Throwable {\n         read5GBOfZerosUsingZipFileImpl(get5GBZerosFileGeneratedByJava7Jar(),\n                                        \"5GB_of_Zeros\");\n     }\n \n     @Ignore\n-    @Test public void read100KFilesUsingZipFile() throws Throwable {\n+        @Test public void read100KFilesUsingZipFile() throws Throwable {\n         read100KFilesUsingZipFileImpl(get100KFileFile());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedBy7ZIPUsingZipFile() throws Throwable {\n+        @Test public void read100KFilesGeneratedBy7ZIPUsingZipFile() throws Throwable {\n         read100KFilesUsingZipFileImpl(get100KFileFileGeneratedBy7ZIP());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedByWinCFUsingZipFile() throws Throwable {\n+        @Test public void read100KFilesGeneratedByWinCFUsingZipFile() throws Throwable {\n         read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByWinCF());\n     }\n \n     @Ignore\n-    @Test public void read100KFilesGeneratedByJava7JarUsingZipFile() throws Throwable {\n+        @Test public void read100KFilesGeneratedByJava7JarUsingZipFile() throws Throwable {\n         read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByJava7Jar());\n     }\n \n     }\n \n     @Ignore\n-    @Test public void readSelfGenerated100KFilesUsingZipFile()\n+        @Test public void readSelfGenerated100KFilesUsingZipFile()\n         throws Throwable {\n         withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\",\n                              new ZipOutputTest() {\n     }\n \n     @Ignore\n-    @Test public void read3EntriesCreatingBigArchiveFileUsingZipFile()\n+        @Test public void read3EntriesCreatingBigArchiveFileUsingZipFile()\n         throws Throwable {\n         withTemporaryArchive(\"read3EntriesCreatingBigArchiveFileUsingZipFile\",\n                              new ZipOutputTest() {\n                              true);\n     }\n \n+    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize) {\n+        return writeSmallStoredEntry(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n     /*\n      * One entry of length 1 million bytes, written without compression.\n      *\n      * No Compression => sizes are stored directly inside the LFH.  No\n      * Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n-     * field if size was known.\n+     * field if size was known and mode was different from Always.\n      *\n      * Creates a temporary archive of approx 1MB in size\n      */\n-    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize) {\n-        return writeSmallStoredEntry(knownSize, Zip64Mode.AsNeeded);\n-    }\n-\n     private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize,\n                                                        final Zip64Mode mode) {\n         return new ZipOutputTest() {\n                              true);\n     }\n \n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH, real values\n+     * are inside the data descriptor.  No ZIP64 extra field at all\n+     * unless mode is Always.\n+     */\n     private static ZipOutputTest\n         writeSmallDeflatedEntryKnownSizeToStream(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n-                                 public void test(File f,\n-                                                  ZipArchiveOutputStream zos)\n-                                     throws IOException {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                                     byte[] buf = new byte[ONE_MILLION];\n-                                     ZipArchiveEntry zae =\n-                                         new ZipArchiveEntry(\"0\");\n-                                     zae.setSize(ONE_MILLION);\n-                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n-                                     zos.putArchiveEntry(zae);\n-                                     zos.write(buf);\n-                                     zos.closeArchiveEntry();\n-                                     zos.close();\n-\n-                                     RandomAccessFile a =\n-                                         new RandomAccessFile(f, \"r\");\n-                                     try {\n-                                         final long end =\n-                                             getLengthAndPositionAtCentralDirectory(a);\n-\n-                                         long cfhPos = a.getFilePointer();\n-                                         // grab first entry, verify\n-                                         // sizes are not 0xFFFFFFF\n-                                         // and it has no ZIP64\n-                                         // extended information extra\n-                                         // field\n-                                         byte[] header = new byte[12];\n-                                         a.readFully(header);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // sig\n-                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n-                                                 // version made by\n-                                                 20, 0,\n-                                                 // version needed to extract\n-                                                 20, 0,\n-                                                 // GPB (EFS + Data Descriptor)\n-                                                 8, 8,\n-                                                 // method\n-                                                 8, 0,\n-                                             }, header);\n-                                         // ignore timestamp\n-                                         a.skipBytes(4);\n-                                         byte[] crc = new byte[4];\n-                                         a.readFully(crc);\n-                                         assertArrayEquals(new byte[] {\n-                                                 (byte) 0x9E, (byte) 0xCB,\n-                                                 (byte) 0x79, (byte) 0x12,\n-                                             }, crc);\n-                                         // skip compressed size\n-                                         a.skipBytes(4);\n-                                         byte[] rest = new byte[23];\n-                                         a.readFully(rest);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // Original Size\n-                                                 (byte) 0x40, (byte) 0x42,\n-                                                 (byte) 0x0F, 0,\n-                                                 // file name length\n-                                                 1, 0,\n-                                                 // extra field length\n-                                                 0, 0,\n-                                                 // comment length\n-                                                 0, 0,\n-                                                 // disk number\n-                                                 0, 0,\n-                                                 // attributes\n-                                                 0, 0,\n-                                                 0, 0, 0, 0,\n-                                                 // offset\n-                                                 0, 0, 0, 0,\n-                                                 // file name\n-                                                 (byte) '0'\n-                                             }, rest);\n-\n-                                         // validate data descriptor\n-                                         a.seek(cfhPos - 16);\n-                                         byte[] dd = new byte[8];\n-                                         a.readFully(dd);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // sig\n-                                                 (byte) 0x50, (byte) 0x4b, 7, 8,\n-                                                 // CRC\n-                                                 (byte) 0x9E, (byte) 0xCB,\n-                                                 (byte) 0x79, (byte) 0x12,\n-                                             }, dd);\n-                                         // skip uncompressed size\n-                                         a.skipBytes(4);\n-                                         dd = new byte[4];\n-                                         a.readFully(dd);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // original size\n-                                                 (byte) 0x40, (byte) 0x42,\n-                                                 (byte) 0x0F, 0,\n-                                             }, dd);\n-\n-                                         // and now validate local file header\n-                                         a.seek(0);\n-                                         header = new byte[10];\n-                                         a.readFully(header);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // sig\n-                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n-                                                 // version needed to extract\n-                                                 20, 0,\n-                                                 // GPB (EFS + Data Descriptor)\n-                                                 8, 8,\n-                                                 // method\n-                                                 8, 0,\n-                                             }, header);\n-                                         // ignore timestamp\n-                                         a.skipBytes(4);\n-                                         rest = new byte[17];\n-                                         a.readFully(rest);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // CRC\n-                                                 0, 0, 0, 0,\n-                                                 // Compressed Size\n-                                                 0, 0, 0, 0,\n-                                                 // Original Size\n-                                                 0, 0, 0, 0,\n-                                                 // file name length\n-                                                 1, 0,\n-                                                 // extra field length\n-                                                 mode == Zip64Mode.Always\n-                                                 ? (byte) 20 : 0,\n-                                                 0,\n-                                                 // file name\n-                                                 (byte) '0'\n-                                             }, rest);\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                zae.setSize(ONE_MILLION);\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify sizes are not\n+                    // 0xFFFFFFF and it has no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            20, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42,\n+                            (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // validate data descriptor\n+                    a.seek(cfhPos - 16);\n+                    byte[] dd = new byte[8];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 7, 8,\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                        }, dd);\n+                    // skip uncompressed size\n+                    a.skipBytes(4);\n+                    dd = new byte[4];\n+                    a.readFully(dd);\n+                    assertArrayEquals(new byte[] {\n+                            // original size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                        }, dd);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            20, 0,\n+                            // GPB (EFS + Data Descriptor)\n+                            8, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            0, 0, 0, 0,\n+                            // Compressed Size\n+                            0, 0, 0, 0,\n+                            // Original Size\n+                            0, 0, 0, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            mode == Zip64Mode.Always ? (byte) 20 : 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n                     if (mode == Zip64Mode.Always) {\n                         byte[] extra = new byte[20];\n                         a.readFully(extra);\n                                 0, 0, 0, 0,\n                             }, extra);\n                     }\n-\n-                                     } finally {\n-                                         a.close();\n-                                     }\n-                                 }\n+                } finally {\n+                    a.close();\n+                }\n+            }\n         };\n \n     }\n \n-    /*\n-     * One entry of length 1 million bytes, written with compression\n-     * to a stream.\n-     *\n-     * Compression + Stream => sizes are set to 0 in LFH, real values\n-     * are inside the data descriptor.  No ZIP64 extra field at all.\n-     */\n     @Test public void writeSmallDeflatedEntryKnownSizeToStream()\n         throws Throwable {\n         withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\",\n                              writeSmallDeflatedEntryKnownSizeToStream(Zip64Mode\n                                                                       .Never),\n                              false);\n+    }\n+\n+    private static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize) {\n+        return writeSmallDeflatedEntryToFile(knownSize, Zip64Mode.AsNeeded);\n     }\n \n     /*\n      *\n      * Writing to a file => sizes are stored directly inside the LFH.\n      * No Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n-     * field if size was known.\n+     * field if size was known and mode was not Always.\n      */\n-    private static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize) {\n-        return writeSmallDeflatedEntryToFile(knownSize, Zip64Mode.AsNeeded);\n-    }\n-\n     private static ZipOutputTest\n         writeSmallDeflatedEntryToFile(final boolean knownSize,\n                                       final Zip64Mode mode) {", "timestamp": 1312886358, "metainfo": ""}