{"sha": "b743bb24b8870ebf7adb47f27750bc140a8ef671", "log": "use term back-reference consistently", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n \n     static final int WINDOW_SIZE = 1 << 16;\n     static final int SIZE_BITS = 4;\n-    static final int COPY_SIZE_MASK = (1 << SIZE_BITS) - 1;\n-    static final int LITERAL_SIZE_MASK = COPY_SIZE_MASK << SIZE_BITS;\n+    static final int BACK_REFERENCE_SIZE_MASK = (1 << SIZE_BITS) - 1;\n+    static final int LITERAL_SIZE_MASK = BACK_REFERENCE_SIZE_MASK << SIZE_BITS;\n \n-    /** Copy-size part of the block starting byte. */\n-    private int nextCopySize;\n+    /** Back-Reference-size part of the block starting byte. */\n+    private int nextBackReferenceSize;\n \n     /** Current state of the stream */\n     private State state = State.NO_BLOCK;\n         case IN_LITERAL:\n             int litLen = readLiteral(b, off, len);\n             if (!hasMoreDataInBlock()) {\n-                state = State.LOOKING_FOR_COPY;\n+                state = State.LOOKING_FOR_BACK_REFERENCE;\n             }\n             return litLen;\n-        case LOOKING_FOR_COPY:\n-            if (!initializeCopy()) {\n+        case LOOKING_FOR_BACK_REFERENCE:\n+            if (!initializeBackReference()) {\n                 state = State.EOF;\n                 return -1;\n             }\n             /*FALLTHROUGH*/\n-        case IN_COPY:\n-            int copyLen = readCopy(b, off, len);\n+        case IN_BACK_REFERENCE:\n+            int backReferenceLen = readBackReference(b, off, len);\n             if (!hasMoreDataInBlock()) {\n                 state = State.NO_BLOCK;\n             }\n-            return copyLen;\n+            return backReferenceLen;\n         default:\n             throw new IOException(\"Unknown stream state \" + state);\n         }\n         if (nextBlock == -1) {\n             throw new IOException(\"Premature end of stream while looking for next block\");\n         }\n-        nextCopySize = nextBlock & COPY_SIZE_MASK;\n+        nextBackReferenceSize = nextBlock & BACK_REFERENCE_SIZE_MASK;\n         long literalSizePart = (nextBlock & LITERAL_SIZE_MASK) >> SIZE_BITS;\n-        if (literalSizePart == COPY_SIZE_MASK) {\n+        if (literalSizePart == BACK_REFERENCE_SIZE_MASK) {\n             literalSizePart += readSizeBytes();\n         }\n         startLiteral(literalSizePart);\n     }\n \n     /**\n-     * @return false if there is no more copy - this means this is the\n+     * @return false if there is no more back-reference - this means this is the\n      * last block of the stream.\n      */\n-    private boolean initializeCopy() throws IOException {\n-        int copyOffset = 0;\n+    private boolean initializeBackReference() throws IOException {\n+        int backReferenceOffset = 0;\n         try {\n-            copyOffset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n+            backReferenceOffset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n         } catch (IOException ex) {\n-            if (nextCopySize == 0) { // the last block has no copy\n+            if (nextBackReferenceSize == 0) { // the last block has no back-reference\n                 return false;\n             }\n             throw ex;\n         }\n-        long copySize = nextCopySize;\n-        if (nextCopySize == COPY_SIZE_MASK) {\n-            copySize += readSizeBytes();\n+        long backReferenceSize = nextBackReferenceSize;\n+        if (nextBackReferenceSize == BACK_REFERENCE_SIZE_MASK) {\n+            backReferenceSize += readSizeBytes();\n         }\n         // minimal match length 4 is encoded as 0\n-        startCopy(copyOffset, copySize + 4);\n-        state = State.IN_COPY;\n+        startBackReference(backReferenceOffset, backReferenceSize + 4);\n+        state = State.IN_BACK_REFERENCE;\n         return true;\n     }\n \n     private enum State {\n-        NO_BLOCK, IN_LITERAL, LOOKING_FOR_COPY, IN_COPY, EOF\n+        NO_BLOCK, IN_LITERAL, LOOKING_FOR_BACK_REFERENCE, IN_BACK_REFERENCE, EOF\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n         block.\n \n       * the start of a literal/back-reference pair contains the length\n-        of the copy (at least some part of it) so we can't start\n-        writing the literal before we know how long the next copy is\n-        going to be.\n+        of the back-reference (at least some part of it) so we can't\n+        start writing the literal before we know how long the next\n+        back-reference is going to be.\n \n       * there is a special rule for the final blocks\n \n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n     /** The underlying stream to read compressed data from */\n     private final InputStream in;\n \n-    /** Number of bytes still to be read from the current literal or copy. */\n+    /** Number of bytes still to be read from the current literal or back-reference. */\n     private long bytesRemaining;\n \n-    /** Offset of the current copy. */\n-    private int copyOffset;\n+    /** Offset of the current back-reference. */\n+    private int backReferenceOffset;\n \n     /** uncompressed size */\n     private int size = 0;\n      * @param the offset of the back-reference\n      * @param length the length of the back-reference\n      */\n-    protected final void startCopy(int offset, long length) {\n-        copyOffset = offset;\n+    protected final void startBackReference(int offset, long length) {\n+        backReferenceOffset = offset;\n         bytesRemaining = length;\n     }\n \n      * @return number of bytes read, may be 0. Will never return -1 as\n      * EOF-detection is the responsibility of the subclass\n      */\n-    protected final int readCopy(final byte[] b, final int off, final int len) {\n+    protected final int readBackReference(final byte[] b, final int off, final int len) {\n         final int avail = available();\n         if (len > avail) {\n             tryToCopy(len - avail);\n \n     private void tryToCopy(int bytesToCopy) {\n         // this will fit into the buffer without sliding and not\n-        // require more than is available inside the copy\n+        // require more than is available inside the back-reference\n         int copy = (int) Math.min(Math.min(bytesToCopy, bytesRemaining),\n                                   buf.length - writeIndex);\n         if (copy == 0) {\n             // NOP\n-        } else if (copyOffset == 1) { // pretty common special case\n+        } else if (backReferenceOffset == 1) { // pretty common special case\n             final byte last = buf[writeIndex - 1];\n             for (int i = 0; i < copy; i++) {\n                 buf[writeIndex++] = last;\n             }\n-        } else if (copy < copyOffset) {\n-            System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copy);\n+        } else if (copy < backReferenceOffset) {\n+            System.arraycopy(buf, writeIndex - backReferenceOffset, buf, writeIndex, copy);\n             writeIndex += copy;\n         } else {\n-            final int fullRots = copy / copyOffset;\n+            final int fullRots = copy / backReferenceOffset;\n             for (int i = 0; i < fullRots; i++) {\n-                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copyOffset);\n-                writeIndex += copyOffset;\n-            }\n-\n-            final int pad = copy - (copyOffset * fullRots);\n+                System.arraycopy(buf, writeIndex - backReferenceOffset, buf, writeIndex, backReferenceOffset);\n+                writeIndex += backReferenceOffset;\n+            }\n+\n+            final int pad = copy - (backReferenceOffset * fullRots);\n             if (pad > 0) {\n-                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, pad);\n+                System.arraycopy(buf, writeIndex - backReferenceOffset, buf, writeIndex, pad);\n                 writeIndex += pad;\n             }\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n                 state = State.NO_BLOCK;\n             }\n             return litLen;\n-        case IN_COPY:\n-            int copyLen = readCopy(b, off, len);\n+        case IN_BACK_REFERENCE:\n+            int backReferenceLen = readBackReference(b, off, len);\n             if (!hasMoreDataInBlock()) {\n                 state = State.NO_BLOCK;\n             }\n-            return copyLen;\n+            return backReferenceLen;\n         default:\n             throw new IOException(\"Unknown stream state \" + state);\n         }\n             offset = (b & 0xE0) << 3;\n             b = readOneByte();\n             if (b == -1) {\n-                throw new IOException(\"Premature end of stream reading copy length\");\n+                throw new IOException(\"Premature end of stream reading back-reference length\");\n             }\n             offset |= b;\n \n-            startCopy(offset, length);\n-            state = State.IN_COPY;\n+            startBackReference(offset, length);\n+            state = State.IN_BACK_REFERENCE;\n             break;\n \n         case 0x02:\n \n             offset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n \n-            startCopy(offset, length);\n-            state = State.IN_COPY;\n+            startBackReference(offset, length);\n+            state = State.IN_BACK_REFERENCE;\n             break;\n \n         case 0x03:\n \n             offset = (int) ByteUtils.fromLittleEndian(supplier, 4) & 0x7fffffff;\n \n-            startCopy(offset, length);\n-            state = State.IN_COPY;\n+            startBackReference(offset, length);\n+            state = State.IN_BACK_REFERENCE;\n             break;\n         }\n     }\n     }\n \n     private enum State {\n-        NO_BLOCK, IN_LITERAL, IN_COPY\n+        NO_BLOCK, IN_LITERAL, IN_BACK_REFERENCE\n     }\n }", "timestamp": 1484720233, "metainfo": ""}