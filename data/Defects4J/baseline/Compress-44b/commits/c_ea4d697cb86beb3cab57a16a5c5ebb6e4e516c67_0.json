{"sha": "ea4d697cb86beb3cab57a16a5c5ebb6e4e516c67", "log": "tweak ByteUtils", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/ByteUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ByteUtils.java\n      * @throws IllegalArgumentException if len is bigger than eight\n      */\n     public static long fromLittleEndian(byte[] bytes, final int off, final int length) {\n-        if (length > 8) {\n-            throw new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n-        }\n+        checkReadLength(length);\n         long l = 0;\n         for (int i = 0; i < length; i++) {\n             l |= (bytes[off + i] & 0xffl) << (8 * i);\n      * contain the given number of bytes anymore\n      */\n     public static long fromLittleEndian(InputStream in, int length) throws IOException {\n-        return fromLittleEndian(new InputStreamByteSupplier(in), length);\n+        // somewhat duplicates the ByteSupplier version in order to save othe creation of a wrapper object\n+        checkReadLength(length);\n+        long l = 0;\n+        for (int i = 0; i < length; i++) {\n+            int b = in.read();\n+            if (b == -1) {\n+                throw new IOException(\"premature end of data\");\n+            }\n+            l |= (b << (i * 8));\n+        }\n+        return l;\n     }\n \n     /**\n      * Reads the given number of bytes from the given supplier as a little endian long.\n+     *\n+     * <p>Typically used by our InputStreams that need to count the\n+     * bytes read as well.</p>\n+     *\n      * @param supplier the supplier for bytes\n      * @param length the number of bytes representing the value\n      * @throws IllegalArgumentException if len is bigger than eight\n      * given number of bytes anymore\n      */\n     public static long fromLittleEndian(ByteSupplier supplier, final int length) throws IOException {\n-        if (length > 8) {\n-            throw new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n-        }\n+        checkReadLength(length);\n         long l = 0;\n         for (int i = 0; i < length; i++) {\n             int b = supplier.getAsByte();\n      */\n     public static void toLittleEndian(OutputStream out, final long value, final int length)\n         throws IOException {\n-        toLittleEndian(new OutputStreamByteConsumer(out), value, length);\n+        // somewhat duplicates the ByteConsumer version in order to save othe creation of a wrapper object\n+        long num = value;\n+        for (int i = 0; i < length; i++) {\n+            out.write((int) (num & 0xff));\n+            num >>= 8;\n+        }\n     }\n \n     /**\n             os.write(b);\n         }\n     }\n+\n+    private static final void checkReadLength(int length) {\n+        if (length > 8) {\n+            throw new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/utils/ByteUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+\n+import static org.apache.commons.compress.utils.ByteUtils.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class ByteUtilsTest {\n+\n+    @Test\n+    public void fromLittleEndianFromArrayOneArg() {\n+        byte[] b = new byte[] { 2, 3, 4 };\n+        assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(b));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fromLittleEndianFromArrayOneArgThrowsForLengthTooBig() {\n+        fromLittleEndian(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n+    }\n+\n+    @Test\n+    public void fromLittleEndianFromArray() {\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5 };\n+        assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(b, 1, 3));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fromLittleEndianFromArrayThrowsForLengthTooBig() {\n+        fromLittleEndian(new byte[0], 0, 9);\n+    }\n+\n+    @Test\n+    public void fromLittleEndianFromStream() throws IOException {\n+        ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, 5 });\n+        assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(bin, 3));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fromLittleEndianFromStreamThrowsForLengthTooBig() throws IOException {\n+        fromLittleEndian(new ByteArrayInputStream(new byte[0]), 9);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void fromLittleEndianFromStreamThrowsForPrematureEnd() throws IOException {\n+        ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3 });\n+        fromLittleEndian(bin, 3);\n+    }\n+\n+    @Test\n+    public void fromLittleEndianFromSupplier() throws IOException {\n+        ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3, 4, 5 });\n+        assertEquals(2 + 3 * 256 + 4 * 256 * 256, fromLittleEndian(new InputStreamByteSupplier(bin), 3));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void fromLittleEndianFromSupplierThrowsForLengthTooBig() throws IOException {\n+        fromLittleEndian(new InputStreamByteSupplier(new ByteArrayInputStream(new byte[0])), 9);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void fromLittleEndianFromSupplierThrowsForPrematureEnd() throws IOException {\n+        ByteArrayInputStream bin = new ByteArrayInputStream(new byte[] { 2, 3 });\n+        fromLittleEndian(new InputStreamByteSupplier(bin), 3);\n+    }\n+\n+    @Test\n+    public void toLittleEndianToStream() throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        toLittleEndian(bos, 2 + 3 * 256 + 4 * 256 * 256, 3);\n+        bos.close();\n+        assertArrayEquals(new byte[] { 2, 3, 4 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void toLittleEndianToConsumer() throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        toLittleEndian(new OutputStreamByteConsumer(bos), 2 + 3 * 256 + 4 * 256 * 256, 3);\n+        bos.close();\n+        assertArrayEquals(new byte[] { 2, 3, 4 }, bos.toByteArray());\n+    }\n+}", "timestamp": 1484768939, "metainfo": ""}