{"sha": "7aa8e75a91013d51348b2e15745972cd6e9aad50", "log": "Format nit.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.compress.archivers.tar;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Locale;\n-\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipEncoding;\n-import org.apache.commons.compress.utils.ArchiveUtils;\n-\n-/**\n- * This class represents an entry in a Tar archive. It consists\n- * of the entry's header, as well as the entry's File. Entries\n- * can be instantiated in one of three ways, depending on how\n- * they are to be used.\n- * <p>\n- * TarEntries that are created from the header bytes read from\n- * an archive are instantiated with the TarEntry( byte[] )\n- * constructor. These entries will be used when extracting from\n- * or listing the contents of an archive. These entries have their\n- * header filled in using the header bytes. They also set the File\n- * to null, since they reference an archive entry not a file.\n- * <p>\n- * TarEntries that are created from Files that are to be written\n- * into an archive are instantiated with the TarEntry( File )\n- * constructor. These entries have their header filled in using\n- * the File's information. They also keep a reference to the File\n- * for convenience when writing entries.\n- * <p>\n- * Finally, TarEntries can be constructed from nothing but a name.\n- * This allows the programmer to construct the entry by hand, for\n- * instance when only an InputStream is available for writing to\n- * the archive, and the header information is constructed from\n- * other information. In this case the header fields are set to\n- * defaults and the File is set to null.\n- *\n- * <p>\n- * The C structure for a Tar Entry's header is:\n- * <pre>\n- * struct header {\n- * char name[100];     // TarConstants.NAMELEN    - offset   0\n- * char mode[8];       // TarConstants.MODELEN    - offset 100\n- * char uid[8];        // TarConstants.UIDLEN     - offset 108\n- * char gid[8];        // TarConstants.GIDLEN     - offset 116\n- * char size[12];      // TarConstants.SIZELEN    - offset 124\n- * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\n- * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\n- * char linkflag[1];   //                         - offset 156\n- * char linkname[100]; // TarConstants.NAMELEN    - offset 157\n- * The following fields are only present in new-style POSIX tar archives:\n- * char magic[6];      // TarConstants.MAGICLEN   - offset 257\n- * char version[2];    // TarConstants.VERSIONLEN - offset 263\n- * char uname[32];     // TarConstants.UNAMELEN   - offset 265\n- * char gname[32];     // TarConstants.GNAMELEN   - offset 297\n- * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\n- * char devminor[8];   // TarConstants.DEVLEN     - offset 337\n- * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\n- * // Used if \"name\" field is not long enough to hold the path\n- * char pad[12];       // NULs                    - offset 500\n- * } header;\n- * All unused bytes are set to null.\n- * New-style GNU tar files are slightly different from the above.\n- * For values of size larger than 077777777777L (11 7s)\n- * or uid and gid larger than 07777777L (7 7s)\n- * the sign bit of the first byte is set, and the rest of the\n- * field is the binary representation of the number.\n- * See TarUtils.parseOctalOrBinary.\n- * </pre>\n- * \n- * <p>\n- * The C structure for a old GNU Tar Entry's header is:\n- * <pre>\n- * struct oldgnu_header {\n- * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n- * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n- * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n- * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n- * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n- * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n- * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n- * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n- * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n- * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n- * };\n- * </pre>\n- * Whereas, \"struct sparse\" is:\n- * <pre>\n- * struct sparse {\n- * char offset[12];   // offset 0\n- * char numbytes[12]; // offset 12\n- * };\n- * </pre>\n- *\n- * @NotThreadSafe\n- */\n-\n-public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n-    /** The entry's name. */\n-    private String name = \"\";\n-\n-    /** The entry's permission mode. */\n-    private int mode;\n-\n-    /** The entry's user id. */\n-    private long userId = 0;\n-\n-    /** The entry's group id. */\n-    private long groupId = 0;\n-\n-    /** The entry's size. */\n-    private long size = 0;\n-\n-    /** The entry's modification time. */\n-    private long modTime;\n-\n-    /** If the header checksum is reasonably correct. */\n-    private boolean checkSumOK;\n-\n-    /** The entry's link flag. */\n-    private byte linkFlag;\n-\n-    /** The entry's link name. */\n-    private String linkName = \"\";\n-\n-    /** The entry's magic tag. */\n-    private String magic = MAGIC_POSIX;\n-    /** The version of the format */\n-    private String version = VERSION_POSIX;\n-\n-    /** The entry's user name. */\n-    private String userName;\n-\n-    /** The entry's group name. */\n-    private String groupName = \"\";\n-\n-    /** The entry's major device number. */\n-    private int devMajor = 0;\n-\n-    /** The entry's minor device number. */\n-    private int devMinor = 0;\n-\n-    /** If an extension sparse header follows. */\n-    private boolean isExtended;\n-\n-    /** The entry's real size in case of a sparse file. */\n-    private long realSize;\n-\n-    /** The entry's file reference */\n-    private final File file;\n-\n-    /** Maximum length of a user's name in the tar file */\n-    public static final int MAX_NAMELEN = 31;\n-\n-    /** Default permissions bits for directories */\n-    public static final int DEFAULT_DIR_MODE = 040755;\n-\n-    /** Default permissions bits for files */\n-    public static final int DEFAULT_FILE_MODE = 0100644;\n-\n-    /** Convert millis to seconds */\n-    public static final int MILLIS_PER_SECOND = 1000;\n-\n-    /**\n-     * Construct an empty entry and prepares the header values.\n-     */\n-    private TarArchiveEntry() {\n-        String user = System.getProperty(\"user.name\", \"\");\n-\n-        if (user.length() > MAX_NAMELEN) {\n-            user = user.substring(0, MAX_NAMELEN);\n-        }\n-\n-        this.userName = user;\n-        this.file = null;\n-    }\n-\n-    /**\n-     * Construct an entry with only a name. This allows the programmer\n-     * to construct the entry's header \"by hand\". File is set to null.\n-     *\n-     * @param name the entry name\n-     */\n-    public TarArchiveEntry(String name) {\n-        this(name, false);\n-    }\n-\n-    /**\n-     * Construct an entry with only a name. This allows the programmer\n-     * to construct the entry's header \"by hand\". File is set to null.\n-     *\n-     * @param name the entry name\n-     * @param preserveLeadingSlashes whether to allow leading slashes\n-     * in the name.\n-     * \n-     * @since 1.1\n-     */\n-    public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n-        this();\n-\n-        name = normalizeFileName(name, preserveLeadingSlashes);\n-        boolean isDir = name.endsWith(\"/\");\n-\n-        this.name = name;\n-        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n-        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n-        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n-        this.userName = \"\";\n-    }\n-\n-    /**\n-     * Construct an entry with a name and a link flag.\n-     *\n-     * @param name the entry name\n-     * @param linkFlag the entry link flag.\n-     */\n-    public TarArchiveEntry(String name, byte linkFlag) {\n-        this(name, linkFlag, false);\n-    }\n-\n-    /**\n-     * Construct an entry with a name and a link flag.\n-     *\n-     * @param name the entry name\n-     * @param linkFlag the entry link flag.\n-     * @param preserveLeadingSlashes whether to allow leading slashes\n-     * in the name.\n-     * \n-     * @since 1.5\n-     */\n-    public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\n-        this(name, preserveLeadingSlashes);\n-        this.linkFlag = linkFlag;\n-        if (linkFlag == LF_GNUTYPE_LONGNAME) {\n-            magic = MAGIC_GNU;\n-            version = VERSION_GNU_SPACE;\n-        }\n-    }\n-\n-    /**\n-     * Construct an entry for a file. File is set to file, and the\n-     * header is constructed from information from the file.\n-     * The name is set from the normalized file path.\n-     *\n-     * @param file The file that the entry represents.\n-     */\n-    public TarArchiveEntry(File file) {\n-        this(file, file.getPath());\n-    }\n-\n-    /**\n-     * Construct an entry for a file. File is set to file, and the\n-     * header is constructed from information from the file.\n-     *\n-     * @param file The file that the entry represents.\n-     * @param fileName the name to be used for the entry.\n-     */\n-    public TarArchiveEntry(File file, String fileName) {\n-        String normalizedName = normalizeFileName(fileName, false);\n-        this.file = file;\n-\n-        if (file.isDirectory()) {\n-            this.mode = DEFAULT_DIR_MODE;\n-            this.linkFlag = LF_DIR;\n-\n-            int nameLength = normalizedName.length();\n-            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n-                this.name = normalizedName + \"/\";\n-            } else {\n-                this.name = normalizedName;\n-            }\n-        } else {\n-            this.mode = DEFAULT_FILE_MODE;\n-            this.linkFlag = LF_NORMAL;\n-            this.size = file.length();\n-            this.name = normalizedName;\n-        }\n-\n-        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n-        this.userName = \"\";\n-    }\n-\n-    /**\n-     * Construct an entry from an archive's header bytes. File is set\n-     * to null.\n-     *\n-     * @param headerBuf The header bytes from a tar archive entry.\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n-     */\n-    public TarArchiveEntry(byte[] headerBuf) {\n-        this();\n-        parseTarHeader(headerBuf);\n-    }\n-\n-    /**\n-     * Construct an entry from an archive's header bytes. File is set\n-     * to null.\n-     *\n-     * @param headerBuf The header bytes from a tar archive entry.\n-     * @param encoding encoding to use for file names\n-     * @since 1.4\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n-     * @throws IOException on error\n-     */\n-    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\n-        throws IOException {\n-        this();\n-        parseTarHeader(headerBuf, encoding);\n-    }\n-\n-    /**\n-     * Determine if the two entries are equal. Equality is determined\n-     * by the header names being equal.\n-     *\n-     * @param it Entry to be checked for equality.\n-     * @return True if the entries are equal.\n-     */\n-    public boolean equals(TarArchiveEntry it) {\n-        return getName().equals(it.getName());\n-    }\n-\n-    /**\n-     * Determine if the two entries are equal. Equality is determined\n-     * by the header names being equal.\n-     *\n-     * @param it Entry to be checked for equality.\n-     * @return True if the entries are equal.\n-     */\n-    @Override\n-    public boolean equals(Object it) {\n-        if (it == null || getClass() != it.getClass()) {\n-            return false;\n-        }\n-        return equals((TarArchiveEntry) it);\n-    }\n-\n-    /**\n-     * Hashcodes are based on entry names.\n-     *\n-     * @return the entry hashcode\n-     */\n-    @Override\n-    public int hashCode() {\n-        return getName().hashCode();\n-    }\n-\n-    /**\n-     * Determine if the given entry is a descendant of this entry.\n-     * Descendancy is determined by the name of the descendant\n-     * starting with this entry's name.\n-     *\n-     * @param desc Entry to be checked as a descendent of this.\n-     * @return True if entry is a descendant of this.\n-     */\n-    public boolean isDescendent(TarArchiveEntry desc) {\n-        return desc.getName().startsWith(getName());\n-    }\n-\n-    /**\n-     * Get this entry's name.\n-     *\n-     * @return This entry's name.\n-     */\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Set this entry's name.\n-     *\n-     * @param name This entry's new name.\n-     */\n-    public void setName(String name) {\n-        this.name = normalizeFileName(name, false);\n-    }\n-\n-    /**\n-     * Set the mode for this entry\n-     *\n-     * @param mode the mode for this entry\n-     */\n-    public void setMode(int mode) {\n-        this.mode = mode;\n-    }\n-\n-    /**\n-     * Get this entry's link name.\n-     *\n-     * @return This entry's link name.\n-     */\n-    public String getLinkName() {\n-        return linkName;\n-    }\n-\n-    /**\n-     * Set this entry's link name.\n-     * \n-     * @param link the link name to use.\n-     * \n-     * @since 1.1\n-     */\n-    public void setLinkName(String link) {\n-        this.linkName = link;\n-    }\n-\n-    /**\n-     * Get this entry's user id.\n-     *\n-     * @return This entry's user id.\n-     * @deprecated use #getLongUserId instead as user ids can be\n-     * bigger than {@link Integer#MAX_VALUE}\n-     */\n-    @Deprecated\n-    public int getUserId() {\n-        return (int) (userId & 0xffffffff);\n-    }\n-\n-    /**\n-     * Set this entry's user id.\n-     *\n-     * @param userId This entry's new user id.\n-     */\n-    public void setUserId(int userId) {\n-        setUserId((long) userId);\n-    }\n-\n-    /**\n-     * Get this entry's user id.\n-     *\n-     * @return This entry's user id.\n-     * @since 1.10\n-     */\n-    public long getLongUserId() {\n-        return userId;\n-    }\n-\n-    /**\n-     * Set this entry's user id.\n-     *\n-     * @param userId This entry's new user id.\n-     * @since 1.10\n-     */\n-    public void setUserId(long userId) {\n-        this.userId = userId;\n-    }\n-\n-    /**\n-     * Get this entry's group id.\n-     *\n-     * @return This entry's group id.\n-     * @deprecated use #getLongGroupId instead as group ids can be\n-     * bigger than {@link Integer#MAX_VALUE}\n-     */\n-    @Deprecated\n-    public int getGroupId() {\n-        return (int) (groupId & 0xffffffff);\n-    }\n-\n-    /**\n-     * Set this entry's group id.\n-     *\n-     * @param groupId This entry's new group id.\n-     */\n-    public void setGroupId(int groupId) {\n-        setGroupId((long) groupId);\n-    }\n-\n-    /**\n-     * Get this entry's group id.\n-     *\n-     * @since 1.10\n-     * @return This entry's group id.\n-     */\n-    public long getLongGroupId() {\n-        return groupId;\n-    }\n-\n-    /**\n-     * Set this entry's group id.\n-     *\n-     * @since 1.10\n-     * @param groupId This entry's new group id.\n-     */\n-    public void setGroupId(long groupId) {\n-        this.groupId = groupId;\n-    }\n-\n-    /**\n-     * Get this entry's user name.\n-     *\n-     * @return This entry's user name.\n-     */\n-    public String getUserName() {\n-        return userName;\n-    }\n-\n-    /**\n-     * Set this entry's user name.\n-     *\n-     * @param userName This entry's new user name.\n-     */\n-    public void setUserName(String userName) {\n-        this.userName = userName;\n-    }\n-\n-    /**\n-     * Get this entry's group name.\n-     *\n-     * @return This entry's group name.\n-     */\n-    public String getGroupName() {\n-        return groupName;\n-    }\n-\n-    /**\n-     * Set this entry's group name.\n-     *\n-     * @param groupName This entry's new group name.\n-     */\n-    public void setGroupName(String groupName) {\n-        this.groupName = groupName;\n-    }\n-\n-    /**\n-     * Convenience method to set this entry's group and user ids.\n-     *\n-     * @param userId This entry's new user id.\n-     * @param groupId This entry's new group id.\n-     */\n-    public void setIds(int userId, int groupId) {\n-        setUserId(userId);\n-        setGroupId(groupId);\n-    }\n-\n-    /**\n-     * Convenience method to set this entry's group and user names.\n-     *\n-     * @param userName This entry's new user name.\n-     * @param groupName This entry's new group name.\n-     */\n-    public void setNames(String userName, String groupName) {\n-        setUserName(userName);\n-        setGroupName(groupName);\n-    }\n-\n-    /**\n-     * Set this entry's modification time. The parameter passed\n-     * to this method is in \"Java time\".\n-     *\n-     * @param time This entry's new modification time.\n-     */\n-    public void setModTime(long time) {\n-        modTime = time / MILLIS_PER_SECOND;\n-    }\n-\n-    /**\n-     * Set this entry's modification time.\n-     *\n-     * @param time This entry's new modification time.\n-     */\n-    public void setModTime(Date time) {\n-        modTime = time.getTime() / MILLIS_PER_SECOND;\n-    }\n-\n-    /**\n-     * Set this entry's modification time.\n-     *\n-     * @return time This entry's new modification time.\n-     */\n-    public Date getModTime() {\n-        return new Date(modTime * MILLIS_PER_SECOND);\n-    }\n-\n-    public Date getLastModifiedDate() {\n-        return getModTime();\n-    }\n-\n-    /**\n-     * Get this entry's checksum status.\n-     *\n-     * @return if the header checksum is reasonably correct\n-     * @see TarUtils#verifyCheckSum(byte[])\n-     * @since 1.5\n-     */\n-    public boolean isCheckSumOK() {\n-        return checkSumOK;\n-    }\n-\n-    /**\n-     * Get this entry's file.\n-     *\n-     * @return This entry's file.\n-     */\n-    public File getFile() {\n-        return file;\n-    }\n-\n-    /**\n-     * Get this entry's mode.\n-     *\n-     * @return This entry's mode.\n-     */\n-    public int getMode() {\n-        return mode;\n-    }\n-\n-    /**\n-     * Get this entry's file size.\n-     *\n-     * @return This entry's file size.\n-     */\n-    public long getSize() {\n-        return size;\n-    }\n-\n-    /**\n-     * Set this entry's file size.\n-     *\n-     * @param size This entry's new file size.\n-     * @throws IllegalArgumentException if the size is &lt; 0.\n-     */\n-    public void setSize(long size) {\n-        if (size < 0){\n-            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n-        }\n-        this.size = size;\n-    }\n-\n-    /**\n-     * Get this entry's major device number.\n-     *\n-     * @return This entry's major device number.\n-     * @since 1.4\n-     */\n-    public int getDevMajor() {\n-        return devMajor;\n-    }\n-\n-    /**\n-     * Set this entry's major device number.\n-     *\n-     * @param devNo This entry's major device number.\n-     * @throws IllegalArgumentException if the devNo is &lt; 0.\n-     * @since 1.4\n-     */\n-    public void setDevMajor(int devNo) {\n-        if (devNo < 0){\n-            throw new IllegalArgumentException(\"Major device number is out of \"\n-                                               + \"range: \" + devNo);\n-        }\n-        this.devMajor = devNo;\n-    }\n-\n-    /**\n-     * Get this entry's minor device number.\n-     *\n-     * @return This entry's minor device number.\n-     * @since 1.4\n-     */\n-    public int getDevMinor() {\n-        return devMinor;\n-    }\n-\n-    /**\n-     * Set this entry's minor device number.\n-     *\n-     * @param devNo This entry's minor device number.\n-     * @throws IllegalArgumentException if the devNo is &lt; 0.\n-     * @since 1.4\n-     */\n-    public void setDevMinor(int devNo) {\n-        if (devNo < 0){\n-            throw new IllegalArgumentException(\"Minor device number is out of \"\n-                                               + \"range: \" + devNo);\n-        }\n-        this.devMinor = devNo;\n-    }\n-\n-    /**\n-     * Indicates in case of a sparse file if an extension sparse header\n-     * follows.\n-     *\n-     * @return true if an extension sparse header follows.\n-     */\n-    public boolean isExtended() {\n-        return isExtended;\n-    }\n-\n-    /**\n-     * Get this entry's real file size in case of a sparse file.\n-     *\n-     * @return This entry's real file size.\n-     */\n-    public long getRealSize() {\n-        return realSize;\n-    }\n-\n-    /**\n-     * Indicate if this entry is a GNU sparse block \n-     *\n-     * @return true if this is a sparse extension provided by GNU tar\n-     */\n-    public boolean isGNUSparse() {\n-        return linkFlag == LF_GNUTYPE_SPARSE;\n-    }\n-\n-    /**\n-     * Indicate if this entry is a GNU long linkname block\n-     *\n-     * @return true if this is a long name extension provided by GNU tar\n-     */\n-    public boolean isGNULongLinkEntry() {\n-        return linkFlag == LF_GNUTYPE_LONGLINK;\n-    }\n-\n-    /**\n-     * Indicate if this entry is a GNU long name block\n-     *\n-     * @return true if this is a long name extension provided by GNU tar\n-     */\n-    public boolean isGNULongNameEntry() {\n-        return linkFlag == LF_GNUTYPE_LONGNAME;\n-    }\n-\n-    /**\n-     * Check if this is a Pax header.\n-     * \n-     * @return {@code true} if this is a Pax header.\n-     * \n-     * @since 1.1\n-     * \n-     */\n-    public boolean isPaxHeader(){\n-        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n-            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n-    }\n-\n-    /**\n-     * Check if this is a Pax header.\n-     * \n-     * @return {@code true} if this is a Pax header.\n-     * \n-     * @since 1.1\n-     */\n-    public boolean isGlobalPaxHeader(){\n-        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n-    }\n-\n-    /**\n-     * Return whether or not this entry represents a directory.\n-     *\n-     * @return True if this entry is a directory.\n-     */\n-    public boolean isDirectory() {\n-        if (file != null) {\n-            return file.isDirectory();\n-        }\n-\n-        if (linkFlag == LF_DIR) {\n-            return true;\n-        }\n-\n-        if (getName().endsWith(\"/\")) {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    /**\n-     * Check if this is a \"normal file\"\n-     *\n-     * @since 1.2\n-     * @return whether this is a \"normal file\"\n-     */\n-    public boolean isFile() {\n-        if (file != null) {\n-            return file.isFile();\n-        }\n-        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n-            return true;\n-        }\n-        return !getName().endsWith(\"/\");\n-    }\n-\n-    /**\n-     * Check if this is a symbolic link entry.\n-     *\n-     * @since 1.2\n-     * @return whether this is a symbolic link\n-     */\n-    public boolean isSymbolicLink() {\n-        return linkFlag == LF_SYMLINK;\n-    }\n-\n-    /**\n-     * Check if this is a link entry.\n-     *\n-     * @since 1.2\n-     * @return whether this is a link entry\n-     */\n-    public boolean isLink() {\n-        return linkFlag == LF_LINK;\n-    }\n-\n-    /**\n-     * Check if this is a character device entry.\n-     *\n-     * @since 1.2\n-     * @return whether this is a character device\n-     */\n-    public boolean isCharacterDevice() {\n-        return linkFlag == LF_CHR;\n-    }\n-\n-    /**\n-     * Check if this is a block device entry.\n-     *\n-     * @since 1.2\n-     * @return whether this is a block device\n-     */\n-    public boolean isBlockDevice() {\n-        return linkFlag == LF_BLK;\n-    }\n-\n-    /**\n-     * Check if this is a FIFO (pipe) entry.\n-     *\n-     * @since 1.2\n-     * @return whether this is a FIFO entry\n-     */\n-    public boolean isFIFO() {\n-        return linkFlag == LF_FIFO;\n-    }\n-\n-    /**\n-     * If this entry represents a file, and the file is a directory, return\n-     * an array of TarEntries for this entry's children.\n-     *\n-     * @return An array of TarEntry's for this entry's children.\n-     */\n-    public TarArchiveEntry[] getDirectoryEntries() {\n-        if (file == null || !file.isDirectory()) {\n-            return new TarArchiveEntry[0];\n-        }\n-\n-        String[]   list = file.list();\n-        TarArchiveEntry[] result = new TarArchiveEntry[list == null ? 0 : list.length];\n-\n-        for (int i = 0; i < result.length; ++i) {\n-            result[i] = new TarArchiveEntry(new File(file, list[i]));\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Write an entry's header information to a header buffer.\n-     *\n-     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\n-     *\n-     * @param outbuf The tar entry header buffer to fill in.\n-     */\n-    public void writeEntryHeader(byte[] outbuf) {\n-        try {\n-            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n-        } catch (IOException ex) {\n-            try {\n-                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n-            } catch (IOException ex2) {\n-                // impossible\n-                throw new RuntimeException(ex2);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Write an entry's header information to a header buffer.\n-     *\n-     * @param outbuf The tar entry header buffer to fill in.\n-     * @param encoding encoding to use when writing the file name.\n-     * @param starMode whether to use the star/GNU tar/BSD tar\n-     * extension for numeric fields if their value doesn't fit in the\n-     * maximum size of standard tar archives\n-     * @since 1.4\n-     * @throws IOException on error\n-     */\n-    public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n-                                 boolean starMode) throws IOException {\n-        int offset = 0;\n-\n-        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n-                                          encoding);\n-        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n-        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n-                                       starMode);\n-        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n-                                       starMode);\n-        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n-        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n-                                       starMode);\n-\n-        int csOffset = offset;\n-\n-        for (int c = 0; c < CHKSUMLEN; ++c) {\n-            outbuf[offset++] = (byte) ' ';\n-        }\n-\n-        outbuf[offset++] = linkFlag;\n-        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n-                                          encoding);\n-        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n-        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n-        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n-                                          encoding);\n-        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n-                                          encoding);\n-        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n-                                       starMode);\n-        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n-                                       starMode);\n-\n-        while (offset < outbuf.length) {\n-            outbuf[offset++] = 0;\n-        }\n-\n-        long chk = TarUtils.computeCheckSum(outbuf);\n-\n-        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n-    }\n-\n-    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n-                                      int length, boolean starMode) {\n-        if (!starMode && (value < 0\n-                          || value >= 1l << 3 * (length - 1))) {\n-            // value doesn't fit into field when written as octal\n-            // number, will be written to PAX header or causes an\n-            // error\n-            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n-        }\n-        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n-                                                     length);\n-    }\n-\n-    /**\n-     * Parse an entry's header information from a header buffer.\n-     *\n-     * @param header The tar entry header buffer to get information from.\n-     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n-     */\n-    public void parseTarHeader(byte[] header) {\n-        try {\n-            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n-        } catch (IOException ex) {\n-            try {\n-                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n-            } catch (IOException ex2) {\n-                // not really possible\n-                throw new RuntimeException(ex2);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parse an entry's header information from a header buffer.\n-     *\n-     * @param header The tar entry header buffer to get information from.\n-     * @param encoding encoding to use for file names\n-     * @since 1.4\n-     * @throws IllegalArgumentException if any of the numeric fields\n-     * have an invalid format\n-     * @throws IOException on error\n-     */\n-    public void parseTarHeader(byte[] header, ZipEncoding encoding)\n-        throws IOException {\n-        parseTarHeader(header, encoding, false);\n-    }\n-\n-    private void parseTarHeader(byte[] header, ZipEncoding encoding,\n-                                final boolean oldStyle)\n-        throws IOException {\n-        int offset = 0;\n-\n-        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n-            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n-        offset += NAMELEN;\n-        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n-        offset += MODELEN;\n-        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n-        offset += UIDLEN;\n-        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n-        offset += GIDLEN;\n-        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n-        offset += SIZELEN;\n-        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n-        offset += MODTIMELEN;\n-        checkSumOK = TarUtils.verifyCheckSum(header);\n-        offset += CHKSUMLEN;\n-        linkFlag = header[offset++];\n-        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n-            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n-        offset += NAMELEN;\n-        magic = TarUtils.parseName(header, offset, MAGICLEN);\n-        offset += MAGICLEN;\n-        version = TarUtils.parseName(header, offset, VERSIONLEN);\n-        offset += VERSIONLEN;\n-        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n-            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n-        offset += UNAMELEN;\n-        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n-            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n-        offset += GNAMELEN;\n-        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n-        offset += DEVLEN;\n-        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n-        offset += DEVLEN;\n-\n-        int type = evaluateType(header);\n-        switch (type) {\n-        case FORMAT_OLDGNU: {\n-            offset += ATIMELEN_GNU;\n-            offset += CTIMELEN_GNU;\n-            offset += OFFSETLEN_GNU;\n-            offset += LONGNAMESLEN_GNU;\n-            offset += PAD2LEN_GNU;\n-            offset += SPARSELEN_GNU;\n-            isExtended = TarUtils.parseBoolean(header, offset);\n-            offset += ISEXTENDEDLEN_GNU;\n-            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n-            offset += REALSIZELEN_GNU;\n-            break;\n-        }\n-        case FORMAT_POSIX:\n-        default: {\n-            String prefix = oldStyle\n-                ? TarUtils.parseName(header, offset, PREFIXLEN)\n-                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n-            // SunOS tar -E does not add / to directory names, so fix\n-            // up to be consistent\n-            if (isDirectory() && !name.endsWith(\"/\")){\n-                name = name + \"/\";\n-            }\n-            if (prefix.length() > 0){\n-                name = prefix + \"/\" + name;\n-            }\n-        }\n-        }\n-    }\n-\n-    /**\n-     * Strips Windows' drive letter as well as any leading slashes,\n-     * turns path separators into forward slahes.\n-     */\n-    private static String normalizeFileName(String fileName,\n-                                            boolean preserveLeadingSlashes) {\n-        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n-\n-        if (osname != null) {\n-\n-            // Strip off drive letters!\n-            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n-\n-            if (osname.startsWith(\"windows\")) {\n-                if (fileName.length() > 2) {\n-                    char ch1 = fileName.charAt(0);\n-                    char ch2 = fileName.charAt(1);\n-\n-                    if (ch2 == ':'\n-                        && (ch1 >= 'a' && ch1 <= 'z'\n-                            || ch1 >= 'A' && ch1 <= 'Z')) {\n-                        fileName = fileName.substring(2);\n-                    }\n-                }\n-            } else if (osname.contains(\"netware\")) {\n-                int colon = fileName.indexOf(':');\n-                if (colon != -1) {\n-                    fileName = fileName.substring(colon + 1);\n-                }\n-            }\n-        }\n-\n-        fileName = fileName.replace(File.separatorChar, '/');\n-\n-        // No absolute pathnames\n-        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n-        // so we loop on starting /'s.\n-        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n-            fileName = fileName.substring(1);\n-        }\n-        return fileName;\n-    }\n-\n-    /**\n-     * Evaluate an entry's header format from a header buffer.\n-     *\n-     * @param header The tar entry header buffer to evaluate the format for.\n-     * @return format type\n-     */\n-    private int evaluateType(byte[] header) {\n-        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n-            return FORMAT_OLDGNU;\n-        }\n-        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n-            return FORMAT_POSIX;\n-        }\n-        return 0;\n-    }\n-}\n-\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n+\n+/**\n+ * This class represents an entry in a Tar archive. It consists\n+ * of the entry's header, as well as the entry's File. Entries\n+ * can be instantiated in one of three ways, depending on how\n+ * they are to be used.\n+ * <p>\n+ * TarEntries that are created from the header bytes read from\n+ * an archive are instantiated with the TarEntry( byte[] )\n+ * constructor. These entries will be used when extracting from\n+ * or listing the contents of an archive. These entries have their\n+ * header filled in using the header bytes. They also set the File\n+ * to null, since they reference an archive entry not a file.\n+ * <p>\n+ * TarEntries that are created from Files that are to be written\n+ * into an archive are instantiated with the TarEntry( File )\n+ * constructor. These entries have their header filled in using\n+ * the File's information. They also keep a reference to the File\n+ * for convenience when writing entries.\n+ * <p>\n+ * Finally, TarEntries can be constructed from nothing but a name.\n+ * This allows the programmer to construct the entry by hand, for\n+ * instance when only an InputStream is available for writing to\n+ * the archive, and the header information is constructed from\n+ * other information. In this case the header fields are set to\n+ * defaults and the File is set to null.\n+ *\n+ * <p>\n+ * The C structure for a Tar Entry's header is:\n+ * <pre>\n+ * struct header {\n+ * char name[100];     // TarConstants.NAMELEN    - offset   0\n+ * char mode[8];       // TarConstants.MODELEN    - offset 100\n+ * char uid[8];        // TarConstants.UIDLEN     - offset 108\n+ * char gid[8];        // TarConstants.GIDLEN     - offset 116\n+ * char size[12];      // TarConstants.SIZELEN    - offset 124\n+ * char mtime[12];     // TarConstants.MODTIMELEN - offset 136\n+ * char chksum[8];     // TarConstants.CHKSUMLEN  - offset 148\n+ * char linkflag[1];   //                         - offset 156\n+ * char linkname[100]; // TarConstants.NAMELEN    - offset 157\n+ * The following fields are only present in new-style POSIX tar archives:\n+ * char magic[6];      // TarConstants.MAGICLEN   - offset 257\n+ * char version[2];    // TarConstants.VERSIONLEN - offset 263\n+ * char uname[32];     // TarConstants.UNAMELEN   - offset 265\n+ * char gname[32];     // TarConstants.GNAMELEN   - offset 297\n+ * char devmajor[8];   // TarConstants.DEVLEN     - offset 329\n+ * char devminor[8];   // TarConstants.DEVLEN     - offset 337\n+ * char prefix[155];   // TarConstants.PREFIXLEN  - offset 345\n+ * // Used if \"name\" field is not long enough to hold the path\n+ * char pad[12];       // NULs                    - offset 500\n+ * } header;\n+ * All unused bytes are set to null.\n+ * New-style GNU tar files are slightly different from the above.\n+ * For values of size larger than 077777777777L (11 7s)\n+ * or uid and gid larger than 07777777L (7 7s)\n+ * the sign bit of the first byte is set, and the rest of the\n+ * field is the binary representation of the number.\n+ * See TarUtils.parseOctalOrBinary.\n+ * </pre>\n+ * \n+ * <p>\n+ * The C structure for a old GNU Tar Entry's header is:\n+ * <pre>\n+ * struct oldgnu_header {\n+ * char unused_pad1[345]; // TarConstants.PAD1LEN_GNU       - offset 0\n+ * char atime[12];        // TarConstants.ATIMELEN_GNU      - offset 345\n+ * char ctime[12];        // TarConstants.CTIMELEN_GNU      - offset 357\n+ * char offset[12];       // TarConstants.OFFSETLEN_GNU     - offset 369\n+ * char longnames[4];     // TarConstants.LONGNAMESLEN_GNU  - offset 381\n+ * char unused_pad2;      // TarConstants.PAD2LEN_GNU       - offset 385\n+ * struct sparse sp[4];   // TarConstants.SPARSELEN_GNU     - offset 386\n+ * char isextended;       // TarConstants.ISEXTENDEDLEN_GNU - offset 482\n+ * char realsize[12];     // TarConstants.REALSIZELEN_GNU   - offset 483\n+ * char unused_pad[17];   // TarConstants.PAD3LEN_GNU       - offset 495\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ *\n+ * @NotThreadSafe\n+ */\n+\n+public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n+    /** The entry's name. */\n+    private String name = \"\";\n+\n+    /** The entry's permission mode. */\n+    private int mode;\n+\n+    /** The entry's user id. */\n+    private long userId = 0;\n+\n+    /** The entry's group id. */\n+    private long groupId = 0;\n+\n+    /** The entry's size. */\n+    private long size = 0;\n+\n+    /** The entry's modification time. */\n+    private long modTime;\n+\n+    /** If the header checksum is reasonably correct. */\n+    private boolean checkSumOK;\n+\n+    /** The entry's link flag. */\n+    private byte linkFlag;\n+\n+    /** The entry's link name. */\n+    private String linkName = \"\";\n+\n+    /** The entry's magic tag. */\n+    private String magic = MAGIC_POSIX;\n+    /** The version of the format */\n+    private String version = VERSION_POSIX;\n+\n+    /** The entry's user name. */\n+    private String userName;\n+\n+    /** The entry's group name. */\n+    private String groupName = \"\";\n+\n+    /** The entry's major device number. */\n+    private int devMajor = 0;\n+\n+    /** The entry's minor device number. */\n+    private int devMinor = 0;\n+\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /** The entry's real size in case of a sparse file. */\n+    private long realSize;\n+\n+    /** The entry's file reference */\n+    private final File file;\n+\n+    /** Maximum length of a user's name in the tar file */\n+    public static final int MAX_NAMELEN = 31;\n+\n+    /** Default permissions bits for directories */\n+    public static final int DEFAULT_DIR_MODE = 040755;\n+\n+    /** Default permissions bits for files */\n+    public static final int DEFAULT_FILE_MODE = 0100644;\n+\n+    /** Convert millis to seconds */\n+    public static final int MILLIS_PER_SECOND = 1000;\n+\n+    /**\n+     * Construct an empty entry and prepares the header values.\n+     */\n+    private TarArchiveEntry() {\n+        String user = System.getProperty(\"user.name\", \"\");\n+\n+        if (user.length() > MAX_NAMELEN) {\n+            user = user.substring(0, MAX_NAMELEN);\n+        }\n+\n+        this.userName = user;\n+        this.file = null;\n+    }\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer\n+     * to construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the entry name\n+     */\n+    public TarArchiveEntry(String name) {\n+        this(name, false);\n+    }\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer\n+     * to construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the entry name\n+     * @param preserveLeadingSlashes whether to allow leading slashes\n+     * in the name.\n+     * \n+     * @since 1.1\n+     */\n+    public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n+        this();\n+\n+        name = normalizeFileName(name, preserveLeadingSlashes);\n+        boolean isDir = name.endsWith(\"/\");\n+\n+        this.name = name;\n+        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n+        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n+        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n+        this.userName = \"\";\n+    }\n+\n+    /**\n+     * Construct an entry with a name and a link flag.\n+     *\n+     * @param name the entry name\n+     * @param linkFlag the entry link flag.\n+     */\n+    public TarArchiveEntry(String name, byte linkFlag) {\n+        this(name, linkFlag, false);\n+    }\n+\n+    /**\n+     * Construct an entry with a name and a link flag.\n+     *\n+     * @param name the entry name\n+     * @param linkFlag the entry link flag.\n+     * @param preserveLeadingSlashes whether to allow leading slashes\n+     * in the name.\n+     * \n+     * @since 1.5\n+     */\n+    public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\n+        this(name, preserveLeadingSlashes);\n+        this.linkFlag = linkFlag;\n+        if (linkFlag == LF_GNUTYPE_LONGNAME) {\n+            magic = MAGIC_GNU;\n+            version = VERSION_GNU_SPACE;\n+        }\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the\n+     * header is constructed from information from the file.\n+     * The name is set from the normalized file path.\n+     *\n+     * @param file The file that the entry represents.\n+     */\n+    public TarArchiveEntry(File file) {\n+        this(file, file.getPath());\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the\n+     * header is constructed from information from the file.\n+     *\n+     * @param file The file that the entry represents.\n+     * @param fileName the name to be used for the entry.\n+     */\n+    public TarArchiveEntry(File file, String fileName) {\n+        String normalizedName = normalizeFileName(fileName, false);\n+        this.file = file;\n+\n+        if (file.isDirectory()) {\n+            this.mode = DEFAULT_DIR_MODE;\n+            this.linkFlag = LF_DIR;\n+\n+            int nameLength = normalizedName.length();\n+            if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n+                this.name = normalizedName + \"/\";\n+            } else {\n+                this.name = normalizedName;\n+            }\n+        } else {\n+            this.mode = DEFAULT_FILE_MODE;\n+            this.linkFlag = LF_NORMAL;\n+            this.size = file.length();\n+            this.name = normalizedName;\n+        }\n+\n+        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n+        this.userName = \"\";\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     */\n+    public TarArchiveEntry(byte[] headerBuf) {\n+        this();\n+        parseTarHeader(headerBuf);\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @param encoding encoding to use for file names\n+     * @since 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     * @throws IOException on error\n+     */\n+    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\n+        throws IOException {\n+        this();\n+        parseTarHeader(headerBuf, encoding);\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals(TarArchiveEntry it) {\n+        return getName().equals(it.getName());\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    @Override\n+    public boolean equals(Object it) {\n+        if (it == null || getClass() != it.getClass()) {\n+            return false;\n+        }\n+        return equals((TarArchiveEntry) it);\n+    }\n+\n+    /**\n+     * Hashcodes are based on entry names.\n+     *\n+     * @return the entry hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * Determine if the given entry is a descendant of this entry.\n+     * Descendancy is determined by the name of the descendant\n+     * starting with this entry's name.\n+     *\n+     * @param desc Entry to be checked as a descendent of this.\n+     * @return True if entry is a descendant of this.\n+     */\n+    public boolean isDescendent(TarArchiveEntry desc) {\n+        return desc.getName().startsWith(getName());\n+    }\n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n+    public void setName(String name) {\n+        this.name = normalizeFileName(name, false);\n+    }\n+\n+    /**\n+     * Set the mode for this entry\n+     *\n+     * @param mode the mode for this entry\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    /**\n+     * Get this entry's link name.\n+     *\n+     * @return This entry's link name.\n+     */\n+    public String getLinkName() {\n+        return linkName;\n+    }\n+\n+    /**\n+     * Set this entry's link name.\n+     * \n+     * @param link the link name to use.\n+     * \n+     * @since 1.1\n+     */\n+    public void setLinkName(String link) {\n+        this.linkName = link;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @deprecated use #getLongUserId instead as user ids can be\n+     * bigger than {@link Integer#MAX_VALUE}\n+     */\n+    @Deprecated\n+    public int getUserId() {\n+        return (int) (userId & 0xffffffff);\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     */\n+    public void setUserId(int userId) {\n+        setUserId((long) userId);\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @since 1.10\n+     */\n+    public long getLongUserId() {\n+        return userId;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     * @since 1.10\n+     */\n+    public void setUserId(long userId) {\n+        this.userId = userId;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     * @deprecated use #getLongGroupId instead as group ids can be\n+     * bigger than {@link Integer#MAX_VALUE}\n+     */\n+    @Deprecated\n+    public int getGroupId() {\n+        return (int) (groupId & 0xffffffff);\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupId(int groupId) {\n+        setGroupId((long) groupId);\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @since 1.10\n+     * @return This entry's group id.\n+     */\n+    public long getLongGroupId() {\n+        return groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @since 1.10\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupId(long groupId) {\n+        this.groupId = groupId;\n+    }\n+\n+    /**\n+     * Get this entry's user name.\n+     *\n+     * @return This entry's user name.\n+     */\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    /**\n+     * Set this entry's user name.\n+     *\n+     * @param userName This entry's new user name.\n+     */\n+    public void setUserName(String userName) {\n+        this.userName = userName;\n+    }\n+\n+    /**\n+     * Get this entry's group name.\n+     *\n+     * @return This entry's group name.\n+     */\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    /**\n+     * Set this entry's group name.\n+     *\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setGroupName(String groupName) {\n+        this.groupName = groupName;\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user ids.\n+     *\n+     * @param userId This entry's new user id.\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setIds(int userId, int groupId) {\n+        setUserId(userId);\n+        setGroupId(groupId);\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user names.\n+     *\n+     * @param userName This entry's new user name.\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setNames(String userName, String groupName) {\n+        setUserName(userName);\n+        setGroupName(groupName);\n+    }\n+\n+    /**\n+     * Set this entry's modification time. The parameter passed\n+     * to this method is in \"Java time\".\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime(long time) {\n+        modTime = time / MILLIS_PER_SECOND;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime(Date time) {\n+        modTime = time.getTime() / MILLIS_PER_SECOND;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @return time This entry's new modification time.\n+     */\n+    public Date getModTime() {\n+        return new Date(modTime * MILLIS_PER_SECOND);\n+    }\n+\n+    public Date getLastModifiedDate() {\n+        return getModTime();\n+    }\n+\n+    /**\n+     * Get this entry's checksum status.\n+     *\n+     * @return if the header checksum is reasonably correct\n+     * @see TarUtils#verifyCheckSum(byte[])\n+     * @since 1.5\n+     */\n+    public boolean isCheckSumOK() {\n+        return checkSumOK;\n+    }\n+\n+    /**\n+     * Get this entry's file.\n+     *\n+     * @return This entry's file.\n+     */\n+    public File getFile() {\n+        return file;\n+    }\n+\n+    /**\n+     * Get this entry's mode.\n+     *\n+     * @return This entry's mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+\n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Set this entry's file size.\n+     *\n+     * @param size This entry's new file size.\n+     * @throws IllegalArgumentException if the size is &lt; 0.\n+     */\n+    public void setSize(long size) {\n+        if (size < 0){\n+            throw new IllegalArgumentException(\"Size is out of range: \"+size);\n+        }\n+        this.size = size;\n+    }\n+\n+    /**\n+     * Get this entry's major device number.\n+     *\n+     * @return This entry's major device number.\n+     * @since 1.4\n+     */\n+    public int getDevMajor() {\n+        return devMajor;\n+    }\n+\n+    /**\n+     * Set this entry's major device number.\n+     *\n+     * @param devNo This entry's major device number.\n+     * @throws IllegalArgumentException if the devNo is &lt; 0.\n+     * @since 1.4\n+     */\n+    public void setDevMajor(int devNo) {\n+        if (devNo < 0){\n+            throw new IllegalArgumentException(\"Major device number is out of \"\n+                                               + \"range: \" + devNo);\n+        }\n+        this.devMajor = devNo;\n+    }\n+\n+    /**\n+     * Get this entry's minor device number.\n+     *\n+     * @return This entry's minor device number.\n+     * @since 1.4\n+     */\n+    public int getDevMinor() {\n+        return devMinor;\n+    }\n+\n+    /**\n+     * Set this entry's minor device number.\n+     *\n+     * @param devNo This entry's minor device number.\n+     * @throws IllegalArgumentException if the devNo is &lt; 0.\n+     * @since 1.4\n+     */\n+    public void setDevMinor(int devNo) {\n+        if (devNo < 0){\n+            throw new IllegalArgumentException(\"Minor device number is out of \"\n+                                               + \"range: \" + devNo);\n+        }\n+        this.devMinor = devNo;\n+    }\n+\n+    /**\n+     * Indicates in case of a sparse file if an extension sparse header\n+     * follows.\n+     *\n+     * @return true if an extension sparse header follows.\n+     */\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+\n+    /**\n+     * Get this entry's real file size in case of a sparse file.\n+     *\n+     * @return This entry's real file size.\n+     */\n+    public long getRealSize() {\n+        return realSize;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU sparse block \n+     *\n+     * @return true if this is a sparse extension provided by GNU tar\n+     */\n+    public boolean isGNUSparse() {\n+        return linkFlag == LF_GNUTYPE_SPARSE;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long linkname block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongLinkEntry() {\n+        return linkFlag == LF_GNUTYPE_LONGLINK;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long name block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongNameEntry() {\n+        return linkFlag == LF_GNUTYPE_LONGNAME;\n+    }\n+\n+    /**\n+     * Check if this is a Pax header.\n+     * \n+     * @return {@code true} if this is a Pax header.\n+     * \n+     * @since 1.1\n+     * \n+     */\n+    public boolean isPaxHeader(){\n+        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n+            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n+    }\n+\n+    /**\n+     * Check if this is a Pax header.\n+     * \n+     * @return {@code true} if this is a Pax header.\n+     * \n+     * @since 1.1\n+     */\n+    public boolean isGlobalPaxHeader(){\n+        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n+    }\n+\n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n+    public boolean isDirectory() {\n+        if (file != null) {\n+            return file.isDirectory();\n+        }\n+\n+        if (linkFlag == LF_DIR) {\n+            return true;\n+        }\n+\n+        if (getName().endsWith(\"/\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Check if this is a \"normal file\"\n+     *\n+     * @since 1.2\n+     * @return whether this is a \"normal file\"\n+     */\n+    public boolean isFile() {\n+        if (file != null) {\n+            return file.isFile();\n+        }\n+        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n+            return true;\n+        }\n+        return !getName().endsWith(\"/\");\n+    }\n+\n+    /**\n+     * Check if this is a symbolic link entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a symbolic link\n+     */\n+    public boolean isSymbolicLink() {\n+        return linkFlag == LF_SYMLINK;\n+    }\n+\n+    /**\n+     * Check if this is a link entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a link entry\n+     */\n+    public boolean isLink() {\n+        return linkFlag == LF_LINK;\n+    }\n+\n+    /**\n+     * Check if this is a character device entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a character device\n+     */\n+    public boolean isCharacterDevice() {\n+        return linkFlag == LF_CHR;\n+    }\n+\n+    /**\n+     * Check if this is a block device entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a block device\n+     */\n+    public boolean isBlockDevice() {\n+        return linkFlag == LF_BLK;\n+    }\n+\n+    /**\n+     * Check if this is a FIFO (pipe) entry.\n+     *\n+     * @since 1.2\n+     * @return whether this is a FIFO entry\n+     */\n+    public boolean isFIFO() {\n+        return linkFlag == LF_FIFO;\n+    }\n+\n+    /**\n+     * If this entry represents a file, and the file is a directory, return\n+     * an array of TarEntries for this entry's children.\n+     *\n+     * @return An array of TarEntry's for this entry's children.\n+     */\n+    public TarArchiveEntry[] getDirectoryEntries() {\n+        if (file == null || !file.isDirectory()) {\n+            return new TarArchiveEntry[0];\n+        }\n+\n+        String[] list = file.list();\n+        TarArchiveEntry[] result = new TarArchiveEntry[list == null ? 0 : list.length];\n+\n+        for (int i = 0; i < result.length; ++i) {\n+            result[i] = new TarArchiveEntry(new File(file, list[i]));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     */\n+    public void writeEntryHeader(byte[] outbuf) {\n+        try {\n+            writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n+        } catch (IOException ex) {\n+            try {\n+                writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n+            } catch (IOException ex2) {\n+                // impossible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     * @param encoding encoding to use when writing the file name.\n+     * @param starMode whether to use the star/GNU tar/BSD tar\n+     * extension for numeric fields if their value doesn't fit in the\n+     * maximum size of standard tar archives\n+     * @since 1.4\n+     * @throws IOException on error\n+     */\n+    public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n+                                 boolean starMode) throws IOException {\n+        int offset = 0;\n+\n+        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n+                                          encoding);\n+        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n+        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n+        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n+                                       starMode);\n+\n+        int csOffset = offset;\n+\n+        for (int c = 0; c < CHKSUMLEN; ++c) {\n+            outbuf[offset++] = (byte) ' ';\n+        }\n+\n+        outbuf[offset++] = linkFlag;\n+        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n+                                          encoding);\n+        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n+        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n+        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n+                                          encoding);\n+        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n+                                          encoding);\n+        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n+                                       starMode);\n+\n+        while (offset < outbuf.length) {\n+            outbuf[offset++] = 0;\n+        }\n+\n+        long chk = TarUtils.computeCheckSum(outbuf);\n+\n+        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n+    }\n+\n+    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n+                                      int length, boolean starMode) {\n+        if (!starMode && (value < 0\n+                          || value >= 1l << 3 * (length - 1))) {\n+            // value doesn't fit into field when written as octal\n+            // number, will be written to PAX header or causes an\n+            // error\n+            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n+        }\n+        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n+                                                     length);\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     */\n+    public void parseTarHeader(byte[] header) {\n+        try {\n+            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n+        } catch (IOException ex) {\n+            try {\n+                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n+            } catch (IOException ex2) {\n+                // not really possible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     * @param encoding encoding to use for file names\n+     * @since 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields\n+     * have an invalid format\n+     * @throws IOException on error\n+     */\n+    public void parseTarHeader(byte[] header, ZipEncoding encoding)\n+        throws IOException {\n+        parseTarHeader(header, encoding, false);\n+    }\n+\n+    private void parseTarHeader(byte[] header, ZipEncoding encoding,\n+                                final boolean oldStyle)\n+        throws IOException {\n+        int offset = 0;\n+\n+        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n+        offset += NAMELEN;\n+        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n+        offset += MODELEN;\n+        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n+        offset += UIDLEN;\n+        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n+        offset += GIDLEN;\n+        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n+        offset += SIZELEN;\n+        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n+        offset += MODTIMELEN;\n+        checkSumOK = TarUtils.verifyCheckSum(header);\n+        offset += CHKSUMLEN;\n+        linkFlag = header[offset++];\n+        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n+        offset += NAMELEN;\n+        magic = TarUtils.parseName(header, offset, MAGICLEN);\n+        offset += MAGICLEN;\n+        version = TarUtils.parseName(header, offset, VERSIONLEN);\n+        offset += VERSIONLEN;\n+        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n+            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n+        offset += UNAMELEN;\n+        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n+            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n+        offset += GNAMELEN;\n+        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n+        offset += DEVLEN;\n+        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n+        offset += DEVLEN;\n+\n+        int type = evaluateType(header);\n+        switch (type) {\n+        case FORMAT_OLDGNU: {\n+            offset += ATIMELEN_GNU;\n+            offset += CTIMELEN_GNU;\n+            offset += OFFSETLEN_GNU;\n+            offset += LONGNAMESLEN_GNU;\n+            offset += PAD2LEN_GNU;\n+            offset += SPARSELEN_GNU;\n+            isExtended = TarUtils.parseBoolean(header, offset);\n+            offset += ISEXTENDEDLEN_GNU;\n+            realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\n+            offset += REALSIZELEN_GNU;\n+            break;\n+        }\n+        case FORMAT_POSIX:\n+        default: {\n+            String prefix = oldStyle\n+                ? TarUtils.parseName(header, offset, PREFIXLEN)\n+                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n+            // SunOS tar -E does not add / to directory names, so fix\n+            // up to be consistent\n+            if (isDirectory() && !name.endsWith(\"/\")){\n+                name = name + \"/\";\n+            }\n+            if (prefix.length() > 0){\n+                name = prefix + \"/\" + name;\n+            }\n+        }\n+        }\n+    }\n+\n+    /**\n+     * Strips Windows' drive letter as well as any leading slashes,\n+     * turns path separators into forward slahes.\n+     */\n+    private static String normalizeFileName(String fileName,\n+                                            boolean preserveLeadingSlashes) {\n+        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n+\n+        if (osname != null) {\n+\n+            // Strip off drive letters!\n+            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n+\n+            if (osname.startsWith(\"windows\")) {\n+                if (fileName.length() > 2) {\n+                    char ch1 = fileName.charAt(0);\n+                    char ch2 = fileName.charAt(1);\n+\n+                    if (ch2 == ':'\n+                        && (ch1 >= 'a' && ch1 <= 'z'\n+                            || ch1 >= 'A' && ch1 <= 'Z')) {\n+                        fileName = fileName.substring(2);\n+                    }\n+                }\n+            } else if (osname.contains(\"netware\")) {\n+                int colon = fileName.indexOf(':');\n+                if (colon != -1) {\n+                    fileName = fileName.substring(colon + 1);\n+                }\n+            }\n+        }\n+\n+        fileName = fileName.replace(File.separatorChar, '/');\n+\n+        // No absolute pathnames\n+        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n+        // so we loop on starting /'s.\n+        while (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\n+            fileName = fileName.substring(1);\n+        }\n+        return fileName;\n+    }\n+\n+    /**\n+     * Evaluate an entry's header format from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to evaluate the format for.\n+     * @return format type\n+     */\n+    private int evaluateType(byte[] header) {\n+        if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n+            return FORMAT_OLDGNU;\n+        }\n+        if (ArchiveUtils.matchAsciiBuffer(MAGIC_POSIX, header, MAGIC_OFFSET, MAGICLEN)) {\n+            return FORMAT_POSIX;\n+        }\n+        return 0;\n+    }\n+}\n+", "timestamp": 1449619394, "metainfo": ""}