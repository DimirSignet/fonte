{"sha": "b8939bea39a1a3dd379986ff2c6cf33a5535c499", "log": "whitespace", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n             return;\n         }\n \n-            int b = readOneByte();\n+        int b = readOneByte();\n+        if (b == -1) {\n+            throw new IOException(\"Premature end of stream reading block start\");\n+        }\n+        int length = 0;\n+        int offset = 0;\n+\n+        switch (b & TAG_MASK) {\n+\n+        case 0x00:\n+\n+            length = readLiteralLength(b);\n+            uncompressedBytesRemaining -= length;\n+            startLiteral(length);\n+            state = State.IN_LITERAL;\n+            break;\n+\n+        case 0x01:\n+\n+            /*\n+             * These elements can encode lengths between [4..11] bytes and\n+             * offsets between [0..2047] bytes. (len-4) occupies three bits\n+             * and is stored in bits [2..4] of the tag byte. The offset\n+             * occupies 11 bits, of which the upper three are stored in the\n+             * upper three bits ([5..7]) of the tag byte, and the lower\n+             * eight are stored in a byte following the tag byte.\n+             */\n+\n+            length = 4 + ((b >> 2) & 0x07);\n+            uncompressedBytesRemaining -= length;\n+            offset = (b & 0xE0) << 3;\n+            b = readOneByte();\n             if (b == -1) {\n-                throw new IOException(\"Premature end of stream reading block start\");\n-            }\n-            int length = 0;\n-            int offset = 0;\n-\n-            switch (b & TAG_MASK) {\n-\n-            case 0x00:\n-\n-                length = readLiteralLength(b);\n-                uncompressedBytesRemaining -= length;\n-                startLiteral(length);\n-                state = State.IN_LITERAL;\n-                break;\n-\n-            case 0x01:\n-\n-                /*\n-                 * These elements can encode lengths between [4..11] bytes and\n-                 * offsets between [0..2047] bytes. (len-4) occupies three bits\n-                 * and is stored in bits [2..4] of the tag byte. The offset\n-                 * occupies 11 bits, of which the upper three are stored in the\n-                 * upper three bits ([5..7]) of the tag byte, and the lower\n-                 * eight are stored in a byte following the tag byte.\n-                 */\n-\n-                length = 4 + ((b >> 2) & 0x07);\n-                uncompressedBytesRemaining -= length;\n-                offset = (b & 0xE0) << 3;\n-                b = readOneByte();\n-                if (b == -1) {\n-                    throw new IOException(\"Premature end of stream reading copy length\");\n-                }\n-                offset |= b;\n-\n-                startCopy(offset, length);\n-                state = State.IN_COPY;\n-                break;\n-\n-            case 0x02:\n-\n-                /*\n-                 * These elements can encode lengths between [1..64] and offsets\n-                 * from [0..65535]. (len-1) occupies six bits and is stored in\n-                 * the upper six bits ([2..7]) of the tag byte. The offset is\n-                 * stored as a little-endian 16-bit integer in the two bytes\n-                 * following the tag byte.\n-                 */\n-\n-                length = (b >> 2) + 1;\n-                uncompressedBytesRemaining -= length;\n-\n-                offset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n-\n-                startCopy(offset, length);\n-                state = State.IN_COPY;\n-                break;\n-\n-            case 0x03:\n-\n-                /*\n-                 * These are like the copies with 2-byte offsets (see previous\n-                 * subsection), except that the offset is stored as a 32-bit\n-                 * integer instead of a 16-bit integer (and thus will occupy\n-                 * four bytes).\n-                 */\n-\n-                length = (b >> 2) + 1;\n-                uncompressedBytesRemaining -= length;\n-\n-                offset = (int) ByteUtils.fromLittleEndian(supplier, 4) & 0x7fffffff;\n-\n-                startCopy(offset, length);\n-                state = State.IN_COPY;\n-                break;\n-            }\n+                throw new IOException(\"Premature end of stream reading copy length\");\n+            }\n+            offset |= b;\n+\n+            startCopy(offset, length);\n+            state = State.IN_COPY;\n+            break;\n+\n+        case 0x02:\n+\n+            /*\n+             * These elements can encode lengths between [1..64] and offsets\n+             * from [0..65535]. (len-1) occupies six bits and is stored in\n+             * the upper six bits ([2..7]) of the tag byte. The offset is\n+             * stored as a little-endian 16-bit integer in the two bytes\n+             * following the tag byte.\n+             */\n+\n+            length = (b >> 2) + 1;\n+            uncompressedBytesRemaining -= length;\n+\n+            offset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n+\n+            startCopy(offset, length);\n+            state = State.IN_COPY;\n+            break;\n+\n+        case 0x03:\n+\n+            /*\n+             * These are like the copies with 2-byte offsets (see previous\n+             * subsection), except that the offset is stored as a 32-bit\n+             * integer instead of a 16-bit integer (and thus will occupy\n+             * four bytes).\n+             */\n+\n+            length = (b >> 2) + 1;\n+            uncompressedBytesRemaining -= length;\n+\n+            offset = (int) ByteUtils.fromLittleEndian(supplier, 4) & 0x7fffffff;\n+\n+            startCopy(offset, length);\n+            state = State.IN_COPY;\n+            break;\n+        }\n     }\n \n     /*", "timestamp": 1484685954, "metainfo": ""}