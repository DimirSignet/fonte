{"sha": "be286da2b3ade34a747a7b650e7bb0d5d233f2c8", "log": "user STAR encoding for all numeric fields in tar headers if they don't fit in the 'normal' range.  COMPRESS-182  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      *\n      * @param outbuf The tar entry header buffer to fill in.\n      * @param starMode whether to use the star/GNU tar/BSD tar\n-     * extension for the size field if the size is bigger than 8GiB\n+     * extension for numeric fields if their value doesn't fit in the\n+     * maximum size of standard tar archives\n      * @since Apache Commons Compress 1.4\n      */\n     public void writeEntryHeader(byte[] outbuf, boolean starMode) {\n         int offset = 0;\n \n         offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\n-        offset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\n-        offset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\n-        offset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\n-        if (size > TarConstants.MAXSIZE && !starMode) {\n-            // size is in PAX header\n-            offset = TarUtils.formatLongOctalBytes(0, outbuf, offset, SIZELEN);\n-        } else {\n-            offset = TarUtils.formatLongOctalOrBinaryBytes(size, outbuf, offset, SIZELEN);\n-        }\n-        offset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n+        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n+        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n+        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n+                                       starMode);\n \n         int csOffset = offset;\n \n         offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n         offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\n         offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\n-        offset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\n-        offset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\n+        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n+                                       starMode);\n+        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n+                                       starMode);\n \n         while (offset < outbuf.length) {\n             outbuf[offset++] = 0;\n         long chk = TarUtils.computeCheckSum(outbuf);\n \n         TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n+    }\n+\n+    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n+                                      int length, boolean starMode) {\n+        if (!starMode && (value < 0\n+                          || value >= (1l << (3 * (length - 1))))) {\n+            // value doesn't fit into field when written as octal\n+            // number, will be written to PAX header or causes an\n+            // error\n+            return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\n+        }\n+        return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset,\n+                                                     length);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n \n     @Test\n     public void datePriorToEpochInGNUFormat() throws Exception {\n-        datePriorToEpoch(\"/preepoch-gnu.tar\");\n+        datePriorToEpoch(\"/preepoch-star.tar\");\n     }\n \n \n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.util.Calendar;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.TimeZone;\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n         TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n     }\n+\n+    public void testOldEntryStarMode() throws Exception {\n+        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        t.setSize(Integer.MAX_VALUE);\n+        t.setModTime(-1000);\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        tos.setBigFileMode(TarArchiveOutputStream.BIGFILE_STAR);\n+        tos.putArchiveEntry(t);\n+        // make sure header is written to byte array\n+        tos.write(new byte[10 * 1024]);\n+        byte[] data = bos.toByteArray();\n+        assertEquals((byte) 0xff,\n+                     data[TarConstants.NAMELEN\n+                          + TarConstants.MODELEN\n+                          + TarConstants.UIDLEN\n+                          + TarConstants.GIDLEN\n+                          + TarConstants.SIZELEN]);\n+        TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        TarArchiveEntry e = tin.getNextTarEntry();\n+        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        cal.set(1969, 11, 31, 23, 59, 59);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        assertEquals(cal.getTime(), e.getLastModifiedDate());\n+    }\n+\n }", "timestamp": 1330976052, "metainfo": ""}