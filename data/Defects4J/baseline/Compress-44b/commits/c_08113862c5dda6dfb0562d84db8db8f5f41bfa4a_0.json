{"sha": "08113862c5dda6dfb0562d84db8db8f5f41bfa4a", "log": "reduce GC pressure by avoiding File(In|Out)putStreams", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n  * Compressing a ZIP-File:\n  * \n  * <pre>\n- * final OutputStream out = new FileOutputStream(output); \n+ * final OutputStream out = Files.newOutputStream(output.toPath());\n  * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n- * \n+ *\n  * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n- * IOUtils.copy(new FileInputStream(file1), os);\n+ * IOUtils.copy(Files.newInputStream(file1.toPath()), os);\n  * os.closeArchiveEntry();\n  *\n  * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n- * IOUtils.copy(new FileInputStream(file2), os);\n+ * IOUtils.copy(Files.newInputStream(file2.toPath()), os);\n  * os.closeArchiveEntry();\n  * os.close();\n  * </pre>\n- * \n+ *\n  * Decompressing a ZIP-File:\n- * \n+ *\n  * <pre>\n- * final InputStream is = new FileInputStream(input); \n+ * final InputStream is = Files.newInputStream(input.toPath());\n  * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n  * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n- * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n+ * OutputStream out = Files.newOutputStream(dir.toPath().resolve(entry.getName()));\n  * IOUtils.copy(in, out);\n  * out.close();\n  * in.close();\n     private static final int SIGNATURE_SIZE = 12;\n \n     private static final ArchiveStreamFactory SINGLETON = new ArchiveStreamFactory();\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the AR archive format.\n      * @since 1.1\n      */\n     public static final String AR = \"ar\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the ARJ archive format.\n      * Not supported as an output stream type.\n      * @since 1.6\n      */\n     public static final String ARJ = \"arj\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the CPIO archive format.\n      * @since 1.1\n      */\n     public static final String CPIO = \"cpio\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the Unix DUMP archive format.\n      * Not supported as an output stream type.\n      * @since 1.3\n      */\n     public static final String DUMP = \"dump\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the JAR archive format.\n      * @since 1.1\n      */\n     public static final String JAR = \"jar\";\n-    \n+\n     /**\n      * Constant used to identify the TAR archive format.\n      * @since 1.1\n      */\n     public static final String TAR = \"tar\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the ZIP archive format.\n      * @since 1.1\n      */\n     public static final String ZIP = \"zip\";\n-    \n+\n     /**\n      * Constant (value {@value}) used to identify the 7z archive format.\n      * @since 1.8\n             map.put(toKey(name), provider);\n         }\n     }\n-    \n+\n     private static Iterator<ArchiveStreamProvider> serviceLoaderIterator() {\n         return new ServiceLoaderIterator<>(ArchiveStreamProvider.class);\n     }\n \n     /**\n      * Sets the encoding to use for arj, jar, zip, dump, cpio and tar files. Use null for the archiver default.\n-     * \n+     *\n      * @param entryEncoding the entry encoding, null uses the archiver default.\n      * @since 1.5\n      * @deprecated 1.10 use {@link #ArchiveStreamFactory(String)} to specify the encoding\n-     * @throws IllegalStateException if the constructor {@link #ArchiveStreamFactory(String)} \n+     * @throws IllegalStateException if the constructor {@link #ArchiveStreamFactory(String)}\n      * was used to specify the factory encoding.\n      */\n     @Deprecated\n \n     /**\n      * Creates an archive input stream from an archiver name and an input stream.\n-     * \n+     *\n      * @param archiverName the archive name,\n      * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}\n      * @param in the input stream\n             throws ArchiveException {\n         return createArchiveInputStream(archiverName, in, entryEncoding);\n     }\n-    \n+\n     @Override\n     public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in,\n             final String actualEncoding) throws ArchiveException {\n \n     /**\n      * Creates an archive output stream from an archiver name and an output stream.\n-     * \n+     *\n      * @param archiverName the archive name,\n-     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n+     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO}\n      * @param out the output stream\n      * @return the archive output stream\n      * @throws ArchiveException if the archiver name is not known\n             throws ArchiveException {\n         return createArchiveOutputStream(archiverName, out, entryEncoding);\n     }\n-    \n+\n     @Override\n     public ArchiveOutputStream createArchiveOutputStream(\n             final String archiverName, final OutputStream out, final String actualEncoding)\n      * Create an archive input stream from an input stream, autodetecting\n      * the archive type from the first few bytes of the stream. The InputStream\n      * must support marks, like BufferedInputStream.\n-     * \n+     *\n      * @param in the input stream\n      * @return the archive input stream\n      * @throws ArchiveException if the archiver name is not known\n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n \n import java.io.BufferedInputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n+import java.nio.file.Files;\n \n /**\n  * Simple command line application that lists the contents of an archive.\n         if (!f.isFile()) {\n             System.err.println(f + \" doesn't exist or is a directory\");\n         }\n-        try (final InputStream fis = new BufferedInputStream(new FileInputStream(f));\n+        try (final InputStream fis = new BufferedInputStream(Files.newInputStream(f.toPath()));\n                 final ArchiveInputStream ais = createArchiveInputStream(args, fis)) {\n             System.out.println(\"Created \" + ais.toString());\n             ArchiveEntry ae;\n         System.out.println(\"Parameters: archive-name [archive-type]\");\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n  * </p>\n  * <pre>\n  * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(\n- *         new FileInputStream(new File(&quot;test.cpio&quot;)));\n+ *         Files.newInputStream(Paths.get(&quot;test.cpio&quot;)));\n  * CPIOArchiveEntry cpioEntry;\n  *\n  * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n  * Example (Compressing a file):\n  * \n  * <pre>\n- * final OutputStream out = new FileOutputStream(output);\n+ * final OutputStream out = Files.newOutputStream(output.toPath());\n  * CompressorOutputStream cos = new CompressorStreamFactory()\n  *         .createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n- * IOUtils.copy(new FileInputStream(input), cos);\n+ * IOUtils.copy(Files.newInputStream(input.toPath()), cos);\n  * cos.close();\n  * </pre>\n  * \n  * Example (Decompressing a file):\n  * \n  * <pre>\n- * final InputStream is = new FileInputStream(input);\n+ * final InputStream is = Files.newInputStream(input.toPath());\n  * CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(CompressorStreamFactory.BZIP2,\n  *         is);\n- * IOUtils.copy(in, new FileOutputStream(output));\n+ * IOUtils.copy(in, Files.newOutputStream(output.toPath()));\n  * in.close();\n  * </pre>\n  * \n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/TempFileCachingStreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/TempFileCachingStreamBridge.java\n package org.apache.commons.compress.compressors.pack200;\n \n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n+import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.file.Files;\n \n /**\n  * StreamSwitcher that caches all data written to the output side in\n     TempFileCachingStreamBridge() throws IOException {\n         f = File.createTempFile(\"commons-compress\", \"packtemp\");\n         f.deleteOnExit();\n-        out = new FileOutputStream(f);\n+        out = Files.newOutputStream(f.toPath());\n     }\n \n     @Override\n     InputStream getInputView() throws IOException {\n         out.close();\n-        return new FileInputStream(f) {\n+        return new FilterInputStream(Files.newInputStream(f.toPath())) {\n             @Override\n             public void close() throws IOException {\n                 super.close();\n--- a/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n \n import java.io.File;\n import java.io.FileNotFoundException;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n \n /**\n  * ScatterGatherBackingStore that is backed by a file.\n  */\n public class FileBasedScatterGatherBackingStore implements ScatterGatherBackingStore {\n     private final File target;\n-    private final FileOutputStream os;\n+    private final OutputStream os;\n     private boolean closed;\n \n     public FileBasedScatterGatherBackingStore(final File target) throws FileNotFoundException {\n         this.target = target;\n-        os = new FileOutputStream(target);\n+        try {\n+            os = Files.newOutputStream(target.toPath());\n+        } catch (FileNotFoundException ex) {\n+            throw ex;\n+        } catch (IOException ex) {\n+            // must convert exception to stay backwards compatible with Compress 1.10 to 1.13\n+            throw new RuntimeException(ex);\n+        }\n     }\n \n     @Override\n     public InputStream getInputStream() throws IOException {\n-        return new FileInputStream(target);\n+        return Files.newInputStream(target.toPath());\n     }\n \n     @Override", "timestamp": 1491914792, "metainfo": ""}