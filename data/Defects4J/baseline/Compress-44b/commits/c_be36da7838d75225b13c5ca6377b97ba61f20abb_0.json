{"sha": "be36da7838d75225b13c5ca6377b97ba61f20abb", "log": "forgot a few files to add: draft 8 from C. Grobmeier, grant has been received, cheers  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/AbstractCompressor.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+/**\n+ * AbstractCompressor handles all compression/decompression \n+ * actions on an abstract basis. \n+ */\n+public abstract class AbstractCompressor \n+\textends PackableObject \n+\timplements Compressor {\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic AbstractCompressor() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Returns a String with the default file extension\n+\t * for this compressor. For example, a zip-files default\n+\t * file extension would be \"zip\" (without leading dot).\n+\t *  \n+\t * @return the default file extension\n+\t */\n+\tpublic abstract String getDefaultFileExtension();\n+\t\n+    \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#compressStream(java.io.FileInputStream)\n+\t */\n+\tpublic InputStream compress(FileInputStream input) throws CompressException {\n+\t\tFileOutputStream outputStream = null;\n+\t\tFileOutputStream tempFileOutputStream = null;\n+\t\ttry {\n+\t\t\tFile temp = File.createTempFile(\"commons_\",\"jkt\");;\n+\t\t\ttempFileOutputStream = new FileOutputStream(temp);\n+\t\t\tcompressTo(input, tempFileOutputStream);\n+\t\t\treturn new FileInputStream(temp);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new CompressException(\"An IO Exception has occured\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\ttempFileOutputStream.close();\n+\t\t\t\toutputStream.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new CompressException(\"An IO Exception occured while closing the streams\", e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#compress(java.io.File, java.io.File)\n+\t */\n+\tpublic void compressTo(File input, File output) throws CompressException {\n+\t\tFileOutputStream outputStream = null;\n+\t\tFileInputStream inputStream = null;\n+\t\ttry {\n+\t\t\toutputStream = new FileOutputStream( output );\n+\t\t\tinputStream = new FileInputStream( input );\n+\t\t\tthis.compressTo(inputStream, outputStream);\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new CompressException(\"File not found\" ,e);\n+\t\t} \n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#compress(java.io.File)\n+\t */\n+\tpublic void compressToHere(File input) throws CompressException {\n+\t\tString pathToFile = input.getAbsolutePath().concat(\".\").concat(getDefaultFileExtension());\n+\t\tFile output = new File(pathToFile);\n+\t\tthis.compressTo(input, output);\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#compressStream(java.io.File)\n+\t */\n+\tpublic InputStream compress(File input) throws CompressException {\n+\t\ttry {\n+\t\t\treturn this.compress(\n+\t\t\t\tnew FileInputStream(input));\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new CompressException(\"File could not be found.\",e);\n+\t\t}\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Decompressor#decompress(java.io.File)\n+\t */\n+\tpublic InputStream decompress(File input) throws CompressException {\n+\t\tFile temp;\n+\t\tInputStream result;\n+\t\ttry {\n+\t\t\ttemp = File.createTempFile(\"compress_\", \"jkt\");\n+\t\t\tthis.decompressTo(input, temp);\n+\t\t\tresult = new FileInputStream(temp);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new CompressException(\"Error while creating a temporary file\", e);\n+\t\t} \n+\t\treturn result; \n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Decompressor#decompress(java.io.FileInputStream)\n+\t */\n+\tpublic InputStream decompress(FileInputStream input) \n+\t\tthrows CompressException {\n+\t\tFile temp;\n+\t\tInputStream result;\n+\t\ttry {\n+\t\t\ttemp = File.createTempFile(\"compress_\", \"jkt\");\n+\t\t\tthis.decompressTo(input, new FileOutputStream(temp));\n+\t\t\tresult = new FileInputStream(temp);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new CompressException(\"Error while creating a temporary file\", e);\n+\t\t} \n+\t\treturn result;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#decompress(java.io.File, java.io.File)\n+\t */\n+\tpublic void decompressTo(File input, File output) \n+\t\tthrows CompressException {\n+\t\tFileInputStream inputStream = null;\n+\t\tFileOutputStream outputStream = null;\n+\t\ttry {\n+\t\t\toutputStream = new FileOutputStream( output );\n+\t\t\tinputStream = new FileInputStream( input );\n+\t\t\tdecompressTo(inputStream, outputStream);\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new CompressException(\"File could not be found\", e);\n+\t\t} finally {\n+\t      \ttry {\n+\t\t\t\tinputStream.close();\n+\t\t\t\toutputStream.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new CompressException(\"An I/O Exception has occured while closing a stream\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/Archive.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+/**\n+ * Archive is the interface which defines all operations \n+ * for all possible archive-operations.\n+ * \n+ * TODO:\n+ * - delete files from an archive\n+ * - add files to an existing archive\n+ * - recursivley add directories\n+ */\n+public interface Archive {\n+\t/**\n+\t * Adds a file to the internal filelist \n+\t * for a possible pack-operation\n+\t */\n+\tpublic void add(File file) throws FileNotFoundException;\n+\t\n+\t/**\n+\t * Adds a FileInputStream to the internal filelist \n+\t * for a possible pack-operation\n+\t */\n+\tpublic void add(ArchiveEntry entry);\n+\t\n+\t/**\n+\t * Packs a file. \n+\t * The destination filename must be set manually with setDestinationFile(...).\n+\t * There must be at least 1 file to be packed.\n+\t * \n+\t * @throws ArchiveException if there is no destination file or files to be packed\n+\t * @return true, if the operation has been ended without exceptions\n+\t */\n+\tpublic void save(FileOutputStream output) throws ArchiveException;\n+\n+\t/**\n+\t * Packs this file. \n+\t * This methods ignores what has been set in setDestinationFile(...) and\n+\t * uses the filename of the parameter. This string must not be null.\n+\t * \n+\t * @throws ArchiveException if there is no destination file or files to be packed\n+\t */\n+\tpublic void save(File output) throws ArchiveException;\n+\n+\t/**\n+\t * Sets an Archive for manipulating. An archive is set if someone\n+\t * saves an Archive or calls getInstance(...) with an archive.\n+\t * @param archive file to manipulate\n+\t */\n+\tvoid setArchive(File file);\n+\t\n+\t/**\n+\t * Returns the archive file and null,\n+\t * if this archiver has not been saved yet or\n+\t * there has not been set an archive manually.\n+\t * @return the archiver, or null\n+\t */\n+\tpublic File getArchive();\n+\n+\t/**\n+\t * Unpacks to the specified directory \n+\t * @param dir to unpack\n+\t * @throws UnpackException if an unpack error occurs\n+\t */\n+\tpublic void unpack(File destinationDir) throws UnpackException;\n+\t\n+\t/**\n+\t * Get an iterator of ArchiveEntrys which shall be archived\n+\t * @return the iterator\n+\t */\n+\tpublic Iterator getEntryIterator();\n+\t\n+\t/**\n+\t * Closes this archiver and all internal streams. \n+\t */\n+\tpublic void close() throws IOException ;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/ArchiverFactory.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.compress.archivers.tar.TarArchive;\n+import org.apache.commons.compress.archivers.zip.ZipArchive;\n+/**\n+ * Provides implementations for all ArchiverFactory methods.\n+ */\n+public class ArchiverFactory {\n+\t/* internal archiver list */\n+\tprivate static List archives;\n+\t\n+\t// pre-register archives \n+\tstatic {\n+\t\tarchives = new ArrayList();\n+\t\ttry {\n+\t\t\tregisterArchiver(TarArchive.class);\n+\t\t\tregisterArchiver(ZipArchive.class);\n+\t\t} catch (ArchiveException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Constructor.\n+\t * @param name name of the implementation\n+\t */\n+\tprivate ArchiverFactory() { \n+\t}\n+\n+\t/**\n+\t * Registers a new archiver in the factory.\n+\t * The archiver must implement the archiver interface.\n+\t * \n+\t * @param className full qualified archiver implementation\n+\t * @throws ClassNotFoundException if the new archiver class could not be found\n+\t * @throws ArchiveException if the new archiver does not implement the archiver interface\n+\t */\n+\tpublic static void registerArchiver(String className) \n+\t\tthrows ClassNotFoundException, ArchiveException {\n+\t\tClass clazz = Class.forName(className);\n+\t\tregisterArchiver(clazz);\n+\t}\n+\t\n+\t/**\n+\t * Registers a new archiver in the factory.\n+\t * The archiver must implement the archiver interface and must\n+\t * be an concrete implementation\n+\t * \n+\t * @param className full qualified archiver implementation\n+\t * @throws ArchiveException if the new archiver does not implement the archiver interface\n+\t */\n+\tpublic static void registerArchiver(Class clazz) \n+\t\tthrows ArchiveException {\n+\t\t// register only, if the class is assignable and not an interface\n+\t\tif(Archive.class.isAssignableFrom(clazz) && !(clazz.isInterface())) {\n+\t\t\ttry {\n+\t\t\t\tarchives.add(clazz.newInstance());\n+\t\t\t} catch (InstantiationException e) {\n+\t\t\t\tthrow new ArchiveException(\"Archive could not be instantiated\", e);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tthrow new ArchiveException(\"Archive could not be instantiated\", e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthrow new ArchiveException(\"Archive does not implement the Archive.class interface.\");\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns an empty Archive, if an archiver could be found for this factory.\n+\t * If two Archive-implementations with the same name are registered,\n+\t * the first matching archiver will be instanciated.\n+\t * \n+\t * @return the archiver, or null, if no matching archiver could be found\n+\t * @throws ArchiveException if the archiver could not be created\n+\t */\n+\tpublic static Archive getInstance(String archiverName) \n+\t\tthrows ArchiveException {\n+\t\ttry {\n+\t\t\tif(archiverName == null) {\n+\t\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\");\n+\t\t\t}\n+\t\t\tIterator it = archives.iterator();\n+\t\t\twhile(it.hasNext()) {\n+\t\t\t\tPackableObject po = (PackableObject)it.next();\n+\t\t\t\tif(po.isPackableWith(archiverName, PackableObject.CHOOSE_NAME)) {\n+\t\t\t\t\treturn (Archive)po.getClass().newInstance();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (InstantiationException e) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns an archiver, filled with an existing archive.\n+\t * Uses the byte header to identify the archiver. If no corresponding\n+\t * archiver could be found, a filename extension check will be done.\n+\t * @param archivedFile an existing archive\n+\t * @return an archiver, filled with the archive\n+\t */\n+\tpublic static Archive getInstance(File file) \n+\t\tthrows ArchiveException {\n+\t\tif(file == null && !file.isFile()) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance for this file\");\n+\t\t}\n+\t\t\n+\t\t\n+\t\t/* Archive result */\n+\t\tPackableObject packable = null; \n+\t\t\n+\t\ttry {\n+\t\t\tpackable = PackableObject.identifyByHeader(file, archives);\n+\t\t\t\n+\t\t\tif(packable == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tArchive archive = (Archive)packable.getClass().newInstance();\n+\t\t\tarchive.setArchive(file);\n+\t\t\treturn archive;\n+\t\t} catch (SecurityException e) {\n+\t\t\tthrow new ArchiveException(\"A security violation occured while reading the field ARCHIVER_NAME\", e);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tthrow new ArchiveException(\"Internal factory exception\", e);\n+\t\t} catch (InstantiationException e) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n+\t\t} catch (PackableObjectException e) {\n+\t\t\tthrow new ArchiveException(\"ArchiverFactory could not create instance\", e);\n+\t\t} \n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/CompressException.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+/**\n+ * Exception occurs when a exception within \n+ * the compress actions occurs.\n+ */\n+public class CompressException extends PackableObjectException {\n+\t/**\n+\t * Comment for <code>serialVersionUID</code>\n+\t */\n+\tprivate static final long serialVersionUID = 3257005449554507057L;\n+\n+\t/**\n+\t * Calls the IOException constructor\n+\t */\n+\tpublic CompressException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Calls the IOException constructor with a message\n+\t * @param message the message\n+\t */\n+\tpublic CompressException(String message) {\n+\t\tsuper(message);\n+\t}\n+\t\n+\t/**\n+\t * Calls the IOException constructor with a message\n+\t * and fills the stacktrace with the stacktrace of \n+\t * an exception\n+\t * \n+\t * @param message the message\n+\t * @param e the exception \n+\t */\n+\tpublic CompressException(String message, Exception e) {\n+\t\tsuper(message);\n+\t\tthis.initCause(e);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/CompressUtils.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Utils for Compress.\n+ */\n+public class CompressUtils {\n+\t/*\n+\t * This class should not be constructed\n+\t */\n+\tprivate CompressUtils() {\n+\t\t// unused\n+\t}\n+\t\n+\t/**\n+     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.\n+     */\n+    public static void copy( final InputStream input,\n+                              final OutputStream output )\n+        throws IOException {\n+        final byte[] buffer = new byte[ 8024 ];\n+        int n = 0;\n+        while( -1 != ( n = input.read( buffer ) ) ) {\n+            output.write( buffer, 0, n );\n+        }\n+    }\n+    \n+    /**\n+     * Compares one byte array to another\n+\t * @param source- the array to compare to \n+\t * @param headerBytes - the bytearray match\n+\t */\n+\tpublic static boolean compareByteArrays(byte[] source, byte[] match) {\n+\t\tint i = 0;\n+\t\twhile(source.length < i || i < match.length ) {\n+\t\t\tif(source[i] != match[i]) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\t\treturn true;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/Compressor.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+/**\n+ * The Compressor Interface defines all operations for \n+ * the compress/decompress actions.\n+ */\n+public interface Compressor {\n+\t/**\n+\t * Compresses this file and returns an \n+\t * InputStream to the compressed File\n+\t * \n+\t * @param input File to compress\n+\t * @return FileInputStream of the compressed file\n+\t * @throws CompressException if the Compressor reports an error\n+\t */\n+\tpublic InputStream compress(File input) \n+\t\tthrows CompressException;\n+\t\n+\t/**\n+\t * Compresses this InputStream and returns an \n+\t * InputStream to the compressed file\n+\t * \n+\t * @param input Stream to compress\n+\t * @return Stream to the compressed file\n+\t * @throws CompressException if the Compressor reports an error\n+\t */\n+\tpublic InputStream compress(FileInputStream input) \n+\t\tthrows CompressException;\n+\n+\t/**\n+\t * Compresses the file input and creates a file in the same\n+\t * directory with the default file extension in its name.\n+\t * \n+\t * @param input the file to compress\n+\t * @throws CompressException if the Compressor reports an error\n+\t */\n+\tpublic void compressToHere(File input) \n+\t\tthrows CompressException;\n+\n+\t/**\n+\t * Creates the file \"output\" with the compressed\n+\t * content of file \"input\"\n+\t * \n+\t * @param input the file to compress\n+\t * @param output the file to create\n+\t * @throws CompressException if the Compressor reports an error\n+\t */\n+\tpublic void compressTo(File input, File output) \n+\t\tthrows CompressException;\n+\t\n+\t/**\n+\t * Compresses the input stream and writes the compressed\n+\t * bytes to the output stream. This method must be implemented\n+\t * by all new compressortypes.\n+\t * \n+\t * @param input InputStream to compress to\n+\t * @param output OutputStream to which the byte shall be written\n+\t * @throws CompressException if the Compressor reports an error\n+\t */\n+\tpublic void compressTo(FileInputStream input, FileOutputStream output) \n+\t\tthrows CompressException;\n+\t\n+\t/**\n+\t * Decompresses a file and returns an InputStream\n+\t * @param input file to decompress\n+\t * @return the decompressed file as an inputstream\n+\t */\n+\tpublic InputStream decompress(File input) \n+\t\tthrows CompressException;\n+\t\n+\t/**\n+\t * Decompresses a file and returns an InputStream\n+\t * @param input inputstream to decompress\n+\t * @return the decompressed InputStream\n+\t */\n+\tpublic InputStream decompress(FileInputStream inputStream) \n+\t\tthrows CompressException;;\n+\t\n+\t/**\n+\t * Decompresses this file and writes the decompressed byte to the output file\n+\t * @param input File to decompress\n+\t * @param output File to write the decompressed bytes to\n+\t * @throws DecompressException if the Compressor reports an error\n+\t */\n+\tpublic void decompressTo(File input, File output) \n+\t\tthrows CompressException;\n+\t\n+\t/**\n+\t * Decompresses this file and writes the decompressed file to the output-stream\n+\t * @param input Stream to decompress\n+\t * @param output Stream to write the decompressed bytes to\n+\t * @throws DecompressException if the Compressor reports an error\n+\t */\n+\tpublic void decompressTo(FileInputStream input, FileOutputStream output) \n+\t\tthrows CompressException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/CompressorFactory.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.compress.compressors.bzip2.BZip2Compressor;\n+/**\n+ * Compressor-Factory. \n+ * Use CompressorFactory.TYPE.getInstance() for an new Compressor-Instance.\n+ */\n+public abstract class CompressorFactory {\n+\t/* Name of this CompressorFactory*/\n+\tprivate final String name;\n+\t/* internal archiver list */\n+\tprivate static List compressors;\n+\t\n+\t// register compressors \n+\tstatic {\n+\t\tcompressors = new ArrayList();\n+\t\ttry {\n+\t\t\tregisterCompressor(BZip2Compressor.class);\n+\t\t} catch (CompressException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Registers a new archiver in the factory.\n+\t * The archiver must implement the archiver interface.\n+\t * \n+\t * @param className full qualified archiver implementation\n+\t * @throws ClassNotFoundException if the new archiver class could not be found\n+\t * @throws ArchiveException if the new archiver does not implement the archiver interface\n+\t */\n+\tpublic static void registerCompressor(String className) \n+\t\tthrows ClassNotFoundException, CompressException {\n+\t\tClass clazz = Class.forName(className);\n+\t\tregisterCompressor(clazz);\n+\t}\n+\t\n+\t/**\n+\t * Registers a new archiver in the factory.\n+\t * The archiver must implement the archiver interface and must\n+\t * be an concrete implementation\n+\t * \n+\t * @param className full qualified archiver implementation\n+\t * @throws ArchiveException if the new archiver does not implement the archiver interface\n+\t */\n+\tpublic static void registerCompressor(Class clazz) \n+\t\tthrows CompressException {\n+\t\t// register only, if the class is assignable and not an interface\n+\t\tif(Compressor.class.isAssignableFrom(clazz) && !(clazz.isInterface())) {\n+\t\t\ttry {\n+\t\t\t\tcompressors.add(clazz.newInstance());\n+\t\t\t} catch (InstantiationException e) {\n+\t\t\t\tthrow new CompressException(\"Compressor could not be instantiated\", e);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tthrow new CompressException(\"Compressor could not be instantiated\", e);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthrow new CompressException(\"Compressor does not implement the Compressor.class interface.\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Constructor. Takes the name of the implementation.\n+\t * @param _name - name of the implementation\n+\t */\n+\tprivate CompressorFactory(String name) { \n+\t\tthis.name = name; \n+\t}\n+\n+\t/**\n+\t * Returns a compressor\n+\t * @return the compressor\n+\t */\n+\tpublic abstract Compressor getInstance();\n+\n+\t/**\n+\t * Returns an empty Compressor, if an matching compressor \n+\t * could be found within this factory.\n+\t * If two implementations with the same name are registered,\n+\t * the first matching implementation will be instanciated.\n+\t * \n+\t * @return the compressor, or null, if no matching compressor could be found\n+\t * @throws CompressorException if the compressor could not be created\n+\t */\n+\tpublic static Compressor getInstance(String compressorName) \n+\t\tthrows CompressException {\n+\t\ttry {\n+\t\t\tif(compressorName == null) {\n+\t\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\");\n+\t\t\t}\n+\t\t\tIterator it = compressors.iterator();\n+\t\t\twhile(it.hasNext()) {\n+\t\t\t\tPackableObject po = (PackableObject)it.next();\n+\t\t\t\tif(po.isPackableWith(compressorName, PackableObject.CHOOSE_NAME)) {\n+\t\t\t\t\treturn (Compressor)po.getClass().newInstance();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (InstantiationException e) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns an archiver, filled with an existing archive.\n+\t * Uses the byte header to identify the archiver. If no corresponding\n+\t * archiver could be found, a filename extension check will be done.\n+\t * @param archivedFile an existing archive\n+\t * @return an archiver, filled with the archive\n+\t */\n+\tpublic static Compressor getInstance(File file) \n+\t\tthrows CompressException {\n+\t\tif(file == null && !file.isFile()) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance for this file\");\n+\t\t}\n+\t\t\n+\t\t\n+\t\t/* Archive result */\n+\t\tPackableObject packable = null; \n+\t\t\n+\t\ttry {\n+\t\t\tpackable = PackableObject.identifyByHeader(file, compressors);\n+\t\t\t\n+\t\t\tif(packable == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tCompressor compressor = (Compressor)packable.getClass().newInstance();\n+\t\t\treturn compressor;\n+\t\t} catch (SecurityException e) {\n+\t\t\tthrow new CompressException(\"A security violation occured while reading the field ARCHIVER_NAME\", e);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tthrow new CompressException(\"Internal factory exception\", e);\n+\t\t} catch (InstantiationException e) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n+\t\t} catch (PackableObjectException e) {\n+\t\t\tthrow new CompressException(\"CompressorFactory could not create instance\", e);\n+\t\t} \n+\t}\n+\t/**\n+\t * <code>BZIP2</code> Compressor Factory\n+\t */\n+\tpublic static CompressorFactory BZIP2 = new CompressorFactory(\"BZIP2\") {\n+\t\t/* (non-Javadoc)\n+\t\t * @see org.apache.commons.compress.ArchiverFactory#getInstance()\n+\t\t */\n+\t\tpublic Compressor getInstance() { \n+\t\t\treturn new BZip2Compressor(); \n+\t\t}\n+\t};\n+\t\n+\t/* (non-Javadoc)\n+\t * @see java.lang.Object#toString()\n+\t */\n+\tpublic String toString() { \n+\t\treturn name; \n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/PackableObject.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+/**\n+ * Abstract super object for Compressor and Archiver classes.\n+ */\n+public abstract class PackableObject {\n+\t/* Type for archive choosing: String */\n+\tprotected static final int CHOOSE_EXTENSION = 1;\n+\t/* Type for archive choosing: Long */\n+\tprotected static final int CHOOSE_NAME = 2;\n+\n+\t/** \n+\t * Header byte array for this archive. \n+\t */\n+\tpublic abstract byte[] getHeader();\n+\n+\t/** \n+\t * Returns the default FileExtension for this archive,\n+\t * for example \"zip\", \"tar\"... \n+\t */\n+\tpublic abstract String getDefaultFileExtension();\n+\t\n+\t/** \n+\t * Returns the ArchiveName for this archive.  \n+\t */\n+\tpublic abstract String getName();\n+\n+\t/**\n+\t * String Chooser.\n+\t * @param value\n+\t * @param methodName\n+\t * @return\n+\t * @throws ArchiveException\n+\t * @throws FileNotFoundException \n+\t */\n+\tprotected boolean isPackableWith(Object value, int choose) {\n+\t\tif(value == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif(choose == CHOOSE_EXTENSION) {\n+\t\t\tif(value.equals( getDefaultFileExtension())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else if (choose == CHOOSE_NAME) {\n+\t\t\tif(value.equals( getName())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\t/**\n+\t * Compares a file to a list of packables and identifies an object by header.\n+\t * If no matching header is found, it identifies the file by file extension. \n+\t * If identification was not successfull, null is returned\n+\t * \n+\t * @param file the file to identify\n+\t * @param packables a list of packables\n+\t * @return a matching packable object, or null\n+\t * @throws ArchiveException\n+\t */\n+\tpublic static PackableObject identifyByHeader(File file, List packables) \n+\t\tthrows PackableObjectException {\n+\t\t/* FileInputStream for the archive */\n+\t\tFileInputStream fis = null;\n+\t\t\n+\t\ttry {\n+\t\t\t/* Archive result */\n+\t\t\tPackableObject packable = null; \n+\t\t\t\n+\t//\t\t identify archive by header\n+\t\t\tfis = new FileInputStream(file);\n+\t\t\tbyte[] headerBytes = new byte[20];\n+\t\t\tfis.read(headerBytes, 0, 20);\n+\t\t\t\n+\t\t\tIterator iter = packables.iterator();\n+\t\t\twhile(iter.hasNext()) {\n+\t\t\t\tPackableObject p = (PackableObject)iter.next();\n+\t\t\t\tbyte[] fieldHeader = p.getHeader();\n+\t\t\t\tif(fieldHeader != null) {\n+\t\t\t\t\tif(CompressUtils.compareByteArrays(headerBytes, fieldHeader)) {\n+\t\t\t\t\t\treturn p;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// if we couldn't find an archiver by header bytes, we'll give it a try\n+\t\t\t// with the default name extension. This is useful, cause some archives \n+\t\t\t// like tar have no header.\n+\t\t\tString name = file.getName();\n+\t\t\tString extension = null;\n+\t\t\tString[] s = name.split(\"\\\\.\");\n+\t\t\tif(s.length > 1) {\n+\t\t\t\textension = s[ s.length - 1];\n+\t\t\t}\n+\t\t\tIterator it = packables.iterator();\n+\t\t\twhile(it.hasNext()) {\n+\t\t\t\tPackableObject p = (PackableObject)it.next();\n+\t\t\t\tif(p.isPackableWith(extension, PackableObject.CHOOSE_EXTENSION)) {\n+\t\t\t\t\treturn p;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// No implementation found\n+\t\t\treturn null;\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new PackableObjectException(\"File not found\", e);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new PackableObjectException(\"Internal factory exception\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tfis.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new PackableObjectException(\"Error while closing InputStream to file\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+}", "timestamp": 1154493926, "metainfo": ""}