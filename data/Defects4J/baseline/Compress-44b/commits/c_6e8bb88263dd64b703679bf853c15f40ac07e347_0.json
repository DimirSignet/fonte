{"sha": "6e8bb88263dd64b703679bf853c15f40ac07e347", "log": "COMPRESS-313 add auto-detection for LZMA streams  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n+import org.apache.commons.compress.compressors.lzma.LZMAUtils;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n import org.apache.commons.compress.compressors.xz.XZUtils;\n                 return new XZCompressorInputStream(in, decompressConcatenated);\n             }\n \n+            if (LZMAUtils.matches(signature, signatureLength) &&\n+                LZMAUtils.isLZMACompressionAvailable()) {\n+                return new LZMACompressorInputStream(in);\n+            }\n+\n         } catch (IOException e) {\n             throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n     public void close() throws IOException {\n         in.close();\n     }\n+\n+    /**\n+     * Checks if the signature matches what is expected for an lzma file.\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is an lzma  compressed stream, false otherwise\n+     * \n+     * @since 1.10\n+     */\n+    public static boolean matches(byte[] signature, int length) {\n+\n+        if (signature == null || length < 3) {\n+            return false;\n+        }\n+\n+        if (signature[0] != 0x5d) {\n+            return false;\n+        }\n+\n+        if (signature[1] != 0) {\n+            return false;\n+        }\n+\n+        if (signature[2] != 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lzma;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.compress.compressors.FileNameUtil;\n+\n+/**\n+ * Utility code for the lzma compression format.\n+ * @ThreadSafe\n+ * @since 1.10\n+ */\n+public class LZMAUtils {\n+\n+    private static final FileNameUtil fileNameUtil;\n+\n+    /**\n+     * LZMA Header Magic Bytes begin a LZMA file.\n+     */\n+    private static final byte[] HEADER_MAGIC = {\n+        (byte) 0x5D, 0, 0\n+    };\n+\n+    static enum CachedAvailability {\n+        DONT_CACHE, CACHED_AVAILABLE, CACHED_UNAVAILABLE\n+    }\n+\n+    private static volatile CachedAvailability cachedLZMAAvailability;\n+\n+    static {\n+        Map<String, String> uncompressSuffix = new HashMap<String, String>();\n+        uncompressSuffix.put(\".lzma\", \"\");\n+        uncompressSuffix.put(\"-lzma\", \"\");\n+        fileNameUtil = new FileNameUtil(uncompressSuffix, \".lzma\");\n+        cachedLZMAAvailability = CachedAvailability.DONT_CACHE;\n+        try {\n+            Class.forName(\"org.osgi.framework.BundleEvent\");\n+        } catch (Exception ex) {\n+            setCacheLZMAAvailablity(true);\n+        }\n+    }\n+\n+    /** Private constructor to prevent instantiation of this utility class. */\n+    private LZMAUtils() {\n+    }\n+\n+    /**\n+     * Checks if the signature matches what is expected for a .lzma file.\n+     *\n+     * @param   signature     the bytes to check\n+     * @param   length        the number of bytes to check\n+     * @return  true if signature matches the .lzma magic bytes, false otherwise\n+     */\n+    public static boolean matches(byte[] signature, int length) {\n+        if (length < HEADER_MAGIC.length) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < HEADER_MAGIC.length; ++i) {\n+            if (signature[i] != HEADER_MAGIC[i]) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Are the classes required to support LZMA compression available?\n+     */\n+    public static boolean isLZMACompressionAvailable() {\n+        final CachedAvailability cachedResult = cachedLZMAAvailability;\n+        if (cachedResult != CachedAvailability.DONT_CACHE) {\n+            return cachedResult == CachedAvailability.CACHED_AVAILABLE;\n+        }\n+        return internalIsLZMACompressionAvailable();\n+    }\n+\n+    private static boolean internalIsLZMACompressionAvailable() {\n+        try {\n+            LZMACompressorInputStream.matches(null, 0);\n+            return true;\n+        } catch (NoClassDefFoundError error) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Detects common lzma suffixes in the given filename.\n+     *\n+     * @param filename name of a file\n+     * @return {@code true} if the filename has a common lzma suffix,\n+     *         {@code false} otherwise\n+     */\n+    public static boolean isCompressedFilename(String filename) {\n+        return fileNameUtil.isCompressedFilename(filename);\n+    }\n+\n+    /**\n+     * Maps the given name of a lzma-compressed file to the name that\n+     * the file should have after uncompression.  Any filenames with\n+     * the generic \".lzma\" suffix (or any other generic lzma suffix)\n+     * is mapped to a name without that suffix. If no lzma suffix is\n+     * detected, then the filename is returned unmapped.\n+     *\n+     * @param filename name of a file\n+     * @return name of the corresponding uncompressed file\n+     */\n+    public static String getUncompressedFilename(String filename) {\n+        return fileNameUtil.getUncompressedFilename(filename);\n+    }\n+\n+    /**\n+     * Maps the given filename to the name that the file should have after\n+     * compression with lzma.\n+     *\n+     * @param filename name of a file\n+     * @return name of the corresponding compressed file\n+     */\n+    public static String getCompressedFilename(String filename) {\n+        return fileNameUtil.getCompressedFilename(filename);\n+    }\n+\n+    /**\n+     * Whether to cache the result of the LZMA check.\n+     *\n+     * <p>This defaults to {@code false} in an OSGi environment and {@code true} otherwise.</p>\n+     * @param doCache whether to cache the result\n+     */\n+    public static void setCacheLZMAAvailablity(boolean doCache) {\n+        if (!doCache) {\n+            cachedLZMAAvailability = CachedAvailability.DONT_CACHE;\n+        } else if (cachedLZMAAvailability == CachedAvailability.DONT_CACHE) {\n+            final boolean hasLzma = internalIsLZMACompressionAvailable();\n+            cachedLZMAAvailability = hasLzma ? CachedAvailability.CACHED_AVAILABLE\n+                : CachedAvailability.CACHED_UNAVAILABLE;\n+        }\n+    }\n+\n+    // only exists to support unit tests\n+    static CachedAvailability getCachedLZMAAvailability() {\n+        return cachedLZMAAvailability;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n  */\n package org.apache.commons.compress.compressors;\n \n+import java.io.BufferedInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n \n import org.apache.commons.compress.AbstractTestCase;\n         final InputStream is = new FileInputStream(input);\n         try {\n             final CompressorInputStream in = new LZMACompressorInputStream(is);\n-            FileOutputStream out = null;\n-            try {\n-                out = new FileOutputStream(output);\n-                IOUtils.copy(in, out);\n-            } finally {\n-                if (out != null) {\n-                    out.close();\n-                }\n-                in.close();\n-            }\n+            copy(in, output);\n         } finally {\n             is.close();\n         }\n     }\n+\n+    @Test\n+    public void testLZMAUnarchiveWithAutodetection() throws Exception {\n+        final File input = getFile(\"bla.tar.lzma\");\n+        final File output = new File(dir, \"bla.tar\");\n+        final InputStream is = new BufferedInputStream(new FileInputStream(input));\n+        try {\n+            final CompressorInputStream in = new CompressorStreamFactory()\n+                .createCompressorInputStream(is);\n+            copy(in, output);\n+        } finally {\n+            is.close();\n+        }\n+    }\n+\n+    private void copy(InputStream in, File output) throws IOException {\n+        FileOutputStream out = null;\n+        try {\n+            out = new FileOutputStream(output);\n+            IOUtils.copy(in, out);\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            in.close();\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lzma/LZMAUtilsTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lzma;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+public class LZMAUtilsTestCase {\n+\n+    @Test\n+    public void testIsCompressedFilename() {\n+        assertFalse(LZMAUtils.isCompressedFilename(\"\"));\n+        assertFalse(LZMAUtils.isCompressedFilename(\".lzma\"));\n+\n+        assertTrue(LZMAUtils.isCompressedFilename(\"x.lzma\"));\n+        assertTrue(LZMAUtils.isCompressedFilename(\"x-lzma\"));\n+\n+        assertFalse(LZMAUtils.isCompressedFilename(\"xxgz\"));\n+        assertFalse(LZMAUtils.isCompressedFilename(\"lzmaz\"));\n+        assertFalse(LZMAUtils.isCompressedFilename(\"xaz\"));\n+\n+        assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma \"));\n+        assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma\\n\"));\n+        assertFalse(LZMAUtils.isCompressedFilename(\"x.lzma.y\"));\n+    }\n+\n+    @Test\n+    public void testGetUncompressedFilename() {\n+        assertEquals(\"\", LZMAUtils.getUncompressedFilename(\"\"));\n+        assertEquals(\".lzma\", LZMAUtils.getUncompressedFilename(\".lzma\"));\n+\n+        assertEquals(\"x\", LZMAUtils.getUncompressedFilename(\"x.lzma\"));\n+        assertEquals(\"x\", LZMAUtils.getUncompressedFilename(\"x-lzma\"));\n+\n+        assertEquals(\"x.lzma \", LZMAUtils.getUncompressedFilename(\"x.lzma \"));\n+        assertEquals(\"x.lzma\\n\", LZMAUtils.getUncompressedFilename(\"x.lzma\\n\"));\n+        assertEquals(\"x.lzma.y\", LZMAUtils.getUncompressedFilename(\"x.lzma.y\"));\n+    }\n+\n+    @Test\n+    public void testGetCompressedFilename() {\n+        assertEquals(\".lzma\", LZMAUtils.getCompressedFilename(\"\"));\n+        assertEquals(\"x.lzma\", LZMAUtils.getCompressedFilename(\"x\"));\n+\n+        assertEquals(\"x.wmf .lzma\", LZMAUtils.getCompressedFilename(\"x.wmf \"));\n+        assertEquals(\"x.wmf\\n.lzma\", LZMAUtils.getCompressedFilename(\"x.wmf\\n\"));\n+        assertEquals(\"x.wmf.y.lzma\", LZMAUtils.getCompressedFilename(\"x.wmf.y\"));\n+    }\n+\n+    @Test\n+    public void testMatches() {\n+        byte[] data = {\n+            (byte) 0x5D, 0, 0,\n+        };\n+        assertFalse(LZMAUtils.matches(data, 2));\n+        assertTrue(LZMAUtils.matches(data, 3));\n+        assertTrue(LZMAUtils.matches(data, 4));\n+        data[2] = '0';\n+        assertFalse(LZMAUtils.matches(data, 3));\n+    }\n+\n+    @Test\n+    public void testCachingIsEnabledByDefaultAndLZMAIsPresent() {\n+        assertEquals(LZMAUtils.CachedAvailability.CACHED_AVAILABLE, LZMAUtils.getCachedLZMAAvailability());\n+        assertTrue(LZMAUtils.isLZMACompressionAvailable());\n+    }\n+\n+    @Test\n+    public void testCanTurnOffCaching() {\n+        try {\n+            LZMAUtils.setCacheLZMAAvailablity(false);\n+            assertEquals(LZMAUtils.CachedAvailability.DONT_CACHE, LZMAUtils.getCachedLZMAAvailability());\n+            assertTrue(LZMAUtils.isLZMACompressionAvailable());\n+        } finally {\n+            LZMAUtils.setCacheLZMAAvailablity(true);\n+        }\n+    }\n+\n+    @Test\n+    public void testTurningOnCachingReEvaluatesAvailability() {\n+        try {\n+            LZMAUtils.setCacheLZMAAvailablity(false);\n+            assertEquals(LZMAUtils.CachedAvailability.DONT_CACHE, LZMAUtils.getCachedLZMAAvailability());\n+            LZMAUtils.setCacheLZMAAvailablity(true);\n+            assertEquals(LZMAUtils.CachedAvailability.CACHED_AVAILABLE, LZMAUtils.getCachedLZMAAvailability());\n+        } finally {\n+            LZMAUtils.setCacheLZMAAvailablity(true);\n+        }\n+    }\n+\n+}", "timestamp": 1427731157, "metainfo": ""}