{"sha": "6c5f04b0f4489aab92cb3a178b59ab4392bfd9f5", "log": "first cut at reading Zip64 without any real tests, yet.  At least the existing test still pass.  COMPRESS-148  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n     // to see whether they do have a problem with the extraneous\n     // information inside the LFH\n \n-    private static final ZipShort HEADER_ID = new ZipShort(0x0001);\n+    static final ZipShort HEADER_ID = new ZipShort(0x0001);\n \n     private static final int WORD = 4, DWORD = 8;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION;\n \n /**\n  * Implements an input stream that can read Zip archives.\n     private long readBytesOfEntry = 0, bytesReadFromStream = 0;\n     private int lengthOfLastRead = 0;\n     private boolean hasDataDescriptor = false;\n+    private boolean usesZip64 = false;\n     private ByteArrayInputStream lastStoredEntry = null;\n \n     private boolean allowStoredEntriesWithDataDescriptor = false;\n         current = new ZipArchiveEntry();\n \n         int versionMadeBy = ZipShort.getValue(lfh, off);\n+        usesZip64 = (versionMadeBy & BYTE_MASK) >= ZIP64_MIN_VERSION;\n         off += SHORT;\n         current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                             & ZipFile.NIBLET_MASK);\n         current.setTime(time);\n         off += WORD;\n \n+        ZipLong size = null, cSize = null;\n         if (!hasDataDescriptor) {\n             current.setCrc(ZipLong.getValue(lfh, off));\n             off += WORD;\n \n-            current.setCompressedSize(ZipLong.getValue(lfh, off));\n+            cSize = new ZipLong(lfh, off);\n             off += WORD;\n \n-            current.setSize(ZipLong.getValue(lfh, off));\n+            size = new ZipLong(lfh, off);\n             off += WORD;\n         } else {\n             off += 3 * WORD;\n \n         if (!hasUTF8Flag && useUnicodeExtraFields) {\n             ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n+        }\n+        if (!hasDataDescriptor) {\n+            if (usesZip64 && (cSize.equals(ZipLong.ZIP64_MAGIC)\n+                              || size.equals(ZipLong.ZIP64_MAGIC))\n+                ) {\n+                Zip64ExtendedInformationExtraField z64 =\n+                    (Zip64ExtendedInformationExtraField)\n+                    current.getExtraField(Zip64ExtendedInformationExtraField\n+                                          .HEADER_ID);\n+                if (z64 == null) {\n+                    throw new ZipException(\"expected ZIP64 extra field\");\n+                }\n+                current.setCompressedSize(z64.getCompressedSize()\n+                                          .getLongValue());\n+                current.setSize(z64.getSize().getLongValue());\n+            } else {\n+                current.setCompressedSize(cSize.getValue());\n+                current.setSize(size.getValue());\n+            }\n         }\n         return current;\n     }\n             val = new ZipLong(b);\n         }\n         current.setCrc(val.getValue());\n+        if (!usesZip64) {\n         readFully(b);\n         current.setCompressedSize(new ZipLong(b).getValue());\n         readFully(b);\n         current.setSize(new ZipLong(b).getValue());\n+        } else {\n+            byte[] b8 = new byte[DWORD];\n+            readFully(b8);\n+            current.setCompressedSize(ZipEightByteInteger.getLongValue(b8));\n+            readFully(b8);\n+            current.setSize(ZipEightByteInteger.getLongValue(b8));\n+        }\n     }\n \n     /**\n         int off = 0;\n         boolean done = false;\n \n+        // length of DD without signature\n+        int ddLen = usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n+\n         while (!done) {\n             int r = in.read(buf, off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                     if ((buf[i + 2] == LFH[2] && buf[i + 3] == LFH[3])\n                         || (buf[i] == CFH[2] && buf[i + 3] == CFH[3])) {\n                         // found a LFH or CFH:\n-                        readTooMuch = off + r - i - 12 /* dd without signature */;\n+                        readTooMuch = off + r - i - ddLen;\n                         done = true;\n                     }\n                     else if (buf[i + 2] == DD[2] && buf[i + 3] == DD[3]) {\n             }\n             if (!done) {\n                 // worst case we've read a data descriptor without a\n-                // signature (12 bytes) plus the first three bytes of\n+                // signature (up to 20 bytes) plus the first three bytes of\n                 // a LFH or CFH signature\n-                // save the last 15 bytes in the buffer, cache\n+                // save the last ddLen + 3 bytes in the buffer, cache\n                 // anything in front of that, read on\n-                if (off + r > 15) {\n-                    bos.write(buf, 0, off + r - 15);\n-                    System.arraycopy(buf, off + r - 15, buf, 0, 15);\n-                    off = 15;\n+                if (off + r > ddLen + 3) {\n+                    bos.write(buf, 0, off + r - ddLen - 3);\n+                    System.arraycopy(buf, off + r - ddLen - 3, buf, 0,\n+                                     ddLen + 3);\n+                    off = ddLen + 3;\n                 } else {\n                     off += r;\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n \n     /** length of a ZipLong in bytes */\n     static final int WORD = 4;\n+\n+    /** length of a ZipEightByteInteger in bytes */\n+    static final int DWORD = 8;\n+\n+    /** ZIP specification version that introduced ZIP64 */\n+    static final int ZIP64_MIN_VERSION = 45;\n }", "timestamp": 1311624899, "metainfo": ""}