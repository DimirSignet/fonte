{"sha": "ce5fdc14713f1d0fe81b4ab6aeae09e788f044e0", "log": "added javadocs  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n     private final InputStream input;\n     private long offset = 0;\n     private boolean closed;\n+    \n     /*\n      * If getNextEnxtry has been called, the entry metadata is stored in\n      * currentEntry.\n      */\n     private ArArchiveEntry currentEntry = null;\n+    \n     /*\n      * The offset where the current entry started. -1 if no entry has been\n      * called\n      */\n     private long entryOffset = -1;\n \n-    public ArArchiveInputStream( final InputStream pInput ) {\n+    /**\n+     * Constructs an Ar input stream with the referenced stream\n+     * \n+     * @param pInput\n+     *            the ar input stream\n+     */\n+    public ArArchiveInputStream(final InputStream pInput) {\n         input = pInput;\n         closed = false;\n     }\n         }\n \n         if (offset == 0) {\n-            final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n-            final byte[] realized = new byte[expected.length]; \n+            final byte[] expected = ArchiveUtils\n+                    .toAsciiBytes(ArArchiveEntry.HEADER);\n+            final byte[] realized = new byte[expected.length];\n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read header. Occured at byte: \" + getCount());\n+                throw new IOException(\n+                        \"failed to read header. Occured at byte: \" + getCount());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid header \" + ArchiveUtils.toAsciiString(realized));\n+                    throw new IOException(\"invalid header \"\n+                            + ArchiveUtils.toAsciiString(realized));\n                 }\n             }\n         }\n         read(length);\n \n         {\n-            final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\n-            final byte[] realized = new byte[expected.length]; \n+            final byte[] expected = ArchiveUtils\n+                    .toAsciiBytes(ArArchiveEntry.TRAILER);\n+            final byte[] realized = new byte[expected.length];\n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read entry header. Occured at byte: \" + getCount());\n+                throw new IOException(\n+                        \"failed to read entry header. Occured at byte: \"\n+                                + getCount());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid entry header. not read the content? Occured at byte: \" + getCount());\n+                    throw new IOException(\n+                            \"invalid entry header. not read the content? Occured at byte: \"\n+                                    + getCount());\n                 }\n             }\n         }\n \n         entryOffset = offset;\n-        \n+\n         // SVR4/GNU adds a trailing \"/\" to names\n-        String temp=new String(name).trim(); // TODO is it correct to use the default charset here?\n-        if (temp.endsWith(\"/\")){\n-            temp=temp.substring(0, temp.length()-1);\n-        }\n-        currentEntry = new ArArchiveEntry(temp, // TODO is it correct to use the default charset here?\n-                                          Long.parseLong(new String(length)\n-                                                         .trim()));\n+        String temp = new String(name).trim(); // TODO is it correct to use the\n+        // default charset here?\n+        if (temp.endsWith(\"/\")) {\n+            temp = temp.substring(0, temp.length() - 1);\n+        }\n+        currentEntry = new ArArchiveEntry(temp, // TODO is it correct to use the\n+                // default charset here?\n+                Long.parseLong(new String(length).trim()));\n         return currentEntry;\n     }\n \n-\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see\n+     * org.apache.commons.compress.archivers.ArchiveInputStream#getNextEntry()\n+     */\n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextArEntry();\n     }\n \n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.io.InputStream#close()\n+     */\n     public void close() throws IOException {\n         if (!closed) {\n             closed = true;\n         currentEntry = null;\n     }\n \n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.io.InputStream#read(byte[], int, int)\n+     */\n     public int read(byte[] b, final int off, final int len) throws IOException {\n         int toRead = len;\n         if (currentEntry != null) {\n         return ret;\n     }\n \n+    /**\n+     * Checks if the signature matches ASCII \"!<arch>\" followed by a single LF\n+     * control character\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is an Ar archive stream, false otherwise\n+     */\n     public static boolean matches(byte[] signature, int length) {\n         // 3c21 7261 6863 0a3e\n ", "timestamp": 1240464606, "metainfo": ""}