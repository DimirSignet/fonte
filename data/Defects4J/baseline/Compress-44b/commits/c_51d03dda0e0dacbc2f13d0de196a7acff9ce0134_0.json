{"sha": "51d03dda0e0dacbc2f13d0de196a7acff9ce0134", "log": "COMPRESS-271 extract LZ4-independent code into reusable stream", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.compressors.lz77support.AbstractLZ77CompressorInputStream;\n import org.apache.commons.compress.utils.ByteUtils;\n-import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * CompressorInputStream for the LZ4 block format.\n  * @see <a href=\"http://lz4.github.io/lz4/lz4_Block_format.html\">LZ4 Block Format Description</a>\n  * @since 1.14\n  */\n-public class BlockLZ4CompressorInputStream extends CompressorInputStream {\n+public class BlockLZ4CompressorInputStream extends AbstractLZ77CompressorInputStream {\n \n     private static final int WINDOW_SIZE = 1 << 16;\n     private static final int SIZE_BITS = 4;\n     private static final int COPY_SIZE_MASK = (1 << SIZE_BITS) - 1;\n     private static final int LITERAL_SIZE_MASK = COPY_SIZE_MASK << SIZE_BITS;\n \n-    /** Buffer to write decompressed bytes to for back-references */\n-    private final byte[] buf = new byte[3 * WINDOW_SIZE];\n-\n-    /** One behind the index of the last byte in the buffer that was written */\n-    private int writeIndex;\n-\n-    /** Index of the next byte to be read. */\n-    private int readIndex;\n-\n-    /** The underlying stream to read compressed data from */\n-    private final InputStream in;\n-\n-    /** Number of bytes still to be read from the current literal or copy. */\n-    private long bytesRemaining;\n-\n     /** Copy-size part of the block starting byte. */\n     private int nextCopySize;\n \n-    /** Offset of the current copy. */\n-    private int copyOffset;\n-\n     /** Current state of the stream */\n     private State state = State.NO_BLOCK;\n-\n-    /** uncompressed size */\n-    private int size = 0;\n-\n-    // used in no-arg read method\n-    private final byte[] oneByte = new byte[1];\n-\n-    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n-        @Override\n-        public int getAsByte() throws IOException {\n-            return readOneByte();\n-        }\n-    };\n \n     /**\n      * Creates a new LZ4 input stream.\n      * @throws IOException if reading fails\n      */\n     public BlockLZ4CompressorInputStream(final InputStream is) throws IOException {\n-        this.in = is;\n-        writeIndex = readIndex = 0;\n-        bytesRemaining = 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int read() throws IOException {\n-        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void close() throws IOException {\n-        in.close();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int available() {\n-        return writeIndex - readIndex;\n+        super(is, WINDOW_SIZE);\n     }\n \n     /**\n             /*FALLTHROUGH*/\n         case IN_LITERAL:\n             int litLen = readLiteral(b, off, len);\n-            if (bytesRemaining == 0) {\n+            if (!hasMoreDataInBlock()) {\n                 state = State.LOOKING_FOR_COPY;\n             }\n             return litLen;\n             /*FALLTHROUGH*/\n         case IN_COPY:\n             int copyLen = readCopy(b, off, len);\n-            if (bytesRemaining == 0) {\n+            if (!hasMoreDataInBlock()) {\n                 state = State.NO_BLOCK;\n             }\n             return copyLen;\n         default:\n             throw new IOException(\"Unknown stream state \" + state);\n         }\n-    }\n-\n-    /**\n-     * Get the uncompressed size of the stream\n-     *\n-     * @return the uncompressed size\n-     */\n-    public int getSize() {\n-        return size;\n     }\n \n     private void readSizes() throws IOException {\n         if (literalSizePart == COPY_SIZE_MASK) {\n             literalSizePart += readSizeBytes();\n         }\n-        bytesRemaining = literalSizePart;\n+        startLiteral(literalSizePart);\n         state = State.IN_LITERAL;\n     }\n \n         return accum;\n     }\n \n-    private int readLiteral(final byte[] b, final int off, final int len) throws IOException {\n-        final int avail = available();\n-        if (len > avail) {\n-            tryToReadLiteral(len - avail);\n-        }\n-        return readFromBuffer(b, off, len);\n-    }\n-\n-    private void tryToReadLiteral(int bytesToRead) throws IOException {\n-        final int reallyTryToRead = (int) Math.min(Math.min(bytesToRead, bytesRemaining),\n-                                                   buf.length - writeIndex);\n-        final int bytesRead = reallyTryToRead > 0\n-            ? IOUtils.readFully(in, buf, writeIndex, reallyTryToRead)\n-            : 0 /* happens for bytesRemaining == 0 */;\n-        count(bytesRead);\n-        if (reallyTryToRead != bytesRead) {\n-            throw new IOException(\"Premature end of stream reading literal\");\n-        }\n-        writeIndex += reallyTryToRead;\n-        bytesRemaining -= reallyTryToRead;\n-    }\n-\n-    private int readFromBuffer(final byte[] b, final int off, final int len) throws IOException {\n-        final int readable = Math.min(len, available());\n-        if (readable > 0) {\n-            System.arraycopy(buf, readIndex, b, off, readable);\n-            readIndex += readable;\n-            if (readIndex > 2 * WINDOW_SIZE) {\n-                slideBuffer();\n-            }\n-        }\n-        size += readable;\n-        return readable;\n-    }\n-\n-    private void slideBuffer() {\n-        System.arraycopy(buf, WINDOW_SIZE, buf, 0, WINDOW_SIZE);\n-        writeIndex -= WINDOW_SIZE;\n-        readIndex -= WINDOW_SIZE;\n-    }\n-\n     /**\n      * @return false if there is no more copy - this means this is the\n      * last block of the stream.\n      */\n     private boolean initializeCopy() throws IOException {\n+        int copyOffset = 0;\n         try {\n             copyOffset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n         } catch (IOException ex) {\n         if (nextCopySize == COPY_SIZE_MASK) {\n             copySize += readSizeBytes();\n         }\n-        bytesRemaining = copySize + 4; // minimal match length 4 is encoded as 0\n+        // minimal match length 4 is encoded as 0\n+        startCopy(copyOffset, copySize + 4);\n         state = State.IN_COPY;\n         return true;\n-    }\n-\n-    private int readCopy(final byte[] b, final int off, final int len) throws IOException {\n-        final int avail = available();\n-        if (len > avail) {\n-            tryToCopy(len - avail);\n-        }\n-        return readFromBuffer(b, off, len);\n-    }\n-\n-    private void tryToCopy(int bytesToCopy) throws IOException {\n-        // this will fit into the buffer without sliding and not\n-        // require more than is available inside the copy\n-        int copy = (int) Math.min(Math.min(bytesToCopy, bytesRemaining),\n-                                  buf.length - writeIndex);\n-        if (copy == 0) {\n-            // NOP\n-        } else if (copyOffset == 1) { // pretty common special case\n-            final byte last = buf[writeIndex - 1];\n-            for (int i = 0; i < copy; i++) {\n-                buf[writeIndex++] = last;\n-            }\n-        } else if (copy < copyOffset) {\n-            System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copy);\n-            writeIndex += copy;\n-        } else {\n-            final int fullRots = copy / copyOffset;\n-            for (int i = 0; i < fullRots; i++) {\n-                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copyOffset);\n-                writeIndex += copyOffset;\n-            }\n-\n-            final int pad = copy - (copyOffset * fullRots);\n-            if (pad > 0) {\n-                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, pad);\n-                writeIndex += pad;\n-            }\n-        }\n-        bytesRemaining -= copy;\n-    }\n-\n-    private int readOneByte() throws IOException {\n-        final int b = in.read();\n-        if (b != -1) {\n-            count(1);\n-            return b & 0xFF;\n-        }\n-        return -1;\n     }\n \n     private enum State {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+/**\n+ * Encapsulates code common to LZ77 decompressors.\n+ *\n+ * <p>Assumes the stream consists of blocks of literal data and\n+ * back-references (called copies) in any order. Of course the first\n+ * block must be a literal block for the scheme to work.</p>\n+ *\n+ * @since 1.14\n+ */\n+public abstract class AbstractLZ77CompressorInputStream extends CompressorInputStream {\n+\n+    /** Size of the window - must be bigger than the biggest offset expected. */\n+    private final int windowSize;\n+\n+    /** Buffer to write decompressed bytes to for back-references */\n+    private final byte[] buf;\n+\n+    /** One behind the index of the last byte in the buffer that was written */\n+    private int writeIndex;\n+\n+    /** Index of the next byte to be read. */\n+    private int readIndex;\n+\n+    /** The underlying stream to read compressed data from */\n+    private final InputStream in;\n+\n+    /** Number of bytes still to be read from the current literal or copy. */\n+    private long bytesRemaining;\n+\n+    /** Offset of the current copy. */\n+    private int copyOffset;\n+\n+    /** uncompressed size */\n+    private int size = 0;\n+\n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n+    /**\n+     * Supplier that delegates to {@link #readOneByte}.\n+     */\n+    protected final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return readOneByte();\n+        }\n+    };\n+\n+    /**\n+     * Creates a new LZ77 input stream.\n+     *\n+     * @param is\n+     *            An InputStream to read compressed data from\n+     * @param windowSize\n+     *            Size of the window kept for back-references, must be bigger than the biggest offset expected.\n+     *\n+     * @throws IOException if reading fails\n+     */\n+    public AbstractLZ77CompressorInputStream(final InputStream is, int windowSize) throws IOException {\n+        this.in = is;\n+        this.windowSize = windowSize;\n+        buf = new byte[3 * windowSize];\n+        writeIndex = readIndex = 0;\n+        bytesRemaining = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() {\n+        return writeIndex - readIndex;\n+    }\n+\n+    /**\n+     * Get the uncompressed size of the stream\n+     *\n+     * @return the uncompressed size\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Used by subclasses to signal the next block contains the given\n+     * amount of literal data.\n+     * @param length the length of the block\n+     */\n+    protected final void startLiteral(long length) {\n+        bytesRemaining = length;\n+    }\n+\n+    /**\n+     * Is there still data remaining inside the current block?\n+     * @return true if there is still data remaining inside the current block.\n+     */\n+    protected final boolean hasMoreDataInBlock() {\n+        return bytesRemaining > 0;\n+    }\n+\n+    /**\n+     * Reads data from the current literal block.\n+     * @param b buffer to write data to\n+     * @param off offset to start writing to\n+     * @param len maximum amount of data to read\n+     * @return number of bytes read, may be 0. Will never return -1 as\n+     * EOF-detection is the responsibility of the subclass\n+     * @throws IOException if the underlying stream throws or signals\n+     * an EOF before the amount of data promised for the block have\n+     * been read\n+     */\n+    protected final int readLiteral(final byte[] b, final int off, final int len) throws IOException {\n+        final int avail = available();\n+        if (len > avail) {\n+            tryToReadLiteral(len - avail);\n+        }\n+        return readFromBuffer(b, off, len);\n+    }\n+\n+    private void tryToReadLiteral(int bytesToRead) throws IOException {\n+        final int reallyTryToRead = (int) Math.min(Math.min(bytesToRead, bytesRemaining),\n+                                                   buf.length - writeIndex);\n+        final int bytesRead = reallyTryToRead > 0\n+            ? IOUtils.readFully(in, buf, writeIndex, reallyTryToRead)\n+            : 0 /* happens for bytesRemaining == 0 */;\n+        count(bytesRead);\n+        if (reallyTryToRead != bytesRead) {\n+            throw new IOException(\"Premature end of stream reading literal\");\n+        }\n+        writeIndex += reallyTryToRead;\n+        bytesRemaining -= reallyTryToRead;\n+    }\n+\n+    private int readFromBuffer(final byte[] b, final int off, final int len) {\n+        final int readable = Math.min(len, available());\n+        if (readable > 0) {\n+            System.arraycopy(buf, readIndex, b, off, readable);\n+            readIndex += readable;\n+            if (readIndex > 2 * windowSize) {\n+                slideBuffer();\n+            }\n+        }\n+        size += readable;\n+        return readable;\n+    }\n+\n+    private void slideBuffer() {\n+        System.arraycopy(buf, windowSize, buf, 0, windowSize);\n+        writeIndex -= windowSize;\n+        readIndex -= windowSize;\n+    }\n+\n+    /**\n+     * Used by subclasses to signal the next block contains a back-reference with the given coordinates.\n+     * @param the offset of the back-reference\n+     * @param length the length of the back-reference\n+     */\n+    protected final void startCopy(int offset, long length) {\n+        copyOffset = offset;\n+        bytesRemaining = length;\n+    }\n+\n+    /**\n+     * Reads data from the current back-reference.\n+     * @param b buffer to write data to\n+     * @param off offset to start writing to\n+     * @param len maximum amount of data to read\n+     * @return number of bytes read, may be 0. Will never return -1 as\n+     * EOF-detection is the responsibility of the subclass\n+     */\n+    protected final int readCopy(final byte[] b, final int off, final int len) {\n+        final int avail = available();\n+        if (len > avail) {\n+            tryToCopy(len - avail);\n+        }\n+        return readFromBuffer(b, off, len);\n+    }\n+\n+    private void tryToCopy(int bytesToCopy) {\n+        // this will fit into the buffer without sliding and not\n+        // require more than is available inside the copy\n+        int copy = (int) Math.min(Math.min(bytesToCopy, bytesRemaining),\n+                                  buf.length - writeIndex);\n+        if (copy == 0) {\n+            // NOP\n+        } else if (copyOffset == 1) { // pretty common special case\n+            final byte last = buf[writeIndex - 1];\n+            for (int i = 0; i < copy; i++) {\n+                buf[writeIndex++] = last;\n+            }\n+        } else if (copy < copyOffset) {\n+            System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copy);\n+            writeIndex += copy;\n+        } else {\n+            final int fullRots = copy / copyOffset;\n+            for (int i = 0; i < fullRots; i++) {\n+                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copyOffset);\n+                writeIndex += copyOffset;\n+            }\n+\n+            final int pad = copy - (copyOffset * fullRots);\n+            if (pad > 0) {\n+                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, pad);\n+                writeIndex += pad;\n+            }\n+        }\n+        bytesRemaining -= copy;\n+    }\n+\n+    /**\n+     * Reads a single byte from the real input stream and ensures the data is accounted for.\n+     *\n+     * @return the byte read as value between 0 and 255 or -1 if EOF has been reached.\n+     * @throws IOException if the underlying stream throws\n+     */\n+    protected final int readOneByte() throws IOException {\n+        final int b = in.read();\n+        if (b != -1) {\n+            count(1);\n+            return b & 0xFF;\n+        }\n+        return -1;\n+    }\n+}", "timestamp": 1484680242, "metainfo": ""}