{"sha": "9e1ac89660190ec4d895855655891ad16d790fc4", "log": "lots of useless javadoc tags to make site build work on Java8  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n      * {@link #closeArchiveEntry()} to complete the process.\n      * \n      * @param entry describes the entry\n-     * @throws IOException\n+     * @throws IOException if an I/O error occurs\n      */\n     public abstract void putArchiveEntry(ArchiveEntry entry) throws IOException;\n \n     /**\n      * Closes the archive entry, writing any trailer information that may\n      * be required.\n-     * @throws IOException\n+     * @throws IOException if an I/O error occurs\n      */\n     public abstract void closeArchiveEntry() throws IOException;\n \n     /**\n      * Create an archive entry using the inputFile and entryName provided.\n      * \n-     * @param inputFile\n-     * @param entryName \n+     * @param inputFile the file to create the entry from\n+     * @param entryName name to use for the entry\n      * @return the ArchiveEntry set up with details from the file\n      * \n-     * @throws IOException\n+     * @throws IOException if an I/O error occurs\n      */\n     public abstract ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n \n     /**\n      * Create a new instance using the attributes of the given file\n+     * @param inputFile the file to create an entry from\n+     * @param entryName the name of the entry\n      */\n     public ArArchiveEntry(File inputFile, String entryName) {\n         // TODO sort out mode\n \n     /**\n      * Last modified time in seconds since the epoch.\n+     * @return the last modified date\n      */\n     public long getLastModified() {\n         return lastModified;\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n         return localFileHeader.originalSize;\n     }\n \n-    /** True if the entry refers to a directory */\n+    /** True if the entry refers to a directory.\n+     *\n+     * @return True if the entry refers to a directory\n+     */\n     public boolean isDirectory() {\n         return localFileHeader.fileType == LocalFileHeader.FileTypes.DIRECTORY;\n     }\n      * regardless of timezone if the archive has been created on a\n      * non-Unix system and a time taking the current timezone into\n      * account if the archive has beeen created on Unix.</p>\n+     *\n+     * @return the last modified date\n      */\n     public Date getLastModifiedDate() {\n         long ts = isHostOsUnix() ? localFileHeader.dateTimeModified * 1000l\n      * File mode of this entry.\n      *\n      * <p>The format depends on the host os that created the entry.</p>\n+     *\n+     * @return the file mode\n      */\n     public int getMode() {\n         return localFileHeader.fileAccessMode;\n      * File mode of this entry as Unix stat value.\n      *\n      * <p>Will only be non-zero of the host os was UNIX.\n+     *\n+     * @return the Unix mode\n      */\n     public int getUnixMode() {\n         return isHostOsUnix() ? getMode() : 0;\n     /**\n      * The operating system the archive has been created on.\n      * @see HostOs\n+     * @return the host OS code\n      */\n     public int getHostOs() {\n         return localFileHeader.hostOS;\n     /**\n      * Is the operating system the archive has been created on one\n      * that is considered a UNIX OS by arj?\n+     * @return whether the operating system the archive has been\n+     * created on is considered a UNIX OS by arj\n      */\n     public boolean isHostOsUnix() {\n         return getHostOs() == HostOs.UNIX || getHostOs() == HostOs.NEXT;\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n      * @param inputStream the underlying stream, whose ownership is taken\n      * @param charsetName the charset used for file names and comments\n      *   in the archive. May be {@code null} to use the platform default.\n-     * @throws ArchiveException\n+     * @throws ArchiveException if an exception occurs while reading\n      */\n     public ArjArchiveInputStream(final InputStream inputStream,\n             final String charsetName) throws ArchiveException {\n      * Constructs the ArjInputStream, taking ownership of the inputStream that is passed in,\n      * and using the CP437 character encoding.\n      * @param inputStream the underlying stream, whose ownership is taken\n-     * @throws ArchiveException\n+     * @throws ArchiveException if an exception occurs while reading\n      */\n     public ArjArchiveInputStream(final InputStream inputStream)\n             throws ArchiveException {\n     \n     /**\n      * Gets the archive's recorded name.\n+     * @return the archive's name\n      */\n     public String getArchiveName() {\n         return mainHeader.name;\n     \n     /**\n      * Gets the archive's comment.\n+     * @return the archive's comment\n      */\n     public String getArchiveComment() {\n         return mainHeader.comment;\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n      * Octal Binary value:\n      * \n      * 070707 - MAGIC_OLD_BINARY (held as a short) = 0x71C7 or 0xC771\n+     * @param signature data to match\n+     * @param length length of data\n+     * @return whether the buffer seems to contain CPIO data\n      */\n     public static boolean matches(byte[] signature, int length) {\n         if (length < 6) {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n     /**\n      * Constructor taking name, inode and type.\n      *\n-     * @param name\n-     * @param simpleName\n-     * @param ino\n-     * @param type\n+     * @param name the name\n+     * @param simpleName the simple name\n+     * @param ino the ino\n+     * @param type the type\n      */\n     protected DumpArchiveEntry(String name, String simpleName, int ino,\n                                TYPE type) {\n     }\n \n     /**\n-     * Constructor taking tape buffer.\n-     * @param buffer\n-     * @param offset\n-     */\n-\n-    /**\n      * Returns the path of the entry.\n      * @return the path of the entry.\n      */\n \n     /**\n      * Sets the path of the entry.\n+     * @param simpleName the simple name\n      */\n     protected void setSimpleName(String simpleName) {\n         this.simpleName = simpleName;\n \n     /**\n      * Returns the ino of the entry.\n+     * @return the ino\n      */\n     public int getIno() {\n         return header.getIno();\n \n     /**\n      * Return the number of hard links to the entry.\n+     * @return the number of hard links\n      */\n     public int getNlink() {\n         return nlink;\n \n     /**\n      * Set the number of hard links.\n+     * @param nlink the number of hard links\n      */\n     public void setNlink(int nlink) {\n         this.nlink = nlink;\n \n     /**\n      * Get file creation time.\n+     * @return the creation time\n      */\n     public Date getCreationTime() {\n         return new Date(ctime);\n \n     /**\n      * Set the file creation time.\n+     * @param ctime the creation time\n      */\n     public void setCreationTime(Date ctime) {\n         this.ctime = ctime.getTime();\n \n     /**\n      * Return the generation of the file.\n+     * @return the generation\n      */\n     public int getGeneration() {\n         return generation;\n \n     /**\n      * Set the generation of the file.\n+     * @param generation the generation\n      */\n     public void setGeneration(int generation) {\n         this.generation = generation;\n \n     /**\n      * Has this file been deleted? (On valid on incremental dumps.)\n+     * @return whether the file has been deleted\n      */\n     public boolean isDeleted() {\n         return isDeleted;\n \n     /**\n      * Set whether this file has been deleted.\n+     * @param isDeleted whether the file has been deleted\n      */\n     public void setDeleted(boolean isDeleted) {\n         this.isDeleted = isDeleted;\n \n     /**\n      * Return the offset within the archive\n+     * @return the offset\n      */\n     public long getOffset() {\n         return offset;\n \n     /**\n      * Set the offset within the archive.\n+     * @param offset the offset\n      */\n     public void setOffset(long offset) {\n         this.offset = offset;\n \n     /**\n      * Return the tape volume where this file is located.\n+     * @return the volume\n      */\n     public int getVolume() {\n         return volume;\n \n     /**\n      * Set the tape volume.\n+     * @param volume the volume\n      */\n     public void setVolume(int volume) {\n         this.volume = volume;\n \n     /**\n      * Return the type of the tape segment header.\n+     * @return the segment header\n      */\n     public DumpArchiveConstants.SEGMENT_TYPE getHeaderType() {\n         return header.getType();\n \n     /**\n      * Return the number of records in this segment.\n+     * @return the number of records\n      */\n     public int getHeaderCount() {\n         return header.getCount();\n \n     /**\n      * Return the number of sparse records in this segment.\n+     * @return the number of sparse records\n      */\n     public int getHeaderHoles() {\n         return header.getHoles();\n \n     /**\n      * Is this a sparse record?\n+     * @param idx index of the record to check\n+     * @return whether this is a sparse record\n      */\n     public boolean isSparseRecord(int idx) {\n         return (header.getCdata(idx) & 0x01) == 0;\n     }\n \n-    /**\n-     * @see java.lang.Object#hashCode()\n-     */\n     @Override\n     public int hashCode() {\n         return ino;\n     }\n \n-    /**\n-     * @see java.lang.Object#equals(Object o)\n-     */\n     @Override\n     public boolean equals(Object o) {\n         if (o == this) {\n         return true;\n     }\n \n-    /**\n-     * @see java.lang.Object#toString()\n-     */\n     @Override\n     public String toString() {\n         return getName();\n      * Populate the dump archive entry and tape segment header with\n      * the contents of the buffer.\n      *\n-     * @param buffer\n-     * @throws Exception\n+     * @param buffer buffer to read content from\n      */\n     static DumpArchiveEntry parse(byte[] buffer) {\n         DumpArchiveEntry entry = new DumpArchiveEntry();\n \n     /**\n      * Sets the name of the entry.\n+     * @param name the name\n      */\n     public final void setName(String name) {\n         this.originalName = name;\n         this.name = name;\n     }\n \n+    /**\n+     * The last modified date.\n+     * @return the last modified date\n+     */\n     public Date getLastModifiedDate() {\n         return new Date(mtime);\n     }\n \n     /**\n      * Is this a directory?\n+     * @return whether this is a directory\n      */\n     public boolean isDirectory() {\n         return type == TYPE.DIRECTORY;\n \n     /**\n      * Is this a regular file?\n+     * @return whether this is a regular file\n      */\n     public boolean isFile() {\n         return type == TYPE.FILE;\n \n     /**\n      * Is this a network device?\n+     * @return whether this is a socket\n      */\n     public boolean isSocket() {\n         return type == TYPE.SOCKET;\n \n     /**\n      * Is this a character device?\n+     * @return whether this is a character device\n      */\n     public boolean isChrDev() {\n         return type == TYPE.CHRDEV;\n \n     /**\n      * Is this a block device?\n+     * @return whether this is a block device\n      */\n     public boolean isBlkDev() {\n         return type == TYPE.BLKDEV;\n \n     /**\n      * Is this a fifo/pipe?\n+     * @return whether this is a fifo\n      */\n     public boolean isFifo() {\n         return type == TYPE.FIFO;\n \n     /**\n      * Get the type of the entry.\n+     * @return the type\n      */\n     public TYPE getType() {\n         return type;\n \n     /**\n      * Set the type of the entry.\n+     * @param type the type\n      */\n     public void setType(TYPE type) {\n         this.type = type;\n \n     /**\n      * Return the access permissions on the entry.\n+     * @return the access permissions\n      */\n     public int getMode() {\n         return mode;\n \n     /**\n      * Set the access permissions on the entry.\n+     * @param mode the access permissions\n      */\n     public void setMode(int mode) {\n         this.mode = mode & 07777;\n \n     /**\n      * Returns the permissions on the entry.\n+     * @return the permissions\n      */\n     public Set<PERMISSION> getPermissions() {\n         return permissions;\n \n     /**\n      * Returns the size of the entry.\n+     * @return the size\n      */\n     public long getSize() {\n         return isDirectory() ? SIZE_UNKNOWN : size;\n \n     /**\n      * Set the size of the entry.\n+     * @param size the size\n      */\n     public void setSize(long size) {\n         this.size = size;\n \n     /**\n      * Set the time the file was last modified.\n+     * @param mtime the last modified time\n      */\n     public void setLastModifiedDate(Date mtime) {\n         this.mtime = mtime.getTime();\n \n     /**\n      * Returns the time the file was last accessed.\n+     * @return the access time\n      */\n     public Date getAccessTime() {\n         return new Date(atime);\n \n     /**\n      * Set the time the file was last accessed.\n+     * @param atime the access time\n      */\n     public void setAccessTime(Date atime) {\n         this.atime = atime.getTime();\n \n     /**\n      * Return the user id.\n+     * @return the user id\n      */\n     public int getUserId() {\n         return uid;\n \n     /**\n      * Set the user id.\n+     * @param uid the user id\n      */\n     public void setUserId(int uid) {\n         this.uid = uid;\n \n     /**\n      * Return the group id\n+     * @return the group id\n      */\n     public int getGroupId() {\n         return gid;\n \n     /**\n      * Set the group id.\n+     * @param gid the group id\n      */\n     public void setGroupId(int gid) {\n         this.gid = gid;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n      * Constructor using the platform's default encoding for file\n      * names.\n      *\n-     * @param is\n-     * @throws ArchiveException\n+     * @param is stream to read from\n+     * @throws ArchiveException on error\n      */\n     public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n         this(is, null);\n     /**\n      * Constructor.\n      *\n-     * @param is\n+     * @param is stream to read from\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n      * @since 1.6\n+     * @throws ArchiveException on error\n      */\n     public DumpArchiveInputStream(InputStream is, String encoding)\n         throws ArchiveException {\n \n     /**\n      * Return the archive summary information.\n+     * @return the summary\n      */\n     public DumpArchiveSummary getSummary() {\n         return summary;\n \n     /**\n      * Read the next entry.\n+     * @return the next entry\n+     * @throws IOException on error\n      */\n     public DumpArchiveEntry getNextDumpEntry() throws IOException {\n         return getNextEntry();\n     }\n \n-    /**\n-     * Read the next entry.\n-     */\n     @Override\n     public DumpArchiveEntry getNextEntry() throws IOException {\n         DumpArchiveEntry entry = null;\n      * Look at the first few bytes of the file to decide if it's a dump\n      * archive. With 32 bytes we can look at the magic value, with a full\n      * 1k we can verify the checksum.\n+     * @param buffer data to match\n+     * @param length length of data\n+     * @return whether the buffer seems to contain dump data\n      */\n     public static boolean matches(byte[] buffer, int length) {\n         // do we have enough of the header?\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n \n     /**\n      * Set dump date.\n+     * @param dumpDate the dump date\n      */\n     public void setDumpDate(Date dumpDate) {\n         this.dumpDate = dumpDate.getTime();\n \n     /**\n      * Set previous dump date.\n+     * @param previousDumpDate the previous dump dat\n      */\n     public void setPreviousDumpDate(Date previousDumpDate) {\n         this.previousDumpDate = previousDumpDate.getTime();\n \n     /**\n      * Set volume (tape) number.\n+     * @param volume the volume number\n      */\n     public void setVolume(int volume) {\n         this.volume = volume;\n \n     /**\n      * Set level.\n+     * @param level the level\n      */\n     public void setLevel(int level) {\n         this.level = level;\n \n     /**\n      * Set dump label.\n-     * @param label\n+     * @param label the label\n      */\n     public void setLabel(String label) {\n         this.label = label;\n \n     /**\n      * Set the last mountpoint.\n+     * @param filesystem the last mountpoint\n      */\n     public void setFilesystem(String filesystem) {\n         this.filesys = filesystem;\n \n     /**\n      * Set the device name.\n-     * @param devname\n+     * @param devname the device name\n      */\n     public void setDevname(String devname) {\n         this.devname = devname;\n \n     /**\n      * Get the hostname of the system where the dump was performed.\n-     * @return hostname\n+     * @return hostname the host name\n      */\n     public String getHostname() {\n         return hostname;\n \n     /**\n      * Set the hostname.\n+     * @param hostname the host name\n      */\n     public void setHostname(String hostname) {\n         this.hostname = hostname;\n \n     /**\n      * Set the miscellaneous flags.\n-     * @param flags\n+     * @param flags flags\n      */\n     public void setFlags(int flags) {\n         this.flags = flags;\n \n     /**\n      * Set the inode of the first record.\n-     * @param firstrec\n+     * @param firstrec the first record\n      */\n     public void setFirstRecord(int firstrec) {\n         this.firstrec = firstrec;\n \n     /**\n      * Set the number of records per tape block.\n+     * @param ntrec the number of records per tape block\n      */\n     public void setNTRec(int ntrec) {\n         this.ntrec = ntrec;\n         return (flags & 0x8000) == 0x8000;\n     }\n \n-    /**\n-     * @see java.lang.Object#hashCode()\n-     */\n     @Override\n     public int hashCode() {\n         int hash = 17;\n         return hash;\n     }\n \n-    /**\n-     * @see java.lang.Object#equals(Object)\n-     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n \n     /**\n      * Returns whether this entry has got a creation date at all.\n+     * @return whether the entry has got a creation date\n      */\n     public boolean getHasCreationDate() {\n         return hasCreationDate;\n     \n     /**\n      * Sets whether this entry has got a creation date at all.\n+     * @param hasCreationDate whether the entry has got a creation date\n      */\n     public void setHasCreationDate(boolean hasCreationDate) {\n         this.hasCreationDate = hasCreationDate;\n      * Gets the creation date.\n      * @throws UnsupportedOperationException if the entry hasn't got a\n      * creation date.\n+     * @return the creation date\n      */\n     public Date getCreationDate() {\n         if (hasCreationDate) {\n     /**\n      * Sets the creation date using NTFS time (100 nanosecond units\n      * since 1 January 1601)\n+     * @param ntfsCreationDate the creation date\n      */\n     public void setCreationDate(long ntfsCreationDate) {\n         this.creationDate = ntfsCreationDate;\n     \n     /**\n      * Sets the creation date,\n+     * @param creationDate the creation date\n      */\n     public void setCreationDate(Date creationDate) {\n         hasCreationDate = creationDate != null;\n \n     /**\n      * Returns whether this entry has got a last modified date at all.\n+     * @return whether this entry has got a last modified date at all\n      */\n     public boolean getHasLastModifiedDate() {\n         return hasLastModifiedDate;\n \n     /**\n      * Sets whether this entry has got a last modified date at all.\n+     * @param hasLastModifiedDate whether this entry has got a last\n+     * modified date at all\n      */\n     public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\n         this.hasLastModifiedDate = hasLastModifiedDate;\n      * Gets the last modified date.\n      * @throws UnsupportedOperationException if the entry hasn't got a\n      * last modified date.\n+     * @return the last modified date\n      */\n     public Date getLastModifiedDate() {\n         if (hasLastModifiedDate) {\n     /**\n      * Sets the last modified date using NTFS time (100 nanosecond\n      * units since 1 January 1601)\n+     * @param ntfsLastModifiedDate the last modified date\n      */\n     public void setLastModifiedDate(long ntfsLastModifiedDate) {\n         this.lastModifiedDate = ntfsLastModifiedDate;\n     \n     /**\n      * Sets the last modified date,\n+     * @param lastModifiedDate the last modified date\n      */\n     public void setLastModifiedDate(Date lastModifiedDate) {\n         hasLastModifiedDate = lastModifiedDate != null;\n     \n     /**\n      * Returns whether this entry has got an access date at all.\n+     * @return whether this entry has got an access date at all.\n      */\n     public boolean getHasAccessDate() {\n         return hasAccessDate;\n \n     /**\n      * Sets whether this entry has got an access date at all.\n+     * @param hasAcessDate whether this entry has got an access date at all.\n      */\n     public void setHasAccessDate(boolean hasAcessDate) {\n         this.hasAccessDate = hasAcessDate;\n      * Gets the access date.\n      * @throws UnsupportedOperationException if the entry hasn't got a\n      * access date.\n+     * @return the access date\n      */\n     public Date getAccessDate() {\n         if (hasAccessDate) {\n     /**\n      * Sets the access date using NTFS time (100 nanosecond units\n      * since 1 January 1601)\n+     * @param ntfsAccessDate the access date\n      */\n     public void setAccessDate(long ntfsAccessDate) {\n         this.accessDate = ntfsAccessDate;\n     \n     /**\n      * Sets the access date,\n+     * @param accessDate the access date\n      */\n     public void setAccessDate(Date accessDate) {\n         hasAccessDate = accessDate != null;\n \n     /**\n      * Returns whether this entry has windows attributes.\n+     * @return whether this entry has windows attributes.\n      */\n     public boolean getHasWindowsAttributes() {\n         return hasWindowsAttributes;\n \n     /**\n      * Sets whether this entry has windows attributes.\n+     * @param hasWindowsAttributes whether this entry has windows attributes.\n      */\n     public void setHasWindowsAttributes(boolean hasWindowsAttributes) {\n         this.hasWindowsAttributes = hasWindowsAttributes;\n \n     /**\n      * Gets the windows attributes.\n+     * @return the windows attributes\n      */\n     public int getWindowsAttributes() {\n         return windowsAttributes;\n \n     /**\n      * Sets the windows attributes.\n+     * @param windowsAttributes the windows attributes\n      */\n     public void setWindowsAttributes(int windowsAttributes) {\n         this.windowsAttributes = windowsAttributes;\n     /**\n      * Returns whether this entry has got a crc.\n      *\n-     * In general entries without streams don't have a CRC either.\n+     * <p>In general entries without streams don't have a CRC either.</p>\n+     * @return whether this entry has got a crc.\n      */\n     public boolean getHasCrc() {\n         return hasCrc;\n \n     /**\n      * Sets whether this entry has got a crc.\n+     * @param hasCrc whether this entry has got a crc.\n      */\n     public void setHasCrc(boolean hasCrc) {\n         this.hasCrc = hasCrc;\n     /**\n      * Gets the CRC.\n      * @deprecated use getCrcValue instead.\n+     * @return the CRC\n      */\n     @Deprecated\n     public int getCrc() {\n     /**\n      * Sets the CRC.\n      * @deprecated use setCrcValue instead.\n+     * @param crc the CRC\n      */\n     @Deprecated\n     public void setCrc(int crc) {\n     /**\n      * Gets the CRC.\n      * @since Compress 1.7\n+     * @return the CRC\n      */\n     public long getCrcValue() {\n         return crc;\n     /**\n      * Sets the CRC.\n      * @since Compress 1.7\n+     * @param crc the CRC\n      */\n     public void setCrcValue(long crc) {\n         this.crc = crc;\n     /**\n      * Gets the compressed CRC.\n      * @deprecated use getCompressedCrcValue instead.\n+     * @return the compressed CRC\n      */\n     @Deprecated\n     int getCompressedCrc() {\n     /**\n      * Sets the compressed CRC.\n      * @deprecated use setCompressedCrcValue instead.\n+     * @param crc the CRC\n      */\n     @Deprecated\n     void setCompressedCrc(int crc) {\n     /**\n      * Gets the compressed CRC.\n      * @since Compress 1.7\n+     * @return the CRC\n      */\n     long getCompressedCrcValue() {\n         return compressedCrc;\n     /**\n      * Sets the compressed CRC.\n      * @since Compress 1.7\n+     * @param crc the CRC\n      */\n     void setCompressedCrcValue(long crc) {\n         this.compressedCrc = crc;\n      * <p>The methods will be consulted in iteration order to create\n      * the final output.</p>\n      *\n+     * @param methods the methods to use for the content\n      * @since 1.8\n      */\n     public void setContentMethods(Iterable<? extends SevenZMethodConfiguration> methods) {\n      * the final output.</p>\n      *\n      * @since 1.8\n+     * @return the methods to use for the content\n      */\n     public Iterable<? extends SevenZMethodConfiguration> getContentMethods() {\n         return contentMethods;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethodConfiguration.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethodConfiguration.java\n \n     /**\n      * The specified method.\n+     * @return the method\n      */\n     public SevenZMethod getMethod() {\n         return method;\n \n     /**\n      * The specified options.\n+     * @return the options\n      */\n     public Object getOptions() {\n         return options;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n      *\n      * <p>This is a short form for passing a single-element iterable\n      * to {@link #setContentMethods}.</p>\n+     * @param method the default compression method\n      */\n     public void setContentCompression(SevenZMethod method) {\n         setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(method)));\n      * the final output.</p>\n      *\n      * @since 1.8\n+     * @param methods the default (compression) methods\n      */\n     public void setContentMethods(Iterable<? extends SevenZMethodConfiguration> methods) {\n         this.contentMethods = reverse(methods);\n     /**\n      * Closes the archive, calling {@link #finish} if necessary.\n      * \n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public void close() throws IOException {\n         if (!finished) {\n     /**\n      * Create an archive entry using the inputFile and entryName provided.\n      * \n-     * @param inputFile\n-     * @param entryName \n+     * @param inputFile file to create an entry from\n+     * @param entryName the name to use\n      * @return the ArchiveEntry set up with details from the file\n      * \n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n             final String entryName) throws IOException {\n      * {@link #closeArchiveEntry()} to complete the process.\n      * \n      * @param archiveEntry describes the entry\n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n     \n     /**\n      * Closes the archive entry.\n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public void closeArchiveEntry() throws IOException {\n         if (currentOutputStream != null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      * @param encoding encoding to use for file names\n      * @since 1.4\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     * @throws IOException on error\n      */\n     public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\n         throws IOException {\n      *\n      * @return This entry's user id.\n      * @deprecated use #getLongUserId instead as user ids can be\n-     * bigger than {@link Integer.MAX_INT}\n+     * bigger than {@link Integer#MAX_VALUE}\n      */\n     @Deprecated\n     public int getUserId() {\n      *\n      * @return This entry's group id.\n      * @deprecated use #getLongGroupId instead as group ids can be\n-     * bigger than {@link Integer.MAX_INT}\n+     * bigger than {@link Integer#MAX_VALUE}\n      */\n     @Deprecated\n     public int getGroupId() {\n      * Check if this is a \"normal file\"\n      *\n      * @since 1.2\n+     * @return whether this is a \"normal file\"\n      */\n     public boolean isFile() {\n         if (file != null) {\n      * Check if this is a symbolic link entry.\n      *\n      * @since 1.2\n+     * @return whether this is a symbolic link\n      */\n     public boolean isSymbolicLink() {\n         return linkFlag == LF_SYMLINK;\n      * Check if this is a link entry.\n      *\n      * @since 1.2\n+     * @return whether this is a link entry\n      */\n     public boolean isLink() {\n         return linkFlag == LF_LINK;\n      * Check if this is a character device entry.\n      *\n      * @since 1.2\n+     * @return whether this is a character device\n      */\n     public boolean isCharacterDevice() {\n         return linkFlag == LF_CHR;\n      * Check if this is a block device entry.\n      *\n      * @since 1.2\n+     * @return whether this is a block device\n      */\n     public boolean isBlockDevice() {\n         return linkFlag == LF_BLK;\n      * Check if this is a FIFO (pipe) entry.\n      *\n      * @since 1.2\n+     * @return whether this is a FIFO entry\n      */\n     public boolean isFIFO() {\n         return linkFlag == LF_FIFO;\n      * extension for numeric fields if their value doesn't fit in the\n      * maximum size of standard tar archives\n      * @since 1.4\n+     * @throws IOException on error\n      */\n     public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n                                  boolean starMode) throws IOException {\n      * @since 1.4\n      * @throws IllegalArgumentException if any of the numeric fields\n      * have an invalid format\n+     * @throws IOException on error\n      */\n     public void parseTarHeader(byte[] header, ZipEncoding encoding)\n         throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     /**\n      * Whether to add a PAX extension header for non-ASCII file names.\n      * @since 1.4\n+     * @param b whether to add a PAX extension header for non-ASCII file names.\n      */\n     public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n         addPaxHeadersForNonAsciiNames = b;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      * @return The entry name.\n+     * @throws IOException on error\n      */\n     public static String parseName(byte[] buffer, final int offset,\n                                    final int length,\n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      * @return The updated offset, i.e. offset + length\n+     * @throws IOException on error\n      */\n     public static int formatNameBytes(String name, byte[] buf, final int offset,\n                                       final int length,\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n \n         /**\n          * Key of the action to take.\n+         * @return the key\n          */\n         public int getKey() { return key; }\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n \n     /**\n      * whether the current entry uses UTF8 for file name and comment.\n+     * @return whether the current entry uses UTF8 for file name and comment.\n      */\n     public boolean usesUTF8ForNames() {\n         return languageEncodingFlag;\n \n     /**\n      * whether the current entry will use UTF8 for file name and comment.\n+     * @param b whether the current entry will use UTF8 for file name and comment.\n      */\n     public void useUTF8ForNames(boolean b) {\n         languageEncodingFlag = b;\n \n     /**\n      * whether the current entry uses the data descriptor to store CRC\n+     * and size information.\n+     * @return whether the current entry uses the data descriptor to store CRC\n      * and size information\n      */\n     public boolean usesDataDescriptor() {\n \n     /**\n      * whether the current entry will use the data descriptor to store\n+     * CRC and size information.\n+     * @param b whether the current entry will use the data descriptor to store\n      * CRC and size information\n      */\n     public void useDataDescriptor(boolean b) {\n     }\n \n     /**\n-     * whether the current entry is encrypted\n+     * whether the current entry is encrypted.\n+     * @return whether the current entry is encrypted\n      */\n     public boolean usesEncryption() {\n         return encryptionFlag;\n     }\n \n     /**\n-     * whether the current entry will be encrypted\n+     * whether the current entry will be encrypted.\n+     * @param b whether the current entry will be encrypted\n      */\n     public void useEncryption(boolean b) {\n         encryptionFlag = b;\n     }\n \n     /**\n-     * whether the current entry is encrypted using strong encryption\n+     * whether the current entry is encrypted using strong encryption.\n+     * @return whether the current entry is encrypted using strong encryption\n      */\n     public boolean usesStrongEncryption() {\n         return encryptionFlag && strongEncryptionFlag;\n     }\n \n     /**\n-     * whether the current entry will be encrypted  using strong encryption\n+     * whether the current entry will be encrypted  using strong encryption.\n+     * @param b whether the current entry will be encrypted  using strong encryption\n      */\n     public void useStrongEncryption(boolean b) {\n         strongEncryptionFlag = b;\n \n     /**\n      * Encodes the set bits in a form suitable for ZIP archives.\n+     * @return the encoded general purpose bits\n      */\n     public byte[] encode() {\n         byte[] result = new byte[2];\n      * \n      * @param data local file header or a central directory entry.\n      * @param offset offset at which the general purpose bit starts\n+     * @return parsed flags\n      */\n     public static GeneralPurposeBit parse(final byte[] data, final int offset) {\n         final int generalPurposeFlag = ZipShort.getValue(data, offset);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n      *\n      * @param file The file to offload compressed data into.\n      * @return A ScatterZipOutputStream that is ready for use.\n-     * @throws FileNotFoundException\n+     * @throws FileNotFoundException if the file cannot be found\n      */\n     public static ScatterZipOutputStream fileBased(File file) throws FileNotFoundException {\n         return fileBased(file, Deflater.DEFAULT_COMPRESSION);\n      * @param file             The file to offload compressed data into.\n      * @param compressionLevel The compression level to use, @see #Deflater\n      * @return A  ScatterZipOutputStream that is ready for use.\n-     * @throws FileNotFoundException\n+     * @throws FileNotFoundException if the file cannot be found\n      */\n     public static ScatterZipOutputStream fileBased(File file, int compressionLevel) throws FileNotFoundException {\n         ScatterGatherBackingStore bs = new FileBasedScatterGatherBackingStore(file);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n \n     /**\n      * The unsupported feature that has been used.\n+     * @return The unsupported feature that has been used.\n      */\n     public Feature getFeature() {\n         return reason;\n \n     /**\n      * The entry using the unsupported feature.\n+     * @return The entry using the unsupported feature.\n      */\n     public ZipArchiveEntry getEntry() {\n         return entry;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n      *\n      * @param size the entry's original size\n      * @param compressedSize the entry's compressed size\n+     * @param relativeHeaderOffset the entry's offset\n+     * @param diskStart the disk start\n      *\n      * @throws IllegalArgumentException if size or compressedSize is null\n      */\n      * field are optional and must only be present if their corresponding\n      * entry inside the central directory contains the correct magic\n      * value.</p>\n+     *\n+     * @param hasUncompressedSize flag to read from central directory\n+     * @param hasCompressedSize flag to read from central directory\n+     * @param hasRelativeHeaderOffset flag to read from central directory\n+     * @param hasDiskStart flag to read from central directory\n+     * @throws ZipException on error\n      */\n     public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                             boolean hasCompressedSize,\n \n     /**\n      * The uncompressed size stored in this extra field.\n+     * @return The uncompressed size stored in this extra field.\n      */\n     public ZipEightByteInteger getSize() {\n         return size;\n \n     /**\n      * The uncompressed size stored in this extra field.\n+     * @param size The uncompressed size stored in this extra field.\n      */\n     public void setSize(ZipEightByteInteger size) {\n         this.size = size;\n \n     /**\n      * The compressed size stored in this extra field.\n+     * @return The compressed size stored in this extra field.\n      */\n     public ZipEightByteInteger getCompressedSize() {\n         return compressedSize;\n \n     /**\n      * The uncompressed size stored in this extra field.\n+     * @param compressedSize The uncompressed size stored in this extra field.\n      */\n     public void setCompressedSize(ZipEightByteInteger compressedSize) {\n         this.compressedSize = compressedSize;\n \n     /**\n      * The relative header offset stored in this extra field.\n+     * @return The relative header offset stored in this extra field.\n      */\n     public ZipEightByteInteger getRelativeHeaderOffset() {\n         return relativeHeaderOffset;\n \n     /**\n      * The relative header offset stored in this extra field.\n+     * @param rho The relative header offset stored in this extra field.\n      */\n     public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n         relativeHeaderOffset = rho;\n \n     /**\n      * The disk start number stored in this extra field.\n+     * @return The disk start number stored in this extra field.\n      */\n     public ZipLong getDiskStartNumber() {\n         return diskStart;\n \n     /**\n      * The disk start number stored in this extra field.\n+     * @param ds The disk start number stored in this extra field.\n      */\n     public void setDiskStartNumber(ZipLong ds) {\n         diskStart = ds;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      * the file is a directory.  If the file is not a directory a\n      * potential trailing forward slash will be stripped from the\n      * entry name.</p>\n+     * @param inputFile file to create the entry from\n+     * @param entryName name of the entry\n      */\n     public ZipArchiveEntry(File inputFile, String entryName) {\n         this(inputFile.isDirectory() && !entryName.endsWith(\"/\") ? \n     /**\n      * Looks up an extra field by its header id.\n      *\n+     * @param type the header id\n      * @return null if no such field exists.\n      */\n     public ZipExtraField getExtraField(ZipShort type) {\n \n     /**\n      * Sets the central directory part of extra fields.\n+     * @param b an array of bytes to be parsed into extra fields\n      */\n     public void setCentralDirectoryExtra(byte[] b) {\n         try {\n      * <p>This method will return null if this instance has not been\n      * read from an archive.</p>\n      *\n+     * @return the raw name bytes\n      * @since 1.2\n      */\n     public byte[] getRawName() {\n \n     /**\n      * The \"general purpose bit\" field.\n+     * @return the general purpose bit\n      * @since 1.1\n      */\n     public GeneralPurposeBit getGeneralPurposeBit() {\n \n     /**\n      * The \"general purpose bit\" field.\n+     * @param b the general purpose bit\n      * @since 1.1\n      */\n     public void setGeneralPurposeBit(GeneralPurposeBit b) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n     }\n \n     /**\n+     * Create an instance using the specified encoding\n+     * @param inputStream the stream to wrap\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n      * @since 1.5\n     }\n \n     /**\n+     * Create an instance using the specified encoding\n+     * @param inputStream the stream to wrap\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n      * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     }\n \n     /**\n+     * Create an instance using the specified encoding\n+     * @param inputStream the stream to wrap\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n      * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n      * encoding is UTF-8.\n      *\n      * <p>Defaults to true.</p>\n+     *\n+     * @param b whether to set the language encoding flag if the file\n+     * name encoding is UTF-8\n      */\n     public void setUseLanguageEncodingFlag(boolean b) {\n         useUTF8Flag = b && ZipEncodingHelper.isUTF8(encoding);\n      * Whether to create Unicode Extra Fields.\n      *\n      * <p>Defaults to NEVER.</p>\n+     *\n+     * @param b whether to create Unicode Extra Fields.\n      */\n     public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\n         createUnicodeExtraFields = b;\n      * the file name cannot be encoded using the specified encoding.\n      *\n      * <p>Defaults to false.</p>\n+     *\n+     * @param b whether to fall back to UTF and the language encoding\n+     * flag if the file name cannot be encoded using the specified\n+     * encoding.\n      */\n     public void setFallbackToUTF8(boolean b) {\n         fallbackToUTF8 = b;\n      * case the default is {@link Zip64Mode#Never Never}.</p>\n      *\n      * @since 1.3\n+     * @param mode Whether Zip64 extensions will be used.\n      */\n     public void setUseZip64(Zip64Mode mode) {\n         zip64Mode = mode;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncoding.java\n      *         beginning of the encoded result, the byte buffer has a\n      *         backing array and the limit of the byte buffer points\n      *         to the end of the encoded result.\n-     * @throws IOException \n+     * @throws IOException on error\n      */\n     ByteBuffer encode(String name) throws IOException;\n \n     /**\n      * @param data The byte values to decode.\n      * @return The decoded string.\n-     * @throws IOException \n+     * @throws IOException on error\n      */\n     String decode(byte [] data) throws IOException;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * <p>May return false if it is set up to use encryption or a\n      * compression method that hasn't been implemented yet.</p>\n      * @since 1.1\n+     * @param ze the entry\n+     * @return whether this class is able to read the given entry.\n      */\n     public boolean canReadEntryData(ZipArchiveEntry ze) {\n         return ZipUtil.canHandleEntryData(ze);\n      *\n      * @param target The zipArchiveOutputStream to write the entries to\n      * @param predicate A predicate that selects which entries to write\n+     * @throws IOException on error\n      */\n     public void copyRawEntries(ZipArchiveOutputStream target, ZipArchiveEntryPredicate predicate)\n             throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n     /**\n      * returns the {@link ZipMethod} for the given code or null if the\n      * method is not known.\n+     * @param code the code\n+     * @return the {@link ZipMethod} for the given code or null if the\n+     * method is not known.\n      */\n     public static ZipMethod getMethodByCode(int code) {\n         return codeToEnum.get(code);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n     /**\n      * Converts DOS time to Java time (number of milliseconds since\n      * epoch).\n+     * @param dosTime time to convert\n+     * @return converted time\n      */\n     public static long dosToJavaTime(long dosTime) {\n         Calendar cal = Calendar.getInstance();\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n      * read from the specified stream. This doesn't suppprt decompressing\n      * concatenated .bz2 files.\n      * \n+     * @param in the InputStream from which this object should be created\n      * @throws IOException\n      *             if the stream content is malformed or an I/O error occurs.\n      * @throws NullPointerException\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n    \n     /**\n      * Creates a Deflate compressed output stream with the default parameters.\n+     * @param outputStream the stream to wrap\n+     * @throws IOException on error\n      */\n     public DeflateCompressorOutputStream(OutputStream outputStream) throws IOException {\n         this(outputStream, new DeflateParameters());\n \n     /**\n      * Creates a Deflate compressed output stream with the specified parameters.\n+     * @param outputStream the stream to wrap\n+     * @param parameters the deflate parameters to apply\n+     * @throws IOException on error\n      */\n     public DeflateCompressorOutputStream(OutputStream outputStream,\n                                          DeflateParameters parameters) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n      *\n      * <p>When reading from a file the File-arg constructor may\n      * provide better performance.</p>\n+     *\n+     * @param in the InputStream from which this object should be created\n      */\n     public Pack200CompressorInputStream(final InputStream in)\n         throws IOException {\n      *\n      * <p>When reading from a file the File-arg constructor may\n      * provide better performance.</p>\n+     *\n+     * @param in the InputStream from which this object should be created\n+     * @param mode the strategy to use\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Pack200Strategy mode)\n      *\n      * <p>When reading from a file the File-arg constructor may\n      * provide better performance.</p>\n+     *\n+     * @param in the InputStream from which this object should be created\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Map<String, String> props)\n      *\n      * <p>When reading from a file the File-arg constructor may\n      * provide better performance.</p>\n+     *\n+     * @param in the InputStream from which this object should be created\n+     * @param mode the strategy to use\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Pack200Strategy mode,\n     /**\n      * Decompresses the given file, caching the decompressed data in\n      * memory.\n+     *\n+     * @param f the file to decompress\n      */\n     public Pack200CompressorInputStream(final File f) throws IOException {\n         this(f, Pack200Strategy.IN_MEMORY);\n     /**\n      * Decompresses the given file using the given strategy to cache\n      * the results.\n+     *\n+     * @param f the file to decompress\n+     * @param mode the strategy to use\n      */\n     public Pack200CompressorInputStream(final File f, final Pack200Strategy mode)\n         throws IOException {\n     /**\n      * Decompresses the given file, caching the decompressed data in\n      * memory and using the given properties.\n+     *\n+     * @param f the file to decompress\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorInputStream(final File f,\n                                         final Map<String, String> props)\n     /**\n      * Decompresses the given file using the given strategy to cache\n      * the results and the given properties.\n+     *\n+     * @param f the file to decompress\n+     * @param mode the strategy to use\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorInputStream(final File f, final Pack200Strategy mode,\n                                         final Map<String, String> props)\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n     /**\n      * Compresses the given stream, caching the compressed data in\n      * memory.\n+     *\n+     * @param out the stream to write to\n      */\n     public Pack200CompressorOutputStream(final OutputStream out)\n         throws IOException {\n     /**\n      * Compresses the given stream using the given strategy to cache\n      * the results.\n+     *\n+     * @param out the stream to write to\n+     * @param mode the strategy to use\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Pack200Strategy mode)\n     /**\n      * Compresses the given stream, caching the compressed data in\n      * memory and using the given properties.\n+     *\n+     * @param out the stream to write to\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Map<String, String> props)\n     /**\n      * Compresses the given stream using the given strategy to cache\n      * the results and the given properties.\n+     *\n+     * @param out the stream to write to\n+     * @param mode the strategy to use\n+     * @param props Pack200 properties to use\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Pack200Strategy mode,\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n \n     /**\n      * Creates a new XZ compressor using the default LZMA2 options.\n-     * This is equivalent to <code>XZCompressorOutputStream(6)</code>.\n+     * This is equivalent to <code>XZCompressorOutputStream(outputStream, 6)</code>.\n+     * @param outputStream the stream to wrap\n+     * @throws IOException on error\n      */\n     public XZCompressorOutputStream(OutputStream outputStream)\n             throws IOException {\n      * Unless the uncompressed size of the file exceeds 8&nbsp;MiB,\n      * 16&nbsp;MiB, or 32&nbsp;MiB, it is waste of memory to use the\n      * presets 7, 8, or 9, respectively.\n+     * @param outputStream the stream to wrap\n+     * @param preset the preset\n+     * @throws IOException on error\n      */\n     public XZCompressorOutputStream(OutputStream outputStream, int preset)\n             throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n     /**\n      * Are the classes required to support XZ compression available?\n      * @since 1.5\n+     * @return true if the classes required to support XZ compression are available\n      */\n     public static boolean isXZCompressionAvailable() {\n         final CachedAvailability cachedResult = cachedXZAvailability;\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n      * d     100 testfiles\n      * </pre>\n      * \n+     * @param entry the entry\n      * @return the representation of the entry\n      */\n     public static String toString(ArchiveEntry entry){\n     /**\n      * Check if buffer contents matches Ascii String.\n      * \n-     * @param expected\n-     * @param buffer\n-     * @param offset\n-     * @param length\n+     * @param expected expected string\n+     * @param buffer the buffer\n+     * @param offset offset to read from\n+     * @param length length of the buffer\n      * @return {@code true} if buffer is the same as the expected string\n      */\n     public static boolean matchAsciiBuffer(\n     /**\n      * Check if buffer contents matches Ascii String.\n      * \n-     * @param expected\n-     * @param buffer\n+     * @param expected the expected strin\n+     * @param buffer the buffer\n      * @return {@code true} if buffer is the same as the expected string\n      */\n     public static boolean matchAsciiBuffer(String expected, byte[] buffer){\n      * Convert a string to Ascii bytes.\n      * Used for comparing \"magic\" strings which need to be independent of the default Locale.\n      * \n-     * @param inputString\n+     * @param inputString string to convert\n      * @return the bytes\n      */\n     public static byte[] toAsciiBytes(String inputString){\n     /**\n      * Convert an input byte array to a String using the ASCII character set.\n      * \n-     * @param inputBytes\n+     * @param inputBytes bytes to convert\n      * @return the bytes, interpreted as an Ascii string\n      */\n     public static String toAsciiString(final byte[] inputBytes){\n     /**\n      * Compare byte buffers, optionally ignoring trailing nulls\n      * \n-     * @param buffer1\n-     * @param offset1\n-     * @param length1\n-     * @param buffer2\n-     * @param offset2\n-     * @param length2\n-     * @param ignoreTrailingNulls\n+     * @param buffer1 first buffer\n+     * @param offset1 first offset\n+     * @param length1 first length\n+     * @param buffer2 second buffer\n+     * @param offset2 second offset\n+     * @param length2 second length\n+     * @param ignoreTrailingNulls whether to ignore trailing nulls\n      * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls\n      */\n     public static boolean isEqual(\n     /**\n      * Compare byte buffers\n      * \n-     * @param buffer1\n-     * @param offset1\n-     * @param length1\n-     * @param buffer2\n-     * @param offset2\n-     * @param length2\n+     * @param buffer1 the first buffer\n+     * @param offset1 the first offset\n+     * @param length1 the first length\n+     * @param buffer2 the second buffer\n+     * @param offset2 the second offset\n+     * @param length2 the second length\n      * @return {@code true} if buffer1 and buffer2 have same contents\n      */\n     public static boolean isEqual(\n     /**\n      * Compare byte buffers\n      * \n-     * @param buffer1\n-     * @param buffer2\n+     * @param buffer1 the first buffer\n+     * @param buffer2 the second buffer\n      * @return {@code true} if buffer1 and buffer2 have same contents\n      */\n     public static boolean isEqual(final byte[] buffer1, final byte[] buffer2 ){\n     /**\n      * Compare byte buffers, optionally ignoring trailing nulls\n      * \n-     * @param buffer1\n-     * @param buffer2\n-     * @param ignoreTrailingNulls\n+     * @param buffer1 the first buffer\n+     * @param buffer2 the second buffer \n+     * @param ignoreTrailingNulls whether to ignore tariling nulls\n      * @return {@code true} if buffer1 and buffer2 have same contents\n      */\n     public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, boolean ignoreTrailingNulls){\n     /**\n      * Compare byte buffers, ignoring trailing nulls\n      * \n-     * @param buffer1\n-     * @param offset1\n-     * @param length1\n-     * @param buffer2\n-     * @param offset2\n-     * @param length2\n+     * @param buffer1 the first buffer\n+     * @param offset1 the first offset\n+     * @param length1 the first length\n+     * @param buffer2 the second buffer\n+     * @param offset2 the second offset\n+     * @param length2 the second length\n      * @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls\n      */\n     public static boolean isEqualWithNull(\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n      * @return the bits concatenated as a long using the stream's byte order.\n      *         -1 if the end of the underlying stream has been reached before reading\n      *         the requested number of bits\n+     * @throws IOException on error\n      */\n     public long readBits(final int count) throws IOException {\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n--- a/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n  */\n public class CRC32VerifyingInputStream extends ChecksumVerifyingInputStream {\n     \n+    /**\n+     * @param in the stream to wrap\n+     * @param size the of the stream's content\n+     * @param expectedCrc32 the expected checksum\n+     */\n     public CRC32VerifyingInputStream(final InputStream in, final long size, final int expectedCrc32) {\n         this(in, size, expectedCrc32 & 0xFFFFffffl);\n     }\n \n     /**\n      * @since 1.7\n+     * @param in the stream to wrap\n+     * @param size the of the stream's content\n+     * @param expectedCrc32 the expected checksum\n      */\n     public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\n         super(new CRC32(), in, size, expectedCrc32);\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n      *            the InputStream to copy\n      * @param output\n      *            the target Stream\n+     * @return the number of bytes copied\n      * @throws IOException\n      *             if an error occurs\n      */\n      *            the target Stream\n      * @param buffersize\n      *            the buffer size to use\n+     * @return the number of bytes copied\n      * @throws IOException\n      *             if an error occurs\n      */\n      * @param input stream to skip bytes in\n      * @param numToSkip the number of bytes to skip\n      * @return the number of bytes actually skipped\n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public static long skip(InputStream input, long numToSkip) throws IOException {\n         long available = numToSkip;\n      * @param input stream to read from\n      * @param b buffer to fill\n      * @return the number of bytes actually read\n-     * @throws IOException\n+     * @throws IOException on error\n      */\n     public static int readFully(InputStream input, byte[] b) throws IOException {\n         return readFully(input, b, 0, b.length);", "timestamp": 1439349847, "metainfo": ""}