{"sha": "c0932797ed15a9e0f49617b5b96bcb0f7827bc35", "log": "consolidate little endian conversions", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n package org.apache.commons.compress.archivers.dump;\n \n import java.io.IOException;\n+import java.util.Arrays;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.utils.ByteUtils;\n \n /**\n  * Various utilities for dump archives.\n      * @return the 8-byte entry as a long\n      */\n     public static final long convert64(final byte[] buffer, final int offset) {\n-        long i = 0;\n-        i += (((long) buffer[offset + 7]) << 56);\n-        i += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\n-        i += (((long) buffer[offset + 5] << 40) & 0x0000FF0000000000L);\n-        i += (((long) buffer[offset + 4] << 32) & 0x000000FF00000000L);\n-        i += (((long) buffer[offset + 3] << 24) & 0x00000000FF000000L);\n-        i += (((long) buffer[offset + 2] << 16) & 0x0000000000FF0000L);\n-        i += (((long) buffer[offset + 1] << 8) & 0x000000000000FF00L);\n-        i += (buffer[offset] & 0x00000000000000FFL);\n-\n-        return i;\n+        return ByteUtils.fromLittleEndian(buffer, offset, 8);\n     }\n \n     /**\n      * @return the 4-byte entry as an int\n      */\n     public static final int convert32(final byte[] buffer, final int offset) {\n-        int i = 0;\n-        i = buffer[offset + 3] << 24;\n-        i += (buffer[offset + 2] << 16) & 0x00FF0000;\n-        i += (buffer[offset + 1] << 8) & 0x0000FF00;\n-        i += buffer[offset] & 0x000000FF;\n-\n-        return i;\n+        return (int) ByteUtils.fromLittleEndian(buffer, offset, 4);\n     }\n \n     /**\n      * @return the 2-byte entry as an int\n      */\n     public static final int convert16(final byte[] buffer, final int offset) {\n-        int i = 0;\n-        i += (buffer[offset + 1] << 8) & 0x0000FF00;\n-        i += buffer[offset] & 0x000000FF;\n-\n-        return i;\n+        return (int) ByteUtils.fromLittleEndian(buffer, offset, 2);\n     }\n \n     /**\n      */\n     static String decode(final ZipEncoding encoding, final byte[] b, final int offset, final int len)\n         throws IOException {\n-        final byte[] copy = new byte[len];\n-        System.arraycopy(b, offset, copy, 0, len);\n-        return encoding.decode(copy);\n+        return encoding.decode(Arrays.copyOfRange(b, offset, offset + len));\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMADecoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMADecoder.java\n import java.io.InputStream;\n import java.io.OutputStream;\n \n+import org.apache.commons.compress.utils.ByteUtils;\n import org.apache.commons.compress.utils.FlushShieldFilterOutputStream;\n import org.tukaani.xz.LZMA2Options;\n import org.tukaani.xz.LZMAInputStream;\n         final LZMA2Options options = getOptions(opts);\n         final byte props = (byte) ((options.getPb() * 5 + options.getLp()) * 9 + options.getLc());\n         int dictSize = options.getDictSize();\n-        return new byte[] {\n-            props,\n-            (byte) (dictSize & 0xff),\n-            (byte) ((dictSize >> 8) & 0xff),\n-            (byte) ((dictSize >> 16) & 0xff),\n-            (byte) ((dictSize >> 24) & 0xff),\n-        };\n+        byte[] o = new byte[5];\n+        o[0] = props;\n+        ByteUtils.toLittleEndian(o, dictSize, 1, 4);\n+        return o;\n     }\n \n     @Override\n     }\n \n     private int getDictionarySize(final Coder coder) throws IllegalArgumentException {\n-        long dictSize = coder.properties[1];\n-        for (int i = 1; i < 4; i++) {\n-            dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n-        }\n-        return (int) dictSize;\n+        return (int) ByteUtils.fromLittleEndian(coder.properties, 1, 4);\n     }\n \n     private LZMA2Options getOptions(final Object opts) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n \n /**\n  * Utility class that represents an eight byte integer with conversion\n- * rules for the big endian byte order of ZIP files.\n+ * rules for the little endian byte order of ZIP files.\n  * @Immutable\n  *\n  * @since 1.2\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n \n import java.io.Serializable;\n \n-import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import org.apache.commons.compress.utils.ByteUtils;\n+\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n \n /**\n  * Utility class that represents a four byte integer with conversion\n- * rules for the big endian byte order of ZIP files.\n+ * rules for the little endian byte order of ZIP files.\n  * @Immutable\n  */\n public final class ZipLong implements Cloneable, Serializable {\n     private static final long serialVersionUID = 1L;\n-\n-    //private static final int BYTE_BIT_SIZE = 8;\n-\n-    private static final int BYTE_1 = 1;\n-    private static final int BYTE_1_MASK = 0xFF00;\n-    private static final int BYTE_1_SHIFT = 8;\n-\n-    private static final int BYTE_2 = 2;\n-    private static final int BYTE_2_MASK = 0xFF0000;\n-    private static final int BYTE_2_SHIFT = 16;\n-\n-    private static final int BYTE_3 = 3;\n-    private static final long BYTE_3_MASK = 0xFF000000L;\n-    private static final int BYTE_3_SHIFT = 24;\n \n     private final long value;\n \n      */\n \n     public static void putLong(final long value, final byte[] buf, int offset) {\n-        buf[offset++] = (byte) ((value & BYTE_MASK));\n-        buf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n-        buf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\n-        buf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n+        ByteUtils.toLittleEndian(buf, value, offset, 4);\n     }\n \n     public void putLong(final byte[] buf, final int offset) {\n      * @return the corresponding Java long value\n      */\n     public static long getValue(final byte[] bytes, final int offset) {\n-        long value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\n-        value += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\n-        value += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n-        value += (bytes[offset] & BYTE_MASK);\n-        return value;\n+        return ByteUtils.fromLittleEndian(bytes, offset, 4);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n \n import java.io.Serializable;\n \n-import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import org.apache.commons.compress.utils.ByteUtils;\n \n /**\n  * Utility class that represents a two byte integer with conversion\n- * rules for the big endian byte order of ZIP files.\n+ * rules for the little endian byte order of ZIP files.\n  * @Immutable\n  */\n public final class ZipShort implements Cloneable, Serializable {\n     private static final long serialVersionUID = 1L;\n-\n-    private static final int BYTE_1_MASK = 0xFF00;\n-    private static final int BYTE_1_SHIFT = 8;\n \n     private final int value;\n \n      */\n     public byte[] getBytes() {\n         final byte[] result = new byte[2];\n-        result[0] = (byte) (value & BYTE_MASK);\n-        result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        ByteUtils.toLittleEndian(result, value, 0, 2);\n         return result;\n     }\n \n      *         must be non-negative and no larger than <tt>buf.length-2</tt>\n      */\n     public static void putShort(final int value, final byte[] buf, final int offset) {\n-        buf[offset] = (byte) (value & BYTE_MASK);\n-        buf[offset+1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        ByteUtils.toLittleEndian(buf, value, offset, 2);\n     }\n \n     /**\n      * @return the corresponding java int value\n      */\n     public static int getValue(final byte[] bytes, final int offset) {\n-        int value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n-        value += (bytes[offset] & BYTE_MASK);\n-        return value;\n+        return (int) ByteUtils.fromLittleEndian(bytes, offset, 2);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n import java.io.IOException;\n import java.io.EOFException;\n import java.io.InputStream;\n+import java.io.DataInput;\n import java.io.DataInputStream;\n import java.io.BufferedInputStream;\n import java.util.zip.DataFormatException;\n import java.util.zip.CRC32;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n         }\n \n         // Parsing the rest of the header may throw EOFException.\n-        final DataInputStream inData = new DataInputStream(in);\n+        final DataInput inData = new DataInputStream(in);\n         final int method = inData.readUnsignedByte();\n         if (method != Deflater.DEFLATED) {\n             throw new IOException(\"Unsupported compression method \"\n                     \"Reserved flags are set in the .gz header\");\n         }\n \n-        parameters.setModificationTime(readLittleEndianInt(inData) * 1000);\n+        parameters.setModificationTime(ByteUtils.fromLittleEndian(inData, 4) * 1000);\n         switch (inData.readUnsignedByte()) { // extra flags\n         case 2:\n             parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\n         return true;\n     }\n \n-    private static byte[] readToNull(final DataInputStream inData) throws IOException {\n+    private static byte[] readToNull(final DataInput inData) throws IOException {\n         final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int b = 0;\n         while ((b = inData.readUnsignedByte()) != 0x00) { // NOPMD\n             bos.write(b);\n         }\n         return bos.toByteArray();\n-    }\n-\n-    private static long readLittleEndianInt(final DataInputStream inData) throws IOException {\n-        return inData.readUnsignedByte()\n-            | (inData.readUnsignedByte() << 8)\n-            | (inData.readUnsignedByte() << 16)\n-            | (((long) inData.readUnsignedByte()) << 24);\n     }\n \n     @Override\n \n                 bufUsed = 0;\n \n-                final DataInputStream inData = new DataInputStream(in);\n+                final DataInput inData = new DataInputStream(in);\n \n                 // CRC32\n-                final long crcStored = readLittleEndianInt(inData);\n+                final long crcStored = ByteUtils.fromLittleEndian(inData, 4);\n \n                 if (crcStored != crc.getValue()) {\n                     throw new IOException(\"Gzip-compressed data is corrupt \"\n                 }\n \n                 // Uncompressed size modulo 2^32 (ISIZE in the spec)\n-                final long isize = readLittleEndianInt(inData);\n+                final long isize = ByteUtils.fromLittleEndian(inData, 4);\n \n                 if (isize != (inf.getBytesWritten() & 0xffffffffl)) {\n                     throw new IOException(\"Gzip-compressed data is corrupt\"", "timestamp": 1485263615, "metainfo": ""}