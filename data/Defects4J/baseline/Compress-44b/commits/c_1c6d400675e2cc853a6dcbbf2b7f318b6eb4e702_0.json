{"sha": "1c6d400675e2cc853a6dcbbf2b7f318b6eb4e702", "log": "implement infrastructure and \"no references to find\" case", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n  * <p>This class attempts to extract the core logic - finding\n  * back-references - so it can be re-used. It follows the algorithm\n  * explained in section 4 of RFC 1951 (DEFLATE) and currently doesn't\n- * implement the \"lazy match\" optimization. The three-byte hash function\n- * used in this class is the same used by zlib and InfoZIP's ZIP\n- * implementation of DEFLATE.</p>\n+ * implement the \"lazy match\" optimization. The three-byte hash\n+ * function used in this class is the same used by zlib and InfoZIP's\n+ * ZIP implementation of DEFLATE. Strongly inspired by InfoZIP's\n+ * implementation.</p>\n  *\n  * <p>LZ77 is used vaguely here (as well as many other places that\n  * talk about it :-), LZSS would likely be closer to the truth but\n     public static abstract class Block { }\n     /**\n      * Represents a literal block of data.\n+     *\n+     * <p>For performance reasons this encapsulates the real data, not\n+     * a copy of it. Don't modify the data and process it inside of\n+     * {@link Callback#accept} immediately as it will get overwritten\n+     * sooner or later.</p>\n      */\n     public static final class LiteralBlock extends Block {\n         private final byte[] data;\n-        private LiteralBlock(byte[] data) {\n+        private final int offset, length;\n+        /* package private for tests */ LiteralBlock(byte[] data, int offset, int length) {\n             this.data = data;\n+            this.offset = offset;\n+            this.length = length;\n         }\n         /**\n          * The literal data.\n         public byte[] getData() {\n             return data;\n         }\n+        /**\n+         * Offset into data where the literal block starts.\n+         */\n+        public int getOffset() {\n+            return offset;\n+        }\n+        /**\n+         * Length of literal block.\n+         */\n+        public int getLength() {\n+            return length;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LiteralBlock starting at \" + offset + \" with length \" + length;\n+        }\n     }\n     /**\n      * Represents a back-reference to a match.\n         public int getLength() {\n             return length;\n         }\n+\n+        @Override\n+        public String toString() {\n+            return \"BackReference with \" + offset + \" and length \" + length;\n+        }\n     }\n     /**\n      * A simple \"we are done\" marker.\n      */\n     public static final class EOD extends Block { }\n+\n+    private static final EOD THE_EOD = new EOD();\n \n     /**\n      * Callback invoked while the compressor processes data.\n         void accept(Block b);\n     }\n \n+    static final int NUMBER_OF_BYTES_IN_HASH = 3;\n+    private static final int NO_MATCH = -1;\n+\n     private final Parameters params;\n     private final Callback callback;\n+\n+    // the sliding window, twice as big as \"windowSize\" parameter\n+    private final byte[] window;\n+    // the head of hash-chain - indexed by hash-code, points to the\n+    // location inside of window of the latest sequence of bytes with\n+    // the given hash.\n+    private final int[] head;\n+    // for each window-location points to the latest earlier location\n+    // with the same hash. Only stored values for the latest\n+    // \"windowSize\" elements, the index is \"window location modulo\n+    // windowSize\".\n+    private final int[] prev;\n+\n+    // bit mask used when indexing into prev\n+    private final int wMask;\n+\n+    private boolean initialized = false;\n+    // the position inside of window that shall be encoded right now\n+    private int currentPosition;\n+    // the number of bytes available to compress including the one at\n+    // currentPosition\n+    private int lookahead = 0;\n+    // the hash of the three bytes stating at the current position\n+    private int insertHash = 0;\n+    // the position inside of the window where the current literal\n+    // block starts (in case we are inside of a literal block).\n+    private int blockStart = 0;\n+    // position of the current match\n+    private int matchStart = NO_MATCH;\n \n     /**\n      * Initializes a compressor with parameters and a callback.\n         }\n         this.params = params;\n         this.callback = callback;\n+\n+        final int wSize = params.getWindowSize();\n+        window = new byte[wSize * 2];\n+        wMask = wSize - 1;\n+        head = new int[HASH_SIZE];\n+        for (int i = 0; i < HASH_SIZE; i++) {\n+            head[i] = NO_MATCH;\n+        }\n+        prev = new int[wSize];\n     }\n \n     /**\n      * @param len the number of bytes to compress\n      */\n     public void compress(byte[] data, int off, int len) {\n+        final int wSize = params.getWindowSize();\n+        while (len > wSize) {\n+            doCompress(data, off, wSize);\n+            off += wSize;\n+            len -= wSize;\n+        }\n+        if (len > 0) {\n+            doCompress(data, off, len);\n+        }\n     }\n \n     /**\n      * the execution of this method.</p>\n      */\n     public void finish() {\n-    }\n-\n+        if (blockStart != currentPosition || lookahead > 0) {\n+            currentPosition += lookahead;\n+            flushLiteralBlock();\n+        }\n+        callback.accept(THE_EOD);\n+    }\n+\n+    // we use a 15 bit hashcode as calculated in updateHash\n+    private static final int HASH_SIZE = 1 << 15;\n+    private static final int HASH_MASK = HASH_SIZE - 1;\n+    private static final int H_SHIFT = 5;\n+\n+    /**\n+     * Assumes we are calculating the hash for three consecutive bytes\n+     * as a rolling hash, i.e. for bytes ABCD if H is the hash of ABC\n+     * the new hash for BCD is nextHash(H, D).\n+     *\n+     * <p>The hash is shifted by five bits on each update so all\n+     * effects of A have been swapped after the third update.</p>\n+     */\n+    private int nextHash(int oldHash, byte nextByte) {\n+        final int nextVal = nextByte & 0xFF;\n+        return ((oldHash << H_SHIFT) ^ nextVal) & HASH_MASK;\n+    }\n+\n+    // performs the actual algorithm with the pre-condition len <= windowSize\n+    private void doCompress(byte[] data, int off, int len) {\n+        int spaceLeft = window.length - currentPosition - lookahead;\n+        if (len > spaceLeft) {\n+            slide();\n+        }\n+        System.arraycopy(data, off, window, currentPosition + lookahead, len);\n+        lookahead += len;\n+        if (!initialized && lookahead >= params.getMinMatchSize()) {\n+            initialize();\n+        }\n+        if (initialized) {\n+            compress();\n+        }\n+    }\n+\n+    private void slide() {\n+        final int wSize = params.getWindowSize();\n+        System.arraycopy(window, wSize, window, 0, wSize);\n+        currentPosition -= wSize;\n+        matchStart -= wSize;\n+        blockStart -= wSize;\n+        for (int i = 0; i< HASH_SIZE; i++) {\n+            int h = head[i];\n+            head[i] = h >= wSize ? h - wSize : NO_MATCH;\n+        }\n+        for (int i = 0; i < wSize; i++) {\n+            int p = prev[i];\n+            prev[i] = p >= wSize ? p - wSize : NO_MATCH;\n+        }\n+    }\n+\n+    private void initialize() {\n+        for (int i = 0; i < NUMBER_OF_BYTES_IN_HASH - 1; i++) {\n+            insertHash = nextHash(insertHash, window[i]);\n+        }\n+        initialized = true;\n+    }\n+\n+    private void compress() {\n+        final int minMatch = params.getMinMatchSize();\n+\n+        while (lookahead >= minMatch) {\n+            int matchLength = 0;\n+            int hashHead = insertString();\n+            if (hashHead != NO_MATCH && hashHead - currentPosition <= params.getMaxOffset()) {\n+                // sets matchStart as a side effect\n+                matchLength = longestMatch(hashHead);\n+            }\n+            if (matchLength >= minMatch) {\n+                if (blockStart != currentPosition) {\n+                    // emit preceeding literal block\n+                    flushLiteralBlock();\n+                    blockStart = NO_MATCH;\n+                }\n+                lookahead -= matchLength;\n+                // inserts strings contained in current match\n+                for (int i = 0; i < matchLength - 1; i++) {\n+                    currentPosition++;\n+                    insertString();\n+                }\n+                currentPosition++;\n+                flushBackReference(matchLength);\n+                blockStart = currentPosition;\n+            } else {\n+                // no match, append to current or start a new literal\n+                lookahead--;\n+                currentPosition++;\n+                if (currentPosition - blockStart >= params.getMaxLiteralSize()) {\n+                    flushLiteralBlock();\n+                    blockStart = currentPosition;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Inserts the current three byte sequence into the dictionary and\n+     * returns the previous previous head of the hash-chain.\n+     *\n+     * <p>Updates <code>insertHash</code> and <code>prev</code> as a\n+     * side effect.</p>\n+     */\n+    private int insertString() {\n+        insertHash = nextHash(insertHash, window[currentPosition -1 + NUMBER_OF_BYTES_IN_HASH]);\n+        int hashHead = head[insertHash];\n+        prev[currentPosition & wMask] = hashHead;\n+        head[insertHash] = currentPosition;\n+        return hashHead;\n+    }\n+\n+    private void flushBackReference(int matchLength) {\n+        callback.accept(new BackReference(matchStart, matchLength));\n+    }\n+\n+    private void flushLiteralBlock() {\n+        callback.accept(new LiteralBlock(window, blockStart, currentPosition - blockStart));\n+    }\n+\n+    private int longestMatch(int matchHead) {\n+        return 0;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n  * Parameters of the {@link LZ77Compressor compressor}.\n  */\n public final class Parameters {\n-    public static final int TRUE_MIN_MATCH_SIZE = 3;\n+    public static final int TRUE_MIN_MATCH_SIZE = LZ77Compressor.NUMBER_OF_BYTES_IN_HASH;\n     private final int windowSize, minMatchSize, maxMatchSize, maxOffset, maxLiteralSize;\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/LZ77CompressorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class LZ77CompressorTest {\n+\n+    private List<LZ77Compressor.Block> compress(Parameters params, byte[]... chunks) {\n+        final List<LZ77Compressor.Block> blocks = new ArrayList<>();\n+        LZ77Compressor c = new LZ77Compressor(params, new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        // replace with a real copy of data so tests\n+                        // can see the results as they've been when\n+                        // the callback has been called\n+                        LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\n+                        int len = b.getLength();\n+                        block = new LZ77Compressor.LiteralBlock(\n+                            Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len),\n+                            0, len);\n+                    }\n+                    blocks.add(block);\n+                }\n+            });\n+        for (byte[] chunk : chunks) {\n+            c.compress(chunk);\n+        }\n+        c.finish();\n+        return blocks;\n+    }\n+\n+    @Test\n+    public void nonCompressableWithLengthSmallerThanLiteralMax() {\n+        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(128), data);\n+        assertEquals(2, blocks.size());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n+        assertArrayEquals(data, ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n+        assertEquals(LZ77Compressor.EOD.class, blocks.get(1).getClass());\n+    }\n+\n+    @Test\n+    public void nonCompressableWithLengthGreaterThanLiteralMaxButLessThanTwiceWindowSize() {\n+        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), data);\n+        assertEquals(3, blocks.size());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n+        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n+        assertArrayEquals(new byte[] { 9, 10 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n+        assertEquals(LZ77Compressor.EOD.class, blocks.get(2).getClass());\n+    }\n+\n+    @Test\n+    public void nonCompressableWithLengthThatForcesWindowSlide() {\n+        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(4), data);\n+        assertEquals(4, blocks.size());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n+        assertArrayEquals(new byte[] { 1, 2, 3, 4 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n+        assertArrayEquals(new byte[] { 5, 6, 7, 8 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(2).getClass());\n+        assertArrayEquals(new byte[] { 9, 10 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(2)).getData());\n+        assertEquals(LZ77Compressor.EOD.class, blocks.get(3).getClass());\n+    }\n+\n+    @Test\n+    public void nonCompressableSentAsSingleBytes() {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), new byte[][] {\n+                { 1 }, { 2 }, { 3 } , { 4 }, { 5 },\n+                { 6 }, { 7 }, { 8 } , { 9 }, { 10 },\n+            });\n+        assertEquals(3, blocks.size());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n+        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n+        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n+        assertArrayEquals(new byte[] { 9, 10 },\n+            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n+        assertEquals(LZ77Compressor.EOD.class, blocks.get(2).getClass());\n+    }\n+\n+}", "timestamp": 1483782453, "metainfo": ""}