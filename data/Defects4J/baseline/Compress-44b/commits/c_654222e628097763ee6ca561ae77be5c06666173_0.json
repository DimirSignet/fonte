{"sha": "654222e628097763ee6ca561ae77be5c06666173", "log": "typos and make PMD happy  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n      *\n      * I've added the fallbackSort function of 1.0.6 and tried to\n      * integrate it with the existing code without touching too much.\n-     * I've also removed the now unused reandomization code.\n+     * I've also removed the now unused randomization code.\n      */\n \n     /*\n                                     int[] eclass, \n                                     int lo, \n                                     int hi) {\n-        if (lo == hi) return;\n+        if (lo == hi) {\n+            return;\n+        }\n \n         int j;\n         if (hi - lo > 3) {\n             // in the cited Sedgewick paper\n             while (true) {\n                 while (true) {\n-                    if (unLo > unHi) break;\n+                    if (unLo > unHi) {\n+                        break;\n+                    }\n                     n = eclass[fmap[unLo]] - (int) med;\n                     if (n == 0) { \n                         fswap(fmap, unLo, ltLo); \n                         ltLo++; unLo++; \n                         continue; \n-                    };\n-                    if (n > 0) break;\n+                    }\n+                    if (n > 0) {\n+                        break;\n+                    }\n                     unLo++;\n                 }\n                 while (true) {\n-                    if (unLo > unHi) break;\n+                    if (unLo > unHi) {\n+                        break;\n+                    }\n                     n = eclass[fmap[unHi]] - (int) med;\n                     if (n == 0) {\n                         fswap(fmap, unHi, gtHi); \n                         gtHi--; unHi--; \n                         continue; \n-                    };\n-                    if (n < 0) break;\n+                    }\n+                    if (n < 0) {\n+                        break;\n+                    }\n                     unHi--;\n                 }\n-                if (unLo > unHi) break;\n+                if (unLo > unHi) {\n+                    break;\n+                }\n                 fswap(fmap, unLo, unHi); unLo++; unHi--;\n             }\n \n-            if (gtHi < ltLo) continue;\n+            if (gtHi < ltLo) {\n+                continue;\n+            }\n \n             n = fmin(ltLo - lo, unLo - ltLo);\n             fvswap(fmap, lo, unLo - n, n);\n         for (i = 0; i < nblock; i++) {\n             ftab[block[i] & 0xff]++;\n         }\n-        for (i = 1; i < 257;    i++) ftab[i] += ftab[i - 1];\n+        for (i = 1; i < 257;    i++) {\n+            ftab[i] += ftab[i - 1];\n+        }\n \n         for (i = 0; i < nblock; i++) {\n             j = block[i] & 0xff;\n \n         nBhtab = 64 + nblock;\n         BitSet bhtab = new BitSet(nBhtab);\n-        for (i = 0; i < 256; i++) bhtab.set(ftab[i]);\n+        for (i = 0; i < 256; i++) {\n+            bhtab.set(ftab[i]);\n+        }\n \n         /*--\n           LBZ2: Inductively refine the buckets.  Kind-of an\n                 k = r + 1;\n                 k = bhtab.nextClearBit(k);\n                 l = k - 1;\n-                if (l >= nblock) break;\n+                if (l >= nblock) {\n+                    break;\n+                }\n                 k = bhtab.nextSetBit(k + 1);\n                 r = k - 1;\n-                if (r >= nblock) break;\n+                if (r >= nblock) {\n+                    break;\n+                }\n \n                 /*-- LBZ2: now [l, r] bracket current bucket --*/\n                 if (r > l) {\n                         if (cc != cc1) {\n                             bhtab.set(i);\n                             cc = cc1;\n-                        };\n+                        }\n                     }\n                 }\n             }\n \n             H *= 2;\n-            if (H > nblock || nNotDone == 0) break;\n+            if (H > nblock || nNotDone == 0) {\n+                break;\n+            }\n         }\n     }\n ", "timestamp": 1337539310, "metainfo": ""}