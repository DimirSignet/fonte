{"sha": "88220840b463a195406648a93189f0321a5aa7e5", "log": "draft 8 from C. Grobmeier, grant has been received, cheers  ", "commit": "\n--- /dev/null\n+++ b/src/examples/org/apache/commons/compress/examples/BZip2Example.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.examples;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.CompressException;\n+import org.apache.commons.compress.Compressor;\n+import org.apache.commons.compress.CompressorFactory;\n+/**\n+ * BZIP2 .Example\n+ */\n+public class BZip2Example {\n+\t/**\n+\t * \n+\t */\n+\tpublic BZip2Example() {\n+\t\tsuper();\n+\t}\n+\t\n+\t/**\n+\t * Compression\n+\t */\n+\tpublic void compress() {\n+\t\tCompressor compressor;\n+\t\ttry {\n+\t\t\tcompressor = CompressorFactory.getInstance(\"bz2\");\n+\t\t\tcompressor.compressToHere( \n+\t\t\t\t\t\t\tnew File(\"C:\\\\Temp\\\\test.tar\"));\n+\t\t} catch (CompressException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * \n+\t */\n+\tpublic void compressStream() {\n+\t\tInputStream in = null;\n+\t\tFileOutputStream out = null;\n+\t\tFileInputStream param = null;\n+\t\ttry {\n+\t\t\t// Get a filestream\n+\t\t\tparam = new FileInputStream(\n+\t\t\t\t\t\tnew File(\"C:\\\\Temp\\\\test.tar\"));\n+\n+\t\t\t// get the compressor\n+\t\t\tCompressor compressor = CompressorFactory.getInstance(\"bz2\");\n+\n+\t\t\t// compress this stream and get back an readable inputstream\n+\t\t\tin = compressor.compress(param);\n+\t\t\t\t\n+\t\t\t// write this stream to a destination of your desire\n+\t\t\tFile f = new File(\"C:\\\\Temp\\\\test.tar.example.bz2\");\n+\t\t\tout = new FileOutputStream(f);\n+\t\t\tfinal byte[] buffer = new byte[ 8024 ];\n+\t        int n = 0;\n+\t        while( -1 != ( n = in.read( buffer ) ) ) {\n+\t            out.write( buffer, 0, n );\n+\t        }\n+\t\t} catch (CompressException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tout.close();\n+\t\t        in.close();\n+\t\t        param.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\te1.printStackTrace();\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Decompress a file.\n+\t */\n+\tpublic void decompress() {\n+\t\tCompressor decompressor;\n+\t\ttry {\n+//\t\t\tdecompressor = DecompressorFactory.BZIP2.getInstance();\n+\t\t\tdecompressor = CompressorFactory.getInstance(\"bz2\");\n+\t\t\t\n+\t\t\tdecompressor.decompressTo( \n+\t\t\t\t\t\t\tnew File(\"C:\\\\Temp\\\\asf-logo-huge.tar.bz2\"),\n+\t\t\t\t\t\t\tnew File(\"C:\\\\Temp\\\\asf-logo-huge.tar\"));\n+\t\t} catch (CompressException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\tpublic static void main(String[] args) {\n+\t\tnew BZip2Example().compress();\n+\t\tnew BZip2Example().decompress();\n+\t}\n+}\n+\n+\n+\n+\n+\n+\n--- /dev/null\n+++ b/src/examples/org/apache/commons/compress/examples/Bzip2Compress.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.examples;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.CompressUtils;\n+import org.apache.commons.compress.compressors.bzip2.BZip2OutputStream;\n+\n+/**\n+ * This simple example shows how to use the Bzip2 classes to compress a file.\n+ *\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ * @deprecated Take a look at Bzip2Example instead\n+ */\n+public class Bzip2Compress\n+{\n+    public static void main( final String[] args )\n+        throws Exception\n+    {\n+        if( 2 != args.length )\n+        {\n+            System.out.println( \"java Bzip2Compress <input> <output>\" );\n+            System.exit( 1 );\n+        }\n+\n+        final File source = new File( args[ 0 ] );\n+        final File destination = new File( args[ 1 ] );\n+        final BZip2OutputStream output =\n+            new BZip2OutputStream( new FileOutputStream( destination ) );\n+        final FileInputStream input = new FileInputStream( source );\n+        CompressUtils.copy( input, output );\n+        input.close();\n+        output.close();\n+    }\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.\n+     */\n+    private static void copy( final InputStream input,\n+                              final OutputStream output )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 8024 ];\n+        int n = 0;\n+        while( -1 != ( n = input.read( buffer ) ) )\n+        {\n+            output.write( buffer, 0, n );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/examples/org/apache/commons/compress/examples/Bzip2Uncompress.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.examples;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.CompressUtils;\n+import org.apache.commons.compress.compressors.bzip2.BZip2InputStream;\n+\n+/**\n+ * This simple example shows how to use the Bzip2 classes to uncompress a file.\n+ *\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @author <a href=\"mailto:nicolaken@apache.org\">Nicola Ken Barozzi</a>\n+ * @version $Revision: 155439 $ $Date$\n+ * @deprecated Take a look at Bzip2Example instead\n+ */\n+public class Bzip2Uncompress\n+{\n+    public static void main( final String[] args )\n+    {\n+      try\n+      {\n+        if( 2 != args.length )\n+        {\n+            System.out.println( \"java Bzip2Uncompress <input> <output>\" );\n+            System.exit( 1 );\n+        }\n+        final File source = new File( args[ 0 ] );\n+        final File destination = new File( args[ 1 ] );\n+        final FileOutputStream output =\n+            new FileOutputStream( destination );\n+        final BZip2InputStream input = new BZip2InputStream( new FileInputStream( source ) );\n+        CompressUtils.copy( input, output );\n+        input.close();\n+        output.close();\n+      }catch(Exception e){\n+        e.printStackTrace();\n+        System.exit(1);       \n+      \n+      }\n+    }\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.\n+     */\n+    private static void copy( final InputStream input,\n+                              final OutputStream output )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 8024 ];\n+        int n = 0;\n+        while( -1 != ( n = input.read( buffer ) ) )\n+        {\n+            output.write( buffer, 0, n );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/examples/org/apache/commons/compress/examples/TarExample.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.examples;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+\n+import org.apache.commons.compress.Archive;\n+import org.apache.commons.compress.ArchiveException;\n+import org.apache.commons.compress.ArchiverFactory;\n+\n+/**\n+ * @author christian.grobmeier\n+ */\n+public class TarExample {\n+\t/**\n+\t * \n+\t */\n+\tpublic TarExample() {\n+\t\tsuper();\n+\t}\n+\t\n+\t/**\n+\t * Example for Tar-packing\n+\t */\n+\tpublic void pack() {\n+\t\ttry {\n+\t\t\tArchive archiver = ArchiverFactory.getInstance(\"tar\");\n+\t\t\tarchiver.add( new File(\"C:\\\\Temp\\\\allclasses-frame.html\"));\n+\t\t\tarchiver.add( new File(\"C:\\\\Temp\\\\allclasses-frame.html.bz2\"));\n+\t\t\tarchiver.save(new File(\"C:\\\\Temp\\\\myTar.tar\"));\n+\t\t} catch (ArchiveException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\te.printStackTrace();\n+\t\t} \n+\t}\n+\t\n+\t/**\n+\t * Example for an unpack operation\n+\t */\n+\tpublic void unpack() {\n+\t\ttry {\n+\t\t\tArchive archiver = ArchiverFactory.getInstance( \n+\t\t\t\tnew File(\"C:\\\\Temp\\\\myTar.tar\"));\n+\t\t\tarchiver.unpack(new File(\"C:\\\\Temp\\\\unpacked\\\\\"));\n+\t\t} catch (ArchiveException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\tpublic static void main(String[] args) {\n+\t\tnew TarExample().pack();\n+\t\tnew TarExample().unpack();\n+\t}\n+}\n--- /dev/null\n+++ b/src/examples/org/apache/commons/compress/examples/ZipExample.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.examples;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+\n+import org.apache.commons.compress.Archive;\n+import org.apache.commons.compress.ArchiveException;\n+import org.apache.commons.compress.ArchiverFactory;\n+\n+/**\n+ * Example for how to use the TarArchive \n+ */\n+public class ZipExample {\n+\t/**\n+\t * Example for an pack operation \n+\t */\n+\tpublic void pack() {\n+\t\ttry {\n+\t\t\tArchive archiver = ArchiverFactory.getInstance(\"zip\");\n+\t\t\tarchiver.add(\tnew File(\"C:\\\\Temp\\\\1.html\"));\n+\t\t\tarchiver.add(\tnew File(\"C:\\\\Temp\\\\1.html.bz2\"));\n+\t\t\tarchiver.save(\tnew File(\"C:\\\\Temp\\\\ZIPTEST.zip\"));\n+\t\t} catch (ArchiveException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Example for an unpack operation\n+\t */\n+\tpublic void unpack() {\n+\t\ttry {\n+\t\t\tArchive archiver = ArchiverFactory.getInstance(\n+\t\t\t\t\tnew File(\"C:\\\\Temp\\\\ZIPTEST.zip\"));\n+\t\t\tarchiver.unpack( new File(\"C:\\\\Temp\\\\unpacked\\\\\"));\n+\t\t} catch (ArchiveException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\tpublic static void main (String argv[]) {\n+\t\tnew ZipExample().pack();\n+\t\tnew ZipExample().unpack();\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/AbstractArchive.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+/**\n+ * Abstract implementation of an archiver\n+ */\n+public abstract class AbstractArchive extends PackableObject implements Archive {\n+\t\n+\t/* hold filestreams for a possible pack operation */\n+\tprivate ArrayList entries = new ArrayList();\n+\t\n+\t/* the source of an unpack-operation */\n+\tprivate File archive = null;\n+\n+\tpublic Archive newInstance() {\n+\t\treturn this.newInstance();\n+\t}\n+\t/**\n+\t * Compresses the file with the given String as a filename\n+\t * @see org.apache.commons.compress.Archive#save(java.lang.String)\n+\t */\n+\tpublic void save(File output) throws ArchiveException {\n+\t\tif(output == null) {\n+\t\t\tthrow new ArchiveException(\"Destination directory must not be null.\");\n+\t\t}\n+\t\ttry {\n+\t\t\tthis.save(new FileOutputStream(output));\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new ArchiveException(\"This path is not writeable\", e);\n+\t\t}\n+\t\tthis.setArchive(output);\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#save(java.io.FileOutputStream)\n+\t */\n+\tpublic void save(FileOutputStream output) throws ArchiveException {\n+\t\tdoSave(output);\n+\t}\n+\t\n+\t/**\n+\t * Specific implementation of the save opteration. \n+\t * @param output - stream to archive to\n+\t * @throws ArchiveException \n+\t */\n+\tprotected abstract void doSave(FileOutputStream output) throws ArchiveException;\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getArchive()\n+\t */\n+\tpublic File getArchive() {\n+\t\treturn this.archive;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#setArchive(java.io.File)\n+\t */\n+\tpublic void setArchive(File file) {\n+\t\t// TODO: when an archive is set, it's files must be added to the\n+\t\t// internal file list for possible delete operations\n+\t\tthis.archive = file;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#add(java.io.File)\n+\t */\n+\tpublic void add(File file) throws FileNotFoundException {\n+\t\tInputStream is = new FileInputStream(file);\n+\t\tArchiveEntry archiveEntry = new ArchiveEntry(file.getName(), is);\n+\t\tentries.add( archiveEntry );\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#add(java.io.InputStream)\n+\t */\n+\tpublic void add(ArchiveEntry archiveEntry) {\n+\t\tentries.add( archiveEntry );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getPackFilesIterator()\n+\t */\n+\tpublic Iterator getEntryIterator() {\n+\t\treturn this.entries.iterator(); \n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#unpack(java.lang.String)\n+\t */\n+\tpublic void unpack(File unpackDir) throws UnpackException {\n+\t\tif(unpackDir == null) {\n+\t\t\tthrow new UnpackException(\"Destination directory must not be null.\");\n+\t\t}\n+\t\tif(!unpackDir.isDirectory()) {\n+\t\t\tthrow new UnpackException(\"This file must be a valid directory.\");\n+\t\t}\n+\t\tif(!unpackDir.canWrite()) {\n+\t\t\tthrow new UnpackException(\"This path is not writeable\");\n+\t\t}\n+\t\tdoUnpack(unpackDir);\n+\t}\n+\t\n+\t/**\n+\t * Specific implementation of the unpack opteration. \n+\t * @param unpackDir dir, to unpack to\n+\t * @throws UnpackException \n+\t */\n+\tprotected abstract void doUnpack(File unpackDir) throws UnpackException;\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#close()\n+\t */\n+\tpublic void close() throws IOException {\n+\t\tIterator it = getEntryIterator();\n+\t\twhile(it.hasNext()) {\n+\t\t\tArchiveEntry ae = (ArchiveEntry)it.next();\n+\t\t\tInputStream is = ae.getStream();\n+\t\t\tis.close();\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/ArchiveEntry.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.InputStream;\n+/**\n+ * Represents an entry of an archive.\n+ */\n+public class ArchiveEntry {\n+\t/* Name of this entry */\n+\tprivate String name = null;\n+\t/* name of this entry stream */\n+\tprivate InputStream stream = null;\n+\t\n+\t/*\n+\t * Should only called with parameters \n+\t */\n+\tprivate ArchiveEntry() {\n+\t\t// unused\n+\t}\n+\t\n+\t/**\n+\t * Constructs a new ArchiveEntry with name and stram\n+\t * @param name the name of this entry\n+\t * @param stream the inputstream of this entry\n+\t */\n+\tpublic ArchiveEntry(String entryName, InputStream entryStream) {\n+\t\tsuper();\n+\t\tthis.name = entryName;\n+\t\tthis.stream = entryStream;\n+\t}\n+\t\n+\t/**\n+\t * Returns this entries name\n+\t * @return name of this entry\n+\t */\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\t\n+\t/**\n+\t * Returns this entries InputStream stream\n+\t * @return InputStream of this entry\n+\t */\n+\tpublic InputStream getStream() {\n+\t\treturn stream;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/ArchiveException.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+/**\n+ * Exception for the archiver. \n+ */\n+public class ArchiveException extends PackableObjectException {\n+\t/**\n+\t * Comment for <code>serialVersionUID</code>\n+\t */\n+\tprivate static final long serialVersionUID = 3256440322136748848L;\n+\n+\t/**\n+\t * Calls the IOException constructor\n+\t */\n+\tpublic ArchiveException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * @param message the message\n+\t */\n+\tpublic ArchiveException(String message) {\n+\t\tsuper(message);\n+\t}\n+\t\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * and fills the stacktrace with the stacktrace of \n+\t * an exception\n+\t * \n+\t * @param message the message\n+\t * @param e the exception \n+\t */\n+\tpublic ArchiveException(String message, Exception e) {\n+\t\tsuper(message);\n+\t\tthis.initCause(e);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/PackableObjectException.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+/**\n+ * Exception for the archiver. \n+ */\n+public class PackableObjectException extends Exception {\n+\t/**\n+\t * Comment for <code>serialVersionUID</code>\n+\t */\n+\tprivate static final long serialVersionUID = 3904960871745534257L;\n+\n+\t/**\n+\t * Calls the IOException constructor\n+\t */\n+\tpublic PackableObjectException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * @param message the message\n+\t */\n+\tpublic PackableObjectException(String message) {\n+\t\tsuper(message);\n+\t}\n+\t\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * and fills the stacktrace with the stacktrace of \n+\t * an exception\n+\t * \n+\t * @param message the message\n+\t * @param e the exception \n+\t */\n+\tpublic PackableObjectException(String message, Exception e) {\n+\t\tsuper(message);\n+\t\tthis.initCause(e);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/UnpackException.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+/**\n+ * Exception occurs when a exception within \n+ * the unpack actions occurs.\n+ */\n+public class UnpackException  extends ArchiveException {\n+\t/**\n+\t * Comment for <code>serialVersionUID</code>\n+\t */\n+\tprivate static final long serialVersionUID = 3906647522633135668L;\n+\n+\t/**\n+\t * Calls the super constructor\n+\t */\n+\tpublic UnpackException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * @param message the message\n+\t */\n+\tpublic UnpackException(String message) {\n+\t\tsuper(message);\n+\t}\n+\t\n+\t/**\n+\t * Calls the super constructor with a message\n+\t * and fills the stacktrace with the stacktrace of \n+\t * an exception\n+\t * \n+\t * @param message the message\n+\t * @param e the exception \n+\t */\n+\tpublic UnpackException(String message, Exception e) {\n+\t\tsuper(message);\n+\t\tthis.initCause(e);\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarArchive.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+\n+import org.apache.commons.compress.AbstractArchive;\n+import org.apache.commons.compress.ArchiveEntry;\n+import org.apache.commons.compress.ArchiveException;\n+import org.apache.commons.compress.UnpackException;\n+\n+/**\n+ * Archive-Implementation for Tar.\n+ * An tar archive has no header. This means, that the \n+ * ArchiverFactory.getInstance( new File(\"file.tar\")) Method\n+ * cannot be used.\n+ */\n+public class TarArchive extends AbstractArchive {\n+\n+\t/* Buffer for the file operations */\n+\tprivate static final int BUFFER = 2048;\n+\n+\t/**\n+\t * DEFAULT_FILE_EXTENSION Field for this archiver.\n+\t */\n+\tpublic final static String DEFAULT_FILE_EXTENSION = \"tar\";\n+\n+\t/**\n+\t * ARCHIVER_NAME Field for this archiver.\n+\t */\n+\tprivate final static String ARCHIVER_NAME = \"tar\";\n+\t\n+\t/**\n+\t * This Archive should be instantiated in the Archive-Interface.\n+\t */\n+\tpublic TarArchive() {\n+\t\t// Empty\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#unpack()\n+\t */\n+\tprotected void doUnpack(File unpackDir) throws UnpackException {\n+\t\tFileInputStream fInputStream = null;\n+\t\tTarInputStream zInputStream = null;\n+\t\t\n+\t\ttry {\n+\t\t\tfInputStream = new FileInputStream(this.getArchive());\n+\t\t\tzInputStream = new TarInputStream(new BufferedInputStream(fInputStream));\n+\t\t} catch(FileNotFoundException e) {\n+\t\t\tthrow new UnpackException(\"SourceFile could not be found.\", e);\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tTarEntry entry = null;\n+\t\t\t\n+\t\t\twhile((entry = zInputStream.getNextEntry()) != null) {\n+\t\t\t\tBufferedOutputStream destination = null;\n+\t\t\t\t\n+\t\t\t\tint count;\n+\t\t\t\tbyte data[] = new byte[BUFFER];\n+\n+\t\t\t\tString filename = \"\";\n+\t\t\t\tFile f = new File(entry.getName());\n+\t\t\t\tif(f.isAbsolute()) {\n+\t\t\t\t\tfilename = entry.getName().substring(3);\n+\t\t\t\t} else {\n+\t\t\t\t\tfilename = entry.getName();\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tString fosString = unpackDir.getPath() + File.separator + filename;\n+\t\t\t\tFile destFile = new File(fosString);\n+\t\t\t\tFile destPath = new File(destFile.getParent());\n+\t\t\t\tdestPath.mkdirs();\n+\t\t\t\t\n+\t\t\t\tFileOutputStream fos = new FileOutputStream(destFile);\n+\t\t\t\ttry {\n+\t\t\t\t\tdestination = new BufferedOutputStream(fos, BUFFER);\n+\t\t\t\t\t\n+\t\t\t\t\twhile((count = zInputStream.read(data, 0, BUFFER))!= -1) {\n+\t\t\t\t\t\tdestination.write(data, 0, count);\n+\t\t\t\t\t}\n+\t\t\t\t\tdestination.flush();\n+\t\t\t\t} finally {\n+\t\t\t\t\tdestination.close();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new UnpackException(\"Exception while unpacking.\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tfInputStream.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new UnpackException(\"Exception while unpacking.\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.AbstractArchive#doSave(java.io.FileOutputStream)\n+\t */\n+\tpublic void doSave(FileOutputStream output) throws ArchiveException {\n+\t\t// Stream initializing\n+\t\tBufferedInputStream origin = null;\n+\t\t\n+\t\t//out.setMethod(ZipOutputStream.DEFLATED);\n+\t\tbyte data[] = new byte[BUFFER];\n+\t\t\n+\t\t// get a list of files from current directory\n+\t\t// less than one file leads to an exception\n+\t\tIterator iterator = this.getEntryIterator();\n+\t\tif(!iterator.hasNext()) {\n+\t\t\tthrow new ArchiveException(\"There must be at least one file to be pack.\");\n+\t\t}\n+\t\t\n+\t\t// Pack-Operation\n+\t\tTarOutputStream out = null;\n+\t\t\n+\t\ttry {\n+\t\t\tout = new TarOutputStream(new BufferedOutputStream(output));\n+\t\t\twhile(iterator.hasNext()) {\n+\n+\t\t\t\tArchiveEntry archiveEntry = (ArchiveEntry)iterator.next();\n+\t\t\t\tInputStream fInputStream = archiveEntry.getStream();\n+\n+\t\t\t\tTarEntry entry = new TarEntry(archiveEntry.getName());\n+\t\t\t\tentry.setModTime( 0 );\n+\t\t        entry.setSize( fInputStream.available() );\n+\t\t        entry.setUserID( 0 );\n+\t\t        entry.setGroupID( 0 );\n+\t\t        entry.setUserName( \"avalon\" );\n+\t\t        entry.setGroupName( \"excalibur\" );\n+\t\t        entry.setMode( 0100000 );\n+\t\t        out.putNextEntry( entry );\n+\t\t        \n+\t\t        out.copyEntryContents( fInputStream );\n+\t\t        out.closeEntry();\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ArchiveException(\"Creation of this archive failed cause of IOExceptions.\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tout.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new ArchiveException(\"Creation of this archive failed cause of IOExceptions.\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getArchiverName()\n+\t */\n+\tpublic String getName() {\n+\t\treturn ARCHIVER_NAME;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getDefaultFileExtension()\n+\t */\n+\tpublic String getDefaultFileExtension() {\n+\t\treturn DEFAULT_FILE_EXTENSION;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getHeader()\n+\t */\n+\tpublic byte[] getHeader() {\n+\t\t// tar's have no specific header\n+\t\treturn null;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * The TarBuffer class implements the tar archive concept of a buffered input\n+ * stream. This concept goes back to the days of blocked tape drives and special\n+ * io devices. In the Java universe, the only real function that this class\n+ * performs is to ensure that files have the correct \"block\" size, or other tars\n+ * will complain. <p>\n+ *\n+ * You should never have a need to access this class directly. TarBuffers are\n+ * created by Tar IO Streams.\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ */\n+public class TarBuffer\n+{\n+    public static final int DEFAULT_RECORDSIZE = ( 512 );\n+    public static final int DEFAULT_BLOCKSIZE = ( DEFAULT_RECORDSIZE * 20 );\n+\n+    private byte[] m_blockBuffer;\n+    private int m_blockSize;\n+    private int m_currBlkIdx;\n+    private int m_currRecIdx;\n+    private boolean m_debug;\n+\n+    private InputStream m_input;\n+    private OutputStream m_output;\n+    private int m_recordSize;\n+    private int m_recsPerBlock;\n+\n+    public TarBuffer( final InputStream input )\n+    {\n+        this( input, TarBuffer.DEFAULT_BLOCKSIZE );\n+    }\n+\n+    public TarBuffer( final InputStream input, final int blockSize )\n+    {\n+        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    public TarBuffer( final InputStream input,\n+                      final int blockSize,\n+                      final int recordSize )\n+    {\n+        m_input = input;\n+        initialize( blockSize, recordSize );\n+    }\n+\n+    public TarBuffer( final OutputStream output )\n+    {\n+        this( output, TarBuffer.DEFAULT_BLOCKSIZE );\n+    }\n+\n+    public TarBuffer( final OutputStream output, final int blockSize )\n+    {\n+        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    public TarBuffer( final OutputStream output,\n+                      final int blockSize,\n+                      final int recordSize )\n+    {\n+        m_output = output;\n+        initialize( blockSize, recordSize );\n+    }\n+\n+    /**\n+     * Set the debugging flag for the buffer.\n+     *\n+     * @param debug If true, print debugging output.\n+     */\n+    public void setDebug( final boolean debug )\n+    {\n+        m_debug = debug;\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's block size. Blocks consist of multiple records.\n+     *\n+     * @return The BlockSize value\n+     */\n+    public int getBlockSize()\n+    {\n+        return m_blockSize;\n+    }\n+\n+    /**\n+     * Get the current block number, zero based.\n+     *\n+     * @return The current zero based block number.\n+     */\n+    public int getCurrentBlockNum()\n+    {\n+        return m_currBlkIdx;\n+    }\n+\n+    /**\n+     * Get the current record number, within the current block, zero based.\n+     * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.\n+     *\n+     * @return The current zero based record number.\n+     */\n+    public int getCurrentRecordNum()\n+    {\n+        return m_currRecIdx - 1;\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's record size.\n+     *\n+     * @return The RecordSize value\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_recordSize;\n+    }\n+\n+    /**\n+     * Determine if an archive record indicate End of Archive. End of archive is\n+     * indicated by a record that consists entirely of null bytes.\n+     *\n+     * @param record The record data to check.\n+     * @return The EOFRecord value\n+     */\n+    public boolean isEOFRecord( final byte[] record )\n+    {\n+        final int size = getRecordSize();\n+        for( int i = 0; i < size; ++i )\n+        {\n+            if( record[ i ] != 0 )\n+            {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Close the TarBuffer. If this is an output buffer, also flush the current\n+     * block before closing.\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            debug( \"TarBuffer.closeBuffer().\" );\n+        }\n+\n+        if( null != m_output )\n+        {\n+            flushBlock();\n+\n+            if( m_output != System.out && m_output != System.err )\n+            {\n+                m_output.close();\n+                m_output = null;\n+            }\n+        }\n+        else if( m_input != null )\n+        {\n+            if( m_input != System.in )\n+            {\n+                m_input.close();\n+                m_input = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read a record from the input stream and return the data.\n+     *\n+     * @return The record data.\n+     * @exception IOException Description of Exception\n+     */\n+    public byte[] readRecord()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"ReadRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            if( !readBlock() )\n+            {\n+                return null;\n+            }\n+        }\n+\n+        final byte[] result = new byte[ m_recordSize ];\n+        System.arraycopy( m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          result,\n+                          0,\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Skip over a record on the input stream.\n+     */\n+    public void skipRecord()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"SkipRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading (via skip) from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            if( !readBlock() )\n+            {\n+                return;// UNDONE\n+            }\n+        }\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive.\n+     *\n+     * @param record The record data to write to the archive.\n+     */\n+    public void writeRecord( final byte[] record )\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( record.length != m_recordSize )\n+        {\n+            final String message = \"record to write has length '\" +\n+                record.length + \"' which is not the record size of '\" +\n+                m_recordSize + \"'\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy( record,\n+                          0,\n+                          m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive, where the record may be inside of\n+     * a larger array buffer. The buffer must be \"offset plus record size\" long.\n+     *\n+     * @param buffer The buffer containing the record data to write.\n+     * @param offset The offset of the record data within buf.\n+     */\n+    public void writeRecord( final byte[] buffer, final int offset )\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n+                \" blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( ( offset + m_recordSize ) > buffer.length )\n+        {\n+            final String message = \"record has length '\" + buffer.length +\n+                \"' with offset '\" + offset + \"' which is less than the record size of '\" +\n+                m_recordSize + \"'\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx >= m_recsPerBlock )\n+        {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy( buffer,\n+                          offset,\n+                          m_blockBuffer,\n+                          ( m_currRecIdx * m_recordSize ),\n+                          m_recordSize );\n+\n+        m_currRecIdx++;\n+    }\n+\n+    /**\n+     * Flush the current data block if it has any data in it.\n+     */\n+    private void flushBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"TarBuffer.flushBlock() called.\";\n+            debug( message );\n+        }\n+\n+        if( m_output == null )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        if( m_currRecIdx > 0 )\n+        {\n+            writeBlock();\n+        }\n+    }\n+\n+    /**\n+     * Initialization common to all constructors.\n+     */\n+    private void initialize( final int blockSize, final int recordSize )\n+    {\n+        m_debug = false;\n+        m_blockSize = blockSize;\n+        m_recordSize = recordSize;\n+        m_recsPerBlock = ( m_blockSize / m_recordSize );\n+        m_blockBuffer = new byte[ m_blockSize ];\n+\n+        if( null != m_input )\n+        {\n+            m_currBlkIdx = -1;\n+            m_currRecIdx = m_recsPerBlock;\n+        }\n+        else\n+        {\n+            m_currBlkIdx = 0;\n+            m_currRecIdx = 0;\n+        }\n+    }\n+\n+    /**\n+     * @return false if End-Of-File, else true\n+     */\n+    private boolean readBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"ReadBlock: blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_input )\n+        {\n+            final String message = \"reading from an output buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        m_currRecIdx = 0;\n+\n+        int offset = 0;\n+        int bytesNeeded = m_blockSize;\n+\n+        while( bytesNeeded > 0 )\n+        {\n+            final long numBytes = m_input.read( m_blockBuffer, offset, bytesNeeded );\n+\n+            //\n+            // NOTE\n+            // We have fit EOF, and the block is not full!\n+            //\n+            // This is a broken archive. It does not follow the standard\n+            // blocking algorithm. However, because we are generous, and\n+            // it requires little effort, we will simply ignore the error\n+            // and continue as if the entire block were read. This does\n+            // not appear to break anything upstream. We used to return\n+            // false in this case.\n+            //\n+            // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n+            //\n+            if( numBytes == -1 )\n+            {\n+                break;\n+            }\n+\n+            offset += numBytes;\n+            bytesNeeded -= numBytes;\n+\n+            if( numBytes != m_blockSize )\n+            {\n+                if( m_debug )\n+                {\n+                    System.err.println( \"ReadBlock: INCOMPLETE READ \"\n+                                        + numBytes + \" of \" + m_blockSize\n+                                        + \" bytes read.\" );\n+                }\n+            }\n+        }\n+\n+        m_currBlkIdx++;\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Write a TarBuffer block to the archive.\n+     *\n+     * @exception IOException Description of Exception\n+     */\n+    private void writeBlock()\n+        throws IOException\n+    {\n+        if( m_debug )\n+        {\n+            final String message = \"WriteBlock: blkIdx = \" + m_currBlkIdx;\n+            debug( message );\n+        }\n+\n+        if( null == m_output )\n+        {\n+            final String message = \"writing to an input buffer\";\n+            throw new IOException( message );\n+        }\n+\n+        m_output.write( m_blockBuffer, 0, m_blockSize );\n+        m_output.flush();\n+\n+        m_currRecIdx = 0;\n+        m_currBlkIdx++;\n+    }\n+\n+    protected void debug( final String message )\n+    {\n+        if( m_debug )\n+        {\n+            System.err.println( message );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarEntry.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.File;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+/**\n+ * This class represents an entry in a Tar archive. It consists of the entry's\n+ * header, as well as the entry's File. Entries can be instantiated in one of\n+ * three ways, depending on how they are to be used. <p>\n+ *\n+ * TarEntries that are created from the header bytes read from an archive are\n+ * instantiated with the TarEntry( byte[] ) constructor. These entries will be\n+ * used when extracting from or listing the contents of an archive. These\n+ * entries have their header filled in using the header bytes. They also set the\n+ * File to null, since they reference an archive entry not a file. <p>\n+ *\n+ * TarEntries that are created from Files that are to be written into an archive\n+ * are instantiated with the TarEntry( File ) constructor. These entries have\n+ * their header filled in using the File's information. They also keep a\n+ * reference to the File for convenience when writing entries. <p>\n+ *\n+ * Finally, TarEntries can be constructed from nothing but a name. This allows\n+ * the programmer to construct the entry by hand, for instance when only an\n+ * InputStream is available for writing to the archive, and the header\n+ * information is constructed from other information. In this case the header\n+ * fields are set to defaults and the File is set to null. <p>\n+ *\n+ * The C structure for a Tar Entry's header is: <pre>\n+ * struct header {\n+ * char name[NAMSIZ];\n+ * char mode[8];\n+ * char uid[8];\n+ * char gid[8];\n+ * char size[12];\n+ * char mtime[12];\n+ * char chksum[8];\n+ * char linkflag;\n+ * char linkname[NAMSIZ];\n+ * char magic[8];\n+ * char uname[TUNMLEN];\n+ * char gname[TGNMLEN];\n+ * char devmajor[8];\n+ * char devminor[8];\n+ * } header;\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ * @see TarInputStream\n+ * @see TarOutputStream\n+ */\n+public class TarEntry\n+{\n+\t/**\n+     * The length of the mode field in a header buffer.\n+     */\n+\tprivate final static int MODELEN = 8;\n+\n+    /**\n+     * The length of the user id field in a header buffer.\n+     */\n+     private final static int UIDLEN = 8;\n+\n+    /**\n+     * The length of the group id field in a header buffer.\n+     */\n+    private final static int GIDLEN = 8;\n+\n+    /**\n+     * The length of the checksum field in a header buffer.\n+     */\n+    private final static int CHKSUMLEN = 8;\n+\n+    /**\n+     * The length of the size field in a header buffer.\n+     */\n+    private final static int SIZELEN = 12;\n+\n+    /**\n+     * The length of the magic field in a header buffer.\n+     */\n+    private final static int MAGICLEN = 8;\n+\n+    /**\n+     * The length of the modification time field in a header buffer.\n+     */\n+    private final static int MODTIMELEN = 12;\n+\n+    /**\n+     * The length of the user name field in a header buffer.\n+     */\n+    private final static int UNAMELEN = 32;\n+\n+    /**\n+     * The length of the group name field in a header buffer.\n+     */\n+    private final static int GNAMELEN = 32;\n+\n+    /**\n+     * The length of the devices field in a header buffer.\n+     */\n+    private final static int DEVLEN = 8;\n+\n+    /**\n+     * LF_ constants represent the \"link flag\" of an entry, or more commonly,\n+     * the \"entry type\". This is the \"old way\" of indicating a normal file.\n+     */\n+    private final static byte LF_OLDNORM = 0;\n+\n+    /**\n+     * Normal file type.\n+     */\n+    private final static byte LF_NORMAL = (byte)'0';\n+\n+    /**\n+     * Link file type.\n+     */\n+    private final static byte LF_LINK = (byte)'1';\n+\n+    /**\n+     * Symbolic link file type.\n+     */\n+    private final static byte LF_SYMLINK = (byte)'2';\n+\n+    /**\n+     * Character device file type.\n+     */\n+    private final static byte LF_CHR = (byte)'3';\n+\n+    /**\n+     * Block device file type.\n+     */\n+    private final static byte LF_BLK = (byte)'4';\n+\n+    /**\n+     * Directory file type.\n+     */\n+    private final static byte LF_DIR = (byte)'5';\n+\n+    /**\n+     * FIFO (pipe) file type.\n+     */\n+    private final static byte LF_FIFO = (byte)'6';\n+\n+    /**\n+     * Contiguous file type.\n+     */\n+    private final static byte LF_CONTIG = (byte)'7';\n+\n+    /**\n+     * The magic tag representing a POSIX tar archive.\n+     */\n+    private final static String TMAGIC = \"ustar\";\n+\n+    /**\n+     * The magic tag representing a GNU tar archive.\n+     */\n+    private final static String GNU_TMAGIC = \"ustar  \";\n+\n+    /**\n+     * The name of the GNU tar entry which contains a long name.\n+     */\n+    static String GNU_LONGLINK = \"././@LongLink\";\n+\n+    /**\n+     * Identifies the *next* file on the tape as having a long name.\n+     */\n+    static byte LF_GNUTYPE_LONGNAME = (byte)'L';\n+    \n+    \n+    \n+    \n+    \n+    \n+    \n+    \n+    /**\n+     * The length of the name field in a header buffer.\n+     */\n+    public static final int NAMELEN = 100;\n+\n+    /**\n+     * The entry's modification time.\n+     */\n+    private int m_checkSum;\n+\n+    /**\n+     * The entry's group name.\n+     */\n+    private int m_devMajor;\n+\n+    /**\n+     * The entry's major device number.\n+     */\n+    private int m_devMinor;\n+\n+    /**\n+     * The entry's minor device number.\n+     */\n+    private File m_file;\n+\n+    /**\n+     * The entry's user id.\n+     */\n+    private int m_groupID;\n+\n+    /**\n+     * The entry's user name.\n+     */\n+    private StringBuffer m_groupName;\n+\n+    /**\n+     * The entry's checksum.\n+     */\n+    private byte m_linkFlag;\n+\n+    /**\n+     * The entry's link flag.\n+     */\n+    private StringBuffer m_linkName;\n+\n+    /**\n+     * The entry's link name.\n+     */\n+    private StringBuffer m_magic;\n+\n+    /**\n+     * The entry's size.\n+     */\n+    private long m_modTime;\n+\n+    /**\n+     * The entry's name.\n+     */\n+    private int m_mode;\n+\n+    private StringBuffer m_name;\n+\n+    /**\n+     * The entry's group id.\n+     */\n+    private long m_size;\n+\n+    /**\n+     * The entry's permission mode.\n+     */\n+    private int m_userID;\n+\n+    /**\n+     * The entry's magic tag.\n+     */\n+    private StringBuffer m_userName;\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer to\n+     * construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the name of the entry\n+     */\n+    public TarEntry( final String name )\n+    {\n+        this();\n+\n+        final boolean isDir = name.endsWith( \"/\" );\n+\n+        m_name = new StringBuffer( name );\n+        m_mode = isDir ? 040755 : 0100644;\n+        m_linkFlag = isDir ? TarEntry.LF_DIR : TarEntry.LF_NORMAL;\n+        m_modTime = ( new Date() ).getTime() / 1000;\n+        m_linkName = new StringBuffer( \"\" );\n+        m_userName = new StringBuffer( \"\" );\n+        m_groupName = new StringBuffer( \"\" );\n+    }\n+\n+    /**\n+     * Construct an entry with a name an a link flag.\n+     *\n+     * @param name Description of Parameter\n+     * @param linkFlag Description of Parameter\n+     */\n+    public TarEntry( final String name, final byte linkFlag )\n+    {\n+        this( name );\n+        m_linkFlag = linkFlag;\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the header is\n+     * constructed from information from the file.\n+     *\n+     * @param file The file that the entry represents.\n+     */\n+    public TarEntry( final File file )\n+    {\n+        this();\n+\n+        m_file = file;\n+\n+        String name = file.getPath();\n+\n+        // Strip off drive letters!\n+        final String osName =\n+            System.getProperty( \"os.name\" ).toLowerCase( Locale.US );\n+        if( -1 != osName.indexOf( \"netware\" ) )\n+        {\n+            if( name.length() > 2 )\n+            {\n+                final char ch1 = name.charAt( 0 );\n+                final char ch2 = name.charAt( 1 );\n+\n+                if( ch2 == ':' &&\n+                    ( ( ch1 >= 'a' && ch1 <= 'z' ) ||\n+                    ( ch1 >= 'A' && ch1 <= 'Z' ) ) )\n+                {\n+                    name = name.substring( 2 );\n+                }\n+            }\n+        }\n+        else if( -1 != osName.indexOf( \"netware\" ) )\n+        {\n+            final int colon = name.indexOf( ':' );\n+            if( colon != -1 )\n+            {\n+                name = name.substring( colon + 1 );\n+            }\n+        }\n+\n+        name = name.replace( File.separatorChar, '/' );\n+\n+        // No absolute pathnames\n+        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n+        // so we loop on starting /'s.\n+        while( name.startsWith( \"/\" ) )\n+        {\n+            name = name.substring( 1 );\n+        }\n+\n+        m_linkName = new StringBuffer( \"\" );\n+        m_name = new StringBuffer( name );\n+\n+        if( file.isDirectory() )\n+        {\n+            m_mode = 040755;\n+            m_linkFlag = TarEntry.LF_DIR;\n+\n+            if( m_name.charAt( m_name.length() - 1 ) != '/' )\n+            {\n+                m_name.append( \"/\" );\n+            }\n+        }\n+        else\n+        {\n+            m_mode = 0100644;\n+            m_linkFlag = TarEntry.LF_NORMAL;\n+        }\n+\n+        m_size = file.length();\n+        m_modTime = file.lastModified() / 1000;\n+        m_checkSum = 0;\n+        m_devMajor = 0;\n+        m_devMinor = 0;\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set to null.\n+     *\n+     * @param header The header bytes from a tar archive entry.\n+     */\n+    public TarEntry( final byte[] header )\n+    {\n+        this();\n+        parseTarHeader( header );\n+    }\n+\n+    /**\n+     * Construct an empty entry and prepares the header values.\n+     */\n+    private TarEntry()\n+    {\n+        m_magic = new StringBuffer( TarEntry.TMAGIC );\n+        m_name = new StringBuffer();\n+        m_linkName = new StringBuffer();\n+\n+        String user = System.getProperty( \"user.name\", \"\" );\n+        if( user.length() > 31 )\n+        {\n+            user = user.substring( 0, 31 );\n+        }\n+\n+        m_userName = new StringBuffer( user );\n+        m_groupName = new StringBuffer( \"\" );\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     */\n+    public void setGroupID( final int groupId )\n+    {\n+        m_groupID = groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group id.\n+     *\n+     * @param groupId This entry's new group id.\n+     * @deprecated Use setGroupID() instead\n+     * @see #setGroupID(int)\n+     */\n+    public void setGroupId( final int groupId )\n+    {\n+        m_groupID = groupId;\n+    }\n+\n+    /**\n+     * Set this entry's group name.\n+     *\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setGroupName( final String groupName )\n+    {\n+        m_groupName = new StringBuffer( groupName );\n+    }\n+\n+    /**\n+     * Set this entry's modification time. The parameter passed to this method\n+     * is in \"Java time\".\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime( final long time )\n+    {\n+        m_modTime = time / 1000;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @param time This entry's new modification time.\n+     */\n+    public void setModTime( final Date time )\n+    {\n+        m_modTime = time.getTime() / 1000;\n+    }\n+\n+    /**\n+     * Set the mode for this entry\n+     *\n+     * @param mode The new Mode value\n+     */\n+    public void setMode( final int mode )\n+    {\n+        m_mode = mode;\n+    }\n+\n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n+    public void setName( final String name )\n+    {\n+        m_name = new StringBuffer( name );\n+    }\n+\n+    /**\n+     * Set this entry's file size.\n+     *\n+     * @param size This entry's new file size.\n+     */\n+    public void setSize( final long size )\n+    {\n+        m_size = size;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     */\n+    public void setUserID( final int userId )\n+    {\n+        m_userID = userId;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     * @deprecated Use setUserID() instead\n+     * @see #setUserID(int)\n+     */\n+    public void setUserId( final int userId )\n+    {\n+        m_userID = userId;\n+    }\n+\n+    /**\n+     * Set this entry's user name.\n+     *\n+     * @param userName This entry's new user name.\n+     */\n+    public void setUserName( final String userName )\n+    {\n+        m_userName = new StringBuffer( userName );\n+    }\n+\n+    /**\n+     * If this entry represents a file, and the file is a directory, return an\n+     * array of TarEntries for this entry's children.\n+     *\n+     * @return An array of TarEntry's for this entry's children.\n+     */\n+    public TarEntry[] getDirectoryEntries()\n+    {\n+        if( null == m_file || !m_file.isDirectory() )\n+        {\n+            return new TarEntry[ 0 ];\n+        }\n+\n+        final String[] list = m_file.list();\n+        final TarEntry[] result = new TarEntry[ list.length ];\n+\n+        for( int i = 0; i < list.length; ++i )\n+        {\n+            result[ i ] = new TarEntry( new File( m_file, list[ i ] ) );\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get this entry's file.\n+     *\n+     * @return This entry's file.\n+     */\n+    public File getFile()\n+    {\n+        return m_file;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     * @deprecated Use getGroupID() instead\n+     * @see #getGroupID()\n+     */\n+    public int getGroupId()\n+    {\n+        return m_groupID;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     */\n+    public int getGroupID()\n+    {\n+        return m_groupID;\n+    }\n+\n+    /**\n+     * Get this entry's group name.\n+     *\n+     * @return This entry's group name.\n+     */\n+    public String getGroupName()\n+    {\n+        return m_groupName.toString();\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @return The ModTime value\n+     */\n+    public Date getModTime()\n+    {\n+        return new Date( m_modTime * 1000 );\n+    }\n+\n+    /**\n+     * Get this entry's mode.\n+     *\n+     * @return This entry's mode.\n+     */\n+    public int getMode()\n+    {\n+        return m_mode;\n+    }\n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n+    public String getName()\n+    {\n+        return m_name.toString();\n+    }\n+\n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n+    public long getSize()\n+    {\n+        return m_size;\n+    }\n+\n+    /**\n+     * Get this entry's checksum.\n+     *\n+     * @return This entry's checksum.\n+     */\n+    public int getCheckSum()\n+    {\n+        return m_checkSum;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     * @deprecated Use getUserID() instead\n+     * @see #getUserID()\n+     */\n+    public int getUserId()\n+    {\n+        return m_userID;\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     */\n+    public int getUserID()\n+    {\n+        return m_userID;\n+    }\n+\n+    /**\n+     * Get this entry's user name.\n+     *\n+     * @return This entry's user name.\n+     */\n+    public String getUserName()\n+    {\n+        return m_userName.toString();\n+    }\n+\n+    /**\n+     * Determine if the given entry is a descendant of this entry. Descendancy\n+     * is determined by the name of the descendant starting with this entry's\n+     * name.\n+     *\n+     * @param desc Entry to be checked as a descendent of\n+     * @return True if entry is a descendant of\n+     */\n+    public boolean isDescendent( final TarEntry desc )\n+    {\n+        return desc.getName().startsWith( getName() );\n+    }\n+\n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n+    public boolean isDirectory()\n+    {\n+        if( m_file != null )\n+        {\n+            return m_file.isDirectory();\n+        }\n+\n+        if( m_linkFlag == TarEntry.LF_DIR )\n+        {\n+            return true;\n+        }\n+\n+        if( getName().endsWith( \"/\" ) )\n+        {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Indicate if this entry is a GNU long name block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongNameEntry()\n+    {\n+        return m_linkFlag == TarEntry.LF_GNUTYPE_LONGNAME &&\n+            m_name.toString().equals( TarEntry.GNU_LONGLINK );\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined by the\n+     * header names being equal.\n+     *\n+     * @param other Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals( final TarEntry other )\n+    {\n+        return getName().equals( other.getName() );\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     */\n+    private void parseTarHeader( final byte[] header )\n+    {\n+        int offset = 0;\n+\n+        m_name = TarUtils.parseName( header, offset, NAMELEN );\n+        offset += NAMELEN;\n+        m_mode = (int)TarUtils.parseOctal( header, offset, TarEntry.MODELEN );\n+        offset += TarEntry.MODELEN;\n+        m_userID = (int)TarUtils.parseOctal( header, offset, TarEntry.UIDLEN );\n+        offset += TarEntry.UIDLEN;\n+        m_groupID = (int)TarUtils.parseOctal( header, offset, TarEntry.GIDLEN );\n+        offset += TarEntry.GIDLEN;\n+        m_size = TarUtils.parseOctal( header, offset, TarEntry.SIZELEN );\n+        offset += TarEntry.SIZELEN;\n+        m_modTime = TarUtils.parseOctal( header, offset, TarEntry.MODTIMELEN );\n+        offset += TarEntry.MODTIMELEN;\n+        m_checkSum = (int)TarUtils.parseOctal( header, offset, TarEntry.CHKSUMLEN );\n+        offset += TarEntry.CHKSUMLEN;\n+        m_linkFlag = header[ offset++ ];\n+        m_linkName = TarUtils.parseName( header, offset, NAMELEN );\n+        offset += NAMELEN;\n+        m_magic = TarUtils.parseName( header, offset, TarEntry.MAGICLEN );\n+        offset += TarEntry.MAGICLEN;\n+        m_userName = TarUtils.parseName( header, offset, TarEntry.UNAMELEN );\n+        offset += TarEntry.UNAMELEN;\n+        m_groupName = TarUtils.parseName( header, offset, TarEntry.GNAMELEN );\n+        offset += TarEntry.GNAMELEN;\n+        m_devMajor = (int)TarUtils.parseOctal( header, offset, TarEntry.DEVLEN );\n+        offset += TarEntry.DEVLEN;\n+        m_devMinor = (int)TarUtils.parseOctal( header, offset, TarEntry.DEVLEN );\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param buffer The tar entry header buffer to fill in.\n+     */\n+    public void writeEntryHeader( final byte[] buffer )\n+    {\n+        int offset = 0;\n+\n+        offset = TarUtils.getNameBytes( m_name, buffer, offset, NAMELEN );\n+        offset = TarUtils.getOctalBytes( m_mode, buffer, offset, TarEntry.MODELEN );\n+        offset = TarUtils.getOctalBytes( m_userID, buffer, offset, TarEntry.UIDLEN );\n+        offset = TarUtils.getOctalBytes( m_groupID, buffer, offset, TarEntry.GIDLEN );\n+        offset = TarUtils.getLongOctalBytes( m_size, buffer, offset, TarEntry.SIZELEN );\n+        offset = TarUtils.getLongOctalBytes( m_modTime, buffer, offset, TarEntry.MODTIMELEN );\n+\n+        final int checkSumOffset = offset;\n+        for( int i = 0; i < TarEntry.CHKSUMLEN; ++i )\n+        {\n+            buffer[ offset++ ] = (byte)' ';\n+        }\n+\n+        buffer[ offset++ ] = m_linkFlag;\n+        offset = TarUtils.getNameBytes( m_linkName, buffer, offset, NAMELEN );\n+        offset = TarUtils.getNameBytes( m_magic, buffer, offset, TarEntry.MAGICLEN );\n+        offset = TarUtils.getNameBytes( m_userName, buffer, offset, TarEntry.UNAMELEN );\n+        offset = TarUtils.getNameBytes( m_groupName, buffer, offset, TarEntry.GNAMELEN );\n+        offset = TarUtils.getOctalBytes( m_devMajor, buffer, offset, TarEntry.DEVLEN );\n+        offset = TarUtils.getOctalBytes( m_devMinor, buffer, offset, TarEntry.DEVLEN );\n+\n+        while( offset < buffer.length )\n+        {\n+            buffer[ offset++ ] = 0;\n+        }\n+\n+        final long checkSum = TarUtils.computeCheckSum( buffer );\n+        TarUtils.getCheckSumOctalBytes( checkSum, buffer, checkSumOffset, TarEntry.CHKSUMLEN );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+/**\n+ * The TarInputStream reads a UNIX tar archive as an InputStream. methods are\n+ * provided to position at each successive entry in the archive, and the read\n+ * each entry as a normal input stream using read().\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ * @see TarInputStream\n+ * @see TarEntry\n+ */\n+public final class TarInputStream extends FilterInputStream\n+{\n+    private TarBuffer m_buffer;\n+    private TarEntry m_currEntry;\n+    private boolean m_debug;\n+    private int m_entryOffset;\n+    private int m_entrySize;\n+    private boolean m_hasHitEOF;\n+    private byte[] m_oneBuf;\n+    private byte[] m_readBuf;\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream and default block and record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @see TarBuffer#DEFAULT_BLOCKSIZE\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarInputStream( final InputStream input )\n+    {\n+        this( input, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream, block size and default record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @param blockSize the block size to use\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarInputStream( final InputStream input,\n+                           final int blockSize )\n+    {\n+        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarInputStream using specified input\n+     * stream, block size and record sizes.\n+     *\n+     * @param input stream to create TarInputStream from\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarInputStream( final InputStream input,\n+                           final int blockSize,\n+                           final int recordSize )\n+    {\n+        super( input );\n+\n+        m_buffer = new TarBuffer( input, blockSize, recordSize );\n+        m_oneBuf = new byte[ 1 ];\n+    }\n+\n+    /**\n+     * Sets the debugging flag.\n+     *\n+     * @param debug The new Debug value\n+     */\n+    public void setDebug( final boolean debug )\n+    {\n+        m_debug = debug;\n+        m_buffer.setDebug( debug );\n+    }\n+\n+    /**\n+     * Get the next entry in this tar archive. This will skip over any remaining\n+     * data in the current entry, if there is one, and place the input stream at\n+     * the header of the next entry, and read the header and instantiate a new\n+     * TarEntry from the header bytes and return that entry. If there are no\n+     * more entries in the archive, null will be returned to indicate that the\n+     * end of the archive has been reached.\n+     *\n+     * @return The next TarEntry in the archive, or null.\n+     * @exception IOException Description of Exception\n+     */\n+    public TarEntry getNextEntry()\n+        throws IOException\n+    {\n+        if( m_hasHitEOF )\n+        {\n+            return null;\n+        }\n+\n+        if( m_currEntry != null )\n+        {\n+            final int numToSkip = m_entrySize - m_entryOffset;\n+\n+            if( m_debug )\n+            {\n+                final String message = \"TarInputStream: SKIP currENTRY '\" +\n+                    m_currEntry.getName() + \"' SZ \" + m_entrySize +\n+                    \" OFF \" + m_entryOffset + \"  skipping \" + numToSkip + \" bytes\";\n+                debug( message );\n+            }\n+\n+            if( numToSkip > 0 )\n+            {\n+                skip( numToSkip );\n+            }\n+\n+            m_readBuf = null;\n+        }\n+\n+        final byte[] headerBuf = m_buffer.readRecord();\n+        if( headerBuf == null )\n+        {\n+            if( m_debug )\n+            {\n+                debug( \"READ NULL RECORD\" );\n+            }\n+            m_hasHitEOF = true;\n+        }\n+        else if( m_buffer.isEOFRecord( headerBuf ) )\n+        {\n+            if( m_debug )\n+            {\n+                debug( \"READ EOF RECORD\" );\n+            }\n+            m_hasHitEOF = true;\n+        }\n+\n+        if( m_hasHitEOF )\n+        {\n+            m_currEntry = null;\n+        }\n+        else\n+        {\n+            m_currEntry = new TarEntry( headerBuf );\n+\n+            if( !( headerBuf[ 257 ] == 'u' && headerBuf[ 258 ] == 's' &&\n+                headerBuf[ 259 ] == 't' && headerBuf[ 260 ] == 'a' &&\n+                headerBuf[ 261 ] == 'r' ) )\n+            {\n+                //Must be v7Format\n+            }\n+\n+            if( m_debug )\n+            {\n+                final String message = \"TarInputStream: SET CURRENTRY '\" +\n+                    m_currEntry.getName() + \"' size = \" + m_currEntry.getSize();\n+                debug( message );\n+            }\n+\n+            m_entryOffset = 0;\n+\n+            // REVIEW How do we resolve this discrepancy?!\n+            m_entrySize = (int)m_currEntry.getSize();\n+        }\n+\n+        if( null != m_currEntry && m_currEntry.isGNULongNameEntry() )\n+        {\n+            // read in the name\n+            final StringBuffer longName = new StringBuffer();\n+            final byte[] buffer = new byte[ 256 ];\n+            int length = 0;\n+            while( ( length = read( buffer ) ) >= 0 )\n+            {\n+                final String str = new String( buffer, 0, length );\n+                longName.append( str );\n+            }\n+            getNextEntry();\n+\n+            // remove trailing null terminator\n+            if (longName.length() > 0\n+                && longName.charAt(longName.length() - 1) == 0) {\n+                longName.deleteCharAt(longName.length() - 1);\n+            }\n+            \n+            m_currEntry.setName( longName.toString() );\n+        }\n+\n+        return m_currEntry;\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Get the available data that can be read from the current entry in the\n+     * archive. This does not indicate how much data is left in the entire\n+     * archive, only in the current entry. This value is determined from the\n+     * entry's size header field and the amount of data already read from the\n+     * current entry.\n+     *\n+     * @return The number of available bytes for the current entry.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int available()\n+        throws IOException\n+    {\n+        return m_entrySize - m_entryOffset;\n+    }\n+\n+    /**\n+     * Closes this stream. Calls the TarBuffer's close() method.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        m_buffer.close();\n+    }\n+\n+    /**\n+     * Copies the contents of the current tar archive entry directly into an\n+     * output stream.\n+     *\n+     * @param output The OutputStream into which to write the entry's data.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void copyEntryContents( final OutputStream output )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 32 * 1024 ];\n+        while( true )\n+        {\n+            final int numRead = read( buffer, 0, buffer.length );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            output.write( buffer, 0, numRead );\n+        }\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     *\n+     * @param markLimit The limit to mark.\n+     */\n+    public void mark( int markLimit )\n+    {\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we return false.\n+     *\n+     * @return False.\n+     */\n+    public boolean markSupported()\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * Reads a byte from the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @return The byte read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read()\n+        throws IOException\n+    {\n+        final int num = read( m_oneBuf, 0, 1 );\n+        if( num == -1 )\n+        {\n+            return num;\n+        }\n+        else\n+        {\n+            return (int)m_oneBuf[ 0 ];\n+        }\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @param buffer The buffer into which to place bytes read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read( final byte[] buffer )\n+        throws IOException\n+    {\n+        return read( buffer, 0, buffer.length );\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry. This method is aware of\n+     * the boundaries of the current entry in the archive and will deal with\n+     * them as if they were this stream's start and EOF.\n+     *\n+     * @param buffer The buffer into which to place bytes read.\n+     * @param offset The offset at which to place bytes read.\n+     * @param count The number of bytes to read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public int read( final byte[] buffer,\n+                     final int offset,\n+                     final int count )\n+        throws IOException\n+    {\n+        int position = offset;\n+        int numToRead = count;\n+        int totalRead = 0;\n+\n+        if( m_entryOffset >= m_entrySize )\n+        {\n+            return -1;\n+        }\n+\n+        if( ( numToRead + m_entryOffset ) > m_entrySize )\n+        {\n+            numToRead = ( m_entrySize - m_entryOffset );\n+        }\n+\n+        if( null != m_readBuf )\n+        {\n+            final int size =\n+                ( numToRead > m_readBuf.length ) ? m_readBuf.length : numToRead;\n+\n+            System.arraycopy( m_readBuf, 0, buffer, position, size );\n+\n+            if( size >= m_readBuf.length )\n+            {\n+                m_readBuf = null;\n+            }\n+            else\n+            {\n+                final int newLength = m_readBuf.length - size;\n+                final byte[] newBuffer = new byte[ newLength ];\n+\n+                System.arraycopy( m_readBuf, size, newBuffer, 0, newLength );\n+\n+                m_readBuf = newBuffer;\n+            }\n+\n+            totalRead += size;\n+            numToRead -= size;\n+            position += size;\n+        }\n+\n+        while( numToRead > 0 )\n+        {\n+            final byte[] rec = m_buffer.readRecord();\n+            if( null == rec )\n+            {\n+                // Unexpected EOF!\n+                final String message =\n+                    \"unexpected EOF with \" + numToRead + \" bytes unread\";\n+                throw new IOException( message );\n+            }\n+\n+            int size = numToRead;\n+            final int recordLength = rec.length;\n+\n+            if( recordLength > size )\n+            {\n+                System.arraycopy( rec, 0, buffer, position, size );\n+\n+                m_readBuf = new byte[ recordLength - size ];\n+\n+                System.arraycopy( rec, size, m_readBuf, 0, recordLength - size );\n+            }\n+            else\n+            {\n+                size = recordLength;\n+\n+                System.arraycopy( rec, 0, buffer, position, recordLength );\n+            }\n+\n+            totalRead += size;\n+            numToRead -= size;\n+            position += size;\n+        }\n+\n+        m_entryOffset += totalRead;\n+\n+        return totalRead;\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     */\n+    public void reset()\n+    {\n+    }\n+\n+    /**\n+     * Skip bytes in the input buffer. This skips bytes in the current entry's\n+     * data, not the entire archive, and will stop at the end of the current\n+     * entry's data if the number to skip extends beyond that point.\n+     *\n+     * @param numToSkip The number of bytes to skip.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void skip( final int numToSkip )\n+        throws IOException\n+    {\n+        // REVIEW\n+        // This is horribly inefficient, but it ensures that we\n+        // properly skip over bytes via the TarBuffer...\n+        //\n+        final byte[] skipBuf = new byte[ 8 * 1024 ];\n+        int num = numToSkip;\n+        while( num > 0 )\n+        {\n+            final int count = ( num > skipBuf.length ) ? skipBuf.length : num;\n+            final int numRead = read( skipBuf, 0, count );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            num -= numRead;\n+        }\n+    }\n+\n+    /**\n+     * Utility method to do debugging.\n+     * Capable of being overidden in sub-classes.\n+     *\n+     * @param message the message to use in debugging\n+     */\n+    protected void debug( final String message )\n+    {\n+        if( m_debug )\n+        {\n+            System.err.println( message );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+/**\n+ * The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are\n+ * provided to put entries, and then write their contents by writing to this\n+ * stream using write().\n+ *\n+ * @author Timothy Gerard Endres <a href=\"mailto:time@ice.com\">time@ice.com</a>\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ * @see TarInputStream\n+ * @see TarEntry\n+ */\n+public final class TarOutputStream extends FilterOutputStream\n+{\n+    /**\n+     * Flag to indicate that an error should be generated if\n+     * an attempt is made to write an entry that exceeds the 100 char\n+     * POSIX limit.\n+     */\n+    public static final int LONGFILE_ERROR = 0;\n+\n+    /**\n+     * Flag to indicate that entry name should be truncated if\n+     * an attempt is made to write an entry that exceeds the 100 char\n+     * POSIX limit.\n+     */\n+    public static final int LONGFILE_TRUNCATE = 1;\n+\n+    /**\n+     * Flag to indicate that entry name should be formatted\n+     * according to GNU tar extension if an attempt is made\n+     * to write an entry that exceeds the 100 char POSIX\n+     * limit. Note that this makes the jar unreadable by\n+     * non-GNU tar commands.\n+     */\n+    public static final int LONGFILE_GNU = 2;\n+\n+    private int m_longFileMode = LONGFILE_ERROR;\n+    private byte[] m_assemBuf;\n+    private int m_assemLen;\n+    private TarBuffer m_buffer;\n+    private int m_currBytes;\n+    private int m_currSize;\n+\n+    private byte[] m_oneBuf;\n+    private byte[] m_recordBuf;\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream and default block and record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @see TarBuffer#DEFAULT_BLOCKSIZE\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarOutputStream( final OutputStream output )\n+    {\n+        this( output, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream, block size and default record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @param blockSize the block size\n+     * @see TarBuffer#DEFAULT_RECORDSIZE\n+     */\n+    public TarOutputStream( final OutputStream output,\n+                            final int blockSize )\n+    {\n+        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n+    }\n+\n+    /**\n+     * Construct a TarOutputStream using specified input\n+     * stream, block size and record sizes.\n+     *\n+     * @param output stream to create TarOutputStream from\n+     * @param blockSize the block size\n+     * @param recordSize the record size\n+     */\n+    public TarOutputStream( final OutputStream output,\n+                            final int blockSize,\n+                            final int recordSize )\n+    {\n+        super( output );\n+\n+        m_buffer = new TarBuffer( output, blockSize, recordSize );\n+        m_assemLen = 0;\n+        m_assemBuf = new byte[ recordSize ];\n+        m_recordBuf = new byte[ recordSize ];\n+        m_oneBuf = new byte[ 1 ];\n+    }\n+\n+    /**\n+     * Sets the debugging flag in this stream's TarBuffer.\n+     *\n+     * @param debug The new BufferDebug value\n+     */\n+    public void setBufferDebug( boolean debug )\n+    {\n+        m_buffer.setDebug( debug );\n+    }\n+\n+    /**\n+     * Set the mode used to work with entrys exceeding\n+     * 100 chars (and thus break the POSIX standard).\n+     * Must be one of the LONGFILE_* constants.\n+     *\n+     * @param longFileMode the mode\n+     */\n+    public void setLongFileMode( final int longFileMode )\n+    {\n+        if( LONGFILE_ERROR != longFileMode &&\n+            LONGFILE_GNU != longFileMode &&\n+            LONGFILE_TRUNCATE != longFileMode )\n+        {\n+            throw new IllegalArgumentException( \"longFileMode\" );\n+        }\n+        m_longFileMode = longFileMode;\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize()\n+    {\n+        return m_buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Ends the TAR archive and closes the underlying OutputStream. This means\n+     * that finish() is called followed by calling the TarBuffer's close().\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void close()\n+        throws IOException\n+    {\n+        finish();\n+        m_buffer.close();\n+    }\n+\n+    /**\n+     * Close an entry. This method MUST be called for all file entries that\n+     * contain data. The reason is that we must buffer data written to the\n+     * stream in order to satisfy the buffer's record based writes. Thus, there\n+     * may be data fragments still being assembled that must be written to the\n+     * output stream before this entry is closed and the next entry written.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void closeEntry()\n+        throws IOException\n+    {\n+        if( m_assemLen > 0 )\n+        {\n+            for( int i = m_assemLen; i < m_assemBuf.length; ++i )\n+            {\n+                m_assemBuf[ i ] = 0;\n+            }\n+\n+            m_buffer.writeRecord( m_assemBuf );\n+\n+            m_currBytes += m_assemLen;\n+            m_assemLen = 0;\n+        }\n+\n+        if( m_currBytes < m_currSize )\n+        {\n+            final String message = \"entry closed at '\" + m_currBytes +\n+                \"' before the '\" + m_currSize +\n+                \"' bytes specified in the header were written\";\n+            throw new IOException( message );\n+        }\n+    }\n+\n+    /**\n+     * Ends the TAR archive without closing the underlying OutputStream. The\n+     * result is that the EOF record of nulls is written.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void finish()\n+        throws IOException\n+    {\n+        writeEOFRecord();\n+    }\n+\n+    /**\n+     * Put an entry on the output stream. This writes the entry's header record\n+     * and positions the output stream for writing the contents of the entry.\n+     * Once this method is called, the stream is ready for calls to write() to\n+     * write the entry's contents. Once the contents are written, closeEntry()\n+     * <B>MUST</B> be called to ensure that all buffered data is completely\n+     * written to the output stream.\n+     *\n+     * @param entry The TarEntry to be written to the archive.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void putNextEntry( final TarEntry entry )\n+        throws IOException\n+    {\n+        if( entry.getName().length() >= TarEntry.NAMELEN )\n+        {\n+            if( m_longFileMode == LONGFILE_GNU )\n+            {\n+                // create a TarEntry for the LongLink, the contents\n+                // of which are the entry's name\n+                final TarEntry longLinkEntry =\n+                    new TarEntry( TarEntry.GNU_LONGLINK,\n+                                  TarEntry.LF_GNUTYPE_LONGNAME );\n+\n+                longLinkEntry.setSize( entry.getName().length() );\n+                putNextEntry( longLinkEntry );\n+                write( entry.getName().getBytes() );\n+                //write( 0 );\n+                closeEntry();\n+            }\n+            else if( m_longFileMode != LONGFILE_TRUNCATE )\n+            {\n+                final String message = \"file name '\" + entry.getName() +\n+                    \"' is too long ( > \" + TarEntry.NAMELEN + \" bytes)\";\n+                throw new IOException( message );\n+            }\n+        }\n+\n+        entry.writeEntryHeader( m_recordBuf );\n+        m_buffer.writeRecord( m_recordBuf );\n+\n+        m_currBytes = 0;\n+\n+        if( entry.isDirectory() )\n+        {\n+            m_currSize = 0;\n+        }\n+        else\n+        {\n+            m_currSize = (int)entry.getSize();\n+        }\n+    }\n+\n+    /**\n+     * Copies the contents of the specified stream into current tar\n+     * archive entry.\n+     *\n+     * @param input The InputStream from which to read entrys data\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    void copyEntryContents( final InputStream input )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 32 * 1024 ];\n+        while( true )\n+        {\n+            final int numRead = input.read( buffer, 0, buffer.length );\n+            if( numRead == -1 )\n+            {\n+                break;\n+            }\n+\n+            write( buffer, 0, numRead );\n+        }\n+    }\n+\n+    /**\n+     * Writes a byte to the current tar archive entry. This method simply calls\n+     * read( byte[], int, int ).\n+     *\n+     * @param data The byte written.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final int data )\n+        throws IOException\n+    {\n+        m_oneBuf[ 0 ] = (byte)data;\n+\n+        write( m_oneBuf, 0, 1 );\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method simply calls\n+     * write( byte[], int, int ).\n+     *\n+     * @param buffer The buffer to write to the archive.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer )\n+        throws IOException\n+    {\n+        write( buffer, 0, buffer.length );\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method is aware of\n+     * the current entry and will throw an exception if you attempt to write\n+     * bytes past the length specified for the current entry. The method is also\n+     * (painfully) aware of the record buffering required by TarBuffer, and\n+     * manages buffers that are not a multiple of recordsize in length,\n+     * including assembling records from small buffers.\n+     *\n+     * @param buffer The buffer to write to the archive.\n+     * @param offset The offset in the buffer from which to get bytes.\n+     * @param count The number of bytes to write.\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer,\n+                       final int offset,\n+                       final int count )\n+        throws IOException\n+    {\n+        int position = offset;\n+        int numToWrite = count;\n+        if( ( m_currBytes + numToWrite ) > m_currSize )\n+        {\n+            final String message = \"request to write '\" + numToWrite +\n+                \"' bytes exceeds size in header of '\" + m_currSize + \"' bytes\";\n+            throw new IOException( message );\n+            //\n+            // We have to deal with assembly!!!\n+            // The programmer can be writing little 32 byte chunks for all\n+            // we know, and we must assemble complete records for writing.\n+            // REVIEW Maybe this should be in TarBuffer? Could that help to\n+            // eliminate some of the buffer copying.\n+            //\n+        }\n+\n+        if( m_assemLen > 0 )\n+        {\n+            if( ( m_assemLen + numToWrite ) >= m_recordBuf.length )\n+            {\n+                final int length = m_recordBuf.length - m_assemLen;\n+\n+                System.arraycopy( m_assemBuf, 0, m_recordBuf, 0,\n+                                  m_assemLen );\n+                System.arraycopy( buffer, position, m_recordBuf,\n+                                  m_assemLen, length );\n+                m_buffer.writeRecord( m_recordBuf );\n+\n+                m_currBytes += m_recordBuf.length;\n+                position += length;\n+                numToWrite -= length;\n+                m_assemLen = 0;\n+            }\n+            else\n+            {\n+                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n+                                  numToWrite );\n+\n+                position += numToWrite;\n+                m_assemLen += numToWrite;\n+                numToWrite -= numToWrite;\n+            }\n+        }\n+\n+        //\n+        // When we get here we have EITHER:\n+        // o An empty \"assemble\" buffer.\n+        // o No bytes to write (numToWrite == 0)\n+        //\n+        while( numToWrite > 0 )\n+        {\n+            if( numToWrite < m_recordBuf.length )\n+            {\n+                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n+                                  numToWrite );\n+\n+                m_assemLen += numToWrite;\n+\n+                break;\n+            }\n+\n+            m_buffer.writeRecord( buffer, position );\n+\n+            int num = m_recordBuf.length;\n+\n+            m_currBytes += num;\n+            numToWrite -= num;\n+            position += num;\n+        }\n+    }\n+\n+    /**\n+     * Write an EOF (end of archive) record to the tar archive. An EOF record\n+     * consists of a record of all zeros.\n+     *\n+     * @exception IOException when an IO error causes operation to fail\n+     */\n+    private void writeEOFRecord()\n+        throws IOException\n+    {\n+        for( int i = 0; i < m_recordBuf.length; ++i )\n+        {\n+            m_recordBuf[ i ] = 0;\n+        }\n+\n+        m_buffer.writeRecord( m_recordBuf );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+/**\n+ * This class provides static utility methods to work with byte streams.\n+ *\n+ * @author <a href=\"mailto:time@ice.com\">Timothy Gerard Endres</a>\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @version $Revision: 155439 $ $Date$\n+ */\n+public class TarUtils\n+{\n+    /**\n+     * Parse the checksum octal integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param value Description of Parameter\n+     * @param buf Description of Parameter\n+     * @return The integer value of the entry's checksum.\n+     */\n+    public static int getCheckSumOctalBytes( final long value,\n+                                             final byte[] buf,\n+                                             final int offset,\n+                                             final int length )\n+    {\n+        getOctalBytes( value, buf, offset, length );\n+\n+        buf[ offset + length - 1 ] = (byte)' ';\n+        buf[ offset + length - 2 ] = 0;\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal long integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param value Description of Parameter\n+     * @param buf Description of Parameter\n+     * @return The long value of the octal bytes.\n+     */\n+    public static int getLongOctalBytes( final long value,\n+                                         final byte[] buf,\n+                                         final int offset,\n+                                         final int length )\n+    {\n+        byte[] temp = new byte[ length + 1 ];\n+\n+        getOctalBytes( value, temp, 0, length + 1 );\n+        System.arraycopy( temp, 0, buf, offset, length );\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Determine the number of bytes in an entry name.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @param name Description of Parameter\n+     * @param buffer Description of Parameter\n+     * @return The number of bytes in a header's entry name.\n+     */\n+    public static int getNameBytes( final StringBuffer name,\n+                                    final byte[] buffer,\n+                                    final int offset,\n+                                    final int length )\n+    {\n+        int i;\n+\n+        for( i = 0; i < length && i < name.length(); ++i )\n+        {\n+            buffer[ offset + i ] = (byte)name.charAt( i );\n+        }\n+\n+        for( ; i < length; ++i )\n+        {\n+            buffer[ offset + i ] = 0;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal integer from a header buffer.\n+     *\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the octal bytes.\n+     */\n+    public static int getOctalBytes( final long value,\n+                                     final byte[] buffer,\n+                                     final int offset,\n+                                     final int length )\n+    {\n+        int idx = length - 1;\n+\n+        buffer[ offset + idx ] = 0;\n+        --idx;\n+        buffer[ offset + idx ] = (byte)' ';\n+        --idx;\n+\n+        if( value == 0 )\n+        {\n+            buffer[ offset + idx ] = (byte)'0';\n+            --idx;\n+        }\n+        else\n+        {\n+            long val = value;\n+            while( idx >= 0 && val > 0 )\n+            {\n+                buffer[ offset + idx ] = (byte)( (byte)'0' + (byte)( val & 7 ) );\n+                val = val >> 3;\n+                idx--;\n+            }\n+        }\n+\n+        while( idx >= 0 )\n+        {\n+            buffer[ offset + idx ] = (byte)' ';\n+            idx--;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Compute the checksum of a tar entry header.\n+     *\n+     * @param buffer The tar entry's header buffer.\n+     * @return The computed checksum.\n+     */\n+    public static long computeCheckSum( final byte[] buffer )\n+    {\n+        long sum = 0;\n+\n+        for( int i = 0; i < buffer.length; ++i )\n+        {\n+            sum += 255 & buffer[ i ];\n+        }\n+\n+        return sum;\n+    }\n+\n+    /**\n+     * Parse an entry name from a header buffer.\n+     *\n+     * @param header The header buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The header's entry name.\n+     */\n+    public static StringBuffer parseName( final byte[] header,\n+                                          final int offset,\n+                                          final int length )\n+    {\n+        StringBuffer result = new StringBuffer( length );\n+        int end = offset + length;\n+\n+        for( int i = offset; i < end; ++i )\n+        {\n+            if( header[ i ] == 0 )\n+            {\n+                break;\n+            }\n+\n+            result.append( (char)header[ i ] );\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Parse an octal string from a header buffer. This is used for the file\n+     * permission mode value.\n+     *\n+     * @param header The header buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The long value of the octal string.\n+     */\n+    public static long parseOctal( final byte[] header,\n+                                   final int offset,\n+                                   final int length )\n+    {\n+        long result = 0;\n+        boolean stillPadding = true;\n+        int end = offset + length;\n+\n+        for( int i = offset; i < end; ++i )\n+        {\n+            if( header[ i ] == 0 )\n+            {\n+                break;\n+            }\n+\n+            if( header[ i ] == (byte)' ' || header[ i ] == '0' )\n+            {\n+                if( stillPadding )\n+                {\n+                    continue;\n+                }\n+\n+                if( header[ i ] == (byte)' ' )\n+                {\n+                    break;\n+                }\n+            }\n+\n+            stillPadding = false;\n+            result = ( result << 3 ) + ( header[ i ] - '0' );\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Adds Unix file permission and UID/GID fields as well as symbolic link\n+ * handling. <p>\n+ *\n+ * This class uses the ASi extra field in the format: <pre>\n+ *         Value         Size            Description\n+ *         -----         ----            -----------\n+ * (Unix3) 0x756e        Short           tag for this extra block type\n+ *         TSize         Short           total data size for this block\n+ *         CRC           Long            CRC-32 of the remaining data\n+ *         Mode          Short           file permissions\n+ *         SizDev        Long            symlink'd size OR major/minor dev num\n+ *         UID           Short           user ID\n+ *         GID           Short           group ID\n+ *         (var.)        variable        symbolic link filename\n+ * </pre> taken from appnote.iz (Info-ZIP note, 981119) found at <a\n+ * href=\"ftp://ftp.uu.net/pub/archiving/zip/doc/\">\n+ * ftp://ftp.uu.net/pub/archiving/zip/doc/</a> </p> <p>\n+ *\n+ * Short is two bytes and Long is four bytes in big endian byte and word order,\n+ * device numbers are currently not supported.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public class AsiExtraField\n+    implements ZipExtraField, UnixStat, Cloneable\n+{\n+    private static final ZipShort HEADER_ID = new ZipShort( 0x756E );\n+\n+    /**\n+     * Standard Unix stat(2) file mode.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_mode;\n+\n+    /**\n+     * User ID.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_uid;\n+\n+    /**\n+     * Group ID.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_gid;\n+\n+    /**\n+     * File this entry points to, if it is a symbolic link. <p>\n+     *\n+     * empty string - if entry is not a symbolic link.</p>\n+     *\n+     * @since 1.1\n+     */\n+    private String m_link = \"\";\n+\n+    /**\n+     * Is this an entry for a directory?\n+     *\n+     * @since 1.1\n+     */\n+    private boolean m_dirFlag;\n+\n+    /**\n+     * Instance used to calculate checksums.\n+     *\n+     * @since 1.1\n+     */\n+    private CRC32 m_crc = new CRC32();\n+\n+    /**\n+     * Indicate whether this entry is a directory.\n+     *\n+     * @param dirFlag The new Directory value\n+     * @since 1.1\n+     */\n+    public void setDirectory( final boolean dirFlag )\n+    {\n+        m_dirFlag = dirFlag;\n+        m_mode = getMode( m_mode );\n+    }\n+\n+    /**\n+     * Set the group id.\n+     *\n+     * @param gid The new GroupId value\n+     * @since 1.1\n+     */\n+    public void setGroupId( int gid )\n+    {\n+        m_gid = gid;\n+    }\n+\n+    /**\n+     * Indicate that this entry is a symbolic link to the given filename.\n+     *\n+     * @param name Name of the file this entry links to, empty String if it is\n+     *      not a symbolic link.\n+     * @since 1.1\n+     */\n+    public void setLinkedFile( final String name )\n+    {\n+        m_link = name;\n+        m_mode = getMode( m_mode );\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     *\n+     * @param mode The new Mode value\n+     * @since 1.1\n+     */\n+    public void setMode( final int mode )\n+    {\n+        m_mode = getMode( mode );\n+    }\n+\n+    /**\n+     * Set the user id.\n+     *\n+     * @param uid The new UserId value\n+     * @since 1.1\n+     * @deprecated Use setUserID(int)\n+     * @see #setUserID(int)\n+     */\n+    public void setUserId( final int uid )\n+    {\n+        m_uid = uid;\n+    }\n+\n+    /**\n+     * Set the user id.\n+     *\n+     * @param uid The new UserId value\n+     */\n+    public void setUserID( final int uid )\n+    {\n+        m_uid = uid;\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     *\n+     * @return The CentralDirectoryData value\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryData()\n+    {\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Delegate to local file data.\n+     *\n+     * @return The CentralDirectoryLength value\n+     * @since 1.1\n+     */\n+    public ZipShort getCentralDirectoryLength()\n+    {\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the group id.\n+     *\n+     * @return The GroupId value\n+     * @since 1.1\n+     */\n+    public int getGroupID()\n+    {\n+        return m_gid;\n+    }\n+\n+    /**\n+     * Get the group id.\n+     *\n+     * @return The GroupId value\n+     * @since 1.1\n+     * @deprecated Use getGroupID() instead\n+     * @see #getGroupID()\n+     */\n+    public int getGroupId()\n+    {\n+        return m_gid;\n+    }\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return The HeaderId value\n+     * @since 1.1\n+     */\n+    public ZipShort getHeaderID()\n+    {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Name of linked file\n+     *\n+     * @return name of the file this entry links to if it is a symbolic link,\n+     *      the empty string otherwise.\n+     * @since 1.1\n+     */\n+    public String getLinkedFile()\n+    {\n+        return m_link;\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The LocalFileDataData value\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataData()\n+    {\n+        // CRC will be added later\n+        byte[] data = new byte[ getLocalFileDataLength().getValue() - 4 ];\n+        System.arraycopy( ( new ZipShort( getMode() ) ).getBytes(), 0, data, 0, 2 );\n+\n+        byte[] linkArray = getLinkedFile().getBytes();\n+        System.arraycopy( ( new ZipLong( linkArray.length ) ).getBytes(),\n+                          0, data, 2, 4 );\n+\n+        System.arraycopy( ( new ZipShort( getUserID() ) ).getBytes(),\n+                          0, data, 6, 2 );\n+        System.arraycopy( ( new ZipShort( getGroupID() ) ).getBytes(),\n+                          0, data, 8, 2 );\n+\n+        System.arraycopy( linkArray, 0, data, 10, linkArray.length );\n+\n+        m_crc.reset();\n+        m_crc.update( data );\n+        long checksum = m_crc.getValue();\n+\n+        byte[] result = new byte[ data.length + 4 ];\n+        System.arraycopy( ( new ZipLong( checksum ) ).getBytes(), 0, result, 0, 4 );\n+        System.arraycopy( data, 0, result, 4, data.length );\n+        return result;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The LocalFileDataLength value\n+     * @since 1.1\n+     */\n+    public ZipShort getLocalFileDataLength()\n+    {\n+        return new ZipShort( 4 + // CRC\n+                             2 + // Mode\n+                             4 + // SizDev\n+                             2 + // UID\n+                             2 + // GID\n+                             getLinkedFile().getBytes().length );\n+    }\n+\n+    /**\n+     * File mode of this file.\n+     *\n+     * @return The Mode value\n+     * @since 1.1\n+     */\n+    public int getMode()\n+    {\n+        return m_mode;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     *\n+     * @return The UserId value\n+     * @since 1.1\n+     * @deprecated Use getUserID()\n+     * @see #getUserID()\n+     */\n+    public int getUserId()\n+    {\n+        return m_uid;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     *\n+     * @return The UserID value\n+     */\n+    public int getUserID()\n+    {\n+        return m_uid;\n+    }\n+\n+    /**\n+     * Is this entry a directory?\n+     *\n+     * @return The Directory value\n+     * @since 1.1\n+     */\n+    public boolean isDirectory()\n+    {\n+        return m_dirFlag && !isLink();\n+    }\n+\n+    /**\n+     * Is this entry a symbolic link?\n+     *\n+     * @return The Link value\n+     * @since 1.1\n+     */\n+    public boolean isLink()\n+    {\n+        return getLinkedFile().length() != 0;\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param buffer the buffer\n+     * @param offset the offset into buffer\n+     * @param length the length of data in buffer\n+     * @throws ZipException on error\n+     * @since 1.1\n+     */\n+    public void parseFromLocalFileData( final byte[] buffer,\n+                                        final int offset,\n+                                        final int length )\n+        throws ZipException\n+    {\n+\n+        long givenChecksum = ( new ZipLong( buffer, offset ) ).getValue();\n+        byte[] tmp = new byte[ length - 4 ];\n+        System.arraycopy( buffer, offset + 4, tmp, 0, length - 4 );\n+        m_crc.reset();\n+        m_crc.update( tmp );\n+        long realChecksum = m_crc.getValue();\n+        if( givenChecksum != realChecksum )\n+        {\n+            throw new ZipException( \"bad CRC checksum \" + Long.toHexString( givenChecksum ) +\n+                                    \" instead of \" + Long.toHexString( realChecksum ) );\n+        }\n+\n+        int newMode = ( new ZipShort( tmp, 0 ) ).getValue();\n+        byte[] linkArray = new byte[ (int)( new ZipLong( tmp, 2 ) ).getValue() ];\n+        m_uid = ( new ZipShort( tmp, 6 ) ).getValue();\n+        m_gid = ( new ZipShort( tmp, 8 ) ).getValue();\n+\n+        if( linkArray.length == 0 )\n+        {\n+            m_link = \"\";\n+        }\n+        else\n+        {\n+            System.arraycopy( tmp, 10, linkArray, 0, linkArray.length );\n+            m_link = new String( linkArray );\n+        }\n+        setDirectory( ( newMode & DIR_FLAG ) != 0 );\n+        setMode( newMode );\n+    }\n+\n+    /**\n+     * Get the file mode for given permissions with the correct file type.\n+     *\n+     * @param mode Description of Parameter\n+     * @return The Mode value\n+     * @since 1.1\n+     */\n+    protected int getMode( final int mode )\n+    {\n+        int type = FILE_FLAG;\n+        if( isLink() )\n+        {\n+            type = LINK_FLAG;\n+        }\n+        else if( isDirectory() )\n+        {\n+            type = DIR_FLAG;\n+        }\n+        return type | ( mode & PERM_MASK );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * ZipExtraField related methods\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public class ExtraFieldUtils\n+{\n+    /**\n+     * Static registry of known extra fields.\n+     *\n+     * @since 1.1\n+     */\n+    private static final Hashtable c_implementations;\n+\n+    static\n+    {\n+        c_implementations = new Hashtable();\n+        register( AsiExtraField.class );\n+    }\n+\n+    /**\n+     * Create an instance of the approriate ExtraField, falls back to {@link\n+     * UnrecognizedExtraField UnrecognizedExtraField}.\n+     *\n+     * Throws java.lang.IllegalAccessException if cant create implementation.\n+     *\n+     * @param headerID the header ID\n+     * @return the extra field implementation\n+     * @throws InstantiationException if cant create implementation\n+     * @throws IllegalAccessException if cant create implementation\n+     * @since 1.1\n+     */\n+    public static ZipExtraField createExtraField( final ZipShort headerID )\n+        throws InstantiationException, IllegalAccessException\n+    {\n+        final Class clazz =\n+            (Class)c_implementations.get( headerID );\n+        if( clazz != null )\n+        {\n+            return (ZipExtraField)clazz.newInstance();\n+        }\n+        final UnrecognizedExtraField unrecognized = new UnrecognizedExtraField();\n+        unrecognized.setHeaderID( headerID );\n+        return unrecognized;\n+    }\n+\n+    /**\n+     * Merges the central directory fields of the given ZipExtraFields.\n+     *\n+     * @param data the central directory data\n+     * @return the merged data\n+     * @since 1.1\n+     */\n+    public static byte[] mergeCentralDirectoryData( final ZipExtraField[] data )\n+    {\n+        int sum = 4 * data.length;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            sum += data[ i ].getCentralDirectoryLength().getValue();\n+        }\n+        byte[] result = new byte[ sum ];\n+        int start = 0;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n+                              0, result, start, 2 );\n+            System.arraycopy( data[ i ].getCentralDirectoryLength().getBytes(),\n+                              0, result, start + 2, 2 );\n+            byte[] local = data[ i ].getCentralDirectoryData();\n+            System.arraycopy( local, 0, result, start + 4, local.length );\n+            start += ( local.length + 4 );\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Merges the local file data fields of the given ZipExtraFields.\n+     *\n+     * @param data the data\n+     * @return the merged data\n+     * @since 1.1\n+     */\n+    public static byte[] mergeLocalFileDataData( final ZipExtraField[] data )\n+    {\n+        int sum = 4 * data.length;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            sum += data[ i ].getLocalFileDataLength().getValue();\n+        }\n+        byte[] result = new byte[ sum ];\n+        int start = 0;\n+        for( int i = 0; i < data.length; i++ )\n+        {\n+            System.arraycopy( data[ i ].getHeaderID().getBytes(),\n+                              0, result, start, 2 );\n+            System.arraycopy( data[ i ].getLocalFileDataLength().getBytes(),\n+                              0, result, start + 2, 2 );\n+            byte[] local = data[ i ].getLocalFileDataData();\n+            System.arraycopy( local, 0, result, start + 4, local.length );\n+            start += ( local.length + 4 );\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Split the array into ExtraFields and populate them with the give data.\n+     *\n+     * @param data the data to parse\n+     * @return the parsed fields\n+     * @exception ZipException on error\n+     * @since 1.1\n+     */\n+    public static ZipExtraField[] parse( final byte[] data )\n+        throws ZipException\n+    {\n+        ArrayList v = new ArrayList();\n+        int start = 0;\n+        while( start <= data.length - 4 )\n+        {\n+            final ZipShort headerID = new ZipShort( data, start );\n+            int length = ( new ZipShort( data, start + 2 ) ).getValue();\n+            if( start + 4 + length > data.length )\n+            {\n+                throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n+            }\n+            try\n+            {\n+                ZipExtraField ze = createExtraField( headerID );\n+                ze.parseFromLocalFileData( data, start + 4, length );\n+                v.add( ze );\n+            }\n+            catch( InstantiationException ie )\n+            {\n+                throw new ZipException( ie.getMessage() );\n+            }\n+            catch( IllegalAccessException iae )\n+            {\n+                throw new ZipException( iae.getMessage() );\n+            }\n+            start += ( length + 4 );\n+        }\n+        if( start != data.length )\n+        {// array not exhausted\n+            throw new ZipException( \"data starting at \" + start + \" is in unknown format\" );\n+        }\n+\n+        final ZipExtraField[] result = new ZipExtraField[ v.size() ];\n+        return (ZipExtraField[])v.toArray( result );\n+    }\n+\n+    /**\n+     * Register a ZipExtraField implementation. <p>\n+     *\n+     * The given class must have a no-arg constructor and implement the {@link\n+     * ZipExtraField ZipExtraField interface}.</p>\n+     *\n+     * @param clazz The Class for particular implementation\n+     * @since 1.1\n+     */\n+    public static void register( final Class clazz )\n+    {\n+        try\n+        {\n+            ZipExtraField ze = (ZipExtraField)clazz.newInstance();\n+            c_implementations.put( ze.getHeaderID(), clazz );\n+        }\n+        catch( ClassCastException cc )\n+        {\n+            throw new RuntimeException( clazz +\n+                                        \" doesn\\'t implement ZipExtraField\" );\n+        }\n+        catch( InstantiationException ie )\n+        {\n+            throw new RuntimeException( clazz + \" is not a concrete class\" );\n+        }\n+        catch( IllegalAccessException ie )\n+        {\n+            throw new RuntimeException( clazz +\n+                                        \"\\'s no-arg constructor is not public\" );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Constants from stat.h on Unix systems.\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public interface UnixStat\n+{\n+    /**\n+     * Bits used for permissions (and sticky bit)\n+     *\n+     * @since 1.1\n+     */\n+    int PERM_MASK = 07777;\n+    /**\n+     * Indicates symbolic links.\n+     *\n+     * @since 1.1\n+     */\n+    int LINK_FLAG = 0120000;\n+    /**\n+     * Indicates plain files.\n+     *\n+     * @since 1.1\n+     */\n+    int FILE_FLAG = 0100000;\n+    /**\n+     * Indicates directories.\n+     *\n+     * @since 1.1\n+     */\n+    int DIR_FLAG = 040000;\n+\n+    // ----------------------------------------------------------\n+    // somewhat arbitrary choices that are quite common for shared\n+    // installations\n+    // -----------------------------------------------------------\n+\n+    /**\n+     * Default permissions for symbolic links.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_LINK_PERM = 0777;\n+\n+    /**\n+     * Default permissions for directories.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_DIR_PERM = 0755;\n+\n+    /**\n+     * Default permissions for plain files.\n+     *\n+     * @since 1.1\n+     */\n+    int DEFAULT_FILE_PERM = 0644;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Simple placeholder for all those extra fields we don't want to deal with. <p>\n+ *\n+ * Assumes local file data and central directory entries are identical - unless\n+ * told the opposite.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public class UnrecognizedExtraField\n+    implements ZipExtraField\n+{\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     *\n+     * @since 1.1\n+     */\n+    private byte[] m_centralData;\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipShort m_headerID;\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @since 1.1\n+     */\n+    private byte[] m_localData;\n+\n+    /**\n+     * Set the central directory data\n+     *\n+     * @param centralData the central directory data\n+     */\n+    public void setCentralDirectoryData( final byte[] centralData )\n+    {\n+        m_centralData = centralData;\n+    }\n+\n+       /**\n+     * Set the header ID.\n+     *\n+     * @param headerID the header ID\n+     */\n+    public void setHeaderID( final ZipShort headerID )\n+    {\n+        m_headerID = headerID;\n+    }\n+\n+    /**\n+     * Set the local file data.\n+     *\n+     * @param localData the local file data\n+     */\n+    public void setLocalFileDataData( final byte[] localData )\n+    {\n+        m_localData = localData;\n+    }\n+\n+    /**\n+     * Get the central directory data.\n+     *\n+     * @return the central directory data.\n+     */\n+    public byte[] getCentralDirectoryData()\n+    {\n+        if( m_centralData != null )\n+        {\n+            return m_centralData;\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Get the length of the central directory in bytes.\n+     *\n+     * @return the length of the central directory in bytes.\n+     */\n+    public ZipShort getCentralDirectoryLength()\n+    {\n+        if( m_centralData != null )\n+        {\n+            return new ZipShort( m_centralData.length );\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the HeaderID.\n+     *\n+     * @return the HeaderID\n+     */\n+    public ZipShort getHeaderID()\n+    {\n+        return m_headerID;\n+    }\n+\n+    /**\n+     * Get the local file data.\n+     *\n+     * @return the local file data\n+     */\n+    public byte[] getLocalFileDataData()\n+    {\n+        return m_localData;\n+    }\n+\n+    /**\n+     * Get the length of local file data in bytes.\n+     *\n+     * @return the length of local file data in bytes\n+     */\n+    public ZipShort getLocalFileDataLength()\n+    {\n+        return new ZipShort( m_localData.length );\n+    }\n+\n+    /**\n+     * Parse LocalFiledata out of supplied buffer.\n+     *\n+     * @param buffer the buffer to use\n+     * @param offset the offset into buffer\n+     * @param length then length of data\n+     */\n+    public void parseFromLocalFileData( final byte[] buffer,\n+                                        final int offset,\n+                                        final int length )\n+    {\n+        final byte[] fileData = new byte[ length ];\n+        System.arraycopy( buffer, offset, fileData, 0, length );\n+        setLocalFileDataData( fileData );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipArchive.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+import java.util.zip.ZipInputStream;\n+\n+import org.apache.commons.compress.AbstractArchive;\n+import org.apache.commons.compress.ArchiveEntry;\n+import org.apache.commons.compress.ArchiveException;\n+import org.apache.commons.compress.UnpackException;\n+\n+/**\n+ * Archive-Implementation for Zip.\n+ */\n+public class ZipArchive extends AbstractArchive {\n+\n+\t/* Buffer for the file operations */\n+\tprivate static final int BUFFER = 2048;\n+\n+\t/**\n+\t * HEADER Field for this archiver.\n+\t */\n+\tprivate static final byte[] HEADER = { 0x50, 0x4b, 0x03, 0x04 };\n+\t\n+\t/**\n+\t * DEFAULT_FILE_EXTENSION Field for this archiver.\n+\t */\n+\tprivate static String DEFAULT_FILE_EXTENSION = \"zip\";\n+\n+\t/**\n+\t * ARCHIVER_NAME Field for this archiver.\n+\t */\n+\tprivate static final String ARCHIVER_NAME = \"zip\";\n+\t\n+\t/**\n+\t * This Archive should be instantiated in the Archive-Interface.\n+\t */\n+\tpublic ZipArchive() {\n+\t\t// Empty\n+\t}\n+\t\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#unpack()\n+\t */\n+\tprotected void doUnpack(File unpackDir) throws UnpackException {\n+\t\tBufferedOutputStream destination = null;\n+\t\tFileInputStream fInputStream = null;\n+\t\t\n+\t\ttry {\n+\t\t\tfInputStream = new FileInputStream(this.getArchive());\n+\t\t} catch(FileNotFoundException e) {\n+\t\t\tthrow new UnpackException(\"SourceFile could not be found.\", e);\n+\t\t}\n+\t\tZipInputStream zInputStream = null;\n+\t\ttry {\n+\t\t\t// TODO: we have no ZipInputStream yet, so we need the sun implementation\n+\t\t\tzInputStream = new ZipInputStream(new BufferedInputStream(fInputStream));\n+\t\t\tjava.util.zip.ZipEntry entry;\n+\t\t\t\n+\t\t\twhile((entry = zInputStream.getNextEntry()) != null) {\n+\t\t\t\tint count;\n+\t\t\t\tbyte data[] = new byte[BUFFER];\n+\n+\t\t\t\tString fosString = unpackDir.getAbsolutePath() + File.separator + entry.getName();\n+\t\t\t\tFileOutputStream fos = new FileOutputStream(fosString);\n+\t\t\t\tdestination = new BufferedOutputStream(fos, BUFFER);\n+\t\t\t\t\n+\t\t\t\twhile((count = zInputStream.read(data, 0, BUFFER))!= -1) {\n+\t\t\t\t\tdestination.write(data, 0, count);\n+\t\t\t\t}\n+\t\t\t\tdestination.flush();\n+\t\t\t\tdestination.close();\n+\t\t\t}\n+\t\t} catch(IOException e) {\n+\t\t\tthrow new UnpackException(\"Exception while unpacking.\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tzInputStream.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new UnpackException(\"Exception while unpacking.\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#pack()\n+\t */\n+\tprotected void doSave(FileOutputStream output) throws ArchiveException {\n+\t\t// Stream initializing\n+\t\tBufferedInputStream origin = null;\n+\t\t\n+\t\t//out.setMethod(ZipOutputStream.DEFLATED);\n+\t\tbyte data[] = new byte[BUFFER];\n+\t\t\n+\t\t// get a list of filesStreams from current directory\n+\t\t// less than one file leads to an exception\n+\t\tIterator iterator = this.getEntryIterator();\n+\t\tif(!iterator.hasNext()) {\n+\t\t\tthrow new ArchiveException(\"There must be at least one file to be pack.\");\n+\t\t}\n+\t\t\n+\t\t// Pack-Operation\n+\t\tZipOutputStream out = null;\n+\t\ttry {\n+\t\t\tout = new ZipOutputStream(new BufferedOutputStream(output));\n+\t\t\twhile(iterator.hasNext()) {\n+\t\t\t\tArchiveEntry archiveEntry = (ArchiveEntry)iterator.next();\n+\t\t\t\tInputStream fInputStream = archiveEntry.getStream();\n+\n+\t\t\t\torigin = new BufferedInputStream(fInputStream, BUFFER);\n+\t\t\t\tZipEntry entry = new ZipEntry(archiveEntry.getName());\n+\t\t\t\tout.putNextEntry(entry);\n+\t\t\t\n+\t\t\t\tint count;\n+\t\t\t\twhile((count = origin.read(data, 0,\tBUFFER)) != -1) {\n+\t\t\t\t\tout.write(data, 0, count);\n+\t\t\t\t}\n+\t\t\t\torigin.close();\n+\t\t\t}\t\t\t\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new ArchiveException(\"Creation of this archive failed cause of IOExceptions.\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tout.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new ArchiveException(\"Creation of this archive failed cause of IOExceptions.\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getArchiverName()\n+\t */\n+\tpublic String getName() {\n+\t\treturn ARCHIVER_NAME;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getDefaultFileExtension()\n+\t */\n+\tpublic String getDefaultFileExtension() {\n+\t\treturn DEFAULT_FILE_EXTENSION;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Archive#getHeader()\n+\t */\n+\tpublic byte[] getHeader() {\n+\t\treturn HEADER;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipEntry.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Extension that adds better handling of extra fields and provides access to\n+ * the internal and external file attributes.\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public class ZipEntry\n+    extends java.util.zip.ZipEntry\n+{\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static Method c_setCompressedSizeMethod;\n+\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static final Object c_lockReflection = new Object();\n+\n+    /**\n+     * Helper for JDK 1.1\n+     *\n+     * @since 1.2\n+     */\n+    private static boolean c_triedToGetMethod;\n+\n+    private final ArrayList m_extraFields = new ArrayList();\n+\n+    private int m_internalAttributes;\n+    private long m_externalAttributes;\n+\n+    /**\n+     * Helper for JDK 1.1 <-> 1.2 incompatibility.\n+     *\n+     * @since 1.2\n+     */\n+    private Long m_compressedSize;\n+\n+    /**\n+     * Creates a new zip entry with the specified name.\n+     *\n+     * @param name the name of entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     *\n+     * @param entry the JDK ZipEntry to adapt\n+     * @exception ZipException if can not create entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( java.util.zip.ZipEntry entry )\n+        throws ZipException\n+    {\n+        /*\n+         * REVISIT: call super(entry) instead of this stuff in Ant2,\n+         * \"copy constructor\" has not been available in JDK 1.1\n+         */\n+        super( entry.getName() );\n+\n+        setComment( entry.getComment() );\n+        setMethod( entry.getMethod() );\n+        setTime( entry.getTime() );\n+\n+        final long size = entry.getSize();\n+        if( size > 0 )\n+        {\n+            setSize( size );\n+        }\n+\n+        final long cSize = entry.getCompressedSize();\n+        if( cSize > 0 )\n+        {\n+            setComprSize( cSize );\n+        }\n+\n+        final long crc = entry.getCrc();\n+        if( crc > 0 )\n+        {\n+            setCrc( crc );\n+        }\n+\n+        final byte[] extra = entry.getExtra();\n+        if( extra != null )\n+        {\n+            setExtraFields( ExtraFieldUtils.parse( extra ) );\n+        }\n+        else\n+        {\n+            // initializes extra data to an empty byte array\n+            setExtra();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new zip entry with fields taken from the specified zip entry.\n+     *\n+     * @param entry the entry to adapt\n+     * @exception ZipException if can not create entry\n+     * @since 1.1\n+     */\n+    public ZipEntry( final ZipEntry entry )\n+        throws ZipException\n+    {\n+        this( (java.util.zip.ZipEntry)entry );\n+        setInternalAttributes( entry.getInternalAttributes() );\n+        setExternalAttributes( entry.getExternalAttributes() );\n+        setExtraFields( entry.getExtraFields() );\n+    }\n+\n+    /**\n+     * Try to get a handle to the setCompressedSize method.\n+     *\n+     * @since 1.2\n+     */\n+    private static void checkSCS()\n+    {\n+        if( !c_triedToGetMethod )\n+        {\n+            synchronized( c_lockReflection )\n+            {\n+                c_triedToGetMethod = true;\n+                try\n+                {\n+                    c_setCompressedSizeMethod =\n+                        java.util.zip.ZipEntry.class.getMethod( \"setCompressedSize\",\n+                                                                new Class[]{Long.TYPE} );\n+                }\n+                catch( NoSuchMethodException nse )\n+                {\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Are we running JDK 1.2 or higher?\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.2\n+     */\n+    private static boolean haveSetCompressedSize()\n+    {\n+        checkSCS();\n+        return c_setCompressedSizeMethod != null;\n+    }\n+\n+    /**\n+     * Invoke setCompressedSize via reflection.\n+     *\n+     * @param entry Description of Parameter\n+     * @param size Description of Parameter\n+     * @since 1.2\n+     */\n+    private static void performSetCompressedSize( final ZipEntry entry,\n+                                                  final long size )\n+    {\n+        final Long[] s = {new Long( size )};\n+        try\n+        {\n+            c_setCompressedSizeMethod.invoke( entry, s );\n+        }\n+        catch( final InvocationTargetException ite )\n+        {\n+            final Throwable nested = ite.getTargetException();\n+            final String message = \"Exception setting the compressed size \" +\n+                \"of \" + entry + \": \" + nested.getMessage();\n+            throw new RuntimeException( message );\n+        }\n+        catch( final Throwable t )\n+        {\n+            final String message = \"Exception setting the compressed size \" +\n+                \"of \" + entry + \": \" + t.getMessage();\n+            throw new RuntimeException( message );\n+        }\n+    }\n+\n+    /**\n+     * Make this class work in JDK 1.1 like a 1.2 class. <p>\n+     *\n+     * This either stores the size for later usage or invokes setCompressedSize\n+     * via reflection.</p>\n+     *\n+     * @param size The new ComprSize value\n+     * @since 1.2\n+     */\n+    public void setComprSize( final long size )\n+    {\n+        if( haveSetCompressedSize() )\n+        {\n+            performSetCompressedSize( this, size );\n+        }\n+        else\n+        {\n+            m_compressedSize = new Long( size );\n+        }\n+    }\n+\n+    /**\n+     * Sets the external file attributes.\n+     *\n+     * @param externalAttributes The new ExternalAttributes value\n+     * @since 1.1\n+     */\n+    public void setExternalAttributes( final long externalAttributes )\n+    {\n+        m_externalAttributes = externalAttributes;\n+    }\n+\n+    /**\n+     * Throws an Exception if extra data cannot be parsed into extra fields.\n+     *\n+     * @param extra The new Extra value\n+     * @throws RuntimeException if fail to set extra data\n+     * @since 1.1\n+     */\n+    public void setExtra( final byte[] extra )\n+        throws RuntimeException\n+    {\n+        try\n+        {\n+            setExtraFields( ExtraFieldUtils.parse( extra ) );\n+        }\n+        catch( final Exception e )\n+        {\n+            throw new RuntimeException( e.getMessage() );\n+        }\n+    }\n+\n+    /**\n+     * Replaces all currently attached extra fields with the new array.\n+     *\n+     * @param fields The new ExtraFields value\n+     * @since 1.1\n+     */\n+    public void setExtraFields( final ZipExtraField[] fields )\n+    {\n+        m_extraFields.clear();\n+        for( int i = 0; i < fields.length; i++ )\n+        {\n+            m_extraFields.add( fields[ i ] );\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Sets the internal file attributes.\n+     *\n+     * @param value The new InternalAttributes value\n+     * @since 1.1\n+     */\n+    public void setInternalAttributes( final int value )\n+    {\n+        m_internalAttributes = value;\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the central directory.\n+     *\n+     * @return The CentralDirectoryExtra value\n+     * @since 1.1\n+     */\n+    public byte[] getCentralDirectoryExtra()\n+    {\n+        return ExtraFieldUtils.mergeCentralDirectoryData( getExtraFields() );\n+    }\n+\n+    /**\n+     * Override to make this class work in JDK 1.1 like a 1.2 class.\n+     *\n+     * @return The CompressedSize value\n+     * @since 1.2\n+     */\n+    public long getCompressedSize()\n+    {\n+        if( m_compressedSize != null )\n+        {\n+            // has been set explicitly and we are running in a 1.1 VM\n+            return m_compressedSize.longValue();\n+        }\n+        return super.getCompressedSize();\n+    }\n+\n+    /**\n+     * Retrieves the external file attributes.\n+     *\n+     * @return The ExternalAttributes value\n+     * @since 1.1\n+     */\n+    public long getExternalAttributes()\n+    {\n+        return m_externalAttributes;\n+    }\n+\n+    /**\n+     * Retrieves extra fields.\n+     *\n+     * @return The ExtraFields value\n+     * @since 1.1\n+     */\n+    public ZipExtraField[] getExtraFields()\n+    {\n+        final ZipExtraField[] result = new ZipExtraField[ m_extraFields.size() ];\n+        return (ZipExtraField[])m_extraFields.toArray( result );\n+    }\n+\n+    /**\n+     * Retrieves the internal file attributes.\n+     *\n+     * @return The InternalAttributes value\n+     * @since 1.1\n+     */\n+    public int getInternalAttributes()\n+    {\n+        return m_internalAttributes;\n+    }\n+\n+    /**\n+     * Retrieves the extra data for the local file data.\n+     *\n+     * @return The LocalFileDataExtra value\n+     * @since 1.1\n+     */\n+    public byte[] getLocalFileDataExtra()\n+    {\n+        byte[] extra = getExtra();\n+        return extra != null ? extra : new byte[ 0 ];\n+    }\n+\n+    /**\n+     * Adds an extra fields - replacing an already present extra field of the\n+     * same type.\n+     *\n+     * @param extraField The feature to be added to the ExtraField attribute\n+     * @since 1.1\n+     */\n+    public void addExtraField( final ZipExtraField extraField )\n+    {\n+        final ZipShort type = extraField.getHeaderID();\n+        boolean done = false;\n+        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n+        {\n+            final ZipExtraField other = (ZipExtraField)m_extraFields.get( i );\n+            if( other.getHeaderID().equals( type ) )\n+            {\n+                m_extraFields.set( i, extraField );\n+                done = true;\n+            }\n+        }\n+        if( !done )\n+        {\n+            m_extraFields.add( extraField );\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Overwrite clone\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public Object clone()\n+    {\n+        ZipEntry entry = null;\n+        try\n+        {\n+            entry = new ZipEntry( (java.util.zip.ZipEntry)super.clone() );\n+        }\n+        catch( final Exception e )\n+        {\n+            // impossible as extra data is in correct format\n+            e.printStackTrace();\n+            return null;\n+        }\n+\n+        entry.setInternalAttributes( getInternalAttributes() );\n+        entry.setExternalAttributes( getExternalAttributes() );\n+        entry.setExtraFields( getExtraFields() );\n+        return entry;\n+    }\n+\n+    /**\n+     * Remove an extra fields.\n+     *\n+     * @param type Description of Parameter\n+     * @since 1.1\n+     */\n+    public void removeExtraField( final ZipShort type )\n+    {\n+        boolean done = false;\n+        for( int i = 0; !done && i < m_extraFields.size(); i++ )\n+        {\n+            if( ( (ZipExtraField)m_extraFields.get( i ) ).getHeaderID().equals( type ) )\n+            {\n+                m_extraFields.remove( i );\n+                done = true;\n+            }\n+        }\n+        if( !done )\n+        {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        setExtra();\n+    }\n+\n+    /**\n+     * Unfortunately {@link java.util.zip.ZipOutputStream\n+     * java.util.zip.ZipOutputStream} seems to access the extra data directly,\n+     * so overriding getExtra doesn't help - we need to modify super's data\n+     * directly.\n+     *\n+     * @since 1.1\n+     */\n+    protected void setExtra()\n+    {\n+        super.setExtra( ExtraFieldUtils.mergeLocalFileDataData( getExtraFields() ) );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.ZipException;\n+\n+/**\n+ * General format of extra field data. <p>\n+ *\n+ * Extra fields usually appear twice per file, once in the local file data and\n+ * once in the central directory. Usually they are the same, but they don't have\n+ * to be. {@link java.util.zip.ZipOutputStream java.util.zip.ZipOutputStream}\n+ * will only use the local file data in both places.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public interface ZipExtraField\n+{\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return The HeaderId value\n+     * @since 1.1\n+     */\n+    ZipShort getHeaderID();\n+\n+    /**\n+     * Length of the extra field in the local file data - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The LocalFileDataLength value\n+     * @since 1.1\n+     */\n+    ZipShort getLocalFileDataLength();\n+\n+    /**\n+     * Length of the extra field in the central directory - without Header-ID or\n+     * length specifier.\n+     *\n+     * @return The CentralDirectoryLength value\n+     * @since 1.1\n+     */\n+    ZipShort getCentralDirectoryLength();\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The LocalFileDataData value\n+     * @since 1.1\n+     */\n+    byte[] getLocalFileDataData();\n+\n+    /**\n+     * The actual data to put central directory - without Header-ID or length\n+     * specifier.\n+     *\n+     * @return The CentralDirectoryData value\n+     * @since 1.1\n+     */\n+    byte[] getCentralDirectoryData();\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n+     * @exception ZipException on error\n+     * @since 1.1\n+     */\n+    void parseFromLocalFileData( byte[] buffer, int offset, int length )\n+        throws ZipException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Utility class that represents a four byte integer with conversion rules for\n+ * the big endian byte order of ZIP files.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public final class ZipLong implements Cloneable\n+{\n+    private long m_value;\n+\n+    /**\n+     * Create instance from a number.\n+     *\n+     * @param value the value\n+     * @since 1.1\n+     */\n+    public ZipLong( final long value )\n+    {\n+        m_value = value;\n+    }\n+\n+    /**\n+     * Create instance from bytes.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @since 1.1\n+     */\n+    public ZipLong( final byte[] buffer )\n+    {\n+        this( buffer, 0 );\n+    }\n+\n+    /**\n+     * Create instance from the four bytes starting at offset.\n+     *\n+     * @param buffer buffer to read data from\n+     * @param offset offset into buffer\n+     * @since 1.1\n+     */\n+    public ZipLong( final byte[] buffer, final int offset )\n+    {\n+        m_value = ( buffer[ offset + 3 ] << 24 ) & 0xFF000000l;\n+        m_value += ( buffer[ offset + 2 ] << 16 ) & 0xFF0000;\n+        m_value += ( buffer[ offset + 1 ] << 8 ) & 0xFF00;\n+        m_value += ( buffer[ offset ] & 0xFF );\n+    }\n+\n+    /**\n+     * Get value as two bytes in big endian byte order.\n+     *\n+     * @return The value as bytes\n+     * @since 1.1\n+     */\n+    public byte[] getBytes()\n+    {\n+        byte[] result = new byte[ 4 ];\n+        result[ 0 ] = (byte)( ( m_value & 0xFF ) );\n+        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n+        result[ 2 ] = (byte)( ( m_value & 0xFF0000 ) >> 16 );\n+        result[ 3 ] = (byte)( ( m_value & 0xFF000000l ) >> 24 );\n+        return result;\n+    }\n+\n+    /**\n+     * Get value as Java int.\n+     *\n+     * @return The value\n+     * @since 1.1\n+     */\n+    public long getValue()\n+    {\n+        return m_value;\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @param o the object to compare against\n+     * @return true if equyal, false otherwise\n+     * @since 1.1\n+     */\n+    public boolean equals( final Object o )\n+    {\n+        if( o == null || !( o instanceof ZipLong ) )\n+        {\n+            return false;\n+        }\n+        return m_value == ( (ZipLong)o ).getValue();\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @return the hashcode\n+     * @since 1.1\n+     */\n+    public int hashCode()\n+    {\n+        return (int)m_value;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.Calendar;\n+import java.util.Hashtable;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Reimplementation of {@link java.util.zip.ZipOutputStream\n+ * java.util.zip.ZipOutputStream} that does handle the extended functionality of\n+ * this package, especially internal/external file attributes and extra fields\n+ * with different layouts for local file data and central directory entries. <p>\n+ *\n+ * This implementation will use a Data Descriptor to store size and CRC\n+ * information for DEFLATED entries, this means, you don't need to calculate\n+ * them yourself. Unfortunately this is not possible for the STORED method, here\n+ * setting the CRC and uncompressed size information is required before {@link\n+ * #putNextEntry putNextEntry} will be called.</p>\n+ *\n+ * @author <a href=\"stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+class ZipOutputStream\n+    extends DeflaterOutputStream\n+{\n+    /**\n+     * Helper, a 0 as ZipShort.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] ZERO = {0, 0};\n+\n+    /**\n+     * Helper, a 0 as ZipLong.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] LZERO = {0, 0, 0, 0};\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int DEFLATED = ZipEntry.DEFLATED;\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int STORED = ZipEntry.STORED;\n+\n+    /*\n+     * Various ZIP constants\n+     */\n+    /**\n+     * local file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong LFH_SIG = new ZipLong( 0X04034B50L );\n+    /**\n+     * data descriptor signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong DD_SIG = new ZipLong( 0X08074B50L );\n+    /**\n+     * central file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong CFH_SIG = new ZipLong( 0X02014B50L );\n+    /**\n+     * end of central dir signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final ZipLong EOCD_SIG = new ZipLong( 0X06054B50L );\n+\n+    /**\n+     * Smallest date/time ZIP can handle.\n+     *\n+     * @since 1.1\n+     */\n+    private static final ZipLong DOS_TIME_MIN = new ZipLong( 0x00002100L );\n+\n+    /**\n+     * The file comment.\n+     *\n+     * @since 1.1\n+     */\n+    private String m_comment = \"\";\n+\n+    /**\n+     * Compression level for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_level = Deflater.DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Default compression method for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int m_method = DEFLATED;\n+\n+    /**\n+     * List of ZipEntries written so far.\n+     *\n+     * @since 1.1\n+     */\n+    private final ArrayList m_entries = new ArrayList();\n+\n+    /**\n+     * CRC instance to avoid parsing DEFLATED data twice.\n+     *\n+     * @since 1.1\n+     */\n+    private final CRC32 m_crc = new CRC32();\n+\n+    /**\n+     * Count the bytes written to out.\n+     *\n+     * @since 1.1\n+     */\n+    private long m_written;\n+\n+    /**\n+     * Data for current entry started here.\n+     *\n+     * @since 1.1\n+     */\n+    private long m_dataStart;\n+\n+    /**\n+     * Start of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipLong m_cdOffset = new ZipLong( 0 );\n+\n+    /**\n+     * Length of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipLong m_cdLength = new ZipLong( 0 );\n+\n+    /**\n+     * Holds the offsets of the LFH starts for each entry\n+     *\n+     * @since 1.1\n+     */\n+    private final Hashtable m_offsets = new Hashtable();\n+\n+    /**\n+     * The encoding to use for filenames and the file comment. <p>\n+     *\n+     * For a list of possible values see <a\n+     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n+     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n+     * </a>. Defaults to the platform's default character encoding.</p>\n+     *\n+     * @since 1.3\n+     */\n+    private String m_encoding;\n+\n+    /**\n+     * Current entry.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipEntry m_entry;\n+\n+    /**\n+     * Creates a new ZIP OutputStream filtering the underlying stream.\n+     *\n+     * @param output the output stream to write to\n+     * @since 1.1\n+     */\n+    public ZipOutputStream( final OutputStream output )\n+    {\n+        super( output, new Deflater( Deflater.DEFAULT_COMPRESSION, true ) );\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field. <p>\n+     *\n+     * Stolen from InfoZip's <code>fileio.c</code></p>\n+     *\n+     * @param time Description of Parameter\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    protected static ZipLong toDosTime( Date time )\n+    {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime( time );\n+        int year = cal.get(Calendar.YEAR);\n+        int month = cal.get(Calendar.MONTH) + 1;\n+        if( year < 1980 )\n+        {\n+            return DOS_TIME_MIN;\n+        }\n+        long value = ( ( year - 1980 ) << 25 )\n+            | ( month << 21 )\n+            | ( cal.get(Calendar.DAY_OF_MONTH) << 16 )\n+            | ( cal.get(Calendar.HOUR_OF_DAY) << 11 )\n+            | ( cal.get(Calendar.MINUTE) << 5 )\n+            | ( cal.get(Calendar.SECOND) >> 1 );\n+\n+        byte[] result = new byte[ 4 ];\n+        result[ 0 ] = (byte)( ( value & 0xFF ) );\n+        result[ 1 ] = (byte)( ( value & 0xFF00 ) >> 8 );\n+        result[ 2 ] = (byte)( ( value & 0xFF0000 ) >> 16 );\n+        result[ 3 ] = (byte)( ( value & 0xFF000000l ) >> 24 );\n+        return new ZipLong( result );\n+    }\n+\n+    /**\n+     * Set the file comment.\n+     *\n+     * @param comment The new Comment value\n+     * @since 1.1\n+     */\n+    public void setComment( String comment )\n+    {\n+        m_comment = comment;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment. <p>\n+     *\n+     * For a list of possible values see <a\n+     * href=\"http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\">\n+     * http://java.sun.com/products/jdk/1.2/docs/guide/internat/encoding.doc.html\n+     * </a>. Defaults to the platform's default character encoding.</p>\n+     *\n+     * @param encoding The new Encoding value\n+     * @since 1.3\n+     */\n+    public void setEncoding( String encoding )\n+    {\n+        m_encoding = encoding;\n+    }\n+\n+    /**\n+     * Sets the compression level for subsequent entries. <p>\n+     *\n+     * Default is Deflater.DEFAULT_COMPRESSION.</p>\n+     *\n+     * @param level The new Level value\n+     * @since 1.1\n+     */\n+    public void setLevel( int level )\n+    {\n+        m_level = level;\n+    }\n+\n+    /**\n+     * Sets the default compression method for subsequent entries. <p>\n+     *\n+     * Default is DEFLATED.</p>\n+     *\n+     * @param method The new Method value\n+     * @since 1.1\n+     */\n+    public void setMethod( final int method )\n+    {\n+        m_method = method;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     * @since 1.3\n+     */\n+    public String getEncoding()\n+    {\n+        return m_encoding;\n+    }\n+\n+    /**\n+     * Writes all necessary data for this entry.\n+     *\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void closeEntry()\n+        throws IOException\n+    {\n+        if( m_entry == null )\n+        {\n+            return;\n+        }\n+\n+        long realCrc = m_crc.getValue();\n+        m_crc.reset();\n+\n+        if( m_entry.getMethod() == DEFLATED )\n+        {\n+            def.finish();\n+            while( !def.finished() )\n+            {\n+                deflate();\n+            }\n+\n+            m_entry.setSize( def.getTotalIn() );\n+            m_entry.setComprSize( def.getTotalOut() );\n+            m_entry.setCrc( realCrc );\n+\n+            def.reset();\n+\n+            m_written += m_entry.getCompressedSize();\n+        }\n+        else\n+        {\n+            if( m_entry.getCrc() != realCrc )\n+            {\n+                throw new ZipException( \"bad CRC checksum for entry \"\n+                                        + m_entry.getName() + \": \"\n+                                        + Long.toHexString( m_entry.getCrc() )\n+                                        + \" instead of \"\n+                                        + Long.toHexString( realCrc ) );\n+            }\n+\n+            if( m_entry.getSize() != m_written - m_dataStart )\n+            {\n+                throw new ZipException( \"bad size for entry \"\n+                                        + m_entry.getName() + \": \"\n+                                        + m_entry.getSize()\n+                                        + \" instead of \"\n+                                        + ( m_written - m_dataStart ) );\n+            }\n+\n+        }\n+\n+        writeDataDescriptor( m_entry );\n+        m_entry = null;\n+    }\n+\n+    /*\n+     * Found out by experiment, that DeflaterOutputStream.close()\n+     * will call finish() - so we don't need to override close\n+     * ourselves.\n+     */\n+    /**\n+     * Finishs writing the contents and closes this as well as the underlying\n+     * stream.\n+     *\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void finish()\n+        throws IOException\n+    {\n+        closeEntry();\n+        m_cdOffset = new ZipLong( m_written );\n+        final int size = m_entries.size();\n+        for( int i = 0; i < size; i++ )\n+        {\n+            final ZipEntry entry = (ZipEntry)m_entries.get( i );\n+            writeCentralFileHeader( entry );\n+        }\n+        m_cdLength = new ZipLong( m_written - m_cdOffset.getValue() );\n+        writeCentralDirectoryEnd();\n+        m_offsets.clear();\n+        m_entries.clear();\n+    }\n+\n+    /**\n+     * Begin writing next entry.\n+     *\n+     * @param entry the entry\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    public void putNextEntry( final ZipEntry entry )\n+        throws IOException\n+    {\n+        closeEntry();\n+\n+        m_entry = entry;\n+        m_entries.add( m_entry );\n+\n+        if( m_entry.getMethod() == -1 )\n+        {// not specified\n+            m_entry.setMethod( m_method );\n+        }\n+\n+        if( m_entry.getTime() == -1 )\n+        {// not specified\n+            m_entry.setTime( System.currentTimeMillis() );\n+        }\n+\n+        if( m_entry.getMethod() == STORED )\n+        {\n+            if( m_entry.getSize() == -1 )\n+            {\n+                throw new ZipException( \"uncompressed size is required for STORED method\" );\n+            }\n+            if( m_entry.getCrc() == -1 )\n+            {\n+                throw new ZipException( \"crc checksum is required for STORED method\" );\n+            }\n+            m_entry.setComprSize( m_entry.getSize() );\n+        }\n+        else\n+        {\n+            def.setLevel( m_level );\n+        }\n+        writeLocalFileHeader( m_entry );\n+    }\n+\n+    /**\n+     * Writes bytes to ZIP entry. <p>\n+     *\n+     * Override is necessary to support STORED entries, as well as calculationg\n+     * CRC automatically for DEFLATED entries.</p>\n+     *\n+     * @param buffer the buffer to write to\n+     * @param offset the offset to write to\n+     * @param length the length of data to write\n+     * @exception IOException if an IO error causes operation to fail\n+     */\n+    public void write( final byte[] buffer,\n+                       final int offset,\n+                       final int length )\n+        throws IOException\n+    {\n+        if( m_entry.getMethod() == DEFLATED )\n+        {\n+            super.write( buffer, offset, length );\n+        }\n+        else\n+        {\n+            out.write( buffer, offset, length );\n+            m_written += length;\n+        }\n+        m_crc.update( buffer, offset, length );\n+    }\n+\n+    /**\n+     * Retrieve the bytes for the given String in the encoding set for this\n+     * Stream.\n+     *\n+     * @param name the name to decode\n+     * @return the bytes for string\n+     * @exception ZipException if fail to retrieve bytes for specified string\n+     * @since 1.3\n+     */\n+    protected byte[] getBytes( String name )\n+        throws ZipException\n+    {\n+        if( m_encoding == null )\n+        {\n+            return name.getBytes();\n+        }\n+        else\n+        {\n+            try\n+            {\n+                return name.getBytes( m_encoding );\n+            }\n+            catch( UnsupportedEncodingException uee )\n+            {\n+                throw new ZipException( uee.getMessage() );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Writes the &quot;End of central dir record&quot;\n+     *\n+     * @exception IOException when an IO erro causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeCentralDirectoryEnd()\n+        throws IOException\n+    {\n+        out.write( EOCD_SIG.getBytes() );\n+\n+        // disk numbers\n+        out.write( ZERO );\n+        out.write( ZERO );\n+\n+        // number of entries\n+        byte[] num = ( new ZipShort( m_entries.size() ) ).getBytes();\n+        out.write( num );\n+        out.write( num );\n+\n+        // length and location of CD\n+        out.write( m_cdLength.getBytes() );\n+        out.write( m_cdOffset.getBytes() );\n+\n+        // ZIP file comment\n+        byte[] data = getBytes( m_comment );\n+        out.write( ( new ZipShort( data.length ) ).getBytes() );\n+        out.write( data );\n+    }\n+\n+    /**\n+     * Writes the central file header entry\n+     *\n+     * @param entry the zip entry\n+     * @throws IOException when an IO error causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeCentralFileHeader( final ZipEntry entry )\n+        throws IOException\n+    {\n+        out.write( CFH_SIG.getBytes() );\n+        m_written += 4;\n+\n+        // version made by\n+        out.write( ( new ZipShort( 20 ) ).getBytes() );\n+        m_written += 2;\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+\n+            // bit3 set to signal, we use a data descriptor\n+            out.write( ( new ZipShort( 8 ) ).getBytes() );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipShort( 10 ) ).getBytes() );\n+            out.write( ZERO );\n+        }\n+        m_written += 4;\n+\n+        // compression method\n+        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // last mod. time and date\n+        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n+        out.write( ( new ZipLong( entry.getCompressedSize() ) ).getBytes() );\n+        out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+        m_written += 12;\n+\n+        // file name length\n+        byte[] name = getBytes( entry.getName() );\n+        out.write( ( new ZipShort( name.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // extra field length\n+        byte[] extra = entry.getCentralDirectoryExtra();\n+        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // file comment length\n+        String comm = entry.getComment();\n+        if( comm == null )\n+        {\n+            comm = \"\";\n+        }\n+        byte[] comment = getBytes( comm );\n+        out.write( ( new ZipShort( comment.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // disk number start\n+        out.write( ZERO );\n+        m_written += 2;\n+\n+        // internal file attributes\n+        out.write( ( new ZipShort( entry.getInternalAttributes() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // external file attributes\n+        out.write( ( new ZipLong( entry.getExternalAttributes() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // relative offset of LFH\n+        out.write( ( (ZipLong)m_offsets.get( entry ) ).getBytes() );\n+        m_written += 4;\n+\n+        // file name\n+        out.write( name );\n+        m_written += name.length;\n+\n+        // extra field\n+        out.write( extra );\n+        m_written += extra.length;\n+\n+        // file comment\n+        out.write( comment );\n+        m_written += comment.length;\n+    }\n+\n+    /**\n+     * Writes the data descriptor entry\n+     *\n+     * @param ze Description of Parameter\n+     * @throws IOException if an IO failure causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeDataDescriptor( ZipEntry ze )\n+        throws IOException\n+    {\n+        if( ze.getMethod() != DEFLATED )\n+        {\n+            return;\n+        }\n+        out.write( DD_SIG.getBytes() );\n+        out.write( ( new ZipLong( m_entry.getCrc() ) ).getBytes() );\n+        out.write( ( new ZipLong( m_entry.getCompressedSize() ) ).getBytes() );\n+        out.write( ( new ZipLong( m_entry.getSize() ) ).getBytes() );\n+        m_written += 16;\n+    }\n+\n+    /**\n+     * Writes the local file header entry\n+     *\n+     * @param entry the zip entry\n+     * @exception IOException when an IO error causes operation to fail\n+     * @since 1.1\n+     */\n+    protected void writeLocalFileHeader( final ZipEntry entry )\n+        throws IOException\n+    {\n+        m_offsets.put( entry, new ZipLong( m_written ) );\n+\n+        out.write( LFH_SIG.getBytes() );\n+        m_written += 4;\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            out.write( ( new ZipShort( 20 ) ).getBytes() );\n+\n+            // bit3 set to signal, we use a data descriptor\n+            out.write( ( new ZipShort( 8 ) ).getBytes() );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipShort( 10 ) ).getBytes() );\n+            out.write( ZERO );\n+        }\n+        m_written += 4;\n+\n+        // compression method\n+        out.write( ( new ZipShort( entry.getMethod() ) ).getBytes() );\n+        m_written += 2;\n+\n+        // last mod. time and date\n+        out.write( toDosTime( new Date( entry.getTime() ) ).getBytes() );\n+        m_written += 4;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        if( entry.getMethod() == DEFLATED )\n+        {\n+            out.write( LZERO );\n+            out.write( LZERO );\n+            out.write( LZERO );\n+        }\n+        else\n+        {\n+            out.write( ( new ZipLong( entry.getCrc() ) ).getBytes() );\n+            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+            out.write( ( new ZipLong( entry.getSize() ) ).getBytes() );\n+        }\n+        m_written += 12;\n+\n+        // file name length\n+        byte[] name = getBytes( entry.getName() );\n+        out.write( ( new ZipShort( name.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // extra field length\n+        byte[] extra = entry.getLocalFileDataExtra();\n+        out.write( ( new ZipShort( extra.length ) ).getBytes() );\n+        m_written += 2;\n+\n+        // file name\n+        out.write( name );\n+        m_written += name.length;\n+\n+        // extra field\n+        out.write( extra );\n+        m_written += extra.length;\n+\n+        m_dataStart = m_written;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Utility class that represents a two byte integer with conversion rules for\n+ * the big endian byte order of ZIP files.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @version $Revision: 155439 $\n+ */\n+public final class ZipShort implements Cloneable\n+{\n+    private int m_value;\n+\n+    /**\n+     * Create instance from a number.\n+     *\n+     * @param value Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( int value )\n+    {\n+        this.m_value = value;\n+    }\n+\n+    /**\n+     * Create instance from bytes.\n+     *\n+     * @param bytes Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( byte[] bytes )\n+    {\n+        this( bytes, 0 );\n+    }\n+\n+    /**\n+     * Create instance from the two bytes starting at offset.\n+     *\n+     * @param bytes Description of Parameter\n+     * @param offset Description of Parameter\n+     * @since 1.1\n+     */\n+    public ZipShort( byte[] bytes, int offset )\n+    {\n+        m_value = ( bytes[ offset + 1 ] << 8 ) & 0xFF00;\n+        m_value += ( bytes[ offset ] & 0xFF );\n+    }\n+\n+    /**\n+     * Get value as two bytes in big endian byte order.\n+     *\n+     * @return The Bytes value\n+     * @since 1.1\n+     */\n+    public byte[] getBytes()\n+    {\n+        byte[] result = new byte[ 2 ];\n+        result[ 0 ] = (byte)( m_value & 0xFF );\n+        result[ 1 ] = (byte)( ( m_value & 0xFF00 ) >> 8 );\n+        return result;\n+    }\n+\n+    /**\n+     * Get value as Java int.\n+     *\n+     * @return The Value value\n+     * @since 1.1\n+     */\n+    public int getValue()\n+    {\n+        return m_value;\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @param o Description of Parameter\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public boolean equals( Object o )\n+    {\n+        if( o == null || !( o instanceof ZipShort ) )\n+        {\n+            return false;\n+        }\n+        return m_value == ( (ZipShort)o ).getValue();\n+    }\n+\n+    /**\n+     * Override to make two instances with same value equal.\n+     *\n+     * @return Description of the Returned Value\n+     * @since 1.1\n+     */\n+    public int hashCode()\n+    {\n+        return m_value;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/compressors/bzip2/BZip2Compressor.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.AbstractCompressor;\n+import org.apache.commons.compress.CompressException;\n+import org.apache.commons.compress.CompressUtils;\n+/**\n+ * Implementation of the Compressor Interface for BZip2. \n+ * \n+ * @author christian.grobmeier\n+ */\n+public class BZip2Compressor extends AbstractCompressor {\n+\t/* Header BZ as byte-Array */\n+\tprivate static final byte[] HEADER = new byte[]{(byte)'B', (byte)'Z'};\n+\t/* Name of this implementation */\n+\tprivate static final String NAME = \"bz2\";\n+\t/* Default file extension*/\n+\tprivate static String DEFAULT_FILE_EXTENSION = \"bz2\";\n+\t\n+\t/**\n+\t * Constructor. \n+\t */\n+\tpublic BZip2Compressor() {\n+\t\tsuper();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#compress(java.io.FileInputStream, java.io.FileOutputStream)\n+\t */\n+\tpublic void compressTo(FileInputStream inputStream, FileOutputStream outputStream) throws CompressException {\n+\t\tBZip2OutputStream outputBZStream = null;\n+\t\ttry {\n+\t\t\toutputBZStream = getPackedOutput( outputStream );\n+\t\t\tCompressUtils.copy( inputStream, outputBZStream );\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tthrow new CompressException(\"File could not be found\", e);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new CompressException(\"An IO Exception occured\", e);\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\toutputBZStream.close();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new CompressException(\"An IO Exception occured while closing the streams\", e1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/* \n+\t * This decompress method uses a special InputStream Class for BZ2\n+\t * @see org.apache.commons.compress.Compressor#decompress(java.io.FileInputStream, java.io.FileOutputStream)\n+\t */\n+\tpublic void decompressTo(FileInputStream input, FileOutputStream outputStream) \n+\t\tthrows CompressException {\n+\t\tBZip2InputStream inputStream = null;\n+\t\ttry {\n+\t\t\tinputStream = getPackedInput( input );\n+\t\t\tCompressUtils.copy( inputStream, outputStream );\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new CompressException(\"An I/O Exception has occured\", e);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Skips the 'BZ' header bytes. required by the BZip2InputStream class.\n+\t * @param input input stream\n+\t * @return {@link BZip2InputStream} instance\n+\t * @throws IOException if an IO error occurs\n+\t */\n+\tprivate BZip2InputStream getPackedInput( final InputStream input )\n+\t\tthrows IOException {\n+\t\t// skips the 'BZ' header bytes required by the BZip2InputStream class\n+\t\tfinal int b1 = input.read();\n+\t\tfinal int b2 = input.read();\n+\t\treturn new BZip2InputStream( input );\n+\t}\n+\t\n+\t/**\n+\t * Writes a 'BZ' header to the output stream, and creates a\n+\t * BZip2OutputStream object ready for use, as required by the\n+\t * BZip2OutputStream class.\n+\t * \n+\t * @param output {@link Output} stream to add a header to\n+\t * @return {@link BZip2OutputStream} ready to write to\n+\t * @throws IOException if an IO error occurs\n+\t */\n+\tprivate BZip2OutputStream getPackedOutput( final OutputStream output )\n+\t\tthrows IOException {\n+\t\toutput.write( HEADER );\n+\t\treturn new BZip2OutputStream( output );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#getHeader()\n+\t */\n+\tpublic byte[] getHeader() {\n+\t\treturn HEADER;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.Compressor#getName()\n+\t */\n+\tpublic String getName() {\n+\t\treturn NAME;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.AbstractCompressor#getDefaultFileExtension()\n+\t */\n+\tpublic String getDefaultFileExtension() {\n+\t\treturn DEFAULT_FILE_EXTENSION;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/compressors/bzip2/BZip2Constants.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * Base class for both the compress and decompress classes. Holds common arrays,\n+ * and static data.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+interface BZip2Constants\n+{\n+    int BASE_BLOCK_SIZE = 100000;\n+    int MAX_ALPHA_SIZE = 258;\n+    int MAX_CODE_LEN = 23;\n+    int RUNA = 0;\n+    int RUNB = 1;\n+    int N_GROUPS = 6;\n+    int G_SIZE = 50;\n+    int N_ITERS = 4;\n+    int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) );\n+    int NUM_OVERSHOOT_BYTES = 20;\n+\n+    int[] RAND_NUMS = new int[]\n+    {\n+        619, 720, 127, 481, 931, 816, 813, 233, 566, 247,\n+        985, 724, 205, 454, 863, 491, 741, 242, 949, 214,\n+        733, 859, 335, 708, 621, 574, 73, 654, 730, 472,\n+        419, 436, 278, 496, 867, 210, 399, 680, 480, 51,\n+        878, 465, 811, 169, 869, 675, 611, 697, 867, 561,\n+        862, 687, 507, 283, 482, 129, 807, 591, 733, 623,\n+        150, 238, 59, 379, 684, 877, 625, 169, 643, 105,\n+        170, 607, 520, 932, 727, 476, 693, 425, 174, 647,\n+        73, 122, 335, 530, 442, 853, 695, 249, 445, 515,\n+        909, 545, 703, 919, 874, 474, 882, 500, 594, 612,\n+        641, 801, 220, 162, 819, 984, 589, 513, 495, 799,\n+        161, 604, 958, 533, 221, 400, 386, 867, 600, 782,\n+        382, 596, 414, 171, 516, 375, 682, 485, 911, 276,\n+        98, 553, 163, 354, 666, 933, 424, 341, 533, 870,\n+        227, 730, 475, 186, 263, 647, 537, 686, 600, 224,\n+        469, 68, 770, 919, 190, 373, 294, 822, 808, 206,\n+        184, 943, 795, 384, 383, 461, 404, 758, 839, 887,\n+        715, 67, 618, 276, 204, 918, 873, 777, 604, 560,\n+        951, 160, 578, 722, 79, 804, 96, 409, 713, 940,\n+        652, 934, 970, 447, 318, 353, 859, 672, 112, 785,\n+        645, 863, 803, 350, 139, 93, 354, 99, 820, 908,\n+        609, 772, 154, 274, 580, 184, 79, 626, 630, 742,\n+        653, 282, 762, 623, 680, 81, 927, 626, 789, 125,\n+        411, 521, 938, 300, 821, 78, 343, 175, 128, 250,\n+        170, 774, 972, 275, 999, 639, 495, 78, 352, 126,\n+        857, 956, 358, 619, 580, 124, 737, 594, 701, 612,\n+        669, 112, 134, 694, 363, 992, 809, 743, 168, 974,\n+        944, 375, 748, 52, 600, 747, 642, 182, 862, 81,\n+        344, 805, 988, 739, 511, 655, 814, 334, 249, 515,\n+        897, 955, 664, 981, 649, 113, 974, 459, 893, 228,\n+        433, 837, 553, 268, 926, 240, 102, 654, 459, 51,\n+        686, 754, 806, 760, 493, 403, 415, 394, 687, 700,\n+        946, 670, 656, 610, 738, 392, 760, 799, 887, 653,\n+        978, 321, 576, 617, 626, 502, 894, 679, 243, 440,\n+        680, 879, 194, 572, 640, 724, 926, 56, 204, 700,\n+        707, 151, 457, 449, 797, 195, 791, 558, 945, 679,\n+        297, 59, 87, 824, 713, 663, 412, 693, 342, 606,\n+        134, 108, 571, 364, 631, 212, 174, 643, 304, 329,\n+        343, 97, 430, 751, 497, 314, 983, 374, 822, 928,\n+        140, 206, 73, 263, 980, 736, 876, 478, 430, 305,\n+        170, 514, 364, 692, 829, 82, 855, 953, 676, 246,\n+        369, 970, 294, 750, 807, 827, 150, 790, 288, 923,\n+        804, 378, 215, 828, 592, 281, 565, 555, 710, 82,\n+        896, 831, 547, 261, 524, 462, 293, 465, 502, 56,\n+        661, 821, 976, 991, 658, 869, 905, 758, 745, 193,\n+        768, 550, 608, 933, 378, 286, 215, 979, 792, 961,\n+        61, 688, 793, 644, 986, 403, 106, 366, 905, 644,\n+        372, 567, 466, 434, 645, 210, 389, 550, 919, 135,\n+        780, 773, 635, 389, 707, 100, 626, 958, 165, 504,\n+        920, 176, 193, 713, 857, 265, 203, 50, 668, 108,\n+        645, 990, 626, 197, 510, 357, 358, 850, 858, 364,\n+        936, 638\n+    };\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/compressors/bzip2/BZip2InputStream.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * An input stream that decompresses from the BZip2 format (without the file\n+ * header chars) to be read as any other stream.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+public class BZip2InputStream\n+    extends InputStream\n+    implements BZip2Constants\n+{\n+    private static final int START_BLOCK_STATE = 1;\n+    private static final int RAND_PART_A_STATE = 2;\n+    private static final int RAND_PART_B_STATE = 3;\n+    private static final int RAND_PART_C_STATE = 4;\n+    private static final int NO_RAND_PART_A_STATE = 5;\n+    private static final int NO_RAND_PART_B_STATE = 6;\n+    private static final int NO_RAND_PART_C_STATE = 7;\n+\n+    private CRC m_crc = new CRC();\n+    private boolean[] m_inUse = new boolean[ 256 ];\n+    private char[] m_seqToUnseq = new char[ 256 ];\n+    private char[] m_unseqToSeq = new char[ 256 ];\n+    private char[] m_selector = new char[ MAX_SELECTORS ];\n+    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];\n+\n+    /*\n+     * freq table collected to save a pass over the data\n+     * during decompression.\n+     */\n+    private int[] m_unzftab = new int[ 256 ];\n+\n+    private int[][] m_limit = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[][] m_base = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[][] m_perm = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+    private int[] m_minLens = new int[ N_GROUPS ];\n+\n+    private boolean m_streamEnd;\n+    private int m_currentChar = -1;\n+\n+    private int m_currentState = START_BLOCK_STATE;\n+    private int m_rNToGo;\n+    private int m_rTPos;\n+    private int m_tPos;\n+\n+    private int i2;\n+    private int count;\n+    private int chPrev;\n+    private int ch2;\n+    private int j2;\n+    private char z;\n+\n+    private boolean m_blockRandomised;\n+\n+    /*\n+     * always: in the range 0 .. 9.\n+     * The current block size is 100000 * this number.\n+     */\n+    private int m_blockSize100k;\n+    private int m_bsBuff;\n+    private int m_bsLive;\n+\n+    private InputStream m_input;\n+\n+    private int m_computedBlockCRC;\n+    private int m_computedCombinedCRC;\n+\n+    /*\n+     * index of the last char in the block, so\n+     * the block size == last + 1.\n+     */\n+    private int m_last;\n+    private char[] m_ll8;\n+    private int m_nInUse;\n+\n+    /*\n+     * index in zptr[] of original string after sorting.\n+     */\n+    private int m_origPtr;\n+\n+    private int m_storedBlockCRC;\n+    private int m_storedCombinedCRC;\n+    private int[] m_tt;\n+\n+    /**\n+     * Initializes ein CBZip2 InputStream with the give\n+     * InputStream\n+     * @param input the InputStream to initialize with\n+     */\n+    public BZip2InputStream( final InputStream input )\n+    {\n+        bsSetStream( input );\n+        initialize();\n+        initBlock();\n+        setupBlock();\n+    }\n+\n+    private static void badBlockHeader()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void blockOverrun()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void cadvise()\n+    {\n+        System.out.println( \"CRC Error\" );\n+        //throw new CCoruptionError();\n+    }\n+\n+    private static void compressedStreamEOF()\n+    {\n+        cadvise();\n+    }\n+\n+    private static void crcError()\n+    {\n+        cadvise();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.io.InputStream#read()\n+     */\n+    public int read()\n+    {\n+        if( m_streamEnd )\n+        {\n+            return -1;\n+        }\n+        else\n+        {\n+            int retChar = m_currentChar;\n+            switch( m_currentState )\n+            {\n+                case START_BLOCK_STATE:\n+                    break;\n+                case RAND_PART_A_STATE:\n+                    break;\n+                case RAND_PART_B_STATE:\n+                    setupRandPartB();\n+                    break;\n+                case RAND_PART_C_STATE:\n+                    setupRandPartC();\n+                    break;\n+                case NO_RAND_PART_A_STATE:\n+                    break;\n+                case NO_RAND_PART_B_STATE:\n+                    setupNoRandPartB();\n+                    break;\n+                case NO_RAND_PART_C_STATE:\n+                    setupNoRandPartC();\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return retChar;\n+        }\n+    }\n+\n+    private void setDecompressStructureSizes( int newSize100k )\n+    {\n+        if( !( 0 <= newSize100k && newSize100k <= 9 && 0 <= m_blockSize100k\n+            && m_blockSize100k <= 9 ) )\n+        {\n+            // throw new IOException(\"Invalid block size\");\n+        }\n+\n+        m_blockSize100k = newSize100k;\n+\n+        if( newSize100k == 0 )\n+        {\n+            return;\n+        }\n+\n+        int n = BASE_BLOCK_SIZE * newSize100k;\n+        m_ll8 = new char[ n ];\n+        m_tt = new int[ n ];\n+    }\n+\n+    private void setupBlock()\n+    {\n+        int[] cftab = new int[ 257 ];\n+        char ch;\n+\n+        cftab[ 0 ] = 0;\n+        for( int i = 1; i <= 256; i++ )\n+        {\n+            cftab[ i ] = m_unzftab[ i - 1 ];\n+        }\n+        for( int i = 1; i <= 256; i++ )\n+        {\n+            cftab[ i ] += cftab[ i - 1 ];\n+        }\n+\n+        for( int i = 0; i <= m_last; i++ )\n+        {\n+            ch = m_ll8[ i ];\n+            m_tt[ cftab[ ch ] ] = i;\n+            cftab[ ch ]++;\n+        }\n+        cftab = null;\n+\n+        m_tPos = m_tt[ m_origPtr ];\n+\n+        count = 0;\n+        i2 = 0;\n+        ch2 = 256;\n+        /*\n+         * not a char and not EOF\n+         */\n+        if( m_blockRandomised )\n+        {\n+            m_rNToGo = 0;\n+            m_rTPos = 0;\n+            setupRandPartA();\n+        }\n+        else\n+        {\n+            setupNoRandPartA();\n+        }\n+    }\n+\n+    private void setupNoRandPartA()\n+    {\n+        if( i2 <= m_last )\n+        {\n+            chPrev = ch2;\n+            ch2 = m_ll8[ m_tPos ];\n+            m_tPos = m_tt[ m_tPos ];\n+            i2++;\n+\n+            m_currentChar = ch2;\n+            m_currentState = NO_RAND_PART_B_STATE;\n+            m_crc.updateCRC( ch2 );\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            setupBlock();\n+        }\n+    }\n+\n+    private void setupNoRandPartB()\n+    {\n+        if( ch2 != chPrev )\n+        {\n+            m_currentState = NO_RAND_PART_A_STATE;\n+            count = 1;\n+            setupNoRandPartA();\n+        }\n+        else\n+        {\n+            count++;\n+            if( count >= 4 )\n+            {\n+                z = m_ll8[ m_tPos ];\n+                m_tPos = m_tt[ m_tPos ];\n+                m_currentState = NO_RAND_PART_C_STATE;\n+                j2 = 0;\n+                setupNoRandPartC();\n+            }\n+            else\n+            {\n+                m_currentState = NO_RAND_PART_A_STATE;\n+                setupNoRandPartA();\n+            }\n+        }\n+    }\n+\n+    private void setupNoRandPartC()\n+    {\n+        if( j2 < z )\n+        {\n+            m_currentChar = ch2;\n+            m_crc.updateCRC( ch2 );\n+            j2++;\n+        }\n+        else\n+        {\n+            m_currentState = NO_RAND_PART_A_STATE;\n+            i2++;\n+            count = 0;\n+            setupNoRandPartA();\n+        }\n+    }\n+\n+    private void setupRandPartA()\n+    {\n+        if( i2 <= m_last )\n+        {\n+            chPrev = ch2;\n+            ch2 = m_ll8[ m_tPos ];\n+            m_tPos = m_tt[ m_tPos ];\n+            if( m_rNToGo == 0 )\n+            {\n+                m_rNToGo = RAND_NUMS[ m_rTPos ];\n+                m_rTPos++;\n+                if( m_rTPos == 512 )\n+                {\n+                    m_rTPos = 0;\n+                }\n+            }\n+            m_rNToGo--;\n+            ch2 ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );\n+            i2++;\n+\n+            m_currentChar = ch2;\n+            m_currentState = RAND_PART_B_STATE;\n+            m_crc.updateCRC( ch2 );\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            setupBlock();\n+        }\n+    }\n+\n+    private void setupRandPartB()\n+    {\n+        if( ch2 != chPrev )\n+        {\n+            m_currentState = RAND_PART_A_STATE;\n+            count = 1;\n+            setupRandPartA();\n+        }\n+        else\n+        {\n+            count++;\n+            if( count >= 4 )\n+            {\n+                z = m_ll8[ m_tPos ];\n+                m_tPos = m_tt[ m_tPos ];\n+                if( m_rNToGo == 0 )\n+                {\n+                    m_rNToGo = RAND_NUMS[ m_rTPos ];\n+                    m_rTPos++;\n+                    if( m_rTPos == 512 )\n+                    {\n+                        m_rTPos = 0;\n+                    }\n+                }\n+                m_rNToGo--;\n+                z ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );\n+                j2 = 0;\n+                m_currentState = RAND_PART_C_STATE;\n+                setupRandPartC();\n+            }\n+            else\n+            {\n+                m_currentState = RAND_PART_A_STATE;\n+                setupRandPartA();\n+            }\n+        }\n+    }\n+\n+    private void setupRandPartC()\n+    {\n+        if( j2 < z )\n+        {\n+            m_currentChar = ch2;\n+            m_crc.updateCRC( ch2 );\n+            j2++;\n+        }\n+        else\n+        {\n+            m_currentState = RAND_PART_A_STATE;\n+            i2++;\n+            count = 0;\n+            setupRandPartA();\n+        }\n+    }\n+\n+    private void getAndMoveToFrontDecode()\n+    {\n+        int nextSym;\n+\n+        int limitLast = BASE_BLOCK_SIZE * m_blockSize100k;\n+        m_origPtr = readVariableSizedInt( 24 );\n+\n+        recvDecodingTables();\n+        int EOB = m_nInUse + 1;\n+        int groupNo = -1;\n+        int groupPos = 0;\n+\n+        /*\n+         * Setting up the unzftab entries here is not strictly\n+         * necessary, but it does save having to do it later\n+         * in a separate pass, and so saves a block's worth of\n+         * cache misses.\n+         */\n+        for( int i = 0; i <= 255; i++ )\n+        {\n+            m_unzftab[ i ] = 0;\n+        }\n+\n+        final char[] yy = new char[ 256 ];\n+        for( int i = 0; i <= 255; i++ )\n+        {\n+            yy[ i ] = (char)i;\n+        }\n+\n+        m_last = -1;\n+        int zt;\n+        int zn;\n+        int zvec;\n+        int zj;\n+        groupNo++;\n+        groupPos = G_SIZE - 1;\n+\n+        zt = m_selector[ groupNo ];\n+        zn = m_minLens[ zt ];\n+        zvec = bsR( zn );\n+        while( zvec > m_limit[ zt ][ zn ] )\n+        {\n+            zn++;\n+\n+            while( m_bsLive < 1 )\n+            {\n+                int zzi;\n+                char thech = 0;\n+                try\n+                {\n+                    thech = (char)m_input.read();\n+                }\n+                catch( IOException e )\n+                {\n+                    compressedStreamEOF();\n+                }\n+                if( thech == -1 )\n+                {\n+                    compressedStreamEOF();\n+                }\n+                zzi = thech;\n+                m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );\n+                m_bsLive += 8;\n+            }\n+\n+            zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+            m_bsLive--;\n+\n+            zvec = ( zvec << 1 ) | zj;\n+        }\n+        nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+        while( true )\n+        {\n+            if( nextSym == EOB )\n+            {\n+                break;\n+            }\n+\n+            if( nextSym == RUNA || nextSym == RUNB )\n+            {\n+                char ch;\n+                int s = -1;\n+                int N = 1;\n+                do\n+                {\n+                    if( nextSym == RUNA )\n+                    {\n+                        s = s + ( 0 + 1 ) * N;\n+                    }\n+                    else// if( nextSym == RUNB )\n+                    {\n+                        s = s + ( 1 + 1 ) * N;\n+                    }\n+                    N = N * 2;\n+\n+                    if( groupPos == 0 )\n+                    {\n+                        groupNo++;\n+                        groupPos = G_SIZE;\n+                    }\n+                    groupPos--;\n+                    zt = m_selector[ groupNo ];\n+                    zn = m_minLens[ zt ];\n+                    zvec = bsR( zn );\n+                    while( zvec > m_limit[ zt ][ zn ] )\n+                    {\n+                        zn++;\n+\n+                        while( m_bsLive < 1 )\n+                        {\n+                            int zzi;\n+                            char thech = 0;\n+                            try\n+                            {\n+                                thech = (char)m_input.read();\n+                            }\n+                            catch( IOException e )\n+                            {\n+                                compressedStreamEOF();\n+                            }\n+                            if( thech == -1 )\n+                            {\n+                                compressedStreamEOF();\n+                            }\n+                            zzi = thech;\n+                            m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );\n+                            m_bsLive += 8;\n+                        }\n+\n+                        zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+                        m_bsLive--;\n+                        zvec = ( zvec << 1 ) | zj;\n+                    }\n+\n+                    nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+                } while( nextSym == RUNA || nextSym == RUNB );\n+\n+                s++;\n+                ch = m_seqToUnseq[ yy[ 0 ] ];\n+                m_unzftab[ ch ] += s;\n+\n+                while( s > 0 )\n+                {\n+                    m_last++;\n+                    m_ll8[ m_last ] = ch;\n+                    s--;\n+                }\n+\n+                if( m_last >= limitLast )\n+                {\n+                    blockOverrun();\n+                }\n+                continue;\n+            }\n+            else\n+            {\n+                char tmp;\n+                m_last++;\n+                if( m_last >= limitLast )\n+                {\n+                    blockOverrun();\n+                }\n+\n+                tmp = yy[ nextSym - 1 ];\n+                m_unzftab[ m_seqToUnseq[ tmp ] ]++;\n+                m_ll8[ m_last ] = m_seqToUnseq[ tmp ];\n+\n+                /*\n+                 * This loop is hammered during decompression,\n+                 * hence the unrolling.\n+                 * for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];\n+                 */\n+                int j = nextSym - 1;\n+                for( ; j > 3; j -= 4 )\n+                {\n+                    yy[ j ] = yy[ j - 1 ];\n+                    yy[ j - 1 ] = yy[ j - 2 ];\n+                    yy[ j - 2 ] = yy[ j - 3 ];\n+                    yy[ j - 3 ] = yy[ j - 4 ];\n+                }\n+                for( ; j > 0; j-- )\n+                {\n+                    yy[ j ] = yy[ j - 1 ];\n+                }\n+\n+                yy[ 0 ] = tmp;\n+\n+                if( groupPos == 0 )\n+                {\n+                    groupNo++;\n+                    groupPos = G_SIZE;\n+                }\n+                groupPos--;\n+                zt = m_selector[ groupNo ];\n+                zn = m_minLens[ zt ];\n+                zvec = bsR( zn );\n+                while( zvec > m_limit[ zt ][ zn ] )\n+                {\n+                    zn++;\n+\n+                    while( m_bsLive < 1 )\n+                    {\n+                        char ch = 0;\n+                        try\n+                        {\n+                            ch = (char)m_input.read();\n+                        }\n+                        catch( IOException e )\n+                        {\n+                            compressedStreamEOF();\n+                        }\n+\n+                        m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );\n+                        m_bsLive += 8;\n+                    }\n+\n+                    zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;\n+                    m_bsLive--;\n+\n+                    zvec = ( zvec << 1 ) | zj;\n+                }\n+                nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];\n+\n+                continue;\n+            }\n+        }\n+    }\n+\n+    private void bsFinishedWithStream()\n+    {\n+        if (m_input != null)\n+        {\n+            try\n+            {\n+                m_input.close();\n+            }\n+            catch ( IOException e )\n+            {\n+            }\n+        }\n+        m_input = null;\n+    }\n+\n+    private int readVariableSizedInt( final int numBits )\n+    {\n+        return bsR( numBits );\n+    }\n+\n+    private char readUnsignedChar()\n+    {\n+        return (char)bsR( 8 );\n+    }\n+\n+    private int readInt()\n+    {\n+        int u = 0;\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        u = ( u << 8 ) | bsR( 8 );\n+        return u;\n+    }\n+\n+    private int bsR( final int n )\n+    {\n+        while( m_bsLive < n )\n+        {\n+            char ch = 0;\n+            try\n+            {\n+                ch = (char)m_input.read();\n+            }\n+            catch( final IOException ioe )\n+            {\n+                compressedStreamEOF();\n+            }\n+\n+            if( ch == -1 )\n+            {\n+                compressedStreamEOF();\n+            }\n+\n+            m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );\n+            m_bsLive += 8;\n+        }\n+\n+        final int result = ( m_bsBuff >> ( m_bsLive - n ) ) & ( ( 1 << n ) - 1 );\n+        m_bsLive -= n;\n+        return result;\n+    }\n+\n+    private void bsSetStream( final InputStream input )\n+    {\n+        m_input = input;\n+        m_bsLive = 0;\n+        m_bsBuff = 0;\n+    }\n+\n+    private void complete()\n+    {\n+        m_storedCombinedCRC = readInt();\n+        if( m_storedCombinedCRC != m_computedCombinedCRC )\n+        {\n+            crcError();\n+        }\n+\n+        bsFinishedWithStream();\n+        m_streamEnd = true;\n+    }\n+\n+    private void endBlock()\n+    {\n+        m_computedBlockCRC = m_crc.getFinalCRC();\n+        /*\n+         * A bad CRC is considered a fatal error.\n+         */\n+        if( m_storedBlockCRC != m_computedBlockCRC )\n+        {\n+            crcError();\n+        }\n+\n+        m_computedCombinedCRC = ( m_computedCombinedCRC << 1 )\n+            | ( m_computedCombinedCRC >>> 31 );\n+        m_computedCombinedCRC ^= m_computedBlockCRC;\n+    }\n+\n+    private void hbCreateDecodeTables( final int[] limit,\n+                                       final int[] base,\n+                                       final int[] perm,\n+                                       final char[] length,\n+                                       final int minLen,\n+                                       final int maxLen,\n+                                       final int alphaSize )\n+    {\n+        int pp = 0;\n+        for( int i = minLen; i <= maxLen; i++ )\n+        {\n+            for( int j = 0; j < alphaSize; j++ )\n+            {\n+                if( length[ j ] == i )\n+                {\n+                    perm[ pp ] = j;\n+                    pp++;\n+                }\n+            }\n+        }\n+\n+        for( int i = 0; i < MAX_CODE_LEN; i++ )\n+        {\n+            base[ i ] = 0;\n+        }\n+\n+        for( int i = 0; i < alphaSize; i++ )\n+        {\n+            base[ length[ i ] + 1 ]++;\n+        }\n+\n+        for( int i = 1; i < MAX_CODE_LEN; i++ )\n+        {\n+            base[ i ] += base[ i - 1 ];\n+        }\n+\n+        for( int i = 0; i < MAX_CODE_LEN; i++ )\n+        {\n+            limit[ i ] = 0;\n+        }\n+\n+        int vec = 0;\n+        for( int i = minLen; i <= maxLen; i++ )\n+        {\n+            vec += ( base[ i + 1 ] - base[ i ] );\n+            limit[ i ] = vec - 1;\n+            vec <<= 1;\n+        }\n+\n+        for( int i = minLen + 1; i <= maxLen; i++ )\n+        {\n+            base[ i ] = ( ( limit[ i - 1 ] + 1 ) << 1 ) - base[ i ];\n+        }\n+    }\n+\n+    private void initBlock()\n+    {\n+        final char magic1 = readUnsignedChar();\n+        final char magic2 = readUnsignedChar();\n+        final char magic3 = readUnsignedChar();\n+        final char magic4 = readUnsignedChar();\n+        final char magic5 = readUnsignedChar();\n+        final char magic6 = readUnsignedChar();\n+        if( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 &&\n+            magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 )\n+        {\n+            complete();\n+            return;\n+        }\n+\n+        if( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 ||\n+            magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 )\n+        {\n+            badBlockHeader();\n+            m_streamEnd = true;\n+            return;\n+        }\n+\n+        m_storedBlockCRC = readInt();\n+\n+        if( bsR( 1 ) == 1 )\n+        {\n+            m_blockRandomised = true;\n+        }\n+        else\n+        {\n+            m_blockRandomised = false;\n+        }\n+\n+        //        currBlockNo++;\n+        getAndMoveToFrontDecode();\n+\n+        m_crc.initialiseCRC();\n+        m_currentState = START_BLOCK_STATE;\n+    }\n+\n+    private void initialize()\n+    {\n+        final char magic3 = readUnsignedChar();\n+        final char magic4 = readUnsignedChar();\n+        if( magic3 != 'h' || magic4 < '1' || magic4 > '9' )\n+        {\n+            bsFinishedWithStream();\n+            m_streamEnd = true;\n+            return;\n+        }\n+\n+        setDecompressStructureSizes( magic4 - '0' );\n+        m_computedCombinedCRC = 0;\n+    }\n+\n+    private void makeMaps()\n+    {\n+        m_nInUse = 0;\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            if( m_inUse[ i ] )\n+            {\n+                m_seqToUnseq[ m_nInUse ] = (char)i;\n+                m_unseqToSeq[ i ] = (char)m_nInUse;\n+                m_nInUse++;\n+            }\n+        }\n+    }\n+\n+    private void recvDecodingTables()\n+    {\n+        buildInUseTable();\n+        makeMaps();\n+        final int alphaSize = m_nInUse + 2;\n+\n+        /*\n+         * Now the selectors\n+         */\n+        final int groupCount = bsR( 3 );\n+        final int selectorCount = bsR( 15 );\n+        for( int i = 0; i < selectorCount; i++ )\n+        {\n+            int run = 0;\n+            while( bsR( 1 ) == 1 )\n+            {\n+                run++;\n+            }\n+            m_selectorMtf[ i ] = (char)run;\n+        }\n+\n+        /*\n+         * Undo the MTF values for the selectors.\n+         */\n+        final char[] pos = new char[ N_GROUPS ];\n+        for( char v = 0; v < groupCount; v++ )\n+        {\n+            pos[ v ] = v;\n+        }\n+\n+        for( int i = 0; i < selectorCount; i++ )\n+        {\n+            int v = m_selectorMtf[ i ];\n+            final char tmp = pos[ v ];\n+            while( v > 0 )\n+            {\n+                pos[ v ] = pos[ v - 1 ];\n+                v--;\n+            }\n+            pos[ 0 ] = tmp;\n+            m_selector[ i ] = tmp;\n+        }\n+\n+        final char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+        /*\n+         * Now the coding tables\n+         */\n+        for( int i = 0; i < groupCount; i++ )\n+        {\n+            int curr = bsR( 5 );\n+            for( int j = 0; j < alphaSize; j++ )\n+            {\n+                while( bsR( 1 ) == 1 )\n+                {\n+                    if( bsR( 1 ) == 0 )\n+                    {\n+                        curr++;\n+                    }\n+                    else\n+                    {\n+                        curr--;\n+                    }\n+                }\n+                len[ i ][ j ] = (char)curr;\n+            }\n+        }\n+\n+        /*\n+         * Create the Huffman decoding tables\n+         */\n+        for( int k = 0; k < groupCount; k++ )\n+        {\n+            int minLen = 32;\n+            int maxLen = 0;\n+            for( int i = 0; i < alphaSize; i++ )\n+            {\n+                if( len[ k ][ i ] > maxLen )\n+                {\n+                    maxLen = len[ k ][ i ];\n+                }\n+                if( len[ k ][ i ] < minLen )\n+                {\n+                    minLen = len[ k ][ i ];\n+                }\n+            }\n+            hbCreateDecodeTables( m_limit[ k ], m_base[ k ], m_perm[ k ], len[ k ], minLen,\n+                                  maxLen, alphaSize );\n+            m_minLens[ k ] = minLen;\n+        }\n+    }\n+\n+    private void buildInUseTable()\n+    {\n+        final boolean[] inUse16 = new boolean[ 16 ];\n+\n+        /*\n+         * Receive the mapping table\n+         */\n+        for( int i = 0; i < 16; i++ )\n+        {\n+            if( bsR( 1 ) == 1 )\n+            {\n+                inUse16[ i ] = true;\n+            }\n+            else\n+            {\n+                inUse16[ i ] = false;\n+            }\n+        }\n+\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        for( int i = 0; i < 16; i++ )\n+        {\n+            if( inUse16[ i ] )\n+            {\n+                for( int j = 0; j < 16; j++ )\n+                {\n+                    if( bsR( 1 ) == 1 )\n+                    {\n+                        m_inUse[ i * 16 + j ] = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see java.io.InputStream#close()\n+     */\n+    public void close() throws IOException \n+    {\n+    \tbsFinishedWithStream();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/compressors/bzip2/BZip2OutputStream.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+/**\n+ * An output stream that compresses into the BZip2 format (without the file\n+ * header chars) into another stream. TODO: Update to BZip2 1.0.1\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+public class BZip2OutputStream\n+    extends OutputStream\n+    implements BZip2Constants\n+{\n+    private static final int LOWER_BYTE_MASK = 0x000000ff;\n+    private static final int UPPER_BYTE_MASK = 0xffffff00;\n+    private static final int SETMASK = ( 1 << 21 );\n+    private static final int CLEARMASK = ( ~SETMASK );\n+    private static final int GREATER_ICOST = 15;\n+    private static final int LESSER_ICOST = 0;\n+    private static final int SMALL_THRESH = 20;\n+    private static final int DEPTH_THRESH = 10;\n+\n+    /*\n+     * If you are ever unlucky/improbable enough\n+     * to get a stack overflow whilst sorting,\n+     * increase the following constant and try\n+     * again.  In practice I have never seen the\n+     * stack go above 27 elems, so the following\n+     * limit seems very generous.\n+     */\n+    private static final int QSORT_STACK_SIZE = 1000;\n+\n+    private CRC m_crc = new CRC();\n+\n+    private boolean[] m_inUse = new boolean[ 256 ];\n+\n+    private char[] m_seqToUnseq = new char[ 256 ];\n+    private char[] m_unseqToSeq = new char[ 256 ];\n+\n+    private char[] m_selector = new char[ MAX_SELECTORS ];\n+    private char[] m_selectorMtf = new char[ MAX_SELECTORS ];\n+\n+    private int[] m_mtfFreq = new int[ MAX_ALPHA_SIZE ];\n+\n+    private int m_currentChar = -1;\n+    private int m_runLength;\n+\n+    private boolean m_closed;\n+\n+    /*\n+     * Knuth's increments seem to work better\n+     * than Incerpi-Sedgewick here.  Possibly\n+     * because the number of elems to sort is\n+     * usually small, typically <= 20.\n+     */\n+    private int[] m_incs = new int[]\n+    {\n+        1, 4, 13, 40, 121, 364, 1093, 3280,\n+        9841, 29524, 88573, 265720,\n+        797161, 2391484\n+    };\n+\n+    private boolean m_blockRandomised;\n+\n+    /*\n+     * always: in the range 0 .. 9.\n+     * The current block size is 100000 * this number.\n+     */\n+    private int m_blockSize100k;\n+    private int m_bsBuff;\n+    private int m_bsLive;\n+\n+    /*\n+     * index of the last char in the block, so\n+     * the block size == last + 1.\n+     */\n+    private int m_last;\n+\n+    /*\n+     * index in zptr[] of original string after sorting.\n+     */\n+    private int m_origPtr;\n+\n+    private int m_allowableBlockSize;\n+\n+    private char[] m_block;\n+\n+    private int m_blockCRC;\n+    private int m_combinedCRC;\n+\n+    private OutputStream m_bsStream;\n+    private boolean m_firstAttempt;\n+    private int[] m_ftab;\n+    private int m_nInUse;\n+\n+    private int m_nMTF;\n+    private int[] m_quadrant;\n+    private short[] m_szptr;\n+    private int m_workDone;\n+\n+    /*\n+     * Used when sorting.  If too many long comparisons\n+     * happen, we stop sorting, randomise the block\n+     * slightly, and try again.\n+     */\n+    private int m_workFactor;\n+    private int m_workLimit;\n+    private int[] m_zptr;\n+\n+    public BZip2OutputStream( final OutputStream output )\n+        throws IOException\n+    {\n+        this( output, 9 );\n+    }\n+\n+    public BZip2OutputStream( final OutputStream output, final int blockSize )\n+        throws IOException\n+    {\n+        bsSetStream( output );\n+        m_workFactor = 50;\n+\n+        int outBlockSize = blockSize;\n+        if( outBlockSize > 9 )\n+        {\n+            outBlockSize = 9;\n+        }\n+        if( outBlockSize < 1 )\n+        {\n+            outBlockSize = 1;\n+        }\n+        m_blockSize100k = outBlockSize;\n+        allocateCompressStructures();\n+        initialize();\n+        initBlock();\n+    }\n+\n+    private static void hbMakeCodeLengths( char[] len, int[] freq,\n+                                           int alphaSize, int maxLen )\n+    {\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int nNodes;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int nHeap;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int n1;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int n2;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int i;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int j;\n+        /*\n+         * Nodes and heap entries run from 1.  Entry 0\n+         * for both the heap and nodes is a sentinel.\n+         */\n+        int k;\n+        boolean tooLong;\n+\n+        int[] heap = new int[ MAX_ALPHA_SIZE + 2 ];\n+        int[] weights = new int[ MAX_ALPHA_SIZE * 2 ];\n+        int[] parent = new int[ MAX_ALPHA_SIZE * 2 ];\n+\n+        for( i = 0; i < alphaSize; i++ )\n+        {\n+            weights[ i + 1 ] = ( freq[ i ] == 0 ? 1 : freq[ i ] ) << 8;\n+        }\n+\n+        while( true )\n+        {\n+            nNodes = alphaSize;\n+            nHeap = 0;\n+\n+            heap[ 0 ] = 0;\n+            weights[ 0 ] = 0;\n+            parent[ 0 ] = -2;\n+\n+            for( i = 1; i <= alphaSize; i++ )\n+            {\n+                parent[ i ] = -1;\n+                nHeap++;\n+                heap[ nHeap ] = i;\n+                {\n+                    int zz;\n+                    int tmp;\n+                    zz = nHeap;\n+                    tmp = heap[ zz ];\n+                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )\n+                    {\n+                        heap[ zz ] = heap[ zz >> 1 ];\n+                        zz >>= 1;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+            }\n+            if( !( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) )\n+            {\n+                panic();\n+            }\n+\n+            while( nHeap > 1 )\n+            {\n+                n1 = heap[ 1 ];\n+                heap[ 1 ] = heap[ nHeap ];\n+                nHeap--;\n+                {\n+                    int zz = 0;\n+                    int yy = 0;\n+                    int tmp = 0;\n+                    zz = 1;\n+                    tmp = heap[ zz ];\n+                    while( true )\n+                    {\n+                        yy = zz << 1;\n+                        if( yy > nHeap )\n+                        {\n+                            break;\n+                        }\n+                        if( yy < nHeap &&\n+                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )\n+                        {\n+                            yy++;\n+                        }\n+                        if( weights[ tmp ] < weights[ heap[ yy ] ] )\n+                        {\n+                            break;\n+                        }\n+                        heap[ zz ] = heap[ yy ];\n+                        zz = yy;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+                n2 = heap[ 1 ];\n+                heap[ 1 ] = heap[ nHeap ];\n+                nHeap--;\n+                {\n+                    int zz = 0;\n+                    int yy = 0;\n+                    int tmp = 0;\n+                    zz = 1;\n+                    tmp = heap[ zz ];\n+                    while( true )\n+                    {\n+                        yy = zz << 1;\n+                        if( yy > nHeap )\n+                        {\n+                            break;\n+                        }\n+                        if( yy < nHeap &&\n+                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )\n+                        {\n+                            yy++;\n+                        }\n+                        if( weights[ tmp ] < weights[ heap[ yy ] ] )\n+                        {\n+                            break;\n+                        }\n+                        heap[ zz ] = heap[ yy ];\n+                        zz = yy;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+                nNodes++;\n+                parent[ n1 ] = nNodes;\n+                parent[ n2 ] = nNodes;\n+\n+                final int v1 = weights[ n1 ];\n+                final int v2 = weights[ n2 ];\n+                final int weight = calculateWeight( v1, v2 );\n+                weights[ nNodes ] = weight;\n+\n+                parent[ nNodes ] = -1;\n+                nHeap++;\n+                heap[ nHeap ] = nNodes;\n+                {\n+                    int zz = 0;\n+                    int tmp = 0;\n+                    zz = nHeap;\n+                    tmp = heap[ zz ];\n+                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )\n+                    {\n+                        heap[ zz ] = heap[ zz >> 1 ];\n+                        zz >>= 1;\n+                    }\n+                    heap[ zz ] = tmp;\n+                }\n+            }\n+            if( !( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) )\n+            {\n+                panic();\n+            }\n+\n+            tooLong = false;\n+            for( i = 1; i <= alphaSize; i++ )\n+            {\n+                j = 0;\n+                k = i;\n+                while( parent[ k ] >= 0 )\n+                {\n+                    k = parent[ k ];\n+                    j++;\n+                }\n+                len[ i - 1 ] = (char)j;\n+                if( j > maxLen )\n+                {\n+                    tooLong = true;\n+                }\n+            }\n+\n+            if( !tooLong )\n+            {\n+                break;\n+            }\n+\n+            for( i = 1; i < alphaSize; i++ )\n+            {\n+                j = weights[ i ] >> 8;\n+                j = 1 + ( j / 2 );\n+                weights[ i ] = j << 8;\n+            }\n+        }\n+    }\n+\n+    private static int calculateWeight( final int v1, final int v2 )\n+    {\n+        final int upper = ( v1 & UPPER_BYTE_MASK ) + ( v2 & UPPER_BYTE_MASK );\n+        final int v1Lower = ( v1 & LOWER_BYTE_MASK );\n+        final int v2Lower = ( v2 & LOWER_BYTE_MASK );\n+        final int nnnn = ( v1Lower > v2Lower ) ? v1Lower : v2Lower;\n+        return upper | ( 1 + nnnn );\n+    }\n+\n+    private static void panic()\n+    {\n+        System.out.println( \"panic\" );\n+        //throw new CError();\n+    }\n+\n+    public void close()\n+        throws IOException\n+    {\n+        if( m_closed )\n+        {\n+            return;\n+        }\n+\n+        if( m_runLength > 0 )\n+        {\n+            writeRun();\n+        }\n+        m_currentChar = -1;\n+        endBlock();\n+        endCompression();\n+        m_closed = true;\n+        super.close();\n+        m_bsStream.close();\n+    }\n+\n+    public void finalize()\n+        throws Throwable\n+    {\n+        close();\n+    }\n+\n+    public void flush()\n+        throws IOException\n+    {\n+        super.flush();\n+        m_bsStream.flush();\n+    }\n+\n+    /**\n+     * modified by Oliver Merkel, 010128\n+     *\n+     * @param bv Description of Parameter\n+     * @exception java.io.IOException Description of Exception\n+     */\n+    /* (non-Javadoc)\n+     * @see java.io.OutputStream#write(int)\n+     */\n+    public void write( int bv )\n+        throws IOException\n+    {\n+        int b = ( 256 + bv ) % 256;\n+        if( m_currentChar != -1 )\n+        {\n+            if( m_currentChar == b )\n+            {\n+                m_runLength++;\n+                if( m_runLength > 254 )\n+                {\n+                    writeRun();\n+                    m_currentChar = -1;\n+                    m_runLength = 0;\n+                }\n+            }\n+            else\n+            {\n+                writeRun();\n+                m_runLength = 1;\n+                m_currentChar = b;\n+            }\n+        }\n+        else\n+        {\n+            m_currentChar = b;\n+            m_runLength++;\n+        }\n+    }\n+\n+    private void allocateCompressStructures()\n+    {\n+        int n = BASE_BLOCK_SIZE * m_blockSize100k;\n+        m_block = new char[ ( n + 1 + NUM_OVERSHOOT_BYTES ) ];\n+        m_quadrant = new int[ ( n + NUM_OVERSHOOT_BYTES ) ];\n+        m_zptr = new int[ n ];\n+        m_ftab = new int[ 65537 ];\n+\n+        if( m_block == null || m_quadrant == null || m_zptr == null\n+            || m_ftab == null )\n+        {\n+            //int totalDraw = (n + 1 + NUM_OVERSHOOT_BYTES) + (n + NUM_OVERSHOOT_BYTES) + n + 65537;\n+            //compressOutOfMemory ( totalDraw, n );\n+        }\n+\n+        /*\n+         * The back end needs a place to store the MTF values\n+         * whilst it calculates the coding tables.  We could\n+         * put them in the zptr array.  However, these values\n+         * will fit in a short, so we overlay szptr at the\n+         * start of zptr, in the hope of reducing the number\n+         * of cache misses induced by the multiple traversals\n+         * of the MTF values when calculating coding tables.\n+         * Seems to improve compression speed by about 1%.\n+         */\n+        //    szptr = zptr;\n+\n+        m_szptr = new short[ 2 * n ];\n+    }\n+\n+    private void bsFinishedWithStream()\n+        throws IOException\n+    {\n+        while( m_bsLive > 0 )\n+        {\n+            int ch = ( m_bsBuff >> 24 );\n+            try\n+            {\n+                m_bsStream.write( ch );// write 8-bit\n+            }\n+            catch( IOException e )\n+            {\n+                throw e;\n+            }\n+            m_bsBuff <<= 8;\n+            m_bsLive -= 8;\n+        }\n+    }\n+\n+    private void bsPutIntVS( int numBits, int c )\n+        throws IOException\n+    {\n+        bsW( numBits, c );\n+    }\n+\n+    private void bsPutUChar( int c )\n+        throws IOException\n+    {\n+        bsW( 8, c );\n+    }\n+\n+    private void bsPutint( int u )\n+        throws IOException\n+    {\n+        bsW( 8, ( u >> 24 ) & 0xff );\n+        bsW( 8, ( u >> 16 ) & 0xff );\n+        bsW( 8, ( u >> 8 ) & 0xff );\n+        bsW( 8, u & 0xff );\n+    }\n+\n+    private void bsSetStream( OutputStream f )\n+    {\n+        m_bsStream = f;\n+        m_bsLive = 0;\n+        m_bsBuff = 0;\n+    }\n+\n+    private void bsW( int n, int v )\n+        throws IOException\n+    {\n+        while( m_bsLive >= 8 )\n+        {\n+            int ch = ( m_bsBuff >> 24 );\n+            try\n+            {\n+                m_bsStream.write( ch );// write 8-bit\n+            }\n+            catch( IOException e )\n+            {\n+                throw e;\n+            }\n+            m_bsBuff <<= 8;\n+            m_bsLive -= 8;\n+        }\n+        m_bsBuff |= ( v << ( 32 - m_bsLive - n ) );\n+        m_bsLive += n;\n+    }\n+\n+    private void doReversibleTransformation()\n+    {\n+        int i;\n+\n+        m_workLimit = m_workFactor * m_last;\n+        m_workDone = 0;\n+        m_blockRandomised = false;\n+        m_firstAttempt = true;\n+\n+        mainSort();\n+\n+        if( m_workDone > m_workLimit && m_firstAttempt )\n+        {\n+            randomiseBlock();\n+            m_workLimit = 0;\n+            m_workDone = 0;\n+            m_blockRandomised = true;\n+            m_firstAttempt = false;\n+            mainSort();\n+        }\n+\n+        m_origPtr = -1;\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            if( m_zptr[ i ] == 0 )\n+            {\n+                m_origPtr = i;\n+                break;\n+            }\n+        }\n+        ;\n+\n+        if( m_origPtr == -1 )\n+        {\n+            panic();\n+        }\n+    }\n+\n+    private void endBlock()\n+        throws IOException\n+    {\n+        m_blockCRC = m_crc.getFinalCRC();\n+        m_combinedCRC = ( m_combinedCRC << 1 ) | ( m_combinedCRC >>> 31 );\n+        m_combinedCRC ^= m_blockCRC;\n+\n+        /*\n+         * sort the block and establish posn of original string\n+         */\n+        doReversibleTransformation();\n+\n+        /*\n+         * A 6-byte block header, the value chosen arbitrarily\n+         * as 0x314159265359 :-).  A 32 bit value does not really\n+         * give a strong enough guarantee that the value will not\n+         * appear by chance in the compressed datastream.  Worst-case\n+         * probability of this event, for a 900k block, is about\n+         * 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.\n+         * For a compressed file of size 100Gb -- about 100000 blocks --\n+         * only a 48-bit marker will do.  NB: normal compression/\n+         * decompression do *not* rely on these statistical properties.\n+         * They are only important when trying to recover blocks from\n+         * damaged files.\n+         */\n+        bsPutUChar( 0x31 );\n+        bsPutUChar( 0x41 );\n+        bsPutUChar( 0x59 );\n+        bsPutUChar( 0x26 );\n+        bsPutUChar( 0x53 );\n+        bsPutUChar( 0x59 );\n+\n+        /*\n+         * Now the block's CRC, so it is in a known place.\n+         */\n+        bsPutint( m_blockCRC );\n+\n+        /*\n+         * Now a single bit indicating randomisation.\n+         */\n+        if( m_blockRandomised )\n+        {\n+            bsW( 1, 1 );\n+        }\n+        else\n+        {\n+            bsW( 1, 0 );\n+        }\n+\n+        /*\n+         * Finally, block's contents proper.\n+         */\n+        moveToFrontCodeAndSend();\n+    }\n+\n+    private void endCompression()\n+        throws IOException\n+    {\n+        /*\n+         * Now another magic 48-bit number, 0x177245385090, to\n+         * indicate the end of the last block.  (sqrt(pi), if\n+         * you want to know.  I did want to use e, but it contains\n+         * too much repetition -- 27 18 28 18 28 46 -- for me\n+         * to feel statistically comfortable.  Call me paranoid.)\n+         */\n+        bsPutUChar( 0x17 );\n+        bsPutUChar( 0x72 );\n+        bsPutUChar( 0x45 );\n+        bsPutUChar( 0x38 );\n+        bsPutUChar( 0x50 );\n+        bsPutUChar( 0x90 );\n+\n+        bsPutint( m_combinedCRC );\n+\n+        bsFinishedWithStream();\n+    }\n+\n+    private boolean fullGtU( int i1, int i2 )\n+    {\n+        int k;\n+        char c1;\n+        char c2;\n+        int s1;\n+        int s2;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        c1 = m_block[ i1 + 1 ];\n+        c2 = m_block[ i2 + 1 ];\n+        if( c1 != c2 )\n+        {\n+            return ( c1 > c2 );\n+        }\n+        i1++;\n+        i2++;\n+\n+        k = m_last + 1;\n+\n+        do\n+        {\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            c1 = m_block[ i1 + 1 ];\n+            c2 = m_block[ i2 + 1 ];\n+            if( c1 != c2 )\n+            {\n+                return ( c1 > c2 );\n+            }\n+            s1 = m_quadrant[ i1 ];\n+            s2 = m_quadrant[ i2 ];\n+            if( s1 != s2 )\n+            {\n+                return ( s1 > s2 );\n+            }\n+            i1++;\n+            i2++;\n+\n+            if( i1 > m_last )\n+            {\n+                i1 -= m_last;\n+                i1--;\n+            }\n+            ;\n+            if( i2 > m_last )\n+            {\n+                i2 -= m_last;\n+                i2--;\n+            }\n+            ;\n+\n+            k -= 4;\n+            m_workDone++;\n+        } while( k >= 0 );\n+\n+        return false;\n+    }\n+\n+    private void generateMTFValues()\n+    {\n+        char[] yy = new char[ 256 ];\n+        int i;\n+        int j;\n+        char tmp;\n+        char tmp2;\n+        int zPend;\n+        int wr;\n+        int EOB;\n+\n+        makeMaps();\n+        EOB = m_nInUse + 1;\n+\n+        for( i = 0; i <= EOB; i++ )\n+        {\n+            m_mtfFreq[ i ] = 0;\n+        }\n+\n+        wr = 0;\n+        zPend = 0;\n+        for( i = 0; i < m_nInUse; i++ )\n+        {\n+            yy[ i ] = (char)i;\n+        }\n+\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            char ll_i;\n+\n+            ll_i = m_unseqToSeq[ m_block[ m_zptr[ i ] ] ];\n+\n+            j = 0;\n+            tmp = yy[ j ];\n+            while( ll_i != tmp )\n+            {\n+                j++;\n+                tmp2 = tmp;\n+                tmp = yy[ j ];\n+                yy[ j ] = tmp2;\n+            }\n+            ;\n+            yy[ 0 ] = tmp;\n+\n+            if( j == 0 )\n+            {\n+                zPend++;\n+            }\n+            else\n+            {\n+                if( zPend > 0 )\n+                {\n+                    zPend--;\n+                    while( true )\n+                    {\n+                        switch( zPend % 2 )\n+                        {\n+                            case 0:\n+                                m_szptr[ wr ] = (short)RUNA;\n+                                wr++;\n+                                m_mtfFreq[ RUNA ]++;\n+                                break;\n+                            case 1:\n+                                m_szptr[ wr ] = (short)RUNB;\n+                                wr++;\n+                                m_mtfFreq[ RUNB ]++;\n+                                break;\n+                        }\n+                        ;\n+                        if( zPend < 2 )\n+                        {\n+                            break;\n+                        }\n+                        zPend = ( zPend - 2 ) / 2;\n+                    }\n+                    ;\n+                    zPend = 0;\n+                }\n+                m_szptr[ wr ] = (short)( j + 1 );\n+                wr++;\n+                m_mtfFreq[ j + 1 ]++;\n+            }\n+        }\n+\n+        if( zPend > 0 )\n+        {\n+            zPend--;\n+            while( true )\n+            {\n+                switch( zPend % 2 )\n+                {\n+                    case 0:\n+                        m_szptr[ wr ] = (short)RUNA;\n+                        wr++;\n+                        m_mtfFreq[ RUNA ]++;\n+                        break;\n+                    case 1:\n+                        m_szptr[ wr ] = (short)RUNB;\n+                        wr++;\n+                        m_mtfFreq[ RUNB ]++;\n+                        break;\n+                }\n+                if( zPend < 2 )\n+                {\n+                    break;\n+                }\n+                zPend = ( zPend - 2 ) / 2;\n+            }\n+        }\n+\n+        m_szptr[ wr ] = (short)EOB;\n+        wr++;\n+        m_mtfFreq[ EOB ]++;\n+\n+        m_nMTF = wr;\n+    }\n+\n+    private void hbAssignCodes( int[] code, char[] length, int minLen,\n+                                int maxLen, int alphaSize )\n+    {\n+        int n;\n+        int vec;\n+        int i;\n+\n+        vec = 0;\n+        for( n = minLen; n <= maxLen; n++ )\n+        {\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                if( length[ i ] == n )\n+                {\n+                    code[ i ] = vec;\n+                    vec++;\n+                }\n+            }\n+            ;\n+            vec <<= 1;\n+        }\n+    }\n+\n+    private void initBlock()\n+    {\n+        //        blockNo++;\n+        m_crc.initialiseCRC();\n+        m_last = -1;\n+        //        ch = 0;\n+\n+        for( int i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        /*\n+         * 20 is just a paranoia constant\n+         */\n+        m_allowableBlockSize = BASE_BLOCK_SIZE * m_blockSize100k - 20;\n+    }\n+\n+    private void initialize()\n+        throws IOException\n+    {\n+        /*\n+         * Write `magic' bytes h indicating file-format == huffmanised,\n+         * followed by a digit indicating blockSize100k.\n+         */\n+        bsPutUChar( 'h' );\n+        bsPutUChar( '0' + m_blockSize100k );\n+\n+        m_combinedCRC = 0;\n+    }\n+\n+    private void mainSort()\n+    {\n+        int i;\n+        int j;\n+        int ss;\n+        int sb;\n+        int[] runningOrder = new int[ 256 ];\n+        int[] copy = new int[ 256 ];\n+        boolean[] bigDone = new boolean[ 256 ];\n+        int c1;\n+        int c2;\n+\n+        /*\n+         * In the various block-sized structures, live data runs\n+         * from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,\n+         * set up the overshoot area for block.\n+         */\n+        //   if (verbosity >= 4) fprintf ( stderr, \"        sort initialise ...\\n\" );\n+        for( i = 0; i < NUM_OVERSHOOT_BYTES; i++ )\n+        {\n+            m_block[ m_last + i + 2 ] = m_block[ ( i % ( m_last + 1 ) ) + 1 ];\n+        }\n+        for( i = 0; i <= m_last + NUM_OVERSHOOT_BYTES; i++ )\n+        {\n+            m_quadrant[ i ] = 0;\n+        }\n+\n+        m_block[ 0 ] = m_block[ m_last + 1 ];\n+\n+        if( m_last < 4000 )\n+        {\n+            /*\n+             * Use simpleSort(), since the full sorting mechanism\n+             * has quite a large constant overhead.\n+             */\n+            for( i = 0; i <= m_last; i++ )\n+            {\n+                m_zptr[ i ] = i;\n+            }\n+            m_firstAttempt = false;\n+            m_workDone = 0;\n+            m_workLimit = 0;\n+            simpleSort( 0, m_last, 0 );\n+        }\n+        else\n+        {\n+            for( i = 0; i <= 255; i++ )\n+            {\n+                bigDone[ i ] = false;\n+            }\n+\n+            for( i = 0; i <= 65536; i++ )\n+            {\n+                m_ftab[ i ] = 0;\n+            }\n+\n+            c1 = m_block[ 0 ];\n+            for( i = 0; i <= m_last; i++ )\n+            {\n+                c2 = m_block[ i + 1 ];\n+                m_ftab[ ( c1 << 8 ) + c2 ]++;\n+                c1 = c2;\n+            }\n+\n+            for( i = 1; i <= 65536; i++ )\n+            {\n+                m_ftab[ i ] += m_ftab[ i - 1 ];\n+            }\n+\n+            c1 = m_block[ 1 ];\n+            for( i = 0; i < m_last; i++ )\n+            {\n+                c2 = m_block[ i + 2 ];\n+                j = ( c1 << 8 ) + c2;\n+                c1 = c2;\n+                m_ftab[ j ]--;\n+                m_zptr[ m_ftab[ j ] ] = i;\n+            }\n+\n+            j = ( ( m_block[ m_last + 1 ] ) << 8 ) + ( m_block[ 1 ] );\n+            m_ftab[ j ]--;\n+            m_zptr[ m_ftab[ j ] ] = m_last;\n+\n+            /*\n+             * Now ftab contains the first loc of every small bucket.\n+             * Calculate the running order, from smallest to largest\n+             * big bucket.\n+             */\n+            for( i = 0; i <= 255; i++ )\n+            {\n+                runningOrder[ i ] = i;\n+            }\n+            {\n+                int vv;\n+                int h = 1;\n+                do\n+                {\n+                    h = 3 * h + 1;\n+                } while( h <= 256 );\n+                do\n+                {\n+                    h = h / 3;\n+                    for( i = h; i <= 255; i++ )\n+                    {\n+                        vv = runningOrder[ i ];\n+                        j = i;\n+                        while( ( m_ftab[ ( ( runningOrder[ j - h ] ) + 1 ) << 8 ]\n+                            - m_ftab[ ( runningOrder[ j - h ] ) << 8 ] ) >\n+                            ( m_ftab[ ( ( vv ) + 1 ) << 8 ] - m_ftab[ ( vv ) << 8 ] ) )\n+                        {\n+                            runningOrder[ j ] = runningOrder[ j - h ];\n+                            j = j - h;\n+                            if( j <= ( h - 1 ) )\n+                            {\n+                                break;\n+                            }\n+                        }\n+                        runningOrder[ j ] = vv;\n+                    }\n+                } while( h != 1 );\n+            }\n+\n+            /*\n+             * The main sorting loop.\n+             */\n+            for( i = 0; i <= 255; i++ )\n+            {\n+\n+                /*\n+                 * Process big buckets, starting with the least full.\n+                 */\n+                ss = runningOrder[ i ];\n+\n+                /*\n+                 * Complete the big bucket [ss] by quicksorting\n+                 * any unsorted small buckets [ss, j].  Hopefully\n+                 * previous pointer-scanning phases have already\n+                 * completed many of the small buckets [ss, j], so\n+                 * we don't have to sort them at all.\n+                 */\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    sb = ( ss << 8 ) + j;\n+                    if( !( ( m_ftab[ sb ] & SETMASK ) == SETMASK ) )\n+                    {\n+                        int lo = m_ftab[ sb ] & CLEARMASK;\n+                        int hi = ( m_ftab[ sb + 1 ] & CLEARMASK ) - 1;\n+                        if( hi > lo )\n+                        {\n+                            qSort3( lo, hi, 2 );\n+                            if( m_workDone > m_workLimit && m_firstAttempt )\n+                            {\n+                                return;\n+                            }\n+                        }\n+                        m_ftab[ sb ] |= SETMASK;\n+                    }\n+                }\n+\n+                /*\n+                 * The ss big bucket is now done.  Record this fact,\n+                 * and update the quadrant descriptors.  Remember to\n+                 * update quadrants in the overshoot area too, if\n+                 * necessary.  The \"if (i < 255)\" test merely skips\n+                 * this updating for the last bucket processed, since\n+                 * updating for the last bucket is pointless.\n+                 */\n+                bigDone[ ss ] = true;\n+\n+                if( i < 255 )\n+                {\n+                    int bbStart = m_ftab[ ss << 8 ] & CLEARMASK;\n+                    int bbSize = ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart;\n+                    int shifts = 0;\n+\n+                    while( ( bbSize >> shifts ) > 65534 )\n+                    {\n+                        shifts++;\n+                    }\n+\n+                    for( j = 0; j < bbSize; j++ )\n+                    {\n+                        int a2update = m_zptr[ bbStart + j ];\n+                        int qVal = ( j >> shifts );\n+                        m_quadrant[ a2update ] = qVal;\n+                        if( a2update < NUM_OVERSHOOT_BYTES )\n+                        {\n+                            m_quadrant[ a2update + m_last + 1 ] = qVal;\n+                        }\n+                    }\n+\n+                    if( !( ( ( bbSize - 1 ) >> shifts ) <= 65535 ) )\n+                    {\n+                        panic();\n+                    }\n+                }\n+\n+                /*\n+                 * Now scan this big bucket so as to synthesise the\n+                 * sorted order for small buckets [t, ss] for all t != ss.\n+                 */\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    copy[ j ] = m_ftab[ ( j << 8 ) + ss ] & CLEARMASK;\n+                }\n+\n+                for( j = m_ftab[ ss << 8 ] & CLEARMASK;\n+                     j < ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ); j++ )\n+                {\n+                    c1 = m_block[ m_zptr[ j ] ];\n+                    if( !bigDone[ c1 ] )\n+                    {\n+                        m_zptr[ copy[ c1 ] ] = m_zptr[ j ] == 0 ? m_last : m_zptr[ j ] - 1;\n+                        copy[ c1 ]++;\n+                    }\n+                }\n+\n+                for( j = 0; j <= 255; j++ )\n+                {\n+                    m_ftab[ ( j << 8 ) + ss ] |= SETMASK;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void makeMaps()\n+    {\n+        int i;\n+        m_nInUse = 0;\n+        for( i = 0; i < 256; i++ )\n+        {\n+            if( m_inUse[ i ] )\n+            {\n+                m_seqToUnseq[ m_nInUse ] = (char)i;\n+                m_unseqToSeq[ i ] = (char)m_nInUse;\n+                m_nInUse++;\n+            }\n+        }\n+    }\n+\n+    private char med3( char a, char b, char c )\n+    {\n+        char t;\n+        if( a > b )\n+        {\n+            t = a;\n+            a = b;\n+            b = t;\n+        }\n+        if( b > c )\n+        {\n+            t = b;\n+            b = c;\n+            c = t;\n+        }\n+        if( a > b )\n+        {\n+            b = a;\n+        }\n+        return b;\n+    }\n+\n+    private void moveToFrontCodeAndSend()\n+        throws IOException\n+    {\n+        bsPutIntVS( 24, m_origPtr );\n+        generateMTFValues();\n+        sendMTFValues();\n+    }\n+\n+    private void qSort3( int loSt, int hiSt, int dSt )\n+    {\n+        int unLo;\n+        int unHi;\n+        int ltLo;\n+        int gtHi;\n+        int med;\n+        int n;\n+        int m;\n+        int sp;\n+        int lo;\n+        int hi;\n+        int d;\n+        StackElem[] stack = new StackElem[ QSORT_STACK_SIZE ];\n+        for( int count = 0; count < QSORT_STACK_SIZE; count++ )\n+        {\n+            stack[ count ] = new StackElem();\n+        }\n+\n+        sp = 0;\n+\n+        stack[ sp ].m_ll = loSt;\n+        stack[ sp ].m_hh = hiSt;\n+        stack[ sp ].m_dd = dSt;\n+        sp++;\n+\n+        while( sp > 0 )\n+        {\n+            if( sp >= QSORT_STACK_SIZE )\n+            {\n+                panic();\n+            }\n+\n+            sp--;\n+            lo = stack[ sp ].m_ll;\n+            hi = stack[ sp ].m_hh;\n+            d = stack[ sp ].m_dd;\n+\n+            if( hi - lo < SMALL_THRESH || d > DEPTH_THRESH )\n+            {\n+                simpleSort( lo, hi, d );\n+                if( m_workDone > m_workLimit && m_firstAttempt )\n+                {\n+                    return;\n+                }\n+                continue;\n+            }\n+\n+            med = med3( m_block[ m_zptr[ lo ] + d + 1 ],\n+                        m_block[ m_zptr[ hi ] + d + 1 ],\n+                        m_block[ m_zptr[ ( lo + hi ) >> 1 ] + d + 1 ] );\n+\n+            unLo = lo;\n+            ltLo = lo;\n+            unHi = hi;\n+            gtHi = hi;\n+\n+            while( true )\n+            {\n+                while( true )\n+                {\n+                    if( unLo > unHi )\n+                    {\n+                        break;\n+                    }\n+                    n = m_block[ m_zptr[ unLo ] + d + 1 ] - med;\n+                    if( n == 0 )\n+                    {\n+                        int temp = 0;\n+                        temp = m_zptr[ unLo ];\n+                        m_zptr[ unLo ] = m_zptr[ ltLo ];\n+                        m_zptr[ ltLo ] = temp;\n+                        ltLo++;\n+                        unLo++;\n+                        continue;\n+                    }\n+                    ;\n+                    if( n > 0 )\n+                    {\n+                        break;\n+                    }\n+                    unLo++;\n+                }\n+                while( true )\n+                {\n+                    if( unLo > unHi )\n+                    {\n+                        break;\n+                    }\n+                    n = m_block[ m_zptr[ unHi ] + d + 1 ] - med;\n+                    if( n == 0 )\n+                    {\n+                        int temp = 0;\n+                        temp = m_zptr[ unHi ];\n+                        m_zptr[ unHi ] = m_zptr[ gtHi ];\n+                        m_zptr[ gtHi ] = temp;\n+                        gtHi--;\n+                        unHi--;\n+                        continue;\n+                    }\n+                    ;\n+                    if( n < 0 )\n+                    {\n+                        break;\n+                    }\n+                    unHi--;\n+                }\n+                if( unLo > unHi )\n+                {\n+                    break;\n+                }\n+                int temp = 0;\n+                temp = m_zptr[ unLo ];\n+                m_zptr[ unLo ] = m_zptr[ unHi ];\n+                m_zptr[ unHi ] = temp;\n+                unLo++;\n+                unHi--;\n+            }\n+\n+            if( gtHi < ltLo )\n+            {\n+                stack[ sp ].m_ll = lo;\n+                stack[ sp ].m_hh = hi;\n+                stack[ sp ].m_dd = d + 1;\n+                sp++;\n+                continue;\n+            }\n+\n+            n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo );\n+            vswap( lo, unLo - n, n );\n+            m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi );\n+            vswap( unLo, hi - m + 1, m );\n+\n+            n = lo + unLo - ltLo - 1;\n+            m = hi - ( gtHi - unHi ) + 1;\n+\n+            stack[ sp ].m_ll = lo;\n+            stack[ sp ].m_hh = n;\n+            stack[ sp ].m_dd = d;\n+            sp++;\n+\n+            stack[ sp ].m_ll = n + 1;\n+            stack[ sp ].m_hh = m - 1;\n+            stack[ sp ].m_dd = d + 1;\n+            sp++;\n+\n+            stack[ sp ].m_ll = m;\n+            stack[ sp ].m_hh = hi;\n+            stack[ sp ].m_dd = d;\n+            sp++;\n+        }\n+    }\n+\n+    private void randomiseBlock()\n+    {\n+        int i;\n+        int rNToGo = 0;\n+        int rTPos = 0;\n+        for( i = 0; i < 256; i++ )\n+        {\n+            m_inUse[ i ] = false;\n+        }\n+\n+        for( i = 0; i <= m_last; i++ )\n+        {\n+            if( rNToGo == 0 )\n+            {\n+                rNToGo = (char)RAND_NUMS[ rTPos ];\n+                rTPos++;\n+                if( rTPos == 512 )\n+                {\n+                    rTPos = 0;\n+                }\n+            }\n+            rNToGo--;\n+            m_block[ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 );\n+            // handle 16 bit signed numbers\n+            m_block[ i + 1 ] &= 0xFF;\n+\n+            m_inUse[ m_block[ i + 1 ] ] = true;\n+        }\n+    }\n+\n+    private void sendMTFValues()\n+        throws IOException\n+    {\n+        char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+\n+        int v;\n+\n+        int t;\n+\n+        int i;\n+\n+        int j;\n+\n+        int gs;\n+\n+        int ge;\n+\n+        int bt;\n+\n+        int bc;\n+\n+        int iter;\n+        int nSelectors = 0;\n+        int alphaSize;\n+        int minLen;\n+        int maxLen;\n+        int selCtr;\n+        int nGroups;\n+\n+        alphaSize = m_nInUse + 2;\n+        for( t = 0; t < N_GROUPS; t++ )\n+        {\n+            for( v = 0; v < alphaSize; v++ )\n+            {\n+                len[ t ][ v ] = (char)GREATER_ICOST;\n+            }\n+        }\n+\n+        /*\n+         * Decide how many coding tables to use\n+         */\n+        if( m_nMTF <= 0 )\n+        {\n+            panic();\n+        }\n+\n+        if( m_nMTF < 200 )\n+        {\n+            nGroups = 2;\n+        }\n+        else if( m_nMTF < 600 )\n+        {\n+            nGroups = 3;\n+        }\n+        else if( m_nMTF < 1200 )\n+        {\n+            nGroups = 4;\n+        }\n+        else if( m_nMTF < 2400 )\n+        {\n+            nGroups = 5;\n+        }\n+        else\n+        {\n+            nGroups = 6;\n+        }\n+        {\n+            /*\n+             * Generate an initial set of coding tables\n+             */\n+            int nPart;\n+            int remF;\n+            int tFreq;\n+            int aFreq;\n+\n+            nPart = nGroups;\n+            remF = m_nMTF;\n+            gs = 0;\n+            while( nPart > 0 )\n+            {\n+                tFreq = remF / nPart;\n+                ge = gs - 1;\n+                aFreq = 0;\n+                while( aFreq < tFreq && ge < alphaSize - 1 )\n+                {\n+                    ge++;\n+                    aFreq += m_mtfFreq[ ge ];\n+                }\n+\n+                if( ge > gs && nPart != nGroups && nPart != 1\n+                    && ( ( nGroups - nPart ) % 2 == 1 ) )\n+                {\n+                    aFreq -= m_mtfFreq[ ge ];\n+                    ge--;\n+                }\n+\n+                for( v = 0; v < alphaSize; v++ )\n+                {\n+                    if( v >= gs && v <= ge )\n+                    {\n+                        len[ nPart - 1 ][ v ] = (char)LESSER_ICOST;\n+                    }\n+                    else\n+                    {\n+                        len[ nPart - 1 ][ v ] = (char)GREATER_ICOST;\n+                    }\n+                }\n+\n+                nPart--;\n+                gs = ge + 1;\n+                remF -= aFreq;\n+            }\n+        }\n+\n+        int[][] rfreq = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+        int[] fave = new int[ N_GROUPS ];\n+        short[] cost = new short[ N_GROUPS ];\n+        /*\n+         * Iterate up to N_ITERS times to improve the tables.\n+         */\n+        for( iter = 0; iter < N_ITERS; iter++ )\n+        {\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                fave[ t ] = 0;\n+            }\n+\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                for( v = 0; v < alphaSize; v++ )\n+                {\n+                    rfreq[ t ][ v ] = 0;\n+                }\n+            }\n+\n+            nSelectors = 0;\n+            gs = 0;\n+            while( true )\n+            {\n+\n+                /*\n+                 * Set group start & end marks.\n+                 */\n+                if( gs >= m_nMTF )\n+                {\n+                    break;\n+                }\n+                ge = gs + G_SIZE - 1;\n+                if( ge >= m_nMTF )\n+                {\n+                    ge = m_nMTF - 1;\n+                }\n+\n+                /*\n+                 * Calculate the cost of this group as coded\n+                 * by each of the coding tables.\n+                 */\n+                for( t = 0; t < nGroups; t++ )\n+                {\n+                    cost[ t ] = 0;\n+                }\n+\n+                if( nGroups == 6 )\n+                {\n+                    short cost0 = 0;\n+                    short cost1 = 0;\n+                    short cost2 = 0;\n+                    short cost3 = 0;\n+                    short cost4 = 0;\n+                    short cost5 = 0;\n+\n+                    for( i = gs; i <= ge; i++ )\n+                    {\n+                        short icv = m_szptr[ i ];\n+                        cost0 += len[ 0 ][ icv ];\n+                        cost1 += len[ 1 ][ icv ];\n+                        cost2 += len[ 2 ][ icv ];\n+                        cost3 += len[ 3 ][ icv ];\n+                        cost4 += len[ 4 ][ icv ];\n+                        cost5 += len[ 5 ][ icv ];\n+                    }\n+                    cost[ 0 ] = cost0;\n+                    cost[ 1 ] = cost1;\n+                    cost[ 2 ] = cost2;\n+                    cost[ 3 ] = cost3;\n+                    cost[ 4 ] = cost4;\n+                    cost[ 5 ] = cost5;\n+                }\n+                else\n+                {\n+                    for( i = gs; i <= ge; i++ )\n+                    {\n+                        short icv = m_szptr[ i ];\n+                        for( t = 0; t < nGroups; t++ )\n+                        {\n+                            cost[ t ] += len[ t ][ icv ];\n+                        }\n+                    }\n+                }\n+\n+                /*\n+                 * Find the coding table which is best for this group,\n+                 * and record its identity in the selector table.\n+                 */\n+                bc = 999999999;\n+                bt = -1;\n+                for( t = 0; t < nGroups; t++ )\n+                {\n+                    if( cost[ t ] < bc )\n+                    {\n+                        bc = cost[ t ];\n+                        bt = t;\n+                    }\n+                }\n+                ;\n+                fave[ bt ]++;\n+                m_selector[ nSelectors ] = (char)bt;\n+                nSelectors++;\n+\n+                /*\n+                 * Increment the symbol frequencies for the selected table.\n+                 */\n+                for( i = gs; i <= ge; i++ )\n+                {\n+                    rfreq[ bt ][ m_szptr[ i ] ]++;\n+                }\n+\n+                gs = ge + 1;\n+            }\n+\n+            /*\n+             * Recompute the tables based on the accumulated frequencies.\n+             */\n+            for( t = 0; t < nGroups; t++ )\n+            {\n+                hbMakeCodeLengths( len[ t ], rfreq[ t ], alphaSize, 20 );\n+            }\n+        }\n+\n+        rfreq = null;\n+        fave = null;\n+        cost = null;\n+\n+        if( !( nGroups < 8 ) )\n+        {\n+            panic();\n+        }\n+        if( !( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) )\n+        {\n+            panic();\n+        }\n+        {\n+            /*\n+             * Compute MTF values for the selectors.\n+             */\n+            char[] pos = new char[ N_GROUPS ];\n+            char ll_i;\n+            char tmp2;\n+            char tmp;\n+            for( i = 0; i < nGroups; i++ )\n+            {\n+                pos[ i ] = (char)i;\n+            }\n+            for( i = 0; i < nSelectors; i++ )\n+            {\n+                ll_i = m_selector[ i ];\n+                j = 0;\n+                tmp = pos[ j ];\n+                while( ll_i != tmp )\n+                {\n+                    j++;\n+                    tmp2 = tmp;\n+                    tmp = pos[ j ];\n+                    pos[ j ] = tmp2;\n+                }\n+                pos[ 0 ] = tmp;\n+                m_selectorMtf[ i ] = (char)j;\n+            }\n+        }\n+\n+        int[][] code = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];\n+\n+        /*\n+         * Assign actual codes for the tables.\n+         */\n+        for( t = 0; t < nGroups; t++ )\n+        {\n+            minLen = 32;\n+            maxLen = 0;\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                if( len[ t ][ i ] > maxLen )\n+                {\n+                    maxLen = len[ t ][ i ];\n+                }\n+                if( len[ t ][ i ] < minLen )\n+                {\n+                    minLen = len[ t ][ i ];\n+                }\n+            }\n+            if( maxLen > 20 )\n+            {\n+                panic();\n+            }\n+            if( minLen < 1 )\n+            {\n+                panic();\n+            }\n+            hbAssignCodes( code[ t ], len[ t ], minLen, maxLen, alphaSize );\n+        }\n+        {\n+            /*\n+             * Transmit the mapping table.\n+             */\n+            boolean[] inUse16 = new boolean[ 16 ];\n+            for( i = 0; i < 16; i++ )\n+            {\n+                inUse16[ i ] = false;\n+                for( j = 0; j < 16; j++ )\n+                {\n+                    if( m_inUse[ i * 16 + j ] )\n+                    {\n+                        inUse16[ i ] = true;\n+                    }\n+                }\n+            }\n+\n+            for( i = 0; i < 16; i++ )\n+            {\n+                if( inUse16[ i ] )\n+                {\n+                    bsW( 1, 1 );\n+                }\n+                else\n+                {\n+                    bsW( 1, 0 );\n+                }\n+            }\n+\n+            for( i = 0; i < 16; i++ )\n+            {\n+                if( inUse16[ i ] )\n+                {\n+                    for( j = 0; j < 16; j++ )\n+                    {\n+                        if( m_inUse[ i * 16 + j ] )\n+                        {\n+                            bsW( 1, 1 );\n+                        }\n+                        else\n+                        {\n+                            bsW( 1, 0 );\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        /*\n+         * Now the selectors.\n+         */\n+        bsW( 3, nGroups );\n+        bsW( 15, nSelectors );\n+        for( i = 0; i < nSelectors; i++ )\n+        {\n+            for( j = 0; j < m_selectorMtf[ i ]; j++ )\n+            {\n+                bsW( 1, 1 );\n+            }\n+            bsW( 1, 0 );\n+        }\n+\n+        for( t = 0; t < nGroups; t++ )\n+        {\n+            int curr = len[ t ][ 0 ];\n+            bsW( 5, curr );\n+            for( i = 0; i < alphaSize; i++ )\n+            {\n+                while( curr < len[ t ][ i ] )\n+                {\n+                    bsW( 2, 2 );\n+                    curr++;\n+                    /*\n+                     * 10\n+                     */\n+                }\n+                while( curr > len[ t ][ i ] )\n+                {\n+                    bsW( 2, 3 );\n+                    curr--;\n+                    /*\n+                     * 11\n+                     */\n+                }\n+                bsW( 1, 0 );\n+            }\n+        }\n+\n+        /*\n+         * And finally, the block data proper\n+         */\n+        selCtr = 0;\n+        gs = 0;\n+        while( true )\n+        {\n+            if( gs >= m_nMTF )\n+            {\n+                break;\n+            }\n+            ge = gs + G_SIZE - 1;\n+            if( ge >= m_nMTF )\n+            {\n+                ge = m_nMTF - 1;\n+            }\n+            for( i = gs; i <= ge; i++ )\n+            {\n+                bsW( len[ m_selector[ selCtr ] ][ m_szptr[ i ] ],\n+                     code[ m_selector[ selCtr ] ][ m_szptr[ i ] ] );\n+            }\n+\n+            gs = ge + 1;\n+            selCtr++;\n+        }\n+        if( !( selCtr == nSelectors ) )\n+        {\n+            panic();\n+        }\n+    }\n+\n+    private void simpleSort( int lo, int hi, int d )\n+    {\n+        int i;\n+        int j;\n+        int h;\n+        int bigN;\n+        int hp;\n+        int v;\n+\n+        bigN = hi - lo + 1;\n+        if( bigN < 2 )\n+        {\n+            return;\n+        }\n+\n+        hp = 0;\n+        while( m_incs[ hp ] < bigN )\n+        {\n+            hp++;\n+        }\n+        hp--;\n+\n+        for( ; hp >= 0; hp-- )\n+        {\n+            h = m_incs[ hp ];\n+\n+            i = lo + h;\n+            while( true )\n+            {\n+                /*\n+                 * copy 1\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                /*\n+                 * copy 2\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                /*\n+                 * copy 3\n+                 */\n+                if( i > hi )\n+                {\n+                    break;\n+                }\n+                v = m_zptr[ i ];\n+                j = i;\n+                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )\n+                {\n+                    m_zptr[ j ] = m_zptr[ j - h ];\n+                    j = j - h;\n+                    if( j <= ( lo + h - 1 ) )\n+                    {\n+                        break;\n+                    }\n+                }\n+                m_zptr[ j ] = v;\n+                i++;\n+\n+                if( m_workDone > m_workLimit && m_firstAttempt )\n+                {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void vswap( int p1, int p2, int n )\n+    {\n+        int temp = 0;\n+        while( n > 0 )\n+        {\n+            temp = m_zptr[ p1 ];\n+            m_zptr[ p1 ] = m_zptr[ p2 ];\n+            m_zptr[ p2 ] = temp;\n+            p1++;\n+            p2++;\n+            n--;\n+        }\n+    }\n+\n+    private void writeRun()\n+        throws IOException\n+    {\n+        if( m_last < m_allowableBlockSize )\n+        {\n+            m_inUse[ m_currentChar ] = true;\n+            for( int i = 0; i < m_runLength; i++ )\n+            {\n+                m_crc.updateCRC( (char)m_currentChar );\n+            }\n+            switch( m_runLength )\n+            {\n+                case 1:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                case 2:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                case 3:\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    break;\n+                default:\n+                    m_inUse[ m_runLength - 4 ] = true;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)m_currentChar;\n+                    m_last++;\n+                    m_block[ m_last + 1 ] = (char)( m_runLength - 4 );\n+                    break;\n+            }\n+        }\n+        else\n+        {\n+            endBlock();\n+            initBlock();\n+            writeRun();\n+        }\n+    }\n+\n+    private static class StackElem\n+    {\n+        int m_dd;\n+        int m_hh;\n+        int m_ll;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n+\n+/**\n+ * A simple class the hold and calculate the CRC for sanity checking of the\n+ * data.\n+ *\n+ * @author <a href=\"mailto:keiron@aftexsw.com\">Keiron Liddle</a>\n+ */\n+class CRC\n+{\n+    private static int[] CRC32_TABLE = new int[]\n+    {\n+        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n+        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n+        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n+        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n+        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n+        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n+        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n+        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n+        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n+        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n+        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n+        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n+        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n+        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n+        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n+        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n+        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n+        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n+        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n+        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n+        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n+        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n+        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n+        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n+        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n+        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n+        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n+        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n+        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n+        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n+        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n+        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n+        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n+        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n+        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n+        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n+        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n+        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n+        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n+        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n+        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n+        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n+        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n+        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n+        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n+        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n+        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n+        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n+        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n+        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n+        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n+        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n+        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n+        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n+        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n+        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n+        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n+        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n+        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n+        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n+        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n+        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n+        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n+        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n+    };\n+\n+    private int m_globalCrc;\n+\n+    protected CRC()\n+    {\n+        initialiseCRC();\n+    }\n+\n+    int getFinalCRC()\n+    {\n+        return ~m_globalCrc;\n+    }\n+\n+    void initialiseCRC()\n+    {\n+        m_globalCrc = 0xffffffff;\n+    }\n+\n+    void updateCRC( final int inCh )\n+    {\n+        int temp = ( m_globalCrc >> 24 ) ^ inCh;\n+        if( temp < 0 )\n+        {\n+            temp = 256 + temp;\n+        }\n+        m_globalCrc = ( m_globalCrc << 8 ) ^ CRC32_TABLE[ temp ];\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/CompressUtilsTest.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test for Compress Utils\n+ * @author christian.grobmeier\n+ */\n+public class CompressUtilsTest extends TestCase {\n+\n+\tpublic void testCompareByteArrays() {\n+\t\tbyte[] source = { 0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0 };\n+\t\tbyte[] match = { 0x0, 0x0, 0x0, 0x0, 0x0 };\n+\t\t\n+\t\tassertTrue(CompressUtils.compareByteArrays(source, match));\n+\t\t\n+\t\tbyte[] match2 = { 0x0, 0x0, 0x0, 0x0, 0x10 };\n+\t\tassertFalse(CompressUtils.compareByteArrays(source, match2));\n+\t\t\n+\t\tbyte[] source3 = { 0x50, 0x4b, 0x03, 0x04, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0 };\n+\t\tbyte[] match3 = { 0x50, 0x4b, 0x03, 0x04};\n+\t\tassertTrue(CompressUtils.compareByteArrays(source3, match3));\n+\t\t\n+\t\tbyte[] source4 = { 0x50, 0x4b, 0x03, 0x04, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0,0x0, 0x0, 0x0, 0x0, 0x0 };\n+\t\tbyte[] match4 = { 0x52, 0x4b, 0x03, 0x04};\n+\t\tassertFalse(CompressUtils.compareByteArrays(source4, match4));\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/tar/TarTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.compress.archivers.tar.TarEntry;\n+import org.apache.commons.compress.archivers.tar.TarInputStream;\n+\n+/**\n+ * Test case for all tar resources.\n+ *\n+ * @todo Find V7 tar and do tests against it\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 155439 $ $Date$\n+ */\n+public final class TarTestCase\n+    extends TestCase\n+{\n+    private static final char SP = File.separatorChar;\n+    private static final String BASE_DATA_NAME = \"data.txt\";\n+    private static final String LFN_PART = \"a-b-c-d-e-f-g-h-i-j/\";\n+    private static final String LONG_FILE_NAME =\n+        LFN_PART + LFN_PART + LFN_PART + LFN_PART + LFN_PART + \"a\";\n+\n+    private static final String BASEDIR = calcBaseDir();\n+\n+    private static final File BASEDIR_FILE = new File( BASEDIR );\n+    private static final File POSIX_TAR_FILE =\n+        new File( BASEDIR_FILE, \"posix.tar\" );\n+    //    private static final File V7_TAR_FILE =\n+    //        new File( BASEDIR_FILE, \"v7.tar\" );\n+    private static final File GNU_TAR_FILE =\n+        new File( BASEDIR_FILE, \"gnu.tar\" );\n+    private static final File DATA_FILE1 =\n+        new File( BASEDIR_FILE, BASE_DATA_NAME );\n+    private static final String USER_NAME = \"avalon\";\n+    private static final String GROUP_NAME = \"excalibur\";\n+    private static final long SIZE = DATA_FILE1.length();\n+    private static final int GROUP_ID = 0;\n+    private static final int USER_ID = 0;\n+    private static final int MODE = 0100000;\n+    private static final int MOD_TIME = 0;\n+\n+    public TarTestCase()\n+    {\n+        this( \"Tar Test Case\" );\n+    }\n+\n+    public TarTestCase( String name )\n+    {\n+        super( name );\n+    }\n+\n+    private static String calcBaseDir()\n+    {\n+        final String name = TarTestCase.class.getName();\n+        final int size = name.length();\n+        final String filename =\n+            name.substring( 0, size - 11 ).replace( '.', SP );\n+        return \"src\" + SP + \"test\" + SP +\n+                SP + filename + SP;\n+    }\n+\n+    public void testReadPosixTar()\n+        throws Exception\n+    {\n+        compareTar( BASE_DATA_NAME, POSIX_TAR_FILE );\n+    }\n+\n+    public void testReadGnuTar()\n+        throws Exception\n+    {\n+        compareTar( LONG_FILE_NAME, GNU_TAR_FILE );\n+    }\n+\n+    public void testWritePosixTar()\n+        throws Exception\n+    {\n+        //final File temp = new File( BASEDIR_FILE, \"posix2.tar\" );\n+        final File temp = File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream fileOutput = new FileOutputStream( temp );\n+        final TarOutputStream output = new TarOutputStream( fileOutput );\n+        //output.setBufferDebug( true );\n+        final TarEntry entry = new TarEntry( BASE_DATA_NAME );\n+        setupEntry( entry );\n+        output.putNextEntry( entry );\n+\n+        final FileInputStream fileInput = new FileInputStream( DATA_FILE1 );\n+        output.copyEntryContents( fileInput );\n+        output.closeEntry();\n+        shutdownStream( fileInput );\n+        shutdownStream( output );\n+        shutdownStream( fileOutput );\n+\n+        assertTrue( \"Tar files Equal\", contentEquals( temp, POSIX_TAR_FILE ) );\n+        temp.delete();\n+    }\n+\n+    public void testWriteGnuTar()\n+        throws Exception\n+    {\n+        //final File temp = new File( BASEDIR_FILE, \"gnu2.tar\" );\n+        final File temp = File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream fileOutput = new FileOutputStream( temp );\n+        final TarOutputStream output = new TarOutputStream( fileOutput );\n+        //output.setBufferDebug( true );\n+        output.setLongFileMode( TarOutputStream.LONGFILE_GNU );\n+        final TarEntry entry = new TarEntry( LONG_FILE_NAME );\n+        setupEntry( entry );\n+        output.putNextEntry( entry );\n+\n+        final FileInputStream fileInput = new FileInputStream( DATA_FILE1 );\n+        output.copyEntryContents( fileInput );\n+        output.closeEntry();\n+        shutdownStream( fileInput );\n+        shutdownStream( output );\n+        shutdownStream( fileOutput );\n+\n+        //Have to compare it this way as the contents will differ\n+        //due to entry created for second part of name\n+        compareTar( LONG_FILE_NAME, temp );\n+        temp.delete();\n+    }\n+\n+    private void setupEntry( final TarEntry entry )\n+    {\n+        entry.setModTime( MOD_TIME );\n+        entry.setSize( SIZE );\n+        entry.setUserID( USER_ID );\n+        entry.setGroupID( GROUP_ID );\n+        entry.setUserName( USER_NAME );\n+        entry.setGroupName( GROUP_NAME );\n+        entry.setMode( MODE );\n+    }\n+\n+    private void checkEntry( final TarEntry entry )\n+    {\n+        assertEquals( \"Entry size\", SIZE, entry.getSize() );\n+        assertEquals( \"Entry User ID\", USER_ID, entry.getUserID() );\n+        assertEquals( \"Entry Group ID\", GROUP_ID, entry.getGroupID() );\n+        assertEquals( \"Entry User name\", USER_NAME, entry.getUserName() );\n+        assertEquals( \"Entry group name\", GROUP_NAME, entry.getGroupName() );\n+        assertEquals( \"Entry mode\", MODE, entry.getMode() );\n+        assertEquals( \"Entry mode\", MOD_TIME, entry.getModTime().getTime() / 1000 );\n+    }\n+\n+    /**\n+     * Read tar entry with specified name from tar file1 and compare\n+     * against data file DATA_FILE1.\n+     *\n+     * @param entryName the expected name of entry\n+     * @param file1 the tar file comparing\n+     * @throws IOException if an error occurs\n+     */\n+    private void compareTar( final String entryName,\n+                             final File file1 )\n+        throws IOException\n+    {\n+        final FileInputStream fileInput = new FileInputStream( file1 );\n+        final TarInputStream input = new TarInputStream( fileInput );\n+        //input.setDebug( true );\n+        final TarEntry entry = input.getNextEntry();\n+\n+        assertEquals( \"Entry name\", entryName, entry.getName() );\n+        checkEntry( entry );\n+\n+        final File temp = new File( BASEDIR_FILE, entryName.length() + \"data.txt\" );//File.createTempFile( \"delete-me\", \"tar\" );\n+        final FileOutputStream output = new FileOutputStream( temp );\n+        input.copyEntryContents( output );\n+        shutdownStream( output );\n+\n+        assertNull( \"Next Entry\", input.getNextEntry() );\n+\n+        shutdownStream( input );\n+\n+        assertTrue( \"Data Equals\", contentEquals( temp, DATA_FILE1 ) );\n+        temp.delete();\n+    }\n+\n+    /**\n+     * Compare the contents of two files to determine if they are equal or not.\n+     *\n+     * @param file1 the first file\n+     * @param file2 the second file\n+     * @return true if the content of the files are equal or they both don't exist, false otherwise\n+     */\n+    private boolean contentEquals( final File file1, final File file2 )\n+        throws IOException\n+    {\n+        final boolean file1Exists = file1.exists();\n+        if( file1Exists != file2.exists() )\n+        {\n+            return false;\n+        }\n+\n+        if( !file1Exists )\n+        {\n+            // two not existing files are equal\n+            return true;\n+        }\n+\n+        if( file1.isDirectory() || file2.isDirectory() )\n+        {\n+            // don't want to compare directory contents\n+            return false;\n+        }\n+\n+        InputStream input1 = null;\n+        InputStream input2 = null;\n+        try\n+        {\n+            input1 = new FileInputStream( file1 );\n+            input2 = new FileInputStream( file2 );\n+            return contentEquals( input1, input2 );\n+\n+        }\n+        finally\n+        {\n+            shutdownStream( input1 );\n+            shutdownStream( input2 );\n+        }\n+    }\n+\n+    /**\n+     * Compare the contents of two Streams to determine if they are equal or not.\n+     *\n+     * @param input1 the first stream\n+     * @param input2 the second stream\n+     * @return true if the content of the streams are equal or they both don't exist, false otherwise\n+     */\n+    private boolean contentEquals( final InputStream input1,\n+                                   final InputStream input2 )\n+        throws IOException\n+    {\n+        final InputStream bufferedInput1 = new BufferedInputStream( input1 );\n+        final InputStream bufferedInput2 = new BufferedInputStream( input2 );\n+\n+        int count = 0;\n+        int ch = bufferedInput1.read();\n+        while( -1 != ch )\n+        {\n+            final int ch2 = bufferedInput2.read();\n+            count++;\n+            if( ch != ch2 )\n+            {\n+                System.out.println( \"count = \" + count );\n+                System.out.println( \"ch2 = \" + ch2 );\n+                System.out.println( \"ch = \" + ch );\n+                return false;\n+            }\n+            ch = bufferedInput1.read();\n+        }\n+\n+        final int ch2 = bufferedInput2.read();\n+        if( -1 != ch2 )\n+        {\n+            return false;\n+        }\n+        else\n+        {\n+            return true;\n+        }\n+    }\n+\n+    private void shutdownStream( final InputStream input )\n+    {\n+        if( null == input )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            input.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+\n+    private void shutdownStream( final OutputStream output )\n+    {\n+        if( null == output )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            output.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/tar/TarTestSuite.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.tar;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * A basic test suite that tests all the tar package.\n+ */\n+public class TarTestSuite\n+{\n+    public static Test suite()\n+    {\n+        final TestSuite suite = new TestSuite( \"Tar Utilities\" );\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/zip/AsiExtraFieldTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.ZipException;\n+\n+import org.apache.commons.compress.archivers.zip.AsiExtraField;\n+import org.apache.commons.compress.archivers.zip.UnixStat;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit testcases AsiExtraField.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class AsiExtraFieldTestCase\n+    extends TestCase\n+    implements UnixStat\n+{\n+    public AsiExtraFieldTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test file mode magic.\n+     */\n+    public void testModes()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setMode( 0123 );\n+        assertEquals( \"plain file\", 0100123, field.getMode() );\n+        field.setDirectory( true );\n+        assertEquals( \"directory\", 040123, field.getMode() );\n+        field.setLinkedFile( \"test\" );\n+        assertEquals( \"symbolic link\", 0120123, field.getMode() );\n+    }\n+\n+    private AsiExtraField createField()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setMode( 0123 );\n+        field.setUserID( 5 );\n+        field.setGroupId( 6 );\n+        return field;\n+    }\n+\n+    public void testContent1()\n+    {\n+        final AsiExtraField field = createField();\n+        final byte[] data = field.getLocalFileDataData();\n+\n+        // CRC manually calculated, sorry\n+        final byte[] expect = {(byte)0xC6, 0x02, 0x78, (byte)0xB6, // CRC\n+                               0123, (byte)0x80, // mode\n+                               0, 0, 0, 0, // link length\n+                               5, 0, 6, 0};                        // uid, gid\n+        assertEquals( \"no link\", expect.length, data.length );\n+        for( int i = 0; i < expect.length; i++ )\n+        {\n+            assertEquals( \"no link, byte \" + i, expect[ i ], data[ i ] );\n+        }\n+\n+        field.setLinkedFile( \"test\" );\n+    }\n+\n+    public void testContent2()\n+    {\n+        final AsiExtraField field = createField();\n+        field.setLinkedFile( \"test\" );\n+\n+        final byte[] data = field.getLocalFileDataData();\n+        final byte[] expect = new byte[]{0x75, (byte)0x8E, 0x41, (byte)0xFD, // CRC\n+                                         0123, (byte)0xA0, // mode\n+                                         4, 0, 0, 0, // link length\n+                                         5, 0, 6, 0, // uid, gid\n+                                         (byte)'t', (byte)'e', (byte)'s', (byte)'t'};\n+        assertEquals( \"no link\", expect.length, data.length );\n+        for( int i = 0; i < expect.length; i++ )\n+        {\n+            assertEquals( \"no link, byte \" + i, expect[ i ], data[ i ] );\n+        }\n+\n+    }\n+\n+    public void testReparse1()\n+        throws ZipException\n+    {\n+        // CRC manually calculated, sorry\n+        final byte[] data = {(byte)0xC6, 0x02, 0x78, (byte)0xB6, // CRC\n+                             0123, (byte)0x80, // mode\n+                             0, 0, 0, 0, // link length\n+                             5, 0, 6, 0};                        // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+\n+        assertEquals( \"length plain file\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"plain file, no link\", !field.isLink() );\n+        assertTrue( \"plain file, no dir\", !field.isDirectory() );\n+        assertEquals( \"mode plain file\", FILE_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid plain file\", 5, field.getUserID() );\n+        assertEquals( \"gid plain file\", 6, field.getGroupID() );\n+    }\n+\n+    public void testReparse2()\n+        throws ZipException\n+    {\n+        final byte[] data = new byte[]{0x75, (byte)0x8E, 0x41, (byte)0xFD, // CRC\n+                                       0123, (byte)0xA0, // mode\n+                                       4, 0, 0, 0, // link length\n+                                       5, 0, 6, 0, // uid, gid\n+                                       (byte)'t', (byte)'e', (byte)'s', (byte)'t'};\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+        assertEquals( \"length link\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"link, is link\", field.isLink() );\n+        assertTrue( \"link, no dir\", !field.isDirectory() );\n+        assertEquals( \"mode link\", LINK_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid link\", 5, field.getUserID() );\n+        assertEquals( \"gid link\", 6, field.getGroupID() );\n+        assertEquals( \"test\", field.getLinkedFile() );\n+    }\n+\n+    public void testReparse3()\n+        throws ZipException\n+    {\n+        final byte[] data = new byte[]{(byte)0x8E, 0x01, (byte)0xBF, (byte)0x0E, // CRC\n+                                       0123, (byte)0x40, // mode\n+                                       0, 0, 0, 0, // link\n+                                       5, 0, 6, 0};                          // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        field.parseFromLocalFileData( data, 0, data.length );\n+        assertEquals( \"length dir\", data.length,\n+                      field.getLocalFileDataLength().getValue() );\n+        assertTrue( \"dir, no link\", !field.isLink() );\n+        assertTrue( \"dir, is dir\", field.isDirectory() );\n+        assertEquals( \"mode dir\", DIR_FLAG | 0123, field.getMode() );\n+        assertEquals( \"uid dir\", 5, field.getUserID() );\n+        assertEquals( \"gid dir\", 6, field.getGroupID() );\n+    }\n+\n+    public void testReparse4()\n+        throws Exception\n+    {\n+        final byte[] data = new byte[]{0, 0, 0, 0, // bad CRC\n+                                       0123, (byte)0x40, // mode\n+                                       0, 0, 0, 0, // link\n+                                       5, 0, 6, 0};                          // uid, gid\n+        final AsiExtraField field = new AsiExtraField();\n+        try\n+        {\n+            field.parseFromLocalFileData( data, 0, data.length );\n+            fail( \"should raise bad CRC exception\" );\n+        }\n+        catch( Exception e )\n+        {\n+            assertEquals( \"bad CRC checksum 0 instead of ebf018e\",\n+                          e.getMessage() );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/zip/ExtraFieldUtilsTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.archivers.zip.AsiExtraField;\n+import org.apache.commons.compress.archivers.zip.ExtraFieldUtils;\n+import org.apache.commons.compress.archivers.zip.UnixStat;\n+import org.apache.commons.compress.archivers.zip.UnrecognizedExtraField;\n+import org.apache.commons.compress.archivers.zip.ZipExtraField;\n+import org.apache.commons.compress.archivers.zip.ZipShort;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit testcases ExtraFieldUtils.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ExtraFieldUtilsTestCase\n+    extends TestCase\n+    implements UnixStat\n+{\n+    private AsiExtraField m_field;\n+    private UnrecognizedExtraField m_dummy;\n+    private byte[] m_data;\n+    private byte[] m_local;\n+\n+    public ExtraFieldUtilsTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void setUp()\n+    {\n+        m_field = new AsiExtraField();\n+        m_field.setMode( 0755 );\n+        m_field.setDirectory( true );\n+        m_dummy = new UnrecognizedExtraField();\n+        m_dummy.setHeaderID( new ZipShort( 1 ) );\n+        m_dummy.setLocalFileDataData( new byte[ 0 ] );\n+        m_dummy.setCentralDirectoryData( new byte[]{0} );\n+\n+        m_local = m_field.getLocalFileDataData();\n+        final byte[] dummyLocal = m_dummy.getLocalFileDataData();\n+        m_data = new byte[ 4 + m_local.length + 4 + dummyLocal.length ];\n+        System.arraycopy( m_field.getHeaderID().getBytes(), 0, m_data, 0, 2 );\n+        System.arraycopy( m_field.getLocalFileDataLength().getBytes(), 0, m_data, 2, 2 );\n+        System.arraycopy( m_local, 0, m_data, 4, m_local.length );\n+        System.arraycopy( m_dummy.getHeaderID().getBytes(), 0, m_data,\n+                          4 + m_local.length, 2 );\n+        System.arraycopy( m_dummy.getLocalFileDataLength().getBytes(), 0, m_data,\n+                          4 + m_local.length + 2, 2 );\n+        System.arraycopy( dummyLocal, 0, m_data,\n+                          4 + m_local.length + 4, dummyLocal.length );\n+\n+    }\n+\n+    /**\n+     * test parser.\n+     */\n+    public void testParse() throws Exception\n+    {\n+        final ZipExtraField[] extraField = ExtraFieldUtils.parse( m_data );\n+        assertEquals( \"number of fields\", 2, extraField.length );\n+        assertTrue( \"type field 1\", extraField[ 0 ] instanceof AsiExtraField );\n+        assertEquals( \"mode field 1\", 040755,\n+                      ( (AsiExtraField)extraField[ 0 ] ).getMode() );\n+        assertTrue( \"type field 2\", extraField[ 1 ] instanceof UnrecognizedExtraField );\n+        assertEquals( \"data length field 2\", 0,\n+                      extraField[ 1 ].getLocalFileDataLength().getValue() );\n+\n+        final byte[] data2 = new byte[ m_data.length - 1 ];\n+        System.arraycopy( m_data, 0, data2, 0, data2.length );\n+        try\n+        {\n+            ExtraFieldUtils.parse( data2 );\n+            fail( \"data should be invalid\" );\n+        }\n+        catch( Exception e )\n+        {\n+            assertEquals( \"message\",\n+                          \"data starting at \" + ( 4 + m_local.length ) + \" is in unknown format\",\n+                          e.getMessage() );\n+        }\n+    }\n+\n+    /**\n+     * Test merge methods\n+     */\n+    public void testMerge()\n+    {\n+        final byte[] local =\n+            ExtraFieldUtils.mergeLocalFileDataData( new ZipExtraField[]{m_field, m_dummy} );\n+        assertEquals( \"local length\", m_data.length, local.length );\n+        for( int i = 0; i < local.length; i++ )\n+        {\n+            assertEquals( \"local byte \" + i, m_data[ i ], local[ i ] );\n+        }\n+\n+        final byte[] dummyCentral = m_dummy.getCentralDirectoryData();\n+        final byte[] data2 = new byte[ 4 + m_local.length + 4 + dummyCentral.length ];\n+        System.arraycopy( m_data, 0, data2, 0, 4 + m_local.length + 2 );\n+        System.arraycopy( m_dummy.getCentralDirectoryLength().getBytes(), 0,\n+                          data2, 4 + m_local.length + 2, 2 );\n+        System.arraycopy( dummyCentral, 0, data2,\n+                          4 + m_local.length + 4, dummyCentral.length );\n+\n+        final byte[] central =\n+            ExtraFieldUtils.mergeCentralDirectoryData( new ZipExtraField[]{m_field, m_dummy} );\n+        assertEquals( \"central length\", data2.length, central.length );\n+        for( int i = 0; i < central.length; i++ )\n+        {\n+            assertEquals( \"central byte \" + i, data2[ i ], central[ i ] );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/zip/ZipEntryTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.compress.archivers.zip.AsiExtraField;\n+import org.apache.commons.compress.archivers.zip.UnrecognizedExtraField;\n+import org.apache.commons.compress.archivers.zip.ZipEntry;\n+import org.apache.commons.compress.archivers.zip.ZipExtraField;\n+import org.apache.commons.compress.archivers.zip.ZipShort;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit testcases ZipEntry.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipEntryTestCase\n+    extends TestCase\n+{\n+    public ZipEntryTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * test handling of extra fields\n+     */\n+    public void testExtraFields()\n+    {\n+        final AsiExtraField field = createField();\n+        final UnrecognizedExtraField extraField = createExtraField();\n+\n+        final ZipEntry entry = new ZipEntry( \"test/\" );\n+        entry.setExtraFields( new ZipExtraField[]{field, extraField} );\n+        final byte[] data1 = entry.getExtra();\n+        ZipExtraField[] result = entry.getExtraFields();\n+        assertEquals( \"first pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( extraField, result[ 1 ] );\n+\n+        UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n+        u2.setHeaderID( new ZipShort( 1 ) );\n+        u2.setLocalFileDataData( new byte[]{1} );\n+\n+        entry.addExtraField( u2 );\n+        byte[] data2 = entry.getExtra();\n+        result = entry.getExtraFields();\n+        assertEquals( \"second pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( u2, result[ 1 ] );\n+        assertEquals( \"length second pass\", data1.length + 1, data2.length );\n+\n+        UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n+        u3.setHeaderID( new ZipShort( 2 ) );\n+        u3.setLocalFileDataData( new byte[]{1} );\n+        entry.addExtraField( u3 );\n+        result = entry.getExtraFields();\n+        assertEquals( \"third pass\", 3, result.length );\n+\n+        entry.removeExtraField( new ZipShort( 1 ) );\n+        byte[] data3 = entry.getExtra();\n+        result = entry.getExtraFields();\n+        assertEquals( \"fourth pass\", 2, result.length );\n+        assertSame( field, result[ 0 ] );\n+        assertSame( u3, result[ 1 ] );\n+        assertEquals( \"length fourth pass\", data2.length, data3.length );\n+\n+        try\n+        {\n+            entry.removeExtraField( new ZipShort( 1 ) );\n+            fail( \"should be no such element\" );\n+        }\n+        catch( final NoSuchElementException nse )\n+        {\n+        }\n+    }\n+\n+    private UnrecognizedExtraField createExtraField()\n+    {\n+        UnrecognizedExtraField extraField = new UnrecognizedExtraField();\n+        extraField.setHeaderID( new ZipShort( 1 ) );\n+        extraField.setLocalFileDataData( new byte[ 0 ] );\n+        return extraField;\n+    }\n+\n+    private AsiExtraField createField()\n+    {\n+        final AsiExtraField field = new AsiExtraField();\n+        field.setDirectory( true );\n+        field.setMode( 0755 );\n+        return field;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/zip/ZipLongTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.archivers.zip.ZipLong;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit 3 testcases for org.apache.tools.zip.ZipLong.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipLongTestCase\n+    extends TestCase\n+{\n+\n+    public ZipLongTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testToBytes()\n+    {\n+        final ZipLong zipLong = new ZipLong( 0x12345678 );\n+        final byte[] result = zipLong.getBytes();\n+        assertEquals( \"length getBytes\", 4, result.length );\n+        assertEquals( \"first byte getBytes\", 0x78, result[ 0 ] );\n+        assertEquals( \"second byte getBytes\", 0x56, result[ 1 ] );\n+        assertEquals( \"third byte getBytes\", 0x34, result[ 2 ] );\n+        assertEquals( \"fourth byte getBytes\", 0x12, result[ 3 ] );\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testFromBytes()\n+    {\n+        final byte[] value = new byte[]{0x78, 0x56, 0x34, 0x12};\n+        final ZipLong zipLong = new ZipLong( value );\n+        assertEquals( \"value from bytes\", 0x12345678, zipLong.getValue() );\n+    }\n+\n+    /**\n+     * Test the contract of the equals method.\n+     */\n+    public void testEquals()\n+    {\n+        final ZipLong zipLong1 = new ZipLong( 0x12345678 );\n+        final ZipLong zipLong2 = new ZipLong( 0x12345678 );\n+        final ZipLong zipLong3 = new ZipLong( 0x87654321 );\n+\n+        assertTrue( \"reflexive\", zipLong1.equals( zipLong1 ) );\n+\n+        assertTrue( \"works\", zipLong1.equals( zipLong2 ) );\n+        assertTrue( \"works, part two\", !zipLong1.equals( zipLong3 ) );\n+\n+        assertTrue( \"symmetric\", zipLong2.equals( zipLong1 ) );\n+\n+        assertTrue( \"null handling\", !zipLong1.equals( null ) );\n+        assertTrue( \"non ZipLong handling\", !zipLong1.equals( new Integer( 0x1234 ) ) );\n+    }\n+\n+    /**\n+     * Test sign handling.\n+     */\n+    public void testSign()\n+    {\n+        final ZipLong zipLong =\n+            new ZipLong( new byte[]{(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF} );\n+        assertEquals( 0x00000000FFFFFFFFl, zipLong.getValue() );\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/archivers/zip/ZipShortTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.archivers.zip.ZipShort;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit 3 testcases for org.apache.tools.zip.ZipShort.\n+ *\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ */\n+public class ZipShortTestCase\n+    extends TestCase\n+{\n+    public ZipShortTestCase( String name )\n+    {\n+        super( name );\n+    }\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testToBytes()\n+    {\n+        final ZipShort zipShort = new ZipShort( 0x1234 );\n+        byte[] result = zipShort.getBytes();\n+        assertEquals( \"length getBytes\", 2, result.length );\n+        assertEquals( \"first byte getBytes\", 0x34, result[ 0 ] );\n+        assertEquals( \"second byte getBytes\", 0x12, result[ 1 ] );\n+    }\n+\n+    /**\n+     * Test conversion from bytes.\n+     */\n+    public void testFromBytes()\n+    {\n+        byte[] val = new byte[]{0x34, 0x12};\n+        final ZipShort zipShort = new ZipShort( val );\n+        assertEquals( \"value from bytes\", 0x1234, zipShort.getValue() );\n+    }\n+\n+    /**\n+     * Test the contract of the equals method.\n+     */\n+    public void testEquals()\n+    {\n+        final ZipShort zipShort = new ZipShort( 0x1234 );\n+        final ZipShort zipShort2 = new ZipShort( 0x1234 );\n+        final ZipShort zipShort3 = new ZipShort( 0x5678 );\n+\n+        assertTrue( \"reflexive\", zipShort.equals( zipShort ) );\n+\n+        assertTrue( \"works\", zipShort.equals( zipShort2 ) );\n+        assertTrue( \"works, part two\", !zipShort.equals( zipShort3 ) );\n+\n+        assertTrue( \"symmetric\", zipShort2.equals( zipShort ) );\n+\n+        assertTrue( \"null handling\", !zipShort.equals( null ) );\n+        assertTrue( \"non ZipShort handling\", !zipShort.equals( new Integer( 0x1234 ) ) );\n+    }\n+\n+    /**\n+     * Test sign handling.\n+     */\n+    public void testSign()\n+    {\n+        final ZipShort zipShort = new ZipShort( new byte[]{(byte)0xFF, (byte)0xFF} );\n+        assertEquals( 0x0000FFFF, zipShort.getValue() );\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/compress/compressors/bzip2/BzipTestCase.java\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.compress.CompressUtils;\n+import org.apache.commons.compress.compressors.bzip2.BZip2InputStream;\n+import org.apache.commons.compress.compressors.bzip2.BZip2OutputStream;\n+\n+/**\n+ * A test the stress tested the BZip implementation to verify\n+ * that it behaves correctly.\n+ *\n+ * @author <a href=\"mailto:peter@apache.org\">Peter Donald</a>\n+ * @version $Revision: 280140 $ $Date$\n+ */\n+public class BzipTestCase\n+    extends TestCase\n+{\n+    private static final byte[] HEADER = new byte[]{(byte)'B', (byte)'Z'};\n+\n+    public BzipTestCase( final String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void testBzipOutputStream()\n+        throws Exception\n+    {\n+        final InputStream input = getInputStream( \"asf-logo-huge.tar\" );\n+        final File outputFile = getOutputFile( \".tar.bz2\" );\n+        final OutputStream output = new FileOutputStream( outputFile );\n+        final BZip2OutputStream packedOutput = getPackedOutput( output );\n+        CompressUtils.copy( input, packedOutput );\n+        shutdownStream( input );\n+        shutdownStream( packedOutput );\n+        shutdownStream( output );\n+        compareContents( \"asf-logo-huge.tar.bz2\", outputFile );\n+        forceDelete( outputFile );\n+    }\n+\n+    private void forceDelete( final File outputFile ) throws IOException\n+    {\n+        if( !outputFile.delete() )\n+        {\n+            final String message = \"File \" + outputFile + \" unable to be deleted.\";\n+            throw new IOException( message );\n+        }\n+    }\n+\n+    public void testBzipInputStream()\n+        throws Exception\n+    {\n+        final InputStream input = getInputStream( \"asf-logo-huge.tar.bz2\" );\n+        final File outputFile = getOutputFile( \".tar\" );\n+        final OutputStream output = new FileOutputStream( outputFile );\n+        final BZip2InputStream packedInput = getPackedInput( input );\n+        CompressUtils.copy( packedInput, output );\n+        shutdownStream( input );\n+        shutdownStream( packedInput );\n+        shutdownStream( output );\n+        compareContents( \"asf-logo-huge.tar\", outputFile );\n+        forceDelete( outputFile );\n+    }\n+\n+    public void testCBZip2InputStreamClose()\n+        throws Exception\n+    {\n+        final InputStream input = getInputStream( \"asf-logo-huge.tar.bz2\" );\n+        final File outputFile = getOutputFile( \".tar.bz2\" );\n+        final OutputStream output = new FileOutputStream( outputFile );\n+        CompressUtils.copy( input, output );\n+        shutdownStream( input );\n+        shutdownStream( output );\n+        assertTrue( \"Check output file exists.\" , outputFile.exists() );\n+        final InputStream input2 = new FileInputStream( outputFile );\n+        final InputStream packedInput = getPackedInput( input2 );\n+        shutdownStream( packedInput );\n+        try\n+        {\n+            input2.read();\n+            assertTrue(\"Source input stream is still opened.\", false);\n+        } catch ( Exception e )\n+        {\n+            // Read closed stream.\n+        }\n+        forceDelete( outputFile );\n+    }\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.\n+     */\n+    private void copy( final InputStream input,\n+                       final OutputStream output )\n+        throws IOException\n+    {\n+        final byte[] buffer = new byte[ 8024 ];\n+        int n = 0;\n+        while( -1 != ( n = input.read( buffer ) ) )\n+        {\n+            output.write( buffer, 0, n );\n+        }\n+    }\n+\n+    private void compareContents( final String initial, final File generated )\n+        throws Exception\n+    {\n+        final InputStream input1 = getInputStream( initial );\n+        final InputStream input2 = new FileInputStream( generated );\n+        final boolean test = contentEquals( input1, input2 );\n+        shutdownStream( input1 );\n+        shutdownStream( input2 );\n+        assertTrue( \"Contents of \" + initial + \" matches generated version \" + generated, test );\n+    }\n+\n+    private BZip2InputStream getPackedInput( final InputStream input )\n+        throws IOException\n+    {\n+        final int b1 = input.read();\n+        final int b2 = input.read();\n+        assertEquals( \"Equal header byte1\", b1, 'B' );\n+        assertEquals( \"Equal header byte2\", b2, 'Z' );\n+        return new BZip2InputStream( input );\n+    }\n+\n+    private BZip2OutputStream getPackedOutput( final OutputStream output )\n+        throws IOException\n+    {\n+        output.write( HEADER );\n+        return new BZip2OutputStream( output );\n+    }\n+\n+    private File getOutputFile( final String postfix )\n+        throws IOException\n+    {\n+        final File cwd = new File( \".\" );\n+        return File.createTempFile( \"ant-test\", postfix, cwd );\n+    }\n+\n+    private InputStream getInputStream( final String resource )\n+        throws Exception\n+    {\n+        final String filename =\n+            \"src\" + File.separator + \"test\" + File.separator +\n+            getClass().getName().replace( '.', File.separatorChar );\n+        final String path = getPath( filename );\n+        final File input = new File( path, resource );\n+        return new FileInputStream( input );\n+//        final ClassLoader loader = getClass().getClassLoader();\n+//        return loader.getResourceAsStream( resource );\n+    }\n+\n+    /**\n+     * Compare the contents of two Streams to determine if they are equal or not.\n+     *\n+     * @param input1 the first stream\n+     * @param input2 the second stream\n+     * @return true if the content of the streams are equal or they both don't exist, false otherwise\n+     */\n+    private boolean contentEquals( final InputStream input1,\n+                                   final InputStream input2 )\n+        throws IOException\n+    {\n+        final InputStream bufferedInput1 = new BufferedInputStream( input1 );\n+        final InputStream bufferedInput2 = new BufferedInputStream( input2 );\n+\n+        int ch = bufferedInput1.read();\n+        while( -1 != ch )\n+        {\n+            final int ch2 = bufferedInput2.read();\n+            if( ch != ch2 )\n+            {\n+                return false;\n+            }\n+            ch = bufferedInput1.read();\n+        }\n+\n+        final int ch2 = bufferedInput2.read();\n+        if( -1 != ch2 )\n+        {\n+            return false;\n+        }\n+        else\n+        {\n+            return true;\n+        }\n+    }\n+\n+    private String getPath( final String filepath )\n+    {\n+        final int index = filepath.lastIndexOf( File.separatorChar );\n+        if( -1 == index )\n+        {\n+            return \"\";\n+        }\n+        else\n+        {\n+            return filepath.substring( 0, index );\n+        }\n+    }\n+\n+    /**\n+     * Unconditionally close an <code>OutputStream</code>.\n+     * Equivalent to {@link java.io.OutputStream#close()}, except any exceptions will be ignored.\n+     * @param output A (possibly null) OutputStream\n+     */\n+    private static void shutdownStream( final OutputStream output )\n+    {\n+        if( null == output )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            output.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+\n+    /**\n+     * Unconditionally close an <code>InputStream</code>.\n+     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.\n+     * @param input A (possibly null) InputStream\n+     */\n+    private static void shutdownStream( final InputStream input )\n+    {\n+        if( null == input )\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            input.close();\n+        }\n+        catch( final IOException ioe )\n+        {\n+        }\n+    }\n+}", "timestamp": 1154343310, "metainfo": ""}