{"sha": "0d0dfb142f721abb473a0324ceede467e195d368", "log": "COMPRESS-271 add structure to keep track of blocks to write", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n \n import java.io.IOException;\n import java.io.OutputStream;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.apache.commons.compress.compressors.CompressorOutputStream;\n import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;\n  * @since 1.14\n  */\n public class BlockLZ4CompressorOutputStream extends CompressorOutputStream {\n+\n+    private static final int MIN_BACK_REFERENCE_LENGTH = 4;\n+    private static final int MIN_LENGTH_OF_LAST_LITERAL = 5;\n+    private static final int MIN_OFFSET_OF_LAST_BACK_REFERENCE = 12;\n \n     /*\n \n \n     private final LZ77Compressor compressor;\n     private final OutputStream os;\n-    private final ByteUtils.ByteConsumer consumer;\n \n     // used in one-arg write method\n     private final byte[] oneByte = new byte[1];\n      */\n     public BlockLZ4CompressorOutputStream(final OutputStream os) throws IOException {\n         this.os = os;\n-        consumer = new ByteUtils.OutputStreamByteConsumer(os);\n         int maxLen = BlockLZ4CompressorInputStream.WINDOW_SIZE - 1;\n-        compressor = new LZ77Compressor(new Parameters(BlockLZ4CompressorInputStream.WINDOW_SIZE, 4, maxLen, maxLen,\n-            maxLen),\n+        compressor = new LZ77Compressor(new Parameters(BlockLZ4CompressorInputStream.WINDOW_SIZE,\n+            MIN_BACK_REFERENCE_LENGTH, maxLen, maxLen, maxLen),\n             new LZ77Compressor.Callback() {\n                 public void accept(LZ77Compressor.Block block) throws IOException {\n                     //System.err.println(block);\n \n     private void writeFinalLiteralBlock() throws IOException {\n     }\n+\n+    final static class Pair {\n+        private final List<byte[]> literals = new LinkedList<>();\n+        private int brOffset, brLength;\n+\n+        void addLiteral(LZ77Compressor.LiteralBlock block) {\n+            literals.add(Arrays.copyOfRange(block.getData(), block.getOffset(),\n+                block.getOffset() + block.getLength()));\n+        }\n+        void setBackReference(LZ77Compressor.BackReference block) {\n+            if (hasBackReference()) {\n+                throw new IllegalStateException();\n+            }\n+            brOffset = block.getOffset();\n+            brLength = block.getLength();\n+        }\n+        boolean hasBackReference() {\n+            return brOffset > 0;\n+        }\n+        boolean canBeWritten(int lengthOfBlocksAfterThisPair) {\n+            return hasBackReference()\n+                && lengthOfBlocksAfterThisPair >= MIN_LENGTH_OF_LAST_LITERAL\n+                && lengthOfBlocksAfterThisPair + brOffset + brLength >= MIN_OFFSET_OF_LAST_BACK_REFERENCE;\n+        }\n+        int length() {\n+            return literalLength() + brLength;\n+        }\n+        void writeTo(OutputStream out) throws IOException {\n+            int litLength = literalLength();\n+            out.write(lengths(litLength, brLength));\n+            if (litLength >= BlockLZ4CompressorInputStream.BACK_REFERENCE_SIZE_MASK) {\n+                writeLength(litLength - BlockLZ4CompressorInputStream.BACK_REFERENCE_SIZE_MASK, out);\n+            }\n+            for (byte[] b : literals) {\n+                out.write(b);\n+            }\n+            if (hasBackReference()) {\n+                ByteUtils.toLittleEndian(out, brOffset, 2);\n+                if (brLength - MIN_BACK_REFERENCE_LENGTH >= BlockLZ4CompressorInputStream.BACK_REFERENCE_SIZE_MASK) {\n+                    writeLength(brLength - MIN_BACK_REFERENCE_LENGTH\n+                        - BlockLZ4CompressorInputStream.BACK_REFERENCE_SIZE_MASK, out);\n+                }\n+            }\n+        }\n+        private int literalLength() {\n+            int length = 0;\n+            for (byte[] b : literals) {\n+                length += b.length;\n+            }\n+            return length;\n+        }\n+        private static int lengths(int litLength, int brLength) {\n+            int l = litLength < 15 ? litLength : 15;\n+            int br = brLength < 4 ? 0 : (brLength < 19 ? brLength - 4 : 15);\n+            return (l << BlockLZ4CompressorInputStream.SIZE_BITS) | br;\n+        }\n+        private static void writeLength(int length, OutputStream out) throws IOException {\n+            while (length >= 255) {\n+                out.write(255);\n+                length -= 255;\n+            }\n+            out.write(length);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n     public static final class LiteralBlock extends Block {\n         private final byte[] data;\n         private final int offset, length;\n-        /* package private for tests */ LiteralBlock(byte[] data, int offset, int length) {\n+        public LiteralBlock(byte[] data, int offset, int length) {\n             this.data = data;\n             this.offset = offset;\n             this.length = length;\n      */\n     public static final class BackReference extends Block {\n         private final int offset, length;\n-        private BackReference(int offset, int length) {\n+        public BackReference(int offset, int length) {\n             this.offset = offset;\n             this.length = length;\n         }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BlockLZ4CompressorOutputStreamTest {\n+\n+    @Test\n+    public void pairSeesbackReferenceWhenSet() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        Assert.assertFalse(p.hasBackReference());\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 4));\n+        Assert.assertTrue(p.hasBackReference());\n+    }\n+\n+    @Test\n+    public void canWriteBackReferenceFollowedByLongLiteral() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 4));\n+        Assert.assertTrue(p.canBeWritten(11));\n+    }\n+\n+    @Test\n+    public void canWriteBackReferenceFollowedByShortLiteralIfOffsetIsBigEnough() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(10, 4));\n+        Assert.assertTrue(p.canBeWritten(5));\n+    }\n+\n+    @Test\n+    public void canWriteBackReferenceFollowedByShortLiteralIfLengthIsBigEnough() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 10));\n+        Assert.assertTrue(p.canBeWritten(5));\n+    }\n+\n+    @Test\n+    public void cantWriteBackReferenceFollowedByLiteralThatIsTooShort() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(10, 14));\n+        Assert.assertFalse(p.canBeWritten(4));\n+    }\n+\n+    @Test\n+    public void cantWriteBackReferenceIfAccumulatedOffsetIsTooShort() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 4));\n+        Assert.assertFalse(p.canBeWritten(5));\n+    }\n+\n+    @Test\n+    public void pairAccumulatesLengths() {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 4));\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 2, 5));\n+        Assert.assertEquals(13, p.length());\n+    }\n+\n+    @Test\n+    public void canWritePairWithoutLiterals() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 4));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { 0, 1, 0 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor19ByteLengthBackReference() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 19));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { 15, 1, 0, 0 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor273ByteLengthBackReference() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 273));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { 15, 1, 0, (byte) 254 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor274ByteLengthBackReference() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 274));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { 15, 1, 0, (byte) 255, 0 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void canWritePairWithoutBackReference() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { 4<<4, 2, 3, 4, 5 }, bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor15ByteLengthLiteral() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 9));\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 6));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { (byte) (15<<4), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6 },\n+            bos.toByteArray());\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor269ByteLengthLiteral() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        for (int i = 0; i < 26; i++) {\n+            p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 10));\n+        }\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 9));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { (byte) (15<<4), (byte) 254, 1 },\n+            Arrays.copyOfRange(bos.toByteArray(), 0, 3));\n+    }\n+\n+    @Test\n+    public void writesCorrectSizeFor270ByteLengthLiteral() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        for (int i = 0; i < 27; i++) {\n+            p.addLiteral(new LZ77Compressor.LiteralBlock(b, 0, 10));\n+        }\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { (byte) (15<<4), (byte) 255, 0, 1 },\n+            Arrays.copyOfRange(bos.toByteArray(), 0, 4));\n+    }\n+\n+    @Test\n+    public void writesCompletePair() throws IOException {\n+        BlockLZ4CompressorOutputStream.Pair p = new BlockLZ4CompressorOutputStream.Pair();\n+        byte[] b = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        p.addLiteral(new LZ77Compressor.LiteralBlock(b, 1, 4));\n+        b[2] = 19;\n+        p.setBackReference(new LZ77Compressor.BackReference(1, 5));\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        p.writeTo(bos);\n+        Assert.assertArrayEquals(new byte[] { (4<<4) + 1, 2, 3, 4, 5, 1, 0 },\n+            bos.toByteArray());\n+    }\n+}", "timestamp": 1484771357, "metainfo": ""}