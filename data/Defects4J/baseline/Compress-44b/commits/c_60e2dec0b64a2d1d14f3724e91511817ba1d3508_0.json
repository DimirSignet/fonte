{"sha": "60e2dec0b64a2d1d14f3724e91511817ba1d3508", "log": "very initial implementation of the extra field that holds Zip64 data.  Many question marks.  We'll likely be forced to change the way we deal with extra fields specifically for this one because of its parsing logic of optional data.  COMPRESS-36  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n+        register(Zip64ExtendedInformationExtraField.class);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.ZipException;\n+\n+/**\n+ * Holds size and other extended information for entries that use Zip64\n+ * features.\n+ *\n+ * <p>From {@link http://www.pkware.com/documents/casestudies/APPNOTE.TXT PKWARE's APPNOTE.TXT}\n+ * <pre>\n+ * Zip64 Extended Information Extra Field (0x0001):\n+ *\n+ *          The following is the layout of the zip64 extended \n+ *          information \"extra\" block. If one of the size or\n+ *          offset fields in the Local or Central directory\n+ *          record is too small to hold the required data,\n+ *          a Zip64 extended information record is created.\n+ *          The order of the fields in the zip64 extended \n+ *          information record is fixed, but the fields will\n+ *          only appear if the corresponding Local or Central\n+ *          directory record field is set to 0xFFFF or 0xFFFFFFFF.\n+ *\n+ *          Note: all fields stored in Intel low-byte/high-byte order.\n+ *\n+ *          Value      Size       Description\n+ *          -----      ----       -----------\n+ *  (ZIP64) 0x0001     2 bytes    Tag for this \"extra\" block type\n+ *          Size       2 bytes    Size of this \"extra\" block\n+ *          Original \n+ *          Size       8 bytes    Original uncompressed file size\n+ *          Compressed\n+ *          Size       8 bytes    Size of compressed data\n+ *          Relative Header\n+ *          Offset     8 bytes    Offset of local header record\n+ *          Disk Start\n+ *          Number     4 bytes    Number of the disk on which\n+ *                                this file starts \n+ *\n+ *          This entry in the Local header must include BOTH original\n+ *          and compressed file size fields. If encrypting the \n+ *          central directory and bit 13 of the general purpose bit\n+ *          flag is set indicating masking, the value stored in the\n+ *          Local Header for the original file size will be zero.\n+ * </pre></p>\n+ *\n+ * <p>Currently Commons Compress doesn't support encrypting the\n+ * central directory so the not about masking doesn't apply.</p>\n+ *\n+ * <p>The implementation relies on data being read from the local file\n+ * header and assumes that both size values are always present.</p>\n+ *\n+ * @since Apache Commons Compress 1.2\n+ * @NotThreadSafe\n+ */\n+public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n+    // TODO: the LFH should probably not contain relativeHeaderOffset\n+    // and diskStart but then ZipArchivePOutputStream won't write it to\n+    // the CD either - need to test interop with other implementations\n+    // to see whether they do have a problem with the extraneous\n+    // information inside the LFH\n+\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0001);\n+\n+    private static final int WORD = 4, DWORD = 8;\n+\n+    private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n+    private ZipLong diskStart;\n+\n+    /**\n+     * This constructor should only be used by the code that reads\n+     * archives inside of Commons Compress.\n+     */\n+    public Zip64ExtendedInformationExtraField() { }\n+\n+    /**\n+     * Creates an extra field based on the original and compressed size.\n+     *\n+     * @param size the entry's original size\n+     * @param compressedSize the entry's compressed size\n+     *\n+     * @throws IllegalArgumentException if size or compressedSize is null\n+     */\n+    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n+                                              ZipEightByteInteger compressedSize) {\n+        this(size, compressedSize, null, null);\n+    }\n+\n+    /**\n+     * Creates an extra field based on all four possible values.\n+     *\n+     * @param size the entry's original size\n+     * @param compressedSize the entry's compressed size\n+     *\n+     * @throws IllegalArgumentException if size or compressedSize is null\n+     */\n+    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n+                                              ZipEightByteInteger compressedSize,\n+                                              ZipEightByteInteger relativeHeaderOffset,\n+                                              ZipLong diskStart) {\n+        if (size == null) {\n+            throw new IllegalArgumentException(\"size must not be null\");\n+        }\n+        if (compressedSize == null) {\n+            throw new IllegalArgumentException(\"compressedSize must not be null\");\n+        }\n+        this.size = size;\n+        this.compressedSize = compressedSize;\n+        this.relativeHeaderOffset = relativeHeaderOffset;\n+        this.diskStart = diskStart;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ZipShort getLocalFileDataLength() {\n+        return getCentralDirectoryLength();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ZipShort getCentralDirectoryLength() {\n+        return new ZipShort(2 * DWORD  // both size fields\n+                            + (relativeHeaderOffset != null ? DWORD : 0)\n+                            + (diskStart != null ? WORD : 0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public byte[] getLocalFileDataData() {\n+        return getCentralDirectoryData();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public byte[] getCentralDirectoryData() {\n+        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n+        addSizes(data);\n+        int off = 2 * DWORD;\n+        if (relativeHeaderOffset != null) {\n+            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n+            off += DWORD;\n+        }\n+        if (diskStart != null) {\n+            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n+            off += WORD;\n+        }\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n+        throws ZipException {\n+        if (length < 2 * DWORD) {\n+            throw new ZipException(\"Zip64 extended information must contain\"\n+                                   + \" both size values in the local file\"\n+                                   + \" header.\");\n+        }\n+        size = new ZipEightByteInteger(buffer, offset);\n+        offset += DWORD;\n+        compressedSize = new ZipEightByteInteger(buffer, offset);\n+        offset += DWORD;\n+        int remaining = length - 2 * DWORD;\n+        if (remaining >= DWORD) {\n+            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n+            offset += DWORD;\n+            remaining -= DWORD;\n+        }\n+        if (remaining >= WORD) {\n+            diskStart = new ZipLong(buffer, offset);\n+            offset += WORD;\n+            remaining -= WORD;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n+                                              int length)\n+        throws ZipException {\n+        // if there is no size information in here, we are screwed and\n+        // can only hope things will get resolved by LFH data later\n+        // But there are some cases that can be detected\n+        // * all data is there\n+        // * length % 8 == 4 -> at least we can identify the diskStart field\n+        if (length >= 3 * DWORD + WORD) {\n+            parseFromLocalFileData(buffer, offset, length);\n+        } else if (length % DWORD == WORD) {\n+            diskStart = new ZipLong(buffer, offset + length - WORD);\n+        }\n+    }\n+\n+    /**\n+     * The uncompressed size stored in this extra field.\n+     */\n+    public ZipEightByteInteger getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * The compressed size stored in this extra field.\n+     */\n+    public ZipEightByteInteger getCompressedSize() {\n+        return compressedSize;\n+    }\n+\n+    /**\n+     * The relative header offset stored in this extra field.\n+     */\n+    public ZipEightByteInteger getRelativeHeaderOffset() {\n+        return relativeHeaderOffset;\n+    }\n+\n+    /**\n+     * The disk start number stored in this extra field.\n+     */\n+    public ZipLong getDiskStartNumber() {\n+        return diskStart;\n+    }\n+\n+    private void addSizes(byte[] data) {\n+        System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n+        System.arraycopy(compressedSize.getBytes(), 0, data, DWORD, DWORD);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n     public int hashCode() {\n         return value.hashCode();\n     }\n+\n+    public String toString() {\n+        return \"ZipEightByteInteger value: \" + value;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n             throw new RuntimeException(cnfe);\n         }\n     }\n+\n+    public String toString() {\n+        return \"ZipLong value: \" + value;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n             throw new RuntimeException(cnfe);\n         }\n     }\n+\n+    public String toString() {\n+        return \"ZipShort value: \" + value;\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.math.BigInteger;\n+import java.util.zip.ZipException;\n+import junit.framework.TestCase;\n+\n+public class Zip64ExtendedInformationExtraFieldTest extends TestCase {\n+    public Zip64ExtendedInformationExtraFieldTest(String name) {\n+        super(name);\n+    }\n+\n+    private static final ZipEightByteInteger SIZE =\n+        new ZipEightByteInteger(0x12345678);\n+    private static final ZipEightByteInteger CSIZE =\n+        new ZipEightByteInteger(0x9ABCDEF);\n+    private static final ZipEightByteInteger OFF =\n+        new ZipEightByteInteger(BigInteger.valueOf(0xABCDEF091234567l)\n+                                .shiftLeft(4)\n+                                .setBit(3));\n+    private static final ZipLong DISK = new ZipLong(0x12);\n+\n+    public void testWriteCDOnlySizes() {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField(SIZE, CSIZE);\n+        assertEquals(new ZipShort(16), f.getCentralDirectoryLength());\n+        byte[] b = f.getCentralDirectoryData();\n+        assertEquals(16, b.length);\n+        checkSizes(b);\n+    }\n+\n+    public void testWriteCDSizeAndOffset() {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, null);\n+        assertEquals(new ZipShort(24), f.getCentralDirectoryLength());\n+        byte[] b = f.getCentralDirectoryData();\n+        assertEquals(24, b.length);\n+        checkSizes(b);\n+        checkOffset(b, 16);\n+    }\n+\n+    public void testWriteCDSizeOffsetAndDisk() {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, DISK);\n+        assertEquals(new ZipShort(28), f.getCentralDirectoryLength());\n+        byte[] b = f.getCentralDirectoryData();\n+        assertEquals(28, b.length);\n+        checkSizes(b);\n+        checkOffset(b, 16);\n+        checkDisk(b, 24);\n+    }\n+\n+    public void testWriteCDSizeAndDisk() {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField(SIZE, CSIZE, null, DISK);\n+        assertEquals(new ZipShort(20), f.getCentralDirectoryLength());\n+        byte[] b = f.getCentralDirectoryData();\n+        assertEquals(20, b.length);\n+        checkSizes(b);\n+        checkDisk(b, 16);\n+    }\n+\n+    public void testReadLFHSizesOnly() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[16];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        f.parseFromLocalFileData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertNull(f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+    }\n+\n+    public void testReadLFHSizesAndOffset() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[24];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n+        f.parseFromLocalFileData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertEquals(OFF, f.getRelativeHeaderOffset());\n+        assertNull(f.getDiskStartNumber());\n+    }\n+\n+    public void testReadLFHSizesOffsetAndDisk() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[28];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n+        System.arraycopy(DISK.getBytes(), 0, b, 24, 4);\n+        f.parseFromLocalFileData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertEquals(OFF, f.getRelativeHeaderOffset());\n+        assertEquals(DISK, f.getDiskStartNumber());\n+    }\n+\n+    public void testReadLFHSizesAndDisk() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[20];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        System.arraycopy(DISK.getBytes(), 0, b, 16, 4);\n+        f.parseFromLocalFileData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertNull(f.getRelativeHeaderOffset());\n+        assertEquals(DISK, f.getDiskStartNumber());\n+    }\n+\n+    public void testReadCDSizesOffsetAndDisk() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[28];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n+        System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n+        System.arraycopy(DISK.getBytes(), 0, b, 24, 4);\n+        f.parseFromCentralDirectoryData(b, 0, b.length);\n+        assertEquals(SIZE, f.getSize());\n+        assertEquals(CSIZE, f.getCompressedSize());\n+        assertEquals(OFF, f.getRelativeHeaderOffset());\n+        assertEquals(DISK, f.getDiskStartNumber());\n+    }\n+\n+    public void testReadCDSomethingAndDisk() throws ZipException {\n+        Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        byte[] b = new byte[12];\n+        System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n+        System.arraycopy(DISK.getBytes(), 0, b, 8, 4);\n+        f.parseFromCentralDirectoryData(b, 0, b.length);\n+        assertNull(f.getSize());\n+        assertNull(f.getCompressedSize());\n+        assertNull(f.getRelativeHeaderOffset());\n+        assertEquals(DISK, f.getDiskStartNumber());\n+    }\n+\n+    private static void checkSizes(byte[] b) {\n+        assertEquals(0x78, b[0]);\n+        assertEquals(0x56, b[1]);\n+        assertEquals(0x34, b[2]);\n+        assertEquals(0x12, b[3]);\n+        assertEquals(0x00, b[4]);\n+        assertEquals(0x00, b[5]);\n+        assertEquals(0x00, b[6]);\n+        assertEquals(0x00, b[7]);\n+        assertEquals((byte) 0xEF, b[8]);\n+        assertEquals((byte) 0xCD, b[9]);\n+        assertEquals((byte) 0xAB, b[10]);\n+        assertEquals(0x09, b[11]);\n+        assertEquals(0x00, b[12]);\n+        assertEquals(0x00, b[13]);\n+        assertEquals(0x00, b[14]);\n+        assertEquals(0x00, b[15]);\n+    }\n+\n+    private static void checkOffset(byte[] b, int off) {\n+        assertEquals(0x78, b[0 + off]);\n+        assertEquals(0x56, b[1 + off]);\n+        assertEquals(0x34, b[2 + off]);\n+        assertEquals(0x12, b[3 + off]);\n+        assertEquals((byte) 0x09, b[4 + off]);\n+        assertEquals((byte) 0xEF, b[5 + off]);\n+        assertEquals((byte) 0xCD, b[6 + off]);\n+        assertEquals((byte) 0xAB, b[7 + off]);\n+    }\n+\n+    private static void checkDisk(byte[] b, int off) {\n+        assertEquals(0x12, b[0 + off]);\n+        assertEquals(0x00, b[1 + off]);\n+        assertEquals(0x00, b[2 + off]);\n+        assertEquals(0x00, b[3 + off]);\n+    }\n+}", "timestamp": 1311250266, "metainfo": ""}