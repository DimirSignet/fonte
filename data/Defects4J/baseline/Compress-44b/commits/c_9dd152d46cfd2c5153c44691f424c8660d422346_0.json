{"sha": "9dd152d46cfd2c5153c44691f424c8660d422346", "log": "whitespace - and rename of local variables in ZAIS.bufferContainsSignature  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n      */\n     private int readStored(byte[] buffer, int start, int length)\n         throws IOException {\n-                if (current.hasDataDescriptor) {\n-                    if (lastStoredEntry == null) {\n-                        readStoredEntry();\n-                    }\n-                    return lastStoredEntry.read(buffer, start, length);\n-                }\n-\n-                long csize = current.entry.getSize();\n-                if (current.bytesRead >= csize) {\n-                    return -1;\n-                }\n-                if (buf.offsetInBuffer >= buf.lengthOfLastRead) {\n-                    buf.offsetInBuffer = 0;\n-                    if ((buf.lengthOfLastRead = in.read(buf.buf)) == -1) {\n-                        return -1;\n-                    }\n-                    count(buf.lengthOfLastRead);\n-                    current.bytesReadFromStream += buf.lengthOfLastRead;\n-                }\n-                int toRead = length > buf.lengthOfLastRead\n-                    ? buf.lengthOfLastRead - buf.offsetInBuffer\n-                    : length;\n-                if ((csize - current.bytesRead) < toRead) {\n-                    // if it is smaller than toRead then it fits into an int\n-                    toRead = (int) (csize - current.bytesRead);\n-                }\n-                System.arraycopy(buf.buf, buf.offsetInBuffer, buffer, start,\n-                                 toRead);\n-                buf.offsetInBuffer += toRead;\n-                current.bytesRead += toRead;\n-                crc.update(buffer, start, toRead);\n-                return toRead;\n+\n+        if (current.hasDataDescriptor) {\n+            if (lastStoredEntry == null) {\n+                readStoredEntry();\n+            }\n+            return lastStoredEntry.read(buffer, start, length);\n+        }\n+\n+        long csize = current.entry.getSize();\n+        if (current.bytesRead >= csize) {\n+            return -1;\n+        }\n+\n+        if (buf.offsetInBuffer >= buf.lengthOfLastRead) {\n+            buf.offsetInBuffer = 0;\n+            if ((buf.lengthOfLastRead = in.read(buf.buf)) == -1) {\n+                return -1;\n+            }\n+            count(buf.lengthOfLastRead);\n+            current.bytesReadFromStream += buf.lengthOfLastRead;\n+        }\n+\n+        int toRead = length > buf.lengthOfLastRead\n+            ? buf.lengthOfLastRead - buf.offsetInBuffer\n+            : length;\n+        if ((csize - current.bytesRead) < toRead) {\n+            // if it is smaller than toRead then it fits into an int\n+            toRead = (int) (csize - current.bytesRead);\n+        }\n+        System.arraycopy(buf.buf, buf.offsetInBuffer, buffer, start, toRead);\n+        buf.offsetInBuffer += toRead;\n+        current.bytesRead += toRead;\n+        crc.update(buffer, start, toRead);\n+        return toRead;\n     }\n \n     /**\n      */\n     private int readDeflated(byte[] buffer, int start, int length)\n         throws IOException {\n-            if (inf.needsInput()) {\n-                fill();\n-                if (buf.lengthOfLastRead > 0) {\n-                    current.bytesReadFromStream += buf.lengthOfLastRead;\n-                }\n-            }\n-            int read = 0;\n-            try {\n-                read = inf.inflate(buffer, start, length);\n-            } catch (DataFormatException e) {\n-                throw new ZipException(e.getMessage());\n-            }\n-            if (read == 0) {\n-                if (inf.finished()) {\n-                    return -1;\n-                } else if (buf.lengthOfLastRead == -1) {\n-                    throw new IOException(\"Truncated ZIP file\");\n-                }\n-            }\n-            crc.update(buffer, start, read);\n-            return read;\n+        if (inf.needsInput()) {\n+            fill();\n+            if (buf.lengthOfLastRead > 0) {\n+                current.bytesReadFromStream += buf.lengthOfLastRead;\n+            }\n+        }\n+        int read = 0;\n+        try {\n+            read = inf.inflate(buffer, start, length);\n+        } catch (DataFormatException e) {\n+            throw new ZipException(e.getMessage());\n+        }\n+        if (read == 0) {\n+            if (inf.finished()) {\n+                return -1;\n+            } else if (buf.lengthOfLastRead == -1) {\n+                throw new IOException(\"Truncated ZIP file\");\n+            }\n+        }\n+        crc.update(buffer, start, read);\n+        return read;\n     }\n \n     @Override\n \n         // Ensure all entry bytes are read\n         if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n-                && !current.hasDataDescriptor) {\n+            && !current.hasDataDescriptor) {\n             drainCurrentEntryData();\n         } else {\n             skip(Long.MAX_VALUE);\n      * that hasn't been read, yet.\n      */\n     private void drainCurrentEntryData() throws IOException {\n-            long remaining = current.entry.getCompressedSize()\n-                - current.bytesReadFromStream;\n-            while (remaining > 0) {\n-                long n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\n-                                                            remaining));\n-                if (n < 0) {\n-                    throw new EOFException(\n-                            \"Truncated ZIP entry: \" + current.entry.getName());\n-                } else {\n-                    count(n);\n-                    remaining -= n;\n-                }\n-            }\n+        long remaining = current.entry.getCompressedSize()\n+            - current.bytesReadFromStream;\n+        while (remaining > 0) {\n+            long n = in.read(buf.buf, 0, (int) Math.min(buf.buf.length,\n+                                                        remaining));\n+            if (n < 0) {\n+                throw new EOFException(\n+                                       \"Truncated ZIP entry: \" + current.entry.getName());\n+            } else {\n+                count(n);\n+                remaining -= n;\n+            }\n+        }\n     }\n \n     /**\n      * and positions the stream right after the data descriptor.</p>\n      */\n     private boolean bufferContainsSignature(ByteArrayOutputStream bos,\n-                                            int off, int r, int ddLen)\n+                                            int offset, int lastRead,\n+                                            int expectedDDLen)\n         throws IOException {\n         boolean done = false;\n-            int readTooMuch = 0;\n-            for (int i = 0; !done && i < r - 4; i++) {\n-                if (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\n-                    if ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n-                        || (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n-                        // found a LFH or CFH:\n-                        readTooMuch = off + r - i - ddLen;\n-                        done = true;\n-                    }\n-                    else if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n-                        // found DD:\n-                        readTooMuch = off + r - i;\n-                        done = true;\n-                    }\n-                    if (done) {\n-                        // * push back bytes read in excess as well as the data\n-                        //   descriptor\n-                        // * copy the remaining bytes to cache\n-                        // * read data descriptor\n-                        pushback(buf.buf, off + r - readTooMuch, readTooMuch);\n-                        bos.write(buf.buf, 0, i);\n-                        readDataDescriptor();\n-                    }\n+        int readTooMuch = 0;\n+        for (int i = 0; !done && i < lastRead - 4; i++) {\n+            if (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\n+                if ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n+                    || (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n+                    // found a LFH or CFH:\n+                    readTooMuch = offset + lastRead - i - expectedDDLen;\n+                    done = true;\n                 }\n-            }\n+                else if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n+                    // found DD:\n+                    readTooMuch = offset + lastRead - i;\n+                    done = true;\n+                }\n+                if (done) {\n+                    // * push back bytes read in excess as well as the data\n+                    //   descriptor\n+                    // * copy the remaining bytes to cache\n+                    // * read data descriptor\n+                    pushback(buf.buf, offset + lastRead - readTooMuch,\n+                             readTooMuch);\n+                    bos.write(buf.buf, 0, i);\n+                    readDataDescriptor();\n+                }\n+            }\n+        }\n         return done;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n      */\n     private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n         throws IOException {\n-            long save = raf.getFilePointer();\n-\n-            raf.seek(entry.localDataStart);\n-            writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n-            if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n-                writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n-                writeOut(ZipLong.getBytes(entry.entry.getSize()));\n-            } else {\n-                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-            }\n-\n-            if (hasZip64Extra(entry.entry)) {\n-                // seek to ZIP64 extra, skip header and size information\n-                raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n-                         + getName(entry.entry).limit() + 2 * SHORT);\n-                // inside the ZIP64 extra uncompressed size comes\n-                // first, unlike the LFH, CD or data descriptor\n-                writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n-                writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n-\n-                if (!actuallyNeedsZip64) {\n-                    // do some cleanup:\n-                    // * rewrite version needed to extract\n-                    raf.seek(entry.localDataStart  - 5 * SHORT);\n-                    writeOut(ZipShort.getBytes(INITIAL_VERSION));\n-\n-                    // * remove ZIP64 extra so it doesn't get written\n-                    //   to the central directory\n-                    entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n-                                                 .HEADER_ID);\n-                    entry.entry.setExtra();\n-\n-                    // * reset hasUsedZip64 if it has been set because\n-                    //   of this entry\n-                    if (entry.causedUseOfZip64) {\n-                        hasUsedZip64 = false;\n-                    }\n+        long save = raf.getFilePointer();\n+\n+        raf.seek(entry.localDataStart);\n+        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n+        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n+            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n+        } else {\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+        }\n+\n+        if (hasZip64Extra(entry.entry)) {\n+            // seek to ZIP64 extra, skip header and size information\n+            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n+                     + getName(entry.entry).limit() + 2 * SHORT);\n+            // inside the ZIP64 extra uncompressed size comes\n+            // first, unlike the LFH, CD or data descriptor\n+            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n+            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n+\n+            if (!actuallyNeedsZip64) {\n+                // do some cleanup:\n+                // * rewrite version needed to extract\n+                raf.seek(entry.localDataStart  - 5 * SHORT);\n+                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n+\n+                // * remove ZIP64 extra so it doesn't get written\n+                //   to the central directory\n+                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n+                                             .HEADER_ID);\n+                entry.entry.setExtra();\n+\n+                // * reset hasUsedZip64 if it has been set because\n+                //   of this entry\n+                if (entry.causedUseOfZip64) {\n+                    hasUsedZip64 = false;\n                 }\n             }\n-            raf.seek(save);\n+        }\n+        raf.seek(save);\n     }\n \n     /**\n                 // actually, we already know the sizes\n                 size = new ZipEightByteInteger(entry.entry.getSize());\n             }\n-                z64.setSize(size);\n-                z64.setCompressedSize(size);\n+            z64.setSize(size);\n+            z64.setCompressedSize(size);\n             entry.entry.setExtra();\n         }\n \n      */\n     private void writeDeflated(byte[]b, int offset, int length)\n         throws IOException {\n-            if (length > 0 && !def.finished()) {\n-                entry.bytesRead += length;\n-                if (length <= DEFLATER_BLOCK_SIZE) {\n-                    def.setInput(b, offset, length);\n+        if (length > 0 && !def.finished()) {\n+            entry.bytesRead += length;\n+            if (length <= DEFLATER_BLOCK_SIZE) {\n+                def.setInput(b, offset, length);\n+                deflateUntilInputIsNeeded();\n+            } else {\n+                final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n+                for (int i = 0; i < fullblocks; i++) {\n+                    def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n+                                 DEFLATER_BLOCK_SIZE);\n                     deflateUntilInputIsNeeded();\n-                } else {\n-                    final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n-                    for (int i = 0; i < fullblocks; i++) {\n-                        def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n-                                     DEFLATER_BLOCK_SIZE);\n-                        deflateUntilInputIsNeeded();\n-                    }\n-                    final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n-                    if (done < length) {\n-                        def.setInput(b, offset + done, length - done);\n-                        deflateUntilInputIsNeeded();\n-                    }\n+                }\n+                final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n+                if (done < length) {\n+                    def.setInput(b, offset + done, length - done);\n+                    deflateUntilInputIsNeeded();\n                 }\n             }\n+        }\n     }\n \n     /**\n     private void addUnicodeExtraFields(ZipArchiveEntry ze, boolean encodable,\n                                        ByteBuffer name)\n         throws IOException {\n+        if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n+            || !encodable) {\n+            ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n+                                                       name.array(),\n+                                                       name.arrayOffset(),\n+                                                       name.limit()));\n+        }\n+\n+        String comm = ze.getComment();\n+        if (comm != null && !\"\".equals(comm)) {\n+\n+            boolean commentEncodable = zipEncoding.canEncode(comm);\n+\n             if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n-                || !encodable) {\n-                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n-                                                           name.array(),\n-                                                           name.arrayOffset(),\n-                                                           name.limit()));\n+                || !commentEncodable) {\n+                ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n+                ze.addExtraField(new UnicodeCommentExtraField(comm,\n+                                                              commentB.array(),\n+                                                              commentB.arrayOffset(),\n+                                                              commentB.limit())\n+                                 );\n             }\n-\n-            String comm = ze.getComment();\n-            if (comm != null && !\"\".equals(comm)) {\n-\n-                boolean commentEncodable = zipEncoding.canEncode(comm);\n-\n-                if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n-                    || !commentEncodable) {\n-                    ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n-                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n-                                                                  commentB.array(),\n-                                                                  commentB.arrayOffset(),\n-                                                                  commentB.limit())\n-                                     );\n-                }\n-            }\n+        }\n     }\n \n     /**\n      */\n     @Override\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n-            throws IOException {\n+        throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n                              .HEADER_ID);\n         if (z64 == null) {\n             /*\n-            System.err.println(\"Adding z64 for \" + ze.getName()\n-                               + \", method: \" + ze.getMethod()\n-                               + \" (\" + (ze.getMethod() == STORED) + \")\"\n-                               + \", raf: \" + (raf != null));\n+              System.err.println(\"Adding z64 for \" + ze.getName()\n+              + \", method: \" + ze.getMethod()\n+              + \" (\" + (ze.getMethod() == STORED) + \")\"\n+              + \", raf: \" + (raf != null));\n             */\n             z64 = new Zip64ExtendedInformationExtraField();\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n  * have to reimplement all methods anyway.  Like\n  * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n- * covers and supports compressed and uncompressed entries.  It also\n- * transparently supports Zip64 extensions and thus individual entries\n- * and archives larger than 4 GB or with more than 65536 entries.</p>\n+ * covers and supports compressed and uncompressed entries.  As of\n+ * Apache Commons Compress it also transparently supports Zip64\n+ * extensions and thus individual entries and archives larger than 4\n+ * GB or with more than 65536 entries.</p>\n  *\n  * <p>The method signatures mimic the ones of\n  * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n      * added to this map.\n      */\n     private void\n-        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException {\n+        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n+        throws IOException {\n         byte[] cfh = new byte[CFH_LEN];\n \n-            archive.readFully(cfh);\n-            int off = 0;\n-            ZipArchiveEntry ze = new ZipArchiveEntry();\n-\n-            int versionMadeBy = ZipShort.getValue(cfh, off);\n-            off += SHORT;\n-            ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n-\n-            off += SHORT; // skip version info\n-\n-            final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n-            final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n-            final ZipEncoding entryEncoding =\n-                hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-            ze.setGeneralPurposeBit(gpFlag);\n-\n-            off += SHORT;\n-\n-            ze.setMethod(ZipShort.getValue(cfh, off));\n-            off += SHORT;\n-\n-            long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n-            ze.setTime(time);\n-            off += WORD;\n-\n-            ze.setCrc(ZipLong.getValue(cfh, off));\n-            off += WORD;\n-\n-            ze.setCompressedSize(ZipLong.getValue(cfh, off));\n-            off += WORD;\n-\n-            ze.setSize(ZipLong.getValue(cfh, off));\n-            off += WORD;\n-\n-            int fileNameLen = ZipShort.getValue(cfh, off);\n-            off += SHORT;\n-\n-            int extraLen = ZipShort.getValue(cfh, off);\n-            off += SHORT;\n-\n-            int commentLen = ZipShort.getValue(cfh, off);\n-            off += SHORT;\n-\n-            int diskStart = ZipShort.getValue(cfh, off);\n-            off += SHORT;\n-\n-            ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n-            off += SHORT;\n-\n-            ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n-            off += WORD;\n-\n-            byte[] fileName = new byte[fileNameLen];\n-            archive.readFully(fileName);\n-            ze.setName(entryEncoding.decode(fileName), fileName);\n-\n-            // LFH offset,\n-            OffsetEntry offset = new OffsetEntry();\n-            offset.headerOffset = ZipLong.getValue(cfh, off);\n-            // data offset will be filled later\n-            entries.put(ze, offset);\n-\n-            nameMap.put(ze.getName(), ze);\n-\n-            byte[] cdExtraData = new byte[extraLen];\n-            archive.readFully(cdExtraData);\n-            ze.setCentralDirectoryExtra(cdExtraData);\n-\n-            setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n-\n-            byte[] comment = new byte[commentLen];\n-            archive.readFully(comment);\n-            ze.setComment(entryEncoding.decode(comment));\n-\n-            if (!hasUTF8Flag && useUnicodeExtraFields) {\n-                noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n-            }\n+        archive.readFully(cfh);\n+        int off = 0;\n+        ZipArchiveEntry ze = new ZipArchiveEntry();\n+\n+        int versionMadeBy = ZipShort.getValue(cfh, off);\n+        off += SHORT;\n+        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n+\n+        off += SHORT; // skip version info\n+\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n+        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n+        final ZipEncoding entryEncoding =\n+            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+        ze.setGeneralPurposeBit(gpFlag);\n+\n+        off += SHORT;\n+\n+        ze.setMethod(ZipShort.getValue(cfh, off));\n+        off += SHORT;\n+\n+        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n+        ze.setTime(time);\n+        off += WORD;\n+\n+        ze.setCrc(ZipLong.getValue(cfh, off));\n+        off += WORD;\n+\n+        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n+        off += WORD;\n+\n+        ze.setSize(ZipLong.getValue(cfh, off));\n+        off += WORD;\n+\n+        int fileNameLen = ZipShort.getValue(cfh, off);\n+        off += SHORT;\n+\n+        int extraLen = ZipShort.getValue(cfh, off);\n+        off += SHORT;\n+\n+        int commentLen = ZipShort.getValue(cfh, off);\n+        off += SHORT;\n+\n+        int diskStart = ZipShort.getValue(cfh, off);\n+        off += SHORT;\n+\n+        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n+        off += SHORT;\n+\n+        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n+        off += WORD;\n+\n+        byte[] fileName = new byte[fileNameLen];\n+        archive.readFully(fileName);\n+        ze.setName(entryEncoding.decode(fileName), fileName);\n+\n+        // LFH offset,\n+        OffsetEntry offset = new OffsetEntry();\n+        offset.headerOffset = ZipLong.getValue(cfh, off);\n+        // data offset will be filled later\n+        entries.put(ze, offset);\n+\n+        nameMap.put(ze.getName(), ze);\n+\n+        byte[] cdExtraData = new byte[extraLen];\n+        archive.readFully(cdExtraData);\n+        ze.setCentralDirectoryExtra(cdExtraData);\n+\n+        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n+\n+        byte[] comment = new byte[commentLen];\n+        archive.readFully(comment);\n+        ze.setComment(entryEncoding.decode(comment));\n+\n+        if (!hasUTF8Flag && useUnicodeExtraFields) {\n+            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n+        }\n     }\n \n     /**\n                                                  OffsetEntry offset,\n                                                  int diskStart)\n         throws IOException {\n-            Zip64ExtendedInformationExtraField z64 =\n-                (Zip64ExtendedInformationExtraField)\n-                ze.getExtraField(Zip64ExtendedInformationExtraField\n-                                 .HEADER_ID);\n-            if (z64 != null) {\n-                boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n-                boolean hasCompressedSize =\n-                    ze.getCompressedSize() == ZIP64_MAGIC;\n-                boolean hasRelativeHeaderOffset = \n-                    offset.headerOffset == ZIP64_MAGIC;\n-                z64.reparseCentralDirectoryData(hasUncompressedSize,\n-                                                hasCompressedSize,\n-                                                hasRelativeHeaderOffset,\n-                                                diskStart == ZIP64_MAGIC_SHORT);\n-\n-                if (hasUncompressedSize) {\n-                    ze.setSize(z64.getSize().getLongValue());\n-                } else if (hasCompressedSize) {\n-                    z64.setSize(new ZipEightByteInteger(ze.getSize()));\n-                }\n-\n-                if (hasCompressedSize) {\n-                    ze.setCompressedSize(z64.getCompressedSize()\n-                                         .getLongValue());\n-                } else if (hasUncompressedSize) {\n-                    z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n-                }\n-\n-                if (hasRelativeHeaderOffset) {\n-                    offset.headerOffset =\n-                        z64.getRelativeHeaderOffset().getLongValue();\n-                }\n-            }\n+        Zip64ExtendedInformationExtraField z64 =\n+            (Zip64ExtendedInformationExtraField)\n+            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        if (z64 != null) {\n+            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n+            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n+            boolean hasRelativeHeaderOffset =\n+                offset.headerOffset == ZIP64_MAGIC;\n+            z64.reparseCentralDirectoryData(hasUncompressedSize,\n+                                            hasCompressedSize,\n+                                            hasRelativeHeaderOffset,\n+                                            diskStart == ZIP64_MAGIC_SHORT);\n+\n+            if (hasUncompressedSize) {\n+                ze.setSize(z64.getSize().getLongValue());\n+            } else if (hasCompressedSize) {\n+                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            }\n+\n+            if (hasCompressedSize) {\n+                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n+            } else if (hasUncompressedSize) {\n+                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+            }\n+\n+            if (hasRelativeHeaderOffset) {\n+                offset.headerOffset =\n+                    z64.getRelativeHeaderOffset().getLongValue();\n+            }\n+        }\n     }\n \n     /**\n      */\n     private void positionAtCentralDirectory64()\n         throws IOException {\n-            archive.skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n-            byte[] zip64EocdOffset = new byte[DWORD];\n-            archive.readFully(zip64EocdOffset);\n-            archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n-            byte[] sig = new byte[WORD];\n-            archive.readFully(sig);\n-            if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n-                || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n-                || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n-                || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n-                ) {\n-                throw new ZipException(\"archive's ZIP64 end of central \"\n-                                       + \"directory locator is corrupt.\");\n-            }\n-            archive.skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n-                              - WORD /* signature has already been read */);\n-            byte[] cfdOffset = new byte[DWORD];\n-            archive.readFully(cfdOffset);\n-            archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n+        archive.skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n+        byte[] zip64EocdOffset = new byte[DWORD];\n+        archive.readFully(zip64EocdOffset);\n+        archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n+        byte[] sig = new byte[WORD];\n+        archive.readFully(sig);\n+        if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n+            || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n+            || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n+            || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n+            ) {\n+            throw new ZipException(\"archive's ZIP64 end of central \"\n+                                   + \"directory locator is corrupt.\");\n+        }\n+        archive.skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n+                          - WORD /* signature has already been read */);\n+        byte[] cfdOffset = new byte[DWORD];\n+        archive.readFully(cfdOffset);\n+        archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n     }\n \n     /**\n      */\n     private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n         new Comparator<ZipArchiveEntry>() {\n-            public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n-                if (e1 == e2)\n-                    return 0;\n-\n-                OffsetEntry off1 = entries.get(e1);\n-                OffsetEntry off2 = entries.get(e2);\n-                if (off1 == null) {\n-                    return 1;\n-                }\n-                if (off2 == null) {\n-                    return -1;\n-                }\n-                long val = (off1.headerOffset - off2.headerOffset);\n-                return val == 0 ? 0 : val < 0 ? -1 : +1;\n-            }\n-        };\n+        public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n+            if (e1 == e2)\n+                return 0;\n+\n+            OffsetEntry off1 = entries.get(e1);\n+            OffsetEntry off2 = entries.get(e2);\n+            if (off1 == null) {\n+                return 1;\n+            }\n+            if (off2 == null) {\n+                return -1;\n+            }\n+            long val = (off1.headerOffset - off2.headerOffset);\n+            return val == 0 ? 0 : val < 0 ? -1 : +1;\n+        }\n+    };\n }", "timestamp": 1313072557, "metainfo": ""}