{"sha": "1053ec1d658f6c584d6043c325da1b17ec2cba8c", "log": "expand BitInputStream to allow reading of up to 63 bits at once  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n      * @return The next bit (0 or 1) or -1 if the end of the stream has been reached\n      */\n     int nextBit() throws IOException {\n-        return readBits(1);\n+        return (int) readBits(1);\n     }\n \n     /**\n      * @param n the number of bits read (up to 8)\n      * @return The value formed by the n bits, or -1 if the end of the stream has been reached\n      */\n-    int nextBits(final int n) throws IOException {\n+    long nextBits(final int n) throws IOException {\n         return readBits(n);\n     }\n \n     int nextByte() throws IOException {\n-        return readBits(8);\n+        return (int) readBits(8);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n             if (literalTree != null) {\n                 literal = literalTree.read(bits);\n             } else {\n-                literal = bits.nextBits(8);\n+                literal = bits.nextByte();\n             }\n \n             if (literal == -1) {\n         } else if (bit == 0) {\n             // back reference\n             int distanceLowSize = dictionarySize == 4096 ? 6 : 7;\n-            int distanceLow = bits.nextBits(distanceLowSize);\n+            int distanceLow = (int) bits.nextBits(distanceLowSize);\n             int distanceHigh = distanceTree.read(bits);\n             if (distanceHigh == -1 && distanceLow <= 0) {\n                 // end of stream reached, nothing left to decode\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n      * Reads the next code from the stream.\n      */\n     protected int readNextCode() throws IOException {\n-        return in.readBits(codeSize);\n+        if (codeSize > 31) {\n+            throw new IllegalArgumentException(\"code size must not be bigger than 31\");\n+        }\n+        return (int) in.readBits(codeSize);\n     }\n     \n     /**\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n     \n     public ZCompressorInputStream(InputStream inputStream) throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n-        int firstByte = in.readBits(8);\n-        int secondByte = in.readBits(8);\n-        int thirdByte = in.readBits(8);\n+        int firstByte = (int) in.readBits(8);\n+        int secondByte = (int) in.readBits(8);\n+        int thirdByte = (int) in.readBits(8);\n         if (firstByte != MAGIC_1 || secondByte != MAGIC_2 || thirdByte < 0) {\n             throw new IOException(\"Input is not in .Z format\");\n         }\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n  * @NotThreadSafe\n  */\n public class BitInputStream implements Closeable {\n-    private static final int MAXIMUM_CACHE_SIZE = 31; // bits in int minus sign bit\n-    private static final int[] MASKS = new int[MAXIMUM_CACHE_SIZE + 1];\n+    private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\n+    private static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n \n     static {\n         for (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\n \n     private final InputStream in;\n     private final ByteOrder byteOrder;\n-    private int bitsCached = 0;\n+    private long bitsCached = 0;\n     private int bitsCachedSize = 0;\n \n     /**\n     }\n     \n     /**\n-     * Returns at most 31 bits read from the underlying stream.\n+     * Returns at most 63 bits read from the underlying stream.\n      *\n      * @param count the number of bits to read, must be a positive\n-     * number not bigger than 31.\n-     * @return the bits concatenated as an integer using the stream's byte order.\n+     * number not bigger than 63.\n+     * @return the bits concatenated as a long using the stream's byte order.\n      *         -1 if the end of the underlying stream has been reached before reading\n      *         the requested number of bits\n      */\n-    public int readBits(final int count) throws IOException {\n+    public long readBits(final int count) throws IOException {\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n         }\n         while (bitsCachedSize < count) {\n-            final int nextByte = in.read();\n+            final long nextByte = in.read();\n             if (nextByte < 0) {\n                 return nextByte;\n             }\n             bitsCachedSize += 8;\n         }\n         \n-        final int bitsOut;\n+        final long bitsOut;\n         if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n             bitsOut = (bitsCached & MASKS[count]);\n             bitsCached >>>= count;\n--- a/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void shouldNotAllowReadingOfMoreThan31BitsAtATime() throws IOException {\n+    public void shouldNotAllowReadingOfMoreThan63BitsAtATime() throws IOException {\n         BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n-        bis.readBits(32);\n+        bis.readBits(64);\n     }\n \n     @Test", "timestamp": 1422180053, "metainfo": ""}