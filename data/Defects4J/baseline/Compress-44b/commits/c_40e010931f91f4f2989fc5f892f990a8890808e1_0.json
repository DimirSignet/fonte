{"sha": "40e010931f91f4f2989fc5f892f990a8890808e1", "log": "COMPRESS-60: extracted ChangeSetPerformer class for more thread safety.   ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n  */\n package org.apache.commons.compress.changes;\n \n-import java.io.IOException;\n import java.io.InputStream;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Set;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.ArchiveInputStream;\n-import org.apache.commons.compress.archivers.ArchiveOutputStream;\n-import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * ChangeSet collects and performs changes to an archive.\n \n     /**\n      * Deletes the file with the filename from the archive. \n-     * This method is not thread safe.\n      * \n+     * @NotThreadSafe\n      * @param pFilename\n      *            the filename of the file to delete\n      */\n     }\n \n     /**\n-     * Performs all changes collected in this ChangeSet on the input stream and\n-     * streams the result to the output stream. Since this method works on a copy\n-     * of the actual ChangSet, perform may be called more than once.\n+     * Adds an delete change.\n      * \n-     * @param in\n-     *            the InputStream to perform the changes on\n-     * @param out\n-     *            the resulting OutputStream with all modifications\n-     * @throws IOException\n-     *             if an read/write error occurs\n-     */\n-    public void perform(ArchiveInputStream in, ArchiveOutputStream out)\n-            throws IOException {\n-        Set workingSet = new LinkedHashSet(changes);\n-        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n-            Change change = (Change) it.next();\n-\n-            if (change.type() == Change.TYPE_ADD) {\n-                copyStream(change.getInput(), out, change.getEntry());\n-                it.remove();\n-            }\n-        }\n-\n-        ArchiveEntry entry = null;\n-        while ((entry = in.getNextEntry()) != null) {\n-            boolean copy = true;\n-\n-            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n-                Change change = (Change) it.next();\n-\n-                if (change.type() == Change.TYPE_DELETE\n-                        && entry.getName() != null) {\n-                    if (entry.getName().equals(change.targetFile())) {\n-                        copy = false;\n-                        it.remove();\n-                        break;\n-                    } else if (entry.getName().matches(\n-                            change.targetFile() + \"/.*\")) {\n-                        copy = false;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            if (copy) {\n-                if (!isDeletedLater(workingSet, entry)) {\n-                    copyStream(in, out, entry);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Adds an delete change. This method is not thread safe.\n-     * \n+     * @NotThreadSafe\n      * @param pChange\n      *            the change which should result in a deletion\n      */\n     }\n \n     /**\n-     * Checks if an ArchiveEntry is deleted later in the ChangeSet. This is\n-     * necessary if an file is added with this ChangeSet, but later became\n-     * deleted in the same set.\n-     * \n-     * @param entry\n-     *            the entry to check\n-     * @return true, if this entry has an deletion change later, false otherwise\n+     * Returns the list of changes as a copy. Changes on this set\n+     * are not reflected on this ChangeSet and vice versa.\n+     * @return the changes as a copy\n      */\n-    private boolean isDeletedLater(Set workingSet, ArchiveEntry entry) {\n-        String source = entry.getName();\n-\n-        if (!workingSet.isEmpty()) {\n-            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n-                Change change = (Change) it.next();\n-                if (change.type() == Change.TYPE_DELETE) {\n-                    String target = change.targetFile();\n-\n-                    if (source.equals(target)) {\n-                        return true;\n-                    }\n-\n-                    return source.matches(target + \"/.*\");\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Copies the ArchiveEntry to the Output stream\n-     * \n-     * @param in\n-     *            the stream to read the data from\n-     * @param out\n-     *            the stream to write the data to\n-     * @param entry\n-     *            the entry to write\n-     * @throws IOException\n-     *             if data cannot be read or written\n-     */\n-    private static void copyStream(InputStream in, ArchiveOutputStream out,\n-            ArchiveEntry entry) throws IOException {\n-        out.putArchiveEntry(entry);\n-        IOUtils.copy(in, out);\n-        out.closeArchiveEntry();\n+    Set getChanges() {\n+        return new LinkedHashSet(changes);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.changes;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+/**\n+ * Performs ChangeSet operations on a stream.\n+ * This class is thread safe and can be used multiple times.\n+ * It operates on a copy of the ChangeSet. If the ChangeSet changes,\n+ * a new Performer must be created.\n+ * \n+ * @Threadsafe\n+ * @Immutable\n+ */\n+public class ChangeSetPerformer {\n+    private Set changes = null;\n+    \n+    /**\n+     * Constructs a ChangeSetPerformer with the changes from this ChangeSet\n+     * @param changeSet the ChangeSet which operations are used for performing\n+     */\n+    public ChangeSetPerformer(final ChangeSet changeSet) {\n+        changes = changeSet.getChanges();\n+    }\n+    \n+    /**\n+     * Performs all changes collected in this ChangeSet on the input stream and\n+     * streams the result to the output stream. Perform may be called more than once.\n+     * \n+     * @param in\n+     *            the InputStream to perform the changes on\n+     * @param out\n+     *            the resulting OutputStream with all modifications\n+     * @throws IOException\n+     *             if an read/write error occurs\n+     */\n+    public void perform(ArchiveInputStream in, ArchiveOutputStream out)\n+            throws IOException {\n+        Set workingSet = new LinkedHashSet(changes);\n+        \n+        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n+            Change change = (Change) it.next();\n+\n+            if (change.type() == Change.TYPE_ADD) {\n+                copyStream(change.getInput(), out, change.getEntry());\n+                it.remove();\n+            }\n+        }\n+\n+        ArchiveEntry entry = null;\n+        while ((entry = in.getNextEntry()) != null) {\n+            boolean copy = true;\n+\n+            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n+                Change change = (Change) it.next();\n+\n+                if (change.type() == Change.TYPE_DELETE\n+                        && entry.getName() != null) {\n+                    if (entry.getName().equals(change.targetFile())) {\n+                        copy = false;\n+                        it.remove();\n+                        break;\n+                    } else if (entry.getName().matches(\n+                            change.targetFile() + \"/.*\")) {\n+                        copy = false;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (copy) {\n+                if (!isDeletedLater(workingSet, entry)) {\n+                    copyStream(in, out, entry);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks if an ArchiveEntry is deleted later in the ChangeSet. This is\n+     * necessary if an file is added with this ChangeSet, but later became\n+     * deleted in the same set.\n+     * \n+     * @param entry\n+     *            the entry to check\n+     * @return true, if this entry has an deletion change later, false otherwise\n+     */\n+    private boolean isDeletedLater(Set workingSet, ArchiveEntry entry) {\n+        String source = entry.getName();\n+\n+        if (!workingSet.isEmpty()) {\n+            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n+                Change change = (Change) it.next();\n+                if (change.type() == Change.TYPE_DELETE) {\n+                    String target = change.targetFile();\n+\n+                    if (source.equals(target)) {\n+                        return true;\n+                    }\n+\n+                    return source.matches(target + \"/.*\");\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Copies the ArchiveEntry to the Output stream\n+     * \n+     * @param in\n+     *            the stream to read the data from\n+     * @param out\n+     *            the stream to write the data to\n+     * @param entry\n+     *            the entry to write\n+     * @throws IOException\n+     *             if data cannot be read or written\n+     */\n+    private void copyStream(InputStream in, ArchiveOutputStream out,\n+            ArchiveEntry entry) throws IOException {\n+        out.putArchiveEntry(entry);\n+        IOUtils.copy(in, out);\n+        out.closeArchiveEntry();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n             ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla\");\n             archiveListDelete(\"bla\");\n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla/test5.xml\");\n             archiveListDelete(\"bla/test5.xml\");\n-            changes.perform(ais, out);\n+            \n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             changes.delete(\"testdata/test1.xml\");\n             archiveListDelete(\"testdata/test1.xml\");\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             changes.delete(\"blub\");\n             archiveListDelete(\"blub\");\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n             is.close();\n \n         } finally {\n             changes.delete(\"bla\");\n             archiveListDelete(\"bla\");\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n             is.close();\n \n         } finally {\n             out = factory.createArchiveOutputStream(\"zip\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"tar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"jar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"tar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"jar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"ar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             out = factory.createArchiveOutputStream(\"ar\",\n                     new FileOutputStream(temp));\n \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+            \n         } finally {\n             if (out != null)\n                 out.close();\n             ArchiveEntry entry = new ZipArchiveEntry(\"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             changes.add(entry, new FileInputStream(file));\n             archiveList.add(\"bla/test.txt\");\n             \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {\n             changes.delete(\"test1.xml\");\n             archiveListDelete(\"test1.xml\");\n             \n-            changes.perform(ais, out);\n+            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n             is.close();\n \n         } finally {", "timestamp": 1239275732, "metainfo": ""}