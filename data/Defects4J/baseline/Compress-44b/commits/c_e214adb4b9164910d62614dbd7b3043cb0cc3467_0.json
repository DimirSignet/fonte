{"sha": "e214adb4b9164910d62614dbd7b3043cb0cc3467", "log": "COMPRESS-296 Parallel compression. Added StreamCompressor and ScatterZipOutputStream.  StreamCompressor is an extract of the deflation algorithm from ZipArchiveOutputStream, which unfortunately was too conflated with writing a file in a particular structure. Using the actual zip file format as an intermediate format for scatter-streams turned out to be fairly inefficient. ScatterZipOuputStream is 2-3x faster than using a zip file as intermediate format.  It would be possibly to refactor ZipArchiveOutputStream to use StreamCompressor, but there would be a slight break in backward compatibility regarding the protected writeOut method, which is moved to the streamCompressor class.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+\n+import org.apache.commons.compress.utils.BoundedInputStream;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.zip.Deflater;\n+\n+/**\n+ * A zip output stream that is optimized for multi-threaded scatter/gather construction of zip files.\n+ * <p/>\n+ * The internal data format of the entries used by this class are entirely private to this class\n+ * and are not part of any public api whatsoever.\n+ * <p/>\n+ * It is possible to extend this class to support different kinds of backing storage, the default\n+ * implementation only supports file-based backing.\n+ * <p/>\n+ * Thread safety: This class supports multiple threads. But the \"writeTo\" method must be called\n+ * by the thread that originally created the ZipArchiveEntry.\n+ *\n+ * @since 1.10\n+ */\n+public abstract class ScatterZipOutputStream  {\n+    private final Queue<CompressedEntry> items = new ConcurrentLinkedQueue<CompressedEntry>();\n+\n+    private static class CompressedEntry {\n+        final ZipArchiveEntry entry;\n+        final long crc;\n+        final long compressedSize;\n+        final int method;\n+        final long size;\n+\n+        public CompressedEntry(ZipArchiveEntry entry, long crc, long compressedSize, int method, long size) {\n+            this.entry = entry;\n+            this.crc = crc;\n+            this.compressedSize = compressedSize;\n+            this.method = method;\n+            this.size = size;\n+        }\n+\n+        public ZipArchiveEntry transferToArchiveEntry(){\n+            entry.setCompressedSize(compressedSize);\n+            entry.setSize(size);\n+            entry.setCrc(crc);\n+            entry.setMethod(method);\n+            return entry;\n+        }\n+    }\n+\n+    /**\n+     * Add an archive entry to this scatter stream.\n+     *\n+     * @param zipArchiveEntry The entry to write\n+     * @param payload         The content to write for the entry\n+     * @param method          The compression method\n+     * @throws IOException    If writing fails\n+     */\n+    public void addArchiveEntry(ZipArchiveEntry zipArchiveEntry, InputStream payload, int method) throws IOException {\n+        StreamCompressor sc = getStreamCompressor();\n+        sc.deflate(payload, method);\n+        payload.close();\n+        items.add(new CompressedEntry(zipArchiveEntry, sc.getCrc32(), sc.getBytesWritten(), method, sc.getBytesRead()));\n+    }\n+\n+    /**\n+     * Write the contents of this scatter stream to a target archive.\n+     *\n+     * @param target The archive to receive the contents of this #ScatterZipOutputStream\n+     * @throws IOException If writing fails\n+     */\n+    public void writeTo(ZipArchiveOutputStream target) throws IOException {\n+        closeBackingStorage();\n+        InputStream data = getInputStream();\n+        for (CompressedEntry compressedEntry : items) {\n+            final BoundedInputStream rawStream = new BoundedInputStream(data, compressedEntry.compressedSize);\n+            target.addRawArchiveEntry(compressedEntry.transferToArchiveEntry(), rawStream);\n+            rawStream.close();\n+        }\n+        data.close();\n+    }\n+\n+    /**\n+     * Returns a stream compressor that can be used to compress the data.\n+     * <p/>\n+     * This method is expected to return the same instance every time.\n+     *\n+     * @return The stream compressor\n+     * @throws FileNotFoundException\n+     */\n+    protected abstract StreamCompressor getStreamCompressor() throws FileNotFoundException;\n+\n+    /**\n+     * An input stream that contains the scattered payload\n+     *\n+     * @return An InputStream, should be closed by the caller of this method.\n+     * @throws IOException when something fails\n+     */\n+    protected abstract InputStream getInputStream() throws IOException;\n+\n+\n+    /**\n+     * Closes whatever storage is backing this scatter stream\n+     */\n+    protected abstract void closeBackingStorage() throws IOException;\n+\n+    /**\n+     * Create a ScatterZipOutputStream with default compression level that is backed by a file\n+     *\n+     * @param file The file to offload compressed data into.\n+     * @return A  ScatterZipOutputStream that is ready for use.\n+     * @throws FileNotFoundException\n+     */\n+    public static ScatterZipOutputStream fileBased(File file) throws FileNotFoundException {\n+        return fileBased(file, Deflater.DEFAULT_COMPRESSION);\n+    }\n+\n+    /**\n+     * Create a ScatterZipOutputStream that is backed by a file\n+     *\n+     * @param file             The file to offload compressed data into.\n+     * @param compressionLevel The compression level to use, @see #Deflater\n+     * @return A  ScatterZipOutputStream that is ready for use.\n+     * @throws FileNotFoundException\n+     */\n+    public static ScatterZipOutputStream fileBased(File file, int compressionLevel) throws FileNotFoundException {\n+        return new FileScatterOutputStream(file, compressionLevel);\n+    }\n+\n+    private static class FileScatterOutputStream extends ScatterZipOutputStream {\n+        final File target;\n+        private StreamCompressor streamDeflater;\n+        final FileOutputStream os;\n+\n+        FileScatterOutputStream(File target, int compressionLevel) throws FileNotFoundException {\n+            this.target = target;\n+            os = new FileOutputStream(target);\n+            streamDeflater = StreamCompressor.create(compressionLevel, os);\n+        }\n+\n+        @Override\n+        protected StreamCompressor getStreamCompressor() throws FileNotFoundException {\n+            return streamDeflater;\n+        }\n+\n+        @Override\n+        protected InputStream getInputStream() throws IOException {\n+            return new FileInputStream(target);\n+        }\n+\n+        @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n+        public void closeBackingStorage() throws IOException {\n+            os.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+\n+/**\n+ * Encapsulates a Deflater and crc calculator, handling multiple types of output streams.\n+ * Currently #ZipEntry.DEFLATED and #ZipEntry.STORED are the only supported compression methods.\n+ *\n+ * @since 1.10\n+ */\n+public abstract class StreamCompressor {\n+\n+    /*\n+     * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n+     * when it gets handed a really big buffer.  See\n+     * https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n+     *\n+     * Using a buffer size of 8 kB proved to be a good compromise\n+     */\n+    private static final int DEFLATER_BLOCK_SIZE = 8192;\n+\n+    private final Deflater def;\n+\n+    private final CRC32 crc = new CRC32();\n+\n+    int writtenToOutputStream = 0;\n+    int sourcePayloadLength = 0;\n+    long actualCrc;\n+\n+    private final int bufferSize = 4096;\n+    private final byte[] outputBuffer = new byte[bufferSize];\n+    private final byte[] readerBuf = new byte[bufferSize];\n+\n+    protected StreamCompressor(Deflater deflater) {\n+        this.def = deflater;\n+    }\n+\n+    /**\n+     * Create a stream compressor with the given compression level.\n+     *\n+     * @param compressionLevel The #Deflater compression level\n+     * @param os The #OutputStream stream to receive output\n+     * @return A stream compressor\n+     */\n+    public static StreamCompressor create(int compressionLevel, OutputStream os) {\n+        final Deflater deflater = new Deflater(compressionLevel, true);\n+        return new OutputStreamCompressor(deflater, os);\n+    }\n+\n+    /**\n+     * Create a stream compressor with the default compression level.\n+     *\n+     * @param os The #OutputStream stream to receive output\n+     * @return A stream compressor\n+     */\n+    public static StreamCompressor create( OutputStream os) {\n+        return create(Deflater.DEFAULT_COMPRESSION, os);\n+    }\n+\n+    /**\n+     * Create a stream compressor with the given compression level.\n+     *\n+     * @param compressionLevel The #Deflater compression level\n+     * @param os The #DataOutput to receive output\n+     * @return A stream compressor\n+     */\n+    public static StreamCompressor create(int compressionLevel, DataOutput os) {\n+        final Deflater deflater = new Deflater(compressionLevel, true);\n+        return new DataOutputCompressor(deflater, os);\n+    }\n+\n+    /**\n+     * The crc32 of the last deflated file\n+     * @return the crc32\n+     */\n+\n+    public long getCrc32() {\n+        return actualCrc;\n+    }\n+\n+    /**\n+     * Return the number of bytes read from the source stream\n+     * @return The number of bytes read, never negative\n+     */\n+    public int getBytesRead() {\n+        return sourcePayloadLength;\n+    }\n+\n+    /**\n+     * The number of bytes written to the output\n+     * @return The number of bytes, never negative\n+     */\n+    public int getBytesWritten() {\n+        return writtenToOutputStream;\n+    }\n+\n+    /**\n+     * Deflate the given source using the supplied compression method\n+     * @param source The source to compress\n+     * @param method The #ZipArchiveEntry compression method\n+     * @throws IOException When failures happen\n+     */\n+\n+    public void deflate(InputStream source, int method) throws IOException {\n+        reset();\n+        int length;\n+\n+        while(( length = source.read(readerBuf, 0, readerBuf.length)) >= 0){\n+            crc.update(readerBuf, 0, length);\n+            if (method == ZipArchiveEntry.DEFLATED) {\n+                writeDeflated(readerBuf, 0, length);\n+            } else {\n+                writeOut(readerBuf, 0, length);\n+                writtenToOutputStream += length;\n+            }\n+            sourcePayloadLength += length;\n+        }\n+        if (method == ZipArchiveEntry.DEFLATED) {\n+            flushDeflater();\n+        }\n+        actualCrc = crc.getValue();\n+\n+\n+    }\n+\n+    private void reset(){\n+        crc.reset();\n+        def.reset();\n+        sourcePayloadLength = 0;\n+        writtenToOutputStream = 0;\n+    }\n+\n+    private void flushDeflater() throws IOException {\n+        def.finish();\n+        while (!def.finished()) {\n+            deflate();\n+        }\n+    }\n+\n+    private void writeDeflated(byte[]b, int offset, int length)\n+            throws IOException {\n+        if (length > 0 && !def.finished()) {\n+            if (length <= DEFLATER_BLOCK_SIZE) {\n+                def.setInput(b, offset, length);\n+                deflateUntilInputIsNeeded();\n+            } else {\n+                final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n+                for (int i = 0; i < fullblocks; i++) {\n+                    def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n+                            DEFLATER_BLOCK_SIZE);\n+                    deflateUntilInputIsNeeded();\n+                }\n+                final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n+                if (done < length) {\n+                    def.setInput(b, offset + done, length - done);\n+                    deflateUntilInputIsNeeded();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void deflateUntilInputIsNeeded() throws IOException {\n+        while (!def.needsInput()) {\n+            deflate();\n+        }\n+    }\n+\n+    private void deflate() throws IOException {\n+        int len = def.deflate(outputBuffer, 0, outputBuffer.length);\n+        if (len > 0) {\n+            writeOut(outputBuffer, 0, len);\n+            writtenToOutputStream += len;\n+        }\n+    }\n+\n+    protected abstract void writeOut(byte[] data, int offset, int length) throws IOException ;\n+\n+    private static final class OutputStreamCompressor extends StreamCompressor {\n+        private final OutputStream os;\n+\n+        public OutputStreamCompressor(Deflater deflater, OutputStream os) {\n+            super(deflater);\n+            this.os = os;\n+        }\n+\n+        protected final void writeOut(byte[] data, int offset, int length)\n+                throws IOException {\n+                os.write(data, offset, length);\n+        }\n+    }\n+\n+    private static final class DataOutputCompressor extends StreamCompressor {\n+        private final DataOutput raf;\n+        public DataOutputCompressor(Deflater deflater, DataOutput raf) {\n+            super(deflater);\n+            this.raf = raf;\n+        }\n+\n+        protected final void writeOut(byte[] data, int offset, int length)\n+                throws IOException {\n+            raf.write(data, offset, length);\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         putArchiveEntry(ae);\n         copyFromZipInputStream(rawStream);\n         closeCopiedEntry();\n-    }\n-\n-    /**\n-     * Make a copy of this stream with all its settings, but point to a new file.\n-     * Used for scatter/gather operations to make several streams from a user-supplied master.\n-     *\n-     * @param newFile The file to use for the copy of this stream\n-     * @return A copy of this stream\n-     */\n-    public ZipArchiveOutputStream cloneWith(File newFile) throws IOException {\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(newFile);\n-        zos.setCreateUnicodeExtraFields(createUnicodeExtraFields);\n-        zos.setMethod(method);\n-        zos.setEncoding(encoding);\n-        zos.setFallbackToUTF8(fallbackToUTF8);\n-        zos.setUseLanguageEncodingFlag(useUTF8Flag);\n-        zos.setUseZip64(zip64Mode);\n-        return zos;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n         }\n     };\n \n-\n-    public void testCloneZipOutputStream( ) throws IOException {\n-        File tempDir = createTempDir();\n-        File fred = new File(tempDir, \"fred\");\n-        ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(fred);\n-        File frank = new File(tempDir, \"frank\");\n-        ZipArchiveOutputStream actual = zipArchiveOutputStream.cloneWith(frank);\n-        zipArchiveOutputStream.close();\n-        actual.close();\n-        assertTrue( fred.exists());\n-        assertTrue( frank.exists());\n-    }\n-\n     public void testCopyRawEntriesFromFile\n             ()\n             throws IOException {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class ScatterZipOutputStreamTest {\n+\n+    @Test\n+    public void putArchiveEntry() throws Exception {\n+        File scatteFile = File.createTempFile(\"scattertest\", \".notzip\");\n+        ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.fileBased(scatteFile);\n+        final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\n+        final byte[] A_PAYLOAD = \"XAAY\".getBytes();\n+\n+        ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\n+        scatterZipOutputStream.addArchiveEntry(zab, new ByteArrayInputStream(B_PAYLOAD), ZipArchiveEntry.DEFLATED);\n+\n+        ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\n+        scatterZipOutputStream.addArchiveEntry(zae, new ByteArrayInputStream(A_PAYLOAD), ZipArchiveEntry.DEFLATED);\n+\n+        File target = File.createTempFile(\"scattertest\", \".zip\");\n+        ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target);\n+        scatterZipOutputStream.writeTo( outputStream);\n+        outputStream.close();\n+\n+        ZipFile zf = new ZipFile(target);\n+        final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\n+        assertEquals(8, b_entry.getSize());\n+        assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(zf.getInputStream(b_entry)));\n+\n+        final ZipArchiveEntry a_entry = zf.getEntries(\"a.txt\").iterator().next();\n+        assertEquals(4, a_entry.getSize());\n+        assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(zf.getInputStream(a_entry)));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/StreamCompressorTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class StreamCompressorTest {\n+\n+    @Test\n+    public void storedEntries() throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        StreamCompressor sc = StreamCompressor.create( baos);\n+        sc.deflate(new ByteArrayInputStream(\"A\".getBytes()), ZipEntry.STORED);\n+        sc.deflate(new ByteArrayInputStream(\"BAD\".getBytes()), ZipEntry.STORED);\n+        assertEquals(3, sc.getBytesRead());\n+        assertEquals(3, sc.getBytesWritten());\n+        assertEquals(344750961, sc.getCrc32());\n+        sc.deflate(new ByteArrayInputStream(\"CAFE\".getBytes()), ZipEntry.STORED);\n+        assertEquals(\"ABADCAFE\", baos.toString());\n+   }\n+\n+    @Test\n+    public void deflatedEntries() throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        StreamCompressor sc = StreamCompressor.create( baos);\n+        sc.deflate(new ByteArrayInputStream(\"AAAAAABBBBBB\".getBytes()), ZipEntry.DEFLATED);\n+        assertEquals(12, sc.getBytesRead());\n+        assertEquals(8, sc.getBytesWritten());\n+        assertEquals(3299542, sc.getCrc32());\n+\n+        final byte[] actuals = baos.toByteArray();\n+        byte[] expected = new byte[]{115,116,4,1,39,48,0,0};\n+        // Note that this test really asserts stuff about the java Deflater, which might be a little bit brittle\n+        assertArrayEquals(expected, actuals);\n+    }\n+}", "timestamp": 1419261842, "metainfo": ""}