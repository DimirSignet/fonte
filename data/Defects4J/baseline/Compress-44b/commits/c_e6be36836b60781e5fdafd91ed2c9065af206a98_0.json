{"sha": "e6be36836b60781e5fdafd91ed2c9065af206a98", "log": "Added ParallelScatterZipCreator  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/InputStreamSupplier.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.InputStream;\n+\n+public interface InputStreamSupplier {\n+\n+    /**\n+     * Supply an input stream for a resource.\n+     * @return the input stream, may be null if there is no content for the resource.\n+     */\n+    InputStream get();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.zip.Deflater;\n+\n+/**\n+ * Creates a zip in parallel by using multiple threadlocal #ScatterZipOutputStream instances.\n+ * <p/>\n+ * Note that this class generally makes no guarantees about the order of things written to\n+ * the output file. Things that need to come in a specific order (manifests, directories)\n+ * must be handled by the client of this class, usually by writing these things to the\n+ * #ZipArchiveOutputStream *before* calling #writeTo on this class.\n+ */\n+public class ParallelScatterZipCreator {\n+    private List<ScatterZipOutputStream> streams = Collections.synchronizedList(new ArrayList<ScatterZipOutputStream>());\n+    private final ExecutorService es;\n+\n+    private final long startedAt = System.currentTimeMillis();\n+    private long compressionDoneAt = 0;\n+    private long scatterDoneAt;\n+\n+    static ScatterGatherBackingStoreSupplier defaultSupplier = new DefaultSupplier();\n+\n+    static class DefaultSupplier implements ScatterGatherBackingStoreSupplier {\n+        AtomicInteger storeNum = new AtomicInteger(0);\n+\n+        public ScatterGatherBackingStore get() throws IOException {\n+            File tempFile = File.createTempFile(\"parallelscatter\", \"n\" + storeNum.incrementAndGet());\n+            return new FileBasedScatterGatherBackingStore(tempFile);\n+        }\n+    }\n+\n+    static ScatterZipOutputStream createDeferred(ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier)\n+            throws IOException {\n+        ScatterGatherBackingStore bs = scatterGatherBackingStoreSupplier.get();\n+        StreamCompressor sc = StreamCompressor.create(Deflater.DEFAULT_COMPRESSION, bs);\n+        return new ScatterZipOutputStream(bs, sc);\n+    }\n+\n+\n+    ThreadLocal<ScatterZipOutputStream> tlScatterStreams = new ThreadLocal<ScatterZipOutputStream>() {\n+        @Override\n+        protected ScatterZipOutputStream initialValue() {\n+            try {\n+                ScatterZipOutputStream scatterStream = createDeferred(defaultSupplier);\n+                streams.add(scatterStream);\n+                return scatterStream;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Create a ParallelScatterZipCreator with default threads\n+     */\n+    public ParallelScatterZipCreator() {\n+        this(Runtime.getRuntime().availableProcessors());\n+    }\n+\n+    /**\n+     * Create a ParallelScatterZipCreator\n+     *\n+     * @param nThreads the number of threads to use in parallel.\n+     */\n+    public ParallelScatterZipCreator(int nThreads) {\n+        es = Executors.newFixedThreadPool(nThreads);\n+    }\n+\n+    /**\n+     * Adds an archive entry to this archive.\n+     * <p/>\n+     * This method is expected to be called from a single client thread\n+     *\n+     * @param zipArchiveEntry The entry to add. Compression method\n+     * @param source          The source input stream supplier\n+     */\n+\n+    public void addArchiveEntry(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n+        final int method = zipArchiveEntry.getMethod();\n+        if (method == -1) throw new IllegalArgumentException(\"Method must be set on the supplied zipArchiveEntry\");\n+        // Consider if we want to constrain the number of items that can enqueue here.\n+        es.submit(new Callable<ScatterZipOutputStream>() {\n+            public ScatterZipOutputStream call() throws Exception {\n+                ScatterZipOutputStream streamToUse = tlScatterStreams.get();\n+                streamToUse.addArchiveEntry(zipArchiveEntry, source.get(), method);\n+                return streamToUse;\n+            }\n+\n+        });\n+    }\n+\n+\n+    /**\n+     * Write the contents this to the target #ZipArchiveOutputStream.\n+     * <p/>\n+     * It may be beneficial to write things like directories and manifest files to the targetStream\n+     * before calling this method.\n+     *\n+     * @param targetStream The ZipArchiveOutputStream to receive the contents of the scatter streams\n+     * @throws IOException          If writing fails\n+     * @throws InterruptedException If we get interrupted\n+     */\n+    public void writeTo(ZipArchiveOutputStream targetStream) throws IOException, InterruptedException {\n+        es.shutdown();\n+        es.awaitTermination(1000 * 60, TimeUnit.SECONDS);\n+\n+        // It is important that all threads terminate before we go on, ensure happens-before relationship\n+        compressionDoneAt = System.currentTimeMillis();\n+\n+        for (ScatterZipOutputStream scatterStream : streams) {\n+            scatterStream.writeTo(targetStream);\n+        }\n+\n+        scatterDoneAt = System.currentTimeMillis();\n+        // Maybe close ScatterZipOS. We should do something to get rid of tempfiles.\n+    }\n+\n+    /**\n+     * Returns a message describing the overall statistics of the compression run\n+     *\n+     * @return A string\n+     */\n+    public String getStatisticsMessage() {\n+        return \"Compression: \" + (compressionDoneAt - startedAt) + \"ms,\" +\n+                \"Merging files: \" + (scatterDoneAt - compressionDoneAt) + \"ms\";\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterGatherBackingStoreSupplier.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+\n+public interface ScatterGatherBackingStoreSupplier {\n+    /**\n+     * Get a ScatterGatherBackingStore.\n+     *\n+     * @return a ScatterGatherBackingStore, not null\n+     */\n+    ScatterGatherBackingStore get() throws IOException;\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.junit.Assert.*;\n+\n+@SuppressWarnings(\"OctalInteger\")\n+public class ParallelScatterZipCreatorTest {\n+\n+    @Test\n+    public void concurrent()\n+            throws Exception {\n+        File result = File.createTempFile(\"parallelScatterGather1\", \"\");\n+        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n+        zos.setEncoding(\"UTF-8\");\n+        ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator();\n+\n+        Map<String, byte[]> entries = writeEntries(zipCreator);\n+        zipCreator.writeTo(zos);\n+        zos.close();\n+\n+        removeEntriesFoundInZipFile(result, entries);\n+        assertTrue(entries.size() == 0);\n+        assertNotNull( zipCreator.getStatisticsMessage());\n+    }\n+\n+    private void removeEntriesFoundInZipFile(File result, Map<String, byte[]> entries) throws IOException {\n+        ZipFile zf = new ZipFile(result);\n+        Enumeration<ZipArchiveEntry> entriesInPhysicalOrder = zf.getEntriesInPhysicalOrder();\n+        while (entriesInPhysicalOrder.hasMoreElements()){\n+            ZipArchiveEntry zipArchiveEntry = entriesInPhysicalOrder.nextElement();\n+            InputStream inputStream = zf.getInputStream(zipArchiveEntry);\n+            byte[] actual = IOUtils.toByteArray(inputStream);\n+            byte[] expected = entries.remove(zipArchiveEntry.getName());\n+            assertArrayEquals( expected, actual);\n+        }\n+        zf.close();\n+    }\n+\n+    private Map<String, byte[]> writeEntries(ParallelScatterZipCreator zipCreator) {\n+        Map<String, byte[]> entries = new HashMap<String, byte[]>();\n+        for (int i = 0; i < 10000; i++){\n+            ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n+            final String payload = \"content\" + i;\n+            final byte[] payloadBytes = payload.getBytes();\n+            entries.put( za.getName(), payloadBytes);\n+            za.setMethod(ZipArchiveEntry.DEFLATED);\n+            za.setSize(payload.length());\n+            za.setUnixMode(UnixStat.FILE_FLAG | 0664);\n+            zipCreator.addArchiveEntry(za, new InputStreamSupplier() {\n+                public InputStream get() {\n+                    return new ByteArrayInputStream(payloadBytes);\n+                }\n+            });\n+        }\n+        return entries;\n+    }\n+}", "timestamp": 1420035275, "metainfo": ""}