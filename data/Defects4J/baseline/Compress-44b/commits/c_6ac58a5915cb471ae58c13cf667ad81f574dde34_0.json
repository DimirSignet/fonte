{"sha": "6ac58a5915cb471ae58c13cf667ad81f574dde34", "log": "COMPRESS-246 support for framed Snappy format", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;\n import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;\n+import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorOutputStream;\n import org.apache.commons.compress.compressors.snappy.SnappyCompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;\n      * \n      * @param name\n      *            the compressor name, i.e. {@value #GZIP}, {@value #BZIP2},\n-     *            {@value #XZ}, {@value #PACK200} or {@value #DEFLATE}\n+     *            {@value #XZ}, {@value #PACK200}, {@value SNAPPY_FRAMED}\n+     *            or {@value #DEFLATE}\n      * @param out\n      *            the output stream\n      * @return the compressor output stream\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n                 return new DeflateCompressorOutputStream(out);\n+            }\n+\n+            if (SNAPPY_FRAMED.equalsIgnoreCase(name)) {\n+                return new FramedSnappyCompressorOutputStream(out);\n             }\n \n         } catch (final IOException e) {\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n     static final long MASK_OFFSET = 0xa282ead8L;\n \n     private static final int STREAM_IDENTIFIER_TYPE = 0xff;\n-    private static final int COMPRESSED_CHUNK_TYPE = 0;\n+    static final int COMPRESSED_CHUNK_TYPE = 0;\n     private static final int UNCOMPRESSED_CHUNK_TYPE = 1;\n     private static final int PADDING_CHUNK_TYPE = 0xfe;\n     private static final int MIN_UNSKIPPABLE_TYPE = 2;\n     private static final int MAX_UNSKIPPABLE_TYPE = 0x7f;\n     private static final int MAX_SKIPPABLE_TYPE = 0xfd;\n \n-    private static final byte[] SZ_SIGNATURE = new byte[] {\n+    // used by FramedSnappyCompressorOutputStream as well\n+    static final byte[] SZ_SIGNATURE = new byte[] {\n         (byte) STREAM_IDENTIFIER_TYPE, // tag\n         6, 0, 0, // length\n         's', 'N', 'a', 'P', 'p', 'Y'\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorOutputStream;\n+\n+/**\n+ * CompressorOutputStream for the framing Snappy format.\n+ *\n+ * <p>Based on the \"spec\" in the version \"Last revised: 2013-10-25\"</p>\n+ *\n+ * @see <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing format description</a>\n+ * @since 1.14\n+ * @NotThreadSafe\n+ */\n+public class FramedSnappyCompressorOutputStream extends CompressorOutputStream {\n+    // see spec:\n+    // > However, we place an additional restriction that the uncompressed data\n+    // > in a chunk must be no longer than 65536 bytes. This allows consumers to\n+    // > easily use small fixed-size buffers.\n+    private static final int MAX_COMPRESSED_BUFFER_SIZE = 1 << 16;\n+\n+    private final OutputStream out;\n+    private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n+    // used in one-arg write method\n+    private final byte[] oneByte = new byte[1];\n+    private final byte[] buffer = new byte[MAX_COMPRESSED_BUFFER_SIZE];\n+    private int currentIndex = 0;\n+\n+    /**\n+     * Constructs a new output stream that compresses\n+     * snappy-framed-compressed data to the specified output stream.\n+     * @param out the OutputStream to which to write the compressed data\n+     * @throws IOException if writing the signature fails\n+     */\n+    public FramedSnappyCompressorOutputStream(final OutputStream out) throws IOException {\n+        this.out = out;\n+        out.write(FramedSnappyCompressorInputStream.SZ_SIGNATURE);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        oneByte[0] = (byte) (b & 0xff);\n+        write(oneByte);\n+    }\n+\n+    @Override\n+    public void write(byte[] data, int off, int len) throws IOException {\n+        if (currentIndex + len > MAX_COMPRESSED_BUFFER_SIZE) {\n+            flushBuffer();\n+            while (len > MAX_COMPRESSED_BUFFER_SIZE) {\n+                System.arraycopy(data, off, buffer, 0, MAX_COMPRESSED_BUFFER_SIZE);\n+                off += MAX_COMPRESSED_BUFFER_SIZE;\n+                len -= MAX_COMPRESSED_BUFFER_SIZE;\n+                currentIndex = MAX_COMPRESSED_BUFFER_SIZE;\n+                flushBuffer();\n+            }\n+        }\n+        System.arraycopy(data, off, buffer, currentIndex, len);\n+        currentIndex += len;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        finish();\n+        out.close();\n+    }\n+\n+    /**\n+     * Compresses all remaining data and writes it to the stream,\n+     * doesn't close the underlying stream.\n+     * @throws IOException if an error occurs\n+     */\n+    public void finish() throws IOException {\n+        if (currentIndex > 0) {\n+            flushBuffer();\n+        }\n+    }\n+\n+    private void flushBuffer() throws IOException {\n+        out.write(FramedSnappyCompressorInputStream.COMPRESSED_CHUNK_TYPE);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (OutputStream o = new SnappyCompressorOutputStream(baos, currentIndex)) {\n+            o.write(buffer, 0, currentIndex);\n+        }\n+        byte[] b = baos.toByteArray();\n+        writeLittleEndian(3, b.length + 4 /* CRC */);\n+        writeCrc();\n+        out.write(b);\n+        currentIndex = 0;\n+    }\n+\n+    private void writeLittleEndian(final int numBytes, long num) throws IOException {\n+        for (int i = 0; i < numBytes; i++) {\n+            out.write((int) (num & 0xff));\n+            num >>= 8;\n+        }\n+    }\n+\n+    private void writeCrc() throws IOException {\n+        checksum.update(buffer, 0, currentIndex);\n+        writeLittleEndian(4, mask(checksum.getValue()));\n+        checksum.reset();\n+    }\n+\n+    static long mask(long x) {\n+        // ugly, maybe we should just have used ints and deal with the\n+        // overflow\n+        x = ((x >> 15) | (x << 17));\n+        x += FramedSnappyCompressorInputStream.MASK_OFFSET;\n+        x &= 0xffffFFFFL;\n+        return x;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Random;\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;\n         }\n     }\n \n+    @Test\n+    public void testRoundtrip() throws Exception {\n+        testRoundtrip(getFile(\"test.txt\"));\n+        testRoundtrip(getFile(\"bla.tar\"));\n+        testRoundtrip(getFile(\"COMPRESS-256.7z\"));\n+    }\n+\n+    @Test\n+    public void testRoundtripWithOneBigWrite() throws Exception {\n+        Random r = new Random();\n+        File input = new File(dir, \"bigChunkTest\");\n+        try (FileOutputStream fs = new FileOutputStream(input)) {\n+            for (int i = 0 ; i < 1 << 17; i++) {\n+                fs.write(r.nextInt(256));\n+            }\n+        }\n+        long start = System.currentTimeMillis();\n+        final File outputSz = new File(dir, input.getName() + \".sz\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             FileOutputStream os = new FileOutputStream(outputSz);\n+             CompressorOutputStream sos = new CompressorStreamFactory()\n+                 .createCompressorOutputStream(\"snappy-framed\", os)) {\n+            byte[] b = IOUtils.toByteArray(is);\n+            sos.write(b[0]);\n+            sos.write(b, 1, b.length - 1); // must be split into multiple compressed chunks\n+        }\n+        System.err.println(input.getName() + \" written, uncompressed bytes: \" + input.length()\n+            + \", compressed bytes: \" + outputSz.length() + \" after \" + (System.currentTimeMillis() - start) + \"ms\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             CompressorInputStream sis = new CompressorStreamFactory()\n+                 .createCompressorInputStream(\"snappy-framed\", new FileInputStream(outputSz))) {\n+            byte[] expected = IOUtils.toByteArray(is);\n+            byte[] actual = IOUtils.toByteArray(sis);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    private void testRoundtrip(File input)  throws Exception {\n+        long start = System.currentTimeMillis();\n+        final File outputSz = new File(dir, input.getName() + \".sz\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             FileOutputStream os = new FileOutputStream(outputSz);\n+             CompressorOutputStream sos = new CompressorStreamFactory()\n+                 .createCompressorOutputStream(\"snappy-framed\", os)) {\n+            IOUtils.copy(is, sos);\n+        }\n+        System.err.println(input.getName() + \" written, uncompressed bytes: \" + input.length()\n+            + \", compressed bytes: \" + outputSz.length() + \" after \" + (System.currentTimeMillis() - start) + \"ms\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             CompressorInputStream sis = new CompressorStreamFactory()\n+                 .createCompressorInputStream(\"snappy-framed\", new FileInputStream(outputSz))) {\n+            byte[] expected = IOUtils.toByteArray(is);\n+            byte[] actual = IOUtils.toByteArray(sis);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n }", "timestamp": 1484057246, "metainfo": ""}