{"sha": "f538f38bd4db41349fb8f753ec17850861de5e0e", "log": "avoid overflow when resizing", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n+++ b/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n  * @NotThreadSafe\n  */\n public class SeekableInMemoryByteChannel implements SeekableByteChannel {\n+\n+    private static final int NAIVE_RESIZE_LIMIT = Integer.MAX_VALUE >> 1;\n \n     private byte[] data;\n     private final AtomicBoolean closed = new AtomicBoolean();\n         int wanted = b.remaining();\n         int possibleWithoutResize = size - position;\n         if (wanted > possibleWithoutResize) {\n-            resize(position + wanted);\n+            int newSize = position + wanted;\n+            if (newSize < 0) { // overflow\n+                resize(Integer.MAX_VALUE);\n+                wanted = Integer.MAX_VALUE - position;\n+            } else {\n+                resize(newSize);\n+            }\n         }\n         b.get(data, position, wanted);\n         position += wanted;\n         if (len <= 0) {\n             len = 1;\n         }\n-        while (len < newLength) {\n-            len <<= 1;\n+        if (newLength < NAIVE_RESIZE_LIMIT) {\n+            while (len < newLength) {\n+                len <<= 1;\n+            }\n+        } else { // avoid overflow\n+            len = newLength;\n         }\n         data = Arrays.copyOf(data, len);\n     }", "timestamp": 1478274623, "metainfo": ""}