{"sha": "d8fc27b40be0c71090fb11d47aba813ce87f3d8b", "log": "COMPRESS-327 read zip archives from arbitrary SeekableByteChannels", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.Enumeration;\n+import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n  *\n  * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n  * have to reimplement all methods anyway.  Like\n- * <code>java.util.ZipFile</code>, it uses RandomAccessFile under the\n+ * <code>java.util.ZipFile</code>, it uses SeekableByteChannel under the\n  * covers and supports compressed and uncompressed entries.  As of\n  * Apache Commons Compress 1.3 it also transparently supports Zip64\n  * extensions and thus individual entries and archives larger than 4\n     /**\n      * The actual data source.\n      */\n-    private final RandomAccessFile archive;\n+    private final SeekableByteChannel archive;\n \n     /**\n      * Whether to look for and use Unicode extra fields.\n     private final byte[] WORD_BUF = new byte[WORD];\n     private final byte[] CFH_BUF = new byte[CFH_LEN];\n     private final byte[] SHORT_BUF = new byte[SHORT];\n+    private final ByteBuffer DWORD_BBUF = ByteBuffer.wrap(DWORD_BUF);\n+    private final ByteBuffer WORD_BBUF = ByteBuffer.wrap(WORD_BUF);\n+    private final ByteBuffer CFH_BBUF = ByteBuffer.wrap(CFH_BUF);\n+    private final ByteBuffer SHORT_BBUF = ByteBuffer.wrap(SHORT_BUF);\n \n     /**\n      * Opens the given file for reading, assuming \"UTF8\" for file names.\n      */\n     public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n         throws IOException {\n-        this.archiveName = f.getAbsolutePath();\n+        this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n+             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * @param channel the archive.\n+     * @param archiveName name of the archivem used for error messages only.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final SeekableByteChannel channel, final String archiveName,\n+                   final String encoding, final boolean useUnicodeExtraFields)\n+        throws IOException {\n+        this(channel, archiveName, encoding, useUnicodeExtraFields, false);\n+    }\n+\n+    private ZipFile(final SeekableByteChannel channel, final String archiveName,\n+                    final String encoding, final boolean useUnicodeExtraFields,\n+                    final boolean closeOnError)\n+        throws IOException {\n+        this.archiveName = archiveName;\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        archive = new RandomAccessFile(f, \"r\");\n+        archive = channel;\n         boolean success = false;\n         try {\n             final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n             success = true;\n         } finally {\n             closed = !success;\n-            if (!success) {\n+            if (!success && closeOnError) {\n                 IOUtils.closeQuietly(archive);\n             }\n         }\n \n         positionAtCentralDirectory();\n \n-        archive.readFully(WORD_BUF);\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n         long sig = ZipLong.getValue(WORD_BUF);\n \n         if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n \n         while (sig == CFH_SIG) {\n             readCentralDirectoryEntry(noUTF8Flag);\n-            archive.readFully(WORD_BUF);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n             sig = ZipLong.getValue(WORD_BUF);\n         }\n         return noUTF8Flag;\n     private void\n         readCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n         throws IOException {\n-        archive.readFully(CFH_BUF);\n+        CFH_BBUF.rewind();\n+        IOUtils.readFully(archive, CFH_BBUF);\n         int off = 0;\n         final OffsetEntry offset = new OffsetEntry();\n         final Entry ze = new Entry(offset);\n         off += WORD;\n \n         final byte[] fileName = new byte[fileNameLen];\n-        archive.readFully(fileName);\n+        IOUtils.readFully(archive, ByteBuffer.wrap(fileName));\n         ze.setName(entryEncoding.decode(fileName), fileName);\n \n         // LFH offset,\n         entries.add(ze);\n \n         final byte[] cdExtraData = new byte[extraLen];\n-        archive.readFully(cdExtraData);\n+        IOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\n         ze.setCentralDirectoryExtra(cdExtraData);\n \n         setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n \n         final byte[] comment = new byte[commentLen];\n-        archive.readFully(comment);\n+        IOUtils.readFully(archive, ByteBuffer.wrap(comment));\n         ze.setComment(entryEncoding.decode(comment));\n \n         if (!hasUTF8Flag && useUnicodeExtraFields) {\n         positionAtEndOfCentralDirectoryRecord();\n         boolean found = false;\n         final boolean searchedForZip64EOCD =\n-            archive.getFilePointer() > ZIP64_EOCDL_LENGTH;\n+            archive.position() > ZIP64_EOCDL_LENGTH;\n         if (searchedForZip64EOCD) {\n-            archive.seek(archive.getFilePointer() - ZIP64_EOCDL_LENGTH);\n-            archive.readFully(WORD_BUF);\n+            archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n             found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n                                   WORD_BUF);\n         }\n         throws IOException {\n         skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n                   - WORD /* signature has already been read */);\n-        archive.readFully(DWORD_BUF);\n-        archive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n-        archive.readFully(WORD_BUF);\n+        DWORD_BBUF.rewind();\n+        IOUtils.readFully(archive, DWORD_BBUF);\n+        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n         if (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n             throw new ZipException(\"archive's ZIP64 end of central \"\n                                    + \"directory locator is corrupt.\");\n         }\n         skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                   - WORD /* signature has already been read */);\n-        archive.readFully(DWORD_BUF);\n-        archive.seek(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+        DWORD_BBUF.rewind();\n+        IOUtils.readFully(archive, DWORD_BBUF);\n+        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n     }\n \n     /**\n     private void positionAtCentralDirectory32()\n         throws IOException {\n         skipBytes(CFD_LOCATOR_OFFSET);\n-        archive.readFully(WORD_BUF);\n-        archive.seek(ZipLong.getValue(WORD_BUF));\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n+        archive.position(ZipLong.getValue(WORD_BUF));\n     }\n \n     /**\n                                          final long maxDistanceFromEnd,\n                                          final byte[] sig) throws IOException {\n         boolean found = false;\n-        long off = archive.length() - minDistanceFromEnd;\n+        long off = archive.size() - minDistanceFromEnd;\n         final long stopSearching =\n-            Math.max(0L, archive.length() - maxDistanceFromEnd);\n+            Math.max(0L, archive.size() - maxDistanceFromEnd);\n         if (off >= 0) {\n             for (; off >= stopSearching; off--) {\n-                archive.seek(off);\n-                int curr = archive.read();\n-                if (curr == -1) {\n+                archive.position(off);\n+                try {\n+                    WORD_BBUF.rewind();\n+                    IOUtils.readFully(archive, WORD_BBUF);\n+                    WORD_BBUF.flip();\n+                } catch (EOFException ex) {\n                     break;\n                 }\n+                int curr = WORD_BBUF.get();\n                 if (curr == sig[POS_0]) {\n-                    curr = archive.read();\n+                    curr = WORD_BBUF.get();\n                     if (curr == sig[POS_1]) {\n-                        curr = archive.read();\n+                        curr = WORD_BBUF.get();\n                         if (curr == sig[POS_2]) {\n-                            curr = archive.read();\n+                            curr = WORD_BBUF.get();\n                             if (curr == sig[POS_3]) {\n                                 found = true;\n                                 break;\n             }\n         }\n         if (found) {\n-            archive.seek(off);\n+            archive.position(off);\n         }\n         return found;\n     }\n      * skipping failed.\n      */ \n     private void skipBytes(final int count) throws IOException {\n-        int totalSkipped = 0;\n-        while (totalSkipped < count) {\n-            final int skippedNow = archive.skipBytes(count - totalSkipped);\n-            if (skippedNow <= 0) {\n-                throw new EOFException();\n-            }\n-            totalSkipped += skippedNow;\n-        }\n+        long currentPosition = archive.position();\n+        long newPosition = currentPosition + count;\n+        if (newPosition > archive.size()) {\n+            throw new EOFException();\n+        }\n+        archive.position(newPosition);\n     }\n \n     /**\n             final Entry ze = (Entry) zipArchiveEntry;\n             final OffsetEntry offsetEntry = ze.getOffsetEntry();\n             final long offset = offsetEntry.headerOffset;\n-            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n-            archive.readFully(SHORT_BUF);\n+            archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n+            SHORT_BBUF.rewind();\n+            IOUtils.readFully(archive, SHORT_BBUF);\n             final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n-            archive.readFully(SHORT_BUF);\n+            SHORT_BBUF.rewind();\n+            IOUtils.readFully(archive, SHORT_BBUF);\n             final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n-            int lenToSkip = fileNameLen;\n-            while (lenToSkip > 0) {\n-                final int skipped = archive.skipBytes(lenToSkip);\n-                if (skipped <= 0) {\n-                    throw new IOException(\"failed to skip file name in\"\n-                                          + \" local file header\");\n-                }\n-                lenToSkip -= skipped;\n-            }\n+            skipBytes(fileNameLen);\n             final byte[] localExtraData = new byte[extraFieldLen];\n-            archive.readFully(localExtraData);\n+            IOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\n             ze.setExtra(localExtraData);\n             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n      * it may be an empty archive.\n      */\n     private boolean startsWithLocalFileHeader() throws IOException {\n-        archive.seek(0);\n-        archive.readFully(WORD_BUF);\n+        archive.position(0);\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n         return Arrays.equals(WORD_BUF, ZipArchiveOutputStream.LFH_SIG);\n     }\n \n      * range can be read.\n      */\n     private class BoundedInputStream extends InputStream {\n+        private static final int MAX_BUF_LEN = 8192;\n+        private final ByteBuffer buffer;\n         private long remaining;\n         private long loc;\n         private boolean addDummyByte = false;\n         BoundedInputStream(final long start, final long remaining) {\n             this.remaining = remaining;\n             loc = start;\n+            if (remaining < MAX_BUF_LEN && remaining > 0) {\n+                buffer = ByteBuffer.allocate((int) remaining);\n+            } else {\n+                buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n+            }\n         }\n \n         @Override\n                 return -1;\n             }\n             synchronized (archive) {\n-                archive.seek(loc++);\n-                return archive.read();\n+                archive.position(loc++);\n+                int read = read(1);\n+                if (read < 0) {\n+                    return read;\n+                }\n+                return buffer.get() & 0xff;\n             }\n         }\n \n             if (len > remaining) {\n                 len = (int) remaining;\n             }\n+            ByteBuffer buf;\n             int ret = -1;\n             synchronized (archive) {\n-                archive.seek(loc);\n-                ret = archive.read(b, off, len);\n+                archive.position(loc);\n+                if (len <= buffer.capacity()) {\n+                    buf = buffer;\n+                    ret = read(len);\n+                } else {\n+                    buf = ByteBuffer.allocate(len);\n+                    ret = archive.read(buf);\n+                    buf.flip();\n+                }\n             }\n             if (ret > 0) {\n+                buf.get(b, off, ret);\n                 loc += ret;\n                 remaining -= ret;\n             }\n             return ret;\n+        }\n+\n+        private int read(int len) throws IOException {\n+            buffer.rewind().limit(len);\n+            int read = archive.read(buffer);\n+            buffer.flip();\n+            return read;\n         }\n \n         /**", "timestamp": 1476290236, "metainfo": ""}