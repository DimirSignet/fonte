{"sha": "3b3b11c839368413d8330561425e2f8f41c1a08b", "log": "third case of seven: known size, no compression, writing to random access file.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n \n             raf.seek(localDataStart);\n             writeOut(ZipLong.getBytes(entry.getCrc()));\n+            if (!hasZip64Extra(entry)) {\n             writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n             writeOut(ZipLong.getBytes(entry.getSize()));\n+            } else {\n+                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+                raf.seek(localDataStart + 3 * WORD + 2 * SHORT\n+                         + getName(entry).limit() + 2 * SHORT);\n+                writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n+                writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n+            }\n             raf.seek(save);\n         }\n \n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n         boolean encodable = zipEncoding.canEncode(ze.getName());\n-\n-        final ZipEncoding entryEncoding;\n-\n-        if (!encodable && fallbackToUTF8) {\n-            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n-        } else {\n-            entryEncoding = zipEncoding;\n-        }\n-\n-        ByteBuffer name = entryEncoding.encode(ze.getName());\n+        ByteBuffer name = getName(ze);\n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n \n             String comm = ze.getComment();\n             if (comm != null && !\"\".equals(comm)) {\n \n-                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n+                boolean commentEncodable = zipEncoding.canEncode(comm);\n \n                 if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                     || !commentEncodable) {\n-                    ByteBuffer commentB = entryEncoding.encode(comm);\n+                    ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n                     ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                   commentB.array(),\n                                                                   commentB.arrayOffset(),\n         written += 12;\n         // CheckStyle:MagicNumber ON\n \n-        // file name length\n-        final ZipEncoding entryEncoding;\n-\n-        if (!encodable && fallbackToUTF8) {\n-            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n-        } else {\n-            entryEncoding = zipEncoding;\n-        }\n-\n-        ByteBuffer name = entryEncoding.encode(ze.getName());\n+        ByteBuffer name = getName(ze);\n \n         writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n             comm = \"\";\n         }\n \n-        ByteBuffer commentB = entryEncoding.encode(comm);\n+        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n \n         writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n                                + \", raf: \" + (raf != null));\n             */\n             z64 = new Zip64ExtendedInformationExtraField();\n+        }\n+\n+        // even if the field is there already, make sure it is the first one\n             ze.addAsFirstExtraField(z64);\n-        }\n+\n         return z64;\n     }\n \n                                 .HEADER_ID)\n             != null;\n     }\n+\n+    private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {\n+        boolean encodable = zipEncoding.canEncode(ze.getName());\n+        return !encodable && fallbackToUTF8\n+            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+    }\n+\n+    private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n+        return getEntryEncoding(ze).encode(ze.getName());\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n             }\n         };\n \n+    @Ignore\n     @Test public void write3EntriesCreatingBigArchiveFile() throws Throwable {\n         withTemporaryArchive(\"write3EntriesCreatingBigArchiveFile\",\n                              write3EntriesCreatingBigArchive,\n                              true);\n     }\n \n+    @Ignore\n     @Test public void write3EntriesCreatingBigArchiveStream() throws Throwable {\n         withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\",\n                              write3EntriesCreatingBigArchive,\n \n     /*\n      * One entry of length 5 billion bytes, written without\n-     * compression to a stream.\n+     * compression.\n      *\n-     * No Compression + Stream => sizes must be known before data is\n-     * written and are stored directly inside the LFH.  No Data\n-     * Descriptor at all.\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all.\n      *\n      * Creates a temporary archive of approx 5GB in size\n      */\n-    @Test public void writeBigStoredEntryToStream() throws Throwable {\n-        withTemporaryArchive(\"writeBigStoredEntryToStream\",\n-                             new ZipOutputTest() {\n+    private static ZipOutputTest writeBigStoredEntry(final boolean knownSize) {\n+        return new ZipOutputTest() {\n                                  public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      byte[] buf = new byte[1000 * 1000];\n                                      ZipArchiveEntry zae =\n                                          new ZipArchiveEntry(\"0\");\n+                                     if (knownSize) {\n                                      zae.setSize(FIVE_BILLION);\n+                                     zae.setCrc(0x5c316f50L);\n+                                     }\n                                      zae.setMethod(ZipArchiveEntry.STORED);\n-                                     zae.setCrc(0x5c316f50L);\n                                      zos.putArchiveEntry(zae);\n                                      for (int j = 0;\n                                           j < FIVE_BILLION / 1000 / 1000;\n                                          a.close();\n                                      }\n                                  }\n-                             },\n+        };\n+    }\n+\n+    /*\n+     * No Compression + Stream => sizes must be known before data is\n+     * written.\n+     */\n+    @Test public void writeBigStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStream\",\n+                             writeBigStoredEntry(true),\n                              false);\n+    }\n+\n+    @Test public void writeBigStoredEntryKnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFile\",\n+                             writeBigStoredEntry(true),\n+                             true);\n     }\n \n     /*", "timestamp": 1312038752, "metainfo": ""}