{"sha": "f7e0a4a0212424edd1765d1abe66772af069dafb", "log": "add lazy matching to LZ77 compressors", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n \n     private void compress() throws IOException {\n         final int minMatch = params.getMinBackReferenceLength();\n+        final boolean lazy = params.getLazyMatching();\n+        final int lazyThreshold = params.getLazyMatchingThreshold();\n \n         while (lookahead >= minMatch) {\n             catchUpMissedInserts();\n             if (hashHead != NO_MATCH && hashHead - currentPosition <= params.getMaxOffset()) {\n                 // sets matchStart as a side effect\n                 matchLength = longestMatch(hashHead);\n+\n+                if (lazy && matchLength <= lazyThreshold && lookahead > minMatch) {\n+                    // try to find a longer match using the next position\n+                    matchLength = longestMatchForNextPosition(matchLength);\n+                }\n             }\n             if (matchLength >= minMatch) {\n                 if (blockStart != currentPosition) {\n         prev[pos & wMask] = hashHead;\n         head[insertHash] = pos;\n         return hashHead;\n+    }\n+\n+    private int longestMatchForNextPosition(final int prevMatchLength) {\n+        // save a bunch of values to restore them if the next match isn't better than the current one\n+        final int prevMatchStart = matchStart;\n+        final int prevInsertHash = insertHash;\n+\n+        lookahead--;\n+        currentPosition++;\n+        int hashHead = insertString(currentPosition);\n+        final int prevHashHead = prev[currentPosition & wMask];\n+        int matchLength = longestMatch(hashHead);\n+\n+        if (matchLength <= prevMatchLength) {\n+            // use the first match, as the next one isn't any better\n+            matchLength = prevMatchLength;\n+            matchStart = prevMatchStart;\n+\n+            // restore modified values\n+            head[insertHash] = prevHashHead;\n+            insertHash = prevInsertHash;\n+            currentPosition--;\n+            lookahead++;\n+        }\n+        return matchLength;\n     }\n \n     private void insertStringsInMatch(int matchLength) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n     public static class Builder {\n         private final int windowSize;\n         private int minBackReferenceLength, maxBackReferenceLength, maxOffset, maxLiteralLength;\n-        private Integer niceBackReferenceLength, maxCandidates;\n+        private Integer niceBackReferenceLength, maxCandidates, lazyThreshold;\n+        private Boolean lazyMatches;\n \n         private Builder(int windowSize) {\n             if (windowSize < 2 || !isPowerOfTwo(windowSize)) {\n         }\n \n         /**\n+         * Sets whether lazy matching should be performed.\n+         *\n+         * <p>Lazy matching means that after a back-reference for a certain position has been found the compressor will\n+         * try to find a longer match for the next position.</p>\n+         *\n+         * <p>Lazy matching is enabled by default and disabled when tuning for speed.</p>\n+         */\n+        public Builder withLazyMatching(boolean lazy) {\n+            lazyMatches = lazy;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the threshold for lazy matching.\n+         *\n+         * <p>Even if lazy matching is enabled it will not be performed if the length of the back-reference found for\n+         * the current position is longer than this value.</p>\n+         */\n+        public Builder withLazyThreshold(int threshold) {\n+            lazyThreshold = threshold;\n+            return this;\n+        }\n+\n+        /**\n          * Changes the default setting for \"nice back-reference length\" and \"maximum number of candidates\" for improved\n          * compression speed at the cost of compression ratio.\n          *\n         public Builder tunedForSpeed() {\n             niceBackReferenceLength = Math.max(minBackReferenceLength, maxBackReferenceLength / 8);\n             maxCandidates = Math.max(32, windowSize / 1024);\n+            lazyMatches = false;\n+            lazyThreshold = minBackReferenceLength;\n             return this;\n         }\n \n          * <p>Use this method after configuring \"maximum back-reference length\".</p>\n          */\n         public Builder tunedForCompressionRatio() {\n-            niceBackReferenceLength = maxBackReferenceLength;\n+            niceBackReferenceLength = lazyThreshold = maxBackReferenceLength;\n             maxCandidates = Math.max(32, windowSize / 16);\n+            lazyMatches = true;\n             return this;\n         }\n \n             int niceLen = niceBackReferenceLength != null ? niceBackReferenceLength\n                 : Math.max(minBackReferenceLength, maxBackReferenceLength / 2);\n             int candidates = maxCandidates != null ? maxCandidates : Math.max(256, windowSize / 128);\n+            boolean lazy = lazyMatches != null ? lazyMatches : true;\n+            int threshold = lazy ? (lazyThreshold != null ? lazyThreshold : niceLen) : minBackReferenceLength;\n \n             return new Parameters(windowSize, minBackReferenceLength, maxBackReferenceLength,\n-                maxOffset, maxLiteralLength, niceLen, candidates);\n+                maxOffset, maxLiteralLength, niceLen, candidates, lazy, threshold);\n         }\n     }\n \n     private final int windowSize, minBackReferenceLength, maxBackReferenceLength, maxOffset, maxLiteralLength,\n-        niceBackReferenceLength, maxCandidates;\n+        niceBackReferenceLength, maxCandidates, lazyThreshold;\n+    private final boolean lazyMatching;\n \n     private Parameters(int windowSize, int minBackReferenceLength, int maxBackReferenceLength, int maxOffset,\n-        int maxLiteralLength, int niceBackReferenceLength, int maxCandidates) {\n+            int maxLiteralLength, int niceBackReferenceLength, int maxCandidates, boolean lazyMatching,\n+            int lazyThreshold) {\n         this.windowSize = windowSize;\n         this.minBackReferenceLength = minBackReferenceLength;\n         this.maxBackReferenceLength = maxBackReferenceLength;\n         this.maxLiteralLength = maxLiteralLength;\n         this.niceBackReferenceLength = niceBackReferenceLength;\n         this.maxCandidates = maxCandidates;\n+        this.lazyMatching = lazyMatching;\n+        this.lazyThreshold = lazyThreshold;\n     }\n \n     /**\n         return maxCandidates;\n     }\n \n+    /**\n+     * Gets whether to perform lazy matching.\n+     */\n+    public boolean getLazyMatching() {\n+        return lazyMatching;\n+    }\n+\n+    /**\n+     * Gets the threshold for lazy matching.\n+     */\n+    public int getLazyMatchingThreshold() {\n+        return lazyThreshold;\n+    }\n+\n     private static final boolean isPowerOfTwo(int x) {\n         // pre-condition: x > 0\n         return (x & (x - 1)) == 0;", "timestamp": 1491131394, "metainfo": ""}