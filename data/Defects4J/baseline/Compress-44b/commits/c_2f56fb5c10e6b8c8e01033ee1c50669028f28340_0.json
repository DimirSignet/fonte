{"sha": "2f56fb5c10e6b8c8e01033ee1c50669028f28340", "log": "ByteBuffer looks convenient but is slow (manual method is 50% faster)", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java\n \n import static java.lang.Integer.rotateLeft;\n \n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n import java.util.zip.Checksum;\n+\n+import static org.apache.commons.compress.utils.ByteUtils.fromLittleEndian;\n \n /**\n  * Implementation of the xxhash32 hash algorithm.\n \n     private final byte[] oneByte = new byte[1];\n     private final int[] state = new int[4];\n-    private final ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE).order(ByteOrder.LITTLE_ENDIAN);\n+    private final byte[] buffer = new byte[BUF_SIZE];\n     private final int seed;\n \n     private int totalLen;\n     @Override\n     public void reset() {\n         initializeState();\n-        buffer.clear();\n         totalLen = 0;\n         pos = 0;\n     }\n         final int end = off + len;\n \n         if (pos + len < BUF_SIZE) {\n-            buffer.put(b, off, len);\n+            System.arraycopy(b, off, buffer, pos, len);\n             pos += len;\n             return;\n         }\n \n         if (pos > 0) {\n             final int size = BUF_SIZE - pos;\n-            buffer.put(b, off, size);\n+            System.arraycopy(b, off, buffer, pos, size);\n             process();\n             off += size;\n         }\n \n         final int limit = end - BUF_SIZE;\n         while (off <= limit) {\n-            buffer.put(b, off, BUF_SIZE);\n+            System.arraycopy(b, off, buffer, 0, BUF_SIZE);\n             process();\n             off += BUF_SIZE;\n         }\n \n         if (off < end) {\n             pos = end - off;\n-            buffer.put(b, off, pos);\n+            System.arraycopy(b, off, buffer, 0, pos);\n         }\n     }\n \n         }\n         hash += totalLen;\n \n-        buffer.flip();\n-\n         int idx = 0;\n         final int limit = pos - 4;\n         for (; idx <= limit; idx += 4) {\n-            hash = rotateLeft(hash + buffer.getInt() * PRIME3, 17) * PRIME4;\n+            hash = rotateLeft(hash + getInt(idx) * PRIME3, 17) * PRIME4;\n         }\n         while (idx < pos) {\n-            hash = rotateLeft(hash + (buffer.get() & 0xff) * PRIME5, 11) * PRIME1;\n-            idx++;\n+            hash = rotateLeft(hash + (buffer[idx++] & 0xff) * PRIME5, 11) * PRIME1;\n         }\n \n         hash ^= hash >>> 15;\n         return hash & 0xffffffffl;\n     }\n \n+    private int getInt(int idx) {\n+        return (int) (fromLittleEndian(buffer, idx, 4) & 0xffffffffl);\n+    }\n+\n     private void initializeState() {\n         state[0] = seed + PRIME1 + PRIME2;\n         state[1] = seed + PRIME2;\n     }\n \n     private void process() {\n-        buffer.flip();\n-\n         // local shadows for performance\n         int s0 = state[0];\n         int s1 = state[1];\n         int s2 = state[2];\n         int s3 = state[3];\n \n-        s0 = rotateLeft(s0 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n-        s1 = rotateLeft(s1 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n-        s2 = rotateLeft(s2 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n-        s3 = rotateLeft(s3 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n+        s0 = rotateLeft(s0 + getInt(0) * PRIME2, ROTATE_BITS) * PRIME1;\n+        s1 = rotateLeft(s1 + getInt(4) * PRIME2, ROTATE_BITS) * PRIME1;\n+        s2 = rotateLeft(s2 + getInt(8) * PRIME2, ROTATE_BITS) * PRIME1;\n+        s3 = rotateLeft(s3 + getInt(12) * PRIME2, ROTATE_BITS) * PRIME1;\n \n         state[0] = s0;\n         state[1] = s1;\n         state[2] = s2;\n         state[3] = s3;\n \n-        buffer.clear();\n         pos = 0;\n     }\n }", "timestamp": 1488036475, "metainfo": ""}