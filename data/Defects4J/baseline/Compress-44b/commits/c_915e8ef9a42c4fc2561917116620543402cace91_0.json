{"sha": "915e8ef9a42c4fc2561917116620543402cace91", "log": "COMPRESS-179 TarUtils.formatLongOctalOrBinaryBytes() assumes the field will be 12 bytes long  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n     int    GIDLEN = 8;\n \n     /**\n+     * The maximum value of gid/uid in a tar archive which can\n+     * be expressed in octal char notation (that's 7 sevens, octal).\n+     * @since 1.4\n+     */\n+    long    MAXID = 07777777L;\n+ \n+    /**\n      * The length of the checksum field in a header buffer.\n      */\n     int    CHKSUMLEN = 8;\n     int    SIZELEN = 12;\n \n     /**\n-     * The maximum size of a file in a tar archive (That's 11 sevens, octal).\n+     * The maximum size of a file in a tar archive \n+     * which can be expressed in octal char notation (that's 11 sevens, octal).\n      */\n     long   MAXSIZE = 077777777777L;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n     public static int formatLongOctalOrBinaryBytes(\n         final long value, byte[] buf, final int offset, final int length) {\n \n-        if (value < TarConstants.MAXSIZE + 1) {\n+        // Check whether we are dealing with UID/GID or SIZE field\n+        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n+\n+        if (value <= maxAsOctalChar) { // OK to store as octal chars\n             return formatLongOctalBytes(value, buf, offset, length);\n         }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n         }\n     }\n \n-    private void checkRoundTripOctal(final long value) {\n-        byte [] buffer = new byte[12];\n+    private void checkRoundTripOctal(final long value, final int bufsize) {\n+        byte [] buffer = new byte[bufsize];\n         long parseValue;\n         TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n         parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n         assertEquals(value,parseValue);\n     }\n     \n+    private void checkRoundTripOctal(final long value) {\n+        checkRoundTripOctal(value, TarConstants.SIZELEN);\n+    }\n+\n     public void testRoundTripOctal() {\n         checkRoundTripOctal(0);\n         checkRoundTripOctal(1);\n //        checkRoundTripOctal(-1); // TODO What should this do?\n-        checkRoundTripOctal(077777777777L);\n+        checkRoundTripOctal(TarConstants.MAXSIZE);\n //        checkRoundTripOctal(0100000000000L); // TODO What should this do?\n+\n+        checkRoundTripOctal(0, TarConstants.UIDLEN);\n+        checkRoundTripOctal(1, TarConstants.UIDLEN);\n+        checkRoundTripOctal(TarConstants.MAXID, 8);\n+    }\n+\n+    private void checkRoundTripOctalOrBinary(final long value, final int bufsize) {\n+        byte [] buffer = new byte[bufsize];\n+        long parseValue;\n+        TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);\n+        parseValue = TarUtils.parseOctalOrBinary(buffer,0, buffer.length);\n+        assertEquals(value,parseValue);\n+    }\n+\n+    public void testRoundTripOctalOrBinary() {\n+        checkRoundTripOctalOrBinary(0, 8);\n+        checkRoundTripOctalOrBinary(1, 8);\n+        checkRoundTripOctalOrBinary(Long.MAX_VALUE, 8); // [0x7f ff ff ff ff ff ff ff\n+        checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, 8); // will need binary format\n     }\n     \n     // Check correct trailing bytes are generated", "timestamp": 1329957375, "metainfo": ""}