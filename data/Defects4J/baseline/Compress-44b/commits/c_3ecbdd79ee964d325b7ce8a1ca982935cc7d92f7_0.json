{"sha": "3ecbdd79ee964d325b7ce8a1ca982935cc7d92f7", "log": "Merge remote-tracking branch 'apache/master' into COMPRESS-382  # Conflicts: #\tsrc/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java #\tsrc/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n      */\n     public ArchiveInputStream createArchiveInputStream(final InputStream in)\n             throws ArchiveException {\n+        return createArchiveInputStream(detect(in), in);\n+    }\n+\n+    /**\n+     * Try to determine the type of Archiver\n+     * @param in input stream\n+     * @return type of archiver if found\n+     * @throws ArchiveException if an archiver cannot be detected in the stream\n+     * @since 1.14\n+     */\n+    public static String detect(InputStream in) throws ArchiveException {\n         if (in == null) {\n             throw new IllegalArgumentException(\"Stream must not be null.\");\n         }\n \n         final byte[] signature = new byte[SIGNATURE_SIZE];\n         in.mark(signature.length);\n+        int signatureLength = -1;\n         try {\n-            int signatureLength = IOUtils.readFully(in, signature);\n+            signatureLength = IOUtils.readFully(in, signature);\n             in.reset();\n-            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(ZIP, in);\n-            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(JAR, in);\n-            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(AR, in);\n-            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(CPIO, in);\n-            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(ARJ, in);\n-            } else if (SevenZFile.matches(signature, signatureLength)) {\n-                throw new StreamingNotSupportedException(SEVEN_Z);\n-            }\n-\n-            // Dump needs a bigger buffer to check the signature;\n-            final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n-            in.mark(dumpsig.length);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading signature.\");\n+        }\n+\n+        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n+            return ZIP;\n+        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n+            return JAR;\n+        } if (ArArchiveInputStream.matches(signature, signatureLength)) {\n+            return AR;\n+        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n+            return CPIO;\n+        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n+            return ARJ;\n+        } else if (SevenZFile.matches(signature, signatureLength)) {\n+            return SEVEN_Z;\n+        }\n+\n+        // Dump needs a bigger buffer to check the signature;\n+        final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n+        in.mark(dumpsig.length);\n+        try {\n             signatureLength = IOUtils.readFully(in, dumpsig);\n             in.reset();\n-            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-                return createArchiveInputStream(DUMP, in);\n-            }\n-\n-            // Tar needs an even bigger buffer to check the signature; read the first block\n-            final byte[] tarHeader = new byte[TAR_HEADER_SIZE];\n-            in.mark(tarHeader.length);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading dump signature\");\n+        }\n+        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+            return DUMP;\n+        }\n+\n+        // Tar needs an even bigger buffer to check the signature; read the first block\n+        final byte[] tarHeader = new byte[TAR_HEADER_SIZE];\n+        in.mark(tarHeader.length);\n+        try {\n             signatureLength = IOUtils.readFully(in, tarHeader);\n             in.reset();\n-            if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\n-                return createArchiveInputStream(TAR, in);\n-            }\n-            // COMPRESS-117 - improve auto-recognition\n-            if (signatureLength >= TAR_HEADER_SIZE) {\n-                TarArchiveInputStream tais = null;\n-                try {\n-                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader));\n-                    // COMPRESS-191 - verify the header checksum\n-                    if (tais.getNextTarEntry().isCheckSumOK()) {\n-                        return createArchiveInputStream(TAR, in);\n-                    }\n-                } catch (final Exception e) { // NOPMD\n-                    // can generate IllegalArgumentException as well\n-                    // as IOException\n-                    // autodetection, simply not a TAR\n-                    // ignored\n-                } finally {\n-                    IOUtils.closeQuietly(tais);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading tar signature\");\n+        }\n+        if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\n+            return TAR;\n+        }\n+\n+        // COMPRESS-117 - improve auto-recognition\n+        if (signatureLength >= TAR_HEADER_SIZE) {\n+            TarArchiveInputStream tais = null;\n+            try {\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader));\n+                // COMPRESS-191 - verify the header checksum\n+                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                    return TAR;\n                 }\n-            }\n-        } catch (final IOException e) {\n-            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n-        }\n-\n+            } catch (final Exception e) { // NOPMD\n+                // can generate IllegalArgumentException as well\n+                // as IOException\n+                // autodetection, simply not a TAR\n+                // ignored\n+            } finally {\n+                IOUtils.closeQuietly(tais);\n+            }\n+        }\n         throw new ArchiveException(\"No Archiver found for the stream signature\");\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      */\n     private volatile boolean decompressConcatenated = false;\n \n-    private volatile int lzmaMemoryLimitKb = -1;\n-\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n         this.decompressConcatenated = decompressUntilEOF;\n     }\n \n+    /**\n+     * Try to detect the type of compressor stream.\n+     *\n+     * @param in input stream\n+     * @return type of compressor stream detected\n+     * @throws CompressorException if no compressor stream type was detected\n+     *                             or if something else went wrong\n+     * @throws IllegalArgumentException if stream is null or does not support mark\n+     *\n+     * @since 1.14\n+     */\n+    public static String detect(final InputStream in) throws CompressorException {\n+        if (in == null) {\n+            throw new IllegalArgumentException(\"Stream must not be null.\");\n+        }\n+\n+        if (!in.markSupported()) {\n+            throw new IllegalArgumentException(\"Mark is not supported.\");\n+        }\n+\n+        final byte[] signature = new byte[12];\n+        in.mark(signature.length);\n+        int signatureLength = -1;\n+        try {\n+            signatureLength = IOUtils.readFully(in, signature);\n+            in.reset();\n+        } catch (IOException e) {\n+            throw new CompressorException(\"IOException while reading signature.\", e);\n+        }\n+\n+        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n+            return BZIP2;\n+        }\n+\n+        if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n+            return GZIP;\n+        }\n+\n+        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n+            return PACK200;\n+        }\n+\n+        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n+            return SNAPPY_FRAMED;\n+        }\n+\n+        if (ZCompressorInputStream.matches(signature, signatureLength)) {\n+            return Z;\n+        }\n+\n+        if (DeflateCompressorInputStream.matches(signature, signatureLength)) {\n+            return DEFLATE;\n+        }\n+\n+        if (XZUtils.matches(signature, signatureLength)) {\n+            return XZ;\n+        }\n+\n+        if (LZMAUtils.matches(signature, signatureLength)) {\n+            return LZMA;\n+        }\n+\n+        if (FramedLZ4CompressorInputStream.matches(signature, signatureLength)) {\n+            return LZ4_FRAMED;\n+        }\n+\n+        throw new CompressorException(\"No Compressor found for the stream signature.\");\n+    }\n     /**\n      * Create an compressor input stream from an input stream, autodetecting the\n      * compressor type from the first few bytes of the stream. The InputStream\n      * @since 1.1\n      */\n     public CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {\n-        if (in == null) {\n-            throw new IllegalArgumentException(\"Stream must not be null.\");\n-        }\n-\n-        if (!in.markSupported()) {\n-            throw new IllegalArgumentException(\"Mark is not supported.\");\n-        }\n-\n-        final byte[] signature = new byte[12];\n-        in.mark(signature.length);\n-        try {\n-            final int signatureLength = IOUtils.readFully(in, signature);\n-            in.reset();\n-\n-            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n-                return new BZip2CompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n-                return new GzipCompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n-                return new Pack200CompressorInputStream(in);\n-            }\n-\n-            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n-                return new FramedSnappyCompressorInputStream(in);\n-            }\n-\n-            if (ZCompressorInputStream.matches(signature, signatureLength)) {\n-                return new ZCompressorInputStream(in);\n-            }\n-\n-            if (DeflateCompressorInputStream.matches(signature, signatureLength)) {\n-                return new DeflateCompressorInputStream(in);\n-            }\n-\n-            if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {\n-                return new XZCompressorInputStream(in, decompressConcatenated);\n-            }\n-\n-            if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {\n-                return new LZMACompressorInputStream(in, lzmaMemoryLimitKb);\n-            }\n-\n-            if (FramedLZ4CompressorInputStream.matches(signature, signatureLength)) {\n-                return new FramedLZ4CompressorInputStream(in);\n-            }\n-\n-        } catch (final IOException e) {\n-            throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n-        }\n-\n-        throw new CompressorException(\"No Compressor found for the stream signature.\");\n+        return createCompressorInputStream(detect(in), in);\n     }\n \n     /**\n      *            the input stream\n      * @return compressor input stream\n      * @throws CompressorException\n-     *             if the compressor name is not known\n+     *             if the compressor name is not known or not available\n      * @throws IllegalArgumentException\n      *             if the name or input stream is null\n      */\n             }\n \n             if (XZ.equalsIgnoreCase(name)) {\n+                if (!XZUtils.isXZCompressionAvailable()) {\n+                    throw new CompressorException(\"XZ compression is not available.\");\n+                }\n                 return new XZCompressorInputStream(in, actualDecompressConcatenated);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n+                if (!LZMAUtils.isLZMACompressionAvailable()) {\n+                    throw new CompressorException(\"LZMA compression is not available\");\n+                }\n                 return new LZMACompressorInputStream(in);\n             }\n \n         }\n         this.decompressConcatenated = decompressConcatenated;\n     }\n-\n-    /**\n-     * Set the maximum calculated memory usage for LZMA\n-     * in KB.\n-     *\n-     * @param lzmaMemoryLimitKb\n-     */\n-    public void setLzmaMemoryLimitKb(int lzmaMemoryLimitKb) {\n-        this.lzmaMemoryLimitKb = lzmaMemoryLimitKb;\n-    }\n+    \n }\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n             if (properties != null) {\n                 p.properties().putAll(properties);\n             }\n-            JarInputStream ji = null;\n-            boolean success = false;\n-            try {\n-                ji = new JarInputStream(streamBridge.getInput());\n+            try (JarInputStream ji = new JarInputStream(streamBridge.getInput())) {\n                 p.pack(ji, originalOutput);\n-                success = true;\n-            } finally {\n-                if (!success) {\n-                    IOUtils.closeQuietly(ji);\n-                }\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n import java.io.File;\n import java.io.FileReader;\n import java.io.FilenameFilter;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Collection;\n \n public class ArchiveReadTest extends AbstractTestCase {\n \n     private static final ClassLoader CLASSLOADER = ArchiveReadTest.class.getClassLoader();\n-    private static final File ARCDIR = new File(CLASSLOADER.getResource(\"archives\").getFile());\n+    private static final File ARCDIR;\n     private static final ArrayList<String> FILELIST = new ArrayList<>();\n+\n+    static {\n+        try {\n+            ARCDIR = new File(CLASSLOADER.getResource(\"archives\").toURI());\n+        } catch (URISyntaxException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n \n     private final File file;\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/MockEvilInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Simple mock InputStream that always throws an IOException\n+ * when {@link #read()} or {@link #read(byte[], int, int)}\n+ * is called.\n+ */\n+public class MockEvilInputStream extends InputStream {\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new IOException(\"Evil\");\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int offset, int length) throws IOException {\n+        throw new IOException(\"Evil\");\n+    }\n+}\n+\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n import java.io.InputStream;\n import java.lang.reflect.Field;\n \n+import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\n         DUMP_DEFAULT = dflt;\n     }\n \n+    @Test\n+    public void testDetect() throws Exception {\n+        for (String extension : new String[]{\n+                ArchiveStreamFactory.AR,\n+                ArchiveStreamFactory.ARJ,\n+                ArchiveStreamFactory.CPIO,\n+                ArchiveStreamFactory.DUMP,\n+                // Compress doesn't know how to detect JARs, see COMPRESS-91\n+ //               ArchiveStreamFactory.JAR,\n+                ArchiveStreamFactory.SEVEN_Z,\n+                ArchiveStreamFactory.TAR,\n+                ArchiveStreamFactory.ZIP\n+        }) {\n+            assertEquals(extension, detect(\"bla.\"+extension));\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n+            fail(\"shouldn't be able to detect empty stream\");\n+        } catch (ArchiveException e) {\n+            assertEquals(\"No Archiver found for the stream signature\", e.getMessage());\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(null);\n+            fail(\"shouldn't be able to detect null stream\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Stream must not be null.\", e.getMessage());\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(new BufferedInputStream(new MockEvilInputStream()));\n+            fail(\"Expected ArchiveException\");\n+        } catch (ArchiveException e) {\n+            assertEquals(\"IOException while reading signature.\", e.getMessage());\n+        }\n+    }\n+\n+    private String detect(String resource) throws IOException, ArchiveException {\n+        try(InputStream in = new BufferedInputStream(new FileInputStream(\n+                getFile(resource)))) {\n+            return ArchiveStreamFactory.detect(in);\n+        }\n+    }\n+\n     static final TestData[] TESTS = {\n         new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, ARJ_DEFAULT, FACTORY, \"charsetName\"),\n         new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"UTF-8\", FACTORY_UTF8, \"charsetName\"),\n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n import java.io.FileInputStream;\n import java.io.FileReader;\n import java.io.FilenameFilter;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Collection;\n \n import junit.framework.AssertionFailedError;\n-\n import org.apache.commons.compress.AbstractTestCase;\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n public class LongPathTest extends AbstractTestCase {\n \n     private static final ClassLoader CLASSLOADER = LongPathTest.class.getClassLoader();\n-    private static final File ARCDIR = new File(CLASSLOADER.getResource(\"longpath\").getFile());\n+    private static final File ARCDIR;\n     private static final ArrayList<String> FILELIST = new ArrayList<>();\n \n+    static {\n+        try {\n+            ARCDIR = new File(CLASSLOADER.getResource(\"longpath\").toURI());\n+        } catch (URISyntaxException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n     private final File file;\n+\n+\n \n     public LongPathTest(final String file){\n         this.file = new File(ARCDIR, file);\n--- a/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n import java.io.FileInputStream;\n import java.io.FileReader;\n import java.io.FilenameFilter;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Collection;\n \n import junit.framework.AssertionFailedError;\n-\n import org.apache.commons.compress.AbstractTestCase;\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n public class LongSymLinkTest extends AbstractTestCase {\n \n     private static final ClassLoader CLASSLOADER = LongSymLinkTest.class.getClassLoader();\n-    private static final File ARCDIR = new File(CLASSLOADER.getResource(\"longsymlink\").getFile());\n+    private static final File ARCDIR;\n     private static final ArrayList<String> FILELIST = new ArrayList<>();\n+\n+    static {\n+        try {\n+            ARCDIR = new File(CLASSLOADER.getResource(\"longsymlink\").toURI());\n+        } catch (URISyntaxException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n \n     private final File file;\n \n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n import org.junit.Test;\n-import org.tukaani.xz.MemoryLimitException;\n \n @SuppressWarnings(\"deprecation\") // deliberately tests setDecompressConcatenated\n public final class DetectCompressorTestCase {\n         } catch (final CompressorException e) {\n             // expected\n         }\n+    }\n+\n+    @Test\n+    public void testDetect() throws Exception {\n+\n+        assertEquals(CompressorStreamFactory.BZIP2, detect(\"bla.txt.bz2\"));\n+        assertEquals(CompressorStreamFactory.GZIP, detect(\"bla.tgz\"));\n+        assertEquals(CompressorStreamFactory.PACK200, detect(\"bla.pack\"));\n+        assertEquals(CompressorStreamFactory.XZ, detect(\"bla.tar.xz\"));\n+        assertEquals(CompressorStreamFactory.DEFLATE, detect(\"bla.tar.deflatez\"));\n+        assertEquals(CompressorStreamFactory.LZ4_FRAMED, detect(\"bla.tar.lz4\"));\n+        assertEquals(CompressorStreamFactory.LZMA, detect(\"bla.tar.lzma\"));\n+        assertEquals(CompressorStreamFactory.SNAPPY_FRAMED, detect(\"bla.tar.sz\"));\n+        assertEquals(CompressorStreamFactory.Z, detect(\"bla.tar.Z\"));\n+\n+        try {\n+            CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n+            fail(\"shouldn't be able to detect empty stream\");\n+        } catch (CompressorException e) {\n+            assertEquals(\"No Compressor found for the stream signature.\", e.getMessage());\n+        }\n+\n+        try {\n+            CompressorStreamFactory.detect(null);\n+            fail(\"shouldn't be able to detect null stream\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Stream must not be null.\", e.getMessage());\n+        }\n+\n+        try {\n+            CompressorStreamFactory.detect(new BufferedInputStream(new MockEvilInputStream()));\n+            fail(\"Expected IOException\");\n+        } catch (CompressorException e) {\n+            assertEquals(\"IOException while reading signature.\", e.getMessage());\n+        }\n+\n+\n+    }\n+\n+    private String detect(String testFileName) throws IOException, CompressorException {\n+        String name = null;\n+        try (InputStream is = new BufferedInputStream(\n+                new FileInputStream(getFile(testFileName)))) {\n+            name = CompressorStreamFactory.detect(is);\n+        }\n+        return name;\n     }\n \n     @Test\n         }\n     }\n \n-    @Test\n-    public void testLZMAMemoryLimit() throws Exception {\n-        CompressorStreamFactory compressorStreamFactory = new CompressorStreamFactory();\n-        compressorStreamFactory.setLzmaMemoryLimitKb(500);\n-        try {\n-            InputStream is = compressorStreamFactory.createCompressorInputStream(\n-                    new BufferedInputStream(new FileInputStream(getFile(\"COMPRESS-382\"))));\n-            fail(\"Should have thrown memory limit exception\");\n-        } catch (CompressorException e) {\n-            assertTrue(e.getCause() instanceof MemoryLimitException);\n-        }\n-    }\n-\n     private CompressorInputStream getStreamFor(final String resource)\n             throws CompressorException, IOException {\n         return factory.createCompressorInputStream(\n                    new BufferedInputStream(new FileInputStream(\n                        getFile(resource))));\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n public class LZMACompressorInputStream extends CompressorInputStream {\n     private final InputStream in;\n \n+    public LZMACompressorInputStream(final InputStream inputStream)\n+            throws IOException {\n+        in = new LZMAInputStream(inputStream, -1);\n+    }\n+\n     /**\n      * Creates a new input stream that decompresses LZMA-compressed data\n      * from the specified input stream.\n      *\n      * @param       inputStream where to read the compressed data\n      *\n+     * @param       memoryLimitKb calculated memory use threshold.  Throws MemoryLimitException\n+     *                            if calculate memory use is above this threshold\n+     *\n      * @throws      IOException if the input is not in the .lzma format,\n      *                          the input is corrupt or truncated, the .lzma\n      *                          headers specify sizes that are not supported\n      *                          by this implementation, or the underlying\n      *                          <code>inputStream</code> throws an exception\n+     *\n+     * @since 1.14\n      */\n-    public LZMACompressorInputStream(final InputStream inputStream)\n+    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitKb)\n             throws IOException {\n-        in = new LZMAInputStream(inputStream);\n+        in = new LZMAInputStream(inputStream, memoryLimitKb);\n     }\n \n     /** {@inheritDoc} */", "timestamp": 1492798959, "metainfo": ""}