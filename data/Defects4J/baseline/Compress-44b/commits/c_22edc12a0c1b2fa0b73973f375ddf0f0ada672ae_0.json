{"sha": "22edc12a0c1b2fa0b73973f375ddf0f0ada672ae", "log": "[COMPRESS-369]  Allow archive extensions through a standard JRE ServiceLoader.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n import org.apache.commons.compress.utils.IOUtils;\n+import org.apache.commons.compress.utils.Lists;\n+import org.apache.commons.compress.utils.ServiceLoaderIterator;\n+import org.apache.commons.compress.utils.Sets;\n \n /**\n  * Factory to create Archive[In|Out]putStreams from names or the first bytes of\n  * @Immutable provided that the deprecated method setEntryEncoding is not used.\n  * @ThreadSafe even if the deprecated method setEntryEncoding is used\n  */\n-public class ArchiveStreamFactory {\n-\n+public class ArchiveStreamFactory implements ArchiveStreamProvider {\n+\n+    private static final ArchiveStreamFactory SINGLETON = new ArchiveStreamFactory();\n+    \n     /**\n      * Constant (value {@value}) used to identify the AR archive format.\n      * @since 1.1\n     /**\n      * Entry encoding, null for the default.\n      */\n-    private volatile String entryEncoding = null;\n+    private volatile String entryEncoding;\n+\n+    private SortedMap<String, ArchiveStreamProvider> archiveInputStreamProviders;\n+\n+    private SortedMap<String, ArchiveStreamProvider> archiveOutputStreamProviders;\n+\n+    private static ArrayList<ArchiveStreamProvider> findArchiveStreamProviders() {\n+        return Lists.newArrayList(serviceLoaderIterator());\n+    }\n+\n+    static void putAll(Set<String> names, ArchiveStreamProvider provider,\n+            TreeMap<String, ArchiveStreamProvider> map) {\n+        for (String name : names) {\n+            map.put(toKey(name), provider);\n+        }\n+    }\n+    private static Iterator<ArchiveStreamProvider> serviceLoaderIterator() {\n+        return new ServiceLoaderIterator<>(ArchiveStreamProvider.class);\n+    }\n+\n+    private static String toKey(final String name) {\n+        return name.toUpperCase(Locale.ROOT);\n+    }\n+\n+    /**\n+     * Constructs a new sorted map from input stream provider names to provider\n+     * objects.\n+     *\n+     * <p>\n+     * The map returned by this method will have one entry for each provider for\n+     * which support is available in the current Java virtual machine. If two or\n+     * more supported provider have the same name then the resulting map will\n+     * contain just one of them; which one it will contain is not specified.\n+     * </p>\n+     *\n+     * <p>\n+     * The invocation of this method, and the subsequent use of the resulting\n+     * map, may cause time-consuming disk or network I/O operations to occur.\n+     * This method is provided for applications that need to enumerate all of\n+     * the available providers, for example to allow user provider selection.\n+     * </p>\n+     *\n+     * <p>\n+     * This method may return different results at different times if new\n+     * providers are dynamically made available to the current Java virtual\n+     * machine.\n+     * </p>\n+     *\n+     * @return An immutable, map from names to provider objects\n+     * @since 1.13\n+     */\n+    public static SortedMap<String, ArchiveStreamProvider> findAvailableArchiveInputStreamProviders() {\n+        return AccessController.doPrivileged(new PrivilegedAction<SortedMap<String, ArchiveStreamProvider>>() {\n+            @Override\n+            public SortedMap<String, ArchiveStreamProvider> run() {\n+                TreeMap<String, ArchiveStreamProvider> map = new TreeMap<>();\n+                putAll(SINGLETON.getInputStreamArchiveNames(), SINGLETON, map);\n+                for (ArchiveStreamProvider provider : findArchiveStreamProviders()) {\n+                    putAll(provider.getInputStreamArchiveNames(), provider, map);\n+                }\n+                return map;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Constructs a new sorted map from output stream provider names to provider\n+     * objects.\n+     *\n+     * <p>\n+     * The map returned by this method will have one entry for each provider for\n+     * which support is available in the current Java virtual machine. If two or\n+     * more supported provider have the same name then the resulting map will\n+     * contain just one of them; which one it will contain is not specified.\n+     * </p>\n+     *\n+     * <p>\n+     * The invocation of this method, and the subsequent use of the resulting\n+     * map, may cause time-consuming disk or network I/O operations to occur.\n+     * This method is provided for applications that need to enumerate all of\n+     * the available providers, for example to allow user provider selection.\n+     * </p>\n+     *\n+     * <p>\n+     * This method may return different results at different times if new\n+     * providers are dynamically made available to the current Java virtual\n+     * machine.\n+     * </p>\n+     *\n+     * @return An immutable, map from names to provider objects\n+     * @since 1.13\n+     */\n+    public static SortedMap<String, ArchiveStreamProvider> findAvailableArchiveOutputStreamProviders() {\n+        return AccessController.doPrivileged(new PrivilegedAction<SortedMap<String, ArchiveStreamProvider>>() {\n+            @Override\n+            public SortedMap<String, ArchiveStreamProvider> run() {\n+                TreeMap<String, ArchiveStreamProvider> map = new TreeMap<>();\n+                putAll(SINGLETON.getOutputStreamArchiveNames(), SINGLETON, map);\n+                for (ArchiveStreamProvider provider : findArchiveStreamProviders()) {\n+                    putAll(provider.getOutputStreamArchiveNames(), provider, map);\n+                }\n+                return map;\n+            }\n+        });\n+    }\n \n     /**\n      * Create an instance using the platform default encoding.\n     }\n \n     /**\n-     * Create an archive input stream from an archiver name and an input stream.\n+     * Creates an archive input stream from an archiver name and an input stream.\n      * \n      * @param archiverName the archive name,\n      * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}\n      * read from a stream\n      * @throws IllegalArgumentException if the archiver name or stream is null\n      */\n-    public ArchiveInputStream createArchiveInputStream(\n-            final String archiverName, final InputStream in)\n+    public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in)\n             throws ArchiveException {\n+        return createArchiveInputStream(archiverName, in, entryEncoding);\n+    }\n+    \n+    @Override\n+    public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in,\n+            final String actualEncoding) throws ArchiveException {\n \n         if (archiverName == null) {\n             throw new IllegalArgumentException(\"Archivername must not be null.\");\n             return new ArArchiveInputStream(in);\n         }\n         if (ARJ.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new ArjArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new ArjArchiveInputStream(in, actualEncoding);\n             }\n             return new ArjArchiveInputStream(in);\n         }\n         if (ZIP.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new ZipArchiveInputStream(in, actualEncoding);\n             }\n             return new ZipArchiveInputStream(in);\n         }\n         if (TAR.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new TarArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new TarArchiveInputStream(in, actualEncoding);\n             }\n             return new TarArchiveInputStream(in);\n         }\n         if (JAR.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new JarArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new JarArchiveInputStream(in, actualEncoding);\n             }\n             return new JarArchiveInputStream(in);\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new CpioArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new CpioArchiveInputStream(in, actualEncoding);\n             }\n             return new CpioArchiveInputStream(in);\n         }\n         if (DUMP.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new DumpArchiveInputStream(in, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new DumpArchiveInputStream(in, actualEncoding);\n             }\n             return new DumpArchiveInputStream(in);\n         }\n             throw new StreamingNotSupportedException(SEVEN_Z);\n         }\n \n+        final ArchiveStreamProvider archiveStreamProvider = getArchiveInputStreamProviders().get(toKey(archiverName));\n+        if (archiveStreamProvider != null) {\n+            return archiveStreamProvider.createArchiveInputStream(archiverName, in, actualEncoding);\n+        }\n+\n         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n     }\n \n     /**\n-     * Create an archive output stream from an archiver name and an output stream.\n+     * Creates an archive output stream from an archiver name and an output stream.\n      * \n      * @param archiverName the archive name,\n      * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n      * written to a stream\n      * @throws IllegalArgumentException if the archiver name or stream is null\n      */\n+    public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out)\n+            throws ArchiveException {\n+        return createArchiveOutputStream(archiverName, out, entryEncoding);\n+    }\n+    \n+    @Override\n     public ArchiveOutputStream createArchiveOutputStream(\n-            final String archiverName, final OutputStream out)\n+            final String archiverName, final OutputStream out, final String actualEncoding)\n             throws ArchiveException {\n         if (archiverName == null) {\n             throw new IllegalArgumentException(\"Archivername must not be null.\");\n         }\n         if (ZIP.equalsIgnoreCase(archiverName)) {\n             final ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n-            if (entryEncoding != null) {\n-                zip.setEncoding(entryEncoding);\n+            if (actualEncoding != null) {\n+                zip.setEncoding(actualEncoding);\n             }\n             return zip;\n         }\n         if (TAR.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new TarArchiveOutputStream(out, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new TarArchiveOutputStream(out, actualEncoding);\n             }\n             return new TarArchiveOutputStream(out);\n         }\n         if (JAR.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new JarArchiveOutputStream(out, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new JarArchiveOutputStream(out, actualEncoding);\n             }\n             return new JarArchiveOutputStream(out);\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new CpioArchiveOutputStream(out, entryEncoding);\n+            if (actualEncoding != null) {\n+                return new CpioArchiveOutputStream(out, actualEncoding);\n             }\n             return new CpioArchiveOutputStream(out);\n         }\n         if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n         }\n+\n+        final ArchiveStreamProvider archiveStreamProvider = getArchiveOutputStreamProviders().get(toKey(archiverName));\n+        if (archiveStreamProvider != null) {\n+            return archiveStreamProvider.createArchiveOutputStream(archiverName, out, actualEncoding);\n+        }\n+\n         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n     }\n \n         throw new ArchiveException(\"No Archiver found for the stream signature\");\n     }\n \n+    public SortedMap<String, ArchiveStreamProvider> getArchiveInputStreamProviders() {\n+        if (archiveInputStreamProviders == null) {\n+            archiveInputStreamProviders = Collections\n+                    .unmodifiableSortedMap(findAvailableArchiveInputStreamProviders());\n+        }\n+        return archiveInputStreamProviders;\n+    }\n+\n+    public SortedMap<String, ArchiveStreamProvider> getArchiveOutputStreamProviders() {\n+        if (archiveOutputStreamProviders == null) {\n+            archiveOutputStreamProviders = Collections\n+                    .unmodifiableSortedMap(findAvailableArchiveOutputStreamProviders());\n+        }\n+        return archiveOutputStreamProviders;\n+    }\n+\n+    @Override\n+    public Set<String> getInputStreamArchiveNames() {\n+        return Sets.newHashSet(AR, ARJ, ZIP, TAR, JAR, CPIO, DUMP, SEVEN_Z);\n+    }\n+\n+    @Override\n+    public Set<String> getOutputStreamArchiveNames() {\n+        return Sets.newHashSet(AR, ZIP, TAR, JAR, CPIO, SEVEN_Z);\n+    }\n+\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Set;\n+\n+/**\n+ * Creates Archive {@link ArchiveInputStream}s and {@link ArchiveOutputStream}s.\n+ * \n+ * @since 1.13\n+ */\n+public interface ArchiveStreamProvider {\n+\n+    /**\n+     * Creates an archive input stream from an archiver name and an input\n+     * stream.\n+     * \n+     * @param archiverName\n+     *            the archive name, i.e. {@value #AR}, {@value #ARJ},\n+     *            {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO},\n+     *            {@value #DUMP} or {@value #SEVEN_Z}\n+     * @param in\n+     *            the input stream\n+     * @return the archive input stream\n+     * @throws ArchiveException\n+     *             if the archiver name is not known\n+     * @throws StreamingNotSupportedException\n+     *             if the format cannot be read from a stream\n+     * @throws IllegalArgumentException\n+     *             if the archiver name or stream is null\n+     */\n+    ArchiveInputStream createArchiveInputStream(final String name, final InputStream in, final String encoding)\n+            throws ArchiveException;\n+\n+    /**\n+     * Creates an archive output stream from an archiver name and an output\n+     * stream.\n+     * \n+     * @param archiverName\n+     *            the archive name, i.e. {@value #AR}, {@value #ZIP},\n+     *            {@value #TAR}, {@value #JAR} or {@value #CPIO}\n+     * @param out\n+     *            the output stream\n+     * @return the archive output stream\n+     * @throws ArchiveException\n+     *             if the archiver name is not known\n+     * @throws StreamingNotSupportedException\n+     *             if the format cannot be written to a stream\n+     * @throws IllegalArgumentException\n+     *             if the archiver name or stream is null\n+     */\n+    ArchiveOutputStream createArchiveOutputStream(final String name, final OutputStream out, final String encoding)\n+            throws ArchiveException;\n+\n+    /**\n+     * Gets all the input stream archive names for this provider\n+     * \n+     * @return all the input archive names for this provider\n+     */\n+    Set<String> getInputStreamArchiveNames();\n+\n+    /**\n+     * Gets all the output stream archive names for this provider\n+     * \n+     * @return all the output archive names for this provider\n+     */\n+    Set<String> getOutputStreamArchiveNames();\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveServiceLoaderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+import org.apache.commons.compress.archivers.TestArchiveStreamProvider.ArchiveInvocationConfirmationException;\n+import org.junit.Test;\n+\n+public class ArchiveServiceLoaderTest {\n+\n+    @Test(expected = ArchiveInvocationConfirmationException.class)\n+    public void testInputStream() throws ArchiveException {\n+        new ArchiveStreamFactory().createArchiveInputStream(\"ArchiveTestInput1\", new ByteArrayInputStream(new byte[] {}));\n+    }\n+\n+    @Test(expected = ArchiveInvocationConfirmationException.class)\n+    public void testOutputStream() throws ArchiveException {\n+        new ArchiveStreamFactory().createArchiveOutputStream(\"ArchiveTestOutput1\", new ByteArrayOutputStream());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/TestArchiveStreamProvider.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class TestArchiveStreamProvider implements ArchiveStreamProvider {\n+\n+    public static final class ArchiveInvocationConfirmationException extends ArchiveException {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public ArchiveInvocationConfirmationException(final String message) {\n+            super(message);\n+        }\n+    }\n+\n+    @Override\n+    public ArchiveInputStream createArchiveInputStream(final String name, final InputStream in, final String encoding) throws ArchiveException {\n+        throw new ArchiveInvocationConfirmationException(name);\n+    }\n+\n+    @Override\n+    public ArchiveOutputStream createArchiveOutputStream(final String name, final OutputStream out, final String encoding) throws ArchiveException {\n+        throw new ArchiveInvocationConfirmationException(name);\n+    }\n+\n+    @Override\n+    public Set<String> getInputStreamArchiveNames() {\n+        final HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, \"ArchiveTestInput1\");\n+        return set;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputStreamArchiveNames() {\n+        final HashSet<String> set = new HashSet<>();\n+        Collections.addAll(set, \"ArchiveTestOutput1\");\n+        return set;\n+    }\n+\n+}", "timestamp": 1479276579, "metainfo": ""}