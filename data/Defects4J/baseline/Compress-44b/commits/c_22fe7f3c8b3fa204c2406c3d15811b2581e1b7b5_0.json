{"sha": "22fe7f3c8b3fa204c2406c3d15811b2581e1b7b5", "log": "[COMPRESS-392] Add Brotli decoder based on the Google Brotli library.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/brotli/BrotliCompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.brotli;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * {@link FilterInputStream} implementation to decode Brotli encoded stream.\n+ * Library relies on <a href=\"https://github.com/google/brotli\">Google brotli</a>\n+ * \n+ * @since 1.14\n+ */\n+public class BrotliCompressorInputStream extends CompressorInputStream {\n+    \n+    private org.brotli.dec.BrotliInputStream decIS;\n+\n+    public BrotliCompressorInputStream(InputStream in) throws IOException {\n+        this.decIS = new org.brotli.dec.BrotliInputStream(in);\n+    }\n+\n+    /**\n+     * @return\n+     * @throws IOException\n+     * @see java.io.InputStream#available()\n+     */\n+    public int available() throws IOException {\n+        return decIS.available();\n+    }\n+\n+    /**\n+     * @throws IOException\n+     * @see org.brotli.dec.BrotliInputStream#close()\n+     */\n+    public void close() throws IOException {\n+        decIS.close();\n+    }\n+\n+    /**\n+     * @return\n+     * @see java.lang.Object#hashCode()\n+     */\n+    public int hashCode() {\n+        return decIS.hashCode();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] b) throws IOException {\n+        return decIS.read(b);\n+    }\n+\n+    /**\n+     * @param obj\n+     * @return\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    public boolean equals(Object obj) {\n+        return decIS.equals(obj);\n+    }\n+\n+    /**\n+     * @param n\n+     * @return\n+     * @throws IOException\n+     * @see java.io.InputStream#skip(long)\n+     */\n+    public long skip(long n) throws IOException {\n+        return decIS.skip(n);\n+    }\n+\n+    /**\n+     * @param readlimit\n+     * @see java.io.InputStream#mark(int)\n+     */\n+    public void mark(int readlimit) {\n+        decIS.mark(readlimit);\n+    }\n+\n+    /**\n+     * @return\n+     * @see java.io.InputStream#markSupported()\n+     */\n+    public boolean markSupported() {\n+        return decIS.markSupported();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        final int ret = decIS.read();\n+        count(ret == -1 ? 0 : 1);\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        final int ret = decIS.read(buf, off, len);\n+        count(ret);\n+        return ret;\n+    }\n+\n+    /**\n+     * @return\n+     * @see java.lang.Object#toString()\n+     */\n+    public String toString() {\n+        return decIS.toString();\n+    }\n+\n+    /**\n+     * @throws IOException\n+     * @see java.io.InputStream#reset()\n+     */\n+    public void reset() throws IOException {\n+        decIS.reset();\n+    }\n+    \n+\n+    /**\n+     * There is no magic for Brotli\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true\n+     */\n+    static boolean matches(final byte[] signature, final int length) {\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/brotli/BrotliUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.brotli;\n+\n+/**\n+ * Utility code for the Brotli compression format.\n+ * @ThreadSafe\n+ * @since 1.14\n+ */\n+public class BrotliUtils {\n+\n+    static enum CachedAvailability {\n+        DONT_CACHE, CACHED_AVAILABLE, CACHED_UNAVAILABLE\n+    }\n+\n+    private static volatile CachedAvailability cachedBrotliAvailability;\n+\n+    static {\n+        cachedBrotliAvailability = CachedAvailability.DONT_CACHE;\n+        try {\n+            Class.forName(\"org.osgi.framework.BundleEvent\");\n+        } catch (final Exception ex) {\n+            setCacheBrotliAvailablity(true);\n+        }\n+    }\n+\n+    /** Private constructor to prevent instantiation of this utility class. */\n+    private BrotliUtils() {\n+    }\n+\n+\n+    /**\n+     * Are the classes required to support Brotli compression available?\n+     * @return true if the classes required to support Brotli compression are available\n+     */\n+    public static boolean isBrotliCompressionAvailable() {\n+        final CachedAvailability cachedResult = cachedBrotliAvailability;\n+        if (cachedResult != CachedAvailability.DONT_CACHE) {\n+            return cachedResult == CachedAvailability.CACHED_AVAILABLE;\n+        }\n+        return internalIsBrotliCompressionAvailable();\n+    }\n+\n+    private static boolean internalIsBrotliCompressionAvailable() {\n+        try {\n+            return BrotliCompressorInputStream.matches(null, 0);\n+        } catch (final NoClassDefFoundError error) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Whether to cache the result of the Brotli for Java check.\n+     *\n+     * <p>This defaults to {@code false} in an OSGi environment and {@code true} otherwise.</p>\n+     * @param doCache whether to cache the result\n+     */\n+    public static void setCacheBrotliAvailablity(final boolean doCache) {\n+        if (!doCache) {\n+            cachedBrotliAvailability = CachedAvailability.DONT_CACHE;\n+        } else if (cachedBrotliAvailability == CachedAvailability.DONT_CACHE) {\n+            final boolean hasXz = internalIsBrotliCompressionAvailable();\n+            cachedBrotliAvailability = hasXz ? CachedAvailability.CACHED_AVAILABLE\n+                : CachedAvailability.CACHED_UNAVAILABLE;\n+        }\n+    }\n+\n+    // only exists to support unit tests\n+    static CachedAvailability getCachedBrotliAvailability() {\n+        return cachedBrotliAvailability;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/brotli/BrotliCompressorInputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.brotli;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BrotliCompressorInputStreamTest {\n+\n+    /**\n+     * Test bridge works fine \n+     * @throws {@link IOException}\n+     */\n+    @Test\n+    public void testBrotliDecode() throws IOException {\n+        final File input = AbstractTestCase.getFile(\"brotli.testdata.compressed\");\n+        final File expected = AbstractTestCase.getFile(\"brotli.testdata.uncompressed\");\n+        try (InputStream inputStream = new FileInputStream(input);\n+                InputStream expectedStream = new FileInputStream(expected);\n+                BrotliCompressorInputStream brotliInputStream = new BrotliCompressorInputStream(inputStream)) {\n+            final byte[] b = new byte[20];\n+            IOUtils.readFully(expectedStream, b);\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            int readByte = -1;\n+            while((readByte = brotliInputStream.read()) != -1) {\n+                bos.write(readByte);\n+            }\n+            Assert.assertArrayEquals(b, bos.toByteArray());\n+        } \n+    }\n+    \n+    @Test\n+    public void testCachingIsEnabledByDefaultAndXZIsPresent() {\n+        assertEquals(BrotliUtils.CachedAvailability.CACHED_AVAILABLE, BrotliUtils.getCachedBrotliAvailability());\n+        assertTrue(BrotliUtils.isBrotliCompressionAvailable());\n+    }\n+\n+    @Test\n+    public void testCanTurnOffCaching() {\n+        try {\n+            BrotliUtils.setCacheBrotliAvailablity(false);\n+            assertEquals(BrotliUtils.CachedAvailability.DONT_CACHE, BrotliUtils.getCachedBrotliAvailability());\n+            assertTrue(BrotliUtils.isBrotliCompressionAvailable());\n+        } finally {\n+            BrotliUtils.setCacheBrotliAvailablity(true);\n+        }\n+    }\n+\n+    @Test\n+    public void testTurningOnCachingReEvaluatesAvailability() {\n+        try {\n+            BrotliUtils.setCacheBrotliAvailablity(false);\n+            assertEquals(BrotliUtils.CachedAvailability.DONT_CACHE, BrotliUtils.getCachedBrotliAvailability());\n+            BrotliUtils.setCacheBrotliAvailablity(true);\n+            assertEquals(BrotliUtils.CachedAvailability.CACHED_AVAILABLE, BrotliUtils.getCachedBrotliAvailability());\n+        } finally {\n+            BrotliUtils.setCacheBrotliAvailablity(true);\n+        }\n+    }\n+    \n+\n+    @Test\n+    public void availableShouldReturnZero() throws IOException {\n+        final File input = AbstractTestCase.getFile(\"brotli.testdata.compressed\");\n+        try (InputStream is = new FileInputStream(input)) {\n+            final BrotliCompressorInputStream in =\n+                    new BrotliCompressorInputStream(is);\n+            Assert.assertTrue(in.available() == 0);\n+            in.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToSkipAByte() throws IOException {\n+        final File input = AbstractTestCase.getFile(\"brotli.testdata.compressed\");\n+        try (InputStream is = new FileInputStream(input)) {\n+            final BrotliCompressorInputStream in =\n+                    new BrotliCompressorInputStream(is);\n+            Assert.assertEquals(1, in.skip(1));\n+            in.close();\n+        }\n+    }\n+\n+    @Test\n+    public void singleByteReadWorksAsExpected() throws IOException {\n+        final File input = AbstractTestCase.getFile(\"brotli.testdata.compressed\");\n+        try (InputStream is = new FileInputStream(input)) {\n+            final BrotliCompressorInputStream in =\n+                    new BrotliCompressorInputStream(is);\n+            //  starts with filename \"XXX\"\n+            Assert.assertEquals('X', in.read());\n+            in.close();\n+        }\n+    }\n+\n+    @Test\n+    public void singleByteReadReturnsMinusOneAtEof() throws IOException {\n+        final File input = AbstractTestCase.getFile(\"brotli.testdata.compressed\");\n+        try (InputStream is = new FileInputStream(input)) {\n+            final BrotliCompressorInputStream in =\n+                    new BrotliCompressorInputStream(is);\n+            IOUtils.toByteArray(in);\n+            Assert.assertEquals(-1, in.read());\n+            in.close();\n+        }\n+    }\n+}", "timestamp": 1493753035, "metainfo": ""}