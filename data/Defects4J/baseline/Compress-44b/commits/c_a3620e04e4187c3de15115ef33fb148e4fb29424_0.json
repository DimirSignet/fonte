{"sha": "a3620e04e4187c3de15115ef33fb148e4fb29424", "log": "refactor Snappy to use the same decompress code as LZ4", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.compressors.lz77support.AbstractLZ77CompressorInputStream;\n import org.apache.commons.compress.utils.ByteUtils;\n import org.apache.commons.compress.utils.IOUtils;\n \n  * @see <a href=\"https://github.com/google/snappy/blob/master/format_description.txt\">Snappy compressed format description</a>\n  * @since 1.7\n  */\n-public class SnappyCompressorInputStream extends CompressorInputStream {\n+public class SnappyCompressorInputStream extends AbstractLZ77CompressorInputStream {\n \n     /** Mask used to determine the type of \"tag\" is being processed */\n     private static final int TAG_MASK = 0x03;\n     /** Default block size */\n     public static final int DEFAULT_BLOCK_SIZE = 32768;\n \n-    /** Buffer to write decompressed bytes to for back-references */\n-    private final byte[] decompressBuf;\n-\n-    /** One behind the index of the last byte in the buffer that was written */\n-    private int writeIndex;\n-\n-    /** Index of the next byte to be read. */\n-    private int readIndex;\n-\n-    /** The actual block size specified */\n-    private final int blockSize;\n-\n-    /** The underlying stream to read compressed data from */\n-    private final InputStream in;\n-\n     /** The size of the uncompressed data */\n     private final int size;\n \n     /** Number of uncompressed bytes still to be read. */\n     private int uncompressedBytesRemaining;\n \n-    // used in no-arg read method\n-    private final byte[] oneByte = new byte[1];\n+    /** Current state of the stream */\n+    private State state = State.NO_BLOCK;\n \n     private boolean endReached = false;\n-\n-    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n-        @Override\n-        public int getAsByte() throws IOException {\n-            return readOneByte();\n-        }\n-    };\n \n     /**\n      * Constructor using the default buffer size of 32k.\n      */\n     public SnappyCompressorInputStream(final InputStream is, final int blockSize)\n             throws IOException {\n-        this.in = is;\n-        this.blockSize = blockSize;\n-        this.decompressBuf = new byte[blockSize * 3];\n-        this.writeIndex = readIndex = 0;\n+        super(is, blockSize);\n         uncompressedBytesRemaining = size = (int) readSize();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int read() throws IOException {\n-        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void close() throws IOException {\n-        in.close();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int available() {\n-        return writeIndex - readIndex;\n     }\n \n     /**\n         if (endReached) {\n             return -1;\n         }\n-        final int avail = available();\n-        if (len > avail) {\n-            fill(len - avail);\n-        }\n-\n-        final int readable = Math.min(len, available());\n-        if (readable == 0 && len > 0) {\n-            return -1;\n-        }\n-        System.arraycopy(decompressBuf, readIndex, b, off, readable);\n-        readIndex += readable;\n-        if (readIndex > 2 * blockSize) {\n-            slideBuffer();\n-        }\n-        return readable;\n+        switch (state) {\n+        case NO_BLOCK:\n+            fill(len);\n+            return read(b, off, len);\n+        case IN_LITERAL:\n+            int litLen = readLiteral(b, off, len);\n+            if (!hasMoreDataInBlock()) {\n+                state = State.NO_BLOCK;\n+            }\n+            return litLen;\n+        case IN_COPY:\n+            int copyLen = readCopy(b, off, len);\n+            if (!hasMoreDataInBlock()) {\n+                state = State.NO_BLOCK;\n+            }\n+            return copyLen;\n+        default:\n+            throw new IOException(\"Unknown stream state \" + state);\n+        }\n     }\n \n     /**\n     private void fill(final int len) throws IOException {\n         if (uncompressedBytesRemaining == 0) {\n             endReached = true;\n-        }\n-        int readNow = Math.min(len, uncompressedBytesRemaining);\n-\n-        while (readNow > 0) {\n-            final int b = readOneByte();\n+            return;\n+        }\n+\n+            int b = readOneByte();\n+            if (b == -1) {\n+                throw new IOException(\"Premature end of stream reading block start\");\n+            }\n             int length = 0;\n-            long offset = 0;\n+            int offset = 0;\n \n             switch (b & TAG_MASK) {\n \n \n                 length = readLiteralLength(b);\n                 uncompressedBytesRemaining -= length;\n-\n-                if (expandLiteral(length)) {\n-                    return;\n-                }\n+                startLiteral(length);\n+                state = State.IN_LITERAL;\n                 break;\n \n             case 0x01:\n                 length = 4 + ((b >> 2) & 0x07);\n                 uncompressedBytesRemaining -= length;\n                 offset = (b & 0xE0) << 3;\n-                offset |= readOneByte();\n-\n-                if (expandCopy(offset, length)) {\n-                    return;\n+                b = readOneByte();\n+                if (b == -1) {\n+                    throw new IOException(\"Premature end of stream reading copy length\");\n                 }\n+                offset |= b;\n+\n+                startCopy(offset, length);\n+                state = State.IN_COPY;\n                 break;\n \n             case 0x02:\n                 length = (b >> 2) + 1;\n                 uncompressedBytesRemaining -= length;\n \n-                offset = ByteUtils.fromLittleEndian(supplier, 2);\n-\n-                if (expandCopy(offset, length)) {\n-                    return;\n-                }\n+                offset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n+\n+                startCopy(offset, length);\n+                state = State.IN_COPY;\n                 break;\n \n             case 0x03:\n                 length = (b >> 2) + 1;\n                 uncompressedBytesRemaining -= length;\n \n-                offset = ByteUtils.fromLittleEndian(supplier, 4);\n-\n-                if (expandCopy(offset, length)) {\n-                    return;\n-                }\n-                break;\n-            }\n-\n-            readNow -= length;\n-        }\n-    }\n-\n-    /**\n-     * Slide buffer.\n-     *\n-     * <p>Move all bytes of the buffer after the first block down to\n-     * the beginning of the buffer.</p>\n-     */\n-    private void slideBuffer() {\n-        System.arraycopy(decompressBuf, blockSize, decompressBuf, 0,\n-                         blockSize * 2);\n-        writeIndex -= blockSize;\n-        readIndex -= blockSize;\n-    }\n-\n+                offset = (int) ByteUtils.fromLittleEndian(supplier, 4) & 0x7fffffff;\n+\n+                startCopy(offset, length);\n+                state = State.IN_COPY;\n+                break;\n+            }\n+    }\n \n     /*\n      * For literals up to and including 60 bytes in length, the\n         switch (b >> 2) {\n         case 60:\n             length = readOneByte();\n+            if (length == -1) {\n+                throw new IOException(\"Premature end of stream reading literal length\");\n+            }\n             break;\n         case 61:\n             length = (int) ByteUtils.fromLittleEndian(supplier, 2);\n         }\n \n         return length + 1;\n-    }\n-\n-    /**\n-     * Literals are uncompressed data stored directly in the byte stream.\n-     * \n-     * @param length\n-     *            The number of bytes to read from the underlying stream\n-     * \n-     * @throws IOException\n-     *             If the first byte cannot be read for any reason other than\n-     *             end of file, or if the input stream has been closed, or if\n-     *             some other I/O error occurs.\n-     * @return True if the decompressed data should be flushed\n-     */\n-    private boolean expandLiteral(final int length) throws IOException {\n-        boolean shouldFlush = ensureBufferSpace(length);\n-        final int bytesRead = IOUtils.readFully(in, decompressBuf, writeIndex, length);\n-        count(bytesRead);\n-        if (length != bytesRead) {\n-            throw new IOException(\"Premature end of stream\");\n-        }\n-\n-        writeIndex += length;\n-        return shouldFlush || writeIndex >= 2 * this.blockSize;\n-    }\n-\n-    private boolean ensureBufferSpace(final int length) {\n-        if (writeIndex + length >= decompressBuf.length) {\n-            slideBuffer();\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Copies are references back into previous decompressed data, telling the\n-     * decompressor to reuse data it has previously decoded. They encode two\n-     * values: The offset, saying how many bytes back from the current position\n-     * to read, and the length, how many bytes to copy. Offsets of zero can be\n-     * encoded, but are not legal; similarly, it is possible to encode\n-     * backreferences that would go past the end of the block (offset > current\n-     * decompressed position), which is also nonsensical and thus not allowed.\n-     * \n-     * @param off\n-     *            The offset from the backward from the end of expanded stream\n-     * @param length\n-     *            The number of bytes to copy\n-     * \n-     * @throws IOException\n-     *             An the offset expands past the front of the decompression\n-     *             buffer\n-     * @return True if the decompressed data should be flushed\n-     */\n-    private boolean expandCopy(final long off, final int length) throws IOException {\n-        if (off > blockSize) {\n-            throw new IOException(\"Offset \" + off + \" is larger than block size \" + blockSize);\n-        }\n-        final int offset = (int) off;\n-        boolean shouldFlush = ensureBufferSpace(length);\n-\n-        if (offset == 1) {\n-            final byte lastChar = decompressBuf[writeIndex - 1];\n-            for (int i = 0; i < length; i++) {\n-                decompressBuf[writeIndex++] = lastChar;\n-            }\n-        } else if (length < offset) {\n-            System.arraycopy(decompressBuf, writeIndex - offset,\n-                    decompressBuf, writeIndex, length);\n-            writeIndex += length;\n-        } else {\n-            int fullRotations = length / offset;\n-            final int pad = length - (offset * fullRotations);\n-\n-            while (fullRotations-- != 0) {\n-                System.arraycopy(decompressBuf, writeIndex - offset,\n-                        decompressBuf, writeIndex, offset);\n-                writeIndex += offset;\n-            }\n-\n-            if (pad > 0) {\n-                System.arraycopy(decompressBuf, writeIndex - offset,\n-                        decompressBuf, writeIndex, pad);\n-\n-                writeIndex += pad;\n-            }\n-        }\n-        return shouldFlush || writeIndex >= 2 * this.blockSize;\n-    }\n-\n-    /**\n-     * This helper method reads the next byte of data from the input stream. The\n-     * value byte is returned as an <code>int</code> in the range <code>0</code>\n-     * to <code>255</code>. If no byte is available because the end of the\n-     * stream has been reached, an Exception is thrown.\n-     * \n-     * @return The next byte of data\n-     * @throws IOException\n-     *             EOF is reached or error reading the stream\n-     */\n-    private int readOneByte() throws IOException {\n-        final int b = in.read();\n-        if (b == -1) {\n-            throw new IOException(\"Premature end of stream\");\n-        }\n-        count(1);\n-        return b & 0xFF;\n     }\n \n     /**\n \n         do {\n             b = readOneByte();\n+            if (b == -1) {\n+                throw new IOException(\"Premature end of stream reading size\");\n+            }\n             sz |= (b & 0x7f) << (index++ * 7);\n         } while (0 != (b & 0x80));\n         return sz;\n      * \n      * @return the uncompressed size\n      */\n+    @Override\n     public int getSize() {\n         return size;\n     }\n \n+    private enum State {\n+        NO_BLOCK, IN_LITERAL, IN_COPY\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n             assertEquals(3, in.available()); // remainder of first uncompressed block\n             assertEquals(3, in.read(new byte[5], 0, 3));\n             assertEquals('5', in.read());\n-            assertEquals(4, in.available()); // remainder of literal\n+            assertEquals(0, in.available()); // end of chunk, must read next one\n             assertEquals(4, in.read(new byte[5], 0, 4));\n             assertEquals('5', in.read());\n-            assertEquals(19, in.available()); // remainder of copy\n             in.close();\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/compressors/snappy/SnappyRoundtripTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/SnappyRoundtripTest.java\n         }\n         System.err.println(input.getName() + \" written, uncompressed bytes: \" + input.length()\n             + \", compressed bytes: \" + outputSz.length() + \" after \" + (System.currentTimeMillis() - start) + \"ms\");\n+        start = System.currentTimeMillis();\n         try (FileInputStream is = new FileInputStream(input);\n              SnappyCompressorInputStream sis = new SnappyCompressorInputStream(new FileInputStream(outputSz),\n                  params.getWindowSize())) {\n             byte[] actual = IOUtils.toByteArray(sis);\n             Assert.assertArrayEquals(expected, actual);\n         }\n+        System.err.println(outputSz.getName() + \" read after \" + (System.currentTimeMillis() - start) + \"ms\");\n     }\n \n     // should yield decent compression", "timestamp": 1484685841, "metainfo": ""}