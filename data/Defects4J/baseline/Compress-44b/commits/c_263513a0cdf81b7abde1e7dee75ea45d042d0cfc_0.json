{"sha": "263513a0cdf81b7abde1e7dee75ea45d042d0cfc", "log": "[COMPRESS-368]   Allow compressor extensions through a standard JRE ServiceLoader. Sort methods.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n     public static final String DEFLATE = \"deflate\";\n \n     /**\n-     * If true, decompress until the end of the input. If false, stop after the\n-     * first stream and leave the input position to point to the next byte after\n-     * the stream\n-     */\n-    private final Boolean decompressUntilEOF;\n-    // This is Boolean so setDecompressConcatenated can determine whether it has\n-    // been set by the ctor\n-    // once the setDecompressConcatenated method has been removed, it can revert\n-    // to boolean\n-\n-    // Thread-local gate to prevent recursive provider lookups\n-    private SortedMap<String, CompressorStreamProvider> compressorInputStreamProviders;\n-    private SortedMap<String, CompressorStreamProvider> compressorOutputStreamProviders;\n-    \n-    /**\n-     * If true, decompress until the end of the input. If false, stop after the\n-     * first stream and leave the input position to point to the next byte after\n-     * the stream\n-     */\n-    private volatile boolean decompressConcatenated = false;\n-\n-    static void putAll(Set<String> names, CompressorStreamProvider provider,\n-            TreeMap<String, CompressorStreamProvider> map) {\n-        for (String name : names) {\n-            map.put(toKey(name), provider);\n-        }\n-    }\n-\n-    /**\n      * Constructs a new sorted map from input stream provider names to provider\n      * objects.\n      *\n \n         });\n     }\n-\n-    @Override\n-    public Set<String> getInputStreamCompressorNames() {\n-        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, SNAPPY_RAW, SNAPPY_FRAMED, Z, DEFLATE);\n-    }\n-\n-    @Override\n-    public Set<String> getOutputStreamCompressorNames() {\n-        return Sets.newHashSet(GZIP, BZIP2, XZ, PACK200, DEFLATE);\n+    private static ArrayList<CompressorStreamProvider> findCompressorStreamProviders() {\n+        return Lists.newArrayList(serviceLoaderIterator());\n+    }\n+    \n+    public static String getBzip2() {\n+        return BZIP2;\n+    }\n+\n+    public static String getDeflate() {\n+        return DEFLATE;\n+    }\n+\n+    public static String getGzip() {\n+        return GZIP;\n+    }\n+\n+    public static String getLzma() {\n+        return LZMA;\n+    }\n+\n+    public static String getPack200() {\n+        return PACK200;\n+    }\n+\n+    public static CompressorStreamFactory getSingleton() {\n+        return SINGLETON;\n+    }\n+\n+    public static String getSnappyFramed() {\n+        return SNAPPY_FRAMED;\n+    }\n+\n+    public static String getSnappyRaw() {\n+        return SNAPPY_RAW;\n+    }\n+\n+    public static String getXz() {\n+        return XZ;\n+    }\n+\n+    public static String getZ() {\n+        return Z;\n+    }\n+\n+    static void putAll(Set<String> names, CompressorStreamProvider provider,\n+            TreeMap<String, CompressorStreamProvider> map) {\n+        for (String name : names) {\n+            map.put(toKey(name), provider);\n+        }\n     }\n \n     private static Iterator<CompressorStreamProvider> serviceLoaderIterator() {\n         return new ServiceLoaderIterator<>(CompressorStreamProvider.class);\n     }\n \n-    private static ArrayList<CompressorStreamProvider> findCompressorStreamProviders() {\n-        return Lists.newArrayList(serviceLoaderIterator());\n-    }\n+    private static String toKey(final String name) {\n+        return name.toUpperCase(Locale.ROOT);\n+    }\n+\n+    /**\n+     * If true, decompress until the end of the input. If false, stop after the\n+     * first stream and leave the input position to point to the next byte after\n+     * the stream\n+     */\n+    private final Boolean decompressUntilEOF;\n+    // This is Boolean so setDecompressConcatenated can determine whether it has\n+    // been set by the ctor\n+    // once the setDecompressConcatenated method has been removed, it can revert\n+    // to boolean\n+\n+    // Thread-local gate to prevent recursive provider lookups\n+    private SortedMap<String, CompressorStreamProvider> compressorInputStreamProviders;\n+\n+    private SortedMap<String, CompressorStreamProvider> compressorOutputStreamProviders;\n+    \n+    /**\n+     * If true, decompress until the end of the input. If false, stop after the\n+     * first stream and leave the input position to point to the next byte after\n+     * the stream\n+     */\n+    private volatile boolean decompressConcatenated = false;\n \n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n         // Also copy to existing variable so can continue to use that as the\n         // current value\n         this.decompressConcatenated = decompressUntilEOF;\n-    }\n-\n-    /**\n-     * Whether to decompress the full input or only the first stream in formats\n-     * supporting multiple concatenated input streams.\n-     *\n-     * <p>\n-     * This setting applies to the gzip, bzip2 and xz formats only.\n-     * </p>\n-     *\n-     * @param decompressConcatenated\n-     *            if true, decompress until the end of the input; if false, stop\n-     *            after the first stream and leave the input position to point\n-     *            to the next byte after the stream\n-     * @since 1.5\n-     * @deprecated 1.10 use the {@link #CompressorStreamFactory(boolean)}\n-     *             constructor instead\n-     * @throws IllegalStateException\n-     *             if the constructor {@link #CompressorStreamFactory(boolean)}\n-     *             was used to create the factory\n-     */\n-    @Deprecated\n-    public void setDecompressConcatenated(final boolean decompressConcatenated) {\n-        if (this.decompressUntilEOF != null) {\n-            throw new IllegalStateException(\"Cannot override the setting defined by the constructor\");\n-        }\n-        this.decompressConcatenated = decompressConcatenated;\n     }\n \n     /**\n         throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n     }\n \n-    private static String toKey(final String name) {\n-        return name.toUpperCase(Locale.ROOT);\n-    }\n-\n     /**\n      * Creates an compressor output stream from an compressor name and an output\n      * stream.\n         throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n     }\n \n-    // For Unit tests\n-    boolean getDecompressConcatenated() {\n-        return decompressConcatenated;\n-    }\n-    \n-    public static CompressorStreamFactory getSingleton() {\n-        return SINGLETON;\n-    }\n-\n-    public static String getBzip2() {\n-        return BZIP2;\n-    }\n-\n-    public static String getGzip() {\n-        return GZIP;\n-    }\n-\n-    public static String getPack200() {\n-        return PACK200;\n-    }\n-\n-    public static String getXz() {\n-        return XZ;\n-    }\n-\n-    public static String getLzma() {\n-        return LZMA;\n-    }\n-\n-    public static String getSnappyFramed() {\n-        return SNAPPY_FRAMED;\n-    }\n-\n-    public static String getSnappyRaw() {\n-        return SNAPPY_RAW;\n-    }\n-\n-    public static String getZ() {\n-        return Z;\n-    }\n-\n-    public static String getDeflate() {\n-        return DEFLATE;\n-    }\n-\n-    public Boolean getDecompressUntilEOF() {\n-        return decompressUntilEOF;\n-    }\n-\n     public SortedMap<String, CompressorStreamProvider> getCompressorInputStreamProviders() {\n         if (compressorInputStreamProviders == null) {\n             compressorInputStreamProviders = Collections\n         }\n         return compressorOutputStreamProviders;\n     }\n+\n+    // For Unit tests\n+    boolean getDecompressConcatenated() {\n+        return decompressConcatenated;\n+    }\n+\n+    public Boolean getDecompressUntilEOF() {\n+        return decompressUntilEOF;\n+    }\n+\n+    @Override\n+    public Set<String> getInputStreamCompressorNames() {\n+        return Sets.newHashSet(GZIP, BZIP2, XZ, LZMA, PACK200, SNAPPY_RAW, SNAPPY_FRAMED, Z, DEFLATE);\n+    }\n+\n+    @Override\n+    public Set<String> getOutputStreamCompressorNames() {\n+        return Sets.newHashSet(GZIP, BZIP2, XZ, PACK200, DEFLATE);\n+    }\n+\n+    /**\n+     * Whether to decompress the full input or only the first stream in formats\n+     * supporting multiple concatenated input streams.\n+     *\n+     * <p>\n+     * This setting applies to the gzip, bzip2 and xz formats only.\n+     * </p>\n+     *\n+     * @param decompressConcatenated\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream\n+     * @since 1.5\n+     * @deprecated 1.10 use the {@link #CompressorStreamFactory(boolean)}\n+     *             constructor instead\n+     * @throws IllegalStateException\n+     *             if the constructor {@link #CompressorStreamFactory(boolean)}\n+     *             was used to create the factory\n+     */\n+    @Deprecated\n+    public void setDecompressConcatenated(final boolean decompressConcatenated) {\n+        if (this.decompressUntilEOF != null) {\n+            throw new IllegalStateException(\"Cannot override the setting defined by the constructor\");\n+        }\n+        this.decompressConcatenated = decompressConcatenated;\n+    }\n     \n }", "timestamp": 1479272453, "metainfo": ""}