{"sha": "2cf575115748e9865daaa369507019141573b86c", "log": "COMPRESS-385, add ArchiveStreamFactory; undo boneheaded RELEASE-NOTES.txt fiasco.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n      */\n     public ArchiveInputStream createArchiveInputStream(final InputStream in)\n             throws ArchiveException {\n+        return createArchiveInputStream(detect(in), in);\n+    }\n+\n+    /**\n+     * Try to determine the type of Archiver\n+     * @param in input stream\n+     * @return type of archiver if found\n+     * @throws ArchiveException if an archiver cannot be detected in the stream\n+     */\n+    public static String detect(InputStream in) throws ArchiveException {\n         if (in == null) {\n             throw new IllegalArgumentException(\"Stream must not be null.\");\n         }\n \n         final byte[] signature = new byte[SIGNATURE_SIZE];\n         in.mark(signature.length);\n+        int signatureLength = -1;\n         try {\n-            int signatureLength = IOUtils.readFully(in, signature);\n+            signatureLength = IOUtils.readFully(in, signature);\n             in.reset();\n-            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(ZIP, in);\n-            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(JAR, in);\n-            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(AR, in);\n-            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(CPIO, in);\n-            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n-                return createArchiveInputStream(ARJ, in);\n-            } else if (SevenZFile.matches(signature, signatureLength)) {\n-                throw new StreamingNotSupportedException(SEVEN_Z);\n-            }\n-\n-            // Dump needs a bigger buffer to check the signature;\n-            final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n-            in.mark(dumpsig.length);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading signature.\");\n+        }\n+\n+        if (JarArchiveInputStream.matches(signature, signatureLength)) {\n+            return JAR;\n+        } else if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n+            return ZIP;\n+        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n+            return AR;\n+        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n+            return CPIO;\n+        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n+            return ARJ;\n+        } else if (SevenZFile.matches(signature, signatureLength)) {\n+            throw new StreamingNotSupportedException(SEVEN_Z);\n+        }\n+\n+        // Dump needs a bigger buffer to check the signature;\n+        final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n+        in.mark(dumpsig.length);\n+        try {\n             signatureLength = IOUtils.readFully(in, dumpsig);\n             in.reset();\n-            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-                return createArchiveInputStream(DUMP, in);\n-            }\n-\n-            // Tar needs an even bigger buffer to check the signature; read the first block\n-            final byte[] tarHeader = new byte[TAR_HEADER_SIZE];\n-            in.mark(tarHeader.length);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading dump signature\");\n+        }\n+        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+            return DUMP;\n+        }\n+\n+        // Tar needs an even bigger buffer to check the signature; read the first block\n+        final byte[] tarHeader = new byte[TAR_HEADER_SIZE];\n+        in.mark(tarHeader.length);\n+        try {\n             signatureLength = IOUtils.readFully(in, tarHeader);\n             in.reset();\n-            if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\n-                return createArchiveInputStream(TAR, in);\n-            }\n-            // COMPRESS-117 - improve auto-recognition\n-            if (signatureLength >= TAR_HEADER_SIZE) {\n-                TarArchiveInputStream tais = null;\n-                try {\n-                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader));\n-                    // COMPRESS-191 - verify the header checksum\n-                    if (tais.getNextTarEntry().isCheckSumOK()) {\n-                        return createArchiveInputStream(TAR, in);\n-                    }\n-                } catch (final Exception e) { // NOPMD\n-                    // can generate IllegalArgumentException as well\n-                    // as IOException\n-                    // autodetection, simply not a TAR\n-                    // ignored\n-                } finally {\n-                    IOUtils.closeQuietly(tais);\n+        } catch (IOException e) {\n+            throw new ArchiveException(\"IOException while reading tar signature\");\n+        }\n+        if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\n+            return TAR;\n+        }\n+\n+        // COMPRESS-117 - improve auto-recognition\n+        if (signatureLength >= TAR_HEADER_SIZE) {\n+            TarArchiveInputStream tais = null;\n+            try {\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader));\n+                // COMPRESS-191 - verify the header checksum\n+                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                    return TAR;\n                 }\n-            }\n-        } catch (final IOException e) {\n-            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n-        }\n-\n+            } catch (final Exception e) { // NOPMD\n+                // can generate IllegalArgumentException as well\n+                // as IOException\n+                // autodetection, simply not a TAR\n+                // ignored\n+            } finally {\n+                IOUtils.closeQuietly(tais);\n+            }\n+        }\n         throw new ArchiveException(\"No Archiver found for the stream signature\");\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n             signatureLength = IOUtils.readFully(in, signature);\n             in.reset();\n         } catch (IOException e) {\n-            throw new CompressorException(\"Failed while reading signature from InputStream.\", e);\n+            throw new CompressorException(\"IOException while reading signature.\", e);\n         }\n \n         if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/MockEvilInputStream.java\n+package org.apache.commons.compress;/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Simple mock InputStream that always throws an IOException\n+ * when {@link #read()} or {@link #read(byte[], int, int)}\n+ * is called.\n+ */\n+public class MockEvilInputStream extends InputStream {\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new IOException(\"Evil\");\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int offset, int length) throws IOException {\n+        throw new IOException(\"Evil\");\n+    }\n+}\n+\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n import java.io.InputStream;\n import java.lang.reflect.Field;\n \n+import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\n         DUMP_DEFAULT = dflt;\n     }\n \n+    @Test\n+    public void testDetect() throws Exception {\n+        for (String extension : new String[]{\n+                ArchiveStreamFactory.ARJ,\n+                ArchiveStreamFactory.CPIO,\n+                ArchiveStreamFactory.DUMP,\n+                ArchiveStreamFactory.JAR,\n+                ArchiveStreamFactory.TAR,\n+ //TODO-- figure out how to differentiate btwn JAR and ZIP\n+ //               ArchiveStreamFactory.ZIP\n+        }) {\n+            assertEquals(extension, detect(\"bla.\"+extension));\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n+            fail(\"shouldn't be able to detect empty stream\");\n+        } catch (ArchiveException e) {\n+            assertEquals(\"No Archiver found for the stream signature\", e.getMessage());\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(null);\n+            fail(\"shouldn't be able to detect null stream\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Stream must not be null.\", e.getMessage());\n+        }\n+\n+        try {\n+            ArchiveStreamFactory.detect(new BufferedInputStream(new MockEvilInputStream()));\n+            fail(\"Expected ArchiveException\");\n+        } catch (ArchiveException e) {\n+            assertEquals(\"IOException while reading signature.\", e.getMessage());\n+        }\n+    }\n+\n+    private String detect(String resource) throws IOException, ArchiveException {\n+        try(InputStream in = new BufferedInputStream(new FileInputStream(\n+                getFile(resource)))) {\n+            return ArchiveStreamFactory.detect(in);\n+        }\n+    }\n+\n     static final TestData[] TESTS = {\n         new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, ARJ_DEFAULT, FACTORY, \"charsetName\"),\n         new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"UTF-8\", FACTORY_UTF8, \"charsetName\"),\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n \n     @Test\n     public void testDetect() throws Exception {\n+\n         assertEquals(CompressorStreamFactory.BZIP2, detect(\"bla.txt.bz2\"));\n         assertEquals(CompressorStreamFactory.GZIP, detect(\"bla.tgz\"));\n         assertEquals(CompressorStreamFactory.PACK200, detect(\"bla.pack\"));\n             CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n             fail(\"shouldn't be able to detect empty stream\");\n         } catch (CompressorException e) {\n-            assertTrue(e.getMessage().contains(\"No Compressor found\"));\n+            assertEquals(\"No Compressor found for the stream signature.\", e.getMessage());\n         }\n \n         try {\n         }\n \n         try {\n-            CompressorStreamFactory.detect(new BufferedInputStream(new BadInputStream()));\n+            CompressorStreamFactory.detect(new BufferedInputStream(new MockEvilInputStream()));\n             fail(\"Expected IOException\");\n         } catch (CompressorException e) {\n-            assertEquals(\"Failed while reading signature from InputStream.\", e.getMessage());\n+            assertEquals(\"IOException while reading signature.\", e.getMessage());\n         }\n \n \n                    new BufferedInputStream(new FileInputStream(\n                        getFile(resource))));\n     }\n-\n-    private static class BadInputStream extends InputStream {\n-        @Override\n-        public int read() throws IOException {\n-            throw new IOException(\"Bad\");\n-        }\n-\n-        @Override\n-        public int read(byte[] bytes, int offset, int length) throws IOException {\n-            throw new IOException(\"Bad\");\n-        }\n-    }\n-\n }", "timestamp": 1492519225, "metainfo": ""}