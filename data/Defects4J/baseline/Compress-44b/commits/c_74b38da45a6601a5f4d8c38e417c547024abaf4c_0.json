{"sha": "74b38da45a6601a5f4d8c38e417c547024abaf4c", "log": "COMPRESS-271 non-functional skeleton of LZ4 block output stream", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n  */\n public class BlockLZ4CompressorInputStream extends AbstractLZ77CompressorInputStream {\n \n-    private static final int WINDOW_SIZE = 1 << 16;\n-    private static final int SIZE_BITS = 4;\n-    private static final int COPY_SIZE_MASK = (1 << SIZE_BITS) - 1;\n-    private static final int LITERAL_SIZE_MASK = COPY_SIZE_MASK << SIZE_BITS;\n+    static final int WINDOW_SIZE = 1 << 16;\n+    static final int SIZE_BITS = 4;\n+    static final int COPY_SIZE_MASK = (1 << SIZE_BITS) - 1;\n+    static final int LITERAL_SIZE_MASK = COPY_SIZE_MASK << SIZE_BITS;\n \n     /** Copy-size part of the block starting byte. */\n     private int nextCopySize;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorOutputStream;\n+import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;\n+import org.apache.commons.compress.compressors.lz77support.Parameters;\n+import org.apache.commons.compress.utils.ByteUtils;\n+\n+/**\n+ * CompressorOutputStream for the LZ4 block format.\n+ *\n+ * @see <a href=\"http://lz4.github.io/lz4/lz4_Block_format.html\">LZ4 Block Format Description</a>\n+ * @since 1.14\n+ */\n+public class BlockLZ4CompressorOutputStream extends CompressorOutputStream {\n+\n+    /*\n+\n+      The LZ4 block format has a few properties that make it less\n+      straight-forward than one would hope:\n+\n+      * literal blocks and back-references must come in pairs (except\n+        for the very last literal block), so consecutive literal\n+        blocks created by the compressor must be merged into a single\n+        block.\n+\n+      * the start of a literal/back-reference pair contains the length\n+        of the copy (at least some part of it) so we can't start\n+        writing the literal before we know how long the next copy is\n+        going to be.\n+\n+      * there is a special rule for the final blocks\n+\n+        > There are specific parsing rules to respect in order to remain\n+        > compatible with assumptions made by the decoder :\n+        >\n+        >     1. The last 5 bytes are always literals\n+        >\n+        >     2. The last match must start at least 12 bytes before end of\n+        >        block. Consequently, a block with less than 13 bytes cannot be\n+        >        compressed.\n+\n+        which means any back-reference may need to get rewritten as a\n+        literal block unless we know the next block is at least of\n+        length 5 and the sum of this block's length and offset and the\n+        next block's length is at least twelve.\n+\n+    */\n+\n+    private final LZ77Compressor compressor;\n+    private final OutputStream os;\n+    private final ByteUtils.ByteConsumer consumer;\n+\n+    // used in one-arg write method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private boolean finished = false;\n+\n+    /**\n+     * Creates a new LZ4 output stream.\n+     *\n+     * @param os\n+     *            An OutputStream to read compressed data from\n+     *\n+     * @throws IOException if reading fails\n+     */\n+    public BlockLZ4CompressorOutputStream(final OutputStream os) throws IOException {\n+        this.os = os;\n+        consumer = new ByteUtils.OutputStreamByteConsumer(os);\n+        int maxLen = BlockLZ4CompressorInputStream.WINDOW_SIZE - 1;\n+        compressor = new LZ77Compressor(new Parameters(BlockLZ4CompressorInputStream.WINDOW_SIZE, 4, maxLen, maxLen,\n+            maxLen),\n+            new LZ77Compressor.Callback() {\n+                public void accept(LZ77Compressor.Block block) throws IOException {\n+                    //System.err.println(block);\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        addLiteralBlock((LZ77Compressor.LiteralBlock) block);\n+                    } else if (block instanceof LZ77Compressor.BackReference) {\n+                        addBackReference((LZ77Compressor.BackReference) block);\n+                    } else if (block instanceof LZ77Compressor.EOD) {\n+                        writeFinalLiteralBlock();\n+                    }\n+                }\n+            });\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        oneByte[0] = (byte) (b & 0xff);\n+        write(oneByte);\n+    }\n+\n+    @Override\n+    public void write(byte[] data, int off, int len) throws IOException {\n+        compressor.compress(data, off, len);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        finish();\n+        os.close();\n+    }\n+\n+    /**\n+     * Compresses all remaining data and writes it to the stream,\n+     * doesn't close the underlying stream.\n+     * @throws IOException if an error occurs\n+     */\n+    public void finish() throws IOException {\n+        if (!finished) {\n+            compressor.finish();\n+            finished = true;\n+        }\n+    }\n+\n+    private void addLiteralBlock(LZ77Compressor.LiteralBlock block) throws IOException {\n+    }\n+\n+    private void addBackReference(LZ77Compressor.BackReference block) throws IOException {\n+    }\n+\n+    private void writeFinalLiteralBlock() throws IOException {\n+    }\n+}", "timestamp": 1484718083, "metainfo": ""}