{"sha": "5ce60be9d55c62b72262680249ad933850aaa064", "log": "fix calculation of self-copy boundaries when expanding back-references", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n                 copyOffset = blockOffset + block.length - offsetRemaining;\n                 copyLen = Math.min(lengthRemaining, block.length - copyOffset);\n             } else {\n-                // offsetRemaining is negative and points into the expanded bytes\n+                // offsetRemaining is negative or 0 and points into the expanded bytes\n                 block = expanded;\n-                copyOffset = writeOffset  + offsetRemaining;\n+                copyOffset = -offsetRemaining;\n                 copyLen = Math.min(lengthRemaining, writeOffset + offsetRemaining);\n             }\n             System.arraycopy(block, copyOffset, expanded, writeOffset, copyLen);\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStreamTest.java\n         Assert.assertArrayEquals(expected, compressed);\n     }\n \n+    @Test\n+    public void rewritingWithFinalBackreferenceAndOffsetBiggerThan1() throws IOException {\n+        // this caused trouble when expandFromList() fell into the \"offsetRemaining is negative\" self-copy case as the\n+        // calculation of copyOffset was wrong\n+        byte[] toCompress = prepareExpected(25);\n+        for (int i = 0; i < toCompress.length; i += 4) {\n+            toCompress[i] = 1;\n+        }\n+        // LZ77Compressor creates a four byte literal and a back-reference with offset 4 and length 21\n+        // we'll need to split the back-reference and chop off the last 12 bytes\n+        byte[] compressed = compress(toCompress);\n+        byte[] expected = prepareExpected(1 + 4 + 2 + 1 + 12);\n+        expected[0] = (byte) ((4<<4) | 5);\n+        expected[1] = 1;\n+        expected[5] = 4;\n+        expected[6] = 0;\n+        expected[7] = (byte) (12<<4);\n+        for (int i = 11; i < expected.length; i += 4) {\n+            expected[i] = 1;\n+        }\n+        Assert.assertArrayEquals(expected, compressed);\n+    }\n+\n     private byte[] compress(int length) throws IOException {\n         return compress(length, 0);\n     }", "timestamp": 1491484680, "metainfo": ""}