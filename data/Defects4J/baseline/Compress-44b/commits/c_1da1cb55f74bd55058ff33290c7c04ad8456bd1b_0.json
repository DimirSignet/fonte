{"sha": "1da1cb55f74bd55058ff33290c7c04ad8456bd1b", "log": "whitespace  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private static final int SHORT = 2;\n     private static final int WORD = 4;\n     static final int BUFFER_SIZE = 512;\n-    \n+\n     /** indicates if this archive is finished. protected for use in Jar implementation */\n     protected boolean finished = false;\n-    \n+\n     /* \n      * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n      * when it gets handed a really big buffer.  See\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n-        \n-        if(entry != null) {\n+\n+        if (entry != null) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n         }\n-        \n+\n         cdOffset = written;\n         for (Iterator i = entries.iterator(); i.hasNext(); ) {\n             writeCentralFileHeader((ZipArchiveEntry) i.next());\n      * @throws IOException on error\n      */\n     public void closeArchiveEntry() throws IOException {\n-        if(finished) {\n+        if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        \n+\n         if (entry == null) {\n             throw new IOException(\"No current entry to close\");\n         }\n     /** {@inheritDoc} */\n  // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n-        if(finished) {\n+        if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        \n+\n         if (entry != null) {\n             closeArchiveEntry();\n         }\n      * @exception  IOException  if an I/O error occurs.\n      */\n     public void close() throws IOException {\n-        if(!finished) {\n+        if (!finished) {\n             finish();\n         }\n-        \n+\n         if (raf != null) {\n             raf.close();\n         }\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n         boolean encodable = zipEncoding.canEncode(ze.getName());\n-        \n+\n         final ZipEncoding entryEncoding;\n-        \n+\n         if (!encodable && fallbackToUTF8) {\n             entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n         } else {\n             entryEncoding = zipEncoding;\n         }\n-        \n-        ByteBuffer name = entryEncoding.encode(ze.getName());        \n+\n+        ByteBuffer name = entryEncoding.encode(ze.getName());\n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n \n \n         // file name length\n         final ZipEncoding entryEncoding;\n-        \n+\n         if (!encodable && fallbackToUTF8) {\n             entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n         } else {\n             entryEncoding = zipEncoding;\n         }\n-        \n-        ByteBuffer name = entryEncoding.encode(ze.getName());        \n+\n+        ByteBuffer name = entryEncoding.encode(ze.getName());\n \n         writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n         if (comm == null) {\n             comm = \"\";\n         }\n-        \n+\n         ByteBuffer commentB = entryEncoding.encode(comm);\n-        \n+\n         writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n \n      */\n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n             throws IOException {\n-        if(finished) {\n+        if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         return new ZipArchiveEntry(inputFile, entryName);", "timestamp": 1271690391, "metainfo": ""}