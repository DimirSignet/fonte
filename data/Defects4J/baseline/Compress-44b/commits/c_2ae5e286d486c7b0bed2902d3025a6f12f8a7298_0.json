{"sha": "2ae5e286d486c7b0bed2902d3025a6f12f8a7298", "log": "[SANDBOX-256] - merge revision 738844 from Ant - use JDK 1.4+ collections  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n-import java.util.Hashtable;\n-import java.util.Vector;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.zip.ZipException;\n \n /**\n      *\n      * @since 1.1\n      */\n-    private static Hashtable implementations;\n+    private static final Map implementations;\n \n     static {\n-        implementations = new Hashtable();\n+        implementations = new HashMap();\n         register(AsiExtraField.class);\n         register(JarMarker.class);\n     }\n      * @throws ZipException on error\n      */\n     public static ZipExtraField[] parse(byte[] data) throws ZipException {\n-        Vector v = new Vector();\n+        List v = new ArrayList();\n         int start = 0;\n         while (start <= data.length - WORD) {\n             ZipShort headerId = new ZipShort(data, start);\n             try {\n                 ZipExtraField ze = createExtraField(headerId);\n                 ze.parseFromLocalFileData(data, start + WORD, length);\n-                v.addElement(ze);\n+                v.add(ze);\n             } catch (InstantiationException ie) {\n                 throw new ZipException(ie.getMessage());\n             } catch (IllegalAccessException iae) {\n         }\n \n         ZipExtraField[] result = new ZipExtraField[v.size()];\n-        v.copyInto(result);\n-        return result;\n+        return (ZipExtraField[]) v.toArray(result);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEntry.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n-import java.util.Vector;\n+import java.util.LinkedHashMap;\n import java.util.zip.ZipException;\n \n /**\n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n-    private Vector/*<ZipExtraField>*/ extraFields = null;\n+    private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n     private String name = null;\n \n     /**\n     public Object clone() {\n         ZipEntry e = (ZipEntry) super.clone();\n \n-        e.extraFields = extraFields != null ? (Vector) extraFields.clone() : null;\n+        e.extraFields = extraFields != null ? (LinkedHashMap) extraFields.clone() : null;\n         e.setInternalAttributes(getInternalAttributes());\n         e.setExternalAttributes(getExternalAttributes());\n         e.setExtraFields(getExtraFields());\n      * @since 1.1\n      */\n     public void setExtraFields(ZipExtraField[] fields) {\n-        extraFields = new Vector();\n+        extraFields = new LinkedHashMap();\n         for (int i = 0; i < fields.length; i++) {\n-            extraFields.addElement(fields[i]);\n+            extraFields.put(fields[i].getHeaderId(), fields[i]);\n         }\n         setExtra();\n     }\n             return new ZipExtraField[0];\n         }\n         ZipExtraField[] result = new ZipExtraField[extraFields.size()];\n-        extraFields.copyInto(result);\n-        return result;\n+        return (ZipExtraField[]) extraFields.values().toArray(result);\n     }\n \n     /**\n      */\n     public void addExtraField(ZipExtraField ze) {\n         if (extraFields == null) {\n-            extraFields = new Vector();\n-        }\n-        ZipShort type = ze.getHeaderId();\n-        boolean done = false;\n-        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {\n-            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {\n-                extraFields.setElementAt(ze, i);\n-                done = true;\n-            }\n-        }\n-        if (!done) {\n-            extraFields.addElement(ze);\n-        }\n+            extraFields = new LinkedHashMap();\n+        }\n+        extraFields.put(ze.getHeaderId(), ze);\n         setExtra();\n     }\n \n      */\n     public void removeExtraField(ZipShort type) {\n         if (extraFields == null) {\n-            extraFields = new Vector();\n-        }\n-        boolean done = false;\n-        for (int i = 0, fieldsSize = extraFields.size(); !done && i < fieldsSize; i++) {\n-            if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {\n-                extraFields.removeElementAt(i);\n-                done = true;\n-            }\n-        }\n-        if (!done) {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        if (extraFields.remove(type) == null) {\n             throw new java.util.NoSuchElementException();\n         }\n         setExtra();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.RandomAccessFile;\n import java.io.UnsupportedEncodingException;\n import java.util.Calendar;\n+import java.util.Collections;\n import java.util.Date;\n import java.util.Enumeration;\n-import java.util.Hashtable;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n import java.util.zip.ZipException;\n      * Maps ZipEntrys to Longs, recording the offsets of the local\n      * file headers.\n      */\n-    private Hashtable entries = new Hashtable(HASH_SIZE);\n+    private final Map entries = new HashMap(HASH_SIZE);\n \n     /**\n      * Maps String to ZipEntrys, name -> actual entry.\n      */\n-    private Hashtable nameMap = new Hashtable(HASH_SIZE);\n+    private final Map nameMap = new HashMap(HASH_SIZE);\n \n     private static final class OffsetEntry {\n         private long headerOffset = -1;\n      * @return all entries as {@link ZipEntry} instances\n      */\n     public Enumeration getEntries() {\n-        return entries.keys();\n+        return Collections.enumeration(entries.keySet());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipOutputStream.java\n import java.io.RandomAccessFile;\n import java.io.UnsupportedEncodingException;\n import java.util.Date;\n-import java.util.Hashtable;\n-import java.util.Vector;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n import java.util.zip.CRC32;\n import java.util.zip.Deflater;\n import java.util.zip.ZipException;\n      *\n      * @since 1.1\n      */\n-    private Vector entries = new Vector();\n+    private final List entries = new LinkedList();\n \n     /**\n      * CRC instance to avoid parsing DEFLATED data twice.\n      *\n      * @since 1.1\n      */\n-    private CRC32 crc = new CRC32();\n+    private final CRC32 crc = new CRC32();\n \n     /**\n      * Count the bytes written to out.\n      *\n      * @since 1.1\n      */\n-    private Hashtable offsets = new Hashtable();\n+    private final Map offsets = new HashMap();\n \n     /**\n      * The encoding to use for filenames and the file comment.\n     public void finish() throws IOException {\n         closeEntry();\n         cdOffset = written;\n-        for (int i = 0, entriesSize = entries.size(); i < entriesSize; i++) {\n-            writeCentralFileHeader((ZipEntry) entries.elementAt(i));\n+        for (Iterator i = entries.iterator(); i.hasNext(); ) {\n+            writeCentralFileHeader((ZipEntry) i.next());\n         }\n         cdLength = written - cdOffset;\n         writeCentralDirectoryEnd();\n         offsets.clear();\n-        entries.removeAllElements();\n+        entries.clear();\n     }\n \n     /**\n         closeEntry();\n \n         entry = ze;\n-        entries.addElement(entry);\n+        entries.add(entry);\n \n         if (entry.getMethod() == -1) { // not specified\n             entry.setMethod(method);", "timestamp": 1233737131, "metainfo": ""}