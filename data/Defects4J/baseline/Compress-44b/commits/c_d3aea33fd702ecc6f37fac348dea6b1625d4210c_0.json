{"sha": "d3aea33fd702ecc6f37fac348dea6b1625d4210c", "log": "Java5ify ZipFile  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n import java.util.zip.ZipException;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n \n /**\n  * Replacement for <code>java.util.ZipFile</code>.\n  */\n public class ZipFile {\n     private static final int HASH_SIZE = 509;\n-    private static final int SHORT     =   2;\n-    private static final int WORD      =   4;\n     static final int NIBLET_MASK = 0x0f;\n     static final int BYTE_SHIFT = 8;\n     private static final int POS_0 = 0;\n     private static final int POS_3 = 3;\n \n     /**\n-     * Maps ZipArchiveEntrys to Longs, recording the offsets of the local\n-     * file headers.\n-     */\n-    private final Map entries = new LinkedHashMap(HASH_SIZE);\n+     * Maps ZipArchiveEntrys to two longs, recording the offsets of\n+     * the local file headers and the start of entry data.\n+     */\n+    private final Map<ZipArchiveEntry, OffsetEntry> entries =\n+        new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(HASH_SIZE);\n \n     /**\n      * Maps String to ZipArchiveEntrys, name -> actual entry.\n      */\n-    private final Map nameMap = new HashMap(HASH_SIZE);\n+    private final Map<String, ZipArchiveEntry> nameMap =\n+        new HashMap<String, ZipArchiveEntry>(HASH_SIZE);\n \n     private static final class OffsetEntry {\n         private long headerOffset = -1;\n         archive = new RandomAccessFile(f, \"r\");\n         boolean success = false;\n         try {\n-            Map entriesWithoutUTF8Flag = populateFromCentralDirectory();\n+            Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n+                populateFromCentralDirectory();\n             resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n             success = true;\n         } finally {\n      * @since Commons Compress 1.1\n      */\n     public Enumeration getEntriesInPhysicalOrder() {\n-        Object[] allEntries = entries.keySet().toArray();\n+        ZipArchiveEntry[] allEntries =\n+            entries.keySet().toArray(new ZipArchiveEntry[0]);\n         Arrays.sort(allEntries, OFFSET_COMPARATOR);\n         return Collections.enumeration(Arrays.asList(allEntries));\n     }\n      * <code>null</code> if not present.\n      */\n     public ZipArchiveEntry getEntry(String name) {\n-        return (ZipArchiveEntry) nameMap.get(name);\n+        return nameMap.get(name);\n     }\n \n     /**\n      */\n     public InputStream getInputStream(ZipArchiveEntry ze)\n         throws IOException, ZipException {\n-        OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n+        OffsetEntry offsetEntry = entries.get(ze);\n         if (offsetEntry == null) {\n             return null;\n         }\n      * the central directory alone, but not the data that requires the\n      * local file header or additional data to be read.</p>\n      *\n-     * @return a Map&lt;ZipArchiveEntry, NameAndComment>&gt; of\n-     * zipentries that didn't have the language encoding flag set when\n-     * read.\n-     */\n-    private Map populateFromCentralDirectory()\n+     * @return a map of zipentries that didn't have the language\n+     * encoding flag set when read.\n+     */\n+    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n         throws IOException {\n-        HashMap noUTF8Flag = new HashMap();\n+        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n+            new HashMap<ZipArchiveEntry, NameAndComment>();\n \n         positionAtCentralDirectory();\n \n      * <p>Also records the offsets for the data to read from the\n      * entries.</p>\n      */\n-    private void resolveLocalFileHeaderData(Map entriesWithoutUTF8Flag)\n+    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n+                                            entriesWithoutUTF8Flag)\n         throws IOException {\n-        Enumeration e = getEntries();\n-        while (e.hasMoreElements()) {\n-            ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement();\n-            OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n+        for (ZipArchiveEntry ze : entries.keySet()) {\n+            OffsetEntry offsetEntry = entries.get(ze);\n             long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n             byte[] b = new byte[SHORT];\n             byte[] localExtraData = new byte[extraFieldLen];\n             archive.readFully(localExtraData);\n             ze.setExtra(localExtraData);\n-            /*dataOffsets.put(ze,\n-                            new Long(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n-                                     + SHORT + SHORT + fileNameLen + extraFieldLen));\n-            */\n             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n \n             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                 String orig = ze.getName();\n-                NameAndComment nc = (NameAndComment) entriesWithoutUTF8Flag.get(ze);\n+                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                          nc.comment);\n                 if (!orig.equals(ze.getName())) {\n      *\n      * @since Commons Compress 1.1\n      */\n-    private final Comparator OFFSET_COMPARATOR =\n-        new Comparator() {\n-            public int compare(Object o1, Object o2) {\n-                if (o1 == o2)\n+    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n+        new Comparator<ZipArchiveEntry>() {\n+            public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n+                if (e1 == e2)\n                     return 0;\n \n-                ZipArchiveEntry e1 = (ZipArchiveEntry) o1;\n-                ZipArchiveEntry e2 = (ZipArchiveEntry) o2;\n-\n-                OffsetEntry off1 = (OffsetEntry) entries.get(e1);\n-                OffsetEntry off2 = (OffsetEntry) entries.get(e2);\n+                OffsetEntry off1 = entries.get(e1);\n+                OffsetEntry off2 = entries.get(e2);\n                 if (off1 == null) {\n                     return 1;\n                 }", "timestamp": 1312383435, "metainfo": ""}