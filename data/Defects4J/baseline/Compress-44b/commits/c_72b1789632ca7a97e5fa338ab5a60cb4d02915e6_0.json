{"sha": "72b1789632ca7a97e5fa338ab5a60cb4d02915e6", "log": "COMPRESS-327 tests and tweaks for SeekableInMemoryByteChannel  patch by Maciej Nowakowski", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n+++ b/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.NonWritableChannelException;\n import java.nio.channels.SeekableByteChannel;\n import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicBoolean;\n     }\n \n     @Override\n-    public SeekableByteChannel position(long newPosition) {\n-        if (newPosition > Integer.MAX_VALUE) {\n-            throw new IllegalArgumentException(\"Position cannot exceed \" + Integer.MAX_VALUE);\n+    public SeekableByteChannel position(long newPosition) throws IOException {\n+        ensureOpen();\n+        if (newPosition < 0L || newPosition > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Position has to be in range 0.. \" + Integer.MAX_VALUE);\n         }\n         position = (int) newPosition;\n         return this;\n         if (size > newSize) {\n             size = (int) newSize;\n         }\n-        if (position > size) {\n-            position = size;\n-        }\n+        repositionIfNecessary();\n         return this;\n     }\n \n     @Override\n     public int read(ByteBuffer buf) throws IOException {\n-        if (!isOpen()) {\n-            throw new ClosedChannelException();\n-        }\n+        ensureOpen();\n+        repositionIfNecessary();\n         int wanted = buf.remaining();\n         int possible = size - position;\n         if (wanted > possible) {\n \n     @Override\n     public int write(ByteBuffer b) throws IOException {\n-        if (!isOpen()) {\n-            throw new ClosedChannelException();\n-        }\n+        ensureOpen();\n         int wanted = b.remaining();\n         int possibleWithoutResize = size - position;\n         if (wanted > possibleWithoutResize) {\n         data = Arrays.copyOf(data, len);\n     }\n \n+    private void ensureOpen() throws ClosedChannelException {\n+        if (!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+    }\n+\n+    private void repositionIfNecessary() {\n+        if (position > size) {\n+            position = size;\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannelTest.java\n+package org.apache.commons.compress.utils;\n+\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+import static org.apache.commons.compress.utils.CharsetNames.UTF_8;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class SeekableInMemoryByteChannelTest {\n+\n+    private final byte[] testData = \"Some data\".getBytes(Charset.forName(UTF_8));\n+\n+    @Test\n+    public void shouldReadContentsProperly() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n+        //when\n+        int readCount = c.read(readBuffer);\n+        //then\n+        assertEquals(testData.length, readCount);\n+        assertArrayEquals(testData, readBuffer.array());\n+        assertEquals(testData.length, c.position());\n+    }\n+\n+    @Test\n+    public void shouldReadContentsWhenBiggerBufferSupplied() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        ByteBuffer readBuffer = ByteBuffer.allocate(testData.length + 1);\n+        //when\n+        int readCount = c.read(readBuffer);\n+        //then\n+        assertEquals(testData.length, readCount);\n+        assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\n+        assertEquals(testData.length, c.position());\n+    }\n+\n+    @Test\n+    public void shouldReadDataFromSetPosition() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        ByteBuffer readBuffer = ByteBuffer.allocate(4);\n+        //when\n+        c.position(5L);\n+        int readCount = c.read(readBuffer);\n+        //then\n+        assertEquals(4L, readCount);\n+        assertEquals(\"data\", new String(readBuffer.array(), Charset.forName(UTF_8)));\n+        assertEquals(testData.length, c.position());\n+    }\n+\n+    @Test\n+    public void shouldReadNoDataWhenPositionAtTheEnd() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n+        //when\n+        c.position(testData.length + 1);\n+        int readCount = c.read(readBuffer);\n+        //then\n+        assertEquals(0L, readBuffer.position());\n+        assertEquals(0, readCount);\n+    }\n+\n+    @Test(expected = ClosedChannelException.class)\n+    public void shouldThrowExceptionOnReadingClosedChannel() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        //when\n+        c.close();\n+        c.read(ByteBuffer.allocate(1));\n+    }\n+\n+    @Test\n+    public void shouldWriteDataProperly() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        ByteBuffer inData = ByteBuffer.wrap(testData);\n+        //when\n+        int writeCount = c.write(inData);\n+        //then\n+        assertEquals(testData.length, writeCount);\n+        assertArrayEquals(testData, Arrays.copyOf(c.array(), (int) c.size()));\n+        assertEquals(testData.length, c.position());\n+    }\n+\n+    @Test\n+    public void shouldWriteDataProperlyAfterPositionSet() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        ByteBuffer inData = ByteBuffer.wrap(testData);\n+        ByteBuffer expectedData = ByteBuffer.allocate(testData.length + 5).put(testData, 0, 5).put(testData);\n+        //when\n+        c.position(5L);\n+        int writeCount = c.write(inData);\n+\n+        //then\n+        assertEquals(testData.length, writeCount);\n+        assertArrayEquals(expectedData.array(), Arrays.copyOf(c.array(), (int) c.size()));\n+        assertEquals(testData.length + 5, c.position());\n+    }\n+\n+\n+    @Test(expected = ClosedChannelException.class)\n+    public void shouldThrowExceptionOnWritingToClosedChannel() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        //when\n+        c.close();\n+        c.write(ByteBuffer.allocate(1));\n+    }\n+\n+    @Test\n+    public void shouldTruncateContentsProperly() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        //when\n+        c.truncate(4);\n+        //then\n+        byte[] bytes = Arrays.copyOf(c.array(), (int) c.size());\n+        assertEquals(\"Some\", new String(bytes, Charset.forName(UTF_8)));\n+    }\n+\n+    @Test\n+    public void shouldSetProperPositionOnTruncate() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        //when\n+        c.position(testData.length);\n+        c.truncate(4L);\n+        //then\n+        assertEquals(4L, c.position());\n+        assertEquals(4L, c.size());\n+    }\n+\n+    @Test\n+    public void shouldSetProperPosition() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData);\n+        //when\n+        long posAtFour = c.position(4L).position();\n+        long posAtTheEnd = c.position(testData.length).position();\n+        long posPastTheEnd = c.position(testData.length + 1L).position();\n+        //then\n+        assertEquals(4L, posAtFour);\n+        assertEquals(c.size(), posAtTheEnd);\n+        assertEquals(posPastTheEnd, posPastTheEnd);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void shouldThrowExceptionWhenSettingIncorrectPosition() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        //when\n+        c.position(Integer.MAX_VALUE + 1L);\n+    }\n+\n+    @Test(expected = ClosedChannelException.class)\n+    public void shouldThrowExceptionWhenSettingPositionOnClosedChannel() throws IOException {\n+        //given\n+        SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel();\n+        //when\n+        c.close();\n+        c.position(1L);\n+    }\n+\n+}", "timestamp": 1477154318, "metainfo": ""}