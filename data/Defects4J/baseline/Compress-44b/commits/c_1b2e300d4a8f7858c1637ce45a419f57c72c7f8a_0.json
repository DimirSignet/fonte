{"sha": "1b2e300d4a8f7858c1637ce45a419f57c72c7f8a", "log": "Add alignmentBoundary and pad calculation methods to simplify the job for users. Update some Javadoc headerSize can only be an int.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n  *                  FIFOs and directories\n  *               \n  * All fields are unsigned short fields with 16-bit integer values\n+ * apart from c_mtime and c_filesize which are 32-bit integer values\n  * </pre>\n+ * \n+ * <p>If necessary, the filename and file data are padded with a NUL byte to an even length</p>\n  * \n  * <p>Special files, directories, and the trailer are recorded with\n  * the h_filesize field equal to 0.</p>\n  * \n+ * <p>In the ASCII version of this format, the 16-bit entries are represented as 6-byte octal numbers,\n+ * and the 32-bit entries are represented as 11-byte octal numbers. No padding is added.</p>\n  * \n  * <h3>NEW FORMAT</h3>\n  * \n     private short fileFormat = 0; // Default chosen so checkNewFormat() and checkOldFormat() both fail \n \n     /** The number of bytes in each header record; depends on the file format */\n-    private long headerSize = -1;\n+    private int headerSize = -1;\n+\n+    /** The boundary to which the header and data elements are aligned: 0, 2 or 4 bytes */\n+    private int alignmentBoundary;\n \n     // Header fields\n     \n     private long chksum = 0;\n \n+    /** Number of bytes in the file */\n     private long filesize = 0;\n \n     private long gid = 0;\n \n     /**\n      * Get the checksum.\n+     * Only supported for the new formats.\n      * \n      * @return Returns the checksum.\n+     * @throws UnsupportedOperationException if the format is not a new format\n      */\n     public long getChksum() {\n         checkNewFormat();\n      * Get the minor device id\n      * \n      * @return Returns the minor device id.\n+     * @throws UnsupportedOperationException if format is not a new format\n      */\n     public long getDeviceMin() {\n         checkNewFormat();\n      * Get the filesize.\n      * \n      * @return Returns the filesize.\n-     */\n-    /*\n-     * (non-Javadoc)\n-     * \n      * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n      */\n     public long getSize() {\n     }\n \n     /**\n-     * Get the size of this entry on the stream\n-     * \n-     * @return Returns the size.\n-     */\n-    public long getHeaderSize() {\n+     * Get the header size for this CPIO format\n+     * \n+     * @return Returns the header size in bytes.\n+     */\n+    public int getHeaderSize() {\n         return this.headerSize;\n+    }\n+\n+    /**\n+     * Get the alignment boundary for this CPIO format\n+     * \n+     * @return Returns the aligment boundary (0, 2, 4) in bytes\n+     */\n+    public int getAlignmentBoundary() {\n+        return this.alignmentBoundary;\n+    }\n+\n+    /**\n+     * Get the number of bytes needed to pad the header to the alignment boundary.\n+     * \n+     * @return the number of bytes needed to pad the header (0,1,2,3)\n+     */\n+    public int getHeaderPadCount(){\n+        if (this.alignmentBoundary == 0) return 0;\n+        int size = this.headerSize+this.name.length()+1; // Name has terminating null\n+        int remain = size % this.alignmentBoundary;\n+        if (remain > 0){\n+            return this.alignmentBoundary - remain;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Get the number of bytes needed to pad the data to the alignment boundary.\n+     * \n+     * @return the number of bytes needed to pad the data (0,1,2,3)\n+     */\n+    public int getDataPadCount(){\n+        if (this.alignmentBoundary == 0) return 0;\n+        long size = this.filesize;\n+        int remain = (int) (size % this.alignmentBoundary);\n+        if (remain > 0){\n+            return this.alignmentBoundary - remain;\n+        }\n+        return 0;\n     }\n \n     /**\n         switch (format) {\n         case FORMAT_NEW:\n             this.headerSize = 110;\n+            this.alignmentBoundary = 4;\n             break;\n         case FORMAT_NEW_CRC:\n             this.headerSize = 110;\n+            this.alignmentBoundary = 4;\n             break;\n         case FORMAT_OLD_ASCII:\n             this.headerSize = 76;\n+            this.alignmentBoundary = 0;\n             break;\n         case FORMAT_OLD_BINARY:\n             this.headerSize = 26;\n+            this.alignmentBoundary = 2;\n             break;\n         default:\n             throw new IllegalArgumentException(\"Unknown header type\");", "timestamp": 1238175856, "metainfo": ""}