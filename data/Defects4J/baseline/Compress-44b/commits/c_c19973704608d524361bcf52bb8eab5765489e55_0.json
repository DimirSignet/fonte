{"sha": "c19973704608d524361bcf52bb8eab5765489e55", "log": "applied patch from Christian Grobmeier  updated bzip2 streams https://issues.apache.org/jira/browse/SANDBOX-195    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n+/*\n+ * This package is based on the work done by Keiron Liddle, Aftex Software\n+ * <keiron@aftexsw.com> to whom the Ant project is very grateful for his\n+ * great code.\n+ */\n package org.apache.commons.compress.compressors.bzip2;\n \n import java.io.IOException;\n  * header chars) to be read as any other stream.\n  */\n public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants {\n-\n-    private static void cadvise() {\n-        System.out.println(\"CRC Error\");\n-        //throw new CCoruptionError();\n-    }\n-\n-    /*\n-    private static void badBGLengths() {\n-        cadvise();\n-    }\n-\n-    private static void bitStreamEOF() {\n-        cadvise();\n-    }\n-    */\n-\n-    private static void compressedStreamEOF() {\n-        cadvise();\n+    private static void reportCRCError() throws IOException {\n+        // The clean way would be to throw an exception.\n+        //throw new IOException(\"crc error\");\n+\n+        // Just print a message, like the previous versions of this class did\n+        System.err.println(\"BZip2 CRC error\");\n     }\n \n     private void makeMaps() {\n-        int i;\n-        nInUse = 0;\n-        for (i = 0; i < 256; i++) {\n-            if (inUse[i]) {\n-                seqToUnseq[nInUse] = (char) i;\n-                unseqToSeq[i] = (char) nInUse;\n-                nInUse++;\n-            }\n-        }\n-    }\n-\n-    /*\n-      index of the last char in the block, so\n-      the block size == last + 1.\n-    */\n+        final boolean[] inUse   = this.data.inUse;\n+        final byte[] seqToUnseq = this.data.seqToUnseq;\n+\n+        int nInUseShadow = 0;\n+\n+        for (int i = 0; i < 256; i++) {\n+            if (inUse[i])\n+                seqToUnseq[nInUseShadow++] = (byte) i;\n+        }\n+\n+        this.nInUse = nInUseShadow;\n+    }\n+\n+    /**\n+     * Index of the last char in the block, so the block size == last + 1.\n+     */\n     private int  last;\n \n-    /*\n-      index in zptr[] of original string after sorting.\n-    */\n+    /**\n+     * Index in zptr[] of original string after sorting.\n+     */\n     private int  origPtr;\n \n-    /*\n-      always: in the range 0 .. 9.\n-      The current block size is 100000 * this number.\n-    */\n+    /**\n+     * always: in the range 0 .. 9.\n+     * The current block size is 100000 * this number.\n+     */\n     private int blockSize100k;\n \n     private boolean blockRandomised;\n \n     private int bsBuff;\n     private int bsLive;\n-    private CRC mCrc = new CRC();\n-\n-    private boolean[] inUse = new boolean[256];\n+    private final CRC crc = new CRC();\n+\n     private int nInUse;\n \n-    private char[] seqToUnseq = new char[256];\n-    private char[] unseqToSeq = new char[256];\n-\n-    private char[] selector = new char[MAX_SELECTORS];\n-    private char[] selectorMtf = new char[MAX_SELECTORS];\n-\n-    private int[] tt;\n-    private char[] ll8;\n-\n-    /*\n-      freq table collected to save a pass over the data\n-      during decompression.\n-    */\n-    private int[] unzftab = new int[256];\n-\n-    private int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE];\n-    private int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE];\n-    private int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE];\n-    private int[] minLens = new int[N_GROUPS];\n-\n-    private InputStream bsStream;\n-\n-    private boolean streamEnd = false;\n+    private InputStream in;\n \n     private int currentChar = -1;\n \n+    private static final int EOF                  = 0;\n     private static final int START_BLOCK_STATE = 1;\n     private static final int RAND_PART_A_STATE = 2;\n     private static final int RAND_PART_B_STATE = 3;\n     private int storedBlockCRC, storedCombinedCRC;\n     private int computedBlockCRC, computedCombinedCRC;\n \n-    int i2, count, chPrev, ch2;\n-    int i, tPos;\n-    int rNToGo = 0;\n-    int rTPos  = 0;\n-    int j2;\n-    char z;\n-\n-    public BZip2CompressorInputStream(InputStream zStream) {\n-        ll8 = null;\n-        tt = null;\n-        bsSetStream(zStream);\n-        initialize();\n+    // Variables used by setup* methods exclusively\n+\n+    private int su_count;\n+    private int su_ch2;\n+    private int su_chPrev;\n+    private int su_i2;\n+    private int su_j2;\n+    private int su_rNToGo;\n+    private int su_rTPos;\n+    private int su_tPos;\n+    private char su_z;\n+\n+    /**\n+     * All memory intensive stuff.\n+     * This field is initialized by initBlock().\n+     */\n+    private BZip2CompressorInputStream.Data data;\n+\n+    /**\n+     * Constructs a new CBZip2InputStream which decompresses bytes read from\n+     * the specified stream.\n+     *\n+     * <p>Although BZip2 headers are marked with the magic\n+     * <tt>\"Bz\"</tt> this constructor expects the next byte in the\n+     * stream to be the first one after the magic.  Thus callers have\n+     * to skip the first two bytes. Otherwise this constructor will\n+     * throw an exception. </p>\n+     *\n+     * @throws IOException\n+     *  if the stream content is malformed or an I/O error occurs.\n+     * @throws NullPointerException\n+     *  if <tt>in == null</tt>\n+     */\n+    public BZip2CompressorInputStream(final InputStream in) throws IOException {\n+        super();\n+\n+        this.in = in;\n+        init();\n+    }\n+\n+    public int read() throws IOException {\n+        if (this.in != null) {\n+            return read0();\n+        } else {\n+            throw new IOException(\"stream closed\");\n+        }\n+    }\n+\n+    public int read(final byte[] dest, final int offs, final int len)\n+        throws IOException {\n+        if (offs < 0) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n+        }\n+        if (len < 0) {\n+            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n+        }\n+        if (offs + len > dest.length) {\n+            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+                                                + len + \") > dest.length(\"\n+                                                + dest.length + \").\");\n+        }\n+        if (this.in == null) {\n+            throw new IOException(\"stream closed\");\n+        }\n+\n+        final int hi = offs + len;\n+        int destOffs = offs;\n+        for (int b; (destOffs < hi) && ((b = read0()) >= 0);) {\n+            dest[destOffs++] = (byte) b;\n+        }\n+\n+        return (destOffs == offs) ? -1 : (destOffs - offs);\n+    }\n+\n+    private int read0() throws IOException {\n+        final int retChar = this.currentChar;\n+\n+        switch (this.currentState) {\n+        case EOF:\n+            return -1;\n+\n+        case START_BLOCK_STATE:\n+            throw new IllegalStateException();\n+\n+        case RAND_PART_A_STATE:\n+            throw new IllegalStateException();\n+\n+        case RAND_PART_B_STATE:\n+            setupRandPartB();\n+            break;\n+\n+        case RAND_PART_C_STATE:\n+            setupRandPartC();\n+            break;\n+\n+        case NO_RAND_PART_A_STATE:\n+            throw new IllegalStateException();\n+\n+        case NO_RAND_PART_B_STATE:\n+            setupNoRandPartB();\n+            break;\n+\n+        case NO_RAND_PART_C_STATE:\n+            setupNoRandPartC();\n+            break;\n+\n+        default:\n+            throw new IllegalStateException();\n+        }\n+\n+        return retChar;\n+    }\n+\n+    private void init() throws IOException {\n+        if (null == in) {\n+            throw new IOException(\"No InputStream\");\n+        }\n+        if (in.available() == 0) {\n+            throw new IOException(\"Empty InputStream\");\n+        }\n+        int magic2 = this.in.read();\n+        if (magic2 != 'h') {\n+            throw new IOException(\"Stream is not BZip2 formatted: expected 'h'\"\n+                                  + \" as first byte but got '\" + (char) magic2\n+                                  + \"'\");\n+        }\n+\n+        int blockSize = this.in.read();\n+        if ((blockSize < '1') || (blockSize > '9')) {\n+            throw new IOException(\"Stream is not BZip2 formatted: illegal \"\n+                                  + \"blocksize \" + (char) blockSize);\n+        }\n+\n+        this.blockSize100k = blockSize - '0';\n+\n         initBlock();\n         setupBlock();\n     }\n \n-    public int read() {\n-        if (streamEnd) {\n-            return -1;\n+    private void initBlock() throws IOException {\n+        char magic0 = bsGetUByte();\n+        char magic1 = bsGetUByte();\n+        char magic2 = bsGetUByte();\n+        char magic3 = bsGetUByte();\n+        char magic4 = bsGetUByte();\n+        char magic5 = bsGetUByte();\n+\n+        if (magic0 == 0x17 &&\n+            magic1 == 0x72 &&\n+            magic2 == 0x45 &&\n+            magic3 == 0x38 &&\n+            magic4 == 0x50 &&\n+            magic5 == 0x90) {\n+            complete(); // end of file\n+        } else if (magic0 != 0x31 || // '1'\n+                   magic1 != 0x41 || // ')'\n+                   magic2 != 0x59 || // 'Y'\n+                   magic3 != 0x26 || // '&'\n+                   magic4 != 0x53 || // 'S'\n+                   magic5 != 0x59   // 'Y'\n+                   ) {\n+            this.currentState = EOF;\n+            throw new IOException(\"bad block header\");\n         } else {\n-            int retChar = currentChar;\n-            switch(currentState) {\n-            case START_BLOCK_STATE:\n-                break;\n-            case RAND_PART_A_STATE:\n-                break;\n-            case RAND_PART_B_STATE:\n-                setupRandPartB();\n-                break;\n-            case RAND_PART_C_STATE:\n-                setupRandPartC();\n-                break;\n-            case NO_RAND_PART_A_STATE:\n-                break;\n-            case NO_RAND_PART_B_STATE:\n-                setupNoRandPartB();\n-                break;\n-            case NO_RAND_PART_C_STATE:\n-                setupNoRandPartC();\n-                break;\n-            default:\n-                break;\n-            }\n-            return retChar;\n-        }\n-    }\n-\n-    private void initialize() {\n-        char magic3, magic4;\n-        magic3 = bsGetUChar();\n-        magic4 = bsGetUChar();\n-        if (magic3 != 'h' || magic4 < '1' || magic4 > '9') {\n-            bsFinishedWithStream();\n-            streamEnd = true;\n-            return;\n-        }\n-\n-        setDecompressStructureSizes(magic4 - '0');\n-        computedCombinedCRC = 0;\n-    }\n-\n-    private void initBlock() {\n-        char magic1, magic2, magic3, magic4;\n-        char magic5, magic6;\n-        magic1 = bsGetUChar();\n-        magic2 = bsGetUChar();\n-        magic3 = bsGetUChar();\n-        magic4 = bsGetUChar();\n-        magic5 = bsGetUChar();\n-        magic6 = bsGetUChar();\n-        if (magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45\n-            && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90) {\n-            complete();\n-            return;\n-        }\n-\n-        if (magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59\n-            || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59) {\n-            badBlockHeader();\n-            streamEnd = true;\n-            return;\n-        }\n-\n-        storedBlockCRC = bsGetInt32();\n-\n-        if (bsR(1) == 1) {\n-            blockRandomised = true;\n-        } else {\n-            blockRandomised = false;\n-        }\n-\n-        //        currBlockNo++;\n-        getAndMoveToFrontDecode();\n-\n-        mCrc.initialiseCRC();\n-        currentState = START_BLOCK_STATE;\n-    }\n-\n-    private void endBlock() {\n-        computedBlockCRC = mCrc.getFinalCRC();\n-        /* A bad CRC is considered a fatal error. */\n-        if (storedBlockCRC != computedBlockCRC) {\n-            crcError();\n-        }\n-\n-        computedCombinedCRC = (computedCombinedCRC << 1)\n-            | (computedCombinedCRC >>> 31);\n-        computedCombinedCRC ^= computedBlockCRC;\n-    }\n-\n-    private void complete() {\n-        storedCombinedCRC = bsGetInt32();\n-        if (storedCombinedCRC != computedCombinedCRC) {\n-            crcError();\n-        }\n-\n-        bsFinishedWithStream();\n-        streamEnd = true;\n-    }\n-\n-    private static void blockOverrun() {\n-        cadvise();\n-    }\n-\n-    private static void badBlockHeader() {\n-        cadvise();\n-    }\n-\n-    private static void crcError() {\n-        cadvise();\n-    }\n-\n-    private void bsFinishedWithStream() {\n-        try {\n-            if (this.bsStream != null) {\n-                if (this.bsStream != System.in) {\n-                    this.bsStream.close();\n-                    this.bsStream = null;\n-                }\n-            }\n-        } catch (IOException ioe) {\n-            //ignore\n-        }\n-    }\n-\n-    private void bsSetStream(InputStream f) {\n-        bsStream = f;\n-        bsLive = 0;\n-        bsBuff = 0;\n-    }\n-\n-    private int bsR(int n) {\n-        int v;\n-        while (bsLive < n) {\n-            int zzi;\n-            char thech = 0;\n+            this.storedBlockCRC = bsGetInt();\n+            this.blockRandomised = bsR(1) == 1;\n+\n+            /**\n+             * Allocate data here instead in constructor, so we do not\n+             * allocate it if the input file is empty.\n+             */\n+            if (this.data == null) {\n+                this.data = new Data(this.blockSize100k);\n+            }\n+\n+            // currBlockNo++;\n+            getAndMoveToFrontDecode();\n+\n+            this.crc.initialiseCRC();\n+            this.currentState = START_BLOCK_STATE;\n+        }\n+    }\n+\n+    private void endBlock() throws IOException {\n+        this.computedBlockCRC = this.crc.getFinalCRC();\n+\n+        // A bad CRC is considered a fatal error.\n+        if (this.storedBlockCRC != this.computedBlockCRC) {\n+            // make next blocks readable without error\n+            // (repair feature, not yet documented, not tested)\n+            this.computedCombinedCRC\n+                = (this.storedCombinedCRC << 1)\n+                | (this.storedCombinedCRC >>> 31);\n+            this.computedCombinedCRC ^= this.storedBlockCRC;\n+\n+            reportCRCError();\n+        }\n+\n+        this.computedCombinedCRC\n+            = (this.computedCombinedCRC << 1)\n+            | (this.computedCombinedCRC >>> 31);\n+        this.computedCombinedCRC ^= this.computedBlockCRC;\n+    }\n+\n+    private void complete() throws IOException {\n+        this.storedCombinedCRC = bsGetInt();\n+        this.currentState = EOF;\n+        this.data = null;\n+\n+        if (this.storedCombinedCRC != this.computedCombinedCRC) {\n+            reportCRCError();\n+        }\n+    }\n+\n+    public void close() throws IOException {\n+        InputStream inShadow = this.in;\n+        if (inShadow != null) {\n             try {\n-                thech = (char) bsStream.read();\n-            } catch (IOException e) {\n-                compressedStreamEOF();\n-            }\n-            if (thech == -1) {\n-                compressedStreamEOF();\n-            }\n-            zzi = thech;\n-            bsBuff = (bsBuff << 8) | (zzi & 0xff);\n-            bsLive += 8;\n-        }\n-\n-        v = (bsBuff >> (bsLive - n)) & ((1 << n) - 1);\n-        bsLive -= n;\n-        return v;\n-    }\n-\n-    private char bsGetUChar() {\n+                if (inShadow != System.in) {\n+                    inShadow.close();\n+                }\n+            } finally {\n+                this.data = null;\n+                this.in = null;\n+            }\n+        }\n+    }\n+\n+    private int bsR(final int n) throws IOException {\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        if (bsLiveShadow < n) {\n+            final InputStream inShadow = this.in;\n+            do {\n+                int thech = inShadow.read();\n+\n+                if (thech < 0) {\n+                    throw new IOException(\"unexpected end of stream\");\n+                }\n+\n+                bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                bsLiveShadow += 8;\n+            } while (bsLiveShadow < n);\n+\n+            this.bsBuff = bsBuffShadow;\n+        }\n+\n+        this.bsLive = bsLiveShadow - n;\n+        return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n+    }\n+\n+    private boolean bsGetBit() throws IOException {\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        if (bsLiveShadow < 1) {\n+            int thech = this.in.read();\n+\n+            if (thech < 0) {\n+                throw new IOException(\"unexpected end of stream\");\n+            }\n+\n+            bsBuffShadow = (bsBuffShadow << 8) | thech;\n+            bsLiveShadow += 8;\n+            this.bsBuff = bsBuffShadow;\n+        }\n+\n+        this.bsLive = bsLiveShadow - 1;\n+        return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n+    }\n+\n+    private char bsGetUByte() throws IOException {\n         return (char) bsR(8);\n     }\n \n-    private int bsGetint() {\n-        int u = 0;\n-        u = (u << 8) | bsR(8);\n-        u = (u << 8) | bsR(8);\n-        u = (u << 8) | bsR(8);\n-        u = (u << 8) | bsR(8);\n-        return u;\n-    }\n-\n-    private int bsGetIntVS(int numBits) {\n-        return (int) bsR(numBits);\n-    }\n-\n-    private int bsGetInt32() {\n-        return (int) bsGetint();\n-    }\n-\n-    private void hbCreateDecodeTables(int[] limit, int[] base,\n-                                      int[] perm, char[] length,\n-                                      int minLen, int maxLen, int alphaSize) {\n-        int pp, i, j, vec;\n-\n-        pp = 0;\n-        for (i = minLen; i <= maxLen; i++) {\n-            for (j = 0; j < alphaSize; j++) {\n+    private int bsGetInt() throws IOException {\n+        return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n+    }\n+\n+    /**\n+     * Called by createHuffmanDecodingTables() exclusively.\n+     */\n+    private static void hbCreateDecodeTables(final int[] limit,\n+                                             final int[] base,\n+                                             final int[] perm,\n+                                             final char[] length,\n+                                             final int minLen,\n+                                             final int maxLen,\n+                                             final int alphaSize) {\n+        for (int i = minLen, pp = 0; i <= maxLen; i++) {\n+            for (int j = 0; j < alphaSize; j++) {\n                 if (length[j] == i) {\n-                    perm[pp] = j;\n-                    pp++;\n-                }\n-            }\n-        }\n-\n-        for (i = 0; i < MAX_CODE_LEN; i++) {\n+                    perm[pp++] = j;\n+                }\n+            }\n+        }\n+\n+        for (int i = MAX_CODE_LEN; --i > 0;) {\n             base[i] = 0;\n-        }\n-        for (i = 0; i < alphaSize; i++) {\n+            limit[i] = 0;\n+        }\n+\n+        for (int i = 0; i < alphaSize; i++) {\n             base[length[i] + 1]++;\n         }\n \n-        for (i = 1; i < MAX_CODE_LEN; i++) {\n-            base[i] += base[i - 1];\n-        }\n-\n-        for (i = 0; i < MAX_CODE_LEN; i++) {\n-            limit[i] = 0;\n-        }\n-        vec = 0;\n-\n-        for (i = minLen; i <= maxLen; i++) {\n-            vec += (base[i + 1] - base[i]);\n+        for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\n+            b += base[i];\n+            base[i] = b;\n+        }\n+\n+        for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\n+            final int nb = base[i + 1];\n+            vec += nb - b;\n+            b = nb;\n             limit[i] = vec - 1;\n             vec <<= 1;\n         }\n-        for (i = minLen + 1; i <= maxLen; i++) {\n+\n+        for (int i = minLen + 1; i <= maxLen; i++) {\n             base[i] = ((limit[i - 1] + 1) << 1) - base[i];\n         }\n     }\n \n-    private void recvDecodingTables() {\n-        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n-        int i, j, t, nGroups, nSelectors, alphaSize;\n-        int minLen, maxLen;\n-        boolean[] inUse16 = new boolean[16];\n+    private void recvDecodingTables() throws IOException {\n+        final Data dataShadow     = this.data;\n+        final boolean[] inUse     = dataShadow.inUse;\n+        final byte[] pos          = dataShadow.recvDecodingTables_pos;\n+        final byte[] selector     = dataShadow.selector;\n+        final byte[] selectorMtf  = dataShadow.selectorMtf;\n+\n+        int inUse16 = 0;\n \n         /* Receive the mapping table */\n-        for (i = 0; i < 16; i++) {\n-            if (bsR(1) == 1) {\n-                inUse16[i] = true;\n-            } else {\n-                inUse16[i] = false;\n-            }\n-        }\n-\n-        for (i = 0; i < 256; i++) {\n+        for (int i = 0; i < 16; i++) {\n+            if (bsGetBit()) {\n+                inUse16 |= 1 << i;\n+            }\n+        }\n+\n+        for (int i = 256; --i >= 0;) {\n             inUse[i] = false;\n         }\n \n-        for (i = 0; i < 16; i++) {\n-            if (inUse16[i]) {\n-                for (j = 0; j < 16; j++) {\n-                    if (bsR(1) == 1) {\n-                        inUse[i * 16 + j] = true;\n+        for (int i = 0; i < 16; i++) {\n+            if ((inUse16 & (1 << i)) != 0) {\n+                final int i16 = i << 4;\n+                for (int j = 0; j < 16; j++) {\n+                    if (bsGetBit()) {\n+                        inUse[i16 + j] = true;\n                     }\n                 }\n             }\n         }\n \n         makeMaps();\n-        alphaSize = nInUse + 2;\n+        final int alphaSize = this.nInUse + 2;\n \n         /* Now the selectors */\n-        nGroups = bsR(3);\n-        nSelectors = bsR(15);\n-        for (i = 0; i < nSelectors; i++) {\n-            j = 0;\n-            while (bsR(1) == 1) {\n+        final int nGroups = bsR(3);\n+        final int nSelectors = bsR(15);\n+\n+        for (int i = 0; i < nSelectors; i++) {\n+            int j = 0;\n+            while (bsGetBit()) {\n                 j++;\n             }\n-            selectorMtf[i] = (char) j;\n+            selectorMtf[i] = (byte) j;\n         }\n \n         /* Undo the MTF values for the selectors. */\n-        {\n-            char[] pos = new char[N_GROUPS];\n-            char tmp, v;\n-            for (v = 0; v < nGroups; v++) {\n-                pos[v] = v;\n-            }\n-\n-            for (i = 0; i < nSelectors; i++) {\n-                v = selectorMtf[i];\n-                tmp = pos[v];\n-                while (v > 0) {\n-                    pos[v] = pos[v - 1];\n-                    v--;\n-                }\n-                pos[0] = tmp;\n-                selector[i] = tmp;\n-            }\n-        }\n+        for (int v = nGroups; --v >= 0;) {\n+            pos[v] = (byte) v;\n+        }\n+\n+        for (int i = 0; i < nSelectors; i++) {\n+            int v = selectorMtf[i] & 0xff;\n+            final byte tmp = pos[v];\n+            while (v > 0) {\n+                // nearly all times v is zero, 4 in most other cases\n+                pos[v] = pos[v - 1];\n+                v--;\n+            }\n+            pos[0] = tmp;\n+            selector[i] = tmp;\n+        }\n+\n+        final char[][] len  = dataShadow.temp_charArray2d;\n \n         /* Now the coding tables */\n-        for (t = 0; t < nGroups; t++) {\n+        for (int t = 0; t < nGroups; t++) {\n             int curr = bsR(5);\n-            for (i = 0; i < alphaSize; i++) {\n-                while (bsR(1) == 1) {\n-                    if (bsR(1) == 0) {\n-                        curr++;\n-                    } else {\n-                        curr--;\n-                    }\n-                }\n-                len[t][i] = (char) curr;\n-            }\n-        }\n-\n-        /* Create the Huffman decoding tables */\n-        for (t = 0; t < nGroups; t++) {\n-            minLen = 32;\n-            maxLen = 0;\n-            for (i = 0; i < alphaSize; i++) {\n-                if (len[t][i] > maxLen) {\n-                    maxLen = len[t][i];\n-                }\n-                if (len[t][i] < minLen) {\n-                    minLen = len[t][i];\n+            final char[] len_t = len[t];\n+            for (int i = 0; i < alphaSize; i++) {\n+                while (bsGetBit()) {\n+                    curr += bsGetBit() ? -1 : 1;\n+                }\n+                len_t[i] = (char) curr;\n+            }\n+        }\n+\n+        // finally create the Huffman tables\n+        createHuffmanDecodingTables(alphaSize, nGroups);\n+    }\n+\n+    /**\n+     * Called by recvDecodingTables() exclusively.\n+     */\n+    private void createHuffmanDecodingTables(final int alphaSize,\n+                                             final int nGroups) {\n+        final Data dataShadow = this.data;\n+        final char[][] len  = dataShadow.temp_charArray2d;\n+        final int[] minLens = dataShadow.minLens;\n+        final int[][] limit = dataShadow.limit;\n+        final int[][] base  = dataShadow.base;\n+        final int[][] perm  = dataShadow.perm;\n+\n+        for (int t = 0; t < nGroups; t++) {\n+            int minLen = 32;\n+            int maxLen = 0;\n+            final char[] len_t = len[t];\n+            for (int i = alphaSize; --i >= 0;) {\n+                final char lent = len_t[i];\n+                if (lent > maxLen) {\n+                    maxLen = lent;\n+                }\n+                if (lent < minLen) {\n+                    minLen = lent;\n                 }\n             }\n             hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\n         }\n     }\n \n-    private void getAndMoveToFrontDecode() {\n-        char[] yy = new char[256];\n-        int i, j, nextSym, limitLast;\n-        int EOB, groupNo, groupPos;\n-\n-        limitLast = baseBlockSize * blockSize100k;\n-        origPtr = bsGetIntVS(24);\n-\n+    private void getAndMoveToFrontDecode() throws IOException {\n+        this.origPtr = bsR(24);\n         recvDecodingTables();\n-        EOB = nInUse + 1;\n-        groupNo = -1;\n-        groupPos = 0;\n+\n+        final InputStream inShadow = this.in;\n+        final Data dataShadow   = this.data;\n+        final byte[] ll8        = dataShadow.ll8;\n+        final int[] unzftab     = dataShadow.unzftab;\n+        final byte[] selector   = dataShadow.selector;\n+        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n+        final char[] yy         = dataShadow.getAndMoveToFrontDecode_yy;\n+        final int[] minLens     = dataShadow.minLens;\n+        final int[][] limit     = dataShadow.limit;\n+        final int[][] base      = dataShadow.base;\n+        final int[][] perm      = dataShadow.perm;\n+        final int limitLast     = this.blockSize100k * 100000;\n \n         /*\n           Setting up the unzftab entries here is not strictly\n           in a separate pass, and so saves a block's worth of\n           cache misses.\n         */\n-        for (i = 0; i <= 255; i++) {\n+        for (int i = 256; --i >= 0;) {\n+            yy[i] = (char) i;\n             unzftab[i] = 0;\n         }\n \n-        for (i = 0; i <= 255; i++) {\n-            yy[i] = (char) i;\n-        }\n-\n-        last = -1;\n-\n-        {\n-            int zt, zn, zvec, zj;\n-            if (groupPos == 0) {\n-                groupNo++;\n-                groupPos = G_SIZE;\n-            }\n-            groupPos--;\n-            zt = selector[groupNo];\n-            zn = minLens[zt];\n-            zvec = bsR(zn);\n-            while (zvec > limit[zt][zn]) {\n-                zn++;\n-                {\n-                    {\n-                        while (bsLive < 1) {\n-                            int zzi;\n-                            char thech = 0;\n-                            try {\n-                                thech = (char) bsStream.read();\n-                            } catch (IOException e) {\n-                                compressedStreamEOF();\n-                            }\n-                            if (thech == -1) {\n-                                compressedStreamEOF();\n-                            }\n-                            zzi = thech;\n-                            bsBuff = (bsBuff << 8) | (zzi & 0xff);\n-                            bsLive += 8;\n+        int groupNo     = 0;\n+        int groupPos    = G_SIZE - 1;\n+        final int eob   = this.nInUse + 1;\n+        int nextSym     = getAndMoveToFrontDecode0(0);\n+        int bsBuffShadow      = this.bsBuff;\n+        int bsLiveShadow      = this.bsLive;\n+        int lastShadow        = -1;\n+        int zt          = selector[groupNo] & 0xff;\n+        int[] base_zt   = base[zt];\n+        int[] limit_zt  = limit[zt];\n+        int[] perm_zt   = perm[zt];\n+        int minLens_zt  = minLens[zt];\n+\n+        while (nextSym != eob) {\n+            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n+                int s = -1;\n+\n+                for (int n = 1; true; n <<= 1) {\n+                    if (nextSym == RUNA) {\n+                        s += n;\n+                    } else if (nextSym == RUNB) {\n+                        s += n << 1;\n+                    } else {\n+                        break;\n+                    }\n+\n+                    if (groupPos == 0) {\n+                        groupPos    = G_SIZE - 1;\n+                        zt          = selector[++groupNo] & 0xff;\n+                        base_zt     = base[zt];\n+                        limit_zt    = limit[zt];\n+                        perm_zt     = perm[zt];\n+                        minLens_zt  = minLens[zt];\n+                    } else {\n+                        groupPos--;\n+                    }\n+\n+                    int zn = minLens_zt;\n+\n+                    // Inlined:\n+                    // int zvec = bsR(zn);\n+                    while (bsLiveShadow < zn) {\n+                        final int thech = inShadow.read();\n+                        if (thech >= 0) {\n+                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                            bsLiveShadow += 8;\n+                            continue;\n+                        } else {\n+                            throw new IOException(\"unexpected end of stream\");\n                         }\n                     }\n-                    zj = (bsBuff >> (bsLive - 1)) & 1;\n-                    bsLive--;\n-                }\n-                zvec = (zvec << 1) | zj;\n-            }\n-            nextSym = perm[zt][zvec - base[zt][zn]];\n-        }\n-\n-        while (true) {\n-\n-            if (nextSym == EOB) {\n-                break;\n-            }\n-\n-            if (nextSym == RUNA || nextSym == RUNB) {\n-                char ch;\n-                int s = -1;\n-                int N = 1;\n-                do {\n-                    if (nextSym == RUNA) {\n-                        s = s + (0 + 1) * N;\n-                    } else if (nextSym == RUNB) {\n-                        s = s + (1 + 1) * N;\n-                           }\n-                    N = N * 2;\n-                    {\n-                        int zt, zn, zvec, zj;\n-                        if (groupPos == 0) {\n-                            groupNo++;\n-                            groupPos = G_SIZE;\n+                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);\n+                    bsLiveShadow -= zn;\n+\n+                    while (zvec > limit_zt[zn]) {\n+                        zn++;\n+                        while (bsLiveShadow < 1) {\n+                            final int thech = inShadow.read();\n+                            if (thech >= 0) {\n+                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                                bsLiveShadow += 8;\n+                                continue;\n+                            } else {\n+                                throw new IOException(\"unexpected end of stream\");\n+                            }\n                         }\n-                        groupPos--;\n-                        zt = selector[groupNo];\n-                        zn = minLens[zt];\n-                        zvec = bsR(zn);\n-                        while (zvec > limit[zt][zn]) {\n-                            zn++;\n-                            {\n-                                {\n-                                    while (bsLive < 1) {\n-                                        int zzi;\n-                                        char thech = 0;\n-                                        try {\n-                                            thech = (char) bsStream.read();\n-                                        } catch (IOException e) {\n-                                            compressedStreamEOF();\n-                                        }\n-                                        if (thech == -1) {\n-                                            compressedStreamEOF();\n-                                        }\n-                                        zzi = thech;\n-                                        bsBuff = (bsBuff << 8) | (zzi & 0xff);\n-                                        bsLive += 8;\n-                                    }\n-                                }\n-                                zj = (bsBuff >> (bsLive - 1)) & 1;\n-                                bsLive--;\n-                            }\n-                            zvec = (zvec << 1) | zj;\n-                        }\n-                        nextSym = perm[zt][zvec - base[zt][zn]];\n+                        bsLiveShadow--;\n+                        zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                     }\n-                } while (nextSym == RUNA || nextSym == RUNB);\n-\n-                s++;\n-                ch = seqToUnseq[yy[0]];\n-                unzftab[ch] += s;\n-\n-                while (s > 0) {\n-                    last++;\n-                    ll8[last] = ch;\n-                    s--;\n-                }\n-\n-                if (last >= limitLast) {\n-                    blockOverrun();\n-                }\n-                continue;\n+                    nextSym = perm_zt[zvec - base_zt[zn]];\n+                }\n+\n+                final byte ch = seqToUnseq[yy[0]];\n+                unzftab[ch & 0xff] += s + 1;\n+\n+                while (s-- >= 0) {\n+                    ll8[++lastShadow] = ch;\n+                }\n+\n+                if (lastShadow >= limitLast) {\n+                    throw new IOException(\"block overrun\");\n+                }\n             } else {\n-                char tmp;\n-                last++;\n-                if (last >= limitLast) {\n-                    blockOverrun();\n-                }\n-\n-                tmp = yy[nextSym - 1];\n-                unzftab[seqToUnseq[tmp]]++;\n-                ll8[last] = seqToUnseq[tmp];\n+                if (++lastShadow >= limitLast) {\n+                    throw new IOException(\"block overrun\");\n+                }\n+\n+                final char tmp = yy[nextSym - 1];\n+                unzftab[seqToUnseq[tmp] & 0xff]++;\n+                ll8[lastShadow] = seqToUnseq[tmp];\n \n                 /*\n                   This loop is hammered during decompression,\n-                  hence the unrolling.\n-\n-                  for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];\n+                  hence avoid native method call overhead of\n+                  System.arraycopy for very small ranges to copy.\n                 */\n-\n-                j = nextSym - 1;\n-                for (; j > 3; j -= 4) {\n-                    yy[j]     = yy[j - 1];\n-                    yy[j - 1] = yy[j - 2];\n-                    yy[j - 2] = yy[j - 3];\n-                    yy[j - 3] = yy[j - 4];\n-                }\n-                for (; j > 0; j--) {\n-                    yy[j] = yy[j - 1];\n+                if (nextSym <= 16) {\n+                    for (int j = nextSym - 1; j > 0;) {\n+                        yy[j] = yy[--j];\n+                    }\n+                } else {\n+                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                 }\n \n                 yy[0] = tmp;\n-                {\n-                    int zt, zn, zvec, zj;\n-                    if (groupPos == 0) {\n-                        groupNo++;\n-                        groupPos = G_SIZE;\n+\n+                if (groupPos == 0) {\n+                    groupPos    = G_SIZE - 1;\n+                    zt          = selector[++groupNo] & 0xff;\n+                    base_zt     = base[zt];\n+                    limit_zt    = limit[zt];\n+                    perm_zt     = perm[zt];\n+                    minLens_zt  = minLens[zt];\n+                } else {\n+                    groupPos--;\n+                }\n+\n+                int zn = minLens_zt;\n+\n+                // Inlined:\n+                // int zvec = bsR(zn);\n+                while (bsLiveShadow < zn) {\n+                    final int thech = inShadow.read();\n+                    if (thech >= 0) {\n+                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                        bsLiveShadow += 8;\n+                        continue;\n+                    } else {\n+                        throw new IOException(\"unexpected end of stream\");\n                     }\n-                    groupPos--;\n-                    zt = selector[groupNo];\n-                    zn = minLens[zt];\n-                    zvec = bsR(zn);\n-                    while (zvec > limit[zt][zn]) {\n-                        zn++;\n-                        {\n-                            {\n-                                while (bsLive < 1) {\n-                                    int zzi;\n-                                    char thech = 0;\n-                                    try {\n-                                        thech = (char) bsStream.read();\n-                                    } catch (IOException e) {\n-                                        compressedStreamEOF();\n-                                    }\n-                                    zzi = thech;\n-                                    bsBuff = (bsBuff << 8) | (zzi & 0xff);\n-                                    bsLive += 8;\n-                                }\n-                            }\n-                            zj = (bsBuff >> (bsLive - 1)) & 1;\n-                            bsLive--;\n+                }\n+                int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);\n+                bsLiveShadow -= zn;\n+\n+                while (zvec > limit_zt[zn]) {\n+                    zn++;\n+                    while (bsLiveShadow < 1) {\n+                        final int thech = inShadow.read();\n+                        if (thech >= 0) {\n+                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                            bsLiveShadow += 8;\n+                            continue;\n+                        } else {\n+                            throw new IOException(\"unexpected end of stream\");\n                         }\n-                        zvec = (zvec << 1) | zj;\n                     }\n-                    nextSym = perm[zt][zvec - base[zt][zn]];\n-                }\n-                continue;\n-            }\n-        }\n-    }\n-\n-    private void setupBlock() {\n-        int[] cftab = new int[257];\n-        char ch;\n-\n+                    bsLiveShadow--;\n+                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                }\n+                nextSym = perm_zt[zvec - base_zt[zn]];\n+            }\n+        }\n+\n+        this.last = lastShadow;\n+        this.bsLive = bsLiveShadow;\n+        this.bsBuff = bsBuffShadow;\n+    }\n+\n+    private int getAndMoveToFrontDecode0(final int groupNo)\n+        throws IOException {\n+        final InputStream inShadow  = this.in;\n+        final Data dataShadow  = this.data;\n+        final int zt          = dataShadow.selector[groupNo] & 0xff;\n+        final int[] limit_zt  = dataShadow.limit[zt];\n+        int zn = dataShadow.minLens[zt];\n+        int zvec = bsR(zn);\n+        int bsLiveShadow = this.bsLive;\n+        int bsBuffShadow = this.bsBuff;\n+\n+        while (zvec > limit_zt[zn]) {\n+            zn++;\n+            while (bsLiveShadow < 1) {\n+                final int thech = inShadow.read();\n+\n+                if (thech >= 0) {\n+                    bsBuffShadow = (bsBuffShadow << 8) | thech;\n+                    bsLiveShadow += 8;\n+                    continue;\n+                } else {\n+                    throw new IOException(\"unexpected end of stream\");\n+                }\n+            }\n+            bsLiveShadow--;\n+            zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n+        }\n+\n+        this.bsLive = bsLiveShadow;\n+        this.bsBuff = bsBuffShadow;\n+\n+        return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n+    }\n+\n+    private void setupBlock() throws IOException {\n+        if (this.data == null) {\n+            return;\n+        }\n+\n+        final int[] cftab = this.data.cftab;\n+        final int[] tt    = this.data.initTT(this.last + 1);\n+        final byte[] ll8  = this.data.ll8;\n         cftab[0] = 0;\n-        for (i = 1; i <= 256; i++) {\n-            cftab[i] = unzftab[i - 1];\n-        }\n-        for (i = 1; i <= 256; i++) {\n-            cftab[i] += cftab[i - 1];\n-        }\n-\n-        for (i = 0; i <= last; i++) {\n-            ch = (char) ll8[i];\n-            tt[cftab[ch]] = i;\n-            cftab[ch]++;\n-        }\n-        cftab = null;\n-\n-        tPos = tt[origPtr];\n-\n-        count = 0;\n-        i2 = 0;\n-        ch2 = 256;   /* not a char and not EOF */\n-\n-        if (blockRandomised) {\n-            rNToGo = 0;\n-            rTPos = 0;\n+        System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n+\n+        for (int i = 1, c = cftab[0]; i <= 256; i++) {\n+            c += cftab[i];\n+            cftab[i] = c;\n+        }\n+\n+        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\n+            tt[cftab[ll8[i] & 0xff]++] = i;\n+        }\n+\n+        if ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\n+            throw new IOException(\"stream corrupted\");\n+        }\n+\n+        this.su_tPos = tt[this.origPtr];\n+        this.su_count = 0;\n+        this.su_i2 = 0;\n+        this.su_ch2 = 256;   /* not a char and not EOF */\n+\n+        if (this.blockRandomised) {\n+            this.su_rNToGo = 0;\n+            this.su_rTPos = 0;\n             setupRandPartA();\n         } else {\n             setupNoRandPartA();\n         }\n     }\n \n-    private void setupRandPartA() {\n-        if (i2 <= last) {\n-            chPrev = ch2;\n-            ch2 = ll8[tPos];\n-            tPos = tt[tPos];\n-            if (rNToGo == 0) {\n-                rNToGo = rNums[rTPos];\n-                rTPos++;\n-                if (rTPos == 512) {\n-                    rTPos = 0;\n-                }\n-            }\n-            rNToGo--;\n-            ch2 ^= (int) ((rNToGo == 1) ? 1 : 0);\n-            i2++;\n-\n-            currentChar = ch2;\n-            currentState = RAND_PART_B_STATE;\n-            mCrc.updateCRC(ch2);\n+    private void setupRandPartA() throws IOException {\n+        if (this.su_i2 <= this.last) {\n+            this.su_chPrev = this.su_ch2;\n+            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n+            this.su_tPos = this.data.tt[this.su_tPos];\n+            if (this.su_rNToGo == 0) {\n+                this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1;\n+                if (++this.su_rTPos == 512) {\n+                    this.su_rTPos = 0;\n+                }\n+            } else {\n+                this.su_rNToGo--;\n+            }\n+            this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\n+            this.su_i2++;\n+            this.currentChar = su_ch2Shadow;\n+            this.currentState = RAND_PART_B_STATE;\n+            this.crc.updateCRC(su_ch2Shadow);\n         } else {\n             endBlock();\n             initBlock();\n         }\n     }\n \n-    private void setupNoRandPartA() {\n-        if (i2 <= last) {\n-            chPrev = ch2;\n-            ch2 = ll8[tPos];\n-            tPos = tt[tPos];\n-            i2++;\n-\n-            currentChar = ch2;\n-            currentState = NO_RAND_PART_B_STATE;\n-            mCrc.updateCRC(ch2);\n+    private void setupNoRandPartA() throws IOException {\n+        if (this.su_i2 <= this.last) {\n+            this.su_chPrev = this.su_ch2;\n+            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n+            this.su_ch2 = su_ch2Shadow;\n+            this.su_tPos = this.data.tt[this.su_tPos];\n+            this.su_i2++;\n+            this.currentChar = su_ch2Shadow;\n+            this.currentState = NO_RAND_PART_B_STATE;\n+            this.crc.updateCRC(su_ch2Shadow);\n         } else {\n+            this.currentState = NO_RAND_PART_A_STATE;\n             endBlock();\n             initBlock();\n             setupBlock();\n         }\n     }\n \n-    private void setupRandPartB() {\n-        if (ch2 != chPrev) {\n-            currentState = RAND_PART_A_STATE;\n-            count = 1;\n+    private void setupRandPartB() throws IOException {\n+        if (this.su_ch2 != this.su_chPrev) {\n+            this.currentState = RAND_PART_A_STATE;\n+            this.su_count = 1;\n             setupRandPartA();\n+        } else if (++this.su_count >= 4) {\n+            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n+            this.su_tPos = this.data.tt[this.su_tPos];\n+            if (this.su_rNToGo == 0) {\n+                this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1;\n+                if (++this.su_rTPos == 512) {\n+                    this.su_rTPos = 0;\n+                }\n+            } else {\n+                this.su_rNToGo--;\n+            }\n+            this.su_j2 = 0;\n+            this.currentState = RAND_PART_C_STATE;\n+            if (this.su_rNToGo == 1) {\n+                this.su_z ^= 1;\n+            }\n+            setupRandPartC();\n         } else {\n-            count++;\n-            if (count >= 4) {\n-                z = ll8[tPos];\n-                tPos = tt[tPos];\n-                if (rNToGo == 0) {\n-                    rNToGo = rNums[rTPos];\n-                    rTPos++;\n-                    if (rTPos == 512) {\n-                        rTPos = 0;\n-                    }\n-                }\n-                rNToGo--;\n-                z ^= ((rNToGo == 1) ? 1 : 0);\n-                j2 = 0;\n-                currentState = RAND_PART_C_STATE;\n-                setupRandPartC();\n-            } else {\n-                currentState = RAND_PART_A_STATE;\n-                setupRandPartA();\n-            }\n-        }\n-    }\n-\n-    private void setupRandPartC() {\n-        if (j2 < (int) z) {\n-            currentChar = ch2;\n-            mCrc.updateCRC(ch2);\n-            j2++;\n+            this.currentState = RAND_PART_A_STATE;\n+            setupRandPartA();\n+        }\n+    }\n+\n+    private void setupRandPartC() throws IOException {\n+        if (this.su_j2 < this.su_z) {\n+            this.currentChar = this.su_ch2;\n+            this.crc.updateCRC(this.su_ch2);\n+            this.su_j2++;\n         } else {\n-            currentState = RAND_PART_A_STATE;\n-            i2++;\n-            count = 0;\n+            this.currentState = RAND_PART_A_STATE;\n+            this.su_i2++;\n+            this.su_count = 0;\n             setupRandPartA();\n         }\n     }\n \n-    private void setupNoRandPartB() {\n-        if (ch2 != chPrev) {\n-            currentState = NO_RAND_PART_A_STATE;\n-            count = 1;\n+    private void setupNoRandPartB() throws IOException {\n+        if (this.su_ch2 != this.su_chPrev) {\n+            this.su_count = 1;\n             setupNoRandPartA();\n+        } else if (++this.su_count >= 4) {\n+            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n+            this.su_tPos = this.data.tt[this.su_tPos];\n+            this.su_j2 = 0;\n+            setupNoRandPartC();\n         } else {\n-            count++;\n-            if (count >= 4) {\n-                z = ll8[tPos];\n-                tPos = tt[tPos];\n-                currentState = NO_RAND_PART_C_STATE;\n-                j2 = 0;\n-                setupNoRandPartC();\n-            } else {\n-                currentState = NO_RAND_PART_A_STATE;\n-                setupNoRandPartA();\n-            }\n-        }\n-    }\n-\n-    private void setupNoRandPartC() {\n-        if (j2 < (int) z) {\n-            currentChar = ch2;\n-            mCrc.updateCRC(ch2);\n-            j2++;\n+            setupNoRandPartA();\n+        }\n+    }\n+\n+    private void setupNoRandPartC() throws IOException {\n+        if (this.su_j2 < this.su_z) {\n+            int su_ch2Shadow = this.su_ch2;\n+            this.currentChar = su_ch2Shadow;\n+            this.crc.updateCRC(su_ch2Shadow);\n+            this.su_j2++;\n+            this.currentState = NO_RAND_PART_C_STATE;\n         } else {\n-            currentState = NO_RAND_PART_A_STATE;\n-            i2++;\n-            count = 0;\n+            this.su_i2++;\n+            this.su_count = 0;\n             setupNoRandPartA();\n         }\n     }\n \n-    private void setDecompressStructureSizes(int newSize100k) {\n-        if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k\n-               && blockSize100k <= 9)) {\n-            // throw new IOException(\"Invalid block size\");\n-        }\n-\n-        blockSize100k = newSize100k;\n-\n-        if (newSize100k == 0) {\n-            return;\n-        }\n-\n-        int n = baseBlockSize * newSize100k;\n-        ll8 = new char[n];\n-        tt = new int[n];\n-    }\n+    private static final class Data extends Object {\n+\n+        // (with blockSize 900k)\n+        final boolean[] inUse   = new boolean[256];                                   //      256 byte\n+\n+        final byte[] seqToUnseq   = new byte[256];                                    //      256 byte\n+        final byte[] selector     = new byte[MAX_SELECTORS];                          //    18002 byte\n+        final byte[] selectorMtf  = new byte[MAX_SELECTORS];                          //    18002 byte\n+\n+        /**\n+         * Freq table collected to save a pass over the data during\n+         * decompression.\n+         */\n+        final int[] unzftab = new int[256];                                           //     1024 byte\n+\n+        final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n+        final int[][] base  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n+        final int[][] perm  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n+        final int[] minLens = new int[N_GROUPS];                                      //       24 byte\n+\n+        final int[]     cftab     = new int[257];                                     //     1028 byte\n+        final char[]    getAndMoveToFrontDecode_yy = new char[256];                   //      512 byte\n+        final char[][]  temp_charArray2d  = new char[N_GROUPS][MAX_ALPHA_SIZE];       //     3096 byte\n+        final byte[] recvDecodingTables_pos = new byte[N_GROUPS];                     //        6 byte\n+        //---------------\n+        //    60798 byte\n+\n+        int[] tt;                                                                     //  3600000 byte\n+        byte[] ll8;                                                                   //   900000 byte\n+        //---------------\n+        //  4560782 byte\n+        //===============\n+\n+        Data(int blockSize100k) {\n+            super();\n+\n+            this.ll8 = new byte[blockSize100k * BZip2Constants.baseBlockSize];\n+        }\n+\n+        /**\n+         * Initializes the {@link #tt} array.\n+         *\n+         * This method is called when the required length of the array\n+         * is known.  I don't initialize it at construction time to\n+         * avoid unneccessary memory allocation when compressing small\n+         * files.\n+         */\n+        final int[] initTT(int length) {\n+            int[] ttShadow = this.tt;\n+\n+            // tt.length should always be >= length, but theoretically\n+            // it can happen, if the compressor mixed small and large\n+            // blocks.  Normally only the last block will be smaller\n+            // than others.\n+            if ((ttShadow == null) || (ttShadow.length < length)) {\n+                this.tt = ttShadow = new int[length];\n+            }\n+\n+            return ttShadow;\n+        }\n+\n+    }\n+\n }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n \n                 weight[nNodes] = ((weight[n1] & 0xffffff00)\n                                   + (weight[n2] & 0xffffff00))\n-                    | (1 + (((weight[n1] & 0x000000ff) >\n-                             (weight[n2] & 0x000000ff)) ?\n-                            (weight[n1] & 0x000000ff) :\n-                            (weight[n2] & 0x000000ff)));\n+                    | (1 + (((weight[n1] & 0x000000ff)\n+                            > (weight[n2] & 0x000000ff))\n+                            ? (weight[n1] & 0x000000ff)\n+                            : (weight[n2] & 0x000000ff)));\n \n                 parent[nNodes] = -1;\n                 nHeap++;\n         combinedCRC = (combinedCRC << 1) | (combinedCRC >>> 31);\n         combinedCRC ^= blockCRC;\n \n+        // If the stream was empty we must skip the rest of this method.\n+        // See bug#32200.\n+        if (last == -1) {\n+\t    return;\n+        }\n+        \n         /* sort the block and establish posn of original string */\n         doReversibleTransformation();\n \n                     code[i] = vec;\n                     vec++;\n                 }\n-            };\n+            }\n             vec <<= 1;\n         }\n     }\n \n         int v, t, i, j, gs, ge, totc, bt, bc, iter;\n         int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n-        int nGroups;\n-        //int nBytes;\n+        int nGroups, nBytes;\n \n         alphaSize = nInUse + 2;\n         for (t = 0; t < N_GROUPS; t++) {\n                         bc = cost[t];\n                         bt = t;\n                     }\n-                };\n+                }\n                 totc += bc;\n                 fave[bt]++;\n                 selector[nSelectors] = (char) bt;\n                 }\n             }\n \n-            //nBytes = bytesOut;\n+            nBytes = bytesOut;\n             for (i = 0; i < 16; i++) {\n                 if (inUse16[i]) {\n                     bsW(1, 1);\n         }\n \n         /* Now the selectors. */\n-        //nBytes = bytesOut;\n+        nBytes = bytesOut;\n         bsW (3, nGroups);\n         bsW (15, nSelectors);\n         for (i = 0; i < nSelectors; i++) {\n         }\n \n         /* Now the coding tables. */\n-        //nBytes = bytesOut;\n+        nBytes = bytesOut;\n \n         for (t = 0; t < nGroups; t++) {\n             int curr = len[t][0];\n         }\n \n         /* And finally, the block data proper */\n-        //nBytes = bytesOut;\n+        nBytes = bytesOut;\n         selCtr = 0;\n         gs = 0;\n         while (true) {\n         int dd;\n     }\n \n-    private void qSort3(int loSt, int hiSt, int dSt) {\n+    private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack) {\n         int unLo, unHi, ltLo, gtHi, med, n, m;\n         int sp, lo, hi, d;\n-        StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n-        for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n-            stack[count] = new StackElem();\n-        }\n \n         sp = 0;\n \n                         ltLo++;\n                         unLo++;\n                         continue;\n-                    };\n+                    }\n                     if (n >  0) {\n                         break;\n                     }\n                         gtHi--;\n                         unHi--;\n                         continue;\n-                    };\n+                    }\n                     if (n <  0) {\n                         break;\n                     }\n         */\n \n         //   if (verbosity >= 4) fprintf ( stderr, \"   sort initialise ...\\n\" );\n+\n         for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) {\n             block[last + i + 2] = block[(i % (last + 1)) + 1];\n         }\n                         vv = runningOrder[i];\n                         j = i;\n                         while ((ftab[((runningOrder[j - h]) + 1) << 8]\n-                                - ftab[(runningOrder[j - h]) << 8]) >\n-                               (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n+                                - ftab[(runningOrder[j - h]) << 8])\n+                                > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {\n                             runningOrder[j] = runningOrder[j - h];\n                             j = j - h;\n                             if (j <= (h - 1)) {\n                         runningOrder[j] = vv;\n                     }\n                 } while (h != 1);\n+            }\n+\n+            StackElem[] stack = new StackElem[QSORT_STACK_SIZE];\n+            for (int count = 0; count < QSORT_STACK_SIZE; count++) {\n+                stack[count] = new StackElem();\n             }\n \n             /*\n                         int lo = ftab[sb] & CLEARMASK;\n                         int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                         if (hi > lo) {\n-                            qSort3(lo, hi, 2);\n+                            qSort3(lo, hi, 2, stack);\n                             numQSorted += (hi - lo + 1);\n                             if (workDone > workLimit && firstAttempt) {\n                                 return;\n                 origPtr = i;\n                 break;\n             }\n-        };\n+        }\n \n         if (origPtr == -1) {\n             panic();\n             if (i1 > last) {\n                 i1 -= last;\n                 i1--;\n-            };\n+            }\n             if (i2 > last) {\n                 i2 -= last;\n                 i2--;\n-            };\n+            }\n \n             k -= 4;\n             workDone++;\n       because the number of elems to sort is\n       usually small, typically <= 20.\n     */\n-    private int[] incs = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n+    private int[] incs = {1, 4, 13, 40, 121, 364, 1093, 3280,\n                            9841, 29524, 88573, 265720,\n-                           797161, 2391484 };\n+                           797161, 2391484};\n \n     private void allocateCompressStructures () {\n         int n = baseBlockSize * blockSize100k;\n                 tmp2 = tmp;\n                 tmp = yy[j];\n                 yy[j] = tmp2;\n-            };\n+            }\n             yy[0] = tmp;\n \n             if (j == 0) {\n                             wr++;\n                             mtfFreq[RUNB]++;\n                             break;\n-                        };\n+                        }\n                         if (zPend < 2) {\n                             break;\n                         }\n                         zPend = (zPend - 2) / 2;\n-                    };\n+                    }\n                     zPend = 0;\n                 }\n                 szptr[wr] = (short) (j + 1);\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Constants.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Constants.java\n     int MAX_SELECTORS = (2 + (900000 / G_SIZE));\n     int NUM_OVERSHOOT_BYTES = 20;\n \n+    /**\n+     * This array really shouldn't be here.\n+     * Again, for historical purposes it is.\n+     *\n+     * <p>FIXME: This array should be in a private or package private\n+     * location, since it could be modified by malicious code.</p>\n+     */\n     int[] rNums = {\n         619, 720, 127, 481, 931, 816, 813, 233, 566, 247,\n         985, 724, 205, 454, 863, 491, 741, 242, 949, 214,\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n  * data.\n  */\n class CRC {\n-\tprivate static int[] CRC32_TABLE = new int[] { 0x00000000, 0x04c11db7,\n-\t\t\t0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2,\n-\t\t\t0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n-\t\t\t0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70,\n-\t\t\t0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b,\n-\t\t\t0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f, 0x639b0da6,\n-\t\t\t0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n-\t\t\t0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c,\n-\t\t\t0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,\n-\t\t\t0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea,\n-\t\t\t0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n-\t\t\t0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95, 0xf23a8028,\n-\t\t\t0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43,\n-\t\t\t0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0, 0x3d044b19,\n-\t\t\t0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n-\t\t\t0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13,\n-\t\t\t0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0,\n-\t\t\t0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5,\n-\t\t\t0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n-\t\t\t0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba, 0xaca5c697,\n-\t\t\t0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,\n-\t\t\t0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041,\n-\t\t\t0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n-\t\t\t0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b,\n-\t\t\t0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f, 0xc27dede8,\n-\t\t\t0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded,\n-\t\t\t0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n-\t\t\t0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56,\n-\t\t\t0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d,\n-\t\t\t0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629, 0x2c9f00f0,\n-\t\t\t0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n-\t\t\t0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa,\n-\t\t\t0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,\n-\t\t\t0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc,\n-\t\t\t0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n-\t\t\t0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3, 0xbd3e8d7e,\n-\t\t\t0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615,\n-\t\t\t0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71, 0x92b45ba8,\n-\t\t\t0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n-\t\t\t0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645,\n-\t\t\t0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096,\n-\t\t\t0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093,\n-\t\t\t0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n-\t\t\t0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec, 0x3793a651,\n-\t\t\t0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,\n-\t\t\t0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17,\n-\t\t\t0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n-\t\t\t0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d,\n-\t\t\t0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09, 0x8d79e0be,\n-\t\t\t0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb,\n-\t\t\t0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n-\t\t\t0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4 };\n+\t static final int crc32Table[] = {\n+\t        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n+\t        0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n+\t        0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n+\t        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n+\t        0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n+\t        0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n+\t        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n+\t        0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n+\t        0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n+\t        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n+\t        0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n+\t        0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n+\t        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n+\t        0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n+\t        0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n+\t        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n+\t        0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n+\t        0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n+\t        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n+\t        0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n+\t        0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n+\t        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n+\t        0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n+\t        0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n+\t        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n+\t        0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n+\t        0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n+\t        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n+\t        0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n+\t        0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n+\t        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n+\t        0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n+\t        0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n+\t        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n+\t        0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n+\t        0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n+\t        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n+\t        0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n+\t        0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n+\t        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n+\t        0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n+\t        0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n+\t        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n+\t        0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n+\t        0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n+\t        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n+\t        0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n+\t        0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n+\t        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n+\t        0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n+\t        0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n+\t        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n+\t        0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n+\t        0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n+\t        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n+\t        0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n+\t        0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n+\t        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n+\t        0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n+\t        0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n+\t        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n+\t        0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n+\t        0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n+\t        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n+\t    };\n \n-\tprivate int m_globalCrc;\n+\t    CRC() {\n+\t        initialiseCRC();\n+\t    }\n \n-\tprotected CRC() {\n-\t\tinitialiseCRC();\n-\t}\n+\t    void initialiseCRC() {\n+\t        globalCrc = 0xffffffff;\n+\t    }\n \n-\tint getFinalCRC() {\n-\t\treturn ~m_globalCrc;\n-\t}\n+\t    int getFinalCRC() {\n+\t        return ~globalCrc;\n+\t    }\n \n-\tvoid initialiseCRC() {\n-\t\tm_globalCrc = 0xffffffff;\n-\t}\n+\t    int getGlobalCRC() {\n+\t        return globalCrc;\n+\t    }\n \n-\tvoid updateCRC(final int inCh) {\n-\t\tint temp = (m_globalCrc >> 24) ^ inCh;\n-\t\tif (temp < 0) {\n-\t\t\ttemp = 256 + temp;\n-\t\t}\n-\t\tm_globalCrc = (m_globalCrc << 8) ^ CRC32_TABLE[temp];\n-\t}\n+\t    void setGlobalCRC(int newCrc) {\n+\t        globalCrc = newCrc;\n+\t    }\n+\n+\t    void updateCRC(int inCh) {\n+\t        int temp = (globalCrc >> 24) ^ inCh;\n+\t        if (temp < 0) {\n+\t            temp = 256 + temp;\n+\t        }\n+\t        globalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n+\t    }\n+\n+\t    void updateCRC(int inCh, int repeat) {\n+\t        int globalCrcShadow = this.globalCrc;\n+\t        while (repeat-- > 0) {\n+\t            int temp = (globalCrcShadow >> 24) ^ inCh;\n+\t            globalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n+\t                                                      ? temp\n+\t                                                      : (temp + 256)];\n+\t        }\n+\t        this.globalCrc = globalCrcShadow;\n+\t    }\n+\n+\t    int globalCrc;\n }", "timestamp": 1231413230, "metainfo": ""}