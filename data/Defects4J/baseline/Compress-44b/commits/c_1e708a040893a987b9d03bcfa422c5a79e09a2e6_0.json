{"sha": "1e708a040893a987b9d03bcfa422c5a79e09a2e6", "log": "don't rely on archives to implement ZIP64 correctly when reading the data descriptor.  Works around a bug in java.util.ZipArchiveOutputStream of Java7, may be useful for other implementations as well.  COMPRESS-148  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n \n             // Pushback any required bytes\n             if (diff > 0) {\n-                ((PushbackInputStream) in).unread(\n-                        buf,  lengthOfLastRead - diff, diff);\n-                pushedBackBytes(diff);\n+                pushback(buf, lengthOfLastRead - diff, diff);\n             }\n         }\n \n             val = new ZipLong(b);\n         }\n         current.setCrc(val.getValue());\n-        if (!usesZip64) {\n-            readFully(b);\n+\n+        // if there is a ZIP64 extra field, sizes are eight bytes\n+        // each, otherwise four bytes each.  Unfortunately some\n+        // implementations - namely Java7 - use eight bytes without\n+        // using a ZIP64 extra field -\n+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588\n+\n+        // just read 16 bytes and check whether bytes nine to twelve\n+        // look like one of the signatures of what could follow a data\n+        // descriptor (ignoring archive decryption headers for now).\n+        // If so, push back eight bytes and assume sizes are four\n+        // bytes, otherwise sizes are eight bytes each.\n+        b = new byte[2 * DWORD];\n+        readFully(b);\n+        ZipLong potentialSig = new ZipLong(b, DWORD);\n+        if (potentialSig.equals(ZipLong.CFH_SIG)\n+            || potentialSig.equals(ZipLong.LFH_SIG)) {\n+            pushback(b, DWORD, DWORD);\n             current.setCompressedSize(ZipLong.getValue(b));\n-            readFully(b);\n-            current.setSize(ZipLong.getValue(b));\n+            current.setSize(ZipLong.getValue(b, WORD));\n         } else {\n-            byte[] b8 = new byte[DWORD];\n-            readFully(b8);\n-            current.setCompressedSize(ZipEightByteInteger.getLongValue(b8));\n-            readFully(b8);\n-            current.setSize(ZipEightByteInteger.getLongValue(b8));\n+            current.setCompressedSize(ZipEightByteInteger.getLongValue(b));\n+            current.setSize(ZipEightByteInteger.getLongValue(b, DWORD));\n         }\n     }\n \n                         //   descriptor\n                         // * copy the remaining bytes to cache\n                         // * read data descriptor\n-                        ((PushbackInputStream) in).unread(buf, off + r - readTooMuch, readTooMuch);\n+                        pushback(buf, off + r - readTooMuch, readTooMuch);\n                         bos.write(buf, 0, i);\n                         readDataDescriptor();\n                     }\n         byte[] b = bos.toByteArray();\n         lastStoredEntry = new ByteArrayInputStream(b);\n     }\n+\n+    private void pushback(byte[] buf, int offset, int length)\n+        throws IOException {\n+        ((PushbackInputStream) in).unread(buf, offset, length);\n+        pushedBackBytes(length);\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n \n     @Test public void read5GBOfZerosGeneratedByJava7JarUsingInputStream()\n         throws Throwable {\n-        // don't check the size in jar case as jar uses 8-Byte values\n-        // inside the data descriptor without adding a ZIP64 extra\n-        // field, violating the \"spec\".\n-        read5GBOfZerosImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\",\n-                           false);\n+        read5GBOfZerosImpl(get5GBZerosFileGeneratedByJava7Jar(), \"5GB_of_Zeros\");\n     }\n \n     @Test public void read100KFilesUsingInputStream() throws Throwable {\n \n     private static void read5GBOfZerosImpl(File f, String expectedName)\n         throws IOException {\n-        read5GBOfZerosImpl(f, expectedName, true);\n-    }\n-\n-    private static void read5GBOfZerosImpl(File f, String expectedName,\n-                                           boolean checkSize)\n-        throws IOException {\n         FileInputStream fin = new FileInputStream(f);\n         ZipArchiveInputStream zin = null;\n         try {\n             }\n             assertEquals(FIVE_BILLION, read);\n             assertNull(zin.getNextZipEntry());\n-            if (checkSize) {\n-                assertEquals(FIVE_BILLION, zae.getSize());\n-            }\n+            assertEquals(FIVE_BILLION, zae.getSize());\n         } finally {\n             if (zin != null) {\n                 zin.close();", "timestamp": 1312365353, "metainfo": ""}