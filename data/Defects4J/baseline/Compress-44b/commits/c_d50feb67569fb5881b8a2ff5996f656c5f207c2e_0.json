{"sha": "d50feb67569fb5881b8a2ff5996f656c5f207c2e", "log": "COMPRESS-306 ArchiveStreamFactory fails to pass on the encoding when creating some streams.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n     }\n \n     /**\n-     * Returns the encoding to use for arj, zip, dump, cpio and tar\n-     * files, or null for the default.\n+     * Returns the encoding to use for arj, jar, zip, dump, cpio and tar\n+     * files, or null for the archiver default.\n      *\n-     * @return entry encoding, or null\n+     * @return entry encoding, or null for the archiver default\n      * @since 1.5\n      */\n     public String getEntryEncoding() {\n     }\n \n     /**\n-     * Sets the encoding to use for arj, zip, dump, cpio and tar files. Use null for the default.\n+     * Sets the encoding to use for arj, jar, zip, dump, cpio and tar files. Use null for the archiver default.\n      * \n-     * @param entryEncoding the entry encoding, null uses the default.\n+     * @param entryEncoding the entry encoding, null uses the archiver default.\n      * @since 1.5\n      * @deprecated 1.10 use {@link #ArchiveStreamFactory(String)} to specify the encoding\n      * @throws IllegalStateException if the constructor {@link #ArchiveStreamFactory(String)} \n             }\n         }\n         if (JAR.equalsIgnoreCase(archiverName)) {\n-            return new JarArchiveInputStream(in);\n+            if (entryEncoding != null) {\n+                return new JarArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new JarArchiveInputStream(in);\n+            }\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n             if (entryEncoding != null) {\n      * Create an archive output stream from an archiver name and an output stream.\n      * \n      * @param archiverName the archive name,\n-     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO} or {@value #SEVEN_Z} \n+     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n      * @param out the output stream\n      * @return the archive output stream\n      * @throws ArchiveException if the archiver name is not known\n             }\n         }\n         if (JAR.equalsIgnoreCase(archiverName)) {\n-            return new JarArchiveOutputStream(out);\n+            if (entryEncoding != null) {\n+                return new JarArchiveOutputStream(out, entryEncoding);\n+            } else {\n+                return new JarArchiveOutputStream(out);\n+            }\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n             if (entryEncoding != null) {\n                     return new ZipArchiveInputStream(in);\n                 }\n             } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n-                return new JarArchiveInputStream(in);\n+                if (entryEncoding != null) {\n+                    return new JarArchiveInputStream(in, entryEncoding);\n+                } else {\n+                    return new JarArchiveInputStream(in);\n+                }\n             } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                 return new ArArchiveInputStream(in);\n             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n-                return new CpioArchiveInputStream(in);\n+                if (entryEncoding != null) {\n+                    return new CpioArchiveInputStream(in, entryEncoding);\n+                } else {\n+                    return new CpioArchiveInputStream(in);\n+                }\n             } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n-                return new ArjArchiveInputStream(in);\n+                if (entryEncoding != null) {\n+                    return new ArjArchiveInputStream(in, entryEncoding);\n+                } else {\n+                    return new ArjArchiveInputStream(in);\n+                }\n             } else if (SevenZFile.matches(signature, signatureLength)) {\n                 throw new StreamingNotSupportedException(SEVEN_Z);\n             }\n             signatureLength = IOUtils.readFully(in, dumpsig);\n             in.reset();\n             if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-                return new DumpArchiveInputStream(in);\n+                return new DumpArchiveInputStream(in, entryEncoding);\n             }\n \n             // Tar needs an even bigger buffer to check the signature; read the first block\n             signatureLength = IOUtils.readFully(in, tarheader);\n             in.reset();\n             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-                if (entryEncoding != null) {\n-                    return new TarArchiveInputStream(in, entryEncoding);\n-                } else {\n-                    return new TarArchiveInputStream(in);\n-                }\n+                return new TarArchiveInputStream(in, entryEncoding);\n             }\n             // COMPRESS-117 - improve auto-recognition\n             if (signatureLength >= 512) {\n                     tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                     // COMPRESS-191 - verify the header checksum\n                     if (tais.getNextTarEntry().isCheckSumOK()) {\n-                        return new TarArchiveInputStream(in);\n+                        return new TarArchiveInputStream(in, encoding);\n                     }\n                 } catch (Exception e) { // NOPMD\n                     // can generate IllegalArgumentException as well\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n     /**\n      * The encoding to use for filenames and labels.\n      */\n-    private final ZipEncoding encoding;\n+    private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     /**\n      * Construct the cpio input stream with a blocksize of {@link\n     public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n         this.in = in;\n         this.blockSize = blockSize;\n-        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     }\n \n     /**\n         byte tmpBuffer[] = new byte[length - 1];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n         this.in.read();\n-        return encoding.decode(tmpBuffer);\n+        return zipEncoding.decode(tmpBuffer);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n     /**\n      * The encoding to use for filenames and labels.\n      */\n-    private final ZipEncoding encoding;\n+    private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     /**\n      * Construct the cpio output stream with a specified format, a\n         }\n         this.entryFormat = format;\n         this.blockSize = blockSize;\n-        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     }\n \n     /**\n      * @throws IOException if the string couldn't be written\n      */\n     private void writeCString(final String str) throws IOException {\n-        ByteBuffer buf = encoding.encode(str);\n+        ByteBuffer buf = zipEncoding.encode(str);\n         final int len = buf.limit() - buf.position();\n         out.write(buf.array(), buf.arrayOffset(), len);\n         out.write('\\0');\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n     /**\n      * The encoding to use for filenames and labels.\n      */\n-    private final ZipEncoding encoding;\n+    private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     /**\n      * Constructor using the platform's default encoding for file\n         throws ArchiveException {\n         this.raw = new TapeInputStream(is);\n         this.hasHitEOF = false;\n-        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         try {\n             // read header, verify it's a dump archive.\n             }\n \n             // get summary information\n-            summary = new DumpArchiveSummary(headerBytes, this.encoding);\n+            summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n \n             // reset buffer with actual block size.\n             raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n \n                 byte type = blockBuffer[i + 6];\n \n-                String name = DumpArchiveUtil.decode(encoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n+                String name = DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n \n                 if (\".\".equals(name) || \"..\".equals(name)) {\n                     // do nothing...\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n  */\n public class JarArchiveInputStream extends ZipArchiveInputStream {\n \n+    /**\n+     * Creates an instance from the input stream using the default encoding.\n+     * \n+     * @param inputStream the input stream to wrap\n+     */\n     public JarArchiveInputStream( final InputStream inputStream ) {\n         super(inputStream);\n+    }\n+\n+    /**\n+     * Creates an instance from the input stream using the specified encoding.\n+     * \n+     * @param inputStream the input stream to wrap\n+     * @param encoding the encoding to use\n+     * @since 1.10\n+     */\n+    public JarArchiveInputStream( final InputStream inputStream, final String encoding ) {\n+        super(inputStream, encoding);\n     }\n \n     public JarArchiveEntry getNextJarEntry() throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n         super(out);\n     }\n \n+    /**\n+     * Create and instance that wraps the output stream using the provided encoding.\n+     * \n+     * @param out the output stream to wrap\n+     * @param encoding the encoding to use. Use null for the platform default.\n+     * @since 1.10\n+     */\n+    public JarArchiveOutputStream(final OutputStream out, final String encoding) {\n+        super(out);\n+        setEncoding(encoding);\n+    }\n+\n     // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     @Override\n     public void putArchiveEntry(ArchiveEntry ze) throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n     private TarArchiveEntry currEntry;\n \n     /** The encoding of the file */\n-    private final ZipEncoding encoding;\n+    private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     /**\n      * Constructor for TarInputStream.\n                                  String encoding) {\n         this.is = is;\n         this.hasHitEOF = false;\n-        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.recordSize = recordSize;\n         this.blockSize = blockSize;\n     }\n         }\n \n         try {\n-            currEntry = new TarArchiveEntry(headerBuf, encoding);\n+            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n         } catch (IllegalArgumentException e) {\n             IOException ioe = new IOException(\"Error detected parsing the header\");\n             ioe.initCause(e);\n                 // entry\n                 return null;\n             }\n-            currEntry.setLinkName(encoding.decode(longLinkData));\n+            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n         }\n \n         if (currEntry.isGNULongNameEntry()) {\n                 // entry\n                 return null;\n             }\n-            currEntry.setName(encoding.decode(longNameData));\n+            currEntry.setName(zipEncoding.decode(longNameData));\n         }\n \n         if (currEntry.isPaxHeader()){ // Process Pax headers\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n \n     private final OutputStream out;\n \n-    private final ZipEncoding encoding;\n+    private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     private boolean addPaxHeadersForNonAsciiNames = false;\n     private static final ZipEncoding ASCII =\n     public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                   int recordSize, String encoding) {\n         out = new CountingOutputStream(os);\n-        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         this.assemLen = 0;\n         this.assemBuf = new byte[recordSize];\n             writePaxHeaders(entry, entryName, paxHeaders);\n         }\n \n-        entry.writeEntryHeader(recordBuf, encoding,\n+        entry.writeEntryHeader(recordBuf, zipEncoding,\n                                bigNumberMode == BIGNUMBER_STAR);\n         writeRecord(recordBuf);\n \n                                    Map<String, String> paxHeaders,\n                                    String paxHeaderName, byte linkType, String fieldName)\n         throws IOException {\n-        final ByteBuffer encodedName = encoding.encode(name);\n+        final ByteBuffer encodedName = zipEncoding.encode(name);\n         final int len = encodedName.limit() - encodedName.position();\n         if (len >= TarConstants.NAMELEN) {\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n \n     /** The zip encoding to use for filenames and the file comment. */\n     private final ZipEncoding zipEncoding;\n+\n+    // the provided encoding (for unit tests)\n+    final String encoding;\n \n     /** Whether to look for and use Unicode extra fields. */\n     private final boolean useUnicodeExtraFields;\n \n     private int entriesRead = 0;\n \n+    /**\n+     * Create an instance using UTF-8 encoding\n+     * @param inputStream the stream to wrap\n+     */\n     public ZipArchiveInputStream(InputStream inputStream) {\n         this(inputStream, ZipEncodingHelper.UTF8);\n     }\n                                  String encoding,\n                                  boolean useUnicodeExtraFields,\n                                  boolean allowStoredEntriesWithDataDescriptor) {\n+        this.encoding = encoding;\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         in = new PushbackInputStream(inputStream, buf.capacity());\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n  */\n package org.apache.commons.compress.archivers;\n \n+import static org.apache.commons.compress.AbstractTestCase.getFile;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.FileInputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n-\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n+import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\n+import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n import org.junit.Test;\n \n             fis.close();\n     \t}\n     }\n+    \n+    @Test\n+    public void testEncodingCtor() {\n+        ArchiveStreamFactory fac = new ArchiveStreamFactory();\n+        assertNull(fac.getEntryEncoding());\n+        fac = new ArchiveStreamFactory(null);\n+        assertNull(fac.getEntryEncoding());\n+        fac = new ArchiveStreamFactory(\"UTF-8\");\n+        assertEquals(\"UTF-8\", fac.getEntryEncoding());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"deprecation\")\n+    public void testEncodingDeprecated() {\n+        ArchiveStreamFactory fac = new ArchiveStreamFactory();\n+        assertNull(fac.getEntryEncoding());\n+        fac.setEntryEncoding(\"UTF-8\");\n+        assertEquals(\"UTF-8\", fac.getEntryEncoding());\n+        fac.setEntryEncoding(\"US_ASCII\");\n+        assertEquals(\"US_ASCII\", fac.getEntryEncoding());\n+        fac = new ArchiveStreamFactory(\"UTF-8\");\n+        assertEquals(\"UTF-8\", fac.getEntryEncoding());\n+        try {\n+            fac.setEntryEncoding(\"US_ASCII\");\n+            fail(\"Expected IllegalStateException\");\n+        } catch (IllegalStateException ise) {\n+            // expected\n+        }\n+    }\n+\n+    static class TestData {\n+        final String testFile;\n+        final String expectedEncoding;\n+        final ArchiveStreamFactory fac;\n+        final String fieldName;\n+        final String type;\n+        final boolean hasOutputStream;\n+        TestData(String testFile, String type, boolean hasOut, String expectedEncoding, ArchiveStreamFactory fac, String fieldName) {\n+            this.testFile = testFile;\n+            this.expectedEncoding = expectedEncoding;\n+            this.fac = fac;\n+            this.fieldName = fieldName;\n+            this.type = type;\n+            this.hasOutputStream = hasOut;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\") // test of deprecated method\n+    static ArchiveStreamFactory getFactory(String entryEncoding) {\n+        ArchiveStreamFactory fac = new ArchiveStreamFactory();\n+        fac.setEntryEncoding(entryEncoding);\n+        return fac;\n+    }\n+    // The different factory types\n+    private static final ArchiveStreamFactory FACTORY = new ArchiveStreamFactory();\n+    private static final ArchiveStreamFactory FACTORY_UTF8 = new ArchiveStreamFactory(\"UTF-8\");\n+    private static final ArchiveStreamFactory FACTORY_ASCII = new ArchiveStreamFactory(\"ASCII\");\n+    private static final ArchiveStreamFactory FACTORY_SET_UTF8 = getFactory(\"UTF-8\");\n+    private static final ArchiveStreamFactory FACTORY_SET_ASCII = getFactory(\"ASCII\");\n+\n+    // Default encoding if none is provided (not even null)\n+    // The test currently assumes that the output default is the same as the input default\n+    private static final String ARJ_DEFAULT;\n+    private static final String DUMP_DEFAULT;\n+\n+    private static final String ZIP_DEFAULT = getField(new ZipArchiveInputStream(null),\"encoding\");\n+    private static final String CPIO_DEFAULT = getField(new CpioArchiveInputStream(null),\"encoding\");\n+    private static final String TAR_DEFAULT = getField(new TarArchiveInputStream(null),\"encoding\");\n+    private static final String JAR_DEFAULT = getField(new JarArchiveInputStream(null),\"encoding\");\n+\n+    static {\n+        String dflt;\n+        dflt = \"??\";\n+        try {\n+            dflt = getField(new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\"))), \"charsetName\");\n+        } catch (ArchiveException e) {\n+            e.printStackTrace();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        ARJ_DEFAULT = dflt;\n+        dflt = \"??\";\n+        try {\n+            dflt = getField(new DumpArchiveInputStream(new FileInputStream(getFile(\"bla.dump\"))), \"encoding\");\n+        } catch (ArchiveException e) {\n+            e.printStackTrace();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        DUMP_DEFAULT = dflt;\n+    }\n+\n+    static final TestData[] TESTS = {\n+        new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, ARJ_DEFAULT, FACTORY, \"charsetName\"),\n+        new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"UTF-8\", FACTORY_UTF8, \"charsetName\"),\n+        new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"ASCII\", FACTORY_ASCII, \"charsetName\"),\n+        new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"UTF-8\", FACTORY_SET_UTF8, \"charsetName\"),\n+        new TestData(\"bla.arj\", ArchiveStreamFactory.ARJ, false, \"ASCII\", FACTORY_SET_ASCII, \"charsetName\"),\n+\n+        new TestData(\"bla.cpio\", ArchiveStreamFactory.CPIO, true, CPIO_DEFAULT, FACTORY, \"encoding\"),\n+        new TestData(\"bla.cpio\", ArchiveStreamFactory.CPIO, true, \"UTF-8\", FACTORY_UTF8, \"encoding\"),\n+        new TestData(\"bla.cpio\", ArchiveStreamFactory.CPIO, true, \"ASCII\", FACTORY_ASCII, \"encoding\"),\n+        new TestData(\"bla.cpio\", ArchiveStreamFactory.CPIO, true, \"UTF-8\", FACTORY_SET_UTF8, \"encoding\"),\n+        new TestData(\"bla.cpio\", ArchiveStreamFactory.CPIO, true, \"ASCII\", FACTORY_SET_ASCII, \"encoding\"),\n+\n+        new TestData(\"bla.dump\", ArchiveStreamFactory.DUMP, false, DUMP_DEFAULT, FACTORY, \"encoding\"),\n+        new TestData(\"bla.dump\", ArchiveStreamFactory.DUMP, false, \"UTF-8\", FACTORY_UTF8, \"encoding\"),\n+        new TestData(\"bla.dump\", ArchiveStreamFactory.DUMP, false, \"ASCII\", FACTORY_ASCII, \"encoding\"),\n+        new TestData(\"bla.dump\", ArchiveStreamFactory.DUMP, false, \"UTF-8\", FACTORY_SET_UTF8, \"encoding\"),\n+        new TestData(\"bla.dump\", ArchiveStreamFactory.DUMP, false, \"ASCII\", FACTORY_SET_ASCII, \"encoding\"),\n+\n+        new TestData(\"bla.tar\", ArchiveStreamFactory.TAR, true, TAR_DEFAULT, FACTORY, \"encoding\"),\n+        new TestData(\"bla.tar\", ArchiveStreamFactory.TAR, true, \"UTF-8\", FACTORY_UTF8, \"encoding\"),\n+        new TestData(\"bla.tar\", ArchiveStreamFactory.TAR, true, \"ASCII\", FACTORY_ASCII, \"encoding\"),\n+        new TestData(\"bla.tar\", ArchiveStreamFactory.TAR, true, \"UTF-8\", FACTORY_SET_UTF8, \"encoding\"),\n+        new TestData(\"bla.tar\", ArchiveStreamFactory.TAR, true, \"ASCII\", FACTORY_SET_ASCII, \"encoding\"),\n+\n+        new TestData(\"bla.jar\", ArchiveStreamFactory.JAR, true, JAR_DEFAULT, FACTORY, \"encoding\"),\n+        new TestData(\"bla.jar\", ArchiveStreamFactory.JAR, true, \"UTF-8\", FACTORY_UTF8, \"encoding\"),\n+        new TestData(\"bla.jar\", ArchiveStreamFactory.JAR, true, \"ASCII\", FACTORY_ASCII, \"encoding\"),\n+        new TestData(\"bla.jar\", ArchiveStreamFactory.JAR, true, \"UTF-8\", FACTORY_SET_UTF8, \"encoding\"),\n+        new TestData(\"bla.jar\", ArchiveStreamFactory.JAR, true, \"ASCII\", FACTORY_SET_ASCII, \"encoding\"),\n+\n+        new TestData(\"bla.zip\", ArchiveStreamFactory.ZIP, true, ZIP_DEFAULT, FACTORY, \"encoding\"),\n+        new TestData(\"bla.zip\", ArchiveStreamFactory.ZIP, true, \"UTF-8\", FACTORY_UTF8, \"encoding\"),\n+        new TestData(\"bla.zip\", ArchiveStreamFactory.ZIP, true, \"ASCII\", FACTORY_ASCII, \"encoding\"),\n+        new TestData(\"bla.zip\", ArchiveStreamFactory.ZIP, true, \"UTF-8\", FACTORY_SET_UTF8, \"encoding\"),\n+        new TestData(\"bla.zip\", ArchiveStreamFactory.ZIP, true, \"ASCII\", FACTORY_SET_ASCII, \"encoding\"),\n+    };\n+\n+    @Test\n+    public void testEncodingInputStreamAutodetect() throws Exception {\n+        int failed = 0;\n+        for(int i = 1; i <= TESTS.length; i++) {\n+            TestData test = TESTS[i-1];\n+            ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n+            final String field = getField(ais,test.fieldName);\n+            if (!eq(test.expectedEncoding,field)) {\n+                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n+                failed++;\n+            }\n+        }\n+        if (failed > 0) {\n+            fail(\"Tests failed: \" + failed);\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodingInputStream() throws Exception {\n+        int failed = 0;\n+        for(int i = 1; i <= TESTS.length; i++) {\n+            TestData test = TESTS[i-1];\n+            ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n+            final String field = getField(ais,test.fieldName);\n+            if (!eq(test.expectedEncoding,field)) {\n+                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n+                failed++;\n+            }\n+        }\n+        if (failed > 0) {\n+            fail(\"Tests failed: \" + failed);\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodingOutputStream() throws Exception {\n+        int failed = 0;\n+        for(int i = 1; i <= TESTS.length; i++) {\n+            TestData test = TESTS[i-1];\n+            if (test.hasOutputStream) {\n+                ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n+                final String field = getField(ais, test.fieldName);\n+                if (!eq(test.expectedEncoding, field)) {\n+                    System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n+                    failed++;\n+                }\n+            }\n+        }\n+        if (failed > 0) {\n+            fail(\"Tests failed: \" + failed);\n+        }\n+    }\n+\n+    // equals allowing null\n+    private static boolean eq(String exp, String act) {\n+        if (exp == null) {\n+            return act == null;\n+        }\n+        return exp.equals(act);\n+    }\n+\n+    private static String getField(Object instance, String name) {\n+        Class<?> cls = instance.getClass();\n+        Field fld;\n+        try {\n+            fld = cls.getDeclaredField(name);\n+        } catch (NoSuchFieldException nsfe) {\n+                try {\n+                    fld = cls.getSuperclass().getDeclaredField(name);\n+                } catch (NoSuchFieldException e) {\n+                    System.out.println(\"Cannot find \" + name + \" in class \" + instance.getClass().getSimpleName());\n+                    return \"??\";\n+                }                \n+        }\n+        boolean isAccessible = fld.isAccessible();\n+        try {\n+            if (!isAccessible) {\n+                fld.setAccessible(true);\n+            }\n+            final Object object = fld.get(instance);\n+            if (object instanceof String || object == null) {\n+                return (String) object;\n+            } else {\n+                System.out.println(\"Wrong type: \" + object.getClass().getCanonicalName() + \" for \" + name + \" in class \" + instance.getClass().getSimpleName());\n+                return \"??\";                \n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            return \"??\";\n+        } finally {\n+            if (!isAccessible) {\n+                fld.setAccessible(isAccessible);\n+            }\n+        }\n+    }\n+\n+    private ArchiveInputStream getInputStreamFor(String resource, ArchiveStreamFactory factory)\n+            throws IOException, ArchiveException {\n+        return factory.createArchiveInputStream(\n+                   new BufferedInputStream(new FileInputStream(\n+                       getFile(resource))));\n+    }\n+\n+    private ArchiveInputStream getInputStreamFor(String type, String resource, ArchiveStreamFactory factory)\n+            throws IOException, ArchiveException {\n+        return factory.createArchiveInputStream(\n+                   type,\n+                   new BufferedInputStream(new FileInputStream(\n+                       getFile(resource))));\n+    }\n+\n+    private ArchiveOutputStream getOutputStreamFor(String type, ArchiveStreamFactory factory)\n+            throws IOException, ArchiveException {\n+        return factory.createArchiveOutputStream(type, new ByteArrayOutputStream());\n+    }\n }", "timestamp": 1424128381, "metainfo": ""}