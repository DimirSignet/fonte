{"sha": "2d70b7a25386bff27a14e34062fa4c01d4d45681", "log": "may need to flush the buffer when sliding ...  ... the start of the current literal block past the beginning of the buffer", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n \n         @Override\n         public String toString() {\n-            return \"BackReference with \" + offset + \" and length \" + length;\n+            return \"BackReference with offset \" + offset + \" and length \" + length;\n         }\n     }\n     /**\n     // the given hash.\n     private final int[] head;\n     // for each window-location points to the latest earlier location\n-    // with the same hash. Only stored values for the latest\n+    // with the same hash. Only stores values for the latest\n     // \"windowSize\" elements, the index is \"window location modulo\n     // windowSize\".\n     private final int[] prev;\n         }\n     }\n \n-    private void slide() {\n+    private void slide() throws IOException {\n         final int wSize = params.getWindowSize();\n+        if (blockStart != currentPosition && blockStart < wSize) {\n+            flushLiteralBlock();\n+            blockStart = currentPosition;\n+        }\n         System.arraycopy(window, wSize, window, 0, wSize);\n         currentPosition -= wSize;\n         matchStart -= wSize;\n         blockStart -= wSize;\n-        for (int i = 0; i< HASH_SIZE; i++) {\n+        for (int i = 0; i < HASH_SIZE; i++) {\n             int h = head[i];\n             head[i] = h >= wSize ? h - wSize : NO_MATCH;\n         }", "timestamp": 1483984740, "metainfo": ""}