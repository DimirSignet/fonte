{"sha": "bd64dc7abee36984e830c740588990739b71cc93", "log": "COMPRESS-391: Allow alignment on zip content", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     private int platform = PLATFORM_FAT;\n     private int rawFlag;\n     private long externalAttributes = 0;\n+    private int alignment = 0;\n     private ZipExtraField[] extraFields;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n      */\n     protected void setPlatform(final int platform) {\n         this.platform = platform;\n+    }\n+\n+    /**\n+     * Gets currently configured alignment.\n+     *\n+     * @return\n+     *      alignment for this entry.\n+     */\n+    protected int getAlignment() {\n+        return this.alignment;\n+    }\n+\n+    /**\n+     * Sets alignment for this entry.\n+     *\n+     * @param alignment\n+     *      requested alignment, 0 for default.\n+     */\n+    public void setAlignment(int alignment) {\n+        if ((alignment & (alignment - 1)) != 0) {\n+            throw new IllegalArgumentException(\"Invalid value for alignment, must be power of two: \" + alignment);\n+        }\n+        this.alignment = alignment;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     @Deprecated\n     public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n \n+    /**\n+     * Size of the extra field header (id + length).\n+     */\n+    public static final int EXTRAFIELD_HEADER_SIZE = 4;\n+\n+    /**\n+     * Extra field id used for padding (there is no special value documented,\n+     * therefore USHORT_MAX seems to be good choice).\n+     */\n+    public static final int EXTRAFIELD_PADDING_ID = 0xffff;\n+\n     private static final byte[] EMPTY = new byte[0];\n \n     /**\n             addUnicodeExtraFields(ze, encodable, name);\n         }\n \n-        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased);\n         final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n+        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n         offsets.put(ze, localHeaderStart);\n         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n         writeCounted(localHeader);\n \n \n     private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n-                                         final boolean phased)  {\n+                                         final boolean phased, long archiveOffset) throws IOException {\n         final byte[] extra = ze.getLocalFileDataExtra();\n         final int nameLen = name.limit() - name.position();\n-        final int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n+        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n+        int padding = 0;\n+        int alignment = ze.getAlignment();\n+        if (alignment > 1 && ((archiveOffset + len) & (alignment - 1)) != 0) {\n+            padding = (int) ((-archiveOffset - len - EXTRAFIELD_HEADER_SIZE) & (alignment - 1));\n+            len += EXTRAFIELD_HEADER_SIZE+padding;\n+        }\n         final byte[] buf = new byte[len];\n \n         System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n         // file name length\n         putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n \n+        int totalExtra = extra.length + (padding > 0 ? padding + EXTRAFIELD_HEADER_SIZE : 0);\n+        if (totalExtra > 0xffff) {\n+            throw new IOException(\"Too much data for extra fields and padding\"+\n+                            \", extra=\"+extra.length+\n+                            \", padding=\"+padding);\n+        }\n         // extra field length\n-        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n+        putShort(totalExtra, buf, LFH_EXTRA_LENGTH_OFFSET);\n \n         // file name\n         System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n \n+        // extra fields\n         System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n+\n+        // padding\n+        if (padding > 0) {\n+            putShort(EXTRAFIELD_PADDING_ID, buf, LFH_FILENAME_OFFSET + nameLen + extra.length);\n+            putShort(padding, buf, LFH_FILENAME_OFFSET + nameLen + extra.length + 2);\n+        }\n+\n         return buf;\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n         }\n     }\n \n+    /**\n+     * Test entries alignment.\n+     */\n+    @Test\n+    public void testEntryAlignment() throws Exception {\n+        SeekableInMemoryByteChannel zipContent = new SeekableInMemoryByteChannel();\n+        try (ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\n+            ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\n+            inflatedEntry.setMethod(ZipEntry.DEFLATED);\n+            inflatedEntry.setAlignment(1024);\n+            zipOutput.putArchiveEntry(inflatedEntry);\n+            zipOutput.write(\"Hello Deflated\\n\".getBytes(Charset.forName(\"UTF-8\")));\n+            zipOutput.closeArchiveEntry();\n+\n+            ZipArchiveEntry storedEntry = new ZipArchiveEntry(\"stored.txt\");\n+            storedEntry.setMethod(ZipEntry.STORED);\n+            storedEntry.setAlignment(1024);\n+            zipOutput.putArchiveEntry(storedEntry);\n+            zipOutput.write(\"Hello Stored\\n\".getBytes(Charset.forName(\"UTF-8\")));\n+            zipOutput.closeArchiveEntry();\n+\n+        }\n+\n+        try (ZipFile zf = new ZipFile(new SeekableInMemoryByteChannel(\n+                        Arrays.copyOfRange(zipContent.array(), 0, (int)zipContent.size())\n+        ))) {\n+            ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\n+            assertNotEquals(-1L, inflatedEntry.getCompressedSize());\n+            assertNotEquals(-1L, inflatedEntry.getSize());\n+            assertEquals(0L, inflatedEntry.getDataOffset()%1024);\n+            try (InputStream stream = zf.getInputStream(inflatedEntry)) {\n+                Assert.assertEquals(\"Hello Deflated\\n\",\n+                                new String(IOUtils.toByteArray(stream), Charset.forName(\"UTF-8\")));\n+            }\n+            ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\n+            assertNotEquals(-1L, storedEntry.getCompressedSize());\n+            assertNotEquals(-1L, storedEntry.getSize());\n+            assertEquals(0L, inflatedEntry.getDataOffset()%1024);\n+            try (InputStream stream = zf.getInputStream(storedEntry)) {\n+                Assert.assertEquals(\"Hello Stored\\n\",\n+                                new String(IOUtils.toByteArray(stream), Charset.forName(\"UTF-8\")));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test too big alignment, resulting into exceeding extra field limit.\n+     */\n+    @Test(expected = IOException.class)\n+    public void testEntryAlignmentExceed() throws Exception {\n+        SeekableInMemoryByteChannel zipContent = new SeekableInMemoryByteChannel();\n+        try (ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\n+            ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\n+            inflatedEntry.setMethod(ZipEntry.STORED);\n+            inflatedEntry.setAlignment(0x20000);\n+            zipOutput.putArchiveEntry(inflatedEntry);\n+            zipOutput.write(\"Hello Stored\\n\".getBytes(Charset.forName(\"UTF-8\")));\n+            zipOutput.closeArchiveEntry();\n+        }\n+    }\n+\n+    /**\n+     * Test non power of 2 alignment.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidAlignment() throws Exception {\n+        ZipArchiveEntry entry = new ZipArchiveEntry(\"dummy\");\n+        entry.setAlignment(3);\n+    }\n+\n     private void assertAllReadMethods(byte[] expected, ZipFile zipFile, ZipArchiveEntry entry) {\n         // simple IOUtil read\n         try (InputStream stream = zf.getInputStream(entry)) {", "timestamp": 1494525874, "metainfo": ""}