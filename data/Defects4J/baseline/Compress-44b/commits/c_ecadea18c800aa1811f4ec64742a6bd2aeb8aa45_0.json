{"sha": "ecadea18c800aa1811f4ec64742a6bd2aeb8aa45", "log": "COMPRESS-271 tests for rewriting of last pairs", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n         // only needs to be five bytes long if the previous\n         // back-reference has an offset big enough\n \n-        final int allButFirstOfLastPairs = lastPairs.size() - 1;\n+        final int lastPairsSize = lastPairs.size();\n         int toExpand = 0;\n-        for (int i = 1; i < allButFirstOfLastPairs; i++) {\n+        for (int i = 1; i < lastPairsSize; i++) {\n             toExpand += pairLength.get(i);\n         }\n         Pair replacement = new Pair();\n         int splitLen = splitCandidate.length();\n         int stillNeeded = MIN_OFFSET_OF_LAST_BACK_REFERENCE - toExpand;\n         if (splitCandidate.hasBackReference()\n-            && splitCandidate.backReferenceLength() > MIN_BACK_REFERENCE_LENGTH + stillNeeded) {\n+            && splitCandidate.backReferenceLength() >= MIN_BACK_REFERENCE_LENGTH + stillNeeded) {\n             replacement.prependLiteral(expand(toExpand + stillNeeded, stillNeeded));\n             pairs.add(splitCandidate.splitWithNewBackReferenceLengthOf(splitCandidate.backReferenceLength()\n                 - stillNeeded));\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStreamTest.java\n         Assert.assertArrayEquals(new byte[] { (4<<4) + 1, 2, 3, 4, 5, 1, 0 },\n             bos.toByteArray());\n     }\n+\n+    @Test\n+    public void rewritingOfFinalBlockWithoutTrailingLZ77Literals() throws IOException {\n+        for (int i = 1; i < 13; i++) {\n+            // according to the spec these are all too short be compressed\n+            // LZ77Compressor will create a single byte literal\n+            // followed by a back-reference starting with i = 5,\n+            // though. (4 is the minimum length for a back-reference\n+            // in LZ4\n+            byte[] compressed = compress(i);\n+            byte[] expected = new byte[i + 1];\n+            expected[0] = (byte) (i<<4);\n+            Assert.assertArrayEquals(\"input length is \" + i, expected, compressed);\n+        }\n+\n+        for (int i = 13; i < 17; i++) {\n+            // LZ77Compressor will still create a single byte literal\n+            // followed by a back-reference\n+            // according to the spec the back-reference could be split\n+            // as we can cut out a five byte literal and the offset\n+            // would be big enough, but our algorithm insists on a\n+            // twelve byte literal trailer and the back-reference\n+            // would fall below the minimal size\n+            byte[] compressed = compress(i);\n+            byte[] expected = i < 15 ? new byte[i + 1] : new byte[i + 2];\n+            if (i < 15) {\n+                expected[0] = (byte) (i<<4);\n+            } else {\n+                expected[0] = (byte) (15<<4);\n+                expected[1] = (byte) (i - 15);\n+            }\n+            Assert.assertArrayEquals(\"input length is \" + i, expected, compressed);\n+        }\n+\n+        for (int i = 17; i < 20; i++) {\n+            // LZ77Compressor will still create a single byte literal\n+            // followed by a back-reference\n+            // this time even our algorithm is willing to break up the\n+            // back-reference\n+            byte[] compressed = compress(i);\n+            byte[] expected = new byte[17];\n+            expected[0] = (byte) ((1<<4) | i - 17);\n+            expected[2] = 1; // offset\n+            expected[4] = (byte) (12<<4);\n+            Assert.assertArrayEquals(\"input length is \" + i, expected, compressed);\n+        }\n+    }\n+\n+    @Test\n+    public void rewritingOfFinalBlockWithTrailingLZ77Literals() throws IOException {\n+        for (int i = 1; i < 5; i++) {\n+            // LZ77Compressor will create a single byte literal\n+            // followed by a back-reference of length 15 followed by a\n+            // literal of length i\n+            // we can split the back-reference and merge it with the literal\n+            byte[] compressed = compress(16, i);\n+            byte[] expected = new byte[17];\n+            expected[0] = (byte) ((1<<4) | i - 1);\n+            expected[2] = 1; // offset\n+            expected[4] = (byte) (12<<4);\n+            for (int j = 0; j < i; j++) {\n+                expected[expected.length - 1 - j] = 1;\n+            }\n+            Assert.assertArrayEquals(\"trailer length is \" + i, expected, compressed);\n+        }\n+        for (int i = 5; i < 12; i++) {\n+            // LZ77Compressor will create a single byte literal\n+            // followed by a back-reference of length 15 followed by\n+            // another single byte literal and another back-reference\n+            // of length i-1\n+            // according to the spec we could completely satisfy the\n+            // requirements by just rewriting the last Pair, but our\n+            // algorithm will chip off a few bytes from the first Pair\n+            byte[] compressed = compress(16, i);\n+            byte[] expected = new byte[17];\n+            expected[0] = (byte) ((1<<4) | i - 1);\n+            expected[2] = 1; // offset\n+            expected[4] = (byte) (12<<4);\n+            for (int j = 0; j < i; j++) {\n+                expected[expected.length - 1 - j] = 1;\n+            }\n+            Assert.assertArrayEquals(\"trailer length is \" + i, expected, compressed);\n+        }\n+        for (int i = 12; i < 15; i++) {\n+            // LZ77Compressor will create a single byte literal\n+            // followed by a back-reference of length 15 followed by\n+            // another single byte literal and another back-reference\n+            // of length i-1\n+            // this shouldn't affect the first pair at all as\n+            // rewriting the second one is sufficient\n+            byte[] compressed = compress(16, i);\n+            byte[] expected = new byte[i + 5];\n+            expected[0] = (byte) ((1<<4) | 11);\n+            expected[2] = 1; // offset\n+            expected[4] = (byte) (i<<4);\n+            for (int j = 0; j < i; j++) {\n+                expected[expected.length - 1 - j] = 1;\n+            }\n+            Assert.assertArrayEquals(\"trailer length is \" + i, expected, compressed);\n+        }\n+    }\n+\n+    @Test\n+    public void rewritingOfFourPairs() throws IOException {\n+        // LZ77Compressor creates three times a literal block followed\n+        // by a back-reference (once 5 bytes long and twice four bytes\n+        // long and a final literal block of length 1\n+        // in the result the three last pairs are merged into a single\n+        // literal and one byte is chopped off of the first pair's\n+        // back-reference\n+        byte[] compressed = compress(6, 5, 5, 1);\n+        byte[] expected = new byte[17];\n+        expected[0] = (byte) (1<<4);\n+        expected[2] = 1; // offset\n+        expected[4] = (byte) (12<<4);\n+        for (int i = 6; i < 11; i++) {\n+            expected[i] = 1;\n+        }\n+        for (int i = 11; i < 16; i++) {\n+            expected[i] = 2;\n+        }\n+        expected[16] = 3;\n+        Assert.assertArrayEquals(expected, compressed);\n+    }\n+\n+    private byte[] compress(int length) throws IOException {\n+        return compress(length, 0);\n+    }\n+\n+    private byte[] compress(int lengthBeforeTrailer, int... lengthOfTrailers) throws IOException {\n+        return compress(new byte[lengthBeforeTrailer], lengthOfTrailers);\n+    }\n+\n+    private byte[] compress(byte[] input, int... lengthOfTrailers) throws IOException {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             BlockLZ4CompressorOutputStream lo = new BlockLZ4CompressorOutputStream(baos)) {\n+            lo.write(input);\n+            for (int i = 0; i < lengthOfTrailers.length; i++) {\n+                int lengthOfTrailer = lengthOfTrailers[i];\n+                for (int j = 0; j < lengthOfTrailer; j++) {\n+                    lo.write(i + 1);\n+                }\n+            }\n+            lo.close();\n+            return baos.toByteArray();\n+        }\n+    }\n }", "timestamp": 1485087698, "metainfo": ""}