{"sha": "3b7a059940786cad20282eb2fe303514114e1e1d", "log": "Added ZipArchiveEntryRequest class  ZipArchiveEntry is not thread safe, and the hand-off between the creating thread and the executorService actually doing the compression has been somewhat of a tightrope-walking effort, since we cannot reliably read fields off the ZipArchiveEntry  Furthermore, to achieve true maximum IO performance in the gather-phase it would be required that Zip headers be created in the parallel part of the compression run, which was not possible prior to this commit.  The ZipArchiveEntryRequest has clear and well-defined thread semantics and can cater for any future algorithmic improvements that may want to try to take performance to the very edge of what is achievable. To my understanding this will not be for this next relasease :)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n import java.util.zip.Deflater;\n \n import static java.util.Collections.synchronizedList;\n+import static org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest.createZipArchiveEntryRequest;\n \n /**\n  * Creates a zip in parallel by using multiple threadlocal #ScatterZipOutputStream instances.\n      * Submit a callable for compression\n      * @param callable The callable to run\n      */\n-    public void submit(Callable<Object> callable) {\n+    public final void submit(Callable<Object> callable) {\n         futures.add(es.submit(callable));\n     }\n \n      * @return   A callable that will be used to check for errors\n      */\n \n-    public Callable<Object> createCallable(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n+    public final Callable<Object> createCallable(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier source) {\n         final int method = zipArchiveEntry.getMethod();\n         if (method == ZipMethod.UNKNOWN_CODE) {\n             throw new IllegalArgumentException(\"Method must be set on the supplied zipArchiveEntry\");\n         }\n+        final ZipArchiveEntryRequest zipArchiveEntryRequest = createZipArchiveEntryRequest(zipArchiveEntry, source);\n         return new Callable<Object>() {\n             public Object call() throws Exception {\n-                final ScatterZipOutputStream streamToUse = tlScatterStreams.get();\n-                InputStream payload = source.get();\n-                try {\n-                    streamToUse.addArchiveEntry(zipArchiveEntry, payload, method);\n-                } finally {\n-                    payload.close();\n-                }\n+                tlScatterStreams.get().addArchiveEntry(zipArchiveEntryRequest);\n                 return null;\n             }\n         };\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n     private final StreamCompressor streamCompressor;\n \n     private static class CompressedEntry {\n-        final ZipArchiveEntry entry;\n+        final ZipArchiveEntryRequest zipArchiveEntryRequest;\n         final long crc;\n         final long compressedSize;\n-        final int method;\n         final long size;\n \n-        public CompressedEntry(ZipArchiveEntry entry, long crc, long compressedSize, int method, long size) {\n-            this.entry = entry;\n+        public CompressedEntry(ZipArchiveEntryRequest zipArchiveEntryRequest, long crc, long compressedSize, long size) {\n+            this.zipArchiveEntryRequest = zipArchiveEntryRequest;\n             this.crc = crc;\n             this.compressedSize = compressedSize;\n-            this.method = method;\n             this.size = size;\n         }\n \n+        /**\n+         * Update the original ZipArchiveEntry witg sizes/crc\n+         * Do not use this methods from threads that did not create the instance itself !\n+         * @return the zipeArchiveEntry that is basis for this request\n+         */\n+\n         public ZipArchiveEntry transferToArchiveEntry(){\n+            ZipArchiveEntry entry = zipArchiveEntryRequest.getZipArchiveEntry();\n             entry.setCompressedSize(compressedSize);\n             entry.setSize(size);\n             entry.setCrc(crc);\n-            entry.setMethod(method);\n+            entry.setMethod(zipArchiveEntryRequest.getMethod());\n             return entry;\n         }\n     }\n     /**\n      * Add an archive entry to this scatter stream.\n      *\n-     * @param zipArchiveEntry The entry to write\n-     * @param payload         The content to write for the entry. The caller is responsible for closing this.\n-     * @param method          The compression method\n+     * @param zipArchiveEntryRequest The entry to write.\n      * @throws IOException    If writing fails\n      */\n-    public void addArchiveEntry(ZipArchiveEntry zipArchiveEntry, InputStream payload, int method) throws IOException {\n-        streamCompressor.deflate(payload, method);\n-        items.add(new CompressedEntry(zipArchiveEntry, streamCompressor.getCrc32(),\n-                                      streamCompressor.getBytesWrittenForLastEntry(), method,\n-                                      streamCompressor.getBytesRead()));\n+    public void addArchiveEntry(ZipArchiveEntryRequest zipArchiveEntryRequest) throws IOException {\n+        final InputStream payloadStream = zipArchiveEntryRequest.getPayloadStream();\n+        try {\n+            streamCompressor.deflate(payloadStream, zipArchiveEntryRequest.getMethod());\n+        } finally {\n+            payloadStream.close();\n+        }\n+        items.add(new CompressedEntry(zipArchiveEntryRequest, streamCompressor.getCrc32(),\n+                                      streamCompressor.getBytesWrittenForLastEntry(), streamCompressor.getBytesRead()));\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.InputStream;\n+\n+/**\n+ * A Thread-safe representation of a ZipArchiveEntry that is used to add entries to parallel archives.\n+ */\n+public class ZipArchiveEntryRequest {\n+    /*\n+     The zipArchiveEntry is not thread safe, and cannot be safely accessed by the getters of this class.\n+     It is safely accessible during the construction part of this class and also after the\n+     thread pools have been shut down.\n+     */\n+    private final ZipArchiveEntry zipArchiveEntry;\n+    private final InputStreamSupplier payloadSupplier;\n+    private final int method;\n+\n+\n+    private ZipArchiveEntryRequest(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier payloadSupplier) {\n+        // this constructor has \"safe\" access to all member variables on zipArchiveEntry\n+        this.zipArchiveEntry = zipArchiveEntry;\n+        this.payloadSupplier = payloadSupplier;\n+        this.method = zipArchiveEntry.getMethod();\n+    }\n+\n+    /**\n+     * Create a ZipArchiveEntryRequest\n+     * @param zipArchiveEntry The entry to use\n+     * @param payloadSupplier The payload that will be added to the zip entry.\n+     * @return The newly created request\n+     */\n+    public static ZipArchiveEntryRequest createZipArchiveEntryRequest(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier payloadSupplier) {\n+        return new ZipArchiveEntryRequest(zipArchiveEntry, payloadSupplier);\n+    }\n+\n+    /**\n+     * The paylaod that will be added to this zip entry\n+     * @return The input stream.\n+     */\n+    public InputStream getPayloadStream() {\n+        return payloadSupplier.get();\n+    }\n+\n+    /**\n+     * The compression method to use\n+     * @return The compression method to use\n+     */\n+    public int getMethod(){\n+       return method;\n+    }\n+\n+\n+    /**\n+     * Gets the underlying entry. Do not use this methods from threads that did not create the instance itself !\n+     * @return the zipeArchiveEntry that is basis for this request\n+     */\n+    ZipArchiveEntry getZipArchiveEntry() {\n+        return zipArchiveEntry;\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n+import java.io.InputStream;\n \n+import static org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest.createZipArchiveEntryRequest;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n \n         final byte[] A_PAYLOAD = \"XAAY\".getBytes();\n \n         ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\n-        ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\n-        scatterZipOutputStream.addArchiveEntry(zab, payload, ZipArchiveEntry.DEFLATED);\n+        zab.setMethod(ZipArchiveEntry.DEFLATED);\n+        final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\n+        scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\n \n         ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\n+        zae.setMethod(ZipArchiveEntry.DEFLATED);\n         ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\n-        scatterZipOutputStream.addArchiveEntry(zae, payload1, ZipArchiveEntry.DEFLATED);\n+        scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\n \n         File target = File.createTempFile(\"scattertest\", \".zip\");\n         ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target);\n         assertEquals(4, a_entry.getSize());\n         assertArrayEquals(A_PAYLOAD, IOUtils.toByteArray(zf.getInputStream(a_entry)));\n     }\n+\n+    private InputStreamSupplier createPayloadSupplier(final ByteArrayInputStream payload) {\n+        return new InputStreamSupplier() {\n+            public InputStream get() {\n+                return payload;\n+            }\n+        };\n+    }\n }", "timestamp": 1421219182, "metainfo": ""}