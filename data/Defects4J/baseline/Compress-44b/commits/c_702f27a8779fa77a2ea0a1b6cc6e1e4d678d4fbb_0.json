{"sha": "702f27a8779fa77a2ea0a1b6cc6e1e4d678d4fbb", "log": "deal with existing PaddingExtraFields when calculating the alignment", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PaddingExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PaddingExtraField.java\n      * Extra field id used for padding (there is no special value documented,\n      * therefore USHORT_MAX seems to be good choice).\n      */\n-    private static final ZipShort ID = new ZipShort(0xffff);\n+    public static final ZipShort ID = new ZipShort(0xffff);\n \n     private int len = 0;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n                                          final boolean phased, long archiveOffset) throws IOException {\n         byte[] extra = ze.getLocalFileDataExtra();\n         final int nameLen = name.limit() - name.position();\n-        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n+        int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n         int alignment = ze.getAlignment();\n         if (alignment > 1 && ((archiveOffset + len) & (alignment - 1)) != 0) {\n             int padding = (int) ((-archiveOffset - len - EXTRAFIELD_HEADER_SIZE) & (alignment - 1));\n+            ZipExtraField pex = (PaddingExtraField) ze.getExtraField(PaddingExtraField.ID);\n+            if (pex != null) {\n+                padding += pex.getLocalFileDataLength().getValue() + EXTRAFIELD_HEADER_SIZE;\n+            }\n+            // will overwrite an existing PaddingExtraField\n             ze.addExtraField(new PaddingExtraField(padding));\n             extra = ze.getLocalFileDataExtra();\n-            len += EXTRAFIELD_HEADER_SIZE + padding;\n+            len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n         }\n         final byte[] buf = new byte[len];\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n             zipOutput.write(\"Hello Stored\\n\".getBytes(Charset.forName(\"UTF-8\")));\n             zipOutput.closeArchiveEntry();\n \n+            ZipArchiveEntry storedEntry2 = new ZipArchiveEntry(\"stored2.txt\");\n+            storedEntry2.setMethod(ZipEntry.STORED);\n+            storedEntry2.setAlignment(1024);\n+            storedEntry2.addExtraField(new PaddingExtraField(123));\n+            zipOutput.putArchiveEntry(storedEntry2);\n+            zipOutput.write(\"Hello pre-aligned Stored\\n\".getBytes(Charset.forName(\"UTF-8\")));\n+            zipOutput.closeArchiveEntry();\n+\n         }\n \n         try (ZipFile zf = new ZipFile(new SeekableInMemoryByteChannel(\n             ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\n             assertNotEquals(-1L, storedEntry.getCompressedSize());\n             assertNotEquals(-1L, storedEntry.getSize());\n-            assertEquals(0L, inflatedEntry.getDataOffset()%1024);\n+            assertEquals(0L, storedEntry.getDataOffset()%1024);\n             try (InputStream stream = zf.getInputStream(storedEntry)) {\n                 Assert.assertEquals(\"Hello Stored\\n\",\n+                                new String(IOUtils.toByteArray(stream), Charset.forName(\"UTF-8\")));\n+            }\n+\n+            ZipArchiveEntry storedEntry2 = zf.getEntry(\"stored2.txt\");\n+            assertNotEquals(-1L, storedEntry2.getCompressedSize());\n+            assertNotEquals(-1L, storedEntry2.getSize());\n+            assertEquals(0L, storedEntry2.getDataOffset()%1024);\n+            try (InputStream stream = zf.getInputStream(storedEntry2)) {\n+                Assert.assertEquals(\"Hello pre-aligned Stored\\n\",\n                                 new String(IOUtils.toByteArray(stream), Charset.forName(\"UTF-8\")));\n             }\n         }", "timestamp": 1494525874, "metainfo": ""}