{"sha": "2b5ba89b7705592e5ac2de46c6b68cfc5c16a53b", "log": "rename class constants that look like instance fields", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n     private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\n     private int currBlkIdx = -1;\n     private int blockSize = DumpArchiveConstants.TP_SIZE;\n-    private static final int recordSize = DumpArchiveConstants.TP_SIZE;\n+    private static final int RECORD_SIZE = DumpArchiveConstants.TP_SIZE;\n     private int readOffset = DumpArchiveConstants.TP_SIZE;\n     private boolean isCompressed = false;\n     private long bytesRead = 0;\n         throws IOException {\n         this.isCompressed = isCompressed;\n \n-        blockSize = recordSize * recsPerBlock;\n+        blockSize = RECORD_SIZE * recsPerBlock;\n \n         // save first block in case we need it again\n         final byte[] oldBuffer = blockBuffer;\n \n         // read rest of new block\n         blockBuffer = new byte[blockSize];\n-        System.arraycopy(oldBuffer, 0, blockBuffer, 0, recordSize);\n-        readFully(blockBuffer, recordSize, blockSize - recordSize);\n+        System.arraycopy(oldBuffer, 0, blockBuffer, 0, RECORD_SIZE);\n+        readFully(blockBuffer, RECORD_SIZE, blockSize - RECORD_SIZE);\n \n         this.currBlkIdx = 0;\n-        this.readOffset = recordSize;\n+        this.readOffset = RECORD_SIZE;\n     }\n \n     /**\n     @Override\n     public int read() throws IOException {\n         throw new IllegalArgumentException(\n-            \"all reads must be multiple of record size (\" + recordSize +\n+            \"all reads must be multiple of record size (\" + RECORD_SIZE +\n             \" bytes.\");\n     }\n \n      */\n     @Override\n     public int read(final byte[] b, int off, final int len) throws IOException {\n-        if ((len % recordSize) != 0) {\n+        if ((len % RECORD_SIZE) != 0) {\n             throw new IllegalArgumentException(\n-                \"all reads must be multiple of record size (\" + recordSize +\n+                \"all reads must be multiple of record size (\" + RECORD_SIZE +\n                 \" bytes.\");\n         }\n \n      */\n     @Override\n     public long skip(final long len) throws IOException {\n-        if ((len % recordSize) != 0) {\n+        if ((len % RECORD_SIZE) != 0) {\n             throw new IllegalArgumentException(\n-                \"all reads must be multiple of record size (\" + recordSize +\n+                \"all reads must be multiple of record size (\" + RECORD_SIZE +\n                 \" bytes.\");\n         }\n \n         }\n \n         // copy data, increment counters.\n-        final byte[] b = new byte[recordSize];\n+        final byte[] b = new byte[RECORD_SIZE];\n         System.arraycopy(blockBuffer, readOffset, b, 0, b.length);\n \n         return b;\n      * @throws IOException on error\n      */\n     public byte[] readRecord() throws IOException {\n-        final byte[] result = new byte[recordSize];\n+        final byte[] result = new byte[RECORD_SIZE];\n \n         // the read implementation will loop internally as long as\n         // input is available\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n     private long sourcePayloadLength = 0;\n     private long totalWrittenToOutputStream = 0;\n \n-    private static final int bufferSize = 4096;\n-    private final byte[] outputBuffer = new byte[bufferSize];\n-    private final byte[] readerBuf = new byte[bufferSize];\n+    private static final int BUFFER_SIZE = 4096;\n+    private final byte[] outputBuffer = new byte[BUFFER_SIZE];\n+    private final byte[] readerBuf = new byte[BUFFER_SIZE];\n \n     StreamCompressor(final Deflater deflater) {\n         this.def = deflater;\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n       final int c1 =(b[off+1] ^ (localCrc >>>= 8)) & 0xff; //NOSONAR\n       final int c2 =(b[off+2] ^ (localCrc >>>= 8)) & 0xff; //NOSONAR\n       final int c3 =(b[off+3] ^ (localCrc >>>= 8)) & 0xff; //NOSONAR\n-      localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1])\n-          ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);\n+      localCrc = (T[T8_7_START + c0] ^ T[T8_6_START + c1])\n+          ^ (T[T8_5_START + c2] ^ T[T8_4_START + c3]);\n \n       final int c4 = b[off+4] & 0xff;\n       final int c5 = b[off+5] & 0xff;\n       final int c6 = b[off+6] & 0xff;\n       final int c7 = b[off+7] & 0xff;\n \n-      localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5])\n-           ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);\n+      localCrc ^= (T[T8_3_START + c4] ^ T[T8_2_START + c5])\n+           ^ (T[T8_1_START + c6] ^ T[T8_0_START + c7]);\n \n       off += 8;\n       len -= 8;\n \n     /* loop unroll - duff's device style */\n     switch(len) {\n-      case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n-      case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\n+      case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n+      case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)];\n       default:\n         /* nothing */\n     }\n \n   @Override\n   final public void update(final int b) {\n-    crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\n+    crc = (crc >>> 8) ^ T[T8_0_START + ((crc ^ b) & 0xff)];\n   }\n     \n   // CRC polynomial tables generated by:\n   // java -cp build/test/classes/:build/classes/ \\\n   //   org.apache.hadoop.util.TestPureJavaCrc32\\$Table 82F63B78\n \n-  private static final int T8_0_start = 0*256;\n-  private static final int T8_1_start = 1*256;\n-  private static final int T8_2_start = 2*256;\n-  private static final int T8_3_start = 3*256;\n-  private static final int T8_4_start = 4*256;\n-  private static final int T8_5_start = 5*256;\n-  private static final int T8_6_start = 6*256;\n-  private static final int T8_7_start = 7*256;\n+  private static final int T8_0_START = 0*256;\n+  private static final int T8_1_START = 1*256;\n+  private static final int T8_2_START = 2*256;\n+  private static final int T8_3_START = 3*256;\n+  private static final int T8_4_START = 4*256;\n+  private static final int T8_5_START = 5*256;\n+  private static final int T8_6_START = 6*256;\n+  private static final int T8_7_START = 7*256;\n \n   private static final int[] T = new int[] {\n     /* T8_0 */", "timestamp": 1482242763, "metainfo": ""}