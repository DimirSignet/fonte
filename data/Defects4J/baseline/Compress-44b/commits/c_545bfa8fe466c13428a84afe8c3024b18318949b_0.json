{"sha": "545bfa8fe466c13428a84afe8c3024b18318949b", "log": "call of finish() is optional calling finish() twice causes an exception  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n     private long entryOffset = 0;\n     private ArArchiveEntry prevEntry;\n     private boolean haveUnclosedEntry = true;\n+    private boolean finished = false;\n \n     public ArArchiveOutputStream( final OutputStream pOut ) {\n         this.out = pOut;\n     }\n \n     public void close() throws IOException {\n+        if(!finished) {\n+            finish();\n+        }\n         out.close();\n         prevEntry = null;\n     }\n     public void finish() throws IOException {\n         if(haveUnclosedEntry) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n+        } else if(finished) {\n+            throw new IOException(\"This archive has already been finished\");\n         }\n+        finished = true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      */\n     public void finish() throws IOException {\n         ensureOpen();\n-\n-        if (this.finished) {\n-            return;\n-        }\n+        if (finished) {\n+            throw new IOException(\"This archive has already been finished\");\n+        }\n+        \n         if (this.entry != null) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n         }\n         this.entry.setNumberOfLinks(1);\n         writeHeader(this.entry);\n         closeArchiveEntry();\n+        \n+        finished = true;\n     }\n \n     /**\n      *             occurred\n      */\n     public void close() throws IOException {\n+        if(!finished) {\n+            finish();\n+        }\n+        \n         if (!this.closed) {\n             out.close();\n             this.closed = true;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     /* Indicates if putArchiveEntry has been called without closeArchiveEntry */\n     private boolean haveUnclosedEntry = false;\n     \n+    private boolean finished = false;\n+    \n     private final OutputStream out;\n \n     /**\n      * @throws IOException on error\n      */\n     public void finish() throws IOException {\n+        if (finished) {\n+            throw new IOException(\"This archive has already been finished\");\n+        }\n+        \n         if(haveUnclosedEntry) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n         }\n         writeEOFRecord();\n         writeEOFRecord();\n+        finished = true;\n     }\n \n     /**\n      * @throws IOException on error\n      */\n     public void close() throws IOException {\n+        if(!finished) {\n+            finish();\n+        }\n+        \n         if (!closed) {\n             buffer.close();\n             out.close();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private static final int SHORT = 2;\n     private static final int WORD = 4;\n     static final int BUFFER_SIZE = 512;\n+    \n+    private boolean finished = false;\n+    \n     /* \n      * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n      * when it gets handed a really big buffer.  See\n      * @see org.apache.commons.compress.archivers.ArchiveOutputStream#finish()\n      */\n     public void finish() throws IOException {\n+        if (finished) {\n+            throw new IOException(\"This archive has already been finished\");\n+        }\n+        \n         if(entry != null) {\n             throw new IOException(\"This archives contains unclosed entries.\");\n         }\n         writeCentralDirectoryEnd();\n         offsets.clear();\n         entries.clear();\n+        finished = true;\n     }\n \n     /**\n      * @exception  IOException  if an I/O error occurs.\n      */\n     public void close() throws IOException {\n+        if(!finished) {\n+            finish();\n+        }\n+        \n         if (raf != null) {\n             raf.close();\n         }\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n         }\n     }\n \n+    public void testOptionalFinish() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        \n+        ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n+        aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n+        aos1.closeArchiveEntry();\n+        aos1.close();\n+        \n+        aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n+        aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n+        aos1.closeArchiveEntry();\n+        aos1.close();\n+        try {\n+            aos1.finish();\n+            aos1.finish();\n+            fail(\"After putArchive should follow closeArchive\");\n+        } catch (IOException io) {\n+            // Exception expected\n+        }\n+    }\n }", "timestamp": 1240854238, "metainfo": ""}