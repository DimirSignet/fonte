{"sha": "0257fe02eff57d77f2a199b613d8b03b200ce532", "log": "second of seven permutations: size known, compression, writing to a stream.  Lesson learned: don't trust Deflater.getBytesRead, likely don't trust any of the related methods either, must fix later.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private long cdLength = 0;\n \n     /**\n+     * Number of bytes read for the current entry (can't rely on\n+     * Deflater#getBytesRead) when using DEFLATED.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private long bytesRead = 0;\n+\n+    /**\n      * Helper, a 0 as ZipShort.\n      */\n     private static final byte[] ZERO = {0, 0};\n                 deflate();\n             }\n \n+            /* It turns out def.getBytesRead() returns wrong values if\n+             * the size exceeds 4 GB - no idea whether one can trust\n+             * def.getBytesWritten()\n             entry.setSize(def.getBytesRead());\n+            */\n+            entry.setSize(bytesRead);\n             entry.setCompressedSize(def.getBytesWritten());\n             entry.setCrc(realCrc);\n \n \n         writeDataDescriptor(entry);\n         entry = null;\n+        bytesRead = 0;\n     }\n \n     /**\n         ZipUtil.checkRequestedFeatures(entry);\n         if (entry.getMethod() == DEFLATED) {\n             if (length > 0 && !def.finished()) {\n+                bytesRead += length;\n                 if (length <= DEFLATER_BLOCK_SIZE) {\n                     def.setInput(b, offset, length);\n                     deflateUntilInputIsNeeded();\n             return;\n         }\n         writeOut(DD_SIG);\n-        writeOut(ZipLong.getBytes(entry.getCrc()));\n+        writeOut(ZipLong.getBytes(ze.getCrc()));\n         int sizeFieldSize = WORD;\n         if (!hasZip64Extra(ze)) {\n-            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n-            writeOut(ZipLong.getBytes(entry.getSize()));\n+            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n         } else {\n             sizeFieldSize = DWORD;\n-            writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n-            writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n+            writeOut(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipEightByteInteger.getBytes(ze.getSize()));\n         }\n         written += 2 * WORD + 2 * sizeFieldSize;\n     }\n \n         if (needsZip64Extra) {\n             Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n-            if (ze.getCompressedSize() >= ZIP64_MAGIC) { \n+            if (ze.getCompressedSize() >= ZIP64_MAGIC\n+                || ze.getSize() >= ZIP64_MAGIC) {\n                 z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n             } else {\n                 // reset value that may have been set for LFH\n                 z64.setCompressedSize(null);\n-            }\n-            if (ze.getSize() >= ZIP64_MAGIC) {\n-                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n-            } else {\n-                // reset value that may have been set for LFH\n                 z64.setSize(null);\n             }\n             if (lfhOffset >= ZIP64_MAGIC) {\n         // compressed length\n         // uncompressed length\n         writeOut(ZipLong.getBytes(ze.getCrc()));\n-        writeOut(ZipLong.getBytes(Math.min(ze.getCompressedSize(), ZIP64_MAGIC)));\n-        writeOut(ZipLong.getBytes(Math.min(ze.getSize(), ZIP64_MAGIC)));\n+        if (ze.getCompressedSize() >= ZIP64_MAGIC\n+            || ze.getSize() >= ZIP64_MAGIC) {\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+        } else {\n+            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+        }\n         // CheckStyle:MagicNumber OFF\n         written += 12;\n         // CheckStyle:MagicNumber ON\n     private Zip64ExtendedInformationExtraField\n         getZip64Extra(ZipArchiveEntry ze) {\n         hasUsedZip64 = true;\n-        Zip64ExtendedInformationExtraField z64 =  \n+        Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField)\n             ze.getExtraField(Zip64ExtendedInformationExtraField\n                              .HEADER_ID);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n \n                 RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n-                    final long end = a.length();\n-                    long cdOffsetLoc = end - 22 /* eocd.length */\n-                        - 20 /* z64 eocd locator.length */\n-                        - 56 /* z64 eocd without extensible data sector */\n-                        + 48 /* position in z64 eocd */;\n-                    // seek to central directory\n-                    a.seek(cdOffsetLoc);\n-                    byte[] cdOffset = new byte[8];\n-                    a.readFully(cdOffset);\n-                    a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n                     // skip first two entries\n                     a.skipBytes(2 * 47 /* CD entry of file with\n                                           file name length 1 and no\n                                      RandomAccessFile a =\n                                          new RandomAccessFile(f, \"r\");\n                                      try {\n-                                         final long end = a.length();\n-                                         long cdOffsetLoc = end - 22\n-                                             - 20\n-                                             - 56\n-                                             + 48;\n-                                         // seek to central directory\n-                                         a.seek(cdOffsetLoc);\n-                                         byte[] cdOffset = new byte[8];\n-                                         a.readFully(cdOffset);\n-                                         a.seek(ZipEightByteInteger\n-                                                .getLongValue(cdOffset));\n+                                         final long end =\n+                                             getLengthAndPositionAtCentralDirectory(a);\n \n                                          // grab first entry, verify\n                                          // sizes are 0xFFFFFFFF and\n      *\n      * Creates a temporary archive of approx 4MB in size\n      */\n-    @Ignore\n     @Test public void writeBigDeflatedEntryKnownSizeToStream()\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\",\n                                      RandomAccessFile a =\n                                          new RandomAccessFile(f, \"r\");\n                                      try {\n-                                         final long end = a.length();\n-                                         long cdOffsetLoc = end - 22\n-                                             - 20\n-                                             - 56\n-                                             + 48;\n-                                         // seek to central directory\n-                                         a.seek(cdOffsetLoc);\n-                                         byte[] cdOffset = new byte[8];\n-                                         a.readFully(cdOffset);\n-                                         a.seek(ZipEightByteInteger\n-                                                .getLongValue(cdOffset));\n-\n+                                         final long end =\n+                                             getLengthAndPositionAtCentralDirectory(a);\n+\n+                                         long cfhPos = a.getFilePointer();\n                                          // grab first entry, verify\n                                          // sizes are 0xFFFFFFFF and\n                                          // it has a ZIP64 extended\n                                                  45, 0,\n                                                  // version needed to extract\n                                                  45, 0,\n-                                                 // GPB\n+                                                 // GPB (EFS + Data Descriptor)\n                                                  8, 8,\n                                                  // method\n                                                  8, 0,\n                                              }, header);\n                                          // ignore timestamp\n                                          a.skipBytes(4);\n-                                         byte[] crc = new byte[4];\n-                                         a.readFully(crc);\n-                                         assertArrayEquals(new byte[] {\n+                                         byte[] rest = new byte[31];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n                                                  (byte) 0x50, (byte) 0x6F,\n                                                  (byte) 0x31, (byte) 0x5c,\n-                                             }, crc);\n-                                         // ignore compressed size,\n-                                         // check it is smaller than\n-                                         // 4GB by validating it is\n-                                         // not part of the ZIP64\n-                                         // extra field\n-                                         a.skipBytes(4);\n-                                         byte[] rest = new byte[23];\n-                                         a.readFully(rest);\n-                                         assertArrayEquals(new byte[] {\n+                                                 // Compressed Size\n+                                                 (byte) 0xFF, (byte) 0xFF,\n+                                                 (byte) 0xFF, (byte) 0xFF,\n                                                  // Original Size\n                                                  (byte) 0xFF, (byte) 0xFF,\n                                                  (byte) 0xFF, (byte) 0xFF,\n                                                  // file name length\n                                                  1, 0,\n                                                  // extra field length\n-                                                 12, 0,\n+                                                 20, 0,\n                                                  // comment length\n                                                  0, 0,\n                                                  // disk number\n                                                  // Header-ID\n                                                  1, 0,\n                                                  // size of extra\n-                                                 8, 0,\n+                                                 16, 0,\n                                                  // original size\n                                                  0, (byte) 0xF2, 5, (byte) 0x2A,\n                                                  1, 0, 0, 0,\n+                                                 // don't know the\n+                                                 // compressed size,\n+                                                 // don't want to\n+                                                 // hard-code it\n                                              }, extra);\n+\n+                                         // validate data descriptor\n+                                         a.seek(cfhPos - 24);\n+                                         byte[] dd = new byte[8];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 7, 8,\n+                                                 // CRC\n+                                                 (byte) 0x50, (byte) 0x6F,\n+                                                 (byte) 0x31, (byte) 0x5c,\n+                                             }, dd);\n+                                         // skip uncompressed size\n+                                         a.skipBytes(8);\n+                                         dd = new byte[8];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // original size\n+                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n+                                                 1, 0, 0, 0,\n+                                             }, dd);\n \n                                          // and now validate local file header\n                                          a.seek(0);\n                                      } finally {\n                                          a.close();\n                                      }\n-\n-                                     read5GBOfZerosImpl(f, \"0\");\n                                  }\n                              },\n                              false);\n             }\n         }\n     }\n+\n+    private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n+        throws IOException {\n+        final long end = a.length();\n+        long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n+        // seek to central directory locator\n+        a.seek(cdOffsetLoc);\n+        byte[] cdOffset = new byte[8];\n+        a.readFully(cdOffset);\n+        a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+        return end;\n+    }\n }", "timestamp": 1312034936, "metainfo": ""}