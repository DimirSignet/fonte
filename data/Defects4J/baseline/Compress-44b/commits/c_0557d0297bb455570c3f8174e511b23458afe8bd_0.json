{"sha": "0557d0297bb455570c3f8174e511b23458afe8bd", "log": "experimental API for generic compressor for LZ77-like alhorithms  Right now I'm experimenting with the API as a building block for adding write support to Snappy. The hard part of LZ77 (finding matches for back-references) is generic enough to extract it.  If this works out it may help us implementing compressors for Snappy or LZ4 and with quite a bit of additional work for Brotli or DEFLATE64 (which use additional encoders on top of LZ77).", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+/**\n+ * Helper class for compression algorithms that use the ideas of LZ77.\n+ *\n+ * <p>Most LZ77 derived algorithms split input data into blocks of\n+ * uncompressed data (called literal blocks) and back-references\n+ * (pairs of offsets and lengths) that state \"add <code>length</code>\n+ * bytes that are the same as those already written starting\n+ * <code>offset</code> bytes before the current position. The details\n+ * of how those blocks and back-references are encoded are quite\n+ * different between the algorithms and some algorithms perform\n+ * additional steps (Huffman encoding in the case of DEFLATE for\n+ * example).</p>\n+ *\n+ * <p>This class attempts to extract the core logic - finding\n+ * back-references - so it can be re-used. It follows the algorithm\n+ * explained in section 4 of RFC 1951 (DEFLATE) and currently doesn't\n+ * implement the \"lazy match\" optimization. The three-byte hash function\n+ * used in this class is the same used by zlib and InfoZIP's ZIP\n+ * implementation of DEFLATE.</p>\n+ *\n+ * <p>LZ77 is used vaguely here (as well as many other places that\n+ * talk about it :-), LZSS would likely be closer to the truth but\n+ * LZ77 has become the synonym for a whole family of algorithms.</p>\n+ *\n+ * <p>The API consists of a compressor that is fed <code>byte</code>s\n+ * and emits {@link Block}s to a registered callback where the blocks\n+ * represent either {@link LiteralBlock literal blocks}, {@link\n+ * BackReference back references} or {@link EOD end of data\n+ * markers}. In order to ensure the callback receives all information,\n+ * the {@code #finish} method must be used once all data has been fed\n+ * into the compressor.</p>\n+ *\n+ * <p>Several parameters influence the outcome of the \"compression\":</p>\n+ * <dl>\n+ *\n+ *  <dt><code>windowSize</code></dt> <dd>the size of the sliding\n+ *  window, must be a power of two - this determines the maximum\n+ *  offset a back-reference can take. The compressor maintains a\n+ *  buffer of twice of <code>windowSize</code> - real world values are\n+ *  in the area of 32k.</dd>\n+ *\n+ *  <dt><code>minMatchSize</code></dt>\n+ *  <dd>Minimal size of a match found. A true minimum of 3 is\n+ *  hard-coded inside of this implemention but bigger sizes can be\n+ *  configured.</dd>\n+ *\n+ *  <dt><code>maxMatchSize</code></dt>\n+ *  <dd>Maximal size of a match found.</dd>\n+ *\n+ *  <dt><code>maxOffset</code></dt>\n+ *  <dd>Maximal offset of a back-reference.</dd>\n+ *\n+ *  <dt><code>maxLiteralSize</code></dt>\n+ *  <dd>Maximal size of a literal block.</dd>\n+ * </dl>\n+ *\n+ * @see \"https://tools.ietf.org/html/rfc1951#section-4\"\n+ * @since 1.14\n+ * @NotThreadSafe\n+ */\n+public class LZ77Compressor {\n+\n+    /**\n+     * Base class representing things the compressor may emit.\n+     */\n+    public static abstract class Block { }\n+    /**\n+     * Represents a literal block of data.\n+     */\n+    public static final class LiteralBlock extends Block {\n+        private final byte[] data;\n+        private LiteralBlock(byte[] data) {\n+            this.data = data;\n+        }\n+        /**\n+         * The literal data.\n+         *\n+         * <p>This returns a life view of the actual data in order to\n+         * avoid copying, modify the array at your own risk.</p>\n+         */\n+        public byte[] getData() {\n+            return data;\n+        }\n+    }\n+    /**\n+     * Represents a back-reference to a match.\n+     */\n+    public static final class BackReference extends Block {\n+        private final int offset, length;\n+        private BackReference(int offset, int length) {\n+            this.offset = offset;\n+            this.length = length;\n+        }\n+        /**\n+         * Provides the offset of the match.\n+         */\n+        public int getOffset() {\n+            return offset;\n+        }\n+        /**\n+         * Provides the length of the match.\n+         */\n+        public int getLength() {\n+            return length;\n+        }\n+    }\n+    /**\n+     * A simple \"we are done\" marker.\n+     */\n+    public static final class EOD extends Block { }\n+\n+    /**\n+     * Callback invoked while the compressor processes data.\n+     *\n+     * <p>The callback is invoked on the same thread that receives the\n+     * bytes to compress and may be invoked multiple times during the\n+     * execution of {@link #compress} or {@link #finish}.</p>\n+     */\n+    public interface Callback /* extends Consumer<Block> */ {\n+        void accept(Block b);\n+    }\n+\n+    private final Parameters params;\n+    private final Callback callback;\n+\n+    /**\n+     * Initializes a compressor with parameters and a callback.\n+     * @param params the parameters\n+     * @param callback the callback\n+     * @throws NullPointerException if either parameter is <code>null</code>\n+     */\n+    public LZ77Compressor(Parameters params, Callback callback) {\n+        if (params == null) {\n+            throw new NullPointerException(\"params must not be null\");\n+        }\n+        if (callback == null) {\n+            throw new NullPointerException(\"callback must not be null\");\n+        }\n+        this.params = params;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * Feeds bytes into the compressor which in turn may emit zero or\n+     * more blocks to the callback during the execution of this\n+     * method.\n+     * @param data the data to compress - must not be null\n+     */\n+    public void compress(byte[] data) {\n+        compress(data, 0, data.length);\n+    }\n+\n+    /**\n+     * Feeds bytes into the compressor which in turn may emit zero or\n+     * more blocks to the callback during the execution of this\n+     * method.\n+     * @param data the data to compress - must not be null\n+     * @param off the start offset of the data\n+     * @param len the number of bytes to compress\n+     */\n+    public void compress(byte[] data, int off, int len) {\n+    }\n+\n+    /**\n+     * Tells the compressor to process all remaining data and signal\n+     * end of data to the callback.\n+     *\n+     * <p>The compressor will in turn emit at least one block ({@link\n+     * EOD}) but potentially multiple blocks to the callback during\n+     * the execution of this method.</p>\n+     */\n+    public void finish() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/Parameters.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+/**\n+ * Parameters of the {@link LZ77Compressor compressor}.\n+ */\n+public final class Parameters {\n+    public static final int TRUE_MIN_MATCH_SIZE = 3;\n+    private final int windowSize, minMatchSize, maxMatchSize, maxOffset, maxLiteralSize;\n+\n+    /**\n+     * Initializes the compressor's parameters with a\n+     * <code>minMatchSize</code> of 3 and <code>max*Size</code>\n+     * equal to <code>windowSize</code>.\n+     *\n+     * @param windowSize the size of the sliding window - this\n+     * determines the maximum offset a back-reference can take.\n+     * @throws IllegalArgumentException if <code>windowSize</code>\n+     * is smaller than <code>minMatchSize</code>.\n+     */\n+    public Parameters(int windowSize) {\n+        this(windowSize, TRUE_MIN_MATCH_SIZE, windowSize, windowSize, windowSize);\n+    }\n+\n+    /**\n+     * Initializes the compressor's parameters.\n+     *\n+     * @param windowSize the size of the sliding window, must be a\n+     * power of two - this determines the maximum offset a\n+     * back-reference can take.\n+     * @param minMatchSize the minimal size of a match found. A\n+     * true minimum of 3 is hard-coded inside of this implemention\n+     * but bigger sizes can be configured.\n+     * @param maxMatchSize maximal site of a match found. A value\n+     * smaller than <code>minMatchSize</code> is interpreted as\n+     * infinite (actually {@link Integer.MAX_VALUE}).\n+     * @param maxOffset maximal offset of a back-reference. A\n+     * non-positive value is interpreted as <code>windowSize</code>.\n+     * @param maxLiteralSize maximal size of a literal block. Negative\n+     * numbers and 0 as well as values bigger than <code>2 *\n+     * windowSize</code> are interpreted as <code>windowSize</code>.\n+     * @throws IllegalArgumentException if <code>windowSize</code> is\n+     * smaller than <code>minMatchSize</code> or not a power of two.\n+     */\n+    public Parameters(int windowSize, int minMatchSize, int maxMatchSize,\n+                      int maxOffset, int maxLiteralSize) {\n+        this.minMatchSize = Math.max(TRUE_MIN_MATCH_SIZE, minMatchSize);\n+        if (windowSize < this.minMatchSize) {\n+            throw new IllegalArgumentException(\"windowSize must be at least as big as minMatchSize\");\n+        }\n+        if (!isPowerOfTwo(windowSize)) {\n+            throw new IllegalArgumentException(\"windowSize must be a power of two\");\n+        }\n+        this.windowSize = windowSize;\n+        this.maxOffset = maxOffset < 1 ? this.windowSize\n+            : Math.min(maxOffset, this.windowSize);\n+        this.maxMatchSize = maxMatchSize < this.minMatchSize ? Integer.MAX_VALUE\n+            : maxMatchSize;\n+        this.maxLiteralSize = maxLiteralSize < 1 || maxLiteralSize > 2 * windowSize\n+            ? windowSize : maxLiteralSize;\n+    }\n+\n+    /**\n+     * Gets the size of the sliding window - this determines the\n+     * maximum offset a back-reference can take.\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+    /**\n+     * Gets the minimal size of a match found.\n+     */\n+    public int getMinMatchSize() {\n+        return minMatchSize;\n+    }\n+    /**\n+     * Gets the maximal size of a match found.\n+     */\n+    public int getMaxMatchSize() {\n+        return maxMatchSize;\n+    }\n+    /**\n+     * Gets the maximal offset of a match found.\n+     */\n+    public int getMaxOffset() {\n+        return maxOffset;\n+    }\n+    /**\n+     * Gets the maximal size of a literal block.\n+     */\n+    public int getMaxLiteralSize() {\n+        return maxLiteralSize;\n+    }\n+\n+    private static final boolean isPowerOfTwo(int x) {\n+        // pre-condition: x > 0\n+        return (x & (x - 1)) == 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/ParametersTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class ParametersTest {\n+\n+    @Test\n+    public void defaultConstructor() {\n+        Parameters p = new Parameters(128);\n+        assertEquals(128, p.getWindowSize());\n+        assertEquals(3, p.getMinMatchSize());\n+        assertEquals(128, p.getMaxMatchSize());\n+        assertEquals(128, p.getMaxOffset());\n+        assertEquals(128, p.getMaxLiteralSize());\n+    }\n+\n+    @Test\n+    public void minMatchSizeIsAtLeastThree() {\n+        Parameters p = new Parameters(128, 2, 3, 4, 5);\n+        assertEquals(3, p.getMinMatchSize());\n+    }\n+\n+    @Test\n+    public void maxMatchSizeIsInfiniteWhenSmallerThanMinMatchSize() {\n+        Parameters p = new Parameters(128, 2, 2, 4, 5);\n+        assertEquals(Integer.MAX_VALUE, p.getMaxMatchSize());\n+    }\n+\n+    @Test\n+    public void maxMatchSizeIsMinMatchSizeIfBothAreEqual() {\n+        Parameters p = new Parameters(128, 2, 3, 4, 5);\n+        assertEquals(3, p.getMaxMatchSize());\n+    }\n+\n+    @Test\n+    public void maxOffsetIsWindowSizeIfSetTo0() {\n+        Parameters p = new Parameters(128, 2, 3, 0, 5);\n+        assertEquals(128, p.getMaxOffset());\n+    }\n+\n+    @Test\n+    public void maxOffsetIsWindowSizeIfSetToANegativeValue() {\n+        Parameters p = new Parameters(128, 2, 3, -1, 5);\n+        assertEquals(128, p.getMaxOffset());\n+    }\n+\n+    @Test\n+    public void maxOffsetIsWindowSizeIfBiggerThanWindowSize() {\n+        Parameters p = new Parameters(128, 2, 3, 129, 5);\n+        assertEquals(128, p.getMaxOffset());\n+    }\n+\n+    @Test\n+    public void maxLiteralSizeIsWindowSizeIfSetTo0() {\n+        Parameters p = new Parameters(128, 2, 3, 4, 0);\n+        assertEquals(128, p.getMaxLiteralSize());\n+    }\n+\n+    @Test\n+    public void maxLiteralSizeIsWindowSizeIfSetToANegativeValue() {\n+        Parameters p = new Parameters(128, 2, 3, 0, -1);\n+        assertEquals(128, p.getMaxLiteralSize());\n+    }\n+\n+    @Test\n+    public void maxLiteralSizeIsWindowSizeIfSetToAValueTooBigToHoldInSlidingWindow() {\n+        Parameters p = new Parameters(128, 2, 3, 0, 259);\n+        assertEquals(128, p.getMaxLiteralSize());\n+    }\n+\n+    @Test\n+    public void allParametersUsuallyTakeTheirSpecifiedValues() {\n+        Parameters p = new Parameters(256, 4, 5, 6, 7);\n+        assertEquals(256, p.getWindowSize());\n+        assertEquals(4, p.getMinMatchSize());\n+        assertEquals(5, p.getMaxMatchSize());\n+        assertEquals(6, p.getMaxOffset());\n+        assertEquals(7, p.getMaxLiteralSize());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void windowSizeMustNotBeSmallerThanMinMatchSize() {\n+        new Parameters(128, 200, 300, 400, 500);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void windowSizeMustNotBeAPowerOfTwo() {\n+        new Parameters(100, 200, 300, 400, 500);\n+    }\n+}", "timestamp": 1483735846, "metainfo": ""}