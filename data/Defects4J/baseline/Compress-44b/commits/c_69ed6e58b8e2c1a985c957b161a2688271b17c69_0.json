{"sha": "69ed6e58b8e2c1a985c957b161a2688271b17c69", "log": "ensure ZIP64 features are kept to a minimum for entries that don't need them.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.DEFLATE_MIN_VERSION;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DATA_DESCRIPTOR_MIN_VERSION;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.INITIAL_VERSION;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n     private boolean hasUsedZip64 = false;\n \n     /**\n+     * Whether current entry was the first one using ZIP64 features.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean entryCausedUseOfZip64 = false;\n+\n+    /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n      * @param out the outputstream to zip\n      */\n         // the correct CRC and compressed/uncompressed sizes\n         if (raf != null) {\n             long save = raf.getFilePointer();\n+            boolean actuallyNeedsZip64 = entry.getSize() >= ZIP64_MAGIC\n+                || entry.getCompressedSize() >= ZIP64_MAGIC;\n \n             raf.seek(localDataStart);\n             writeOut(ZipLong.getBytes(entry.getCrc()));\n-            if (!hasZip64Extra(entry)\n-                || (entry.getSize() < ZIP64_MAGIC\n-                    && entry.getCompressedSize() < ZIP64_MAGIC)) {\n+            if (!hasZip64Extra(entry) || !actuallyNeedsZip64) {\n                 writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n                 writeOut(ZipLong.getBytes(entry.getSize()));\n             } else {\n                 // first, unlike the LFH, CD or data descriptor\n                 writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n                 writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n+\n+                if (!actuallyNeedsZip64) {\n+                    // do some cleanup:\n+                    // * rewrite version needed to extract\n+                    raf.seek(localDataStart  - 5 * SHORT);\n+                    writeOut(ZipShort.getBytes(INITIAL_VERSION));\n+\n+                    // * remove ZIP64 extra so it doesn't get written\n+                    //   to the central directory\n+                    entry.removeExtraField(Zip64ExtendedInformationExtraField\n+                                           .HEADER_ID);\n+                    entry.setExtra();\n+\n+                    // * reset hasUsedZip64 if it has been set because\n+                    //   of this entry\n+                    hasUsedZip64 &= !entryCausedUseOfZip64;\n+                }\n             }\n             raf.seek(save);\n         }\n         writeDataDescriptor(entry);\n         entry = null;\n         bytesRead = 0;\n+        entryCausedUseOfZip64 = false;\n     }\n \n     /**\n         // version made by\n         // CheckStyle:MagicNumber OFF\n         writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n-                                   (!hasUsedZip64 ? DEFLATE_MIN_VERSION\n+                                   (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION\n                                                   : ZIP64_MIN_VERSION)));\n         written += SHORT;\n \n         throws IOException {\n \n         // CheckStyle:MagicNumber OFF\n-        int versionNeededToExtract = 10;\n+        int versionNeededToExtract = INITIAL_VERSION;\n         GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useUTF8ForNames(useUTF8Flag || utfFallback);\n         if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n-            versionNeededToExtract = DEFLATE_MIN_VERSION;\n+            versionNeededToExtract = DATA_DESCRIPTOR_MIN_VERSION;\n             b.useDataDescriptor(true);\n         }\n         if (zip64) {\n      */\n     private Zip64ExtendedInformationExtraField\n         getZip64Extra(ZipArchiveEntry ze) {\n+        entryCausedUseOfZip64 = !hasUsedZip64;\n         hasUsedZip64 = true;\n         Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField)\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n     /** length of a ZipEightByteInteger in bytes */\n     static final int DWORD = 8;\n \n-    /** ZIP specification version that introduced DEFLATE method */\n-    static final int DEFLATE_MIN_VERSION = 20;\n+    /** Initial ZIP specification version */\n+    static final int INITIAL_VERSION = 10;\n+\n+    /** ZIP specification version that introduced data descriptor method */\n+    static final int DATA_DESCRIPTOR_MIN_VERSION = 20;\n \n     /** ZIP specification version that introduced ZIP64 */\n     static final int ZIP64_MIN_VERSION = 45;\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n public class Zip64SupportTest {\n \n     private static final long FIVE_BILLION = 5000000000l;\n+    private static final int ONE_MILLION = 1000000;\n     private static final int ONE_HUNDRED_THOUSAND = 100000;\n \n     @Test public void read5GBOfZerosUsingInputStream() throws Throwable {\n         new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n-                byte[] buf = new byte[1000 * 1000];\n+                byte[] buf = new byte[ONE_MILLION];\n                 ZipArchiveEntry zae = null;\n                 for (int i = 0; i < 2; i++) {\n                     zae = new ZipArchiveEntry(String.valueOf(i));\n         return new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n-                byte[] buf = new byte[1000 * 1000];\n+                byte[] buf = new byte[ONE_MILLION];\n                 ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(FIVE_BILLION);\n                              true);\n     }\n \n+    @Ignore\n     @Test public void writeBigStoredEntryUnnownSizeToFile() throws Throwable {\n         withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n                              writeBigStoredEntry(false),\n                                  public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n-                                     byte[] buf = new byte[1000 * 1000];\n+                                     byte[] buf = new byte[ONE_MILLION];\n                                      ZipArchiveEntry zae =\n                                          new ZipArchiveEntry(\"0\");\n                                      zae.setSize(FIVE_BILLION);\n         return new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n-                byte[] buf = new byte[1000 * 1000];\n+                byte[] buf = new byte[ONE_MILLION];\n                 ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(FIVE_BILLION);\n                              true);\n     }\n \n+    @Ignore\n     @Test public void writeBigDeflatedEntryUnknownSizeToFile()\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFile\",\n                              writeBigDeflatedEntryToFile(false),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written without compression.\n+     *\n+     * No Compression => sizes are stored directly inside the LFH.  No\n+     * Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n+     * field if size was known.\n+     *\n+     * Creates a temporary archive of approx 1MB in size\n+     */\n+    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                    zae.setCrc(0x1279CB9EL);\n+                }\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    // grab first CF entry, verify sizes are 1e6 and it\n+                    // has no ZIP64 extended information extra field\n+                    // at all\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header: this one\n+                    // has a ZIP64 extra field if and only if size was\n+                    // unknown\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit)\n+                            0, 8,\n+                            // method\n+                            0, 0\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    // 1e6 == 0xF4240\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12,\n+                            // Compressed Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            (byte) (knownSize ? 0 : 20), 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    if (!knownSize) {\n+                        byte[] extra = new byte[20];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size of extra\n+                                16, 0,\n+                                // original size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                                // compressed size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                            }, extra);\n+                    }\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallStoredEntryToStream() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryToStream\",\n+                             writeSmallStoredEntry(true),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallStoredEntryKnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFile\",\n+                             writeSmallStoredEntry(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryUnnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFile\",\n+                             writeSmallStoredEntry(false),\n+                             true);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH, real values\n+     * are inside the data descriptor.  No ZIP64 extra field at all.\n+     */\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     byte[] buf = new byte[ONE_MILLION];\n+                                     ZipArchiveEntry zae =\n+                                         new ZipArchiveEntry(\"0\");\n+                                     zae.setSize(ONE_MILLION);\n+                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                     zos.putArchiveEntry(zae);\n+                                     zos.write(buf);\n+                                     zos.closeArchiveEntry();\n+                                     zos.close();\n+\n+                                     RandomAccessFile a =\n+                                         new RandomAccessFile(f, \"r\");\n+                                     try {\n+                                         final long end =\n+                                             getLengthAndPositionAtCentralDirectory(a);\n+\n+                                         long cfhPos = a.getFilePointer();\n+                                         // grab first entry, verify\n+                                         // sizes are not 0xFFFFFFF\n+                                         // and it has no ZIP64\n+                                         // extended information extra\n+                                         // field\n+                                         byte[] header = new byte[12];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                                 // version made by\n+                                                 20, 0,\n+                                                 // version needed to extract\n+                                                 20, 0,\n+                                                 // GPB (EFS + Data Descriptor)\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         byte[] crc = new byte[4];\n+                                         a.readFully(crc);\n+                                         assertArrayEquals(new byte[] {\n+                                                 (byte) 0x9E, (byte) 0xCB,\n+                                                 (byte) 0x79, (byte) 0x12,\n+                                             }, crc);\n+                                         // skip compressed size\n+                                         a.skipBytes(4);\n+                                         byte[] rest = new byte[23];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // Original Size\n+                                                 (byte) 0x40, (byte) 0x42,\n+                                                 (byte) 0x0F, 0,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 0, 0,\n+                                                 // comment length\n+                                                 0, 0,\n+                                                 // disk number\n+                                                 0, 0,\n+                                                 // attributes\n+                                                 0, 0,\n+                                                 0, 0, 0, 0,\n+                                                 // offset\n+                                                 0, 0, 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+\n+                                         // validate data descriptor\n+                                         a.seek(cfhPos - 16);\n+                                         byte[] dd = new byte[8];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 7, 8,\n+                                                 // CRC\n+                                                 (byte) 0x9E, (byte) 0xCB,\n+                                                 (byte) 0x79, (byte) 0x12,\n+                                             }, dd);\n+                                         // skip uncompressed size\n+                                         a.skipBytes(4);\n+                                         dd = new byte[4];\n+                                         a.readFully(dd);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // original size\n+                                                 (byte) 0x40, (byte) 0x42,\n+                                                 (byte) 0x0F, 0,\n+                                             }, dd);\n+\n+                                         // and now validate local file header\n+                                         a.seek(0);\n+                                         header = new byte[10];\n+                                         a.readFully(header);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // sig\n+                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n+                                                 // version needed to extract\n+                                                 20, 0,\n+                                                 // GPB (EFS + Data Descriptor)\n+                                                 8, 8,\n+                                                 // method\n+                                                 8, 0,\n+                                             }, header);\n+                                         // ignore timestamp\n+                                         a.skipBytes(4);\n+                                         rest = new byte[17];\n+                                         a.readFully(rest);\n+                                         assertArrayEquals(new byte[] {\n+                                                 // CRC\n+                                                 0, 0, 0, 0,\n+                                                 // Compressed Size\n+                                                 0, 0, 0, 0,\n+                                                 // Original Size\n+                                                 0, 0, 0, 0,\n+                                                 // file name length\n+                                                 1, 0,\n+                                                 // extra field length\n+                                                 0, 0,\n+                                                 // file name\n+                                                 (byte) '0'\n+                                             }, rest);\n+                                     } finally {\n+                                         a.close();\n+                                     }\n+                                 }\n+                             },\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.  Shouldn't contain any ZIP64 extra\n+     * field if size was known.\n+     */\n+    private static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[ONE_MILLION];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(ONE_MILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                zos.write(buf);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first CD entry, verify sizes are not\n+                    // 0xFFFFFFFF and it has a no ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            20, 0,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS + *no* Data Descriptor)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            0, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            10, 0,\n+                            // GPB (EFS bit, no DD)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    crc = new byte[4];\n+                    a.readFully(crc);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x9E, (byte) 0xCB,\n+                            (byte) 0x79, (byte) 0x12,\n+                        }, crc);\n+                    // skip compressed size\n+                    a.skipBytes(4);\n+                    rest = new byte[9];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            (byte) (knownSize ? 0 : 20), 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    if (!knownSize) {\n+                        byte[] extra = new byte[12];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size of extra\n+                                16, 0,\n+                                // original size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                                // don't know the\n+                                // compressed size,\n+                                // don't want to\n+                                // hard-code it\n+                            }, extra);\n+                    }\n+                } finally {\n+                    a.close();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFile\",\n+                             writeSmallDeflatedEntryToFile(true),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFile\",\n+                             writeSmallDeflatedEntryToFile(false),\n                              true);\n     }\n \n     private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n         throws IOException {\n         final long end = a.length();\n+        a.seek(end - 22 - 20);\n+        byte[] sig = new byte[4];\n+        a.readFully(sig);\n+        if (sig[0] != (byte) 0x50 || sig[1] != (byte) 0x4b\n+            || sig[2] != 6 || sig[3] != 7) {\n+            // not a ZIP64 archive\n+            return getLengthAndPositionAtCentralDirectory32(a, end);\n+        }\n+\n         long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n         // seek to central directory locator\n         a.seek(cdOffsetLoc);\n         a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n         return end;\n     }\n+\n+    private static long getLengthAndPositionAtCentralDirectory32(RandomAccessFile a, final long end)\n+        throws IOException {\n+        a.seek(end - 22 + 16);\n+        byte[] cdOffset = new byte[4];\n+        a.readFully(cdOffset);\n+        a.seek(ZipLong.getValue(cdOffset));\n+        return end;\n+    }\n }", "timestamp": 1312144232, "metainfo": ""}