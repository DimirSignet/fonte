{"sha": "3bf400edc1add6078a9bd935e3ae684b8bf8493f", "log": "COMPRESS-390: Expose stream offsets and size", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/EntryStreamOffsets.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers;\n+\n+\n+/**\n+ * Provides information about ArchiveEntry stream offsets.\n+ */\n+public interface EntryStreamOffsets {\n+\n+    /** Special value indicating that the offset is unknown. */\n+    long OFFSET_UNKNOWN = -1;\n+\n+    /**\n+     * Gets the offset of data stream within the archive file,\n+     *\n+     * @return\n+     *      the offset of entry data stream, {@code OFFSET_UNKNOWN} if not known.\n+     */\n+    long getDataOffset();\n+\n+    /**\n+     * Indicates whether the stream is contiguous, i.e. not split among\n+     * several archive parts, interspersed with control blocks, etc.\n+     *\n+     * @return\n+     *      true if stream is contiguous, false otherwise.\n+     */\n+    boolean isStreamContiguous();\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n  * @NotThreadSafe\n  */\n \n-public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n+public class TarArchiveEntry implements ArchiveEntry, TarConstants {\n     private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n \n     /** The entry's name. */\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n package org.apache.commons.compress.archivers.zip;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.EntryStreamOffsets;\n \n import java.io.File;\n import java.util.ArrayList;\n  * @NotThreadSafe\n  */\n public class ZipArchiveEntry extends java.util.zip.ZipEntry\n-    implements ArchiveEntry {\n+    implements ArchiveEntry, EntryStreamOffsets\n+{\n \n     public static final int PLATFORM_UNIX = 3;\n     public static final int PLATFORM_FAT  = 0;\n     private byte[] rawName = null;\n     private GeneralPurposeBit gpb = new GeneralPurposeBit();\n     private static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\n+    private long localHeaderOffset = OFFSET_UNKNOWN;\n+    private long dataOffset = OFFSET_UNKNOWN;\n+    private boolean isStreamContiguous = false;\n+\n \n     /**\n      * Creates a new zip entry with the specified name.\n             return b;\n         }\n         return null;\n+    }\n+\n+    protected long getLocalHeaderOffset() {\n+        return this.localHeaderOffset;\n+    }\n+\n+    protected void setLocalHeaderOffset(long localHeaderOffset) {\n+        this.localHeaderOffset = localHeaderOffset;\n+    }\n+\n+    @Override\n+    public long getDataOffset() {\n+        return dataOffset;\n+    }\n+\n+    /**\n+     * Sets the data offset.\n+     *\n+     * @param dataOffset\n+     *      new value of data offset.\n+     */\n+    protected void setDataOffset(long dataOffset) {\n+        this.dataOffset = dataOffset;\n+    }\n+\n+    @Override\n+    public boolean isStreamContiguous() {\n+        return isStreamContiguous;\n+    }\n+\n+    protected void setStreamContiguous(boolean isStreamContiguous) {\n+        this.isStreamContiguous = isStreamContiguous;\n     }\n \n     /**\n                              other.getCentralDirectoryExtra())\n             && Arrays.equals(getLocalFileDataExtra(),\n                              other.getLocalFileDataExtra())\n+            && localHeaderOffset == other.localHeaderOffset\n+            && dataOffset == other.dataOffset\n             && gpb.equals(other.gpb);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n             firstEntry = false;\n         }\n \n+        long currentHeaderOffset = getBytesRead();\n         try {\n             if (firstEntry) {\n                 // split archives have a special signature before the\n         }\n \n         processZip64Extra(size, cSize);\n+\n+        current.entry.setLocalHeaderOffset(currentHeaderOffset);\n+        current.entry.setDataOffset(getBytesRead());\n+        current.entry.setStreamContiguous(true);\n \n         if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n             if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                 current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n             }\n         }\n-        \n+\n         entriesRead++;\n         return current.entry;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n     private final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\n         new HashMap<>(HASH_SIZE);\n \n-    private static final class OffsetEntry {\n-        private long headerOffset = -1;\n-        private long dataOffset = -1;\n-    }\n-\n     /**\n      * The encoding to use for filenames and the file comment.\n      *\n         if (!(ze instanceof Entry)) {\n             return null;\n         }\n-        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n-        final long start = offsetEntry.dataOffset;\n+        final long start = ze.getDataOffset();\n         return createBoundedInputStream(start, ze.getCompressedSize());\n     }\n \n             return null;\n         }\n         // cast valididty is checked just above\n-        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n         ZipUtil.checkRequestedFeatures(ze);\n-        final long start = offsetEntry.dataOffset;\n+        final long start = ze.getDataOffset();\n         // doesn't get closed if the method is not supported, but doesn't hold any resources either\n         final BoundedInputStream bis =\n             createBoundedInputStream(start, ze.getCompressedSize()); //NOSONAR\n         cfhBbuf.rewind();\n         IOUtils.readFully(archive, cfhBbuf);\n         int off = 0;\n-        final OffsetEntry offset = new OffsetEntry();\n-        final Entry ze = new Entry(offset);\n+        final Entry ze = new Entry();\n \n         final int versionMadeBy = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n         ze.setName(entryEncoding.decode(fileName), fileName);\n \n         // LFH offset,\n-        offset.headerOffset = ZipLong.getValue(cfhBuf, off);\n+        ze.setLocalHeaderOffset(ZipLong.getValue(cfhBuf, off));\n         // data offset will be filled later\n         entries.add(ze);\n \n         IOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\n         ze.setCentralDirectoryExtra(cdExtraData);\n \n-        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n+        setSizesAndOffsetFromZip64Extra(ze, diskStart);\n \n         final byte[] comment = new byte[commentLen];\n         IOUtils.readFully(archive, ByteBuffer.wrap(comment));\n      * size would be invalid.</p>\n      */\n     private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\n-                                                 final OffsetEntry offset,\n                                                  final int diskStart)\n         throws IOException {\n         final Zip64ExtendedInformationExtraField z64 =\n             final boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n             final boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n             final boolean hasRelativeHeaderOffset =\n-                offset.headerOffset == ZIP64_MAGIC;\n+                ze.getLocalHeaderOffset() == ZIP64_MAGIC;\n             z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                             hasCompressedSize,\n                                             hasRelativeHeaderOffset,\n             }\n \n             if (hasRelativeHeaderOffset) {\n-                offset.headerOffset =\n-                    z64.getRelativeHeaderOffset().getLongValue();\n+                ze.setLocalHeaderOffset(z64.getRelativeHeaderOffset().getLongValue());\n             }\n         }\n     }\n             // entries is filled in populateFromCentralDirectory and\n             // never modified\n             final Entry ze = (Entry) zipArchiveEntry;\n-            final OffsetEntry offsetEntry = ze.getOffsetEntry();\n-            final long offset = offsetEntry.headerOffset;\n+            final long offset = ze.getLocalHeaderOffset();\n             archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n             wordBbuf.rewind();\n             IOUtils.readFully(archive, wordBbuf);\n             final byte[] localExtraData = new byte[extraFieldLen];\n             IOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\n             ze.setExtra(localExtraData);\n-            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n-                + SHORT + SHORT + fileNameLen + extraFieldLen;\n+            ze.setDataOffset(offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+                + SHORT + SHORT + fileNameLen + extraFieldLen);\n+            ze.setStreamContiguous(true);\n \n             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                 final NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n             if (ent2 == null) {\n                 return -1;\n             }\n-            final long val = (ent1.getOffsetEntry().headerOffset\n-                        - ent2.getOffsetEntry().headerOffset);\n+            final long val = (ent1.getLocalHeaderOffset()\n+                        - ent2.getLocalHeaderOffset());\n             return val == 0 ? 0 : val < 0 ? -1 : +1;\n         }\n     };\n      */\n     private static class Entry extends ZipArchiveEntry {\n \n-        private final OffsetEntry offsetEntry;\n-\n-        Entry(final OffsetEntry offset) {\n-            this.offsetEntry = offset;\n-        }\n-\n-        OffsetEntry getOffsetEntry() {\n-            return offsetEntry;\n+        Entry() {\n         }\n \n         @Override\n         public int hashCode() {\n             return 3 * super.hashCode()\n-                + (int) (offsetEntry.headerOffset % Integer.MAX_VALUE);\n+                + (int) getLocalHeaderOffset()+(int)(getLocalHeaderOffset()>>32);\n         }\n \n         @Override\n             if (super.equals(other)) {\n                 // super.equals would return false if other were not an Entry\n                 final Entry otherEntry = (Entry) other;\n-                return offsetEntry.headerOffset\n-                        == otherEntry.offsetEntry.headerOffset\n-                    && offsetEntry.dataOffset\n-                        == otherEntry.offsetEntry.dataOffset;\n+                return getLocalHeaderOffset()\n+                        == otherEntry.getLocalHeaderOffset()\n+                    && getDataOffset()\n+                        == otherEntry.getDataOffset();\n             }\n             return false;\n         }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n \n import java.io.BufferedInputStream;\n import java.io.EOFException;\n+import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Arrays;\n import java.util.zip.ZipException;\n \n+import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ZipArchiveInputStreamTest {\n         }\n     }\n \n+    /**\n+     * Test correct population of header and data offsets.\n+     */\n+    @Test\n+    public void testOffsets() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        try (InputStream archiveStream = ZipArchiveInputStream.class.getResourceAsStream(\"/mixed.zip\");\n+             ZipArchiveInputStream zipStream =  new ZipArchiveInputStream((archiveStream))\n+        ) {\n+            ZipArchiveEntry inflatedEntry = zipStream.getNextZipEntry();\n+            Assert.assertEquals(\"inflated.txt\", inflatedEntry.getName());\n+            Assert.assertEquals(0x0000, inflatedEntry.getLocalHeaderOffset());\n+            Assert.assertEquals(0x0046, inflatedEntry.getDataOffset());\n+            ZipArchiveEntry storedEntry = zipStream.getNextZipEntry();\n+            Assert.assertEquals(\"stored.txt\", storedEntry.getName());\n+            Assert.assertEquals(0x5892, storedEntry.getLocalHeaderOffset());\n+            Assert.assertEquals(0x58d6, storedEntry.getDataOffset());\n+            Assert.assertNull(zipStream.getNextZipEntry());\n+        }\n+    }\n+\n     private static byte[] readEntry(ZipArchiveInputStream zip, ZipArchiveEntry zae) throws IOException {\n         final int len = (int)zae.getSize();\n         final byte[] buff = new byte[len];\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import static org.apache.commons.compress.AbstractTestCase.getFile;\n import static org.junit.Assert.*;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.util.Map;\n import java.util.TreeMap;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.zip.CRC32;\n import java.util.zip.ZipEntry;\n \n import org.apache.commons.compress.utils.IOUtils;\n import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;\n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Test;\n \n public class ZipFileTest {\n         assertEquals(2, passedCount.get());\n     }\n \n+    /**\n+     * Test correct population of header and data offsets.\n+     */\n+    @Test\n+    public void testOffsets() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        final File archive = getFile(\"mixed.zip\");\n+        try (ZipFile zf = new ZipFile(archive)) {\n+            ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\n+            Assert.assertEquals(0x0000, inflatedEntry.getLocalHeaderOffset());\n+            Assert.assertEquals(0x0046, inflatedEntry.getDataOffset());\n+            Assert.assertTrue(inflatedEntry.isStreamContiguous());\n+            ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\n+            Assert.assertEquals(0x5892, storedEntry.getLocalHeaderOffset());\n+            Assert.assertEquals(0x58d6, storedEntry.getDataOffset());\n+            Assert.assertTrue(inflatedEntry.isStreamContiguous());\n+        }\n+    }\n+\n+    /**\n+     * Test correct population of header and data offsets when they are written after stream.\n+     */\n+    @Test\n+    public void testDelayedOffsetsAndSizes() throws Exception {\n+        ByteArrayOutputStream zipContent = new ByteArrayOutputStream();\n+        try (ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(zipContent)) {\n+            ZipArchiveEntry inflatedEntry = new ZipArchiveEntry(\"inflated.txt\");\n+            inflatedEntry.setMethod(ZipEntry.DEFLATED);\n+            zipOutput.putArchiveEntry(inflatedEntry);\n+            zipOutput.write(\"Hello Deflated\\n\".getBytes());\n+            zipOutput.closeArchiveEntry();\n+\n+            byte[] storedContent = \"Hello Stored\\n\".getBytes();\n+            ZipArchiveEntry storedEntry = new ZipArchiveEntry(\"stored.txt\");\n+            storedEntry.setMethod(ZipEntry.STORED);\n+            storedEntry.setSize(storedContent.length);\n+            storedEntry.setCrc(calculateCrc32(storedContent));\n+            zipOutput.putArchiveEntry(storedEntry);\n+            zipOutput.write(\"Hello Stored\\n\".getBytes());\n+            zipOutput.closeArchiveEntry();\n+\n+        }\n+\n+        try (ZipFile zf = new ZipFile(new SeekableInMemoryByteChannel(zipContent.toByteArray()))) {\n+            ZipArchiveEntry inflatedEntry = zf.getEntry(\"inflated.txt\");\n+            Assert.assertNotEquals(-1L, inflatedEntry.getLocalHeaderOffset());\n+            Assert.assertNotEquals(-1L, inflatedEntry.getDataOffset());\n+            Assert.assertTrue(inflatedEntry.isStreamContiguous());\n+            Assert.assertNotEquals(-1L, inflatedEntry.getCompressedSize());\n+            Assert.assertNotEquals(-1L, inflatedEntry.getSize());\n+            ZipArchiveEntry storedEntry = zf.getEntry(\"stored.txt\");\n+            Assert.assertNotEquals(-1L, storedEntry.getLocalHeaderOffset());\n+            Assert.assertNotEquals(-1L, storedEntry.getDataOffset());\n+            Assert.assertTrue(inflatedEntry.isStreamContiguous());\n+            Assert.assertNotEquals(-1L, storedEntry.getCompressedSize());\n+            Assert.assertNotEquals(-1L, storedEntry.getSize());\n+        }\n+    }\n+\n     private void assertAllReadMethods(byte[] expected, ZipFile zipFile, ZipArchiveEntry entry) {\n         // simple IOUtil read\n         try (InputStream stream = zf.getInputStream(entry)) {\n         return full;\n     }\n \n+    private long calculateCrc32(byte[] content) {\n+        CRC32 crc = new CRC32();\n+        crc.update(content);\n+        return crc.getValue();\n+    }\n+\n     /*\n      * ordertest.zip has been handcrafted.\n      *", "timestamp": 1493909237, "metainfo": ""}