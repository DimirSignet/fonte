{"sha": "b5d6f1f622c7770d0473f380aa3156ea79dae77a", "log": "COMPRESS-271 xxhash32 checksum", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import static java.lang.Integer.rotateLeft;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * Implementation of the xxhash32 hash algorithm.\n+ *\n+ * @see <a href=\"http://cyan4973.github.io/xxHash/\">xxHash</a>\n+ * @NotThreadSafe\n+ * @since 1.14\n+ */\n+public class XXHash32 implements Checksum {\n+\n+    private static final int BUF_SIZE = 16;\n+    private static final int ROTATE_BITS = 13;\n+\n+    private static final int PRIME1 = (int) 2654435761l;\n+    private static final int PRIME2 = (int) 2246822519l;\n+    private static final int PRIME3 = (int) 3266489917l;\n+    private static final int PRIME4 =  668265263;\n+    private static final int PRIME5 =  374761393;\n+\n+    private final byte[] oneByte = new byte[1];\n+    private final int[] state = new int[4];\n+    private final ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE).order(ByteOrder.LITTLE_ENDIAN);\n+    private final int seed;\n+\n+    private int totalLen;\n+    private int pos;\n+\n+    /**\n+     * Creates an XXHash32 instance with a seed of 0.\n+     */\n+    public XXHash32() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Creates an XXHash32 instance.\n+     */\n+    public XXHash32(int seed) {\n+        this.seed = seed;\n+        initializeState();\n+    }\n+\n+    @Override\n+    public void reset() {\n+        initializeState();\n+        buffer.clear();\n+        totalLen = 0;\n+        pos = 0;\n+    }\n+\n+    @Override\n+    public void update(int b) {\n+        oneByte[0] = (byte) (b & 0xff);\n+        update(oneByte, 0, 1);\n+    }\n+\n+    @Override\n+    public void update(byte[] b, int off, final int len) {\n+        if (len <= 0) {\n+            return;\n+        }\n+        totalLen += len;\n+\n+        final int end = off + len;\n+\n+        if (pos + len < BUF_SIZE) {\n+            buffer.put(b, off, len);\n+            pos += len;\n+            return;\n+        }\n+\n+        if (pos > 0) {\n+            final int size = BUF_SIZE - pos;\n+            buffer.put(b, off, size);\n+            process();\n+            off += size;\n+        }\n+\n+        final int limit = end - BUF_SIZE;\n+        while (off <= limit) {\n+            buffer.put(b, off, BUF_SIZE);\n+            process();\n+            off += BUF_SIZE;\n+        }\n+\n+        if (off < end) {\n+            pos = end - off;\n+            buffer.put(b, off, pos);\n+        }\n+    }\n+\n+    @Override\n+    public long getValue() {\n+        int hash;\n+        if (totalLen > BUF_SIZE) {\n+            hash =\n+                rotateLeft(state[0],  1) +\n+                rotateLeft(state[1],  7) +\n+                rotateLeft(state[2], 12) +\n+                rotateLeft(state[3], 18);\n+        } else {\n+            hash = state[2] + PRIME5;\n+        }\n+        hash += totalLen;\n+\n+        buffer.flip();\n+\n+        int idx = 0;\n+        final int limit = pos - 4;\n+        for (; idx <= limit; idx += 4) {\n+            hash = rotateLeft(hash + buffer.getInt() * PRIME3, 17) * PRIME4;\n+        }\n+        while (idx < pos) {\n+            hash = rotateLeft(hash + (buffer.get() & 0xff) * PRIME5, 11) * PRIME1;\n+            idx++;\n+        }\n+\n+        hash ^= hash >>> 15;\n+        hash *= PRIME2;\n+        hash ^= hash >>> 13;\n+        hash *= PRIME3;\n+        hash ^= hash >>> 16;\n+        return hash & 0xffffffffl;\n+    }\n+\n+    private void initializeState() {\n+        state[0] = seed + PRIME1 + PRIME2;\n+        state[1] = seed + PRIME2;\n+        state[2] = seed;\n+        state[3] = seed - PRIME1;\n+    }\n+\n+    private void process() {\n+        buffer.flip();\n+\n+        // local shadows for performance\n+        int s0 = state[0];\n+        int s1 = state[1];\n+        int s2 = state[2];\n+        int s3 = state[3];\n+\n+        s0 = rotateLeft(s0 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n+        s1 = rotateLeft(s1 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n+        s2 = rotateLeft(s2 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n+        s3 = rotateLeft(s3 + buffer.getInt() * PRIME2, ROTATE_BITS) * PRIME1;\n+\n+        state[0] = s0;\n+        state[1] = s1;\n+        state[2] = s2;\n+        state[3] = s3;\n+\n+        buffer.clear();\n+        pos = 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/XXHash32Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(Parameterized.class)\n+public class XXHash32Test {\n+\n+    private final File file;\n+    private final String expectedChecksum;\n+\n+    public XXHash32Test(String fileName, String c) throws IOException {\n+        file = AbstractTestCase.getFile(fileName);\n+        expectedChecksum = c;\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> factory() {\n+        return Arrays.asList(new Object[][] {\n+            // reference checksums created with xxh32sum\n+            { \"bla.tar\", \"fbb5c8d1\" },\n+            { \"bla.tar.xz\", \"4106a208\" },\n+            { \"8.posix.tar.gz\", \"9fce116a\" },\n+        });\n+    }\n+\n+    @Test\n+    public void verifyChecksum() throws IOException {\n+        XXHash32 h = new XXHash32();\n+        try (FileInputStream s = new FileInputStream(file)) {\n+            byte[] b = IOUtils.toByteArray(s);\n+            h.update(b, 0, b.length);\n+        }\n+        Assert.assertEquals(\"checksum for \" + file.getName(), expectedChecksum, Long.toHexString(h.getValue()));\n+    }\n+}", "timestamp": 1485287568, "metainfo": ""}