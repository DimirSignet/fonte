{"sha": "76b0184c7714cd5f580860daeb70c3a3808eb5f2", "log": "silence Java8's javadoc, add a few @since tags", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n  *  char xmagic[4];             // offset 508  \"tar\"\n  * };\n  * </pre>\n- * which is identical to new-style POSIX up to the first 130 bytes of the prefix.</p>\n+ * <p>which is identical to new-style POSIX up to the first 130 bytes of the prefix.</p>\n  *\n  * @NotThreadSafe\n  */\n     /**\n      * Check whether this is a sparse entry.\n      *\n+     * @return whether this is a sparse entry\n      * @since 1.11\n      */\n     public boolean isSparse() {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n  *\n  * <ul>\n  * <li>0x6601 - DES</li>\n- * <li>0x6602 - RC2 (version needed to extract < 5.2)</li>\n+ * <li>0x6602 - RC2 (version needed to extract &lt; 5.2)</li>\n  * <li>0x6603 - 3DES 168</li>\n  * <li>0x6609 - 3DES 112</li>\n  * <li>0x660E - AES 128</li>\n  * <li>0x660F - AES 192</li>\n  * <li>0x6610 - AES 256</li>\n- * <li>0x6702 - RC2 (version needed to extract >= 5.2)</li>\n+ * <li>0x6702 - RC2 (version needed to extract &gt;= 5.2)</li>\n  * <li>0x6720 - Blowfish</li>\n  * <li>0x6721 - Twofish</li>\n  * <li>0x6801 - RC4</li>\n  * <li>0x800D - SHA384</li>\n  * <li>0x800E - SHA512</li>\n  * </ul>\n+ *\n+ * @since 1.11\n  */\n public abstract class PKWareExtraHeader implements ZipExtraField {\n \n     /**\n      * Encryption algorithm.\n+     *\n+     * @since 1.11\n      */\n     public enum EncryptionAlgorithm {\n         DES(0x6601),\n         }\n \n         /**\n-         * returns the EncryptionAlgorithm for the given code or null if the\n+         * Returns the EncryptionAlgorithm for the given code or null if the\n          * method is not known.\n+         * @param code the code of the algorithm\n+         * @return the EncryptionAlgorithm for the given code or null\n+         * if the method is not known\n          */\n         public static EncryptionAlgorithm getAlgorithmByCode(int code) {\n             return codeToEnum.get(Integer.valueOf(code));\n \n     /**\n      * Hash Algorithm\n+     *\n+     * @since 1.11\n      */\n     public enum HashAlgorithm {\n         NONE(0),\n         }\n \n         /**\n-         * returns the HashAlgorithm for the given code or null if the method is\n+         * Returns the HashAlgorithm for the given code or null if the method is\n          * not known.\n+         * @param code the code of the algorithm\n+         * @return the HashAlgorithm for the given code or null\n+         * if the method is not known\n          */\n         public static HashAlgorithm getAlgorithmByCode(int code) {\n             return codeToEnum.get(Integer.valueOf(code));\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n  *          Atime      8 bytes    File last access time\n  *          Ctime      8 bytes    File creation time\n  * </pre>\n+ *\n+ * @since 1.11\n+ * @NotThreadSafe\n  */\n public class X000A_NTFS implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x000a);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0014_X509Certificates.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0014_X509Certificates.java\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * PKCS#7 Store for X.509 Certificates (0x0014):\n+ * PKCS#7 Store for X.509 Certificates (0x0014).\n  *\n- * This field MUST contain information about each of the certificates files may\n+ * <p>This field MUST contain information about each of the certificates files may\n  * be signed with. When the Central Directory Encryption feature is enabled for\n  * a ZIP file, this record will appear in the Archive Extra Data Record,\n  * otherwise it will appear in the first central directory record and will be\n- * ignored in any other record.\n+ * ignored in any other record.</p>\n  *\n- * Note: all fields stored in Intel low-byte/high-byte order.\n+ * <p>Note: all fields stored in Intel low-byte/high-byte order.</p>\n  *\n  * <pre>\n  *         Value     Size     Description\n  * </pre>\n  *\n  * @NotThreadSafe\n+ * @since 1.11\n  */\n public class X0014_X509Certificates extends PKWareExtraHeader implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x0014);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * X.509 Certificate ID and Signature for individual file (0x0015):\n+ * X.509 Certificate ID and Signature for individual file (0x0015).\n  *\n- * This field contains the information about which certificate in the PKCS#7\n+ * <p>This field contains the information about which certificate in the PKCS#7\n  * store was used to sign a particular file. It also contains the signature\n  * data. This field can appear multiple times, but can only appear once per\n- * certificate.\n+ * certificate.</p>\n  *\n- * Note: all fields stored in Intel low-byte/high-byte order.\n+ * <p>Note: all fields stored in Intel low-byte/high-byte order.</p>\n  *\n  * <pre>\n  *         Value     Size     Description\n  * </pre>\n  *\n  * @NotThreadSafe\n+ * @since 1.11\n  */\n public class X0015_CertificateIdForFile extends PKWareExtraHeader implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x0015);\n \n     /**\n      * Get record count.\n-     * @return\n+     * @return the record count\n      */\n     public int getRecordCount() {\n         return rcount;\n \n     /**\n      * Get hash algorithm.\n-     * @return\n+     * @return the hash algorithm\n      */\n     public HashAlgorithm getHashAlgorithm() {\n         return hashAlg;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * X.509 Certificate ID and Signature for central directory (0x0016):\n+ * X.509 Certificate ID and Signature for central directory (0x0016).\n  *\n- * This field contains the information about which certificate in the PKCS#7\n+ * <p>This field contains the information about which certificate in the PKCS#7\n  * store was used to sign the central directory structure. When the Central\n  * Directory Encryption feature is enabled for a ZIP file, this record will\n  * appear in the Archive Extra Data Record, otherwise it will appear in the\n- * first central directory record.\n+ * first central directory record.</p>\n  *\n- * Note: all fields stored in Intel low-byte/high-byte order.\n+ * <p>Note: all fields stored in Intel low-byte/high-byte order.</p>\n  *\n  * <pre>\n  *         Value     Size     Description\n  * </pre>\n  *\n  * @NotThreadSafe\n+ * @since 1.11\n  */\n public class X0016_CertificateIdForCentralDirectory extends PKWareExtraHeader implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x0016);\n \n     /**\n      * Get record count.\n-     * @return\n+     * @return the record count\n      */\n     public int getRecordCount() {\n         return rcount;\n \n     /**\n      * Get hash algorithm.\n-     * @return\n+     * @return the hash algorithm\n      */\n     public HashAlgorithm getHashAlgorithm() {\n         return hashAlg;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * Strong Encryption Header (0x0017)\n- *\n- * Certificate-based encryption:\n+ * Strong Encryption Header (0x0017).\n+ *\n+ * <p>Certificate-based encryption:</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  * SRList    (var)    Simple list of recipients hashed public keys\n  *\n  * Flags -   This defines the processing flags.\n+ * </pre>\n  *\n  *           <ul>\n  *           <li>0x0007 - reserved for future use\n  *           <li>0x8000 - reserved for future use\n  *           </ul>\n  *\n+ * <pre>\n  * RCount - This defines the number intended recipients whose\n  *          public keys were used for encryption.  This identifies\n  *          the number of elements in the SRList.\n  *           SRList is determined using RCount * HSize.\n  * </pre>\n  *\n- * Password-based Extra Field 0x0017 in central header only.\n+ * <p>Password-based Extra Field 0x0017 in central header only.</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  * (more?)\n  * </pre>\n  *\n- * <b>Format</b> - the data format identifier for this record. The only value\n- * allowed at this time is the integer value 2.\n- *\n- * Password-based Extra Field 0x0017 preceding compressed file data.\n+ * <p><b>Format</b> - the data format identifier for this record. The only value\n+ * allowed at this time is the integer value 2.</p>\n+ *\n+ * <p>Password-based Extra Field 0x0017 preceding compressed file data.</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  *         stream of encrypted data for a file.\n  * </pre>\n  *\n- *\n- * Reserved1 - Certificate Decryption Header Reserved1 Data:\n+ * <p>Reserved1 - Certificate Decryption Header Reserved1 Data:</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  * RCount    4 bytes  Number of recipients.\n  * </pre>\n  *\n- * RCount - This defines the number intended recipients whose public keys were\n+ * <p>RCount - This defines the number intended recipients whose public keys were\n  * used for encryption. This defines the number of elements in the REList field\n- * defined below.\n- *\n- *\n- * Reserved2 - Certificate Decryption Header Reserved2 Data Structures:\n+ * defined below.</p>\n+ *\n+ * <p>Reserved2 - Certificate Decryption Header Reserved2 Data Structures:</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  *           Element data structure as follows:\n  * </pre>\n  *\n- * Recipient Element (REList) Data Structure:\n+ * <p>Recipient Element (REList) Data Structure:</p>\n  *\n  * <pre>\n  * Value     Size     Description\n  *           For more details see https://msdn.microsoft.com/en-us/library/aa920051.aspx\n  * </pre>\n  *\n- * <b>Flags</b> - Processing flags needed for decryption\n+ * <p><b>Flags</b> - Processing flags needed for decryption</p>\n  *\n  * <ul>\n  * <li>0x0001 - Password is required to decrypt</li>\n  * <li>0x8000 - reserved for future use.\n  * </ul>\n  *\n- * <b>See the section describing the Strong Encryption Specification for\n+ * <p><b>See the section describing the Strong Encryption Specification for\n  * details. Refer to the section in this document entitled\n  * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n- * information.</b>\n+ * information.</b></p>\n  *\n  * @NotThreadSafe\n+ * @since 1.11\n  */\n public class X0017_StrongEncryptionHeader extends PKWareExtraHeader implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x0017);\n \n     /**\n      * Get record count.\n-     * @return\n+     * @return the record count\n      */\n     public long getRecordCount() {\n         return rcount;\n \n     /**\n      * Get hash algorithm.\n-     * @return\n+     * @return the hash algorithm\n      */\n     public HashAlgorithm getHashAlgorithm() {\n         return hashAlg;\n \n     /**\n      * Get encryption algorithm.\n-     * @return\n+     * @return the encryption algorithm\n      */\n     public EncryptionAlgorithm getEncryptionAlgorithm() {\n         return algId;\n     /**\n      * Parse central directory format.\n      *\n-     * @param data\n-     * @param offset\n-     * @param length\n+     * @param data the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n      */\n     public void parseCentralDirectoryFormat(byte[] data, int offset, int length) {\n         this.format = ZipShort.getValue(data, offset);\n     }\n \n     /**\n-     * Parse file header format. (Password only?)\n-     *\n-     * @param data\n-     * @param offset\n-     * @param length\n+     * Parse file header format.\n+     *\n+     * <p>(Password only?)</p>\n+     *\n+     * @param data the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n      */\n     public void parseFileFormat(byte[] data, int offset, int length) {\n         int ivSize = ZipShort.getValue(data, offset);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0019_EncryptionRecipientCertificateList.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0019_EncryptionRecipientCertificateList.java\n package org.apache.commons.compress.archivers.zip;\n \n /**\n- * PKCS#7 Encryption Recipient Certificate List (0x0019)\n+ * PKCS#7 Encryption Recipient Certificate List (0x0019).\n  *\n- * This field MAY contain information about each of the certificates used in\n+ * <p>This field MAY contain information about each of the certificates used in\n  * encryption processing and it can be used to identify who is allowed to\n  * decrypt encrypted files. This field should only appear in the archive extra\n  * data record. This field is not required and serves only to aid archive\n  * modifications by preserving public encryption key data. Individual security\n  * requirements may dictate that this data be omitted to deter information\n- * exposure.\n+ * exposure.</p>\n  *\n- * Note: all fields stored in Intel low-byte/high-byte order.\n+ * <p>Note: all fields stored in Intel low-byte/high-byte order.</p>\n  *\n  * <pre>\n  *          Value     Size     Description\n  *          CStore    (var)    PKCS#7 data blob\n  * </pre>\n  *\n- * <b>See the section describing the Strong Encryption Specification for\n+ * <p><b>See the section describing the Strong Encryption Specification for\n  * details. Refer to the section in this document entitled\n  * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n- * information.</b>\n+ * information.</b></p>\n  *\n  * @NotThreadSafe\n+ * @since 1.11\n  */\n public class X0019_EncryptionRecipientCertificateList extends PKWareExtraHeader implements ZipExtraField {\n     private static final ZipShort HEADER_ID = new ZipShort(0x0019);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     }\n \n     /**\n-     * Wraps {@link ZipEntry#getTime} with a {@link Date} as the\n+     * Wraps {@link java.util.zip.ZipEntry#getTime} with a {@link Date} as the\n      * entry's last modified date.\n      *\n-     * <p>Changes to the implementation of {@link ZipEntry#getTime}\n+     * <p>Changes to the implementation of {@link java.util.zip.ZipEntry#getTime}\n      * leak through and the returned value may depend on your local\n      * time zone as well as your version of Java.</p>\n      */\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n     }\n \n     /**\n-     * Expose the raw stream of the archive entry (compressed form)\n-     * <p/>\n-     * This method does not relate to how/if we understand the payload in the\n-     * stream, since we really only intend to move it on to somewhere else.\n+     * Expose the raw stream of the archive entry (compressed form).\n+     *\n+     * <p>This method does not relate to how/if we understand the payload in the\n+     * stream, since we really only intend to move it on to somewhere else.</p>\n      *\n      * @param ze The entry to get the stream for\n      * @return The raw input stream containing (possibly) compressed data.\n+     * @since 1.11\n      */\n     public InputStream getRawInputStream(ZipArchiveEntry ze) {\n         if (!(ze instanceof Entry)) {\n     /**\n      * Transfer selected entries from this zipfile to a given #ZipArchiveOutputStream.\n      * Compression and all other attributes will be as in this file.\n-     * This method transfers entries based on the central directory of the zip file.\n+     * <p>This method transfers entries based on the central directory of the zip file.</p>\n      *\n      * @param target The zipArchiveOutputStream to write the entries to\n      * @param predicate A predicate that selects which entries to write\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n \n     /**\n      * Returns the blocksize parameter specified at construction time.\n+     * @return the blocksize parameter specified at construction time\n      */\n     public final int getBlockSize() {\n         return this.blockSize100k;\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n \n     /**\n      * Finishes compression without closing the underlying stream.\n-     * No more data can be written to this stream after finishing.\n+     * <p>No more data can be written to this stream after finishing.</p>\n+     * @throws IOException on error\n      */\n     public void finish() throws IOException {\n         out.finish();\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\n     /**\n      * Whether or not the zlib header shall be written (when\n      * compressing) or expected (when decompressing).\n+     * @return true if zlib header shall be written\n      */\n     public boolean withZlibHeader() {\n         return zlibHeader;\n      * <p>This affects whether or not the zlib header will be written\n      * (when compressing) or expected (when decompressing).</p>\n      *\n-     * @param zlibHeader\n+     * @param zlibHeader true if zlib header shall be written\n      */\n     public void setWithZlibHeader(boolean zlibHeader) {\n         this.zlibHeader = zlibHeader;\n     /**\n      * The compression level.\n      * @see #setCompressionLevel\n+     * @return the compression level\n      */\n     public int getCompressionLevel() {\n         return compressionLevel;\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n \n     /**\n      * Creates a gzip compressed output stream with the default parameters.\n+     * @param out the stream to compress to\n+     * @throws IOException if writing fails\n      */\n     public GzipCompressorOutputStream(OutputStream out) throws IOException {\n         this(out, new GzipParameters());\n \n     /**\n      * Creates a gzip compressed output stream with the specified parameters.\n+     * @param out the stream to compress to\n+     * @param parameters the parameters to use\n+     * @throws IOException if writing fails\n      * \n      * @since 1.7\n      */\n      * Finishes writing compressed data to the underlying stream without closing it.\n      * \n      * @since 1.7\n+     * @throws IOException on error\n      */\n     public void finish() throws IOException {\n         if (!deflater.finished()) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n \n     /**\n      * Are the classes required to support LZMA compression available?\n+     * @return true if the classes required to support LZMA\n+     * compression are available\n      */\n     public static boolean isLZMACompressionAvailable() {\n         final CachedAvailability cachedResult = cachedLZMAAvailability;\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n \n     /**\n      * Read the next code and expand it.\n+     * @return the expanded next code\n+     * @throws IOException on error\n      */\n     protected abstract int decompressNextSymbol() throws IOException;\n \n     /**\n      * Add a new entry to the dictionary.\n+     * @param previousCode the previous code\n+     * @param character the next character to append\n+     * @return the new code\n+     * @throws IOException on error\n      */\n     protected abstract int addEntry(int previousCode, byte character)\n         throws IOException;\n \n     /**\n      * Sets the clear code based on the code size.\n+     * @param codeSize code size\n      */\n     protected void setClearCode(int codeSize) {\n         clearCode = (1 << (codeSize - 1));\n \n     /**\n      * Initializes the arrays based on the maximum code size.\n+     * @param maxCodeSize maximum code size\n      */\n     protected void initializeTables(int maxCodeSize) {\n         final int maxTableSize = 1 << maxCodeSize;\n \n     /**\n      * Reads the next code from the stream.\n+     * @return the next code\n+     * @throws IOException on error\n      */\n     protected int readNextCode() throws IOException {\n         if (codeSize > 31) {\n     /**\n      * Adds a new entry if the maximum table size hasn't been exceeded\n      * and returns the new index.\n+     * @param previousCode the previous code\n+     * @param character the character to append\n+     * @param maxTableSize the maximum table size\n+     * @return the new code\n      */\n     protected int addEntry(int previousCode, byte character, int maxTableSize) {\n         if (tableSize < maxTableSize) {\n \n     /**\n      * Add entry for repeat of previousCode we haven't added, yet.\n+     * @return new code for a repeat of the previous code\n+     * @throws IOException on error\n      */\n     protected int addRepeatOfPreviousCode() throws IOException {\n         if (previousCode == -1) {\n     /**\n      * Expands the entry with index code to the output stack and may\n      * create a new entry\n+     * @param code the code\n+     * @param addedUnfinishedEntry whether unfinished entries have been added\n+     * @return the new location of the output stack\n+     * @throws IOException on error\n      */\n     protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry)\n         throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n      * provide better performance.</p>\n      *\n      * @param in the InputStream from which this object should be created\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final InputStream in)\n         throws IOException {\n      *\n      * @param in the InputStream from which this object should be created\n      * @param mode the strategy to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Pack200Strategy mode)\n      *\n      * @param in the InputStream from which this object should be created\n      * @param props Pack200 properties to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Map<String, String> props)\n      * @param in the InputStream from which this object should be created\n      * @param mode the strategy to use\n      * @param props Pack200 properties to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final InputStream in,\n                                         final Pack200Strategy mode,\n      * memory.\n      *\n      * @param f the file to decompress\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final File f) throws IOException {\n         this(f, Pack200Strategy.IN_MEMORY);\n      *\n      * @param f the file to decompress\n      * @param mode the strategy to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final File f, final Pack200Strategy mode)\n         throws IOException {\n      *\n      * @param f the file to decompress\n      * @param props Pack200 properties to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final File f,\n                                         final Map<String, String> props)\n      * @param f the file to decompress\n      * @param mode the strategy to use\n      * @param props Pack200 properties to use\n+     * @throws IOException if reading fails\n      */\n     public Pack200CompressorInputStream(final File f, final Pack200Strategy mode,\n                                         final Map<String, String> props)\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n      * memory.\n      *\n      * @param out the stream to write to\n+     * @throws IOException if writing fails\n      */\n     public Pack200CompressorOutputStream(final OutputStream out)\n         throws IOException {\n      *\n      * @param out the stream to write to\n      * @param mode the strategy to use\n+     * @throws IOException if writing fails\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Pack200Strategy mode)\n      *\n      * @param out the stream to write to\n      * @param props Pack200 properties to use\n+     * @throws IOException if writing fails\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Map<String, String> props)\n      * @param out the stream to write to\n      * @param mode the strategy to use\n      * @param props Pack200 properties to use\n+     * @throws IOException if writing fails\n      */\n     public Pack200CompressorOutputStream(final OutputStream out,\n                                          final Pack200Strategy mode,\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n      * -1.</p>\n      *\n      * @param jar the JAR archive to normalize\n+     * @throws IOException if reading or writing fails\n      */\n     public static void normalize(File jar)\n         throws IOException {\n      * @param jar the JAR archive to normalize\n      * @param props properties to set for the pack operation.  This\n      * method will implicitly set the segment limit to -1.\n+     * @throws IOException if reading or writing fails\n      */\n     public static void normalize(File jar, Map<String, String> props)\n         throws IOException {\n      *\n      * @param from the JAR archive to normalize\n      * @param to the normalized archive\n+     * @throws IOException if reading or writing fails\n      */\n     public static void normalize(File from, File to)\n         throws IOException {\n      * @param to the normalized archive\n      * @param props properties to set for the pack operation.  This\n      * method will implicitly set the segment limit to -1.\n+     * @throws IOException if reading or writing fails\n      */\n     public static void normalize(File from, File to, Map<String, String> props)\n         throws IOException {\n             f.delete();\n         }\n     }\n-}\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n      * Constructs a new input stream that decompresses snappy-framed-compressed data\n      * from the specified input stream.\n      * @param in  the InputStream from which to read the compressed data\n+     * @throws IOException if reading fails\n      */\n     public FramedSnappyCompressorInputStream(InputStream in) throws IOException {\n         this.in = new PushbackInputStream(in, 1);\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n      * @param is\n      *            An InputStream to read compressed data from\n      * \n-     * @throws IOException\n+     * @throws IOException if reading fails\n      */\n     public SnappyCompressorInputStream(final InputStream is) throws IOException {\n         this(is, DEFAULT_BLOCK_SIZE);\n      * @param blockSize\n      *            The block size used in compression\n      * \n-     * @throws IOException\n+     * @throws IOException if reading fails\n      */\n     public SnappyCompressorInputStream(final InputStream is, final int blockSize)\n             throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n     /**\n      * Finishes compression without closing the underlying stream.\n      * No more data can be written to this stream after finishing.\n+     * @throws IOException on error\n      */\n     public void finish() throws IOException {\n         out.finish();\n--- a/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStore.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStore.java\n \n     /**\n      * Closes this backing store for further writing.\n+     * @throws IOException when something fails\n      */\n     void closeForWriting() throws IOException;\n }\n--- a/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStoreSupplier.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStoreSupplier.java\n      * Create a ScatterGatherBackingStore.\n      *\n      * @return a ScatterGatherBackingStore, not null\n+     * @throws IOException when something fails\n      */\n     ScatterGatherBackingStore get() throws IOException;\n }", "timestamp": 1458917089, "metainfo": ""}