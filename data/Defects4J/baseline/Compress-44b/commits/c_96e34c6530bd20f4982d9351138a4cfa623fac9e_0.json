{"sha": "96e34c6530bd20f4982d9351138a4cfa623fac9e", "log": "BZip2CompressorInputStream: Use BitInputStream.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.BitInputStream;\n \n /**\n  * An input stream that decompresses from the BZip2 format to be read as any other stream.\n \n     private boolean blockRandomised;\n \n-    private int bsBuff;\n-    private int bsLive;\n     private final CRC crc = new CRC();\n \n     private int nInUse;\n \n-    private InputStream in;\n+    private BitInputStream bin;\n     private final boolean decompressConcatenated;\n \n     private static final int EOF = 0;\n      *             if {@code in == null}, the stream content is malformed, or an I/O error occurs.\n      */\n     public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n-        this.in = in;\n+        this.bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN);\n         this.decompressConcatenated = decompressConcatenated;\n \n         init(true);\n \n     @Override\n     public int read() throws IOException {\n-        if (this.in != null) {\n+        if (this.bin != null) {\n             final int r = read0();\n             count(r < 0 ? -1 : 1);\n             return r;\n             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                 + len + \") > dest.length(\" + dest.length + \").\");\n         }\n-        if (this.in == null) {\n+        if (this.bin == null) {\n             throw new IOException(\"stream closed\");\n         }\n         if (len == 0) {\n         }\n     }\n \n+    private int readNextByte(BitInputStream in) throws IOException {\n+        long b = in.readBits(8);\n+        return (int) b;\n+    }\n+\n     private boolean init(final boolean isFirstStream) throws IOException {\n-        if (null == in) {\n+        if (null == bin) {\n             throw new IOException(\"No InputStream\");\n         }\n \n-        final int magic0 = this.in.read();\n+        if(!isFirstStream) {\n+            bin.clearBitCache();\n+        }\n+\n+        final int magic0 = readNextByte(this.bin);\n         if (magic0 == -1 && !isFirstStream) {\n             return false;\n         }\n-        final int magic1 = this.in.read();\n-        final int magic2 = this.in.read();\n+        final int magic1 = readNextByte(this.bin);\n+        final int magic2 = readNextByte(this.bin);\n \n         if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\n             throw new IOException(isFirstStream\n                     : \"Garbage after a valid BZip2 stream\");\n         }\n \n-        final int blockSize = this.in.read();\n+        final int blockSize = readNextByte(this.bin);\n         if ((blockSize < '1') || (blockSize > '9')) {\n             throw new IOException(\"BZip2 block size is invalid\");\n         }\n \n         this.blockSize100k = blockSize - '0';\n \n-        this.bsLive = 0;\n         this.computedCombinedCRC = 0;\n \n         return true;\n \n     @Override\n     public void close() throws IOException {\n-        final InputStream inShadow = this.in;\n+        final BitInputStream inShadow = this.bin;\n         if (inShadow != null) {\n             try {\n-                if (inShadow != System.in) {\n-                    inShadow.close();\n-                }\n+//                if (inShadow != System.in) {\n+//                    inShadow.close();\n+//                }\n             } finally {\n                 this.data = null;\n-                this.in = null;\n-            }\n-        }\n-    }\n-\n+                this.bin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * read bits from the input stream\n+     * @param n the number of bits to read, must not exceed 32?\n+     * @return\n+     * @throws IOException\n+     */\n     private int bsR(final int n) throws IOException {\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-\n-        if (bsLiveShadow < n) {\n-            final InputStream inShadow = this.in;\n-            do {\n-                final int thech = inShadow.read();\n-\n-                if (thech < 0) {\n-                    throw new IOException(\"unexpected end of stream\");\n-                }\n-\n-                bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                bsLiveShadow += 8;\n-            } while (bsLiveShadow < n);\n-\n-            this.bsBuff = bsBuffShadow;\n-        }\n-\n-        this.bsLive = bsLiveShadow - n;\n-        return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n+        long thech = bin.readBits(n);\n+        if (thech < 0) {\n+            throw new IOException(\"unexpected end of stream\");\n+        }\n+        return (int) thech;\n     }\n \n     private boolean bsGetBit() throws IOException {\n     }\n \n     private int bsGetInt() throws IOException {\n-        return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n+        return (int) bsR(32);\n     }\n \n     /**\n             }\n         }\n \n-        for (int i = 256; --i >= 0;) {\n-            inUse[i] = false;\n-        }\n-\n+        Arrays.fill(inUse, false);\n         for (int i = 0; i < 16; i++) {\n             if ((inUse16 & (1 << i)) != 0) {\n                 final int i16 = i << 4;\n         this.origPtr = bsR(24);\n         recvDecodingTables();\n \n-        final InputStream inShadow = this.in;\n         final Data dataShadow = this.data;\n         final byte[] ll8 = dataShadow.ll8;\n         final int[] unzftab = dataShadow.unzftab;\n         int groupPos = G_SIZE - 1;\n         final int eob = this.nInUse + 1;\n         int nextSym = getAndMoveToFrontDecode0(0);\n-        int bsBuffShadow = this.bsBuff;\n-        int bsLiveShadow = this.bsLive;\n         int lastShadow = -1;\n         int zt = selector[groupNo] & 0xff;\n         int[] base_zt = base[zt];\n                     }\n \n                     int zn = minLens_zt;\n-\n-                    // Inlined:\n-                    // int zvec = bsR(zn);\n-                    while (bsLiveShadow < zn) {\n-                        final int thech = inShadow.read();\n-                        if (thech >= 0) {\n-                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                            bsLiveShadow += 8;\n-                            continue;\n-                        }\n-                        throw new IOException(\"unexpected end of stream\");\n-                    }\n-                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n-                        & ((1 << zn) - 1);\n-                    bsLiveShadow -= zn;\n-\n-                    while (zvec > limit_zt[zn]) {\n+                    int zvec = (int) bsR(zn);\n+                    while(zvec > limit_zt[zn]) {\n                         zn++;\n-                        while (bsLiveShadow < 1) {\n-                            final int thech = inShadow.read();\n-                            if (thech >= 0) {\n-                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                                bsLiveShadow += 8;\n-                                continue;\n-                            }\n-                            throw new IOException(\n-                                                  \"unexpected end of stream\");\n-                        }\n-                        bsLiveShadow--;\n-                        zvec = (zvec << 1)\n-                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                        zvec = (zvec << 1) | bsR(1);\n                     }\n                     nextSym = perm_zt[zvec - base_zt[zn]];\n                 }\n                 }\n \n                 int zn = minLens_zt;\n-\n-                // Inlined:\n-                // int zvec = bsR(zn);\n-                while (bsLiveShadow < zn) {\n-                    final int thech = inShadow.read();\n-                    if (thech >= 0) {\n-                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                        bsLiveShadow += 8;\n-                        continue;\n-                    }\n-                    throw new IOException(\"unexpected end of stream\");\n-                }\n-                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n-                    & ((1 << zn) - 1);\n-                bsLiveShadow -= zn;\n-\n-                while (zvec > limit_zt[zn]) {\n+                int zvec = (int) bsR(zn);\n+                while(zvec > limit_zt[zn]) {\n                     zn++;\n-                    while (bsLiveShadow < 1) {\n-                        final int thech = inShadow.read();\n-                        if (thech >= 0) {\n-                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                            bsLiveShadow += 8;\n-                            continue;\n-                        }\n-                        throw new IOException(\"unexpected end of stream\");\n-                    }\n-                    bsLiveShadow--;\n-                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                    zvec = (zvec << 1) | (int) bsR(1);\n                 }\n                 nextSym = perm_zt[zvec - base_zt[zn]];\n             }\n         }\n \n         this.last = lastShadow;\n-        this.bsLive = bsLiveShadow;\n-        this.bsBuff = bsBuffShadow;\n     }\n \n     private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\n-        final InputStream inShadow = this.in;\n         final Data dataShadow = this.data;\n         final int zt = dataShadow.selector[groupNo] & 0xff;\n         final int[] limit_zt = dataShadow.limit[zt];\n         int zn = dataShadow.minLens[zt];\n         int zvec = bsR(zn);\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-\n         while (zvec > limit_zt[zn]) {\n             zn++;\n-            while (bsLiveShadow < 1) {\n-                final int thech = inShadow.read();\n-\n-                if (thech >= 0) {\n-                    bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                    bsLiveShadow += 8;\n-                    continue;\n-                }\n-                throw new IOException(\"unexpected end of stream\");\n-            }\n-            bsLiveShadow--;\n-            zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n-        }\n-\n-        this.bsLive = bsLiveShadow;\n-        this.bsBuff = bsBuffShadow;\n+            zvec = (zvec << 1) | (int) bsR(1);\n+        }\n \n         return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n     }", "timestamp": 1486231019, "metainfo": ""}