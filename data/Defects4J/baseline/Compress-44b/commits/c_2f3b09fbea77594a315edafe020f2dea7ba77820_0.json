{"sha": "2f3b09fbea77594a315edafe020f2dea7ba77820", "log": "add a test that verifies ZipArchiveOutputStream now creates a ZIP64 extension extra field if the offset of a LFH exceeds 4GB.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         writeOut(CFH_SIG);\n         written += WORD;\n \n-        // version made by\n-        // CheckStyle:MagicNumber OFF\n-        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n-                                   (!hasUsedZip64 ? DEFLATE_MIN_VERSION\n-                                                  : ZIP64_MIN_VERSION)));\n-        written += SHORT;\n-\n-        final int zipMethod = ze.getMethod();\n-        final boolean encodable = zipEncoding.canEncode(ze.getName());\n-\n         final long lfhOffset = offsets.get(ze).longValue();\n         final boolean needsZip64Extra = ze.getCompressedSize() >= ZIP64_MAGIC\n             || ze.getSize() >= ZIP64_MAGIC\n             ze.setExtra();\n         }\n \n+        // version made by\n+        // CheckStyle:MagicNumber OFF\n+        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n+                                   (!hasUsedZip64 ? DEFLATE_MIN_VERSION\n+                                                  : ZIP64_MIN_VERSION)));\n+        written += SHORT;\n+\n+        final int zipMethod = ze.getMethod();\n+        final boolean encodable = zipEncoding.canEncode(ze.getName());\n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n                                                          && fallbackToUTF8,\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n             });\n     }\n \n+    /*\n+     * Individual sizes don't require ZIP64 but the offset of the\n+     * third entry is bigger than 0xFFFFFFFF so a ZIP64 extended\n+     * information is needed inside the central directory.\n+     *\n+     * Creates a temporary archive of approx 5GB in size\n+     */ \n+    @Test public void write3EntriesCreatingBigArchive() throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchive\",\n+                             new ZipOutputTest() {\n+                public void test(File f, ZipArchiveOutputStream zos)\n+                    throws IOException {\n+                    byte[] buf = new byte[1000 * 1000];\n+                    ZipArchiveEntry zae = null;\n+                    for (int i = 0; i < 2; i++) {\n+                        zae = new ZipArchiveEntry(String.valueOf(i));\n+                        zae.setSize(FIVE_BILLION / 2);\n+                        zae.setMethod(ZipArchiveEntry.STORED);\n+                        zae.setCrc(0);\n+                        zos.putArchiveEntry(zae);\n+                        for (int j = 0; j < FIVE_BILLION / 2 / 1000 / 1000;\n+                             j++) {\n+                            zos.write(buf);\n+                        }\n+                        zos.closeArchiveEntry();\n+                    }\n+                    zae = new ZipArchiveEntry(String.valueOf(2));\n+                    zae.setSize(0);\n+                    zos.putArchiveEntry(zae);\n+                    zos.closeArchiveEntry();\n+                    zos.close();\n+\n+                    RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                    try {\n+                        final long end = a.length();\n+                        long cdOffsetLoc = end - 22 /* eocd.length */\n+                            - 20 /* z64 eocd locator.length */\n+                            - 56 /* z64 eocd without extensible data sector */\n+                            + 48 /* position in z64 eocd */;\n+                        // seek to central directory\n+                        a.seek(cdOffsetLoc);\n+                        byte[] cdOffset = new byte[8];\n+                        a.readFully(cdOffset);\n+                        a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+                        // skip first two entries\n+                        a.skipBytes(2 * 47 /* CD entry of file with\n+                                              file name length 1 and no\n+                                              extra data */);\n+\n+                        // grab third entry, verify offset is\n+                        // 0xFFFFFFFF and it has a ZIP64 extended\n+                        // information extra field\n+                        byte[] header = new byte[8];\n+                        a.readFully(header);\n+                        assertArrayEquals(new byte[] {\n+                                // sig\n+                                (byte) 0x50, (byte) 0x4b, 1, 2,\n+                                // version made by\n+                                45, 0,\n+                                // version needed to extract\n+                                45, 0,\n+                            }, header);\n+                        // ignore GPB, method, timestamp, CRC, compressed size\n+                        a.skipBytes(16);\n+                        byte[] rest = new byte[23];\n+                        a.readFully(rest);\n+                        assertArrayEquals(new byte[] {\n+                                // Original Size\n+                                0, 0, 0, 0,\n+                                // file name length\n+                                1, 0,\n+                                // extra field length\n+                                12, 0,\n+                                // comment length\n+                                0, 0,\n+                                // disk number\n+                                0, 0,\n+                                // attributes\n+                                0, 0,\n+                                0, 0, 0, 0,\n+                                // offset\n+                                (byte) 0xFF, (byte) 0xFF,\n+                                (byte) 0xFF, (byte) 0xFF,\n+                                // file name\n+                                (byte) '2'\n+                            }, rest);\n+                        byte[] extra = new byte[4];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size\n+                                8, 0\n+                            }, extra);\n+\n+                        // read offset of LFH\n+                        byte[] offset = new byte[8];\n+                        a.readFully(offset);\n+                        // verify there is a LFH where the CD claims it\n+                        a.seek(ZipEightByteInteger.getLongValue(offset));\n+                        byte[] sig = new byte[4];\n+                        a.readFully(sig);\n+                        assertArrayEquals(new byte[] {\n+                                (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            }, sig);\n+                    } finally {\n+                        a.close();\n+                    }\n+                }\n+\n+            });\n+    }\n+\n     static interface ZipOutputTest {\n         void test(File f, ZipArchiveOutputStream zos) throws IOException;\n     }\n         } finally {\n             zos.close();\n         }\n+        f.delete();\n     }\n \n     private static File getFile(String name) throws Throwable {", "timestamp": 1311957635, "metainfo": ""}