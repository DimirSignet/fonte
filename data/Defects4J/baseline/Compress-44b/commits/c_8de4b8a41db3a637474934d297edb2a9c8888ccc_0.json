{"sha": "8de4b8a41db3a637474934d297edb2a9c8888ccc", "log": "line-ends", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n-/*\n- *  Licensed to the Apache Software Foundation (ASF) under one or more\n- *  contributor license agreements.  See the NOTICE file distributed with\n- *  this work for additional information regarding copyright ownership.\n- *  The ASF licenses this file to You under the Apache License, Version 2.0\n- *  (the \"License\"); you may not use this file except in compliance with\n- *  the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- *\n- */\n-package org.apache.commons.compress.archivers.zip;\n-\n-import java.io.BufferedInputStream;\n-import java.io.Closeable;\n-import java.io.EOFException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.SeekableByteChannel;\n-import java.nio.file.Files;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.Enumeration;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.zip.Inflater;\n-import java.util.zip.InflaterInputStream;\n-import java.util.zip.ZipException;\n-\n-import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n-import org.apache.commons.compress.utils.IOUtils;\n-\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n-import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT;\n-\n-/**\n- * Replacement for <code>java.util.ZipFile</code>.\n- *\n- * <p>This class adds support for file name encodings other than UTF-8\n- * (which is required to work on ZIP files created by native zip tools\n- * and is able to skip a preamble like the one found in self\n- * extracting archives.  Furthermore it returns instances of\n- * <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n- * instead of <code>java.util.zip.ZipEntry</code>.</p>\n- *\n- * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n- * have to reimplement all methods anyway.  Like\n- * <code>java.util.ZipFile</code>, it uses SeekableByteChannel under the\n- * covers and supports compressed and uncompressed entries.  As of\n- * Apache Commons Compress 1.3 it also transparently supports Zip64\n- * extensions and thus individual entries and archives larger than 4\n- * GB or with more than 65536 entries.</p>\n- *\n- * <p>The method signatures mimic the ones of\n- * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n- *\n- * <ul>\n- *   <li>There is no getName method.</li>\n- *   <li>entries has been renamed to getEntries.</li>\n- *   <li>getEntries and getEntry return\n- *   <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n- *   instances.</li>\n- *   <li>close is allowed to throw IOException.</li>\n- * </ul>\n- *\n- */\n-public class ZipFile implements Closeable {\n-    private static final int HASH_SIZE = 509;\n-    static final int NIBLET_MASK = 0x0f;\n-    static final int BYTE_SHIFT = 8;\n-    private static final int POS_0 = 0;\n-    private static final int POS_1 = 1;\n-    private static final int POS_2 = 2;\n-    private static final int POS_3 = 3;\n-\n-    /**\n-     * List of entries in the order they appear inside the central\n-     * directory.\n-     */\n-    private final List<ZipArchiveEntry> entries =\n-        new LinkedList<>();\n-\n-    /**\n-     * Maps String to list of ZipArchiveEntrys, name -> actual entries.\n-     */\n-    private final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\n-        new HashMap<>(HASH_SIZE);\n-\n-    private static final class OffsetEntry {\n-        private long headerOffset = -1;\n-        private long dataOffset = -1;\n-    }\n-\n-    /**\n-     * The encoding to use for filenames and the file comment.\n-     *\n-     * <p>For a list of possible values see <a\n-     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n-     * Defaults to UTF-8.</p>\n-     */\n-    private final String encoding;\n-\n-    /**\n-     * The zip encoding to use for filenames and the file comment.\n-     */\n-    private final ZipEncoding zipEncoding;\n-\n-    /**\n-     * File name of actual source.\n-     */\n-    private final String archiveName;\n-\n-    /**\n-     * The actual data source.\n-     */\n-    private final SeekableByteChannel archive;\n-\n-    /**\n-     * Whether to look for and use Unicode extra fields.\n-     */\n-    private final boolean useUnicodeExtraFields;\n-\n-    /**\n-     * Whether the file is closed.\n-     */\n-    private volatile boolean closed = true;\n-\n-    // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n-    private final byte[] DWORD_BUF = new byte[DWORD];\n-    private final byte[] WORD_BUF = new byte[WORD];\n-    private final byte[] CFH_BUF = new byte[CFH_LEN];\n-    private final byte[] SHORT_BUF = new byte[SHORT];\n-    private final ByteBuffer DWORD_BBUF = ByteBuffer.wrap(DWORD_BUF);\n-    private final ByteBuffer WORD_BBUF = ByteBuffer.wrap(WORD_BUF);\n-    private final ByteBuffer CFH_BBUF = ByteBuffer.wrap(CFH_BUF);\n-    private final ByteBuffer SHORT_BBUF = ByteBuffer.wrap(SHORT_BUF);\n-\n-    /**\n-     * Opens the given file for reading, assuming \"UTF8\" for file names.\n-     *\n-     * @param f the archive.\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     */\n-    public ZipFile(final File f) throws IOException {\n-        this(f, ZipEncodingHelper.UTF8);\n-    }\n-\n-    /**\n-     * Opens the given file for reading, assuming \"UTF8\".\n-     *\n-     * @param name name of the archive.\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     */\n-    public ZipFile(final String name) throws IOException {\n-        this(new File(name), ZipEncodingHelper.UTF8);\n-    }\n-\n-    /**\n-     * Opens the given file for reading, assuming the specified\n-     * encoding for file names, scanning unicode extra fields.\n-     *\n-     * @param name name of the archive.\n-     * @param encoding the encoding to use for file names, use null\n-     * for the platform's default encoding\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     */\n-    public ZipFile(final String name, final String encoding) throws IOException {\n-        this(new File(name), encoding, true);\n-    }\n-\n-    /**\n-     * Opens the given file for reading, assuming the specified\n-     * encoding for file names and scanning for unicode extra fields.\n-     *\n-     * @param f the archive.\n-     * @param encoding the encoding to use for file names, use null\n-     * for the platform's default encoding\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     */\n-    public ZipFile(final File f, final String encoding) throws IOException {\n-        this(f, encoding, true);\n-    }\n-\n-    /**\n-     * Opens the given file for reading, assuming the specified\n-     * encoding for file names.\n-     *\n-     * @param f the archive.\n-     * @param encoding the encoding to use for file names, use null\n-     * for the platform's default encoding\n-     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n-     * Extra Fields (if present) to set the file names.\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     */\n-    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n-        throws IOException {\n-        this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n-             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n-    }\n-\n-    /**\n-     * Opens the given channel for reading, assuming \"UTF8\" for file names.\n-     *\n-     * <p>{@link\n-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n-     * allows you to read from an in-memory archive.</p>\n-     *\n-     * @param channel the archive.\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     * @since 1.13\n-     */\n-    public ZipFile(final SeekableByteChannel channel)\n-            throws IOException {\n-        this(channel, \"unknown archive\", ZipEncodingHelper.UTF8, true);\n-    }\n-\n-    /**\n-     * Opens the given channel for reading, assuming the specified\n-     * encoding for file names.\n-     *\n-     * <p>{@link\n-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n-     * allows you to read from an in-memory archive.</p>\n-     *\n-     * @param channel the archive.\n-     * @param encoding the encoding to use for file names, use null\n-     * for the platform's default encoding\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     * @since 1.13\n-     */\n-    public ZipFile(final SeekableByteChannel channel, final String encoding)\n-        throws IOException {\n-        this(channel, \"unknown archive\", encoding, true);\n-    }\n-\n-    /**\n-     * Opens the given channel for reading, assuming the specified\n-     * encoding for file names.\n-     *\n-     * <p>{@link\n-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n-     * allows you to read from an in-memory archive.</p>\n-     *\n-     * @param channel the archive.\n-     * @param archiveName name of the archive, used for error messages only.\n-     * @param encoding the encoding to use for file names, use null\n-     * for the platform's default encoding\n-     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n-     * Extra Fields (if present) to set the file names.\n-     *\n-     * @throws IOException if an error occurs while reading the file.\n-     * @since 1.13\n-     */\n-    public ZipFile(final SeekableByteChannel channel, final String archiveName,\n-                   final String encoding, final boolean useUnicodeExtraFields)\n-        throws IOException {\n-        this(channel, archiveName, encoding, useUnicodeExtraFields, false);\n-    }\n-\n-    private ZipFile(final SeekableByteChannel channel, final String archiveName,\n-                    final String encoding, final boolean useUnicodeExtraFields,\n-                    final boolean closeOnError)\n-        throws IOException {\n-        this.archiveName = archiveName;\n-        this.encoding = encoding;\n-        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n-        this.useUnicodeExtraFields = useUnicodeExtraFields;\n-        archive = channel;\n-        boolean success = false;\n-        try {\n-            final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n-                populateFromCentralDirectory();\n-            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n-            success = true;\n-        } finally {\n-            closed = !success;\n-            if (!success && closeOnError) {\n-                IOUtils.closeQuietly(archive);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The encoding to use for filenames and the file comment.\n-     *\n-     * @return null if using the platform's default character encoding.\n-     */\n-    public String getEncoding() {\n-        return encoding;\n-    }\n-\n-    /**\n-     * Closes the archive.\n-     * @throws IOException if an error occurs closing the archive.\n-     */\n-    @Override\n-    public void close() throws IOException {\n-        // this flag is only written here and read in finalize() which\n-        // can never be run in parallel.\n-        // no synchronization needed.\n-        closed = true;\n-\n-        archive.close();\n-    }\n-\n-    /**\n-     * close a zipfile quietly; throw no io fault, do nothing\n-     * on a null parameter\n-     * @param zipfile file to close, can be null\n-     */\n-    public static void closeQuietly(final ZipFile zipfile) {\n-        IOUtils.closeQuietly(zipfile);\n-    }\n-\n-    /**\n-     * Returns all entries.\n-     *\n-     * <p>Entries will be returned in the same order they appear\n-     * within the archive's central directory.</p>\n-     *\n-     * @return all entries as {@link ZipArchiveEntry} instances\n-     */\n-    public Enumeration<ZipArchiveEntry> getEntries() {\n-        return Collections.enumeration(entries);\n-    }\n-\n-    /**\n-     * Returns all entries in physical order.\n-     *\n-     * <p>Entries will be returned in the same order their contents\n-     * appear within the archive.</p>\n-     *\n-     * @return all entries as {@link ZipArchiveEntry} instances\n-     *\n-     * @since 1.1\n-     */\n-    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n-        final ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n-        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n-        return Collections.enumeration(Arrays.asList(allEntries));\n-    }\n-\n-    /**\n-     * Returns a named entry - or {@code null} if no entry by\n-     * that name exists.\n-     *\n-     * <p>If multiple entries with the same name exist the first entry\n-     * in the archive's central directory by that name is\n-     * returned.</p>\n-     *\n-     * @param name name of the entry.\n-     * @return the ZipArchiveEntry corresponding to the given name - or\n-     * {@code null} if not present.\n-     */\n-    public ZipArchiveEntry getEntry(final String name) {\n-        final LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n-        return entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n-    }\n-\n-    /**\n-     * Returns all named entries in the same order they appear within\n-     * the archive's central directory.\n-     *\n-     * @param name name of the entry.\n-     * @return the Iterable&lt;ZipArchiveEntry&gt; corresponding to the\n-     * given name\n-     * @since 1.6\n-     */\n-    public Iterable<ZipArchiveEntry> getEntries(final String name) {\n-        final List<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n-        return entriesOfThatName != null ? entriesOfThatName\n-            : Collections.<ZipArchiveEntry>emptyList();\n-    }\n-\n-    /**\n-     * Returns all named entries in the same order their contents\n-     * appear within the archive.\n-     *\n-     * @param name name of the entry.\n-     * @return the Iterable&lt;ZipArchiveEntry&gt; corresponding to the\n-     * given name\n-     * @since 1.6\n-     */\n-    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(final String name) {\n-        ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n-        if (nameMap.containsKey(name)) {\n-            entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n-            Arrays.sort(entriesOfThatName, OFFSET_COMPARATOR);\n-        }\n-        return Arrays.asList(entriesOfThatName);\n-    }\n-\n-    /**\n-     * Whether this class is able to read the given entry.\n-     *\n-     * <p>May return false if it is set up to use encryption or a\n-     * compression method that hasn't been implemented yet.</p>\n-     * @since 1.1\n-     * @param ze the entry\n-     * @return whether this class is able to read the given entry.\n-     */\n-    public boolean canReadEntryData(final ZipArchiveEntry ze) {\n-        return ZipUtil.canHandleEntryData(ze);\n-    }\n-\n-    /**\n-     * Expose the raw stream of the archive entry (compressed form).\n-     *\n-     * <p>This method does not relate to how/if we understand the payload in the\n-     * stream, since we really only intend to move it on to somewhere else.</p>\n-     *\n-     * @param ze The entry to get the stream for\n-     * @return The raw input stream containing (possibly) compressed data.\n-     * @since 1.11\n-     */\n-    public InputStream getRawInputStream(final ZipArchiveEntry ze) {\n-        if (!(ze instanceof Entry)) {\n-            return null;\n-        }\n-        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n-        final long start = offsetEntry.dataOffset;\n-        return new BoundedInputStream(start, ze.getCompressedSize());\n-    }\n-\n-\n-    /**\n-     * Transfer selected entries from this zipfile to a given #ZipArchiveOutputStream.\n-     * Compression and all other attributes will be as in this file.\n-     * <p>This method transfers entries based on the central directory of the zip file.</p>\n-     *\n-     * @param target The zipArchiveOutputStream to write the entries to\n-     * @param predicate A predicate that selects which entries to write\n-     * @throws IOException on error\n-     */\n-    public void copyRawEntries(final ZipArchiveOutputStream target, final ZipArchiveEntryPredicate predicate)\n-            throws IOException {\n-        final Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();\n-        while (src.hasMoreElements()) {\n-            final ZipArchiveEntry entry = src.nextElement();\n-            if (predicate.test( entry)) {\n-                target.addRawArchiveEntry(entry, getRawInputStream(entry));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns an InputStream for reading the contents of the given entry.\n-     *\n-     * @param ze the entry to get the stream for.\n-     * @return a stream to read the entry from.\n-     * @throws IOException if unable to create an input stream from the zipentry\n-     * @throws ZipException if the zipentry uses an unsupported feature\n-     */\n-    public InputStream getInputStream(final ZipArchiveEntry ze)\n-        throws IOException, ZipException {\n-        if (!(ze instanceof Entry)) {\n-            return null;\n-        }\n-        // cast valididty is checked just above\n-        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n-        ZipUtil.checkRequestedFeatures(ze);\n-        final long start = offsetEntry.dataOffset;\n-        final BoundedInputStream bis =\n-            new BoundedInputStream(start, ze.getCompressedSize());\n-        switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n-            case STORED:\n-                return bis;\n-            case UNSHRINKING:\n-                return new UnshrinkingInputStream(bis);\n-            case IMPLODING:\n-                return new ExplodingInputStream(ze.getGeneralPurposeBit().getSlidingDictionarySize(),\n-                        ze.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BufferedInputStream(bis));\n-            case DEFLATED:\n-                bis.addDummy();\n-                final Inflater inflater = new Inflater(true);\n-                return new InflaterInputStream(bis, inflater) {\n-                    @Override\n-                    public void close() throws IOException {\n-                        try {\n-                            super.close();\n-                        } finally {\n-                            inflater.end();\n-                        }\n-                    }\n-                };\n-            case BZIP2:\n-                return new BZip2CompressorInputStream(bis);\n-            case AES_ENCRYPTED:\n-            case ENHANCED_DEFLATED:\n-            case EXPANDING_LEVEL_1:\n-            case EXPANDING_LEVEL_2:\n-            case EXPANDING_LEVEL_3:\n-            case EXPANDING_LEVEL_4:\n-            case JPEG:\n-            case LZMA:\n-            case PKWARE_IMPLODING:\n-            case PPMD:\n-            case TOKENIZATION:\n-            case UNKNOWN:\n-            case WAVPACK:\n-            default:\n-                throw new ZipException(\"Found unsupported compression method \"\n-                                       + ze.getMethod());\n-        }\n-    }\n-\n-    /**\n-     * <p>\n-     * Convenience method to return the entry's content as a String if isUnixSymlink()\n-     * returns true for it, otherwise returns null.\n-     * </p>\n-     *\n-     * <p>This method assumes the symbolic link's file name uses the\n-     * same encoding that as been specified for this ZipFile.</p>\n-     *\n-     * @param entry ZipArchiveEntry object that represents the symbolic link\n-     * @return entry's content as a String\n-     * @throws IOException problem with content's input stream\n-     * @since 1.5\n-     */\n-    public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n-        if (entry != null && entry.isUnixSymlink()) {\n-            try (InputStream in = getInputStream(entry)) {\n-                return zipEncoding.decode(IOUtils.toByteArray(in));\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Ensures that the close method of this zipfile is called when\n-     * there are no more references to it.\n-     * @see #close()\n-     */\n-    @Override\n-    protected void finalize() throws Throwable {\n-        try {\n-            if (!closed) {\n-                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n-                                   + archiveName);\n-                close();\n-            }\n-        } finally {\n-            super.finalize();\n-        }\n-    }\n-\n-    /**\n-     * Length of a \"central directory\" entry structure without file\n-     * name, extra fields or comment.\n-     */\n-    private static final int CFH_LEN =\n-        /* version made by                 */ SHORT\n-        /* version needed to extract       */ + SHORT\n-        /* general purpose bit flag        */ + SHORT\n-        /* compression method              */ + SHORT\n-        /* last mod file time              */ + SHORT\n-        /* last mod file date              */ + SHORT\n-        /* crc-32                          */ + WORD\n-        /* compressed size                 */ + WORD\n-        /* uncompressed size               */ + WORD\n-        /* filename length                 */ + SHORT\n-        /* extra field length              */ + SHORT\n-        /* file comment length             */ + SHORT\n-        /* disk number start               */ + SHORT\n-        /* internal file attributes        */ + SHORT\n-        /* external file attributes        */ + WORD\n-        /* relative offset of local header */ + WORD;\n-\n-    private static final long CFH_SIG =\n-        ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n-\n-    /**\n-     * Reads the central directory of the given archive and populates\n-     * the internal tables with ZipArchiveEntry instances.\n-     *\n-     * <p>The ZipArchiveEntrys will know all data that can be obtained from\n-     * the central directory alone, but not the data that requires the\n-     * local file header or additional data to be read.</p>\n-     *\n-     * @return a map of zipentries that didn't have the language\n-     * encoding flag set when read.\n-     */\n-    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n-        throws IOException {\n-        final HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n-            new HashMap<>();\n-\n-        positionAtCentralDirectory();\n-\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        long sig = ZipLong.getValue(WORD_BUF);\n-\n-        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n-            throw new IOException(\"central directory is empty, can't expand\"\n-                                  + \" corrupt archive.\");\n-        }\n-\n-        while (sig == CFH_SIG) {\n-            readCentralDirectoryEntry(noUTF8Flag);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n-            sig = ZipLong.getValue(WORD_BUF);\n-        }\n-        return noUTF8Flag;\n-    }\n-\n-    /**\n-     * Reads an individual entry of the central directory, creats an\n-     * ZipArchiveEntry from it and adds it to the global maps.\n-     *\n-     * @param noUTF8Flag map used to collect entries that don't have\n-     * their UTF-8 flag set and whose name will be set by data read\n-     * from the local file header later.  The current entry may be\n-     * added to this map.\n-     */\n-    private void\n-        readCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n-        throws IOException {\n-        CFH_BBUF.rewind();\n-        IOUtils.readFully(archive, CFH_BBUF);\n-        int off = 0;\n-        final OffsetEntry offset = new OffsetEntry();\n-        final Entry ze = new Entry(offset);\n-\n-        final int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n-        off += SHORT;\n-        ze.setVersionMadeBy(versionMadeBy);\n-        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n-\n-        ze.setVersionRequired(ZipShort.getValue(CFH_BUF, off));\n-        off += SHORT; // version required\n-\n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\n-        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n-        final ZipEncoding entryEncoding =\n-            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-        ze.setGeneralPurposeBit(gpFlag);\n-        ze.setRawFlag(ZipShort.getValue(CFH_BUF, off));\n-\n-        off += SHORT;\n-\n-        //noinspection MagicConstant\n-        ze.setMethod(ZipShort.getValue(CFH_BUF, off));\n-        off += SHORT;\n-\n-        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n-        ze.setTime(time);\n-        off += WORD;\n-\n-        ze.setCrc(ZipLong.getValue(CFH_BUF, off));\n-        off += WORD;\n-\n-        ze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\n-        off += WORD;\n-\n-        ze.setSize(ZipLong.getValue(CFH_BUF, off));\n-        off += WORD;\n-\n-        final int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n-        off += SHORT;\n-\n-        final int extraLen = ZipShort.getValue(CFH_BUF, off);\n-        off += SHORT;\n-\n-        final int commentLen = ZipShort.getValue(CFH_BUF, off);\n-        off += SHORT;\n-\n-        final int diskStart = ZipShort.getValue(CFH_BUF, off);\n-        off += SHORT;\n-\n-        ze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\n-        off += SHORT;\n-\n-        ze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\n-        off += WORD;\n-\n-        final byte[] fileName = new byte[fileNameLen];\n-        IOUtils.readFully(archive, ByteBuffer.wrap(fileName));\n-        ze.setName(entryEncoding.decode(fileName), fileName);\n-\n-        // LFH offset,\n-        offset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n-        // data offset will be filled later\n-        entries.add(ze);\n-\n-        final byte[] cdExtraData = new byte[extraLen];\n-        IOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\n-        ze.setCentralDirectoryExtra(cdExtraData);\n-\n-        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n-\n-        final byte[] comment = new byte[commentLen];\n-        IOUtils.readFully(archive, ByteBuffer.wrap(comment));\n-        ze.setComment(entryEncoding.decode(comment));\n-\n-        if (!hasUTF8Flag && useUnicodeExtraFields) {\n-            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n-        }\n-    }\n-\n-    /**\n-     * If the entry holds a Zip64 extended information extra field,\n-     * read sizes from there if the entry's sizes are set to\n-     * 0xFFFFFFFFF, do the same for the offset of the local file\n-     * header.\n-     *\n-     * <p>Ensures the Zip64 extra either knows both compressed and\n-     * uncompressed size or neither of both as the internal logic in\n-     * ExtraFieldUtils forces the field to create local header data\n-     * even if they are never used - and here a field with only one\n-     * size would be invalid.</p>\n-     */\n-    private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\n-                                                 final OffsetEntry offset,\n-                                                 final int diskStart)\n-        throws IOException {\n-        final Zip64ExtendedInformationExtraField z64 =\n-            (Zip64ExtendedInformationExtraField)\n-            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n-        if (z64 != null) {\n-            final boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n-            final boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n-            final boolean hasRelativeHeaderOffset =\n-                offset.headerOffset == ZIP64_MAGIC;\n-            z64.reparseCentralDirectoryData(hasUncompressedSize,\n-                                            hasCompressedSize,\n-                                            hasRelativeHeaderOffset,\n-                                            diskStart == ZIP64_MAGIC_SHORT);\n-\n-            if (hasUncompressedSize) {\n-                ze.setSize(z64.getSize().getLongValue());\n-            } else if (hasCompressedSize) {\n-                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n-            }\n-\n-            if (hasCompressedSize) {\n-                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n-            } else if (hasUncompressedSize) {\n-                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n-            }\n-\n-            if (hasRelativeHeaderOffset) {\n-                offset.headerOffset =\n-                    z64.getRelativeHeaderOffset().getLongValue();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Length of the \"End of central directory record\" - which is\n-     * supposed to be the last structure of the archive - without file\n-     * comment.\n-     */\n-    static final int MIN_EOCD_SIZE =\n-        /* end of central dir signature    */ WORD\n-        /* number of this disk             */ + SHORT\n-        /* number of the disk with the     */\n-        /* start of the central directory  */ + SHORT\n-        /* total number of entries in      */\n-        /* the central dir on this disk    */ + SHORT\n-        /* total number of entries in      */\n-        /* the central dir                 */ + SHORT\n-        /* size of the central directory   */ + WORD\n-        /* offset of start of central      */\n-        /* directory with respect to       */\n-        /* the starting disk number        */ + WORD\n-        /* zipfile comment length          */ + SHORT;\n-\n-    /**\n-     * Maximum length of the \"End of central directory record\" with a\n-     * file comment.\n-     */\n-    private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE\n-        /* maximum length of zipfile comment */ + ZIP64_MAGIC_SHORT;\n-\n-    /**\n-     * Offset of the field that holds the location of the first\n-     * central directory entry inside the \"End of central directory\n-     * record\" relative to the start of the \"End of central directory\n-     * record\".\n-     */\n-    private static final int CFD_LOCATOR_OFFSET =\n-        /* end of central dir signature    */ WORD\n-        /* number of this disk             */ + SHORT\n-        /* number of the disk with the     */\n-        /* start of the central directory  */ + SHORT\n-        /* total number of entries in      */\n-        /* the central dir on this disk    */ + SHORT\n-        /* total number of entries in      */\n-        /* the central dir                 */ + SHORT\n-        /* size of the central directory   */ + WORD;\n-\n-    /**\n-     * Length of the \"Zip64 end of central directory locator\" - which\n-     * should be right in front of the \"end of central directory\n-     * record\" if one is present at all.\n-     */\n-    private static final int ZIP64_EOCDL_LENGTH =\n-        /* zip64 end of central dir locator sig */ WORD\n-        /* number of the disk with the start    */\n-        /* start of the zip64 end of            */\n-        /* central directory                    */ + WORD\n-        /* relative offset of the zip64         */\n-        /* end of central directory record      */ + DWORD\n-        /* total number of disks                */ + WORD;\n-\n-    /**\n-     * Offset of the field that holds the location of the \"Zip64 end\n-     * of central directory record\" inside the \"Zip64 end of central\n-     * directory locator\" relative to the start of the \"Zip64 end of\n-     * central directory locator\".\n-     */\n-    private static final int ZIP64_EOCDL_LOCATOR_OFFSET =\n-        /* zip64 end of central dir locator sig */ WORD\n-        /* number of the disk with the start    */\n-        /* start of the zip64 end of            */\n-        /* central directory                    */ + WORD;\n-\n-    /**\n-     * Offset of the field that holds the location of the first\n-     * central directory entry inside the \"Zip64 end of central\n-     * directory record\" relative to the start of the \"Zip64 end of\n-     * central directory record\".\n-     */\n-    private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET =\n-        /* zip64 end of central dir        */\n-        /* signature                       */ WORD\n-        /* size of zip64 end of central    */\n-        /* directory record                */ + DWORD\n-        /* version made by                 */ + SHORT\n-        /* version needed to extract       */ + SHORT\n-        /* number of this disk             */ + WORD\n-        /* number of the disk with the     */\n-        /* start of the central directory  */ + WORD\n-        /* total number of entries in the  */\n-        /* central directory on this disk  */ + DWORD\n-        /* total number of entries in the  */\n-        /* central directory               */ + DWORD\n-        /* size of the central directory   */ + DWORD;\n-\n-    /**\n-     * Searches for either the &quot;Zip64 end of central directory\n-     * locator&quot; or the &quot;End of central dir record&quot;, parses\n-     * it and positions the stream at the first central directory\n-     * record.\n-     */\n-    private void positionAtCentralDirectory()\n-        throws IOException {\n-        positionAtEndOfCentralDirectoryRecord();\n-        boolean found = false;\n-        final boolean searchedForZip64EOCD =\n-            archive.position() > ZIP64_EOCDL_LENGTH;\n-        if (searchedForZip64EOCD) {\n-            archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n-            found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n-                                  WORD_BUF);\n-        }\n-        if (!found) {\n-            // not a ZIP64 archive\n-            if (searchedForZip64EOCD) {\n-                skipBytes(ZIP64_EOCDL_LENGTH - WORD);\n-            }\n-            positionAtCentralDirectory32();\n-        } else {\n-            positionAtCentralDirectory64();\n-        }\n-    }\n-\n-    /**\n-     * Parses the &quot;Zip64 end of central directory locator&quot;,\n-     * finds the &quot;Zip64 end of central directory record&quot; using the\n-     * parsed information, parses that and positions the stream at the\n-     * first central directory record.\n-     *\n-     * Expects stream to be positioned right behind the &quot;Zip64\n-     * end of central directory locator&quot;'s signature.\n-     */\n-    private void positionAtCentralDirectory64()\n-        throws IOException {\n-        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n-                  - WORD /* signature has already been read */);\n-        DWORD_BBUF.rewind();\n-        IOUtils.readFully(archive, DWORD_BBUF);\n-        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        if (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n-            throw new ZipException(\"archive's ZIP64 end of central \"\n-                                   + \"directory locator is corrupt.\");\n-        }\n-        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n-                  - WORD /* signature has already been read */);\n-        DWORD_BBUF.rewind();\n-        IOUtils.readFully(archive, DWORD_BBUF);\n-        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n-    }\n-\n-    /**\n-     * Parses the &quot;End of central dir record&quot; and positions\n-     * the stream at the first central directory record.\n-     *\n-     * Expects stream to be positioned at the beginning of the\n-     * &quot;End of central dir record&quot;.\n-     */\n-    private void positionAtCentralDirectory32()\n-        throws IOException {\n-        skipBytes(CFD_LOCATOR_OFFSET);\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        archive.position(ZipLong.getValue(WORD_BUF));\n-    }\n-\n-    /**\n-     * Searches for the and positions the stream at the start of the\n-     * &quot;End of central dir record&quot;.\n-     */\n-    private void positionAtEndOfCentralDirectoryRecord()\n-        throws IOException {\n-        final boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n-                                             ZipArchiveOutputStream.EOCD_SIG);\n-        if (!found) {\n-            throw new ZipException(\"archive is not a ZIP archive\");\n-        }\n-    }\n-\n-    /**\n-     * Searches the archive backwards from minDistance to maxDistance\n-     * for the given signature, positions the RandomaccessFile right\n-     * at the signature if it has been found.\n-     */\n-    private boolean tryToLocateSignature(final long minDistanceFromEnd,\n-                                         final long maxDistanceFromEnd,\n-                                         final byte[] sig) throws IOException {\n-        boolean found = false;\n-        long off = archive.size() - minDistanceFromEnd;\n-        final long stopSearching =\n-            Math.max(0L, archive.size() - maxDistanceFromEnd);\n-        if (off >= 0) {\n-            for (; off >= stopSearching; off--) {\n-                archive.position(off);\n-                try {\n-                    WORD_BBUF.rewind();\n-                    IOUtils.readFully(archive, WORD_BBUF);\n-                    WORD_BBUF.flip();\n-                } catch (EOFException ex) {\n-                    break;\n-                }\n-                int curr = WORD_BBUF.get();\n-                if (curr == sig[POS_0]) {\n-                    curr = WORD_BBUF.get();\n-                    if (curr == sig[POS_1]) {\n-                        curr = WORD_BBUF.get();\n-                        if (curr == sig[POS_2]) {\n-                            curr = WORD_BBUF.get();\n-                            if (curr == sig[POS_3]) {\n-                                found = true;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (found) {\n-            archive.position(off);\n-        }\n-        return found;\n-    }\n-\n-    /**\n-     * Skips the given number of bytes or throws an EOFException if\n-     * skipping failed.\n-     */ \n-    private void skipBytes(final int count) throws IOException {\n-        long currentPosition = archive.position();\n-        long newPosition = currentPosition + count;\n-        if (newPosition > archive.size()) {\n-            throw new EOFException();\n-        }\n-        archive.position(newPosition);\n-    }\n-\n-    /**\n-     * Number of bytes in local file header up to the &quot;length of\n-     * filename&quot; entry.\n-     */\n-    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH =\n-        /* local file header signature     */ WORD\n-        /* version needed to extract       */ + SHORT\n-        /* general purpose bit flag        */ + SHORT\n-        /* compression method              */ + SHORT\n-        /* last mod file time              */ + SHORT\n-        /* last mod file date              */ + SHORT\n-        /* crc-32                          */ + WORD\n-        /* compressed size                 */ + WORD\n-        /* uncompressed size               */ + WORD;\n-\n-    /**\n-     * Walks through all recorded entries and adds the data available\n-     * from the local file header.\n-     *\n-     * <p>Also records the offsets for the data to read from the\n-     * entries.</p>\n-     */\n-    private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\n-                                            entriesWithoutUTF8Flag)\n-        throws IOException {\n-        for (final ZipArchiveEntry zipArchiveEntry : entries) {\n-            // entries is filled in populateFromCentralDirectory and\n-            // never modified\n-            final Entry ze = (Entry) zipArchiveEntry;\n-            final OffsetEntry offsetEntry = ze.getOffsetEntry();\n-            final long offset = offsetEntry.headerOffset;\n-            archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n-            WORD_BBUF.flip();\n-            WORD_BBUF.get(SHORT_BUF);\n-            final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n-            WORD_BBUF.get(SHORT_BUF);\n-            final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n-            skipBytes(fileNameLen);\n-            final byte[] localExtraData = new byte[extraFieldLen];\n-            IOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\n-            ze.setExtra(localExtraData);\n-            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n-                + SHORT + SHORT + fileNameLen + extraFieldLen;\n-\n-            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n-                final NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n-                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n-                                                         nc.comment);\n-            }\n-\n-            final String name = ze.getName();\n-            LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n-            if (entriesOfThatName == null) {\n-                entriesOfThatName = new LinkedList<>();\n-                nameMap.put(name, entriesOfThatName);\n-            }\n-            entriesOfThatName.addLast(ze);\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the archive starts with a LFH.  If it doesn't,\n-     * it may be an empty archive.\n-     */\n-    private boolean startsWithLocalFileHeader() throws IOException {\n-        archive.position(0);\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        return Arrays.equals(WORD_BUF, ZipArchiveOutputStream.LFH_SIG);\n-    }\n-\n-    /**\n-     * InputStream that delegates requests to the underlying\n-     * SeekableByteChannel, making sure that only bytes from a certain\n-     * range can be read.\n-     */\n-    private class BoundedInputStream extends InputStream {\n-        private static final int MAX_BUF_LEN = 8192;\n-        private final ByteBuffer buffer;\n-        private long remaining;\n-        private long loc;\n-        private boolean addDummyByte = false;\n-\n-        BoundedInputStream(final long start, final long remaining) {\n-            this.remaining = remaining;\n-            loc = start;\n-            if (remaining < MAX_BUF_LEN && remaining > 0) {\n-                buffer = ByteBuffer.allocate((int) remaining);\n-            } else {\n-                buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n-            }\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            if (remaining-- <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n-                    return 0;\n-                }\n-                return -1;\n-            }\n-            synchronized (archive) {\n-                archive.position(loc++);\n-                int read = read(1);\n-                if (read < 0) {\n-                    return read;\n-                }\n-                return buffer.get() & 0xff;\n-            }\n-        }\n-\n-        @Override\n-        public int read(final byte[] b, final int off, int len) throws IOException {\n-            if (remaining <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n-                    b[off] = 0;\n-                    return 1;\n-                }\n-                return -1;\n-            }\n-\n-            if (len <= 0) {\n-                return 0;\n-            }\n-\n-            if (len > remaining) {\n-                len = (int) remaining;\n-            }\n-            ByteBuffer buf;\n-            int ret = -1;\n-            synchronized (archive) {\n-                archive.position(loc);\n-                if (len <= buffer.capacity()) {\n-                    buf = buffer;\n-                    ret = read(len);\n-                } else {\n-                    buf = ByteBuffer.allocate(len);\n-                    ret = archive.read(buf);\n-                    buf.flip();\n-                }\n-            }\n-            if (ret > 0) {\n-                buf.get(b, off, ret);\n-                loc += ret;\n-                remaining -= ret;\n-            }\n-            return ret;\n-        }\n-\n-        private int read(int len) throws IOException {\n-            buffer.rewind().limit(len);\n-            int read = archive.read(buffer);\n-            buffer.flip();\n-            return read;\n-        }\n-\n-        /**\n-         * Inflater needs an extra dummy byte for nowrap - see\n-         * Inflater's javadocs.\n-         */\n-        void addDummy() {\n-            addDummyByte = true;\n-        }\n-    }\n-\n-    private static final class NameAndComment {\n-        private final byte[] name;\n-        private final byte[] comment;\n-        private NameAndComment(final byte[] name, final byte[] comment) {\n-            this.name = name;\n-            this.comment = comment;\n-        }\n-    }\n-\n-    /**\n-     * Compares two ZipArchiveEntries based on their offset within the archive.\n-     *\n-     * <p>Won't return any meaningful results if one of the entries\n-     * isn't part of the archive at all.</p>\n-     *\n-     * @since 1.1\n-     */\n-    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n-        new Comparator<ZipArchiveEntry>() {\n-        @Override\n-        public int compare(final ZipArchiveEntry e1, final ZipArchiveEntry e2) {\n-            if (e1 == e2) {\n-                return 0;\n-            }\n-\n-            final Entry ent1 = e1 instanceof Entry ? (Entry) e1 : null;\n-            final Entry ent2 = e2 instanceof Entry ? (Entry) e2 : null;\n-            if (ent1 == null) {\n-                return 1;\n-            }\n-            if (ent2 == null) {\n-                return -1;\n-            }\n-            final long val = (ent1.getOffsetEntry().headerOffset\n-                        - ent2.getOffsetEntry().headerOffset);\n-            return val == 0 ? 0 : val < 0 ? -1 : +1;\n-        }\n-    };\n-\n-    /**\n-     * Extends ZipArchiveEntry to store the offset within the archive.\n-     */\n-    private static class Entry extends ZipArchiveEntry {\n-\n-        private final OffsetEntry offsetEntry;\n-\n-        Entry(final OffsetEntry offset) {\n-            this.offsetEntry = offset;\n-        }\n-\n-        OffsetEntry getOffsetEntry() {\n-            return offsetEntry;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return 3 * super.hashCode()\n-                + (int) (offsetEntry.headerOffset % Integer.MAX_VALUE);\n-        }\n-\n-        @Override\n-        public boolean equals(final Object other) {\n-            if (super.equals(other)) {\n-                // super.equals would return false if other were not an Entry\n-                final Entry otherEntry = (Entry) other;\n-                return offsetEntry.headerOffset\n-                        == otherEntry.offsetEntry.headerOffset\n-                    && offsetEntry.dataOffset\n-                        == otherEntry.offsetEntry.dataOffset;\n-            }\n-            return false;\n-        }\n-    }\n-}\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.BufferedInputStream;\n+import java.io.Closeable;\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Enumeration;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import java.util.zip.ZipException;\n+\n+import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT;\n+\n+/**\n+ * Replacement for <code>java.util.ZipFile</code>.\n+ *\n+ * <p>This class adds support for file name encodings other than UTF-8\n+ * (which is required to work on ZIP files created by native zip tools\n+ * and is able to skip a preamble like the one found in self\n+ * extracting archives.  Furthermore it returns instances of\n+ * <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n+ * instead of <code>java.util.zip.ZipEntry</code>.</p>\n+ *\n+ * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n+ * have to reimplement all methods anyway.  Like\n+ * <code>java.util.ZipFile</code>, it uses SeekableByteChannel under the\n+ * covers and supports compressed and uncompressed entries.  As of\n+ * Apache Commons Compress 1.3 it also transparently supports Zip64\n+ * extensions and thus individual entries and archives larger than 4\n+ * GB or with more than 65536 entries.</p>\n+ *\n+ * <p>The method signatures mimic the ones of\n+ * <code>java.util.zip.ZipFile</code>, with a couple of exceptions:\n+ *\n+ * <ul>\n+ *   <li>There is no getName method.</li>\n+ *   <li>entries has been renamed to getEntries.</li>\n+ *   <li>getEntries and getEntry return\n+ *   <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n+ *   instances.</li>\n+ *   <li>close is allowed to throw IOException.</li>\n+ * </ul>\n+ *\n+ */\n+public class ZipFile implements Closeable {\n+    private static final int HASH_SIZE = 509;\n+    static final int NIBLET_MASK = 0x0f;\n+    static final int BYTE_SHIFT = 8;\n+    private static final int POS_0 = 0;\n+    private static final int POS_1 = 1;\n+    private static final int POS_2 = 2;\n+    private static final int POS_3 = 3;\n+\n+    /**\n+     * List of entries in the order they appear inside the central\n+     * directory.\n+     */\n+    private final List<ZipArchiveEntry> entries =\n+        new LinkedList<>();\n+\n+    /**\n+     * Maps String to list of ZipArchiveEntrys, name -> actual entries.\n+     */\n+    private final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\n+        new HashMap<>(HASH_SIZE);\n+\n+    private static final class OffsetEntry {\n+        private long headerOffset = -1;\n+        private long dataOffset = -1;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to UTF-8.</p>\n+     */\n+    private final String encoding;\n+\n+    /**\n+     * The zip encoding to use for filenames and the file comment.\n+     */\n+    private final ZipEncoding zipEncoding;\n+\n+    /**\n+     * File name of actual source.\n+     */\n+    private final String archiveName;\n+\n+    /**\n+     * The actual data source.\n+     */\n+    private final SeekableByteChannel archive;\n+\n+    /**\n+     * Whether to look for and use Unicode extra fields.\n+     */\n+    private final boolean useUnicodeExtraFields;\n+\n+    /**\n+     * Whether the file is closed.\n+     */\n+    private volatile boolean closed = true;\n+\n+    // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n+    private final byte[] DWORD_BUF = new byte[DWORD];\n+    private final byte[] WORD_BUF = new byte[WORD];\n+    private final byte[] CFH_BUF = new byte[CFH_LEN];\n+    private final byte[] SHORT_BUF = new byte[SHORT];\n+    private final ByteBuffer DWORD_BBUF = ByteBuffer.wrap(DWORD_BUF);\n+    private final ByteBuffer WORD_BBUF = ByteBuffer.wrap(WORD_BUF);\n+    private final ByteBuffer CFH_BBUF = ByteBuffer.wrap(CFH_BUF);\n+    private final ByteBuffer SHORT_BBUF = ByteBuffer.wrap(SHORT_BUF);\n+\n+    /**\n+     * Opens the given file for reading, assuming \"UTF8\" for file names.\n+     *\n+     * @param f the archive.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final File f) throws IOException {\n+        this(f, ZipEncodingHelper.UTF8);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming \"UTF8\".\n+     *\n+     * @param name name of the archive.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final String name) throws IOException {\n+        this(new File(name), ZipEncodingHelper.UTF8);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names, scanning unicode extra fields.\n+     *\n+     * @param name name of the archive.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final String name, final String encoding) throws IOException {\n+        this(new File(name), encoding, true);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names and scanning for unicode extra fields.\n+     *\n+     * @param f the archive.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final File f, final String encoding) throws IOException {\n+        this(f, encoding, true);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * @param f the archive.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n+        throws IOException {\n+        this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n+             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true);\n+    }\n+\n+    /**\n+     * Opens the given channel for reading, assuming \"UTF8\" for file names.\n+     *\n+     * <p>{@link\n+     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n+     * allows you to read from an in-memory archive.</p>\n+     *\n+     * @param channel the archive.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     * @since 1.13\n+     */\n+    public ZipFile(final SeekableByteChannel channel)\n+            throws IOException {\n+        this(channel, \"unknown archive\", ZipEncodingHelper.UTF8, true);\n+    }\n+\n+    /**\n+     * Opens the given channel for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * <p>{@link\n+     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n+     * allows you to read from an in-memory archive.</p>\n+     *\n+     * @param channel the archive.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     * @since 1.13\n+     */\n+    public ZipFile(final SeekableByteChannel channel, final String encoding)\n+        throws IOException {\n+        this(channel, \"unknown archive\", encoding, true);\n+    }\n+\n+    /**\n+     * Opens the given channel for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * <p>{@link\n+     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}\n+     * allows you to read from an in-memory archive.</p>\n+     *\n+     * @param channel the archive.\n+     * @param archiveName name of the archive, used for error messages only.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     * @since 1.13\n+     */\n+    public ZipFile(final SeekableByteChannel channel, final String archiveName,\n+                   final String encoding, final boolean useUnicodeExtraFields)\n+        throws IOException {\n+        this(channel, archiveName, encoding, useUnicodeExtraFields, false);\n+    }\n+\n+    private ZipFile(final SeekableByteChannel channel, final String archiveName,\n+                    final String encoding, final boolean useUnicodeExtraFields,\n+                    final boolean closeOnError)\n+        throws IOException {\n+        this.archiveName = archiveName;\n+        this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.useUnicodeExtraFields = useUnicodeExtraFields;\n+        archive = channel;\n+        boolean success = false;\n+        try {\n+            final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n+                populateFromCentralDirectory();\n+            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n+            success = true;\n+        } finally {\n+            closed = !success;\n+            if (!success && closeOnError) {\n+                IOUtils.closeQuietly(archive);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     */\n+    public String getEncoding() {\n+        return encoding;\n+    }\n+\n+    /**\n+     * Closes the archive.\n+     * @throws IOException if an error occurs closing the archive.\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        // this flag is only written here and read in finalize() which\n+        // can never be run in parallel.\n+        // no synchronization needed.\n+        closed = true;\n+\n+        archive.close();\n+    }\n+\n+    /**\n+     * close a zipfile quietly; throw no io fault, do nothing\n+     * on a null parameter\n+     * @param zipfile file to close, can be null\n+     */\n+    public static void closeQuietly(final ZipFile zipfile) {\n+        IOUtils.closeQuietly(zipfile);\n+    }\n+\n+    /**\n+     * Returns all entries.\n+     *\n+     * <p>Entries will be returned in the same order they appear\n+     * within the archive's central directory.</p>\n+     *\n+     * @return all entries as {@link ZipArchiveEntry} instances\n+     */\n+    public Enumeration<ZipArchiveEntry> getEntries() {\n+        return Collections.enumeration(entries);\n+    }\n+\n+    /**\n+     * Returns all entries in physical order.\n+     *\n+     * <p>Entries will be returned in the same order their contents\n+     * appear within the archive.</p>\n+     *\n+     * @return all entries as {@link ZipArchiveEntry} instances\n+     *\n+     * @since 1.1\n+     */\n+    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n+        final ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n+        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n+        return Collections.enumeration(Arrays.asList(allEntries));\n+    }\n+\n+    /**\n+     * Returns a named entry - or {@code null} if no entry by\n+     * that name exists.\n+     *\n+     * <p>If multiple entries with the same name exist the first entry\n+     * in the archive's central directory by that name is\n+     * returned.</p>\n+     *\n+     * @param name name of the entry.\n+     * @return the ZipArchiveEntry corresponding to the given name - or\n+     * {@code null} if not present.\n+     */\n+    public ZipArchiveEntry getEntry(final String name) {\n+        final LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        return entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n+    }\n+\n+    /**\n+     * Returns all named entries in the same order they appear within\n+     * the archive's central directory.\n+     *\n+     * @param name name of the entry.\n+     * @return the Iterable&lt;ZipArchiveEntry&gt; corresponding to the\n+     * given name\n+     * @since 1.6\n+     */\n+    public Iterable<ZipArchiveEntry> getEntries(final String name) {\n+        final List<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        return entriesOfThatName != null ? entriesOfThatName\n+            : Collections.<ZipArchiveEntry>emptyList();\n+    }\n+\n+    /**\n+     * Returns all named entries in the same order their contents\n+     * appear within the archive.\n+     *\n+     * @param name name of the entry.\n+     * @return the Iterable&lt;ZipArchiveEntry&gt; corresponding to the\n+     * given name\n+     * @since 1.6\n+     */\n+    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(final String name) {\n+        ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n+        if (nameMap.containsKey(name)) {\n+            entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n+            Arrays.sort(entriesOfThatName, OFFSET_COMPARATOR);\n+        }\n+        return Arrays.asList(entriesOfThatName);\n+    }\n+\n+    /**\n+     * Whether this class is able to read the given entry.\n+     *\n+     * <p>May return false if it is set up to use encryption or a\n+     * compression method that hasn't been implemented yet.</p>\n+     * @since 1.1\n+     * @param ze the entry\n+     * @return whether this class is able to read the given entry.\n+     */\n+    public boolean canReadEntryData(final ZipArchiveEntry ze) {\n+        return ZipUtil.canHandleEntryData(ze);\n+    }\n+\n+    /**\n+     * Expose the raw stream of the archive entry (compressed form).\n+     *\n+     * <p>This method does not relate to how/if we understand the payload in the\n+     * stream, since we really only intend to move it on to somewhere else.</p>\n+     *\n+     * @param ze The entry to get the stream for\n+     * @return The raw input stream containing (possibly) compressed data.\n+     * @since 1.11\n+     */\n+    public InputStream getRawInputStream(final ZipArchiveEntry ze) {\n+        if (!(ze instanceof Entry)) {\n+            return null;\n+        }\n+        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n+        final long start = offsetEntry.dataOffset;\n+        return new BoundedInputStream(start, ze.getCompressedSize());\n+    }\n+\n+\n+    /**\n+     * Transfer selected entries from this zipfile to a given #ZipArchiveOutputStream.\n+     * Compression and all other attributes will be as in this file.\n+     * <p>This method transfers entries based on the central directory of the zip file.</p>\n+     *\n+     * @param target The zipArchiveOutputStream to write the entries to\n+     * @param predicate A predicate that selects which entries to write\n+     * @throws IOException on error\n+     */\n+    public void copyRawEntries(final ZipArchiveOutputStream target, final ZipArchiveEntryPredicate predicate)\n+            throws IOException {\n+        final Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();\n+        while (src.hasMoreElements()) {\n+            final ZipArchiveEntry entry = src.nextElement();\n+            if (predicate.test( entry)) {\n+                target.addRawArchiveEntry(entry, getRawInputStream(entry));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns an InputStream for reading the contents of the given entry.\n+     *\n+     * @param ze the entry to get the stream for.\n+     * @return a stream to read the entry from.\n+     * @throws IOException if unable to create an input stream from the zipentry\n+     * @throws ZipException if the zipentry uses an unsupported feature\n+     */\n+    public InputStream getInputStream(final ZipArchiveEntry ze)\n+        throws IOException, ZipException {\n+        if (!(ze instanceof Entry)) {\n+            return null;\n+        }\n+        // cast valididty is checked just above\n+        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n+        ZipUtil.checkRequestedFeatures(ze);\n+        final long start = offsetEntry.dataOffset;\n+        final BoundedInputStream bis =\n+            new BoundedInputStream(start, ze.getCompressedSize());\n+        switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n+            case STORED:\n+                return bis;\n+            case UNSHRINKING:\n+                return new UnshrinkingInputStream(bis);\n+            case IMPLODING:\n+                return new ExplodingInputStream(ze.getGeneralPurposeBit().getSlidingDictionarySize(),\n+                        ze.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BufferedInputStream(bis));\n+            case DEFLATED:\n+                bis.addDummy();\n+                final Inflater inflater = new Inflater(true);\n+                return new InflaterInputStream(bis, inflater) {\n+                    @Override\n+                    public void close() throws IOException {\n+                        try {\n+                            super.close();\n+                        } finally {\n+                            inflater.end();\n+                        }\n+                    }\n+                };\n+            case BZIP2:\n+                return new BZip2CompressorInputStream(bis);\n+            case AES_ENCRYPTED:\n+            case ENHANCED_DEFLATED:\n+            case EXPANDING_LEVEL_1:\n+            case EXPANDING_LEVEL_2:\n+            case EXPANDING_LEVEL_3:\n+            case EXPANDING_LEVEL_4:\n+            case JPEG:\n+            case LZMA:\n+            case PKWARE_IMPLODING:\n+            case PPMD:\n+            case TOKENIZATION:\n+            case UNKNOWN:\n+            case WAVPACK:\n+            default:\n+                throw new ZipException(\"Found unsupported compression method \"\n+                                       + ze.getMethod());\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Convenience method to return the entry's content as a String if isUnixSymlink()\n+     * returns true for it, otherwise returns null.\n+     * </p>\n+     *\n+     * <p>This method assumes the symbolic link's file name uses the\n+     * same encoding that as been specified for this ZipFile.</p>\n+     *\n+     * @param entry ZipArchiveEntry object that represents the symbolic link\n+     * @return entry's content as a String\n+     * @throws IOException problem with content's input stream\n+     * @since 1.5\n+     */\n+    public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n+        if (entry != null && entry.isUnixSymlink()) {\n+            try (InputStream in = getInputStream(entry)) {\n+                return zipEncoding.decode(IOUtils.toByteArray(in));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Ensures that the close method of this zipfile is called when\n+     * there are no more references to it.\n+     * @see #close()\n+     */\n+    @Override\n+    protected void finalize() throws Throwable {\n+        try {\n+            if (!closed) {\n+                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n+                                   + archiveName);\n+                close();\n+            }\n+        } finally {\n+            super.finalize();\n+        }\n+    }\n+\n+    /**\n+     * Length of a \"central directory\" entry structure without file\n+     * name, extra fields or comment.\n+     */\n+    private static final int CFH_LEN =\n+        /* version made by                 */ SHORT\n+        /* version needed to extract       */ + SHORT\n+        /* general purpose bit flag        */ + SHORT\n+        /* compression method              */ + SHORT\n+        /* last mod file time              */ + SHORT\n+        /* last mod file date              */ + SHORT\n+        /* crc-32                          */ + WORD\n+        /* compressed size                 */ + WORD\n+        /* uncompressed size               */ + WORD\n+        /* filename length                 */ + SHORT\n+        /* extra field length              */ + SHORT\n+        /* file comment length             */ + SHORT\n+        /* disk number start               */ + SHORT\n+        /* internal file attributes        */ + SHORT\n+        /* external file attributes        */ + WORD\n+        /* relative offset of local header */ + WORD;\n+\n+    private static final long CFH_SIG =\n+        ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n+\n+    /**\n+     * Reads the central directory of the given archive and populates\n+     * the internal tables with ZipArchiveEntry instances.\n+     *\n+     * <p>The ZipArchiveEntrys will know all data that can be obtained from\n+     * the central directory alone, but not the data that requires the\n+     * local file header or additional data to be read.</p>\n+     *\n+     * @return a map of zipentries that didn't have the language\n+     * encoding flag set when read.\n+     */\n+    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n+        throws IOException {\n+        final HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n+            new HashMap<>();\n+\n+        positionAtCentralDirectory();\n+\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n+        long sig = ZipLong.getValue(WORD_BUF);\n+\n+        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n+            throw new IOException(\"central directory is empty, can't expand\"\n+                                  + \" corrupt archive.\");\n+        }\n+\n+        while (sig == CFH_SIG) {\n+            readCentralDirectoryEntry(noUTF8Flag);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n+            sig = ZipLong.getValue(WORD_BUF);\n+        }\n+        return noUTF8Flag;\n+    }\n+\n+    /**\n+     * Reads an individual entry of the central directory, creats an\n+     * ZipArchiveEntry from it and adds it to the global maps.\n+     *\n+     * @param noUTF8Flag map used to collect entries that don't have\n+     * their UTF-8 flag set and whose name will be set by data read\n+     * from the local file header later.  The current entry may be\n+     * added to this map.\n+     */\n+    private void\n+        readCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n+        throws IOException {\n+        CFH_BBUF.rewind();\n+        IOUtils.readFully(archive, CFH_BBUF);\n+        int off = 0;\n+        final OffsetEntry offset = new OffsetEntry();\n+        final Entry ze = new Entry(offset);\n+\n+        final int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n+        off += SHORT;\n+        ze.setVersionMadeBy(versionMadeBy);\n+        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n+\n+        ze.setVersionRequired(ZipShort.getValue(CFH_BUF, off));\n+        off += SHORT; // version required\n+\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\n+        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n+        final ZipEncoding entryEncoding =\n+            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+        ze.setGeneralPurposeBit(gpFlag);\n+        ze.setRawFlag(ZipShort.getValue(CFH_BUF, off));\n+\n+        off += SHORT;\n+\n+        //noinspection MagicConstant\n+        ze.setMethod(ZipShort.getValue(CFH_BUF, off));\n+        off += SHORT;\n+\n+        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n+        ze.setTime(time);\n+        off += WORD;\n+\n+        ze.setCrc(ZipLong.getValue(CFH_BUF, off));\n+        off += WORD;\n+\n+        ze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\n+        off += WORD;\n+\n+        ze.setSize(ZipLong.getValue(CFH_BUF, off));\n+        off += WORD;\n+\n+        final int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n+        off += SHORT;\n+\n+        final int extraLen = ZipShort.getValue(CFH_BUF, off);\n+        off += SHORT;\n+\n+        final int commentLen = ZipShort.getValue(CFH_BUF, off);\n+        off += SHORT;\n+\n+        final int diskStart = ZipShort.getValue(CFH_BUF, off);\n+        off += SHORT;\n+\n+        ze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\n+        off += SHORT;\n+\n+        ze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\n+        off += WORD;\n+\n+        final byte[] fileName = new byte[fileNameLen];\n+        IOUtils.readFully(archive, ByteBuffer.wrap(fileName));\n+        ze.setName(entryEncoding.decode(fileName), fileName);\n+\n+        // LFH offset,\n+        offset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n+        // data offset will be filled later\n+        entries.add(ze);\n+\n+        final byte[] cdExtraData = new byte[extraLen];\n+        IOUtils.readFully(archive, ByteBuffer.wrap(cdExtraData));\n+        ze.setCentralDirectoryExtra(cdExtraData);\n+\n+        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n+\n+        final byte[] comment = new byte[commentLen];\n+        IOUtils.readFully(archive, ByteBuffer.wrap(comment));\n+        ze.setComment(entryEncoding.decode(comment));\n+\n+        if (!hasUTF8Flag && useUnicodeExtraFields) {\n+            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n+        }\n+    }\n+\n+    /**\n+     * If the entry holds a Zip64 extended information extra field,\n+     * read sizes from there if the entry's sizes are set to\n+     * 0xFFFFFFFFF, do the same for the offset of the local file\n+     * header.\n+     *\n+     * <p>Ensures the Zip64 extra either knows both compressed and\n+     * uncompressed size or neither of both as the internal logic in\n+     * ExtraFieldUtils forces the field to create local header data\n+     * even if they are never used - and here a field with only one\n+     * size would be invalid.</p>\n+     */\n+    private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\n+                                                 final OffsetEntry offset,\n+                                                 final int diskStart)\n+        throws IOException {\n+        final Zip64ExtendedInformationExtraField z64 =\n+            (Zip64ExtendedInformationExtraField)\n+            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n+        if (z64 != null) {\n+            final boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n+            final boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n+            final boolean hasRelativeHeaderOffset =\n+                offset.headerOffset == ZIP64_MAGIC;\n+            z64.reparseCentralDirectoryData(hasUncompressedSize,\n+                                            hasCompressedSize,\n+                                            hasRelativeHeaderOffset,\n+                                            diskStart == ZIP64_MAGIC_SHORT);\n+\n+            if (hasUncompressedSize) {\n+                ze.setSize(z64.getSize().getLongValue());\n+            } else if (hasCompressedSize) {\n+                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            }\n+\n+            if (hasCompressedSize) {\n+                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n+            } else if (hasUncompressedSize) {\n+                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+            }\n+\n+            if (hasRelativeHeaderOffset) {\n+                offset.headerOffset =\n+                    z64.getRelativeHeaderOffset().getLongValue();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Length of the \"End of central directory record\" - which is\n+     * supposed to be the last structure of the archive - without file\n+     * comment.\n+     */\n+    static final int MIN_EOCD_SIZE =\n+        /* end of central dir signature    */ WORD\n+        /* number of this disk             */ + SHORT\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir on this disk    */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir                 */ + SHORT\n+        /* size of the central directory   */ + WORD\n+        /* offset of start of central      */\n+        /* directory with respect to       */\n+        /* the starting disk number        */ + WORD\n+        /* zipfile comment length          */ + SHORT;\n+\n+    /**\n+     * Maximum length of the \"End of central directory record\" with a\n+     * file comment.\n+     */\n+    private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE\n+        /* maximum length of zipfile comment */ + ZIP64_MAGIC_SHORT;\n+\n+    /**\n+     * Offset of the field that holds the location of the first\n+     * central directory entry inside the \"End of central directory\n+     * record\" relative to the start of the \"End of central directory\n+     * record\".\n+     */\n+    private static final int CFD_LOCATOR_OFFSET =\n+        /* end of central dir signature    */ WORD\n+        /* number of this disk             */ + SHORT\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir on this disk    */ + SHORT\n+        /* total number of entries in      */\n+        /* the central dir                 */ + SHORT\n+        /* size of the central directory   */ + WORD;\n+\n+    /**\n+     * Length of the \"Zip64 end of central directory locator\" - which\n+     * should be right in front of the \"end of central directory\n+     * record\" if one is present at all.\n+     */\n+    private static final int ZIP64_EOCDL_LENGTH =\n+        /* zip64 end of central dir locator sig */ WORD\n+        /* number of the disk with the start    */\n+        /* start of the zip64 end of            */\n+        /* central directory                    */ + WORD\n+        /* relative offset of the zip64         */\n+        /* end of central directory record      */ + DWORD\n+        /* total number of disks                */ + WORD;\n+\n+    /**\n+     * Offset of the field that holds the location of the \"Zip64 end\n+     * of central directory record\" inside the \"Zip64 end of central\n+     * directory locator\" relative to the start of the \"Zip64 end of\n+     * central directory locator\".\n+     */\n+    private static final int ZIP64_EOCDL_LOCATOR_OFFSET =\n+        /* zip64 end of central dir locator sig */ WORD\n+        /* number of the disk with the start    */\n+        /* start of the zip64 end of            */\n+        /* central directory                    */ + WORD;\n+\n+    /**\n+     * Offset of the field that holds the location of the first\n+     * central directory entry inside the \"Zip64 end of central\n+     * directory record\" relative to the start of the \"Zip64 end of\n+     * central directory record\".\n+     */\n+    private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET =\n+        /* zip64 end of central dir        */\n+        /* signature                       */ WORD\n+        /* size of zip64 end of central    */\n+        /* directory record                */ + DWORD\n+        /* version made by                 */ + SHORT\n+        /* version needed to extract       */ + SHORT\n+        /* number of this disk             */ + WORD\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + WORD\n+        /* total number of entries in the  */\n+        /* central directory on this disk  */ + DWORD\n+        /* total number of entries in the  */\n+        /* central directory               */ + DWORD\n+        /* size of the central directory   */ + DWORD;\n+\n+    /**\n+     * Searches for either the &quot;Zip64 end of central directory\n+     * locator&quot; or the &quot;End of central dir record&quot;, parses\n+     * it and positions the stream at the first central directory\n+     * record.\n+     */\n+    private void positionAtCentralDirectory()\n+        throws IOException {\n+        positionAtEndOfCentralDirectoryRecord();\n+        boolean found = false;\n+        final boolean searchedForZip64EOCD =\n+            archive.position() > ZIP64_EOCDL_LENGTH;\n+        if (searchedForZip64EOCD) {\n+            archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n+            found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n+                                  WORD_BUF);\n+        }\n+        if (!found) {\n+            // not a ZIP64 archive\n+            if (searchedForZip64EOCD) {\n+                skipBytes(ZIP64_EOCDL_LENGTH - WORD);\n+            }\n+            positionAtCentralDirectory32();\n+        } else {\n+            positionAtCentralDirectory64();\n+        }\n+    }\n+\n+    /**\n+     * Parses the &quot;Zip64 end of central directory locator&quot;,\n+     * finds the &quot;Zip64 end of central directory record&quot; using the\n+     * parsed information, parses that and positions the stream at the\n+     * first central directory record.\n+     *\n+     * Expects stream to be positioned right behind the &quot;Zip64\n+     * end of central directory locator&quot;'s signature.\n+     */\n+    private void positionAtCentralDirectory64()\n+        throws IOException {\n+        skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n+                  - WORD /* signature has already been read */);\n+        DWORD_BBUF.rewind();\n+        IOUtils.readFully(archive, DWORD_BBUF);\n+        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n+        if (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n+            throw new ZipException(\"archive's ZIP64 end of central \"\n+                                   + \"directory locator is corrupt.\");\n+        }\n+        skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n+                  - WORD /* signature has already been read */);\n+        DWORD_BBUF.rewind();\n+        IOUtils.readFully(archive, DWORD_BBUF);\n+        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+    }\n+\n+    /**\n+     * Parses the &quot;End of central dir record&quot; and positions\n+     * the stream at the first central directory record.\n+     *\n+     * Expects stream to be positioned at the beginning of the\n+     * &quot;End of central dir record&quot;.\n+     */\n+    private void positionAtCentralDirectory32()\n+        throws IOException {\n+        skipBytes(CFD_LOCATOR_OFFSET);\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n+        archive.position(ZipLong.getValue(WORD_BUF));\n+    }\n+\n+    /**\n+     * Searches for the and positions the stream at the start of the\n+     * &quot;End of central dir record&quot;.\n+     */\n+    private void positionAtEndOfCentralDirectoryRecord()\n+        throws IOException {\n+        final boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n+                                             ZipArchiveOutputStream.EOCD_SIG);\n+        if (!found) {\n+            throw new ZipException(\"archive is not a ZIP archive\");\n+        }\n+    }\n+\n+    /**\n+     * Searches the archive backwards from minDistance to maxDistance\n+     * for the given signature, positions the RandomaccessFile right\n+     * at the signature if it has been found.\n+     */\n+    private boolean tryToLocateSignature(final long minDistanceFromEnd,\n+                                         final long maxDistanceFromEnd,\n+                                         final byte[] sig) throws IOException {\n+        boolean found = false;\n+        long off = archive.size() - minDistanceFromEnd;\n+        final long stopSearching =\n+            Math.max(0L, archive.size() - maxDistanceFromEnd);\n+        if (off >= 0) {\n+            for (; off >= stopSearching; off--) {\n+                archive.position(off);\n+                try {\n+                    WORD_BBUF.rewind();\n+                    IOUtils.readFully(archive, WORD_BBUF);\n+                    WORD_BBUF.flip();\n+                } catch (EOFException ex) {\n+                    break;\n+                }\n+                int curr = WORD_BBUF.get();\n+                if (curr == sig[POS_0]) {\n+                    curr = WORD_BBUF.get();\n+                    if (curr == sig[POS_1]) {\n+                        curr = WORD_BBUF.get();\n+                        if (curr == sig[POS_2]) {\n+                            curr = WORD_BBUF.get();\n+                            if (curr == sig[POS_3]) {\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (found) {\n+            archive.position(off);\n+        }\n+        return found;\n+    }\n+\n+    /**\n+     * Skips the given number of bytes or throws an EOFException if\n+     * skipping failed.\n+     */ \n+    private void skipBytes(final int count) throws IOException {\n+        long currentPosition = archive.position();\n+        long newPosition = currentPosition + count;\n+        if (newPosition > archive.size()) {\n+            throw new EOFException();\n+        }\n+        archive.position(newPosition);\n+    }\n+\n+    /**\n+     * Number of bytes in local file header up to the &quot;length of\n+     * filename&quot; entry.\n+     */\n+    private static final long LFH_OFFSET_FOR_FILENAME_LENGTH =\n+        /* local file header signature     */ WORD\n+        /* version needed to extract       */ + SHORT\n+        /* general purpose bit flag        */ + SHORT\n+        /* compression method              */ + SHORT\n+        /* last mod file time              */ + SHORT\n+        /* last mod file date              */ + SHORT\n+        /* crc-32                          */ + WORD\n+        /* compressed size                 */ + WORD\n+        /* uncompressed size               */ + WORD;\n+\n+    /**\n+     * Walks through all recorded entries and adds the data available\n+     * from the local file header.\n+     *\n+     * <p>Also records the offsets for the data to read from the\n+     * entries.</p>\n+     */\n+    private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\n+                                            entriesWithoutUTF8Flag)\n+        throws IOException {\n+        for (final ZipArchiveEntry zipArchiveEntry : entries) {\n+            // entries is filled in populateFromCentralDirectory and\n+            // never modified\n+            final Entry ze = (Entry) zipArchiveEntry;\n+            final OffsetEntry offsetEntry = ze.getOffsetEntry();\n+            final long offset = offsetEntry.headerOffset;\n+            archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n+            WORD_BBUF.rewind();\n+            IOUtils.readFully(archive, WORD_BBUF);\n+            WORD_BBUF.flip();\n+            WORD_BBUF.get(SHORT_BUF);\n+            final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n+            WORD_BBUF.get(SHORT_BUF);\n+            final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n+            skipBytes(fileNameLen);\n+            final byte[] localExtraData = new byte[extraFieldLen];\n+            IOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\n+            ze.setExtra(localExtraData);\n+            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n+                + SHORT + SHORT + fileNameLen + extraFieldLen;\n+\n+            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n+                final NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n+                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n+                                                         nc.comment);\n+            }\n+\n+            final String name = ze.getName();\n+            LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+            if (entriesOfThatName == null) {\n+                entriesOfThatName = new LinkedList<>();\n+                nameMap.put(name, entriesOfThatName);\n+            }\n+            entriesOfThatName.addLast(ze);\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the archive starts with a LFH.  If it doesn't,\n+     * it may be an empty archive.\n+     */\n+    private boolean startsWithLocalFileHeader() throws IOException {\n+        archive.position(0);\n+        WORD_BBUF.rewind();\n+        IOUtils.readFully(archive, WORD_BBUF);\n+        return Arrays.equals(WORD_BUF, ZipArchiveOutputStream.LFH_SIG);\n+    }\n+\n+    /**\n+     * InputStream that delegates requests to the underlying\n+     * SeekableByteChannel, making sure that only bytes from a certain\n+     * range can be read.\n+     */\n+    private class BoundedInputStream extends InputStream {\n+        private static final int MAX_BUF_LEN = 8192;\n+        private final ByteBuffer buffer;\n+        private long remaining;\n+        private long loc;\n+        private boolean addDummyByte = false;\n+\n+        BoundedInputStream(final long start, final long remaining) {\n+            this.remaining = remaining;\n+            loc = start;\n+            if (remaining < MAX_BUF_LEN && remaining > 0) {\n+                buffer = ByteBuffer.allocate((int) remaining);\n+            } else {\n+                buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n+            }\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (remaining-- <= 0) {\n+                if (addDummyByte) {\n+                    addDummyByte = false;\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            synchronized (archive) {\n+                archive.position(loc++);\n+                int read = read(1);\n+                if (read < 0) {\n+                    return read;\n+                }\n+                return buffer.get() & 0xff;\n+            }\n+        }\n+\n+        @Override\n+        public int read(final byte[] b, final int off, int len) throws IOException {\n+            if (remaining <= 0) {\n+                if (addDummyByte) {\n+                    addDummyByte = false;\n+                    b[off] = 0;\n+                    return 1;\n+                }\n+                return -1;\n+            }\n+\n+            if (len <= 0) {\n+                return 0;\n+            }\n+\n+            if (len > remaining) {\n+                len = (int) remaining;\n+            }\n+            ByteBuffer buf;\n+            int ret = -1;\n+            synchronized (archive) {\n+                archive.position(loc);\n+                if (len <= buffer.capacity()) {\n+                    buf = buffer;\n+                    ret = read(len);\n+                } else {\n+                    buf = ByteBuffer.allocate(len);\n+                    ret = archive.read(buf);\n+                    buf.flip();\n+                }\n+            }\n+            if (ret > 0) {\n+                buf.get(b, off, ret);\n+                loc += ret;\n+                remaining -= ret;\n+            }\n+            return ret;\n+        }\n+\n+        private int read(int len) throws IOException {\n+            buffer.rewind().limit(len);\n+            int read = archive.read(buffer);\n+            buffer.flip();\n+            return read;\n+        }\n+\n+        /**\n+         * Inflater needs an extra dummy byte for nowrap - see\n+         * Inflater's javadocs.\n+         */\n+        void addDummy() {\n+            addDummyByte = true;\n+        }\n+    }\n+\n+    private static final class NameAndComment {\n+        private final byte[] name;\n+        private final byte[] comment;\n+        private NameAndComment(final byte[] name, final byte[] comment) {\n+            this.name = name;\n+            this.comment = comment;\n+        }\n+    }\n+\n+    /**\n+     * Compares two ZipArchiveEntries based on their offset within the archive.\n+     *\n+     * <p>Won't return any meaningful results if one of the entries\n+     * isn't part of the archive at all.</p>\n+     *\n+     * @since 1.1\n+     */\n+    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n+        new Comparator<ZipArchiveEntry>() {\n+        @Override\n+        public int compare(final ZipArchiveEntry e1, final ZipArchiveEntry e2) {\n+            if (e1 == e2) {\n+                return 0;\n+            }\n+\n+            final Entry ent1 = e1 instanceof Entry ? (Entry) e1 : null;\n+            final Entry ent2 = e2 instanceof Entry ? (Entry) e2 : null;\n+            if (ent1 == null) {\n+                return 1;\n+            }\n+            if (ent2 == null) {\n+                return -1;\n+            }\n+            final long val = (ent1.getOffsetEntry().headerOffset\n+                        - ent2.getOffsetEntry().headerOffset);\n+            return val == 0 ? 0 : val < 0 ? -1 : +1;\n+        }\n+    };\n+\n+    /**\n+     * Extends ZipArchiveEntry to store the offset within the archive.\n+     */\n+    private static class Entry extends ZipArchiveEntry {\n+\n+        private final OffsetEntry offsetEntry;\n+\n+        Entry(final OffsetEntry offset) {\n+            this.offsetEntry = offset;\n+        }\n+\n+        OffsetEntry getOffsetEntry() {\n+            return offsetEntry;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 3 * super.hashCode()\n+                + (int) (offsetEntry.headerOffset % Integer.MAX_VALUE);\n+        }\n+\n+        @Override\n+        public boolean equals(final Object other) {\n+            if (super.equals(other)) {\n+                // super.equals would return false if other were not an Entry\n+                final Entry otherEntry = (Entry) other;\n+                return offsetEntry.headerOffset\n+                        == otherEntry.offsetEntry.headerOffset\n+                    && offsetEntry.dataOffset\n+                        == otherEntry.offsetEntry.dataOffset;\n+            }\n+            return false;\n+        }\n+    }\n+}", "timestamp": 1481318914, "metainfo": ""}