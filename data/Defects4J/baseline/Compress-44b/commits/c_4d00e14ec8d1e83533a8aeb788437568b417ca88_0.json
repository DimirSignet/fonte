{"sha": "4d00e14ec8d1e83533a8aeb788437568b417ca88", "log": "COMPRESS-405 Create Fixed Length Block OutputStream / WriteableByteChannel  This commit provides a new class that is an OutputStream and WritableByteChannel, and which supports writing to a destination output stream or byte channel in fixed size blocks. Internally, all writes are made using NIO. If the destination is a  FileOutputStream the existing channel is used. Other OutputStreams are wrapped with a custom channel implementation which does not attempt to split writes into chunks.  If the target channel fails to write the entire buffer in a single call, an exception is thrown,  Incoming data is accumulated in a ByteBuffer until a complete block is ready, then written to the target. If  WritableByteChannel::write(ByteBuffer)  method is called, the code will attempt to avoid copying data into the buffer if the buffer is empty, and a complete block is available.  The class and UnitTest are in compress/utils . This is a MINOR change - thus the version number for the package should be increated to 1.15.0.  Signed-off-by: Simon Spero <sesuncedu@gmail.com>", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/FixedLengthBlockOutputStream.java\n+package org.apache.commons.compress.utils;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class FixedLengthBlockOutputStream extends OutputStream implements WritableByteChannel,\n+    AutoCloseable {\n+\n+    private final WritableByteChannel out;\n+    private final int blockSize;\n+    private final ByteBuffer buffer;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    public FixedLengthBlockOutputStream(OutputStream os, int blockSize) {\n+        if (os instanceof FileOutputStream) {\n+            FileOutputStream fileOutputStream = (FileOutputStream) os;\n+            out = fileOutputStream.getChannel();\n+            buffer = ByteBuffer.allocateDirect(blockSize);\n+        } else {\n+            out = new BufferAtATimeOutputChannel(os);\n+            buffer = ByteBuffer.allocate(blockSize);\n+        }\n+        this.blockSize = blockSize;\n+    }\n+\n+    public FixedLengthBlockOutputStream(WritableByteChannel out, int blockSize) {\n+        this.out = out;\n+        this.blockSize = blockSize;\n+        this.buffer = ByteBuffer.allocateDirect(blockSize);\n+    }\n+\n+    private void maybeFlush() throws IOException {\n+        if (!buffer.hasRemaining()) {\n+            writeBlock();\n+        }\n+    }\n+\n+    private void writeBlock() throws IOException {\n+        buffer.flip();\n+        int i = out.write(buffer);\n+        boolean hasRemaining = buffer.hasRemaining();\n+        if (i != blockSize || hasRemaining) {\n+            String msg = String\n+                .format(\"Failed to write %,d bytes atomically. Only wrote  %,d\",\n+                    blockSize, i);\n+            throw new IOException(msg);\n+        }\n+        buffer.clear();\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        if(!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+        buffer.put((byte) b);\n+        maybeFlush();\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        if(!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+        while (len > 0) {\n+            int n = Math.min(len, buffer.remaining());\n+            buffer.put(b, off, n);\n+            maybeFlush();\n+            len -= n;\n+            off += n;\n+        }\n+    }\n+\n+    @Override\n+    public int write(ByteBuffer src) throws IOException {\n+        if(!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+        int srcRemaining = src.remaining();\n+\n+        if (srcRemaining < buffer.remaining()) {\n+            // if don't have enough bytes in src to fill up a block we must buffer\n+            buffer.put(src);\n+        } else {\n+            int srcLeft = srcRemaining;\n+            int savedLimit = src.limit();\n+            // If we're not at the start of buffer, we have some bytes already  buffered\n+            // fill up the reset of buffer and write the block.\n+            if (buffer.position() != 0) {\n+                int n = buffer.remaining();\n+                src.limit(src.position() + n);\n+                buffer.put(src);\n+                writeBlock();\n+                srcLeft -= n;\n+            }\n+            // whilst we have enough bytes in src for complete blocks,\n+            // write them directly from src without copying them to buffer\n+            while (srcLeft >= blockSize) {\n+                src.limit(src.position() + blockSize);\n+                out.write(src);\n+                srcLeft -= blockSize;\n+            }\n+            // copy any remaining bytes into buffer\n+            src.limit(savedLimit);\n+            buffer.put(src);\n+        }\n+        return srcRemaining;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        if(!out.isOpen()) {\n+            closed.set(true);\n+        }\n+        return !closed.get();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (closed.compareAndSet(false, true)) {\n+            if (buffer.position() != 0) {\n+                padLastBlock();\n+                writeBlock();\n+            }\n+            out.close();\n+        }\n+    }\n+\n+    private void padLastBlock() {\n+        buffer.order(ByteOrder.nativeOrder());\n+        int bytesToWrite = buffer.remaining();\n+        if (bytesToWrite > 8) {\n+            int align = (buffer.position() & 7);\n+            if (align != 0) {\n+                int limit = 8 - align;\n+                for (int i = 0; i < limit; i++) {\n+                    buffer.put((byte) 0);\n+                }\n+                bytesToWrite -= limit;\n+            }\n+\n+            while (bytesToWrite >= 8) {\n+                buffer.putLong(0L);\n+                bytesToWrite -= 8;\n+            }\n+        }\n+        while (buffer.hasRemaining()) {\n+            buffer.put((byte) 0);\n+        }\n+    }\n+\n+    /**\n+     * Helper class to provide channel wrapper for arbitrary output stream that doesn't alter the\n+     * size of writes.  We can't use Channels.newChannel, because for non FileOutputStreams, it\n+     * breaks up writes into 8KB max chunks. Since the purpose of this class is to always write\n+     * complete blocks, we need to write a simple class to take care of it.\n+     */\n+    private static class BufferAtATimeOutputChannel implements WritableByteChannel {\n+\n+        private final OutputStream out;\n+        private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+        private BufferAtATimeOutputChannel(OutputStream out) {\n+            this.out = out;\n+        }\n+\n+        @Override\n+        public int write(ByteBuffer buffer) throws IOException {\n+            assert isOpen() : \"somehow trying to write to closed BufferAtATimeOutputChannel\";\n+            assert buffer.hasArray() :\n+                \"direct buffer somehow written to BufferAtATimeOutputChannel\";\n+\n+            try {\n+                int pos = buffer.position();\n+                int len = buffer.limit() - pos;\n+                out.write(buffer.array(), buffer.arrayOffset() + pos, len);\n+                buffer.position(buffer.limit());\n+                return len;\n+            } catch (IOException e) {\n+                  try {\n+                      close();\n+                  } finally {\n+                      throw e;\n+                  }\n+            }\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return !closed.get();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (closed.compareAndSet(false, true)) {\n+                out.close();\n+            }\n+        }\n+\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/utils/FixedLengthBlockOutputStreamTest.java\n+package org.apache.commons.compress.utils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.hamcrest.core.IsInstanceOf;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.GreaterOrEqual;\n+\n+public class FixedLengthBlockOutputStreamTest {\n+\n+    @Test\n+    public void testSmallWrite() throws IOException {\n+        testWriteAndPad(10240, \"hello world!\\n\", false);\n+        testWriteAndPad(512, \"hello world!\\n\", false);\n+        testWriteAndPad(11, \"hello world!\\n\", false);\n+        testWriteAndPad(3, \"hello world!\\n\", false);\n+    }\n+\n+    @Test\n+    public void testSmallWriteToStream() throws IOException {\n+        testWriteAndPadToStream(10240, \"hello world!\\n\", false);\n+        testWriteAndPadToStream(512, \"hello world!\\n\", false);\n+        testWriteAndPadToStream(11, \"hello world!\\n\", false);\n+        testWriteAndPadToStream(3, \"hello     world!\\n\", false);\n+    }\n+\n+    @Test\n+    public void testWriteSingleBytes() throws IOException {\n+        int blockSize = 4;\n+        MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, false);\n+        ByteArrayOutputStream bos = mock.bos;\n+        String text = \"hello world avengers\";\n+        byte msg[] = text.getBytes();\n+        int len = msg.length;\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\n+            for (int i = 0; i < len; i++) {\n+                out.write(msg[i]);\n+            }\n+        }\n+        byte[] output = bos.toByteArray();\n+\n+        validate(blockSize, msg, output);\n+    }\n+\n+\n+    @Test\n+    public void testWriteBuf() throws IOException {\n+        String hwa = \"hello world avengers\";\n+        testBuf(4, hwa);\n+        testBuf(512, hwa);\n+        testBuf(10240, hwa);\n+        testBuf(11, hwa + hwa + hwa);\n+    }\n+\n+    @Test\n+    public void testMultiWriteBuf() throws IOException {\n+        int blockSize = 13;\n+        MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, false);\n+        String testString = \"hello world\";\n+        byte msg[] = testString.getBytes();\n+        int reps = 17;\n+\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\n+            for (int i = 0; i < reps; i++) {\n+                ByteBuffer buf = getByteBuffer(msg);\n+                out.write(buf);\n+            }\n+        }\n+        ByteArrayOutputStream bos = mock.bos;\n+        double v = Math.ceil((reps * msg.length) / (double) blockSize) * blockSize;\n+        assertEquals(\"wrong size\", (long) v, bos.size());\n+        int strLen = msg.length * reps;\n+        byte[] output = bos.toByteArray();\n+        String l = new String(output, 0, strLen);\n+        StringBuilder buf = new StringBuilder(strLen);\n+        for (int i = 0; i < reps; i++) {\n+            buf.append(testString);\n+        }\n+        assertEquals(buf.toString(), l);\n+        for (int i = strLen; i < output.length; i++) {\n+            assertEquals(0, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testPartialWritingThrowsException() {\n+        try {\n+            testWriteAndPad(512, \"hello world!\\n\", true);\n+            fail(\"Exception for partial write not thrown\");\n+        } catch (IOException e) {\n+            String msg = e.getMessage();\n+            assertEquals(\"exception message\",\n+                \"Failed to write 512 bytes atomically. Only wrote  511\", msg);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testWriteFailsAfterFLClosedThrowsException() {\n+        try {\n+            FixedLengthBlockOutputStream out = getClosedFLBOS();\n+            out.write(1);\n+            fail(\"expected Closed Channel Exception\");\n+        } catch (IOException e) {\n+            assertThat(e, IsInstanceOf.instanceOf(ClosedChannelException.class));\n+            // expected\n+        }\n+        try {\n+            FixedLengthBlockOutputStream out = getClosedFLBOS();\n+            out.write(new byte[] {0,1,2,3});\n+            fail(\"expected Closed Channel Exception\");\n+        } catch (IOException e) {\n+            assertThat(e, IsInstanceOf.instanceOf(ClosedChannelException.class));\n+            // expected\n+        }\n+\n+        try {\n+            FixedLengthBlockOutputStream out = getClosedFLBOS();\n+            out.write(ByteBuffer.wrap(new byte[] {0,1,2,3}));\n+            fail(\"expected Closed Channel Exception\");\n+        } catch (IOException e) {\n+            assertThat(e, IsInstanceOf.instanceOf(ClosedChannelException.class));\n+            // expected\n+        }\n+\n+    }\n+\n+    private FixedLengthBlockOutputStream getClosedFLBOS() throws IOException {\n+        int blockSize = 512;\n+        FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(\n+            new MockOutputStream(blockSize, false), blockSize);\n+        out.write(1);\n+        assertTrue(out.isOpen());\n+        out.close();\n+        assertFalse(out.isOpen());\n+        return out;\n+    }\n+\n+    @Test\n+    public void testWriteFailsAfterDestClosedThrowsException() {\n+        int blockSize = 2;\n+        MockOutputStream mock = new MockOutputStream(blockSize, false);\n+        FixedLengthBlockOutputStream out =\n+            new FixedLengthBlockOutputStream(mock, blockSize);\n+        try {\n+            out.write(1);\n+            assertTrue(out.isOpen());\n+            mock.close();\n+            out.write(1);\n+            fail(\"expected IO Exception\");\n+        } catch (IOException e) {\n+            // expected\n+        }\n+        assertFalse(out.isOpen());\n+    }\n+\n+    @Test\n+    public void testWithFileOutputStream() throws IOException {\n+        final Path tempFile = Files.createTempFile(\"xxx\", \"yyy\");\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Files.deleteIfExists(tempFile);\n+                } catch (IOException e) {\n+                }\n+            }\n+        });\n+        int blockSize = 512;\n+        int reps = 1000;\n+        OutputStream os = new FileOutputStream(tempFile.toFile());\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(\n+            os, blockSize)) {\n+            DataOutputStream dos = new DataOutputStream(out);\n+            for (int i = 0; i < reps; i++) {\n+               dos.writeInt(i);\n+            }\n+        }\n+        long expectedDataSize = reps * 4L;\n+        long expectedFileSize = (long)Math.ceil(expectedDataSize/(double)blockSize)*blockSize;\n+        assertEquals(\"file size\",expectedFileSize, Files.size(tempFile));\n+        DataInputStream din = new DataInputStream(Files.newInputStream(tempFile));\n+        for(int i=0;i<reps;i++) {\n+            assertEquals(\"file int\",i,din.readInt());\n+        }\n+        for(int i=0;i<expectedFileSize - expectedDataSize;i++) {\n+            assertEquals(0,din.read());\n+        }\n+        assertEquals(-1,din.read());\n+    }\n+\n+    private void testBuf(int blockSize, String text) throws IOException {\n+        MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, false);\n+\n+        ByteArrayOutputStream bos = mock.bos;\n+        byte msg[] = text.getBytes();\n+        ByteBuffer buf = getByteBuffer(msg);\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\n+            out.write(buf);\n+        }\n+        double v = Math.ceil(msg.length / (double) blockSize) * blockSize;\n+        assertEquals(\"wrong size\", (long) v, bos.size());\n+        byte[] output = bos.toByteArray();\n+        String l = new String(output, 0, msg.length);\n+        assertEquals(text, l);\n+        for (int i = msg.length; i < bos.size(); i++) {\n+            assertEquals(String.format(\"output[%d]\", i), 0, output[i]);\n+\n+        }\n+    }\n+\n+    private ByteBuffer getByteBuffer(byte[] msg) {\n+        int len = msg.length;\n+        ByteBuffer buf = ByteBuffer.allocate(len);\n+        buf.put(msg);\n+        buf.flip();\n+        return buf;\n+    }\n+\n+\n+    private void testWriteAndPad(int blockSize, String text, boolean doPartialWrite)\n+        throws IOException {\n+        MockWritableByteChannel mock = new MockWritableByteChannel(blockSize, doPartialWrite);\n+        byte[] msg = text.getBytes(StandardCharsets.US_ASCII);\n+\n+        ByteArrayOutputStream bos = mock.bos;\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\n+\n+            out.write(msg);\n+            assertEquals(\"no partial write\", (msg.length / blockSize) * blockSize, bos.size());\n+        }\n+        validate(blockSize, msg, bos.toByteArray());\n+    }\n+\n+    private void testWriteAndPadToStream(int blockSize, String text, boolean doPartialWrite)\n+        throws IOException {\n+        MockOutputStream mock = new MockOutputStream(blockSize, doPartialWrite);\n+        byte[] msg = text.getBytes(StandardCharsets.US_ASCII);\n+\n+        ByteArrayOutputStream bos = mock.bos;\n+        try (FixedLengthBlockOutputStream out = new FixedLengthBlockOutputStream(mock, blockSize)) {\n+            out.write(msg);\n+            assertEquals(\"no partial write\", (msg.length / blockSize) * blockSize, bos.size());\n+        }\n+        validate(blockSize, msg, bos.toByteArray());\n+\n+    }\n+\n+\n+    private void validate(int blockSize, byte[] expectedBytes, byte[] actualBytes) {\n+        double v = Math.ceil(expectedBytes.length / (double) blockSize) * blockSize;\n+        assertEquals(\"wrong size\", (long) v, actualBytes.length);\n+        assertContainsAtOffset(\"output\", expectedBytes, 0, actualBytes);\n+        for (int i = expectedBytes.length; i < actualBytes.length; i++) {\n+            assertEquals(String.format(\"output[%d]\", i), 0, actualBytes[i]);\n+\n+        }\n+    }\n+\n+    private static void assertContainsAtOffset(String msg, byte[] expected, int offset,\n+        byte[] actual) {\n+        assertThat(actual.length, new GreaterOrEqual<>(offset + expected.length));\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals(String.format(\"%s ([%d])\", msg, i), expected[i], actual[i + offset]);\n+        }\n+    }\n+\n+    private static class MockOutputStream extends OutputStream {\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        private final int requiredWriteSize;\n+        private final boolean doPartialWrite;\n+        private AtomicBoolean closed = new AtomicBoolean();\n+\n+        private MockOutputStream(int requiredWriteSize, boolean doPartialWrite) {\n+            this.requiredWriteSize = requiredWriteSize;\n+            this.doPartialWrite = doPartialWrite;\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            checkIsOpen();\n+            assertEquals(\"write size\", requiredWriteSize, len);\n+            if (doPartialWrite) {\n+                len--;\n+            }\n+            bos.write(b, off, len);\n+        }\n+\n+        private void checkIsOpen() throws IOException {\n+            if (closed.get()) {\n+                IOException e = new IOException(\"Closed\");\n+                throw e;\n+            }\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            checkIsOpen();\n+            assertEquals(\"write size\", requiredWriteSize, 1);\n+            bos.write(b);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (closed.compareAndSet(false, true)) {\n+                bos.close();\n+            }\n+        }\n+    }\n+\n+    private static class MockWritableByteChannel implements WritableByteChannel {\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        private final int requiredWriteSize;\n+        private final boolean doPartialWrite;\n+\n+        private MockWritableByteChannel(int requiredWriteSize, boolean doPartialWrite) {\n+            this.requiredWriteSize = requiredWriteSize;\n+            this.doPartialWrite = doPartialWrite;\n+        }\n+\n+        @Override\n+        public int write(ByteBuffer src) throws IOException {\n+            assertEquals(\"write size\", requiredWriteSize, src.remaining());\n+            if (doPartialWrite) {\n+                src.limit(src.limit() - 1);\n+            }\n+            int bytesOut = src.remaining();\n+            while (src.hasRemaining()) {\n+                bos.write(src.get());\n+            }\n+            return bytesOut;\n+        }\n+\n+        AtomicBoolean closed = new AtomicBoolean();\n+\n+        @Override\n+        public boolean isOpen() {\n+            return !closed.get();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            closed.compareAndSet(false, true);\n+        }\n+    }\n+}", "timestamp": 1497543484, "metainfo": ""}