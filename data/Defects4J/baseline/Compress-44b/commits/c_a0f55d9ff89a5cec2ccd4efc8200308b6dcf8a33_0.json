{"sha": "a0f55d9ff89a5cec2ccd4efc8200308b6dcf8a33", "log": "BitInputStream: Optimize a bit to reach previous run times.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n             throw new IOException(\"bad block header\");\n         }\n         this.storedBlockCRC = bsGetInt();\n-        this.blockRandomised = bsR(1) == 1;\n+        this.blockRandomised = bsR(bin, 1) == 1;\n \n         /**\n          * Allocate data here instead in constructor, so we do not allocate\n      * @return\n      * @throws IOException\n      */\n-    private int bsR(final int n) throws IOException {\n+    private static int bsR(BitInputStream bin, final int n) throws IOException {\n         long thech = bin.readBits(n);\n         if (thech < 0) {\n             throw new IOException(\"unexpected end of stream\");\n         return (int) thech;\n     }\n \n-    private boolean bsGetBit() throws IOException {\n-        return bsR(1) != 0;\n+    private static boolean bsGetBit(BitInputStream bin) throws IOException {\n+        return bsR(bin, 1) != 0;\n     }\n \n     private char bsGetUByte() throws IOException {\n-        return (char) bsR(8);\n+        return (char) bsR(bin, 8);\n     }\n \n     private int bsGetInt() throws IOException {\n-        return (int) bsR(32);\n+        return (int) bsR(bin, 32);\n     }\n \n     /**\n     }\n \n     private void recvDecodingTables() throws IOException {\n+        final BitInputStream bin = this.bin;\n         final Data dataShadow = this.data;\n         final boolean[] inUse = dataShadow.inUse;\n         final byte[] pos = dataShadow.recvDecodingTables_pos;\n \n         /* Receive the mapping table */\n         for (int i = 0; i < 16; i++) {\n-            if (bsGetBit()) {\n+            if (bsGetBit(bin)) {\n                 inUse16 |= 1 << i;\n             }\n         }\n             if ((inUse16 & (1 << i)) != 0) {\n                 final int i16 = i << 4;\n                 for (int j = 0; j < 16; j++) {\n-                    if (bsGetBit()) {\n+                    if (bsGetBit(bin)) {\n                         inUse[i16 + j] = true;\n                     }\n                 }\n \n         makeMaps();\n         final int alphaSize = this.nInUse + 2;\n-\n         /* Now the selectors */\n-        final int nGroups = bsR(3);\n-        final int nSelectors = bsR(15);\n+        final int nGroups = bsR(bin, 3);\n+        final int nSelectors = bsR(bin, 15);\n \n         for (int i = 0; i < nSelectors; i++) {\n             int j = 0;\n-            while (bsGetBit()) {\n+            while (bsGetBit(bin)) {\n                 j++;\n             }\n             selectorMtf[i] = (byte) j;\n \n         /* Now the coding tables */\n         for (int t = 0; t < nGroups; t++) {\n-            int curr = bsR(5);\n+            int curr = bsR(bin, 5);\n             final char[] len_t = len[t];\n             for (int i = 0; i < alphaSize; i++) {\n-                while (bsGetBit()) {\n-                    curr += bsGetBit() ? -1 : 1;\n+                while (bsGetBit(bin)) {\n+                    curr += bsGetBit(bin) ? -1 : 1;\n                 }\n                 len_t[i] = (char) curr;\n             }\n     }\n \n     private void getAndMoveToFrontDecode() throws IOException {\n-        this.origPtr = bsR(24);\n+        final BitInputStream bin = this.bin;\n+        this.origPtr = bsR(bin, 24);\n         recvDecodingTables();\n \n         final Data dataShadow = this.data;\n                     }\n \n                     int zn = minLens_zt;\n-                    int zvec = (int) bsR(zn);\n+                    int zvec = (int) bsR(bin, zn);\n                     while(zvec > limit_zt[zn]) {\n                         zn++;\n-                        zvec = (zvec << 1) | bsR(1);\n+                        zvec = (zvec << 1) | bsR(bin, 1);\n                     }\n                     nextSym = perm_zt[zvec - base_zt[zn]];\n                 }\n                 }\n \n                 int zn = minLens_zt;\n-                int zvec = (int) bsR(zn);\n+                int zvec = (int) bsR(bin, zn);\n                 while(zvec > limit_zt[zn]) {\n                     zn++;\n-                    zvec = (zvec << 1) | (int) bsR(1);\n+                    zvec = (zvec << 1) | (int) bsR(bin, 1);\n                 }\n                 nextSym = perm_zt[zvec - base_zt[zn]];\n             }\n         final int zt = dataShadow.selector[groupNo] & 0xff;\n         final int[] limit_zt = dataShadow.limit[zt];\n         int zn = dataShadow.minLens[zt];\n-        int zvec = bsR(zn);\n+        int zvec = bsR(bin, zn);\n         while (zvec > limit_zt[zn]) {\n             zn++;\n-            zvec = (zvec << 1) | (int) bsR(1);\n+            zvec = (zvec << 1) | (int) bsR(bin, 1);\n         }\n \n         return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n         this.in = in;\n         this.byteOrder = byteOrder;\n     }\n-    \n+\n     @Override\n     public void close() throws IOException {\n         in.close();\n     }\n-    \n+\n     /**\n      * Clears the cache of bits that have been read from the\n      * underlying stream but not yet provided via {@link #readBits}.\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n         }\n+        if(ensureCache(count))\n+            return -1;\n+\n+        if (bitsCachedSize < count) {\n+            return processBitsGreater57(count);\n+        } else {\n+            final long bitsOut;\n+            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+                bitsOut = (bitsCached & MASKS[count]);\n+                bitsCached >>>= count;\n+            } else {\n+                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n+            }\n+            bitsCachedSize -= count;\n+            return bitsOut;\n+        }\n+    }\n+\n+    private long processBitsGreater57(final int count) throws IOException {\n+        final long bitsOut;\n+        int overflowBits = 0;\n+        long overflow = 0l;\n+\n+        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n+        int bitsToAddCount = count - bitsCachedSize;\n+        overflowBits = 8 - bitsToAddCount;\n+        final long nextByte = in.read();\n+        if (nextByte < 0) {\n+            return nextByte;\n+        }\n+        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+            long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n+            bitsCached |= (bitsToAdd << bitsCachedSize);\n+            overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n+        } else {\n+            bitsCached <<= bitsToAddCount;\n+            long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n+            bitsCached |= bitsToAdd;\n+            overflow = nextByte & MASKS[overflowBits];\n+        }\n+        bitsCachedSize = count;\n+        bitsOut = bitsCached & MASKS[count];\n+        bitsCached = overflow;\n+        bitsCachedSize = overflowBits;\n+        return bitsOut;\n+\t}\n+\n+\t/**\n+     * Fills the cache up to 56 bits\n+     * @param count\n+     * @return return true, when EOF\n+     * @throws IOException\n+     */\n+    private boolean ensureCache(final int count) throws IOException {\n         while (bitsCachedSize < count && bitsCachedSize < 57) {\n             final long nextByte = in.read();\n             if (nextByte < 0) {\n-                return nextByte;\n+                return true;\n             }\n             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                 bitsCached |= (nextByte << bitsCachedSize);\n             }\n             bitsCachedSize += 8;\n         }\n-        int overflowBits = 0;\n-        long overflow = 0l;\n-        if (bitsCachedSize < count) {\n-            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n-            int bitsToAddCount = count - bitsCachedSize;\n-            overflowBits = 8 - bitsToAddCount;\n-            final long nextByte = in.read();\n-            if (nextByte < 0) {\n-                return nextByte;\n-            }\n-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n-                bitsCached |= (bitsToAdd << bitsCachedSize);\n-                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n-            } else {\n-                bitsCached <<= bitsToAddCount;\n-                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n-                bitsCached |= bitsToAdd;\n-                overflow = nextByte & MASKS[overflowBits];\n-            }\n-            bitsCachedSize = count;\n-        }\n-        \n-        final long bitsOut;\n-        if (overflowBits == 0) {\n-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-                bitsOut = (bitsCached & MASKS[count]);\n-                bitsCached >>>= count;\n-            } else {\n-                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n-            }\n-            bitsCachedSize -= count;\n-        } else {\n-            bitsOut = bitsCached & MASKS[count];\n-            bitsCached = overflow;\n-            bitsCachedSize = overflowBits;\n-        }\n-        return bitsOut;\n+        return false;\n     }\n }", "timestamp": 1486231019, "metainfo": ""}