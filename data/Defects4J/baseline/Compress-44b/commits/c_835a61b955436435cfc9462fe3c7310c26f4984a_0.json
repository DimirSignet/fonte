{"sha": "835a61b955436435cfc9462fe3c7310c26f4984a", "log": "COMPRESS-271 rough, pretty much untested inputstream for frame lz4", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PushbackInputStream;\n+import java.util.Arrays;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.BoundedInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+/**\n+ * CompressorInputStream for the LZ4 frame format.\n+ *\n+ * <p>Based on the \"spec\" in the version \"1.5.1 (31/03/2015)\"</p>\n+ *\n+ * @see <a href=\"http://lz4.github.io/lz4/lz4_Frame_format.html\">LZ4 Frame Format Description</a>\n+ * @since 1.14\n+ */\n+public class FramedLZ4CompressorInputStream extends CompressorInputStream {\n+    /*\n+     * TODO before releasing 1.14:\n+     *\n+     * + xxhash32 checksum validation\n+     * + decompressConcatenated\n+     * + block dependence\n+     */\n+\n+    // used by FramedLZ4CompressorOutputStream as well\n+    static final byte[] LZ4_SIGNATURE = new byte[] { //NOSONAR\n+        4, 0x22, 0x4d, 0x18\n+    };\n+\n+    static final int VERSION_MASK = 0xC0;\n+    static final int SUPPORTED_VERSION = 0x40;\n+    static final int BLOCK_INDEPENDENCE_MASK = 0x20;\n+    static final int BLOCK_CHECKSUM_MASK = 0x10;\n+    static final int CONTENT_SIZE_MASK = 0x08;\n+    static final int CONTENT_CHECKSUM_MASK = 0x04;\n+    static final int BLOCK_MAX_SIZE_MASK = 0x70;\n+    static final int UNCOMPRESSED_FLAG_MASK = 0x80000000;\n+\n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return readOneByte();\n+        }\n+    };\n+\n+    private final InputStream in;\n+\n+    private boolean expectBlockChecksum;\n+    private boolean expectContentSize;\n+    private boolean expectContentChecksum;\n+\n+    private InputStream currentBlock;\n+    private boolean endReached, inUncompressed;\n+\n+    /**\n+     * Creates a new input stream that decompresses streams compressed\n+     * using the LZ4 frame format.\n+     * @param in  the InputStream from which to read the compressed data\n+     * @throws IOException if reading fails\n+     */\n+    public FramedLZ4CompressorInputStream(InputStream in) throws IOException {\n+        this.in = in;\n+        readSignature();\n+        readFrameDescriptor();\n+        nextBlock();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        if (currentBlock != null) {\n+            currentBlock.close();\n+            currentBlock = null;\n+        }\n+        in.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        if (endReached) {\n+            return -1;\n+        }\n+        int r = readOnce(b, off, len);\n+        if (r == -1) {\n+            nextBlock();\n+            if (!endReached) {\n+                r = readOnce(b, off, len);\n+            }\n+        }\n+        return r;\n+    }\n+\n+    private void readSignature() throws IOException {\n+        final byte[] b = new byte[4];\n+        final int read = IOUtils.readFully(in, b);\n+        count(read);\n+        if (4 != read || !matches(b, 4)) {\n+            throw new IOException(\"Not a LZ4 frame stream\");\n+        }\n+    }\n+\n+    private void readFrameDescriptor() throws IOException {\n+        int flags = readOneByte();\n+        if (flags == -1) {\n+            throw new IOException(\"Premature end of stream while reading frame flags\");\n+        }\n+        if ((flags & VERSION_MASK) != SUPPORTED_VERSION) {\n+            throw new IOException(\"Unsupported version \" + (flags >> 6));\n+        }\n+        if ((flags & BLOCK_INDEPENDENCE_MASK) == 0) {\n+            throw new IOException(\"Block dependence is not supported\");\n+        }\n+        expectBlockChecksum = (flags & BLOCK_CHECKSUM_MASK) != 0;\n+        expectContentSize = (flags & CONTENT_SIZE_MASK) != 0;\n+        expectContentChecksum = (flags & CONTENT_CHECKSUM_MASK) != 0;\n+        if (readOneByte() == -1) { // max size is irrelevant for this implementation\n+            throw new IOException(\"Premature end of stream while reading frame BD byte\");\n+        }\n+        if (expectContentSize) { // for now we don't care, contains the uncompressed size\n+            int skipped = (int) IOUtils.skip(in, 8);\n+            count(skipped);\n+            if (8 != skipped) {\n+                throw new IOException(\"Premature end of stream while reading content size\");\n+            }\n+        }\n+        if (readOneByte() == -1) { // partial hash of header. not supported, yet\n+            throw new IOException(\"Premature end of stream while reading frame header checksum\");\n+        }\n+    }\n+\n+    private void nextBlock() throws IOException {\n+        maybeFinishCurrentBlock();\n+        long len = ByteUtils.fromLittleEndian(supplier, 4);\n+        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n+        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n+        if (realLen == 0) {\n+            endReached = true;\n+            return;\n+        }\n+        InputStream capped = new BoundedInputStream(in, realLen);\n+        if (uncompressed) {\n+            inUncompressed = true;\n+            currentBlock = capped;\n+        } else {\n+            inUncompressed = true;\n+            currentBlock = new BlockLZ4CompressorInputStream(capped);\n+        }\n+    }\n+\n+    private void maybeFinishCurrentBlock() throws IOException {\n+        if (currentBlock != null) {\n+            currentBlock.close();\n+            currentBlock = null;\n+            if (expectBlockChecksum) {\n+                int skipped = (int) IOUtils.skip(in, 4);\n+                count(skipped);\n+                if (4 != skipped) {\n+                    throw new IOException(\"Premature end of stream while reading block checksum\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private int readOneByte() throws IOException {\n+        final int b = in.read();\n+        if (b != -1) {\n+            count(1);\n+            return b & 0xFF;\n+        }\n+        return -1;\n+    }\n+\n+    private int readOnce(byte[] b, int off, int len) throws IOException {\n+        if (inUncompressed) {\n+            int cnt = currentBlock.read(b, off, len);\n+            count(cnt);\n+            return cnt;\n+        } else {\n+            BlockLZ4CompressorInputStream l = (BlockLZ4CompressorInputStream) currentBlock;\n+            long before = l.getBytesRead();\n+            int cnt = currentBlock.read(b, off, len);\n+            count(l.getBytesRead() - before);\n+            return cnt;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the signature matches what is expected for a .lz4 file.\n+     *\n+     * <p>.lz4 files start with a four byte signature.</p>\n+     *\n+     * @param signature the bytes to check\n+     * @param length    the number of bytes to check\n+     * @return          true if this is a .sz stream, false otherwise\n+     */\n+    public static boolean matches(final byte[] signature, final int length) {\n+\n+        if (length < LZ4_SIGNATURE.length) {\n+            return false;\n+        }\n+\n+        byte[] shortenedSig = signature;\n+        if (signature.length > LZ4_SIGNATURE.length) {\n+            shortenedSig = new byte[LZ4_SIGNATURE.length];\n+            System.arraycopy(signature, 0, shortenedSig, 0, LZ4_SIGNATURE.length);\n+        }\n+\n+        return Arrays.equals(shortenedSig, LZ4_SIGNATURE);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Test;\n+\n+public final class FramedLZ4CompressorInputStreamTest\n+    extends AbstractTestCase {\n+\n+    @Test\n+    public void testMatches() throws IOException {\n+        assertFalse(FramedLZ4CompressorInputStream.matches(new byte[10], 4));\n+        final byte[] b = new byte[12];\n+        final File input = getFile(\"bla.tar.lz4\");\n+        try (FileInputStream in = new FileInputStream(input)) {\n+            IOUtils.readFully(in, b);\n+        }\n+        assertFalse(FramedLZ4CompressorInputStream.matches(b, 3));\n+        assertTrue(FramedLZ4CompressorInputStream.matches(b, 4));\n+        assertTrue(FramedLZ4CompressorInputStream.matches(b, 5));\n+    }\n+\n+    @Test\n+    public void readBlaLz4() throws IOException {\n+        try {\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.tar.lz4\")));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expected, actual);\n+        }\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+}", "timestamp": 1485104132, "metainfo": ""}