{"sha": "1b47ffe3bb81de2a922d72782b6b685de610f7a6", "log": "Support shrunk entries in ZipArchiveInputStream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         }\n \n         processZip64Extra(size, cSize);\n+        \n+        if (current.entry.getCompressedSize() != -1 \n+                && current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n+            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n+        }\n+        \n         entriesRead++;\n         return current.entry;\n     }\n             read = readStored(buffer, offset, length);\n         } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n             read = readDeflated(buffer, offset, length);\n+        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n+            read = current.in.read(buffer, offset, length);\n         } else {\n             throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                     current.entry);\n          * The checksum calculated as the current entry is read.\n          */\n         private final CRC32 crc = new CRC32();\n+\n+        /**\n+         * The input stream decompressing the data for shrunk and imploded entries.\n+         */\n+        private InputStream in;\n+    }\n+\n+    /**\n+     * Bounded input stream adapted from commons-io\n+     */\n+    private class BoundedInputStream extends InputStream {\n+\n+        /** the wrapped input stream */\n+        private final InputStream in;\n+\n+        /** the max length to provide */\n+        private final long max;\n+\n+        /** the number of bytes already returned */\n+        private long pos = 0;\n+    \n+        /**\n+         * Creates a new <code>BoundedInputStream</code> that wraps the given input\n+         * stream and limits it to a certain size.\n+         *\n+         * @param in The wrapped input stream\n+         * @param size The maximum number of bytes to return\n+         */\n+        public BoundedInputStream(final InputStream in, final long size) {\n+            this.max = size;\n+            this.in = in;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            if (max >= 0 && pos >= max) {\n+                return -1;\n+            }\n+            final int result = in.read();\n+            pos++;\n+            count(1);\n+            current.bytesReadFromStream++;\n+            return result;\n+        }\n+\n+        @Override\n+        public int read(final byte[] b) throws IOException {\n+            return this.read(b, 0, b.length);\n+        }\n+\n+        @Override\n+        public int read(final byte[] b, final int off, final int len) throws IOException {\n+            if (max >= 0 && pos >= max) {\n+                return -1;\n+            }\n+            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n+            final int bytesRead = in.read(b, off, (int) maxRead);\n+\n+            if (bytesRead == -1) {\n+                return -1;\n+            }\n+\n+            pos += bytesRead;\n+            count(bytesRead);\n+            current.bytesReadFromStream += bytesRead;\n+            return bytesRead;\n+        }\n+\n+        @Override\n+        public long skip(final long n) throws IOException {\n+            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n+            final long skippedBytes = in.skip(toSkip);\n+            pos += skippedBytes;\n+            return skippedBytes;\n+        }\n+    \n+        @Override\n+        public int available() throws IOException {\n+            if (max >= 0 && pos >= max) {\n+                return 0;\n+            }\n+            return in.available();\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n import java.io.FileInputStream;\n import java.io.InputStream;\n import java.io.IOException;\n+\n+import org.apache.commons.compress.utils.IOUtils;\n import org.junit.Test;\n \n public class ZipArchiveInputStreamTest {\n             zae = in.getNextZipEntry();\n         }\n     }\n+\n+    @Test\n+    public void testUnshrinkEntry() throws Exception {\n+        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"SHRUNK.ZIP\")));\n+        \n+        ZipArchiveEntry entry = in.getNextZipEntry();\n+        assertEquals(\"method\", ZipMethod.UNSHRINKING.getCode(), entry.getMethod());\n+        \n+        FileInputStream original = new FileInputStream(getFile(\"test1.xml\"));\n+        try {\n+            assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(in));\n+        } finally {\n+            original.close();\n+        }\n+        \n+        entry = in.getNextZipEntry();\n+        assertEquals(\"method\", ZipMethod.UNSHRINKING.getCode(), entry.getMethod());\n+        \n+        original = new FileInputStream(getFile(\"test2.xml\"));\n+        try {\n+            assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(in));\n+        } finally {\n+            original.close();\n+        }\n+    }\n }", "timestamp": 1387456201, "metainfo": ""}