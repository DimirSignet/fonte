{"sha": "a6fbdae7e9d765ba175374c78050dc391ddb1cb5", "log": "support writing big files using star extensions.  COMPRESS-165.  Patch by John Kodis.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      * Set this entry's file size.\n      *\n      * @param size This entry's new file size.\n-     * @throws IllegalArgumentException if the size is < 0\n-     * or > {@link TarConstants#MAXSIZE} (077777777777L).\n+     * @throws IllegalArgumentException if the size is &lt; 0.\n      */\n     public void setSize(long size) {\n-        if (size > MAXSIZE || size < 0){\n+        if (size < 0){\n             throw new IllegalArgumentException(\"Size is out of range: \"+size);\n-        }\n-        this.size = size;\n-    }\n-\n-    /**\n-     * Set this entry's file size.\n-     *\n-     * <p>Invoked by input stream when reading a PAX header.</p>\n-     * @throws IllegalArgumentException if the size is &lt; 0\n-     * @since Apache Commons Compress 1.4\n-     */\n-    void adjustSize(long size) {\n-        if (size < 0){\n-            throw new IllegalArgumentException(\"Size is out of range: \" + size);\n         }\n         this.size = size;\n     }\n     /**\n      * Write an entry's header information to a header buffer.\n      *\n+     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\n+     *\n      * @param outbuf The tar entry header buffer to fill in.\n      */\n     public void writeEntryHeader(byte[] outbuf) {\n+        writeEntryHeader(outbuf, false);\n+    }\n+\n+    /**\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     * @param starMode whether to use the star/GNU tar/BSD tar\n+     * extension for the size field if the size is bigger than 8GiB\n+     * @since Apache Commons Compress 1.4\n+     */\n+    public void writeEntryHeader(byte[] outbuf, boolean starMode) {\n         int offset = 0;\n \n         offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\n         offset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\n         offset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\n         offset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\n-        offset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\n+        if (size > TarConstants.MAXSIZE && !starMode) {\n+            // size is in PAX header\n+            offset = TarUtils.formatLongOctalBytes(0, outbuf, offset, SIZELEN);\n+        } else {\n+            offset = TarUtils.formatLongOctalOrBinaryBytes(size, outbuf, offset, SIZELEN);\n+        }\n         offset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n \n         int csOffset = offset;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             } else if (\"uname\".equals(key)){\n                 currEntry.setUserName(val);\n             } else if (\"size\".equals(key)){\n-                currEntry.adjustSize(Long.parseLong(val));\n+                currEntry.setSize(Long.parseLong(val));\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     /** GNU tar extensions are used to store long file names in the archive. */\n     public static final int LONGFILE_GNU = 2;\n \n+    /** Fail if a big file (&gt; 8GiB) is required in the archive. */\n+    public static final int BIGFILE_ERROR = 0;\n+\n+    /** star/GNU tar/BSD tar extensions are used to store big file sizes in the archive. */\n+    public static final int BIGFILE_STAR = 1;\n+\n+    /** POSIX/PAX extensions are used to store big file sizes in the archive. */\n+    public static final int BIGFILE_POSIX = 2;\n+\n     private long      currSize;\n     private String    currName;\n     private long      currBytes;\n     private final byte[]    assemBuf;\n     protected final TarBuffer buffer;\n     private int       longFileMode = LONGFILE_ERROR;\n+    private int       bigFileMode = BIGFILE_ERROR;\n \n     private boolean closed = false;\n \n      */\n     public void setLongFileMode(int longFileMode) {\n         this.longFileMode = longFileMode;\n+    }\n+\n+    /**\n+     * Set the big file mode.\n+     * This can be BIGFILE_ERROR(0), BIGFILE_POSIX(1) or BIGFILE_STAR(2).\n+     * This specifies the treatment of big files (sizes &gt; TarConstants.MAXSIZE).\n+     * Default is BIGFILE_ERROR.\n+     * @param bigFileMode the mode to use\n+     * @since Apache Commons Compress 1.4\n+     */\n+    public void setBigFileMode(int bigFileMode) {\n+        this.bigFileMode = bigFileMode;\n     }\n \n \n                                            + TarConstants.NAMELEN + \" bytes)\");\n             }\n         }\n-\n-        entry.writeEntryHeader(recordBuf);\n+        if (entry.getSize() > TarConstants.MAXSIZE) {\n+            if (bigFileMode != BIGFILE_STAR) {\n+                throw new RuntimeException(\"file size '\" + entry.getSize()\n+                                           + \"' is too big ( > \"\n+                                           + TarConstants.MAXSIZE + \" bytes)\");\n+            }\n+        }\n+\n+        entry.writeEntryHeader(recordBuf, bigFileMode == BIGFILE_STAR);\n         buffer.writeRecord(recordBuf);\n \n         currBytes = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * missing or an invalid byte is detected in an octal number, or\n      * if a binary number would exceed the size of a signed long\n      * 64-bit integer.\n+     * @since Apache Commons Compress 1.4\n      */\n     public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                           final int length) {\n     }\n \n     /**\n+     * Write an long integer into a buffer as an octal string if this\n+     * will fit, or as a binary number otherwise.\n+     * \n+     * Uses {@link #formatUnsignedOctalString} to format\n+     * the value as an octal string with leading zeros.\n+     * The converted number is followed by a space.\n+     * \n+     * @param value The value to write into the buffer.\n+     * @param buf The destination buffer.\n+     * @param offset The starting offset into the buffer.\n+     * @param length The length of the buffer.\n+     * @return The updated offset.\n+     * @throws IllegalArgumentException if the value (and trailer)\n+     * will not fit in the buffer.\n+     * @since Apache Commons Compress 1.4\n+     */\n+    public static int formatLongOctalOrBinaryBytes(\n+        final long value, byte[] buf, final int offset, final int length) {\n+\n+        if (value < TarConstants.MAXSIZE + 1) {\n+            return formatLongOctalBytes(value, buf, offset, length);\n+        }\n+\n+        long val = value;\n+        for (int i = offset + length - 1; i >= offset; i--) {\n+            buf[i] = (byte) val;\n+            val >>= 8;\n+        }\n+\n+        if (val != 0 || (buf[offset] & 0x80) != 0) {\n+            throw new IllegalArgumentException(\"Value \" + value +\n+                \" is too large for \" + length + \" byte field.\");\n+        }\n+\n+        buf[offset] |= 0x80;\n+        return offset + length;\n+    }\n+\n+    /**\n      * Writes an octal value into a buffer.\n      * \n      * Uses {@link #formatUnsignedOctalString} to format\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n         } catch (IllegalArgumentException expected) {\n         }\n         t.setSize(077777777777L);\n-        try {\n-            t.setSize(0100000000000L);\n-            fail(\"Should have generated IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n-        }\n-    }\n-\n-    public void testAdjustFileSize(){\n-        TarArchiveEntry t = new TarArchiveEntry(\"\");\n-        t.adjustSize(0);\n-        t.adjustSize(1);\n-        try {\n-            t.adjustSize(-1);\n-            fail(\"Should have generated IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n-        }\n-        t.adjustSize(077777777777L);\n-        t.adjustSize(0100000000000L);\n+        t.setSize(0100000000000L);\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n \n package org.apache.commons.compress.archivers.tar;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n \n         assertEquals(f.length(), tarOut.getBytesWritten());\n     }\n+\n+    public void testMaxFileSizeError() throws Exception {\n+        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        t.setSize(077777777777L);\n+        TarArchiveOutputStream tos =\n+            new TarArchiveOutputStream(new ByteArrayOutputStream());\n+        tos.putArchiveEntry(t);\n+        t.setSize(0100000000000L);\n+        tos = new TarArchiveOutputStream(new ByteArrayOutputStream());\n+        try {\n+            tos.putArchiveEntry(t);\n+            fail(\"Should have generated RuntimeException\");\n+        } catch (RuntimeException expected) {\n+        }\n+    }\n+\n+    public void testBigFileStarMode() throws Exception {\n+        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        t.setSize(0100000000000L);\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        tos.setBigFileMode(TarArchiveOutputStream.BIGFILE_STAR);\n+        tos.putArchiveEntry(t);\n+        // make sure header is written to byte array\n+        tos.write(new byte[10 * 1024]);\n+        byte[] data = bos.toByteArray();\n+        assertEquals(0x80,\n+                     ((int) data[TarConstants.NAMELEN\n+                                 + TarConstants.MODELEN\n+                                 + TarConstants.UIDLEN\n+                                 + TarConstants.GIDLEN]\n+                      ) & 0x80);\n+        TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        TarArchiveEntry e = tin.getNextTarEntry();\n+        assertEquals(0100000000000L, e.getSize());\n+    }\n }", "timestamp": 1323353037, "metainfo": ""}