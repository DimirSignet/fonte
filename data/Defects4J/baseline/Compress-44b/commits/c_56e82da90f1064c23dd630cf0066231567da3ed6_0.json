{"sha": "56e82da90f1064c23dd630cf0066231567da3ed6", "log": "COMPRESS-271 read-support for LZ4 block format", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n+import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorInputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\n import org.apache.commons.compress.compressors.lzma.LZMACompressorOutputStream;\n import org.apache.commons.compress.compressors.lzma.LZMAUtils;\n     public static final String DEFLATE = \"deflate\";\n \n     /**\n+     * Constant (value {@value}) used to identify the block LZ4\n+     * compression method. Not supported as an output stream type.\n+     *\n+     * @since 1.14\n+     */\n+    public static final String LZ4_BLOCK = \"lz4-block\";\n+\n+    /**\n      * Constructs a new sorted map from input stream provider names to provider\n      * objects.\n      *\n      * @param name\n      *            of the compressor, i.e. {@value #GZIP}, {@value #BZIP2},\n      *            {@value #XZ}, {@value #LZMA}, {@value #PACK200},\n-     *            {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, {@value #Z} or\n-     *            {@value #DEFLATE}\n+     *            {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, {@value #Z},\n+     *            {@value #LZ4_BLOCK}\n+     *            or {@value #DEFLATE}\n      * @param in\n      *            the input stream\n      * @return compressor input stream\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n                 return new DeflateCompressorInputStream(in);\n+            }\n+\n+            if (LZ4_BLOCK.equalsIgnoreCase(name)) {\n+                return new BlockLZ4CompressorInputStream(in);\n             }\n \n         } catch (final IOException e) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+/**\n+ * CompressorInputStream for the LZ4 block format.\n+ *\n+ * @see <a href=\"http://lz4.github.io/lz4/lz4_Block_format.html\">LZ4 Block Format Description</a>\n+ * @since 1.14\n+ */\n+public class BlockLZ4CompressorInputStream extends CompressorInputStream {\n+\n+    private static final int WINDOW_SIZE = 1 << 16;\n+    private static final int SIZE_BITS = 4;\n+    private static final int COPY_SIZE_MASK = (1 << SIZE_BITS) - 1;\n+    private static final int LITERAL_SIZE_MASK = COPY_SIZE_MASK << SIZE_BITS;\n+\n+    /** Buffer to write decompressed bytes to for back-references */\n+    private final byte[] buf = new byte[3 * WINDOW_SIZE];\n+\n+    /** One behind the index of the last byte in the buffer that was written */\n+    private int writeIndex;\n+\n+    /** Index of the next byte to be read. */\n+    private int readIndex;\n+\n+    /** The underlying stream to read compressed data from */\n+    private final InputStream in;\n+\n+    /** Number of bytes still to be read from the current literal or copy. */\n+    private long bytesRemaining;\n+\n+    /** Copy-size part of the block starting byte. */\n+    private int nextCopySize;\n+\n+    /** Offset of the current copy. */\n+    private int copyOffset;\n+\n+    /** Current state of the stream */\n+    private State state = State.NO_BLOCK;\n+\n+    /** uncompressed size */\n+    private int size = 0;\n+\n+    // used in no-arg read method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return readOneByte();\n+        }\n+    };\n+\n+    /**\n+     * Creates a new LZ4 input stream.\n+     *\n+     * @param is\n+     *            An InputStream to read compressed data from\n+     *\n+     * @throws IOException if reading fails\n+     */\n+    public BlockLZ4CompressorInputStream(final InputStream is) throws IOException {\n+        this.in = is;\n+        writeIndex = readIndex = 0;\n+        bytesRemaining = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return read(oneByte, 0, 1) == -1 ? -1 : oneByte[0] & 0xFF;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() {\n+        return writeIndex - readIndex;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        if (state == State.EOF) {\n+            return -1;\n+        }\n+        switch (state) {\n+        case NO_BLOCK:\n+            readSizes();\n+            /*FALLTHROUGH*/\n+        case IN_LITERAL:\n+            int litLen = readLiteral(b, off, len);\n+            if (bytesRemaining == 0) {\n+                state = State.LOOKING_FOR_COPY;\n+            }\n+            return litLen;\n+        case LOOKING_FOR_COPY:\n+            if (!initializeCopy()) {\n+                state = State.EOF;\n+                return -1;\n+            }\n+            /*FALLTHROUGH*/\n+        case IN_COPY:\n+            int copyLen = readCopy(b, off, len);\n+            if (bytesRemaining == 0) {\n+                state = State.NO_BLOCK;\n+            }\n+            return copyLen;\n+        default:\n+            throw new IOException(\"Unknown stream state \" + state);\n+        }\n+    }\n+\n+    /**\n+     * Get the uncompressed size of the stream\n+     *\n+     * @return the uncompressed size\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    private void readSizes() throws IOException {\n+        int nextBlock = readOneByte();\n+        if (nextBlock == -1) {\n+            throw new IOException(\"Premature end of stream while looking for next block\");\n+        }\n+        nextCopySize = nextBlock & COPY_SIZE_MASK;\n+        long literalSizePart = (nextBlock & LITERAL_SIZE_MASK) >> SIZE_BITS;\n+        if (literalSizePart == COPY_SIZE_MASK) {\n+            literalSizePart += readSizeBytes();\n+        }\n+        bytesRemaining = literalSizePart;\n+        state = State.IN_LITERAL;\n+    }\n+\n+    private long readSizeBytes() throws IOException {\n+        long accum = 0;\n+        int nextByte;\n+        do {\n+            nextByte = readOneByte();\n+            if (nextByte == -1) {\n+                throw new IOException(\"Premature end of stream while parsing length\");\n+            }\n+            accum += nextByte;\n+        } while (nextByte == 255);\n+        return accum;\n+    }\n+\n+    private int readLiteral(final byte[] b, final int off, final int len) throws IOException {\n+        final int avail = available();\n+        if (len > avail) {\n+            tryToReadLiteral(len - avail);\n+        }\n+        return readFromBuffer(b, off, len);\n+    }\n+\n+    private void tryToReadLiteral(int bytesToRead) throws IOException {\n+        final int reallyTryToRead = (int) Math.min(Math.min(bytesToRead, bytesRemaining),\n+                                                   buf.length - writeIndex);\n+        final int bytesRead = reallyTryToRead > 0\n+            ? IOUtils.readFully(in, buf, writeIndex, reallyTryToRead)\n+            : 0 /* happens for bytesRemaining == 0 */;\n+        count(bytesRead);\n+        if (reallyTryToRead != bytesRead) {\n+            throw new IOException(\"Premature end of stream reading literal\");\n+        }\n+        writeIndex += reallyTryToRead;\n+        bytesRemaining -= reallyTryToRead;\n+    }\n+\n+    private int readFromBuffer(final byte[] b, final int off, final int len) throws IOException {\n+        final int readable = Math.min(len, available());\n+        if (readable > 0) {\n+            System.arraycopy(buf, readIndex, b, off, readable);\n+            readIndex += readable;\n+            if (readIndex > 2 * WINDOW_SIZE) {\n+                slideBuffer();\n+            }\n+        }\n+        size += readable;\n+        return readable;\n+    }\n+\n+    private void slideBuffer() {\n+        System.arraycopy(buf, WINDOW_SIZE, buf, 0, WINDOW_SIZE);\n+        writeIndex -= WINDOW_SIZE;\n+        readIndex -= WINDOW_SIZE;\n+    }\n+\n+    /**\n+     * @return false if there is no more copy - this means this is the\n+     * last block of the stream.\n+     */\n+    private boolean initializeCopy() throws IOException {\n+        try {\n+            copyOffset = (int) ByteUtils.fromLittleEndian(supplier, 2);\n+        } catch (IOException ex) {\n+            if (nextCopySize == 0) { // the last block has no copy\n+                return false;\n+            }\n+            throw ex;\n+        }\n+        long copySize = nextCopySize;\n+        if (nextCopySize == COPY_SIZE_MASK) {\n+            copySize += readSizeBytes();\n+        }\n+        bytesRemaining = copySize + 4; // minimal match length 4 is encoded as 0\n+        state = State.IN_COPY;\n+        return true;\n+    }\n+\n+    private int readCopy(final byte[] b, final int off, final int len) throws IOException {\n+        final int avail = available();\n+        if (len > avail) {\n+            tryToCopy(len - avail);\n+        }\n+        return readFromBuffer(b, off, len);\n+    }\n+\n+    private void tryToCopy(int bytesToCopy) throws IOException {\n+        // this will fit into the buffer without sliding and not\n+        // require more than is available inside the copy\n+        int copy = (int) Math.min(Math.min(bytesToCopy, bytesRemaining),\n+                                  buf.length - writeIndex);\n+        if (copy == 0) {\n+            // NOP\n+        } else if (copyOffset == 1) { // pretty common special case\n+            final byte last = buf[writeIndex - 1];\n+            for (int i = 0; i < copy; i++) {\n+                buf[writeIndex++] = last;\n+            }\n+        } else if (copy < copyOffset) {\n+            System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copy);\n+            writeIndex += copy;\n+        } else {\n+            final int fullRots = copy / copyOffset;\n+            for (int i = 0; i < fullRots; i++) {\n+                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, copyOffset);\n+                writeIndex += copyOffset;\n+            }\n+\n+            final int pad = copy - (copyOffset * fullRots);\n+            if (pad > 0) {\n+                System.arraycopy(buf, writeIndex - copyOffset, buf, writeIndex, pad);\n+                writeIndex += pad;\n+            }\n+        }\n+        bytesRemaining -= copy;\n+    }\n+\n+    private int readOneByte() throws IOException {\n+        final int b = in.read();\n+        if (b != -1) {\n+            count(1);\n+            return b & 0xFF;\n+        }\n+        return -1;\n+    }\n+\n+    private enum State {\n+        NO_BLOCK, IN_LITERAL, LOOKING_FOR_COPY, IN_COPY, EOF\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorInputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz4;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.CompressorStreamFactory;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class BlockLZ4CompressorInputStreamTest extends AbstractTestCase {\n+\n+    @Test\n+    public void readBlaLz4() throws IOException {\n+        try (InputStream a = new BlockLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.tar.block_lz4\")));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            Assert.assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void readBlaLz4ViaFactory() throws Exception {\n+        try (InputStream a = new CompressorStreamFactory()\n+                 .createCompressorInputStream(CompressorStreamFactory.LZ4_BLOCK,\n+                                              new FileInputStream(getFile(\"bla.tar.block_lz4\")));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            Assert.assertArrayEquals(expected, actual);\n+        }\n+    }\n+}", "timestamp": 1484592962, "metainfo": ""}