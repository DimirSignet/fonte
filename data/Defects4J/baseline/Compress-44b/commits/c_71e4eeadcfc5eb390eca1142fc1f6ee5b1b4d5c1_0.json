{"sha": "71e4eeadcfc5eb390eca1142fc1f6ee5b1b4d5c1", "log": "no longer try to read one byte ahead in BZip2CompressorInputStream - COMPRESS-253  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n \n     private InputStream in;\n     private final boolean decompressConcatenated;\n-\n-    private int currentChar = -1;\n \n     private static final int EOF = 0;\n     private static final int START_BLOCK_STATE = 1;\n \n         init(true);\n         initBlock();\n-        setupBlock();\n     }\n \n     @Override\n \n         final int hi = offs + len;\n         int destOffs = offs;\n-        for (int b; (destOffs < hi) && ((b = read0()) >= 0);) {\n+        int b;\n+        while (destOffs < hi && ((b = read0()) >= 0)) {\n             dest[destOffs++] = (byte) b;\n+            count(1);\n         }\n \n         int c = (destOffs == offs) ? -1 : (destOffs - offs);\n-        count(c);\n         return c;\n     }\n \n     }\n \n     private int read0() throws IOException {\n-        final int retChar = this.currentChar;\n-\n-        switch (this.currentState) {\n+        switch (currentState) {\n         case EOF:\n             return -1;\n \n         case START_BLOCK_STATE:\n-            throw new IllegalStateException();\n+            return setupBlock();\n \n         case RAND_PART_A_STATE:\n             throw new IllegalStateException();\n \n         case RAND_PART_B_STATE:\n-            setupRandPartB();\n-            break;\n+            return setupRandPartB();\n \n         case RAND_PART_C_STATE:\n-            setupRandPartC();\n-            break;\n+            return setupRandPartC();\n \n         case NO_RAND_PART_A_STATE:\n             throw new IllegalStateException();\n \n         case NO_RAND_PART_B_STATE:\n-            setupNoRandPartB();\n-            break;\n+            return setupNoRandPartB();\n \n         case NO_RAND_PART_C_STATE:\n-            setupNoRandPartC();\n-            break;\n+            return setupNoRandPartC();\n \n         default:\n             throw new IllegalStateException();\n         }\n-\n-        return retChar;\n     }\n \n     private boolean init(boolean isFirstStream) throws IOException {\n         return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n     }\n \n-    private void setupBlock() throws IOException {\n-        if (this.data == null) {\n-            return;\n+    private int setupBlock() throws IOException {\n+        if (currentState == EOF || this.data == null) {\n+            return -1;\n         }\n \n         final int[] cftab = this.data.cftab;\n         if (this.blockRandomised) {\n             this.su_rNToGo = 0;\n             this.su_rTPos = 0;\n-            setupRandPartA();\n-        } else {\n-            setupNoRandPartA();\n-        }\n-    }\n-\n-    private void setupRandPartA() throws IOException {\n+            return setupRandPartA();\n+        }\n+        return setupNoRandPartA();\n+    }\n+\n+    private int setupRandPartA() throws IOException {\n         if (this.su_i2 <= this.last) {\n             this.su_chPrev = this.su_ch2;\n             int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n             }\n             this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\n             this.su_i2++;\n-            this.currentChar = su_ch2Shadow;\n             this.currentState = RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n+            return su_ch2Shadow;\n         } else {\n             endBlock();\n             initBlock();\n-            setupBlock();\n-        }\n-    }\n-\n-    private void setupNoRandPartA() throws IOException {\n+            return setupBlock();\n+        }\n+    }\n+\n+    private int setupNoRandPartA() throws IOException {\n         if (this.su_i2 <= this.last) {\n             this.su_chPrev = this.su_ch2;\n             int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n             this.su_ch2 = su_ch2Shadow;\n             this.su_tPos = this.data.tt[this.su_tPos];\n             this.su_i2++;\n-            this.currentChar = su_ch2Shadow;\n             this.currentState = NO_RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n+            return su_ch2Shadow;\n         } else {\n             this.currentState = NO_RAND_PART_A_STATE;\n             endBlock();\n             initBlock();\n-            setupBlock();\n-        }\n-    }\n-\n-    private void setupRandPartB() throws IOException {\n+            return setupBlock();\n+        }\n+    }\n+\n+    private int setupRandPartB() throws IOException {\n         if (this.su_ch2 != this.su_chPrev) {\n             this.currentState = RAND_PART_A_STATE;\n             this.su_count = 1;\n-            setupRandPartA();\n+            return setupRandPartA();\n         } else if (++this.su_count >= 4) {\n             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n             this.su_tPos = this.data.tt[this.su_tPos];\n             if (this.su_rNToGo == 1) {\n                 this.su_z ^= 1;\n             }\n-            setupRandPartC();\n+            return setupRandPartC();\n         } else {\n             this.currentState = RAND_PART_A_STATE;\n-            setupRandPartA();\n-        }\n-    }\n-\n-    private void setupRandPartC() throws IOException {\n+            return setupRandPartA();\n+        }\n+    }\n+\n+    private int setupRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n-            this.currentChar = this.su_ch2;\n             this.crc.updateCRC(this.su_ch2);\n             this.su_j2++;\n+            return this.su_ch2;\n         } else {\n             this.currentState = RAND_PART_A_STATE;\n             this.su_i2++;\n             this.su_count = 0;\n-            setupRandPartA();\n-        }\n-    }\n-\n-    private void setupNoRandPartB() throws IOException {\n+            return setupRandPartA();\n+        }\n+    }\n+\n+    private int setupNoRandPartB() throws IOException {\n         if (this.su_ch2 != this.su_chPrev) {\n             this.su_count = 1;\n-            setupNoRandPartA();\n+            return setupNoRandPartA();\n         } else if (++this.su_count >= 4) {\n             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n             this.su_tPos = this.data.tt[this.su_tPos];\n             this.su_j2 = 0;\n-            setupNoRandPartC();\n+            return setupNoRandPartC();\n         } else {\n-            setupNoRandPartA();\n-        }\n-    }\n-\n-    private void setupNoRandPartC() throws IOException {\n+            return setupNoRandPartA();\n+        }\n+    }\n+\n+    private int setupNoRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n             int su_ch2Shadow = this.su_ch2;\n-            this.currentChar = su_ch2Shadow;\n             this.crc.updateCRC(su_ch2Shadow);\n             this.su_j2++;\n             this.currentState = NO_RAND_PART_C_STATE;\n+            return su_ch2Shadow;\n         } else {\n             this.su_i2++;\n             this.su_count = 0;\n-            setupNoRandPartA();\n+            return setupNoRandPartA();\n         }\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.bzip2;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase porting a test from Python's testsuite.\n+ * @see \"https://issues.apache.org/jira/browse/COMPRESS-253\"\n+ */\n+public class PythonTruncatedBzip2Test {\n+\n+    private static String TEXT = \"root:x:0:0:root:/root:/bin/bash\\nbin:x:1:1:bin:/bin:\\ndaemon:x:2:2:daemon:/sbin:\\nadm:x:3:4:adm:/var/adm:\\nlp:x:4:7:lp:/var/spool/lpd:\\nsync:x:5:0:sync:/sbin:/bin/sync\\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\\nhalt:x:7:0:halt:/sbin:/sbin/halt\\nmail:x:8:12:mail:/var/spool/mail:\\nnews:x:9:13:news:/var/spool/news:\\nuucp:x:10:14:uucp:/var/spool/uucp:\\noperator:x:11:0:operator:/root:\\ngames:x:12:100:games:/usr/games:\\ngopher:x:13:30:gopher:/usr/lib/gopher-data:\\nftp:x:14:50:FTP User:/var/ftp:/bin/bash\\nnobody:x:65534:65534:Nobody:/home:\\npostfix:x:100:101:postfix:/var/spool/postfix:\\nniemeyer:x:500:500::/home/niemeyer:/bin/bash\\npostgres:x:101:102:PostgreSQL Server:/var/lib/pgsql:/bin/bash\\nmysql:x:102:103:MySQL server:/var/lib/mysql:/bin/bash\\nwww:x:103:104::/var/www:/bin/false\\n\";\n+\n+    private static byte[] DATA;\n+    private static byte[] TRUNCATED_DATA;\n+    private ReadableByteChannel bz2Channel;\n+\n+    @BeforeClass\n+    public static void initializeTestData() throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        BZip2CompressorOutputStream bz2out = new BZip2CompressorOutputStream(out);\n+        bz2out.write(TEXT.getBytes(), 0, TEXT.getBytes().length);\n+        bz2out.close();\n+        DATA = out.toByteArray();\n+\n+        // Drop the eos_magic field (6 bytes) and CRC (4 bytes).\n+        TRUNCATED_DATA = Arrays.copyOfRange(DATA, 0, DATA.length - 10);\n+    }\n+\n+    @Before\n+    public void initializeChannel() throws IOException {\n+        InputStream source = new ByteArrayInputStream(TRUNCATED_DATA);\n+        this.bz2Channel = makeBZ2C(source);\n+    }\n+\n+    @After\n+    public void closeChannel() throws IOException {\n+        bz2Channel.close();\n+        bz2Channel = null;\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void testTruncatedData() throws IOException {\n+        //with BZ2File(self.filename) as f:\n+        //    self.assertRaises(EOFError, f.read)\n+        System.out.println(\"Attempt to read the whole thing in, should throw ...\");\n+        ByteBuffer buffer = ByteBuffer.allocate(8192);\n+        bz2Channel.read(buffer);\n+    }\n+\n+    @Test\n+    public void testPartialReadTruncatedData() throws IOException {\n+        //with BZ2File(self.filename) as f:\n+        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n+        //    self.assertRaises(EOFError, f.read, 1)\n+\n+        final int length = TEXT.length();\n+        ByteBuffer buffer = ByteBuffer.allocate(length);\n+        bz2Channel.read(buffer);\n+\n+        assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),\n+                buffer.array());\n+\n+        // subsequent read should throw\n+        buffer = ByteBuffer.allocate(1);\n+        try {\n+            bz2Channel.read(buffer);\n+            Assert.fail(\"The read should have thrown.\");\n+        } catch (IOException e) {\n+            // pass\n+        }\n+    }\n+\n+    private static ReadableByteChannel makeBZ2C(InputStream source) throws IOException {\n+        BufferedInputStream bin = new BufferedInputStream(source);\n+        BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);\n+\n+        return Channels.newChannel(bZin);\n+    }\n+}", "timestamp": 1390224368, "metainfo": ""}