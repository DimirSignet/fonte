{"sha": "5def510d00f73b25db8ce44303df49050f99dfbc", "log": "Merge branch 'COMPRESS-382'  closes #20", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/MemoryLimitException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress;\n+\n+import java.io.IOException;\n+\n+/**\n+ * If a stream checks for estimated memory allocation, and the estimate\n+ * goes above the memory limit, this is thrown.  This can also be thrown\n+ * if a stream tries to allocate a byte array that is larger than\n+ * the allowable limit.\n+ *\n+ * @since 1.14\n+ */\n+public class MemoryLimitException extends IOException {\n+\n+    //long instead of int to account for overflow for corrupt files\n+    private final long memoryNeededInKb;\n+    private final int memoryLimitInKb;\n+\n+    public MemoryLimitException(long memoryNeededInKb, int memoryLimitInKb) {\n+        super(buildMessage(memoryNeededInKb, memoryLimitInKb));\n+        this.memoryNeededInKb = memoryNeededInKb;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n+    public MemoryLimitException(long memoryNeededInKb, int memoryLimitInKb, Exception e) {\n+        super(buildMessage(memoryNeededInKb, memoryLimitInKb), e);\n+        this.memoryNeededInKb = memoryNeededInKb;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n+    public long getMemoryNeededInKb() {\n+        return memoryNeededInKb;\n+    }\n+\n+    public int getMemoryLimitInKb() {\n+        return memoryLimitInKb;\n+    }\n+\n+    private static String buildMessage(long memoryNeededInKb, int memoryLimitInKb) {\n+        return \"\" + memoryNeededInKb + \" kb of memory would be needed; limit was \"\n+                + memoryLimitInKb + \" kb. \" +\n+                \"If the file is not corrupt, consider increasing the memory limit.\";\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      */\n     private volatile boolean decompressConcatenated = false;\n \n+    private final int memoryLimitInKb;\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n         this.decompressUntilEOF = null;\n-    }\n+        this.memoryLimitInKb = -1;\n+    }\n+\n+    /**\n+     * Create an instance with the provided decompress Concatenated option.\n+     *\n+     * @param decompressUntilEOF\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream. This setting applies to the\n+     *            gzip, bzip2 and xz formats only.\n+     *\n+     * @param memoryLimitInKb\n+     *            Some streams require allocation of potentially significant\n+     *            byte arrays/tables, and they can offer checks to prevent OOMs\n+     *            on corrupt files.  Set the maximum allowed memory allocation in KBs.\n+     *\n+     * @since 1.14\n+     */\n+    public CompressorStreamFactory(final boolean decompressUntilEOF, final int memoryLimitInKb) {\n+        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n+        this.decompressConcatenated = decompressUntilEOF;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n-        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the\n-        // current value\n-        this.decompressConcatenated = decompressUntilEOF;\n+        this(decompressUntilEOF, -1);\n     }\n \n     /**\n      *            the input stream\n      * @return compressor input stream\n      * @throws CompressorException\n-     *             if the compressor name is not known or not available\n+     *             if the compressor name is not known or not available,\n+     *             or if there's an IOException or MemoryLimitException thrown\n+     *             during initialization\n      * @throws IllegalArgumentException\n      *             if the name or input stream is null\n      */\n                 if (!XZUtils.isXZCompressionAvailable()) {\n                     throw new CompressorException(\"XZ compression is not available.\");\n                 }\n-                return new XZCompressorInputStream(in, actualDecompressConcatenated);\n+                return new XZCompressorInputStream(in, actualDecompressConcatenated, memoryLimitInKb);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                return new LZMACompressorInputStream(in);\n+                return new LZMACompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                return new ZCompressorInputStream(in);\n+                return new ZCompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+\n+import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.LZMAInputStream;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n public class LZMACompressorInputStream extends CompressorInputStream {\n     private final InputStream in;\n \n+    public LZMACompressorInputStream(final InputStream inputStream)\n+            throws IOException {\n+        in = new LZMAInputStream(inputStream, -1);\n+    }\n+\n     /**\n      * Creates a new input stream that decompresses LZMA-compressed data\n      * from the specified input stream.\n      *\n      * @param       inputStream where to read the compressed data\n      *\n+     * @param       memoryLimitInKb calculated memory use threshold.  Throws MemoryLimitException\n+     *                            if calculate memory use is above this threshold\n+     *\n      * @throws      IOException if the input is not in the .lzma format,\n      *                          the input is corrupt or truncated, the .lzma\n      *                          headers specify sizes that are not supported\n      *                          by this implementation, or the underlying\n      *                          <code>inputStream</code> throws an exception\n+     *\n+     * @since 1.14\n      */\n-    public LZMACompressorInputStream(final InputStream inputStream)\n+    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n             throws IOException {\n-        in = new LZMAInputStream(inputStream);\n+        try {\n+            in = new LZMAInputStream(inputStream, memoryLimitInKb);\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress exception\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n+import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.compressors.CompressorInputStream;\n import org.apache.commons.compress.utils.BitInputStream;\n \n \n     /**\n      * Initializes the arrays based on the maximum code size.\n+     * First checks that the estimated memory usage is below memoryLimitInKb\n+     *\n+     * @param maxCodeSize maximum code size\n+     * @param memoryLimitInKb maximum allowed estimated memory usage in Kb\n+     * @throws MemoryLimitException if estimated memory usage is greater than memoryLimitInKb\n+     */\n+    protected void initializeTables(final int maxCodeSize, final int memoryLimitInKb)\n+            throws MemoryLimitException {\n+\n+        if (memoryLimitInKb > -1) {\n+            final int maxTableSize = 1 << maxCodeSize;\n+            //account for potential overflow\n+            long memoryUsageInBytes = (long) maxTableSize * 6;//(4 (prefixes) + 1 (characters) +1 (outputStack))\n+            long memoryUsageInKb = memoryUsageInBytes >> 10;\n+\n+            if (memoryUsageInKb > (long)memoryLimitInKb) {\n+                throw new MemoryLimitException(memoryUsageInKb, memoryLimitInKb);\n+            }\n+        }\n+        initializeTables(maxCodeSize);\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n      * @param maxCodeSize maximum code size\n      */\n     protected void initializeTables(final int maxCodeSize) {\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+\n+import org.apache.commons.compress.MemoryLimitException;\n import org.tukaani.xz.XZ;\n import org.tukaani.xz.SingleXZInputStream;\n import org.tukaani.xz.XZInputStream;\n     public XZCompressorInputStream(final InputStream inputStream,\n                                    final boolean decompressConcatenated)\n             throws IOException {\n+        this(inputStream, decompressConcatenated, -1);\n+    }\n+\n+    /**\n+     * Creates a new input stream that decompresses XZ-compressed data\n+     * from the specified input stream.\n+     *\n+     * @param       inputStream where to read the compressed data\n+     * @param       decompressConcatenated\n+     *                          if true, decompress until the end of the\n+     *                          input; if false, stop after the first .xz\n+     *                          stream and leave the input position to point\n+     *                          to the next byte after the .xz stream\n+     * @param       memoryLimitInKb memory limit used when reading blocks.  If\n+     *                          the estimated memory limit is exceeded on {@link #read()},\n+     *                          a {@link MemoryLimitException} is thrown.\n+     *\n+     * @throws      IOException if the input is not in the .xz format,\n+     *                          the input is corrupt or truncated, the .xz\n+     *                          headers specify options that are not supported\n+     *                          by this implementation,\n+     *                          or the underlying <code>inputStream</code> throws an exception\n+     *\n+     * @since 1.14\n+     */\n+    public XZCompressorInputStream(InputStream inputStream,\n+                                   boolean decompressConcatenated, final int memoryLimitInKb)\n+            throws IOException {\n         if (decompressConcatenated) {\n-            in = new XZInputStream(inputStream);\n+            in = new XZInputStream(inputStream, memoryLimitInKb);\n         } else {\n-            in = new SingleXZInputStream(inputStream);\n+            in = new SingleXZInputStream(inputStream, memoryLimitInKb);\n         }\n     }\n \n     @Override\n     public int read() throws IOException {\n-        final int ret = in.read();\n-        count(ret == -1 ? -1 : 1);\n-        return ret;\n+        try {\n+            final int ret = in.read();\n+            count(ret == -1 ? -1 : 1);\n+            return ret;\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n+        }\n     }\n \n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n-        final int ret = in.read(buf, off, len);\n-        count(ret);\n-        return ret;\n+        try {\n+            final int ret = in.read(buf, off, len);\n+            count(ret);\n+            return ret;\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress MemoryLimtException\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n+        }\n     }\n \n     @Override\n     public long skip(final long n) throws IOException {\n-        return in.skip(n);\n+        try {\n+            return in.skip(n);\n+        } catch (org.tukaani.xz.MemoryLimitException e) {\n+            //convert to commons-compress MemoryLimtException\n+            throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), e);\n+        }\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n     private final boolean blockMode;\n     private final int maxCodeSize;\n     private long totalCodesRead = 0;\n-    \n-    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+\n+    public ZCompressorInputStream(final InputStream inputStream, final int memoryLimitInKb)\n+            throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         final int firstByte = (int) in.readBits(8);\n         final int secondByte = (int) in.readBits(8);\n         if (blockMode) {\n             setClearCode(DEFAULT_CODE_SIZE);\n         }\n-        initializeTables(maxCodeSize);\n+        initializeTables(maxCodeSize, memoryLimitInKb);\n         clearEntries();\n+    }\n+\n+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, -1);\n     }\n     \n     private void clearEntries() {\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;\n         assertEquals(CompressorStreamFactory.SNAPPY_FRAMED, detect(\"bla.tar.sz\"));\n         assertEquals(CompressorStreamFactory.Z, detect(\"bla.tar.Z\"));\n \n+        //make sure we don't oom on detect\n+        assertEquals(CompressorStreamFactory.Z, detect(\"COMPRESS-386\"));\n+        assertEquals(CompressorStreamFactory.LZMA, detect(\"COMPRESS-382\"));\n+\n         try {\n             CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n             fail(\"shouldn't be able to detect empty stream\");\n         }\n         return name;\n     }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testLZMAMemoryLimit() throws Exception {\n+        getStreamFor(\"COMPRESS-382\", 100);\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testZMemoryLimit() throws Exception {\n+        getStreamFor(\"COMPRESS-386\", 100);\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testXZMemoryLimitOnRead() throws Exception {\n+        //Even though the file is very small, the memory limit\n+        //has to be quite large (8296 KiB) because of the dictionary size\n+\n+        //This is triggered on read(); not during initialization.\n+        //This test is here instead of the xz unit test to make sure\n+        //that the parameter is properly passed via the CompressorStreamFactory\n+        try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n+            compressorIs.read();\n+        }\n+    }\n+\n+    @Test(expected = MemoryLimitException.class)\n+    public void testXZMemoryLimitOnSkip() throws Exception {\n+        try (InputStream compressorIs = getStreamFor(\"bla.tar.xz\", 100)) {\n+            compressorIs.skip(10);\n+        }\n+    }\n+\n+    private InputStream getStreamFor(final String fileName, final int memoryLimitInKb) throws Exception {\n+        CompressorStreamFactory fac = new CompressorStreamFactory(true,\n+                memoryLimitInKb);\n+        InputStream is = new BufferedInputStream(\n+                new FileInputStream(getFile(fileName)));\n+        try {\n+            return fac.createCompressorInputStream(is);\n+        } catch (CompressorException e) {\n+            if (e.getCause() != null && e.getCause() instanceof Exception) {\n+                //unwrap cause to reveal MemoryLimitException\n+                throw (Exception)e.getCause();\n+            } else {\n+                throw e;\n+            }\n+        }\n+\n+    }\n+\n \n     @Test\n     public void testOverride() {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n         }\n         final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n         final long start = offsetEntry.dataOffset;\n-        return new BoundedInputStream(start, ze.getCompressedSize());\n+        return createBoundedInputStream(start, ze.getCompressedSize());\n     }\n \n \n         final long start = offsetEntry.dataOffset;\n         // doesn't get closed if the method is not supported, but doesn't hold any resources either\n         final BoundedInputStream bis =\n-            new BoundedInputStream(start, ze.getCompressedSize()); //NOSONAR\n+            createBoundedInputStream(start, ze.getCompressedSize()); //NOSONAR\n         switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n             case STORED:\n                 return bis;\n     }\n \n     /**\n+     * Creates new BoundedInputStream, according to implementation of\n+     * underlying archive channel.\n+     */\n+    private BoundedInputStream createBoundedInputStream(long start, long remaining) {\n+        return archive instanceof FileChannel ?\n+            new BoundedFileChannelInputStream(start, remaining) :\n+            new BoundedInputStream(start, remaining);\n+    }\n+\n+    /**\n      * InputStream that delegates requests to the underlying\n      * SeekableByteChannel, making sure that only bytes from a certain\n      * range can be read.\n      */\n     private class BoundedInputStream extends InputStream {\n-        private static final int MAX_BUF_LEN = 8192;\n-        private final ByteBuffer buffer;\n-        private long remaining;\n+        private ByteBuffer singleByteBuffer;\n+        private final long end;\n         private long loc;\n-        private boolean addDummyByte = false;\n+        private boolean addDummy = false;\n \n         BoundedInputStream(final long start, final long remaining) {\n-            this.remaining = remaining;\n+            this.end = start+remaining;\n+            if (this.end < start) {\n+                // check for potential vulnerability due to overflow\n+                throw new IllegalArgumentException(\"Invalid length of stream at offset=\"+start+\", length=\"+remaining);\n+            }\n             loc = start;\n-            if (remaining < MAX_BUF_LEN && remaining > 0) {\n-                buffer = ByteBuffer.allocate((int) remaining);\n-            } else {\n-                buffer = ByteBuffer.allocate(MAX_BUF_LEN);\n-            }\n         }\n \n         @Override\n-        public int read() throws IOException {\n-            if (remaining-- <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n+        public synchronized int read() throws IOException {\n+            if (loc >= end) {\n+                if (loc == end && addDummy) {\n+                    ++loc;\n                     return 0;\n                 }\n                 return -1;\n             }\n-            synchronized (archive) {\n-                archive.position(loc++);\n-                int read = read(1);\n-                if (read < 0) {\n-                    return read;\n-                }\n-                return buffer.get() & 0xff;\n-            }\n+            if (singleByteBuffer == null) {\n+                singleByteBuffer = ByteBuffer.allocate(1);\n+            }\n+            else {\n+                singleByteBuffer.rewind();\n+            }\n+            int read = read(loc++, singleByteBuffer);\n+            if (read < 0) {\n+                return read;\n+            }\n+            return singleByteBuffer.get() & 0xff;\n         }\n \n         @Override\n-        public int read(final byte[] b, final int off, int len) throws IOException {\n-            if (remaining <= 0) {\n-                if (addDummyByte) {\n-                    addDummyByte = false;\n-                    b[off] = 0;\n-                    return 1;\n-                }\n-                return -1;\n-            }\n-\n+        public synchronized int read(final byte[] b, final int off, int len) throws IOException {\n             if (len <= 0) {\n                 return 0;\n             }\n \n-            if (len > remaining) {\n-                len = (int) remaining;\n-            }\n+            if (len > end-loc) {\n+                if (loc >= end) {\n+                    if (loc == end && addDummy) {\n+                        ++loc;\n+                        b[off] = 0;\n+                        return 1;\n+                    }\n+                    return -1;\n+                }\n+                len = (int)(end-loc);\n+            }\n+\n             ByteBuffer buf;\n-            int ret = -1;\n+            buf = ByteBuffer.wrap(b, off, len);\n+            int ret = read(loc, buf);\n+            if (ret > 0) {\n+                loc += ret;\n+                return ret;\n+            }\n+            return ret;\n+        }\n+\n+        protected int read(long pos, ByteBuffer buf) throws IOException {\n+            int read;\n             synchronized (archive) {\n-                archive.position(loc);\n-                if (len <= buffer.capacity()) {\n-                    buf = buffer;\n-                    ret = read(len);\n-                } else {\n-                    buf = ByteBuffer.allocate(len);\n-                    ret = archive.read(buf);\n-                    buf.flip();\n-                }\n-            }\n-            if (ret > 0) {\n-                buf.get(b, off, ret);\n-                loc += ret;\n-                remaining -= ret;\n-            }\n-            return ret;\n-        }\n-\n-        private int read(int len) throws IOException {\n-            buffer.rewind().limit(len);\n-            int read = archive.read(buffer);\n-            buffer.flip();\n+                archive.position(pos);\n+                read = archive.read(buf);\n+            }\n+            buf.flip();\n             return read;\n         }\n \n-        /**\n-         * Inflater needs an extra dummy byte for nowrap - see\n-         * Inflater's javadocs.\n-         */\n         void addDummy() {\n-            addDummyByte = true;\n+            this.addDummy = true;\n+        }\n+    }\n+\n+    /**\n+     * Lock-free implementation of BoundedInputStream. The\n+     * implementation uses positioned reads on the underlying archive\n+     * file channel and therefore performs significantly faster in\n+     * concurrent environment.\n+     */\n+    private class BoundedFileChannelInputStream extends BoundedInputStream {\n+        private final FileChannel archive;\n+\n+        BoundedFileChannelInputStream(final long start, final long remaining) {\n+            super(start, remaining);\n+            archive = (FileChannel)ZipFile.this.archive;\n+        }\n+\n+        @Override\n+        protected int read(long pos, ByteBuffer buf) throws IOException {\n+            int read = archive.read(buf, pos);\n+            buf.flip();\n+            return read;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.zip.ZipEntry;\n \n import org.apache.commons.compress.utils.IOUtils;\n         assertArrayEquals(expected, IOUtils.toByteArray(zf.getInputStream(ze)));\n     }\n \n+    @Test\n+    public void testConcurrentReadSeekable() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        byte[] data = null;\n+        try (FileInputStream fis = new FileInputStream(getFile(\"mixed.zip\"))) {\n+            data = IOUtils.toByteArray(fis);\n+        }\n+        zf = new ZipFile(new SeekableInMemoryByteChannel(data), ZipEncodingHelper.UTF8);\n+\n+        final Map<String, byte[]> content = new HashMap<String, byte[]>();\n+        for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+            content.put(entry.getName(), IOUtils.toByteArray(zf.getInputStream(entry)));\n+        }\n+\n+        final AtomicInteger passedCount = new AtomicInteger();\n+        Runnable run = new Runnable() {\n+            @Override\n+            public void run() {\n+                for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+                    assertAllReadMethods(content.get(entry.getName()), zf, entry);\n+                }\n+                passedCount.incrementAndGet();\n+            }\n+        };\n+        Thread t0 = new Thread(run);\n+        Thread t1 = new Thread(run);\n+        t0.start();\n+        t1.start();\n+        t0.join();\n+        t1.join();\n+        assertEquals(2, passedCount.get());\n+    }\n+\n+    @Test\n+    public void testConcurrentReadFile() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        final File archive = getFile(\"mixed.zip\");\n+        zf = new ZipFile(archive);\n+\n+        final Map<String, byte[]> content = new HashMap<String, byte[]>();\n+        for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+            content.put(entry.getName(), IOUtils.toByteArray(zf.getInputStream(entry)));\n+        }\n+\n+        final AtomicInteger passedCount = new AtomicInteger();\n+        Runnable run = new Runnable() {\n+            @Override\n+            public void run() {\n+                for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+                    assertAllReadMethods(content.get(entry.getName()), zf, entry);\n+                }\n+                passedCount.incrementAndGet();\n+            }\n+        };\n+        Thread t0 = new Thread(run);\n+        Thread t1 = new Thread(run);\n+        t0.start();\n+        t1.start();\n+        t0.join();\n+        t1.join();\n+        assertEquals(2, passedCount.get());\n+    }\n+\n+    private void assertAllReadMethods(byte[] expected, ZipFile zipFile, ZipArchiveEntry entry) {\n+        // simple IOUtil read\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full = IOUtils.toByteArray(stream);\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        // big buffer at the beginning and then chunks by IOUtils read\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full;\n+            byte[] bytes = new byte[0x40000];\n+            int read = stream.read(bytes);\n+            if (read < 0) {\n+                full = new byte[0];\n+            }\n+            else {\n+                full = readStreamRest(bytes, read, stream);\n+            }\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        // small chunk / single byte and big buffer then\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full;\n+            int single = stream.read();\n+            if (single < 0) {\n+                full = new byte[0];\n+            }\n+            else {\n+                byte[] big = new byte[0x40000];\n+                big[0] = (byte)single;\n+                int read = stream.read(big, 1, big.length-1);\n+                if (read < 0) {\n+                    full = new byte[]{ (byte)single };\n+                }\n+                else {\n+                    full = readStreamRest(big, read+1, stream);\n+                }\n+            }\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Utility to append the rest of the stream to already read data.\n+     */\n+    private byte[] readStreamRest(byte[] beginning, int length, InputStream stream) throws IOException {\n+        byte[] rest = IOUtils.toByteArray(stream);\n+        byte[] full = new byte[length+rest.length];\n+        System.arraycopy(beginning, 0, full, 0, length);\n+        System.arraycopy(rest, 0, full, length, rest.length);\n+        return full;\n+    }\n+\n     /*\n      * ordertest.zip has been handcrafted.\n      *", "timestamp": 1493145938, "metainfo": ""}