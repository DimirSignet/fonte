{"sha": "ff40903d7d1e683490e3e337db506a2ffc6355c9", "log": "remove meaningless @since tags, references to Ant and a single unused deprecated method  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n     private static final int      WORD = 4;\n     /**\n      * Standard Unix stat(2) file mode.\n-     *\n-     * @since 1.1\n      */\n     private int mode = 0;\n     /**\n      * User ID.\n-     *\n-     * @since 1.1\n      */\n     private int uid = 0;\n     /**\n      * Group ID.\n-     *\n-     * @since 1.1\n      */\n     private int gid = 0;\n     /**\n      * File this entry points to, if it is a symbolic link.\n      *\n      * <p>empty string - if entry is not a symbolic link.</p>\n-     *\n-     * @since 1.1\n      */\n     private String link = \"\";\n     /**\n      * Is this an entry for a directory?\n-     *\n-     * @since 1.1\n      */\n     private boolean dirFlag = false;\n \n     /**\n      * Instance used to calculate checksums.\n-     *\n-     * @since 1.1\n      */\n     private CRC32 crc = new CRC32();\n \n     /**\n      * The Header-ID.\n      * @return the value for the header id for this extrafield\n-     * @since 1.1\n      */\n     public ZipShort getHeaderId() {\n         return HEADER_ID;\n      * Length of the extra field in the local file data - without\n      * Header-ID or length specifier.\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n-     * @since 1.1\n      */\n     public ZipShort getLocalFileDataLength() {\n         return new ZipShort(WORD         // CRC\n     /**\n      * Delegate to local file data.\n      * @return the centralDirectory length\n-     * @since 1.1\n      */\n     public ZipShort getCentralDirectoryLength() {\n         return getLocalFileDataLength();\n      * The actual data to put into local file data - without Header-ID\n      * or length specifier.\n      * @return get the data\n-     * @since 1.1\n      */\n     public byte[] getLocalFileDataData() {\n         // CRC will be added later\n     /**\n      * Delegate to local file data.\n      * @return the local file data\n-     * @since 1.1\n      */\n     public byte[] getCentralDirectoryData() {\n         return getLocalFileDataData();\n     /**\n      * Set the user id.\n      * @param uid the user id\n-     * @since 1.1\n      */\n     public void setUserId(int uid) {\n         this.uid = uid;\n     /**\n      * Get the user id.\n      * @return the user id\n-     * @since 1.1\n      */\n     public int getUserId() {\n         return uid;\n     /**\n      * Set the group id.\n      * @param gid the group id\n-     * @since 1.1\n      */\n     public void setGroupId(int gid) {\n         this.gid = gid;\n     /**\n      * Get the group id.\n      * @return the group id\n-     * @since 1.1\n      */\n     public int getGroupId() {\n         return gid;\n      *\n      * @param name Name of the file this entry links to, empty String\n      *             if it is not a symbolic link.\n-     *\n-     * @since 1.1\n      */\n     public void setLinkedFile(String name) {\n         link = name;\n      *\n      * @return name of the file this entry links to if it is a\n      *         symbolic link, the empty string otherwise.\n-     *\n-     * @since 1.1\n      */\n     public String getLinkedFile() {\n         return link;\n     /**\n      * Is this entry a symbolic link?\n      * @return true if this is a symbolic link\n-     * @since 1.1\n      */\n     public boolean isLink() {\n         return getLinkedFile().length() != 0;\n     /**\n      * File mode of this file.\n      * @param mode the file mode\n-     * @since 1.1\n      */\n     public void setMode(int mode) {\n         this.mode = getMode(mode);\n     /**\n      * File mode of this file.\n      * @return the file mode\n-     * @since 1.1\n      */\n     public int getMode() {\n         return mode;\n     /**\n      * Indicate whether this entry is a directory.\n      * @param dirFlag if true, this entry is a directory\n-     * @since 1.1\n      */\n     public void setDirectory(boolean dirFlag) {\n         this.dirFlag = dirFlag;\n     /**\n      * Is this entry a directory?\n      * @return true if this entry is a directory\n-     * @since 1.1\n      */\n     public boolean isDirectory() {\n         return dirFlag && !isLink();\n      * @param data an array of bytes\n      * @param offset the start offset\n      * @param length the number of bytes in the array from offset\n-     * @since 1.1\n      * @throws ZipException on error\n      */\n     public void parseFromLocalFileData(byte[] data, int offset, int length)\n      * Get the file mode for given permissions with the correct file type.\n      * @param mode the mode\n      * @return the type with the mode\n-     * @since 1.1\n      */\n     protected int getMode(int mode) {\n         int type = FILE_FLAG;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n \n     /**\n      * Static registry of known extra fields.\n-     *\n-     * @since 1.1\n      */\n     private static final Map implementations;\n \n      * <p>The given class must have a no-arg constructor and implement\n      * the {@link ZipExtraField ZipExtraField interface}.</p>\n      * @param c the class to register\n-     *\n-     * @since 1.1\n      */\n     public static void register(Class c) {\n         try {\n      * @return an instance of the appropiate ExtraField\n      * @exception InstantiationException if unable to instantiate the class\n      * @exception IllegalAccessException if not allowed to instatiate the class\n-     * @since 1.1\n      */\n     public static ZipExtraField createExtraField(ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n      * give data.\n      * @param data an array of bytes\n      * @return an array of ExtraFields\n-     * @since 1.1\n      * @throws ZipException on error\n      */\n     public static ZipExtraField[] parse(byte[] data) throws ZipException {\n      * Merges the local file data fields of the given ZipExtraFields.\n      * @param data an array of ExtraFiles\n      * @return an array of bytes\n-     * @since 1.1\n      */\n     public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\n         int sum = WORD * data.length;\n      * Merges the central directory fields of the given ZipExtraFields.\n      * @param data an array of ExtraFields\n      * @return an array of bytes\n-     * @since 1.1\n      */\n     public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\n         int sum = WORD * data.length;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n /**\n  * If this extra field is added as the very first extra field of the\n  * archive, Solaris will consider it an executable jar file.\n- *\n- * @since Ant 1.6.3\n  */\n public final class JarMarker implements ZipExtraField {\n \n      * The actual data to put into local file data - without Header-ID\n      * or length specifier.\n      * @return the data\n-     * @since 1.1\n      */\n     public byte[] getLocalFileDataData() {\n         return NO_BYTES;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n \n     /**\n      * Assemble as unicode comment extension from the comment and\n-     * encoding of the orginal zip entry.\n+     * encoding of the original zip entry.\n      * \n      * @param comment The file comment\n      * @param zipEncoding The encoding of the comment in the zip file,\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n \n     /**\n      * Assemble as unicode path extension from the name and encoding\n-     * of the orginal zip entry.\n+     * of the original zip entry.\n      * \n      * @param name The file name\n      * @param zipEncoding The encoding of the filename in the zip\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n {\n     /**\n      * Bits used for permissions (and sticky bit)\n-     *\n-     * @since 1.1\n      */\n     int PERM_MASK = 07777;\n     /**\n      * Indicates symbolic links.\n-     *\n-     * @since 1.1\n      */\n     int LINK_FLAG = 0120000;\n     /**\n      * Indicates plain files.\n-     *\n-     * @since 1.1\n      */\n     int FILE_FLAG = 0100000;\n     /**\n      * Indicates directories.\n-     *\n-     * @since 1.1\n      */\n     int DIR_FLAG = 040000;\n \n \n     /**\n      * Default permissions for symbolic links.\n-     *\n-     * @since 1.1\n      */\n     int DEFAULT_LINK_PERM = 0777;\n \n     /**\n      * Default permissions for directories.\n-     *\n-     * @since 1.1\n      */\n     int DEFAULT_DIR_PERM = 0755;\n \n     /**\n      * Default permissions for plain files.\n-     *\n-     * @since 1.1\n      */\n     int DEFAULT_FILE_PERM = 0644;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n     /**\n      * Extra field data in central directory - without Header-ID or length\n      * specifier.\n-     *\n-     * @since 1.1\n      */\n     private byte[] m_centralData;\n \n     /**\n      * The Header-ID.\n-     *\n-     * @since 1.1\n      */\n     private ZipShort m_headerID;\n \n     /**\n      * Extra field data in local file data - without Header-ID or length\n      * specifier.\n-     *\n-     * @since 1.1\n      */\n     private byte[] m_localData;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     /**\n      * Creates a new zip entry with the specified name.\n      * @param name the name of the entry\n-     * @since 1.1\n      */\n     public ZipArchiveEntry(String name) {\n         super(name);\n     /**\n      * Creates a new zip entry with fields taken from the specified zip entry.\n      * @param entry the entry to get fields from\n-     * @since 1.1\n      * @throws ZipException on error\n      */\n     public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n      * Creates a new zip entry with fields taken from the specified zip entry.\n      * @param entry the entry to get fields from\n      * @throws ZipException on error\n-     * @since 1.1\n      */\n     public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n         this((java.util.zip.ZipEntry) entry);\n     }\n \n     /**\n-     * @since 1.9\n      */\n     protected ZipArchiveEntry() {\n         super(\"\");\n     /**\n      * Overwrite clone.\n      * @return a cloned copy of this ZipArchiveEntry\n-     * @since 1.1\n      */\n     public Object clone() {\n         ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n      * Retrieves the internal file attributes.\n      *\n      * @return the internal file attributes\n-     * @since 1.1\n      */\n     public int getInternalAttributes() {\n         return internalAttributes;\n     /**\n      * Sets the internal file attributes.\n      * @param value an <code>int</code> value\n-     * @since 1.1\n      */\n     public void setInternalAttributes(int value) {\n         internalAttributes = value;\n     /**\n      * Retrieves the external file attributes.\n      * @return the external file attributes\n-     * @since 1.1\n      */\n     public long getExternalAttributes() {\n         return externalAttributes;\n     /**\n      * Sets the external file attributes.\n      * @param value an <code>long</code> value\n-     * @since 1.1\n      */\n     public void setExternalAttributes(long value) {\n         externalAttributes = value;\n      * Sets Unix permissions in a way that is understood by Info-Zip's\n      * unzip command.\n      * @param mode an <code>int</code> value\n-     * @since Ant 1.5.2\n      */\n     public void setUnixMode(int mode) {\n         // CheckStyle:MagicNumberCheck OFF - no point\n     /**\n      * Unix permission.\n      * @return the unix permissions\n-     * @since Ant 1.6\n      */\n     public int getUnixMode() {\n         return platform != PLATFORM_UNIX ? 0 :\n      *\n      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}\n      * has been called, in which case PLATORM_UNIX will be returned.\n-     *\n-     * @since Ant 1.5.2\n      */\n     public int getPlatform() {\n         return platform;\n     /**\n      * Set the platform (UNIX or FAT).\n      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX\n-     * @since 1.9\n      */\n     protected void setPlatform(int platform) {\n         this.platform = platform;\n     /**\n      * Replaces all currently attached extra fields with the new array.\n      * @param fields an array of extra fields\n-     * @since 1.1\n      */\n     public void setExtraFields(ZipExtraField[] fields) {\n         extraFields = new LinkedHashMap();\n     /**\n      * Retrieves extra fields.\n      * @return an array of the extra fields\n-     * @since 1.1\n      */\n     public ZipExtraField[] getExtraFields() {\n         if (extraFields == null) {\n      * <p>If no extra field of the same type exists, the field will be\n      * added as last field.</p>\n      * @param ze an extra field\n-     * @since 1.1\n      */\n     public void addExtraField(ZipExtraField ze) {\n         if (extraFields == null) {\n      *\n      * <p>The new extra field will be the first one.</p>\n      * @param ze an extra field\n-     * @since 1.1\n      */\n     public void addAsFirstExtraField(ZipExtraField ze) {\n         LinkedHashMap copy = extraFields;\n     /**\n      * Remove an extra fields.\n      * @param type the type of extra field to remove\n-     * @since 1.1\n      */\n     public void removeExtraField(ZipShort type) {\n         if (extraFields == null) {\n      * Throws an Exception if extra data cannot be parsed into extra fields.\n      * @param extra an array of bytes to be parsed into extra fields\n      * @throws RuntimeException if the bytes cannot be parsed\n-     * @since 1.1\n      * @throws RuntimeException on error\n      */\n     public void setExtra(byte[] extra) throws RuntimeException {\n      * java.util.zip.ZipOutputStream} seems to access the extra data\n      * directly, so overriding getExtra doesn't help - we need to\n      * modify super's data directly.\n-     *\n-     * @since 1.1\n      */\n     protected void setExtra() {\n         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n     /**\n      * Retrieves the extra data for the local file data.\n      * @return the extra data for local file\n-     * @since 1.1\n      */\n     public byte[] getLocalFileDataExtra() {\n         byte[] extra = getExtra();\n     /**\n      * Retrieves the extra data for the central directory.\n      * @return the central directory extra data\n-     * @since 1.1\n      */\n     public byte[] getCentralDirectoryExtra() {\n         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n     }\n \n     /**\n-     * Make this class work in JDK 1.1 like a 1.2 class.\n-     *\n-     * <p>This either stores the size for later usage or invokes\n-     * setCompressedSize via reflection.</p>\n-     * @param size the size to use\n-     * @deprecated since 1.7.\n-     *             Use setCompressedSize directly.\n-     * @since 1.2\n-     */\n-    public void setComprSize(long size) {\n-        setCompressedSize(size);\n-    }\n-\n-    /**\n      * Get the name of the entry.\n      * @return the entry name\n-     * @since 1.9\n      */\n     public String getName() {\n         return name == null ? super.getName() : name;\n     /**\n      * Is this entry a directory?\n      * @return true if the entry is a directory\n-     * @since 1.10\n      */\n     public boolean isDirectory() {\n         return getName().endsWith(\"/\");\n      * Get the hashCode of the entry.\n      * This uses the name as the hashcode.\n      * @return a hashcode.\n-     * @since Ant 1.7\n      */\n     public int hashCode() {\n         // this method has severe consequences on performance. We cannot rely\n      * which is basically the equals method of the Object class.\n      * @param o the object to compare to\n      * @return true if this object is the same as <code>o</code>\n-     * @since Ant 1.7\n      */\n     public boolean equals(Object o) {\n         return (this == o);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n \n     /**\n      * Compression method for deflated entries.\n-     *\n-     * @since 1.1\n      */\n     public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n \n     /**\n      * Default compression level for deflated entries.\n-     *\n-     * @since Ant 1.7\n      */\n     public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n \n     /**\n      * Compression method for stored entries.\n-     *\n-     * @since 1.1\n      */\n     public static final int STORED = java.util.zip.ZipEntry.STORED;\n \n \n     /**\n      * Current entry.\n-     *\n-     * @since 1.1\n      */\n     private ZipArchiveEntry entry;\n \n     /**\n      * The file comment.\n-     *\n-     * @since 1.1\n      */\n     private String comment = \"\";\n \n     /**\n      * Compression level for next entry.\n-     *\n-     * @since 1.1\n      */\n     private int level = DEFAULT_COMPRESSION;\n \n     /**\n      * Has the compression level changed when compared to the last\n      * entry?\n-     *\n-     * @since 1.5\n      */\n     private boolean hasCompressionLevelChanged = false;\n \n     /**\n      * Default compression method for next entry.\n-     *\n-     * @since 1.1\n      */\n     private int method = java.util.zip.ZipEntry.DEFLATED;\n \n     /**\n-     * List of ZipEntries written so far.\n-     *\n-     * @since 1.1\n+     * List of ZipArchiveEntries written so far.\n      */\n     private final List entries = new LinkedList();\n \n     /**\n      * CRC instance to avoid parsing DEFLATED data twice.\n-     *\n-     * @since 1.1\n      */\n     private final CRC32 crc = new CRC32();\n \n     /**\n      * Count the bytes written to out.\n-     *\n-     * @since 1.1\n      */\n     private long written = 0;\n \n     /**\n      * Data for local header data\n-     *\n-     * @since 1.1\n      */\n     private long dataStart = 0;\n \n     /**\n      * Offset for CRC entry in the local file header data for the\n      * current entry starts here.\n-     *\n-     * @since 1.15\n      */\n     private long localDataStart = 0;\n \n     /**\n      * Start of central directory.\n-     *\n-     * @since 1.1\n      */\n     private long cdOffset = 0;\n \n     /**\n      * Length of central directory.\n-     *\n-     * @since 1.1\n      */\n     private long cdLength = 0;\n \n     /**\n      * Helper, a 0 as ZipShort.\n-     *\n-     * @since 1.1\n      */\n     private static final byte[] ZERO = {0, 0};\n \n     /**\n      * Helper, a 0 as ZipLong.\n-     *\n-     * @since 1.1\n      */\n     private static final byte[] LZERO = {0, 0, 0, 0};\n \n     /**\n      * Holds the offsets of the LFH starts for each entry.\n-     *\n-     * @since 1.1\n      */\n     private final Map offsets = new HashMap();\n \n      * <p>For a list of possible values see <a\n      * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n      * Defaults to UTF-8.</p>\n-     *\n-     * @since 1.3\n      */\n     private String encoding = DEFAULT_ENCODING;\n \n      * backwards compatibility.  This class used to extend {@link\n      * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n      * Revision 1.13.</p>\n-     *\n-     * @since 1.14\n      */\n     protected Deflater def = new Deflater(level, true);\n \n      * backwards compatibility.  This class used to extend {@link\n      * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n      * Revision 1.13.</p>\n-     *\n-     * @since 1.14\n      */\n     protected byte[] buf = new byte[BUFFER_SIZE];\n \n \n     /**\n      * Optional random access output.\n-     *\n-     * @since 1.14\n      */\n     private RandomAccessFile raf = null;\n \n     /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n      * @param out the outputstream to zip\n-     * @since 1.1\n      */\n     public ZipArchiveOutputStream(OutputStream out) {\n         this.out = out;\n      * Creates a new ZIP OutputStream writing to a File.  Will use\n      * random access if possible.\n      * @param file the file to zip to\n-     * @since 1.14\n      * @throws IOException on error\n      */\n     public ZipArchiveOutputStream(File file) throws IOException {\n      * uncompressed size for {@link #STORED} entries before\n      * invoking {@link #putNextEntry}.\n      * @return true if seekable\n-     * @since 1.17\n      */\n     public boolean isSeekable() {\n         return raf != null;\n      * Defaults to UTF-8.</p>\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n-     * @since 1.3\n      */\n     public void setEncoding(final String encoding) {\n         this.encoding = encoding;\n      * The encoding to use for filenames and the file comment.\n      *\n      * @return null if using the platform's default character encoding.\n-     *\n-     * @since 1.3\n      */\n     public String getEncoding() {\n         return encoding;\n     /**\n      * Finishs writing the contents and closes this as well as the\n      * underlying stream.\n-     *\n-     * @since 1.1\n      * @throws IOException on error\n      */\n     public void finish() throws IOException {\n \n     /**\n      * Writes all necessary data for this entry.\n-     *\n-     * @since 1.1\n      * @throws IOException on error\n      */\n     public void closeEntry() throws IOException {\n     /**\n      * Begin writing next entry.\n      * @param ze the entry to write\n-     * @since 1.1\n      * @throws IOException on error\n      */\n     public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n     /**\n      * Set the file comment.\n      * @param comment the comment\n-     * @since 1.1\n      */\n     public void setComment(String comment) {\n         this.comment = comment;\n      * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>\n      * @param level the compression level.\n      * @throws IllegalArgumentException if an invalid compression level is specified.\n-     * @since 1.1\n      */\n     public void setLevel(int level) {\n         if (level < Deflater.DEFAULT_COMPRESSION\n      *\n      * <p>Default is DEFLATED.</p>\n      * @param method an <code>int</code> from java.util.zip.ZipEntry\n-     * @since 1.1\n      */\n     public void setMethod(int method) {\n         this.method = method;\n      *\n      * <p>Delegates to the three arg method.</p>\n      * @param b the byte to write\n-     * @since 1.14\n      * @throws IOException on error\n      */\n     public void write(int b) throws IOException {\n      * associated with the stream.\n      *\n      * @exception  IOException  if an I/O error occurs.\n-     * @since 1.14\n      */\n     public void close() throws IOException {\n         finish();\n      * to be written out to the stream.\n      *\n      * @exception  IOException  if an I/O error occurs.\n-     * @since 1.14\n      */\n     public void flush() throws IOException {\n         if (out != null) {\n      */\n     /**\n      * local file header signature\n-     *\n-     * @since 1.1\n      */\n     static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);\n     /**\n      * data descriptor signature\n-     *\n-     * @since 1.1\n      */\n     static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\n     /**\n      * central file header signature\n-     *\n-     * @since 1.1\n      */\n     static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);\n     /**\n      * end of central dir signature\n-     *\n-     * @since 1.1\n      */\n     static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n \n     /**\n      * Writes next block of compressed data to the output stream.\n      * @throws IOException on error\n-     *\n-     * @since 1.14\n      */\n     protected final void deflate() throws IOException {\n         int len = def.deflate(buf, 0, buf.length);\n      * Writes the local file header entry\n      * @param ze the entry to write\n      * @throws IOException on error\n-     *\n-     * @since 1.1\n      */\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n      * Writes the data descriptor entry.\n      * @param ze the entry to write\n      * @throws IOException on error\n-     *\n-     * @since 1.1\n      */\n     protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n         if (ze.getMethod() != DEFLATED || raf != null) {\n      * Writes the central file header entry.\n      * @param ze the entry to write\n      * @throws IOException on error\n-     *\n-     * @since 1.1\n      */\n     protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n         writeOut(CFH_SIG);\n     /**\n      * Writes the &quot;End of central dir record&quot;.\n      * @throws IOException on error\n-     *\n-     * @since 1.1\n      */\n     protected void writeCentralDirectoryEnd() throws IOException {\n         writeOut(EOCD_SIG);\n \n     /**\n      * Smallest date/time ZIP can handle.\n-     *\n-     * @since 1.1\n      */\n     private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n \n      * Convert a Date object to a DOS date/time field.\n      * @param time the <code>Date</code> to convert\n      * @return the date as a <code>ZipLong</code>\n-     * @since 1.1\n      */\n     protected static ZipLong toDosTime(Date time) {\n         return new ZipLong(toDosTime(time.getTime()));\n      * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n      * @param t number of milliseconds since the epoch\n      * @return the date as a byte array\n-     * @since 1.26\n      */\n     protected static byte[] toDosTime(long t) {\n         Date time = new Date(t);\n      * @param name the string to get bytes from\n      * @return the bytes as a byte array\n      * @throws ZipException on error\n-     *\n-     * @since 1.3\n      */\n     protected byte[] getBytes(String name) throws ZipException {\n         if (encoding == null) {\n      * Write bytes to output or random access file.\n      * @param data the byte array to write\n      * @throws IOException on error\n-     *\n-     * @since 1.14\n      */\n     protected final void writeOut(byte[] data) throws IOException {\n         writeOut(data, 0, data.length);\n      * @param offset the start position to write from\n      * @param length the number of bytes to write\n      * @throws IOException on error\n-     *\n-     * @since 1.14\n      */\n     protected final void writeOut(byte[] data, int offset, int length)\n         throws IOException {\n      * has wrapped around and re-creates the original value.\n      * @param i the value to treat as unsigned int.\n      * @return the unsigned int as a long.\n-     * @since 1.34\n      */\n     protected static long adjustToLong(int i) {\n         if (i < 0) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n      * The Header-ID.\n      *\n      * @return The HeaderId value\n-     * @since 1.1\n      */\n     ZipShort getHeaderId();\n \n      * length specifier.\n      *\n      * @return The LocalFileDataLength value\n-     * @since 1.1\n      */\n     ZipShort getLocalFileDataLength();\n \n      * length specifier.\n      *\n      * @return The CentralDirectoryLength value\n-     * @since 1.1\n      */\n     ZipShort getCentralDirectoryLength();\n \n      * specifier.\n      *\n      * @return The LocalFileDataData value\n-     * @since 1.1\n      */\n     byte[] getLocalFileDataData();\n \n      * length specifier.\n      *\n      * @return The CentralDirectoryData value\n-     * @since 1.1\n      */\n     byte[] getCentralDirectoryData();\n \n      * @param offset offset into buffer to read data\n      * @param length the length of data\n      * @exception ZipException on error\n-     * @since 1.1\n      */\n     void parseFromLocalFileData( byte[] buffer, int offset, int length )\n         throws ZipException;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n  * (which is required to work on ZIP files created by native zip tools\n  * and is able to skip a preamble like the one found in self\n  * extracting archives.  Furthermore it returns instances of\n- * <code>org.apache.tools.zip.ZipArchiveEntry</code> instead of\n- * <code>java.util.zip.ZipEntry</code>.</p>\n+ * <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n+ * instead of <code>java.util.zip.ZipEntry</code>.</p>\n  *\n  * <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would\n  * have to reimplement all methods anyway.  Like\n  *   <li>There is no getName method.</li>\n  *   <li>entries has been renamed to getEntries.</li>\n  *   <li>getEntries and getEntry return\n- *   <code>org.apache.tools.zip.ZipArchiveEntry</code> instances.</li>\n+ *   <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code>\n+ *   instances.</li>\n  *   <li>close is allowed to throw IOException.</li>\n  * </ul>\n  *\n                                                + \" central directory\");\n                 }\n                 lenToSkip -= skipped;\n-            }            \n+            }\n \n             byte[] comment = new byte[commentLen];\n             archive.readFully(comment);\n                                                + \" local file header\");\n                 }\n                 lenToSkip -= skipped;\n-            }            \n+            }\n             byte[] localExtraData = new byte[extraFieldLen];\n             archive.readFully(localExtraData);\n             ze.setExtra(localExtraData);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n /**\n  * Utility class that represents a four byte integer with conversion\n  * rules for the big endian byte order of ZIP files.\n- *\n  */\n public final class ZipLong implements Cloneable {\n \n     /**\n      * Create instance from a number.\n      * @param value the long to store as a ZipLong\n-     * @since 1.1\n      */\n     public ZipLong(long value) {\n         this.value = value;\n     /**\n      * Create instance from bytes.\n      * @param bytes the bytes to store as a ZipLong\n-     * @since 1.1\n      */\n     public ZipLong (byte[] bytes) {\n         this(bytes, 0);\n      * Create instance from the four bytes starting at offset.\n      * @param bytes the bytes to store as a ZipLong\n      * @param offset the offset to start\n-     * @since 1.1\n      */\n     public ZipLong (byte[] bytes, int offset) {\n         value = ZipLong.getValue(bytes, offset);\n \n     /**\n      * Get value as four bytes in big endian byte order.\n-     * @since 1.1\n      * @return value as four bytes in big endian order\n      */\n     public byte[] getBytes() {\n \n     /**\n      * Get value as Java long.\n-     * @since 1.1\n      * @return value as a long\n      */\n     public long getValue() {\n      * Override to make two instances with same value equal.\n      * @param o an object to compare\n      * @return true if the objects are equal\n-     * @since 1.1\n      */\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipLong)) {\n     /**\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipLong\n-     * @since 1.1\n      */\n     public int hashCode() {\n         return (int) value;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n     /**\n      * Create instance from a number.\n      * @param value the int to store as a ZipShort\n-     * @since 1.1\n      */\n     public ZipShort (int value) {\n         this.value = value;\n     /**\n      * Create instance from bytes.\n      * @param bytes the bytes to store as a ZipShort\n-     * @since 1.1\n      */\n     public ZipShort (byte[] bytes) {\n         this(bytes, 0);\n      * Create instance from the two bytes starting at offset.\n      * @param bytes the bytes to store as a ZipShort\n      * @param offset the offset to start\n-     * @since 1.1\n      */\n     public ZipShort (byte[] bytes, int offset) {\n         value = ZipShort.getValue(bytes, offset);\n     /**\n      * Get value as two bytes in big endian byte order.\n      * @return the value as a a two byte array in big endian byte order\n-     * @since 1.1\n      */\n     public byte[] getBytes() {\n         byte[] result = new byte[2];\n     /**\n      * Get value as Java int.\n      * @return value as a Java int\n-     * @since 1.1\n      */\n     public int getValue() {\n         return value;\n      * Override to make two instances with same value equal.\n      * @param o an object to compare\n      * @return true if the objects are equal\n-     * @since 1.1\n      */\n     public boolean equals(Object o) {\n         if (o == null || !(o instanceof ZipShort)) {\n     /**\n      * Override to make two instances with same value equal.\n      * @return the value stored in the ZipShort\n-     * @since 1.1\n      */\n     public int hashCode() {\n         return value;", "timestamp": 1235667940, "metainfo": ""}