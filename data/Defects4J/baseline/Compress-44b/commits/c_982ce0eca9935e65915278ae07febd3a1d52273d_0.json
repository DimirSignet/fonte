{"sha": "982ce0eca9935e65915278ae07febd3a1d52273d", "log": "COMPRESS-271 verify block checksums", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n import org.apache.commons.compress.compressors.CompressorInputStream;\n import org.apache.commons.compress.utils.BoundedInputStream;\n import org.apache.commons.compress.utils.ByteUtils;\n+import org.apache.commons.compress.utils.ChecksumCalculatingInputStream;\n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n \n     // used for frame header checksum and content checksum, if present\n     private final XXHash32 contentHash = new XXHash32();\n+\n+    // used for block checksum, if present\n+    private final XXHash32 blockHash = new XXHash32();\n \n     // only created if the frame doesn't set the block independence flag\n     private byte[] blockDependencyBuffer;\n             return;\n         }\n         InputStream capped = new BoundedInputStream(in, realLen);\n+        if (expectBlockChecksum) {\n+            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n+        }\n         if (uncompressed) {\n             inUncompressed = true;\n             currentBlock = capped;\n             currentBlock.close();\n             currentBlock = null;\n             if (expectBlockChecksum) {\n-                int skipped = (int) IOUtils.skip(in, 4);\n-                count(skipped);\n-                if (4 != skipped) {\n-                    throw new IOException(\"Premature end of stream while reading block checksum\");\n-                }\n+                verifyChecksum(blockHash, \"block\");\n+                blockHash.reset();\n             }\n         }\n     }\n \n     private void verifyContentChecksum() throws IOException {\n         if (expectContentChecksum) {\n-            byte[] checksum = new byte[4];\n-            int read = IOUtils.readFully(in, checksum);\n-            count(read);\n-            if (4 != read) {\n-                throw new IOException(\"Premature end of stream while reading content checksum\");\n-            }\n-            long expectedHash = contentHash.getValue();\n-            if (expectedHash != ByteUtils.fromLittleEndian(checksum)) {\n-                throw new IOException(\"content checksum mismatch.\");\n-            }\n+            verifyChecksum(contentHash, \"content\");\n         }\n         contentHash.reset();\n+    }\n+\n+    private void verifyChecksum(XXHash32 hash, String kind) throws IOException {\n+        byte[] checksum = new byte[4];\n+        int read = IOUtils.readFully(in, checksum);\n+        count(read);\n+        if (4 != read) {\n+            throw new IOException(\"Premature end of stream while reading \" + kind + \" checksum\");\n+        }\n+        long expectedHash = hash.getValue();\n+        if (expectedHash != ByteUtils.fromLittleEndian(checksum)) {\n+            throw new IOException(kind + \" checksum mismatch.\");\n+        }\n     }\n \n     private int readOneByte() throws IOException {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * A stream that calculates the checksum of the data read.\n+ * @NotThreadSafe\n+ * @since 1.14\n+ */\n+public class ChecksumCalculatingInputStream extends InputStream {\n+    private final InputStream in;\n+    private final Checksum checksum;\n+\n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        this.checksum = checksum;\n+        this.in = in;\n+    }\n+\n+    /**\n+     * Reads a single byte from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        final int ret = in.read();\n+        if (ret >= 0) {\n+            checksum.update(ret);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Reads a byte array from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    /**\n+     * Reads from the stream into a byte array.\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        final int ret = in.read(b, off, len);\n+        if (ret >= 0) {\n+            checksum.update(b, off, ret);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public long skip(final long n) throws IOException {\n+        // Can't really skip, we have to hash everything to verify the checksum\n+        if (read() >= 0) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Returns the calculated checksum.\n+     * @return the calculated checksum.\n+     */\n+    public long getValue() {\n+        return checksum.getValue();\n+    }\n+\n+}", "timestamp": 1486658221, "metainfo": ""}