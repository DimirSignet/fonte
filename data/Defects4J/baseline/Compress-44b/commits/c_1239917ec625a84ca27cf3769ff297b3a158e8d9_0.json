{"sha": "1239917ec625a84ca27cf3769ff297b3a158e8d9", "log": "add support for NTFS timestamp field  I need to create a real archive containing the extra field on a Windows box for a real test", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         register(UnicodePathExtraField.class);\n         register(UnicodeCommentExtraField.class);\n         register(Zip64ExtendedInformationExtraField.class);\n+        register(X000A_NTFS.class);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.Date;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * NTFS extra field that was thought to store various attributes but\n+ * in reality only stores timestamps.\n+ *\n+ * <pre>\n+ *    4.5.5 -NTFS Extra Field (0x000a):\n+ *\n+ *       The following is the layout of the NTFS attributes\n+ *       \"extra\" block. (Note: At this time the Mtime, Atime\n+ *       and Ctime values MAY be used on any WIN32 system.)\n+ *\n+ *       Note: all fields stored in Intel low-byte/high-byte order.\n+ *\n+ *         Value      Size       Description\n+ *         -----      ----       -----------\n+ * (NTFS)  0x000a     2 bytes    Tag for this \"extra\" block type\n+ *         TSize      2 bytes    Size of the total \"extra\" block\n+ *         Reserved   4 bytes    Reserved for future use\n+ *         Tag1       2 bytes    NTFS attribute tag value #1\n+ *         Size1      2 bytes    Size of attribute #1, in bytes\n+ *         (var)      Size1      Attribute #1 data\n+ *          .\n+ *          .\n+ *          .\n+ *          TagN       2 bytes    NTFS attribute tag value #N\n+ *          SizeN      2 bytes    Size of attribute #N, in bytes\n+ *          (var)      SizeN      Attribute #N data\n+ *\n+ *        For NTFS, values for Tag1 through TagN are as follows:\n+ *        (currently only one set of attributes is defined for NTFS)\n+ *\n+ *          Tag        Size       Description\n+ *          -----      ----       -----------\n+ *          0x0001     2 bytes    Tag for attribute #1\n+ *          Size1      2 bytes    Size of attribute #1, in bytes\n+ *          Mtime      8 bytes    File last modification time\n+ *          Atime      8 bytes    File last access time\n+ *          Ctime      8 bytes    File creation time\n+ * </pre>\n+ */\n+public class X000A_NTFS implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x000a);\n+    private static final ZipShort TIME_ATTR_TAG = new ZipShort(0x0001);\n+    private static final ZipShort TIME_ATTR_SIZE = new ZipShort(3 * 8);\n+\n+    private ZipEightByteInteger modifyTime = ZipEightByteInteger.ZERO;\n+    private ZipEightByteInteger accessTime = ZipEightByteInteger.ZERO;\n+    private ZipEightByteInteger createTime = ZipEightByteInteger.ZERO;\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return the value for the header id for this extrafield\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(4 /* reserved */\n+                            + 2 /* Tag#1 */\n+                            + 2 /* Size#1 */\n+                            + 3 * 8 /* time values */);\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     *\n+     * <p>For X5455 the central length is often smaller than the\n+     * local length, because central cannot contain access or create\n+     * timestamps.</p>\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return get the data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        byte[] data = new byte[getLocalFileDataLength().getValue()];\n+        int pos = 4;\n+        System.arraycopy(TIME_ATTR_TAG.getBytes(), 0, data, pos, 2);\n+        pos += 2;\n+        System.arraycopy(TIME_ATTR_SIZE.getBytes(), 0, data, pos, 2);\n+        pos += 2;\n+        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 8);\n+        pos += 8;\n+        System.arraycopy(accessTime.getBytes(), 0, data, pos, 8);\n+        pos += 8;\n+        System.arraycopy(createTime.getBytes(), 0, data, pos, 8);\n+        return data;\n+    }\n+\n+    /**\n+     * The actual data to put into central directory data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return the central directory data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param data   an array of bytes\n+     * @param offset the start offset\n+     * @param length the number of bytes in the array from offset\n+     * @throws java.util.zip.ZipException on error\n+     */\n+    public void parseFromLocalFileData(\n+            byte[] data, int offset, int length\n+    ) throws ZipException {\n+        final int len = offset + length;\n+\n+        // skip reserved\n+        offset += 4;\n+\n+        while (offset + 4 <= len) {\n+            ZipShort tag = new ZipShort(data, offset);\n+            offset += 2;\n+            if (tag.equals(TIME_ATTR_TAG)) {\n+                readTimeAttr(data, offset, len - offset);\n+                break;\n+            }\n+            ZipShort size = new ZipShort(data, offset);\n+            offset += 2 + size.getValue();\n+        }\n+    }\n+\n+    /**\n+     * Doesn't do anything special since this class always uses the\n+     * same parsing logic for both central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(\n+            byte[] buffer, int offset, int length\n+    ) throws ZipException {\n+        reset();\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n+\n+    /**\n+     * Returns the \"File last modification time\" of this zip entry as\n+     * a ZipEightByteInteger object, or {@link\n+     * ZipEightByteInteger#ZERO} if no such timestamp exists in the\n+     * zip entry.\n+     *\n+     * @return File last modification time\n+     */\n+    public ZipEightByteInteger getModifyTime() { return modifyTime; }\n+\n+    /**\n+     * Returns the \"File last access time\" of this zip entry as a\n+     * ZipEightByteInteger object, or {@link ZipEightByteInteger#ZERO}\n+     * if no such timestamp exists in the zip entry.\n+     *\n+     * @return File last access time\n+     */\n+    public ZipEightByteInteger getAccessTime() { return accessTime; }\n+\n+    /**\n+     * Returns the \"File creation time\" of this zip entry as a\n+     * ZipEightByteInteger object, or {@link ZipEightByteInteger#ZERO}\n+     * if no such timestamp exists in the zip entry.\n+     *\n+     * @return File creation time\n+     */\n+    public ZipEightByteInteger getCreateTime() { return createTime; }\n+\n+    /**\n+     * Returns the modify time as a java.util.Date\n+     * of this zip entry, or null if no such timestamp exists in the zip entry.\n+     *\n+     * @return modify time as java.util.Date or null.\n+     */\n+    public Date getModifyJavaTime() {\n+        return zipToDate(modifyTime);\n+    }\n+\n+    /**\n+     * Returns the access time as a java.util.Date\n+     * of this zip entry, or null if no such timestamp exists in the zip entry.\n+     *\n+     * @return access time as java.util.Date or null.\n+     */\n+    public Date getAccessJavaTime() {\n+        return zipToDate(accessTime);\n+    }\n+\n+    /**\n+     * Returns the create time as a a java.util.Date of this zip\n+     * entry, or null if no such timestamp exists in the zip entry.\n+     *\n+     * @return create time as java.util.Date or null.\n+     */\n+    public Date getCreateJavaTime() {\n+        return zipToDate(createTime);\n+    }\n+\n+    /**\n+     * Sets the File last modification time of this zip entry using a\n+     * ZipEightByteInteger object.\n+     *\n+     * @param t ZipEightByteInteger of the modify time\n+     */\n+    public void setModifyTime(ZipEightByteInteger t) {\n+        modifyTime = t == null ? ZipEightByteInteger.ZERO : t;\n+    }\n+\n+    /**\n+     * Sets the File last access time of this zip entry using a\n+     * ZipEightByteInteger object.\n+     *\n+     * @param t ZipEightByteInteger of the access time\n+     */\n+    public void setAccessTime(ZipEightByteInteger t) {\n+        accessTime = t == null ? ZipEightByteInteger.ZERO : t;\n+    }\n+\n+    /**\n+     * Sets the File creation time of this zip entry using a\n+     * ZipEightByteInteger object.\n+     *\n+     * @param t ZipEightByteInteger of the create time\n+     */\n+    public void setCreateTime(ZipEightByteInteger t) {\n+        createTime = t == null ? ZipEightByteInteger.ZERO : t;\n+    }\n+\n+    /**\n+     * Sets the modify time as a java.util.Date of this zip entry.\n+     *\n+     * @param d modify time as java.util.Date\n+     */\n+    public void setModifyJavaTime(Date d) { setModifyTime(dateToZip(d)); }\n+\n+    /**\n+     * Sets the access time as a java.util.Date\n+     * of this zip entry.\n+     *\n+     * @param d access time as java.util.Date\n+     */\n+    public void setAccessJavaTime(Date d) { setAccessTime(dateToZip(d)); }\n+\n+    /**\n+     * <p>\n+     * Sets the create time as a java.util.Date\n+     * of this zip entry.  Supplied value is truncated to per-second\n+     * precision (milliseconds zeroed-out).\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param d create time as java.util.Date\n+     */\n+    public void setCreateJavaTime(Date d) { setCreateTime(dateToZip(d)); }\n+\n+    /**\n+     * Returns a String representation of this class useful for\n+     * debugging purposes.\n+     *\n+     * @return A String representation of this class useful for\n+     *         debugging purposes.\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuilder buf = new StringBuilder();\n+        buf.append(\"0x000A Zip Extra Field:\")\n+            .append(\" Modify:[\").append(getModifyJavaTime()).append(\"] \")\n+            .append(\" Access:[\").append(getAccessJavaTime()).append(\"] \")\n+            .append(\" Create:[\").append(getCreateJavaTime()).append(\"] \");\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o instanceof X000A_NTFS) {\n+            X000A_NTFS xf = (X000A_NTFS) o;\n+\n+            return (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n+                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n+                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hc = -123;\n+        if (modifyTime != null) {\n+            hc ^= modifyTime.hashCode();\n+        }\n+        if (accessTime != null) {\n+            // Since accessTime is often same as modifyTime,\n+            // this prevents them from XOR negating each other.\n+            hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);\n+        }\n+        if (createTime != null) {\n+            hc ^= Integer.rotateLeft(createTime.hashCode(), 22);\n+        }\n+        return hc;\n+    }\n+\n+    /**\n+     * Reset state back to newly constructed state.  Helps us make sure\n+     * parse() calls always generate clean results.\n+     */\n+    private void reset() {\n+        this.modifyTime = ZipEightByteInteger.ZERO;\n+        this.accessTime = ZipEightByteInteger.ZERO;\n+        this.createTime = ZipEightByteInteger.ZERO;\n+    }\n+\n+    private void readTimeAttr(byte[] data, int offset, int length) {\n+        if (length >= 2 + 3 * 8) {\n+            ZipShort tagValueLength = new ZipShort(data, offset);\n+            if (TIME_ATTR_SIZE.equals(tagValueLength)) {\n+                offset += 2;\n+                modifyTime = new ZipEightByteInteger(data, offset);\n+                offset += 8;\n+                accessTime = new ZipEightByteInteger(data, offset);\n+                offset += 8;\n+                createTime = new ZipEightByteInteger(data, offset);\n+            }\n+        }\n+    }\n+\n+    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724290%28v=vs.85%29.aspx\n+    // A file time is a 64-bit value that represents the number of\n+    // 100-nanosecond intervals that have elapsed since 12:00\n+    // A.M. January 1, 1601 Coordinated Universal Time (UTC).\n+    // this is the offset of Windows time 0 to Unix epoch in 100-nanosecond intervals\n+    private static final long EPOCH_OFFSET = -116444736000000000L;\n+\n+    private static ZipEightByteInteger dateToZip(final Date d) {\n+        if (d == null) { return null; }\n+        return new ZipEightByteInteger((d.getTime() * 10000l) - EPOCH_OFFSET);\n+    }\n+\n+    private static Date zipToDate(ZipEightByteInteger z) {\n+        if (z == null || ZipEightByteInteger.ZERO.equals(z)) { return null; }\n+        long l = (z.getLongValue() + EPOCH_OFFSET) / 10000l;\n+        return new Date(l);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X000A_NTFSTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.junit.Test;\n+\n+import java.util.Date;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class X000A_NTFSTest {\n+\n+    @Test\n+    public void simpleRountrip() throws Exception {\n+        X000A_NTFS xf = new X000A_NTFS();\n+        xf.setModifyJavaTime(new Date(0));\n+        // one second past midnight\n+        xf.setAccessJavaTime(new Date(-11644473601000l));\n+        xf.setCreateJavaTime(null);\n+        byte[] b = xf.getLocalFileDataData();\n+\n+        X000A_NTFS xf2 = new X000A_NTFS();\n+        xf2.parseFromLocalFileData(b, 0, b.length);\n+        assertEquals(new Date(0), xf2.getModifyJavaTime());\n+        assertEquals(new Date(-11644473601000l), xf2.getAccessJavaTime());\n+        assertEquals(null, xf2.getCreateJavaTime());\n+    }\n+}", "timestamp": 1450034816, "metainfo": ""}