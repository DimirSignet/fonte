{"sha": "45b3f7cc0dcebde4bc2e733e02fd73cb008ad5ef", "log": "Use the ZIP64 structures to locate the central directory in ZipFile if the archive is a ZIP64 archive, fallback to 'the old way' if it is not a ZIP64 archive.  COMPRESS-149  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.util.zip.InflaterInputStream;\n import java.util.zip.ZipException;\n \n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n         }\n     }\n \n+    /**\n+     * Length of a \"central directory\" entry structure without file\n+     * name, extra fields or comment.\n+     */\n     private static final int CFH_LEN =\n         /* version made by                 */ SHORT\n         /* version needed to extract       */ + SHORT\n         return noUTF8Flag;\n     }\n \n+    /**\n+     * Length of the \"End of central directory record\" - which is\n+     * supposed to be the last structure of the archive - without file\n+     * comment.\n+     */\n     private static final int MIN_EOCD_SIZE =\n         /* end of central dir signature    */ WORD\n         /* number of this disk             */ + SHORT\n         /* the starting disk number        */ + WORD\n         /* zipfile comment length          */ + SHORT;\n \n+    /**\n+     * Maximum length of the \"End of central directory record\" with a\n+     * file comment.\n+     */\n     private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE\n         /* maximum length of zipfile comment */ + ZIP64_MAGIC_SHORT;\n \n+    /**\n+     * Offset of the field that holds the location of the first\n+     * central directory entry inside the \"End of central directory\n+     * record\" relative to the start of the \"End of central directory\n+     * record\".\n+     */\n     private static final int CFD_LOCATOR_OFFSET =\n         /* end of central dir signature    */ WORD\n         /* number of this disk             */ + SHORT\n         /* size of the central directory   */ + WORD;\n \n     /**\n+     * Length of the \"Zip64 end of central directory locator\" - which\n+     * should be right in front of the \"end of central directory\n+     * record\" if one is present at all.\n+     */\n+    private static final int ZIP64_EOCDL_LENGTH =\n+        /* zip64 end of central dir locator sig */ WORD\n+        /* number of the disk with the start    */\n+        /* start of the zip64 end of            */\n+        /* central directory                    */ + WORD\n+        /* relative offset of the zip64         */\n+        /* end of central directory record      */ + DWORD\n+        /* total number of disks                */ + WORD;\n+\n+    /**\n+     * Offset of the field that holds the location of the \"Zip64 end\n+     * of central directory record\" inside the \"Zip64 end of central\n+     * directory locator\" relative to the start of the \"Zip64 end of\n+     * central directory locator\".\n+     */\n+    private static final int ZIP64_EOCDL_LOCATOR_OFFSET =\n+        /* zip64 end of central dir locator sig */ WORD\n+        /* number of the disk with the start    */\n+        /* start of the zip64 end of            */\n+        /* central directory                    */ + WORD;\n+\n+    /**\n+     * Offset of the field that holds the location of the first\n+     * central directory entry inside the \"Zip64 end of central\n+     * directory record\" relative to the start of the \"Zip64 end of\n+     * central directory record\".\n+     */\n+    private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET =\n+        /* zip64 end of central dir        */\n+        /* signature                       */ WORD\n+        /* size of zip64 end of central    */\n+        /* directory record                */ + DWORD\n+        /* version made by                 */ + SHORT\n+        /* version needed to extract       */ + SHORT\n+        /* number of this disk             */ + WORD\n+        /* number of the disk with the     */\n+        /* start of the central directory  */ + WORD\n+        /* total number of entries in the  */\n+        /* central directory on this disk  */ + DWORD\n+        /* total number of entries in the  */\n+        /* central directory               */ + DWORD\n+        /* size of the central directory   */ + DWORD;\n+\n+    /**\n+     * Searches for either the &quot;Zip64 end of central directory\n+     * locator&quot; or the &quot;End of central dir record&quot;, parses\n+     * it and positions the stream at the first central directory\n+     * record.\n+     */\n+    private void positionAtCentralDirectory()\n+        throws IOException {\n+        boolean found = tryToLocateSignature(MIN_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n+                                             MAX_EOCD_SIZE + ZIP64_EOCDL_LENGTH,\n+                                             ZipArchiveOutputStream\n+                                             .ZIP64_EOCD_LOC_SIG);\n+        if (!found) {\n+            // not a ZIP64 archive\n+            positionAtCentralDirectory32();\n+        } else {\n+            archive.skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET);\n+            byte[] zip64EocdOffset = new byte[DWORD];\n+            archive.readFully(zip64EocdOffset);\n+            archive.seek(ZipEightByteInteger.getLongValue(zip64EocdOffset));\n+            byte[] sig = new byte[WORD];\n+            archive.readFully(sig);\n+            if (sig[POS_0] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_0]\n+                || sig[POS_1] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_1]\n+                || sig[POS_2] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_2]\n+                || sig[POS_3] != ZipArchiveOutputStream.ZIP64_EOCD_SIG[POS_3]\n+                ) {\n+                throw new ZipException(\"archive's ZIP64 end of central \"\n+                                       + \"directory locator is corrupt.\");\n+            }\n+            archive.skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n+                              - WORD /* signature has already been read */);\n+            byte[] cfdOffset = new byte[DWORD];\n+            archive.readFully(cfdOffset);\n+            archive.seek(ZipEightByteInteger.getLongValue(cfdOffset));\n+        }\n+    }\n+\n+    /**\n      * Searches for the &quot;End of central dir record&quot;, parses\n      * it and positions the stream at the first central directory\n      * record.\n      */\n-    private void positionAtCentralDirectory()\n+    private void positionAtCentralDirectory32()\n         throws IOException {\n         boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                              ZipArchiveOutputStream.EOCD_SIG);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n import java.io.RandomAccessFile;\n import java.net.URI;\n import java.net.URL;\n+import java.util.Enumeration;\n import java.util.Random;\n \n import org.junit.Ignore;\n         read100KFilesImpl(get100KFileFileGeneratedByJava7Jar());\n     }\n \n+    @Test public void read100KFilesUsingZipFile() throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFile());\n+    }\n+\n+    @Test public void read100KFilesGeneratedBy7ZIPUsingZipFile() throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedBy7ZIP());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByWinCFUsingZipFile() throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByWinCF());\n+    }\n+\n+    @Test public void read100KFilesGeneratedByJava7JarUsingZipFile() throws Throwable {\n+        read100KFilesUsingZipFileImpl(get100KFileFileGeneratedByJava7Jar());\n+    }\n+\n     private static final ZipOutputTest write100KFiles =\n         new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n-                for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n-                    ZipArchiveEntry zae =\n-                        new ZipArchiveEntry(String.valueOf(i));\n-                    zae.setSize(0);\n-                    zos.putArchiveEntry(zae);\n-                    zos.closeArchiveEntry();\n-                }\n-                zos.close();\n+                write100KFilesToStream(zos);\n                 RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     final long end = a.length();\n \n     @Test public void write100KFilesStream() throws Throwable {\n         withTemporaryArchive(\"write100KFilesStream\", write100KFiles, false);\n+    }\n+\n+    @Test public void readSelfGenerated100KFilesUsingZipFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     write100KFilesToStream(zos);\n+                                     read100KFilesUsingZipFileImpl(f);\n+                                 }\n+                             },\n+                             true);\n     }\n \n     /*\n         }\n     }\n \n+    private static void read100KFilesUsingZipFileImpl(File f)\n+        throws IOException {\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(f);\n+            int files = 0;\n+            for (Enumeration e = zf.getEntries(); e.hasMoreElements(); ) {\n+                ZipArchiveEntry zae = (ZipArchiveEntry) e.nextElement();\n+                if (!zae.isDirectory()) {\n+                    files++;\n+                    assertEquals(0, zae.getSize());\n+                }\n+            }\n+            assertEquals(ONE_HUNDRED_THOUSAND, files);\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n     private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n         throws IOException {\n         final long end = a.length();\n         a.seek(ZipLong.getValue(cdOffset));\n         return end;\n     }\n+\n+    private static void write100KFilesToStream(ZipArchiveOutputStream zos)\n+        throws IOException {\n+        for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n+            ZipArchiveEntry zae = new ZipArchiveEntry(String.valueOf(i));\n+            zae.setSize(0);\n+            zos.putArchiveEntry(zae);\n+            zos.closeArchiveEntry();\n+        }\n+        zos.close();\n+    }\n }", "timestamp": 1312428834, "metainfo": ""}