{"sha": "ed3e215191e5d3b63e329d1b1c17f96f591ac56f", "log": "whitespace only  ", "commit": "\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n \n     private static final ZipOutputTest write100KFiles =\n         new ZipOutputTest() {\n-                public void test(File f, ZipArchiveOutputStream zos)\n-                    throws IOException {\n-                    for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n-                        ZipArchiveEntry zae =\n-                            new ZipArchiveEntry(String.valueOf(i));\n-                        zae.setSize(0);\n-                        zos.putArchiveEntry(zae);\n-                        zos.closeArchiveEntry();\n-                    }\n-                    zos.close();\n-                    RandomAccessFile a = new RandomAccessFile(f, \"r\");\n-                    try {\n-                        final long end = a.length();\n-\n-                        // validate \"end of central directory\" is at\n-                        // the end of the file and contains the magic\n-                        // value 0xFFFF as \"number of entries\".\n-                        a.seek(end\n-                               - 22 /* length of EOCD without file comment */);\n-                        byte[] eocd = new byte[12];\n-                        a.readFully(eocd);\n-                        assertArrayEquals(new byte[] {\n-                                // sig\n-                                (byte) 0x50, (byte) 0x4b, 5, 6,\n-                                // disk numbers\n-                                0, 0, 0, 0,\n-                                // entries\n-                                (byte) 0xff, (byte) 0xff,\n-                                (byte) 0xff, (byte) 0xff,\n-                            }, eocd); \n-\n-                        // validate \"Zip64 end of central directory\n-                        // locator\" is right in front of the EOCD and\n-                        // the location of the \"Zip64 end of central\n-                        // directory record\" seems correct\n-                        long expectedZ64EocdOffset = end - 22 /* eocd.length */\n-                            - 20 /* z64 eocd locator.length */\n-                            - 56 /* z64 eocd without extensible data sector */;\n-                        byte[] loc =\n-                            ZipEightByteInteger.getBytes(expectedZ64EocdOffset);\n-                        a.seek(end - 22 - 20);\n-                        byte[] z64EocdLoc = new byte[20];\n-                        a.readFully(z64EocdLoc);\n-                        assertArrayEquals(new byte[] {\n-                                // sig\n-                                (byte) 0x50, (byte) 0x4b, 6, 7,\n-                                // disk numbers\n-                                0, 0, 0, 0,\n-                                // location of Zip64 EOCD,\n-                                loc[0], loc[1], loc[2], loc[3],\n-                                loc[4], loc[5], loc[6], loc[7],\n-                                // total number of disks\n-                                1, 0, 0, 0,\n-                            }, z64EocdLoc);\n-\n-                        // validate \"Zip64 end of central directory\n-                        // record\" is where it is supposed to be, the\n-                        // known values are fine and read the location\n-                        // of the central directory from it\n-                        a.seek(expectedZ64EocdOffset);\n-                        byte[] z64EocdStart = new byte[40];\n-                        a.readFully(z64EocdStart);\n-                        assertArrayEquals(new byte[] {\n-                                // sig\n-                                (byte) 0x50, (byte) 0x4b, 6, 6,\n-                                // size of z64 EOCD\n-                                44, 0, 0, 0,\n-                                0, 0, 0, 0,\n-                                // version made by\n-                                45, 0,\n-                                // version needed to extract\n-                                45, 0,\n-                                // disk numbers\n-                                0, 0, 0, 0,\n-                                0, 0, 0, 0,\n-                                // number of entries 100k = 0x186A0\n-                                (byte) 0xA0, (byte) 0x86, 1, 0,\n-                                0, 0, 0, 0,\n-                                (byte) 0xA0, (byte) 0x86, 1, 0,\n-                                0, 0, 0, 0,\n-                            }, z64EocdStart);\n-                        a.seek(expectedZ64EocdOffset + 48 /* skip size */);\n-                        byte[] cdOffset = new byte[8];\n-                        a.readFully(cdOffset);\n-                        long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n-\n-                        // finally verify there really is a central\n-                        // directory entry where the Zip64 EOCD claims\n-                        a.seek(cdLoc);\n-                        byte[] sig = new byte[4];\n-                        a.readFully(sig);\n-                        assertArrayEquals(new byte[] {\n-                                (byte) 0x50, (byte) 0x4b, 1, 2,\n-                            }, sig);\n-                    } finally {\n-                        a.close();\n-                    }\n-                }\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n+                    ZipArchiveEntry zae =\n+                        new ZipArchiveEntry(String.valueOf(i));\n+                    zae.setSize(0);\n+                    zos.putArchiveEntry(zae);\n+                    zos.closeArchiveEntry();\n+                }\n+                zos.close();\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = a.length();\n+\n+                    // validate \"end of central directory\" is at\n+                    // the end of the file and contains the magic\n+                    // value 0xFFFF as \"number of entries\".\n+                    a.seek(end\n+                           - 22 /* length of EOCD without file comment */);\n+                    byte[] eocd = new byte[12];\n+                    a.readFully(eocd);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 5, 6,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // entries\n+                            (byte) 0xff, (byte) 0xff,\n+                            (byte) 0xff, (byte) 0xff,\n+                        }, eocd); \n+\n+                    // validate \"Zip64 end of central directory\n+                    // locator\" is right in front of the EOCD and\n+                    // the location of the \"Zip64 end of central\n+                    // directory record\" seems correct\n+                    long expectedZ64EocdOffset = end - 22 /* eocd.length */\n+                        - 20 /* z64 eocd locator.length */\n+                        - 56 /* z64 eocd without extensible data sector */;\n+                    byte[] loc =\n+                        ZipEightByteInteger.getBytes(expectedZ64EocdOffset);\n+                    a.seek(end - 22 - 20);\n+                    byte[] z64EocdLoc = new byte[20];\n+                    a.readFully(z64EocdLoc);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 7,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            // location of Zip64 EOCD,\n+                            loc[0], loc[1], loc[2], loc[3],\n+                            loc[4], loc[5], loc[6], loc[7],\n+                            // total number of disks\n+                            1, 0, 0, 0,\n+                        }, z64EocdLoc);\n+\n+                    // validate \"Zip64 end of central directory\n+                    // record\" is where it is supposed to be, the\n+                    // known values are fine and read the location\n+                    // of the central directory from it\n+                    a.seek(expectedZ64EocdOffset);\n+                    byte[] z64EocdStart = new byte[40];\n+                    a.readFully(z64EocdStart);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 6, 6,\n+                            // size of z64 EOCD\n+                            44, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // disk numbers\n+                            0, 0, 0, 0,\n+                            0, 0, 0, 0,\n+                            // number of entries 100k = 0x186A0\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                            (byte) 0xA0, (byte) 0x86, 1, 0,\n+                            0, 0, 0, 0,\n+                        }, z64EocdStart);\n+                    a.seek(expectedZ64EocdOffset + 48 /* skip size */);\n+                    byte[] cdOffset = new byte[8];\n+                    a.readFully(cdOffset);\n+                    long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n+\n+                    // finally verify there really is a central\n+                    // directory entry where the Zip64 EOCD claims\n+                    a.seek(cdLoc);\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n         };\n \n     @Test public void write100KFilesFile() throws Throwable {\n      */\n     private static final ZipOutputTest write3EntriesCreatingBigArchive =\n         new ZipOutputTest() {\n-                public void test(File f, ZipArchiveOutputStream zos)\n-                    throws IOException {\n-                    byte[] buf = new byte[1000 * 1000];\n-                    ZipArchiveEntry zae = null;\n-                    for (int i = 0; i < 2; i++) {\n-                        zae = new ZipArchiveEntry(String.valueOf(i));\n-                        zae.setSize(FIVE_BILLION / 2);\n-                        zae.setMethod(ZipArchiveEntry.STORED);\n-                        zae.setCrc(0x8a408f16L);\n-                        zos.putArchiveEntry(zae);\n-                        for (int j = 0; j < FIVE_BILLION / 2 / 1000 / 1000;\n-                             j++) {\n-                            zos.write(buf);\n-                        }\n-                        zos.closeArchiveEntry();\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[1000 * 1000];\n+                ZipArchiveEntry zae = null;\n+                for (int i = 0; i < 2; i++) {\n+                    zae = new ZipArchiveEntry(String.valueOf(i));\n+                    zae.setSize(FIVE_BILLION / 2);\n+                    zae.setMethod(ZipArchiveEntry.STORED);\n+                    zae.setCrc(0x8a408f16L);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0; j < FIVE_BILLION / 2 / 1000 / 1000;\n+                         j++) {\n+                        zos.write(buf);\n                     }\n-                    zae = new ZipArchiveEntry(String.valueOf(2));\n-                    zae.setSize(0);\n-                    zae.setMethod(ZipArchiveEntry.STORED);\n-                    zae.setCrc(0);\n-                    zos.putArchiveEntry(zae);\n-                    zos.write(new byte[0]);\n                     zos.closeArchiveEntry();\n-                    zos.close();\n-\n-                    RandomAccessFile a = new RandomAccessFile(f, \"r\");\n-                    try {\n-                        final long end = a.length();\n-                        long cdOffsetLoc = end - 22 /* eocd.length */\n-                            - 20 /* z64 eocd locator.length */\n-                            - 56 /* z64 eocd without extensible data sector */\n-                            + 48 /* position in z64 eocd */;\n-                        // seek to central directory\n-                        a.seek(cdOffsetLoc);\n-                        byte[] cdOffset = new byte[8];\n-                        a.readFully(cdOffset);\n-                        a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n-                        // skip first two entries\n-                        a.skipBytes(2 * 47 /* CD entry of file with\n-                                              file name length 1 and no\n-                                              extra data */);\n-\n-                        // grab third entry, verify offset is\n-                        // 0xFFFFFFFF and it has a ZIP64 extended\n-                        // information extra field\n-                        byte[] header = new byte[8];\n-                        a.readFully(header);\n-                        assertArrayEquals(new byte[] {\n-                                // sig\n-                                (byte) 0x50, (byte) 0x4b, 1, 2,\n-                                // version made by\n-                                45, 0,\n-                                // version needed to extract\n-                                45, 0,\n-                            }, header);\n-                        // ignore GPB, method, timestamp, CRC, compressed size\n-                        a.skipBytes(16);\n-                        byte[] rest = new byte[23];\n-                        a.readFully(rest);\n-                        assertArrayEquals(new byte[] {\n-                                // Original Size\n-                                0, 0, 0, 0,\n-                                // file name length\n-                                1, 0,\n-                                // extra field length\n-                                12, 0,\n-                                // comment length\n-                                0, 0,\n-                                // disk number\n-                                0, 0,\n-                                // attributes\n-                                0, 0,\n-                                0, 0, 0, 0,\n-                                // offset\n-                                (byte) 0xFF, (byte) 0xFF,\n-                                (byte) 0xFF, (byte) 0xFF,\n-                                // file name\n-                                (byte) '2'\n-                            }, rest);\n-                        byte[] extra = new byte[4];\n-                        a.readFully(extra);\n-                        assertArrayEquals(new byte[] {\n-                                // Header-ID\n-                                1, 0,\n-                                // size\n-                                8, 0\n-                            }, extra);\n-\n-                        // read offset of LFH\n-                        byte[] offset = new byte[8];\n-                        a.readFully(offset);\n-                        // verify there is a LFH where the CD claims it\n-                        a.seek(ZipEightByteInteger.getLongValue(offset));\n-                        byte[] sig = new byte[4];\n-                        a.readFully(sig);\n-                        assertArrayEquals(new byte[] {\n-                                (byte) 0x50, (byte) 0x4b, 3, 4,\n-                            }, sig);\n-                    } finally {\n-                        a.close();\n-                    }\n-                }\n+                }\n+                zae = new ZipArchiveEntry(String.valueOf(2));\n+                zae.setSize(0);\n+                zae.setMethod(ZipArchiveEntry.STORED);\n+                zae.setCrc(0);\n+                zos.putArchiveEntry(zae);\n+                zos.write(new byte[0]);\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = a.length();\n+                    long cdOffsetLoc = end - 22 /* eocd.length */\n+                        - 20 /* z64 eocd locator.length */\n+                        - 56 /* z64 eocd without extensible data sector */\n+                        + 48 /* position in z64 eocd */;\n+                    // seek to central directory\n+                    a.seek(cdOffsetLoc);\n+                    byte[] cdOffset = new byte[8];\n+                    a.readFully(cdOffset);\n+                    a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n+                    // skip first two entries\n+                    a.skipBytes(2 * 47 /* CD entry of file with\n+                                          file name length 1 and no\n+                                          extra data */);\n+\n+                    // grab third entry, verify offset is\n+                    // 0xFFFFFFFF and it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[8];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                        }, header);\n+                    // ignore GPB, method, timestamp, CRC, compressed size\n+                    a.skipBytes(16);\n+                    byte[] rest = new byte[23];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // Original Size\n+                            0, 0, 0, 0,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            12, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            (byte) 0xFF, (byte) 0xFF,\n+                            // file name\n+                            (byte) '2'\n+                        }, rest);\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size\n+                            8, 0\n+                        }, extra);\n+\n+                    // read offset of LFH\n+                    byte[] offset = new byte[8];\n+                    a.readFully(offset);\n+                    // verify there is a LFH where the CD claims it\n+                    a.seek(ZipEightByteInteger.getLongValue(offset));\n+                    byte[] sig = new byte[4];\n+                    a.readFully(sig);\n+                    assertArrayEquals(new byte[] {\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                        }, sig);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n \n         };\n ", "timestamp": 1311962395, "metainfo": ""}