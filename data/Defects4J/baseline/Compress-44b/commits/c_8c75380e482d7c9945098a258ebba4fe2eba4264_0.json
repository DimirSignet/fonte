{"sha": "8c75380e482d7c9945098a258ebba4fe2eba4264", "log": "COMPRESS-271 add read-support for LZ4 with block dependency", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n  * @NotThreadSafe\n  */\n public class FramedLZ4CompressorInputStream extends CompressorInputStream {\n-    /*\n-     * TODO before releasing 1.14:\n-     *\n-     * + block dependence\n-     */\n \n     // used by FramedLZ4CompressorOutputStream as well\n     static final byte[] LZ4_SIGNATURE = new byte[] { //NOSONAR\n     private final boolean decompressConcatenated;\n \n     private boolean expectBlockChecksum;\n+    private boolean expectBlockDependency;\n     private boolean expectContentSize;\n     private boolean expectContentChecksum;\n \n \n     // used for frame header checksum and content checksum, if present\n     private final XXHash32 contentHash = new XXHash32();\n+\n+    // only created if the frame doesn't set the block independence flag\n+    private byte[] blockDependencyBuffer;\n \n     /**\n      * Creates a new input stream that decompresses streams compressed\n                 r = readOnce(b, off, len);\n             }\n         }\n+        if (expectBlockDependency) {\n+            appendToBlockDependencyBuffer(b, off, r);\n+        }\n         if (expectContentChecksum && r != -1) {\n             contentHash.update(b, off, r);\n         }\n         if ((flags & VERSION_MASK) != SUPPORTED_VERSION) {\n             throw new IOException(\"Unsupported version \" + (flags >> 6));\n         }\n-        if ((flags & BLOCK_INDEPENDENCE_MASK) == 0) {\n-            throw new IOException(\"Block dependence is not supported\");\n+        expectBlockDependency = (flags & BLOCK_INDEPENDENCE_MASK) == 0;\n+        if (expectBlockDependency) {\n+            if (blockDependencyBuffer == null) {\n+                blockDependencyBuffer = new byte[BlockLZ4CompressorInputStream.WINDOW_SIZE];\n+            }\n+        } else {\n+            blockDependencyBuffer = null;\n         }\n         expectBlockChecksum = (flags & BLOCK_CHECKSUM_MASK) != 0;\n         expectContentSize = (flags & CONTENT_SIZE_MASK) != 0;\n             currentBlock = capped;\n         } else {\n             inUncompressed = false;\n-            currentBlock = new BlockLZ4CompressorInputStream(capped);\n+            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n+            if (expectBlockDependency) {\n+                s.prefill(blockDependencyBuffer);\n+            }\n+            currentBlock = s;\n         }\n     }\n \n         return read;\n     }\n \n+    private void appendToBlockDependencyBuffer(final byte[] b, final int off, int len) {\n+        len = Math.min(len, blockDependencyBuffer.length);\n+        if (len > 0) {\n+            int keep = blockDependencyBuffer.length - len;\n+            if (keep > 0) {\n+                // move last keep bytes towards the start of the buffer\n+                System.arraycopy(blockDependencyBuffer, len, blockDependencyBuffer, 0, keep);\n+            }\n+            // append new data\n+            System.arraycopy(b, off, blockDependencyBuffer, keep, len);\n+        }\n+    }\n+\n     /**\n      * Checks if the signature matches what is expected for a .lz4 file.\n      *\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n      */\n     public int getSize() {\n         return size;\n+    }\n+\n+    /**\n+     * Adds some initial data to fill the window with.\n+     *\n+     * <p>This is used if the stream has been cut into blocks and\n+     * back-references of one block may refer to data of the previous\n+     * block(s). One such example is the LZ4 frame format using block\n+     * dependency.</p>\n+     *\n+     * @param data the data to fill the window with.\n+     * @throws IllegalStateException if the stream has already started to read data\n+     */\n+    public void prefill(byte[] data) {\n+        if (writeIndex != 0) {\n+            throw new IllegalStateException(\"the stream has already been read from, can't prefill anymore\");\n+        }\n+        int len = Math.min(windowSize, data.length);\n+        System.arraycopy(data, data.length - len, buf, 0, len);\n+        writeIndex += len;\n+        readIndex += len;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n             }, false);\n     }\n \n+    @Test\n+    public void readBlaDumpLz4() throws IOException {\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.dump.lz4\")));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.dump\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n     @Test(expected = IOException.class)\n     public void rejectsNonLZ4Stream() throws IOException {\n         try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.tar\")))) {", "timestamp": 1486318111, "metainfo": ""}