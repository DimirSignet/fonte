{"sha": "de4c4b30baa2ce89360d675f8fa2a1b358b0e10a", "log": "small refactoring of long filename support in AR input stream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n \n         entryOffset = offset;\n \n-//        GNU ar stores multiple extended filenames in the data section of a file with the name \"//\", this record is referred to by future headers. A header references an extended filename by storing a \"/\" followed by a decimal offset to the start of the filename in the extended filename data section. The format of this \"//\" file itself is simply a list of the long filenames, each separated by one or more LF characters. Note that the decimal offsets are number of characters, not line or string number within the \"//\" file.\n-//\n //        GNU ar uses a '/' to mark the end of the filename; this allows for the use of spaces without the use of an extended filename.\n \n         // entry name is stored as ASCII string\n         String temp = ArchiveUtils.toAsciiString(name).trim();\n         long len = asLong(length);\n \n-        if (temp.equals(\"//\")){ // GNU extended filenames entry\n-            int bufflen = asInt(length); // Assume length will fit in an int\n-            namebuffer = new byte[bufflen];\n-            int read = read(namebuffer, 0, bufflen);\n-            if (read != bufflen){\n-                throw new IOException(\"Failed to read complete // record: expected=\"+bufflen+\" read=\"+read);\n-            }\n-            currentEntry = new ArArchiveEntry(temp, bufflen);\n+        if (isGNUStringTable(temp)) { // GNU extended filenames entry\n+            currentEntry = readGNUStringTable(length);\n             return getNextArEntry();\n         } else if (temp.endsWith(\"/\")) { // GNU terminator\n             temp = temp.substring(0, temp.length() - 1);\n-        } else if (temp.matches(\"^/\\\\d+\")) {// GNU long filename ref.\n+        } else if (isGNULongName(temp)) {\n             int offset = Integer.parseInt(temp.substring(1));// get the offset\n             temp = getExtendedName(offset); // convert to the long name\n         } else if (isBSDLongName(temp)) {\n     private static final String BSD_LONGNAME_PREFIX = \"#1/\";\n     private static final int BSD_LONGNAME_PREFIX_LEN =\n         BSD_LONGNAME_PREFIX.length();\n+    private static final String BSD_LONGNAME_PATTERN =\n+        \"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n \n     /**\n      * Does the name look like it is a long name (or a name containing\n      * @since Apache Commons Compress 1.3\n      */\n     private static boolean isBSDLongName(String name) {\n-        return name.startsWith(BSD_LONGNAME_PREFIX)\n-            && name.length() > BSD_LONGNAME_PREFIX_LEN;\n+        return name != null && name.matches(BSD_LONGNAME_PATTERN);\n     }\n \n     /**\n      * first bytes to be read are the real file name.\n      *\n      * @see #isBSDLongName\n+     *\n+     * @since Apache Commons Compress 1.3\n      */\n     private String getBSDLongName(String bsdLongName) throws IOException {\n         int nameLen =\n         }\n         return ArchiveUtils.toAsciiString(name);\n     }\n+\n+    private static final String GNU_STRING_TABLE_NAME = \"//\";\n+\n+    /**\n+     * Is this the name of the \"Archive String Table\" as used by\n+     * SVR4/GNU to store long file names?\n+     *\n+     * <p>GNU ar stores multiple extended filenames in the data section\n+     * of a file with the name \"//\", this record is referred to by\n+     * future headers.</p>\n+     *\n+     * <p>A header references an extended filename by storing a \"/\"\n+     * followed by a decimal offset to the start of the filename in\n+     * the extended filename data section.</p>\n+     * \n+     * <p>The format of the \"//\" file itself is simply a list of the\n+     * long filenames, each separated by one or more LF\n+     * characters. Note that the decimal offsets are number of\n+     * characters, not line or string number within the \"//\" file.</p>\n+     */\n+    private static boolean isGNUStringTable(String name) {\n+        return GNU_STRING_TABLE_NAME.equals(name);\n+    }\n+\n+    /**\n+     * Reads the GNU archive String Table.\n+     *\n+     * @see #isGNUStringTable\n+     */\n+    private ArArchiveEntry readGNUStringTable(byte[] length) throws IOException {\n+        int bufflen = asInt(length); // Assume length will fit in an int\n+        namebuffer = new byte[bufflen];\n+        int read = read(namebuffer, 0, bufflen);\n+        if (read != bufflen){\n+            throw new IOException(\"Failed to read complete // record: expected=\"\n+                                  + bufflen + \" read=\" + read);\n+        }\n+        return new ArArchiveEntry(GNU_STRING_TABLE_NAME, bufflen);\n+    }\n+\n+    private static final String GNU_LONGNAME_PATTERN = \"^/\\\\d+\";\n+\n+    /**\n+     * Does the name look like it is a long name (or a name containing\n+     * spaces) as encoded by SVR4/GNU ar?\n+     *\n+     * @see #isGNUStringTable\n+     */\n+    private boolean isGNULongName(String name) {\n+        return name != null && name.matches(GNU_LONGNAME_PATTERN);\n+    }\n }", "timestamp": 1312796948, "metainfo": ""}