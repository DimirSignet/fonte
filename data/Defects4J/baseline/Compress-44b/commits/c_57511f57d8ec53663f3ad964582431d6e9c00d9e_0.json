{"sha": "57511f57d8ec53663f3ad964582431d6e9c00d9e", "log": "COMPRESS-327 update documentation", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n                                        + \" instead of \"\n                                        + bytesWritten);\n             }\n-        } else { /* method is STORED and we used RandomAccessFile */\n+        } else { /* method is STORED and we used SeekableByteChannel */\n             entry.entry.setSize(bytesWritten);\n             entry.entry.setCompressedSize(bytesWritten);\n             entry.entry.setCrc(crc);\n             final Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n \n             // just a placeholder, real data will be in data\n-            // descriptor or inserted later via RandomAccessFile\n+            // descriptor or inserted later via SeekableByteChannel\n             ZipEightByteInteger size = ZipEightByteInteger.ZERO;\n             ZipEightByteInteger compressedSize = ZipEightByteInteger.ZERO;\n             if (phased){\n      */\n     private void validateSizeInformation(final Zip64Mode effectiveMode)\n         throws ZipException {\n-        // Size/CRC not required if RandomAccessFile is used\n+        // Size/CRC not required if SeekableByteChannel is used\n         if (entry.entry.getMethod() == STORED && channel == null) {\n             if (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                 throw new ZipException(\"uncompressed size is required for\"", "timestamp": 1476303065, "metainfo": ""}