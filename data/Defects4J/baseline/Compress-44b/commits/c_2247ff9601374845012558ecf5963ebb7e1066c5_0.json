{"sha": "2247ff9601374845012558ecf5963ebb7e1066c5", "log": "merge hard reset -- move from other change list...ugh", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      */\n     private volatile boolean decompressConcatenated = false;\n \n+    private final int memoryLimitInKb;\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n         this.decompressUntilEOF = null;\n-    }\n+        this.memoryLimitInKb = -1;\n+    }\n+\n+    /**\n+     * Create an instance with the provided decompress Concatenated option.\n+     *\n+     * @param decompressUntilEOF\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream. This setting applies to the\n+     *            gzip, bzip2 and xz formats only.\n+     *\n+     * @param memoryLimitInKb\n+     *            Some streams require allocation of potentially significant\n+     *            byte arrays/tables, and they can offer checks to prevent OOMs\n+     *            on corrupt files.  Set the maximum allowed memory allocation in KBs.\n+     *\n+     * @since 1.14\n+     */\n+    public CompressorStreamFactory(final boolean decompressUntilEOF, final int memoryLimitInKb) {\n+        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n+        this.decompressConcatenated = decompressUntilEOF;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n-        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the\n-        // current value\n-        this.decompressConcatenated = decompressUntilEOF;\n+        this(decompressUntilEOF, -1);\n     }\n \n     /**\n                 if (!XZUtils.isXZCompressionAvailable()) {\n                     throw new CompressorException(\"XZ compression is not available.\");\n                 }\n-                return new XZCompressorInputStream(in, actualDecompressConcatenated);\n+                return new XZCompressorInputStream(in, actualDecompressConcatenated, memoryLimitInKb);\n             }\n \n             if (LZMA.equalsIgnoreCase(name)) {\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                return new LZMACompressorInputStream(in);\n+                return new LZMACompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                return new ZCompressorInputStream(in);\n+                return new ZCompressorInputStream(in, memoryLimitInKb);\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.MemoryLimit;\n import org.apache.commons.compress.MemoryLimitException;\n import org.apache.commons.compress.MockEvilInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;\n-import org.junit.AfterClass;\n-import org.junit.Before;\n import org.junit.Test;\n \n @SuppressWarnings(\"deprecation\") // deliberately tests setDecompressConcatenated\n         }\n     }\n \n-    @Before\n-    public void setUp() {\n-        //make sure to reset this before each test\n-        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n-    }\n-\n-    @AfterClass\n-    public static void tearDown() {\n-        //make sure this is really, truly reset after all the tests\n-        MemoryLimit.setMemoryLimitInKb(MemoryLimit.NO_LIMIT);\n-    }\n-\n     private final TestData[] tests = {\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factoryTrue, true),\n         new TestData(\"multiple.bz2\", new char[]{'a','b'}, factorySetTrue, true),\n     }\n \n     private InputStream getStreamFor(final String fileName, final int memoryLimitInKb) throws Exception {\n-        MemoryLimit.setMemoryLimitInKb(memoryLimitInKb);\n-        CompressorStreamFactory fac = new CompressorStreamFactory(true);\n+        CompressorStreamFactory fac = new CompressorStreamFactory(true,\n+                memoryLimitInKb);\n         InputStream is = new BufferedInputStream(\n                 new FileInputStream(getFile(fileName)));\n         try {", "timestamp": 1493125288, "metainfo": ""}