{"sha": "7e89c9cc80bc3fd2aab64f25dd816c6d14790988", "log": "COMPRESS-388: Fix concurrent reads performance", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n         }\n         final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n         final long start = offsetEntry.dataOffset;\n-        return new BoundedInputStream(start, ze.getCompressedSize());\n+        return createBoundedInputStream(start, ze.getCompressedSize());\n     }\n \n \n         final long start = offsetEntry.dataOffset;\n         // doesn't get closed if the method is not supported, but doesn't hold any resources either\n         final BoundedInputStream bis =\n-            new BoundedInputStream(start, ze.getCompressedSize()); //NOSONAR\n+            createBoundedInputStream(start, ze.getCompressedSize()); //NOSONAR\n         switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n             case STORED:\n                 return bis;\n     }\n \n     /**\n+     * Creates new BoundedInputStream, according to implementation of\n+     * underlying archive channel.\n+     */\n+    private BoundedInputStream createBoundedInputStream(long start, long remaining) {\n+        return archive instanceof FileChannel ?\n+            new BoundedFileChannelInputStream(start, remaining) :\n+            new BoundedInputStream(start, remaining);\n+    }\n+\n+    /**\n      * InputStream that delegates requests to the underlying\n      * SeekableByteChannel, making sure that only bytes from a certain\n      * range can be read.\n      */\n     private class BoundedInputStream extends InputStream {\n-        private static final int MAX_BUF_LEN = 8192;\n-        private final ByteBuffer buffer;\n-        private long remaining;\n-        private long loc;\n-        private boolean addDummyByte = false;\n+        protected static final int MAX_BUF_LEN = 8192;\n+        protected final ByteBuffer buffer;\n+        protected long remaining;\n+        protected long loc;\n+        protected boolean addDummyByte = false;\n \n         BoundedInputStream(final long start, final long remaining) {\n             this.remaining = remaining;\n                 }\n                 return -1;\n             }\n-            synchronized (archive) {\n-                archive.position(loc++);\n-                int read = read(1);\n-                if (read < 0) {\n-                    return read;\n-                }\n-                return buffer.get() & 0xff;\n-            }\n+            int read = read(loc++, 1);\n+            if (read < 0) {\n+                return read;\n+            }\n+            return buffer.get() & 0xff;\n         }\n \n         @Override\n             }\n             ByteBuffer buf;\n             int ret = -1;\n-            synchronized (archive) {\n-                archive.position(loc);\n-                if (len <= buffer.capacity()) {\n-                    buf = buffer;\n-                    ret = read(len);\n-                } else {\n-                    buf = ByteBuffer.allocate(len);\n-                    ret = archive.read(buf);\n-                    buf.flip();\n-                }\n+            if (len <= buffer.capacity()) {\n+                buf = buffer;\n+                ret = read(loc, len);\n+            } else {\n+                buf = ByteBuffer.allocate(len);\n+                ret = read(loc, buf);\n             }\n             if (ret > 0) {\n                 buf.get(b, off, ret);\n             return ret;\n         }\n \n-        private int read(int len) throws IOException {\n+        protected int read(long pos, ByteBuffer buf) throws IOException {\n+            int read;\n+            synchronized (archive) {\n+                archive.position(pos);\n+                read = archive.read(buf);\n+            }\n+            buf.flip();\n+            return read;\n+        }\n+\n+        protected int read(long pos, int len) throws IOException {\n+            int read;\n             buffer.rewind().limit(len);\n-            int read = archive.read(buffer);\n+            synchronized (archive) {\n+                archive.position(pos);\n+                read = archive.read(buffer);\n+            }\n             buffer.flip();\n             return read;\n         }\n          */\n         void addDummy() {\n             addDummyByte = true;\n+        }\n+    }\n+\n+    /**\n+     * Lock-free implementation of BoundedInputStream. The\n+     * implementation uses positioned reads on the underlying archive\n+     * file channel and therefore performs significantly faster in\n+     * concurrent environment.\n+     */\n+    private class BoundedFileChannelInputStream extends BoundedInputStream {\n+        private final FileChannel archive;\n+\n+        BoundedFileChannelInputStream(final long start, final long remaining) {\n+            super(start, remaining);\n+            archive = (FileChannel)ZipFile.this.archive;\n+        }\n+\n+        @Override\n+        protected int read(long pos, ByteBuffer buf) throws IOException {\n+            int read = archive.read(buf, pos);\n+            buf.flip();\n+            return read;\n+        }\n+\n+        @Override\n+        protected int read(long position, int len) throws IOException {\n+            buffer.rewind().limit(len);\n+            int read = archive.read(buffer, position);\n+            buffer.flip();\n+            return read;\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.zip.ZipEntry;\n \n import org.apache.commons.compress.utils.IOUtils;\n         assertArrayEquals(expected, IOUtils.toByteArray(zf.getInputStream(ze)));\n     }\n \n+    @Test\n+    public void testConcurrentReadSeekable() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        byte[] data = null;\n+        try (FileInputStream fis = new FileInputStream(getFile(\"mixed.zip\"))) {\n+            data = IOUtils.toByteArray(fis);\n+        }\n+        zf = new ZipFile(new SeekableInMemoryByteChannel(data), ZipEncodingHelper.UTF8);\n+\n+        final Map<String, byte[]> content = new HashMap<String, byte[]>();\n+        for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+            content.put(entry.getName(), IOUtils.toByteArray(zf.getInputStream(entry)));\n+        }\n+\n+        final AtomicInteger passedCount = new AtomicInteger();\n+        Runnable run = new Runnable() {\n+            @Override\n+            public void run() {\n+                for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+                    assertAllReadMethods(content.get(entry.getName()), zf, entry);\n+                }\n+                passedCount.incrementAndGet();\n+            }\n+        };\n+        Thread t0 = new Thread(run);\n+        Thread t1 = new Thread(run);\n+        t0.start();\n+        t1.start();\n+        t0.join();\n+        t1.join();\n+        assertEquals(2, passedCount.get());\n+    }\n+\n+    @Test\n+    public void testConcurrentReadFile() throws Exception {\n+        // mixed.zip contains both inflated and stored files\n+        final File archive = getFile(\"mixed.zip\");\n+        zf = new ZipFile(archive);\n+\n+        final Map<String, byte[]> content = new HashMap<String, byte[]>();\n+        for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+            content.put(entry.getName(), IOUtils.toByteArray(zf.getInputStream(entry)));\n+        }\n+\n+        final AtomicInteger passedCount = new AtomicInteger();\n+        Runnable run = new Runnable() {\n+            @Override\n+            public void run() {\n+                for (ZipArchiveEntry entry: Collections.list(zf.getEntries())) {\n+                    assertAllReadMethods(content.get(entry.getName()), zf, entry);\n+                }\n+                passedCount.incrementAndGet();\n+            }\n+        };\n+        Thread t0 = new Thread(run);\n+        Thread t1 = new Thread(run);\n+        t0.start();\n+        t1.start();\n+        t0.join();\n+        t1.join();\n+        assertEquals(2, passedCount.get());\n+    }\n+\n+    private void assertAllReadMethods(byte[] expected, ZipFile zipFile, ZipArchiveEntry entry) {\n+        // simple IOUtil read\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full = IOUtils.toByteArray(stream);\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        // big buffer at the beginning and then chunks by IOUtils read\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full;\n+            byte[] bytes = new byte[0x40000];\n+            int read = stream.read(bytes);\n+            if (read < 0) {\n+                full = new byte[0];\n+            }\n+            else {\n+                full = readStreamRest(bytes, read, stream);\n+            }\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        // small chunk / single byte and big buffer then\n+        try (InputStream stream = zf.getInputStream(entry)) {\n+            byte[] full;\n+            int single = stream.read();\n+            if (single < 0) {\n+                full = new byte[0];\n+            }\n+            else {\n+                byte[] big = new byte[0x40000];\n+                big[0] = (byte)single;\n+                int read = stream.read(big, 1, big.length-1);\n+                if (read < 0) {\n+                    full = new byte[]{ (byte)single };\n+                }\n+                else {\n+                    full = readStreamRest(big, read+1, stream);\n+                }\n+            }\n+            assertArrayEquals(expected, full);\n+        }\n+        catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Utility to append the rest of the stream to already read data.\n+     */\n+    private byte[] readStreamRest(byte[] beginning, int length, InputStream stream) throws IOException {\n+        byte[] rest = IOUtils.toByteArray(stream);\n+        byte[] full = new byte[length+rest.length];\n+        System.arraycopy(beginning, 0, full, 0, length);\n+        System.arraycopy(rest, 0, full, length, rest.length);\n+        return full;\n+    }\n+\n     /*\n      * ordertest.zip has been handcrafted.\n      *", "timestamp": 1493143338, "metainfo": ""}