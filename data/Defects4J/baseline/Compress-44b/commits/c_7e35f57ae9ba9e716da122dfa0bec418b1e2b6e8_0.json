{"sha": "7e35f57ae9ba9e716da122dfa0bec418b1e2b6e8", "log": "COMPRESS-327 write zip archives to arbitrary SeekableByteChannels", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n import java.util.zip.CRC32;\n import java.util.zip.Deflater;\n import java.util.zip.ZipEntry;\n      */\n     static StreamCompressor create(final DataOutput os, final Deflater deflater) {\n         return new DataOutputCompressor(deflater, os);\n+    }\n+\n+    /**\n+     * Create a stream compressor with the given compression level.\n+     *\n+     * @param os       The SeekableByteChannel to receive output\n+     * @param deflater The deflater to use for the compressor\n+     * @return A stream compressor\n+     * @since 1.13\n+     */\n+    static StreamCompressor create(final SeekableByteChannel os, final Deflater deflater) {\n+        return new SeekableByteChannelCompressor(deflater, os);\n     }\n \n     /**\n             raf.write(data, offset, length);\n         }\n     }\n+\n+    private static final class SeekableByteChannelCompressor extends StreamCompressor {\n+        private final SeekableByteChannel channel;\n+\n+        public SeekableByteChannelCompressor(final Deflater deflater,\n+                                             final SeekableByteChannel channel) {\n+            super(deflater);\n+            this.channel = channel;\n+        }\n+\n+        @Override\n+        protected final void writeOut(final byte[] data, final int offset, final int length)\n+                throws IOException {\n+            channel.write(ByteBuffer.wrap(data, offset, length));\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n import java.util.Calendar;\n+import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n  * attributes and extra fields with different layouts for local file\n  * data and central directory entries.\n  *\n- * <p>This class will try to use {@link java.io.RandomAccessFile\n- * RandomAccessFile} when you know that the output is going to go to a\n- * file.</p>\n+ * <p>This class will try to use {@link\n+ * java.nio.channels.SeekableByteChannel} when you know that the\n+ * output is going to go to a file.</p>\n  *\n- * <p>If RandomAccessFile cannot be used, this implementation will use\n+ * <p>If SeekableByteChannel cannot be used, this implementation will use\n  * a Data Descriptor to store size and CRC information for {@link\n  * #DEFLATED DEFLATED} entries, this means, you don't need to\n  * calculate them yourself.  Unfortunately this is not possible for\n  * extensions and thus individual entries and archives larger than 4\n  * GB or with more than 65536 entries in most cases but explicit\n  * control is provided via {@link #setUseZip64}.  If the stream can not\n- * user RandomAccessFile and you try to write a ZipArchiveEntry of\n+ * use SeekableByteChannel and you try to write a ZipArchiveEntry of\n  * unknown size then Zip64 extensions will be disabled by default.</p>\n  *\n  * @NotThreadSafe\n     /**\n      * Optional random access output.\n      */\n-    private final RandomAccessFile raf;\n+    private final SeekableByteChannel channel;\n \n     private final OutputStream out;\n \n      */\n     public ZipArchiveOutputStream(final OutputStream out) {\n         this.out = out;\n-        this.raf = null;\n+        this.channel = null;\n         def = new Deflater(level, true);\n         streamCompressor = StreamCompressor.create(out, def);\n     }\n      * @throws IOException on error\n      */\n     public ZipArchiveOutputStream(final File file) throws IOException {\n+        def = new Deflater(level, true);\n         OutputStream o = null;\n-        RandomAccessFile _raf = null;\n+        SeekableByteChannel _channel = null;\n+        StreamCompressor _streamCompressor = null;\n         try {\n-            _raf = new RandomAccessFile(file, \"rw\");\n-            _raf.setLength(0);\n+            _channel = Files.newByteChannel(file.toPath(),\n+                EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE,\n+                           StandardOpenOption.READ,\n+                           StandardOpenOption.TRUNCATE_EXISTING));\n+            _streamCompressor = StreamCompressor.create(_channel, def);\n         } catch (final IOException e) {\n-            IOUtils.closeQuietly(_raf);\n-            _raf = null;\n+            IOUtils.closeQuietly(_channel);\n+            _channel = null;\n             o = new FileOutputStream(file);\n-        }\n+            _streamCompressor = StreamCompressor.create(o, def);\n+        }\n+        out = o;\n+        channel = _channel;\n+        streamCompressor = _streamCompressor;\n+    }\n+\n+    /**\n+     * Creates a new ZIP OutputStream writing to a SeekableByteChannel.\n+     * @param channel the channel to zip to\n+     * @throws IOException on error\n+     * @since 1.13\n+     */\n+    public ZipArchiveOutputStream(SeekableByteChannel channel) throws IOException {\n+        this.channel = channel;\n         def = new Deflater(level, true);\n-        streamCompressor = StreamCompressor.create(_raf, def);\n-        out = o;\n-        raf = _raf;\n+        streamCompressor = StreamCompressor.create(channel, def);\n+        out = null;\n     }\n \n     /**\n      * @return true if seekable\n      */\n     public boolean isSeekable() {\n-        return raf != null;\n+        return channel != null;\n     }\n \n     /**\n     }\n \n     private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n-        if (!phased && raf != null) {\n+        if (!phased && channel != null) {\n             rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n \n             entry.entry.setCompressedSize(bytesWritten);\n             entry.entry.setCrc(crc);\n \n-        } else if (raf == null) {\n+        } else if (channel == null) {\n             if (entry.entry.getCrc() != crc) {\n                 throw new ZipException(\"bad CRC checksum for entry \"\n                                        + entry.entry.getName() + \": \"\n      */\n     private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64)\n         throws IOException {\n-        final long save = raf.getFilePointer();\n-\n-        raf.seek(entry.localDataStart);\n+        final long save = channel.position();\n+\n+        channel.position(entry.localDataStart);\n         writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n         if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n             writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n             final ByteBuffer name = getName(entry.entry);\n             final int nameLen = name.limit() - name.position();\n             // seek to ZIP64 extra, skip header and size information\n-            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n-                     + nameLen + 2 * SHORT);\n+            channel.position(entry.localDataStart + 3 * WORD + 2 * SHORT\n+                             + nameLen + 2 * SHORT);\n             // inside the ZIP64 extra uncompressed size comes\n             // first, unlike the LFH, CD or data descriptor\n             writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n             if (!actuallyNeedsZip64) {\n                 // do some cleanup:\n                 // * rewrite version needed to extract\n-                raf.seek(entry.localDataStart  - 5 * SHORT);\n+                channel.position(entry.localDataStart  - 5 * SHORT);\n                 writeOut(ZipShort.getBytes(INITIAL_VERSION));\n \n                 // * remove ZIP64 extra so it doesn't get written\n                 }\n             }\n         }\n-        raf.seek(save);\n+        channel.position(save);\n     }\n \n     /**\n     private void validateSizeInformation(final Zip64Mode effectiveMode)\n         throws ZipException {\n         // Size/CRC not required if RandomAccessFile is used\n-        if (entry.entry.getMethod() == STORED && raf == null) {\n+        if (entry.entry.getMethod() == STORED && channel == null) {\n             if (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                 throw new ZipException(\"uncompressed size is required for\"\n                                        + \" STORED method when not writing to a\"\n             || entry.getSize() >= ZIP64_MAGIC\n             || entry.getCompressedSize() >= ZIP64_MAGIC\n             || (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n-                && raf != null && mode != Zip64Mode.Never);\n+                && channel != null && mode != Zip64Mode.Never);\n     }\n \n     /**\n         // CRC\n         if (phased){\n             putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-        } else if (zipMethod == DEFLATED || raf != null) {\n+        } else if (zipMethod == DEFLATED || channel != null) {\n             System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n         } else {\n             putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n         } else if (phased) {\n             putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n             putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-        } else if (zipMethod == DEFLATED || raf != null) {\n+        } else if (zipMethod == DEFLATED || channel != null) {\n             System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n             System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n         } else { // Stored\n      * @throws IOException on error\n      */\n     protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-        if (ze.getMethod() != DEFLATED || raf != null) {\n+        if (ze.getMethod() != DEFLATED || channel != null) {\n             return;\n         }\n         writeCounted(DD_SIG);\n     }\n \n     private boolean isDeflatedToOutputStream(final int zipMethod) {\n-        return zipMethod == DEFLATED && raf == null;\n+        return zipMethod == DEFLATED && channel == null;\n     }\n \n \n               System.err.println(\"Adding z64 for \" + ze.getName()\n               + \", method: \" + ze.getMethod()\n               + \" (\" + (ze.getMethod() == STORED) + \")\"\n-              + \", raf: \" + (raf != null));\n+              + \", channel: \" + (channel != null));\n             */\n             z64 = new Zip64ExtendedInformationExtraField();\n         }\n      */\n     private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n         if (zip64Mode != Zip64Mode.AsNeeded\n-            || raf != null\n+            || channel != null\n             || ze.getMethod() != DEFLATED\n             || ze.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n             return zip64Mode;\n      * corrupt archives so they can clean up any temporary files.</p>\n      */\n     void destroy() throws IOException {\n-        if (raf != null) {\n-            raf.close();\n+        if (channel != null) {\n+            channel.close();\n         }\n         if (out != null) {\n             out.close();", "timestamp": 1476291660, "metainfo": ""}