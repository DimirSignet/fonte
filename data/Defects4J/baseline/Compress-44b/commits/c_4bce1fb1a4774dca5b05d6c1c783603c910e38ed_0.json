{"sha": "4bce1fb1a4774dca5b05d6c1c783603c910e38ed", "log": "COMPRESS-56: enabled counting read bytes in InputStreams and added this information to exceptions, where it seems to fit.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n \n     private byte[] SINGLE = new byte[1];\n     private static final int BYTE_MASK = 0xFF;\n+    private int bytesRead = 0;\n \n     /**\n      * Returns the next Archive Entry in this Stream.\n      */\n     // public abstract XXXArchiveEntry getNextXXXEntry() throws IOException;\n \n-\n     /**\n      * Reads a byte of data. This method will block until enough input is\n      * available.\n         int num = read(SINGLE, 0, 1);\n         return num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n     }\n+    \n+    /**\n+     * Increments the counter of already read bytes.\n+     * Doesn't increment if the EOF has been hit (read == -1)\n+     * \n+     * @param read the number of bytes read\n+     */\n+    protected void count(int read) {\n+        if(read != -1) {\n+            bytesRead = bytesRead + read;\n+        }\n+    }\n+    \n+    /**\n+     * Returns the current number of bytes read from this stream.\n+     * @return the number of read bytes\n+     */\n+    public int getCount() {\n+        return bytesRead;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read header\");\n+                throw new IOException(\"failed to read header. Occured at byte: \" + getCount());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read entry header\");\n+                throw new IOException(\"failed to read entry header. Occured at byte: \" + getCount());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid entry header. not read the content?\");\n+                    throw new IOException(\"invalid entry header. not read the content? Occured at byte: \" + getCount());\n                 }\n             }\n         }\n             }\n         }\n         final int ret = this.input.read(b, off, toRead);\n+        count(ret);\n         offset += (ret > 0 ? ret : 0);\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n             } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                 this.entry = readOldAsciiEntry();\n             } else {\n-                throw new IOException(\"Unknown magic [\" + magicString + \"]\");\n+                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getCount());\n             }\n         }\n \n             this.entryEOF = true;\n             if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n                 if (this.crc != this.entry.getChksum()) {\n-                    throw new IOException(\"CRC Error\");\n+                    throw new IOException(\"CRC Error. Occured at byte: \" + getCount());\n                 }\n             }\n             return -1; // EOF for this entry\n         int n = 0;\n         while (n < len) {\n             int count = this.in.read(b, off + n, len - n);\n+            count(count);\n             if (count < 0) {\n                 throw new EOFException();\n             }\n         String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name);\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getCount());\n         }\n         skip(ret.getHeaderPadCount());\n \n         final String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name);\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getCount());\n         }\n \n         return ret;\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name);\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getCount());\n         }\n         skip(ret.getHeaderPadCount());\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             while (numToSkip > 0) {\n                 long skipped = skip(numToSkip);\n                 if (skipped <= 0) {\n-                    throw new RuntimeException(\"failed to skip current tar\"\n-                                               + \" entry\");\n+                    throw new RuntimeException(\"failed to skip current tar entry\");\n                 }\n                 numToSkip -= skipped;\n             }\n             if (rec == null) {\n                 // Unexpected EOF!\n                 throw new IOException(\"unexpected EOF with \" + numToRead\n-                                      + \" bytes unread\");\n-            }\n-\n+                                      + \" bytes unread. Occured at byte: \" + getCount());\n+            }\n+            count(rec.length);\n             int sz = numToRead;\n             int recLen = rec.length;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n                     if ((lengthOfLastRead = in.read(buf)) == -1) {\n                         return -1;\n                     }\n+                    count(lengthOfLastRead);\n                     bytesReadFromStream += lengthOfLastRead;\n                 }\n                 int toRead = length > lengthOfLastRead", "timestamp": 1239377775, "metainfo": ""}