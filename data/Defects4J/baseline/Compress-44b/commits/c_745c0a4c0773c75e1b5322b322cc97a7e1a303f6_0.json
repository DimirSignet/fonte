{"sha": "745c0a4c0773c75e1b5322b322cc97a7e1a303f6", "log": "whitespace", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n \n /**\n  * Base class for all PKWare strong crypto extra headers.\n- * \n+ *\n  * <p>This base class acts as a marker so you know you can ignore all\n  * extra fields that extend this class if you are not interested in\n  * the meta data of PKWare strong encryption.</p>\n  *\n  * <b>Algorithm IDs</b> - integer identifier of the encryption algorithm from\n  * the following range\n- * \n+ *\n  * <ul>\n  * <li>0x6601 - DES</li>\n  * <li>0x6602 - RC2 (version needed to extract < 5.2)</li>\n  * <li>0x6801 - RC4</li>\n  * <li>0xFFFF - Unknown algorithm</li>\n  * </ul>\n- * \n+ *\n  * <b>Hash Algorithms</b> - integer identifier of the hash algorithm from the\n  * following range\n- * \n+ *\n  * <ul>\n  * <li>0x0000 - none</li>\n  * <li>0x0001 - CRC32</li>\n \n         /**\n          * the algorithm id.\n-         * \n+         *\n          * @return the PKWare AlgorithmId\n          */\n         public int getCode() {\n \n         /**\n          * the hash algorithm ID.\n-         * \n+         *\n          * @return the PKWare hashAlg\n          */\n         public int getCode() {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0014_X509Certificates.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0014_X509Certificates.java\n  * ignored in any other record.\n  *\n  * Note: all fields stored in Intel low-byte/high-byte order.\n- * \n+ *\n  * <pre>\n  *         Value     Size     Description\n  *         -----     ----     -----------\n  *         TSize     2 bytes  Size of the store data\n  *         TData     TSize    Data about the store\n  * </pre>\n- * \n+ *\n  * @NotThreadSafe\n  */\n public class X0014_X509Certificates extends PKWareExtraHeader implements ZipExtraField {\n \n     /**\n      * Get the header id.\n-     * \n+     *\n      * @return the header id\n      */\n     public ZipShort getHeaderId() {\n     /**\n      * Set the extra field data in the local file data - without Header-ID or\n      * length specifier.\n-     * \n+     *\n      * @param data\n      *            the field data to use\n      */\n \n     /**\n      * Get the length of the local data.\n-     * \n+     *\n      * @return the length of the local data\n      */\n     public ZipShort getLocalFileDataLength() {\n \n     /**\n      * Get the local data.\n-     * \n+     *\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n \n     /**\n      * Set the extra field data in central directory.\n-     * \n+     *\n      * @param data\n      *            the data to use\n      */\n     /**\n      * Get the central data length. If there is no central data, get the local\n      * file data length.\n-     * \n+     *\n      * @return the central data length\n      */\n     public ZipShort getCentralDirectoryLength() {\n \n     /**\n      * Get the central data.\n-     * \n+     *\n      * @return the central data if present, else return the local file data\n      */\n     public byte[] getCentralDirectoryData() {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n  *         HashAlg   2 bytes  Hash algorithm identifier. (inferred)\n  *         TData     TSize    Signature Data\n  * </pre>\n- * \n+ *\n  * @NotThreadSafe\n  */\n public class X0015_CertificateIdForFile extends PKWareExtraHeader implements ZipExtraField {\n \n     /**\n      * Get the header id.\n-     * \n+     *\n      * @return the header id\n      */\n     public ZipShort getHeaderId() {\n \n     private int rcount;\n     private HashAlgorithm hashAlg;\n-    \n+\n     /**\n      * Get record count.\n      * @return\n     /**\n      * Set the extra field data in the local file data - without Header-ID or\n      * length specifier.\n-     * \n+     *\n      * @param data\n      *            the field data to use\n      */\n \n     /**\n      * Get the length of the local data.\n-     * \n+     *\n      * @return the length of the local data\n      */\n     public ZipShort getLocalFileDataLength() {\n \n     /**\n      * Get the local data.\n-     * \n+     *\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n \n     /**\n      * Set the extra field data in central directory.\n-     * \n+     *\n      * @param data\n      *            the data to use\n      */\n     /**\n      * Get the central data length. If there is no central data, get the local\n      * file data length.\n-     * \n+     *\n      * @return the central data length\n      */\n     public ZipShort getCentralDirectoryLength() {\n \n     /**\n      * Get the central data.\n-     * \n+     *\n      * @return the central data if present, else return the local file data\n      */\n     public byte[] getCentralDirectoryData() {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n  *         HashAlg   2 bytes  Hash algorithm identifier. (inferred)\n  *         TData     TSize    Data\n  * </pre>\n- * \n+ *\n  * @NotThreadSafe\n  */\n public class X0016_CertificateIdForCentralDirectory extends PKWareExtraHeader implements ZipExtraField {\n \n     /**\n      * Get the header id.\n-     * \n+     *\n      * @return the header id\n      */\n     public ZipShort getHeaderId() {\n     public int getRecordCount() {\n         return rcount;\n     }\n-    \n+\n     /**\n      * Get hash algorithm.\n      * @return\n     public HashAlgorithm getHashAlgorithm() {\n         return hashAlg;\n     }\n-    \n+\n     /**\n      * Set the extra field data in the local file data - without Header-ID or\n      * length specifier.\n-     * \n+     *\n      * @param data\n      *            the field data to use\n      */\n \n     /**\n      * Get the length of the local data.\n-     * \n+     *\n      * @return the length of the local data\n      */\n     public ZipShort getLocalFileDataLength() {\n \n     /**\n      * Get the local data.\n-     * \n+     *\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n \n     /**\n      * Set the extra field data in central directory.\n-     * \n+     *\n      * @param data\n      *            the data to use\n      */\n     /**\n      * Get the central data length. If there is no central data, get the local\n      * file data length.\n-     * \n+     *\n      * @return the central data length\n      */\n     public ZipShort getCentralDirectoryLength() {\n \n     /**\n      * Get the central data.\n-     * \n+     *\n      * @return the central data if present, else return the local file data\n      */\n     public byte[] getCentralDirectoryData() {\n \n     /**\n      * This should never be called for this header type.\n-     * \n+     *\n      * @param data\n      *            the array of bytes.\n      * @param offset\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n  * AlgID     2 bytes  Encryption algorithm identifier\n  * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n  * Flags     2 bytes  Processing flags\n- * RCount    4 bytes  Number of recipients. \n+ * RCount    4 bytes  Number of recipients.\n  * HashAlg   2 bytes  Hash algorithm identifier\n  * HSize     2 bytes  Hash size\n  * SRList    (var)    Simple list of recipients hashed public keys\n- * \n+ *\n  * Flags -   This defines the processing flags.\n- * \n+ *\n  *           <ul>\n  *           <li>0x0007 - reserved for future use\n  *           <li>0x000F - reserved for future use\n  *                        same algorithm used for encrypting the file contents.\n  *           <li>0x8000 - reserved for future use\n  *           </ul>\n- *        \n+ *\n  * RCount - This defines the number intended recipients whose\n  *          public keys were used for encryption.  This identifies\n  *          the number of elements in the SRList.\n- *          \n+ *\n  *          see also: reserved1\n- * \n+ *\n  * HashAlg - This defines the hash algorithm used to calculate\n  *           the public key hash of each public key used\n  *           for encryption. This field currently supports\n  *           only the following value for SHA-1\n- * \n+ *\n  *           0x8004 - SHA1\n- * \n+ *\n  * HSize -   This defines the size of a hashed public key.\n- * \n+ *\n  * SRList -  This is a variable length list of the hashed\n  *           public keys for each intended recipient.  Each\n  *           element in this list is HSize.  The total size of\n  *           SRList is determined using RCount * HSize.\n  * </pre>\n- * \n+ *\n  * Password-based Extra Field 0x0017 in central header only.\n- * \n+ *\n  * <pre>\n  * Value     Size     Description\n  * -----     ----     -----------\n  *\n  * <b>Format</b> - the data format identifier for this record. The only value\n  * allowed at this time is the integer value 2.\n- * \n+ *\n  * Password-based Extra Field 0x0017 preceding compressed file data.\n- * \n+ *\n  * <pre>\n  * Value     Size     Description\n  * -----     ----     -----------\n  * VSize     2 bytes  Size of password validation data\n  * VData     VSize-4  Password validation data\n  * VCRC32    4 bytes  Standard ZIP CRC32 of password validation data\n- *     \n+ *\n  * IVData - The size of the IV should match the algorithm block size.\n  *          The IVData can be completely random data.  If the size of\n  *          the randomly generated data does not match the block size\n  *          it should be complemented with zero's or truncated as\n  *          necessary.  If IVSize is 0,then IV = CRC32 + Uncompressed\n  *          File Size (as a 64 bit little-endian, unsigned integer value).\n- * \n+ *\n  * Format -  the data format identifier for this record.  The only\n  *           value allowed at this time is the integer value 2.\n- * \n+ *\n  * ErdData - Encrypted random data is used to store random data that\n  *           is used to generate a file session key for encrypting\n  *           each file.  SHA1 is used to calculate hash data used to\n  *           the value 0x4000, then the ErdData field must be\n  *           decrypted using 3DES. If the value 0x4000 is not set,\n  *           then the ErdData field must be decrypted using AlgId.\n- * \n+ *\n  * Reserved1 - Reserved for certificate processing, if value is\n  *           zero, then Reserved2 data is absent.  See the explanation\n  *           under the Certificate Processing Method for details on\n  *           this data structure.\n- * \n+ *\n  * Reserved2 - If present, the size of the Reserved2 data structure\n  *           is located by skipping the first 4 bytes of this field\n  *           and using the next 2 bytes as the remaining size.  See\n  *           the explanation under the Certificate Processing Method\n  *           for details on this data structure.\n- * \n+ *\n  * VSize - This size value will always include the 4 bytes of the\n  *         VCRC32 data and will be greater than 4 bytes.\n- * \n+ *\n  * VData - Random data for password validation.  This data is VSize\n  *         in length and VSize must be a multiple of the encryption\n- *         block size.  VCRC32 is a checksum value of VData. \n+ *         block size.  VCRC32 is a checksum value of VData.\n  *         VData and VCRC32 are stored encrypted and start the\n  *         stream of encrypted data for a file.\n  * </pre>\n- * \n- * \n+ *\n+ *\n  * Reserved1 - Certificate Decryption Header Reserved1 Data:\n- * \n+ *\n  * <pre>\n  * Value     Size     Description\n  * -----     ----     -----------\n  * RCount    4 bytes  Number of recipients.\n  * </pre>\n- * \n+ *\n  * RCount - This defines the number intended recipients whose public keys were\n  * used for encryption. This defines the number of elements in the REList field\n  * defined below.\n- * \n- * \n+ *\n+ *\n  * Reserved2 - Certificate Decryption Header Reserved2 Data Structures:\n- * \n+ *\n  * <pre>\n  * Value     Size     Description\n  * -----     ----     -----------\n  * HashAlg   2 bytes  Hash algorithm identifier\n  * HSize     2 bytes  Hash size\n  * REList    (var)    List of recipient data elements\n- * \n+ *\n  * HashAlg - This defines the hash algorithm used to calculate\n  *           the public key hash of each public key used\n  *           for encryption. This field currently supports\n  *           only the following value for SHA-1\n- *    \n+ *\n  *               0x8004 - SHA1\n- *                \n+ *\n  * HSize -   This defines the size of a hashed public key\n  *           defined in REHData.\n- * \n- * REList -  This is a variable length of list of recipient data. \n+ *\n+ * REList -  This is a variable length of list of recipient data.\n  *           Each element in this list consists of a Recipient\n  *           Element data structure as follows:\n  * </pre>\n- * \n+ *\n  * Recipient Element (REList) Data Structure:\n  *\n  * <pre>\n  * RESize    2 bytes  Size of REHData + REKData\n  * REHData   HSize    Hash of recipients public key\n  * REKData   (var)    Simple key blob\n- * \n- * \n+ *\n+ *\n  * RESize -  This defines the size of an individual REList\n  *           element.  This value is the combined size of the\n  *           REHData field + REKData field.  REHData is defined by\n  *           HSize.  REKData is variable and can be calculated\n  *           for each REList element using RESize and HSize.\n- * \n+ *\n  * REHData - Hashed public key for this recipient.\n- * \n+ *\n  * REKData - Simple Key Blob.  The format of this data structure\n  *           is identical to that defined in the Microsoft\n  *           CryptoAPI and generated using the CryptExportKey()\n  *           function.  The version of the Simple Key Blob\n  *           supported at this time is 0x02 as defined by\n  *           Microsoft.\n- *           \n+ *\n  *           For more details see https://msdn.microsoft.com/en-us/library/aa920051.aspx\n  * </pre>\n- * \n+ *\n  * <b>Flags</b> - Processing flags needed for decryption\n- * \n+ *\n  * <ul>\n  * <li>0x0001 - Password is required to decrypt</li>\n  * <li>0x0002 - Certificates only</li>\n \n     /**\n      * Get the header id.\n-     * \n+     *\n      * @return the header id\n      */\n     public ZipShort getHeaderId() {\n     // encryption data\n     private byte ivData[];\n     private byte erdData[];\n-    \n+\n     // encryption key\n     private byte recipientKeyHash[];\n     private byte keyBlob[];\n-    \n+\n     // password verification data\n     private byte vData[];\n     private byte vCRC32[];\n     public long getRecordCount() {\n         return rcount;\n     }\n-    \n+\n     /**\n      * Get hash algorithm.\n      * @return\n     public HashAlgorithm getHashAlgorithm() {\n         return hashAlg;\n     }\n-    \n+\n     /**\n      * Get encryption algorithm.\n      * @return\n     public EncryptionAlgorithm getEncryptionAlgorithm() {\n         return algId;\n     }\n-    \n+\n     /**\n      * Set the extra field data in the local file data - without Header-ID or\n      * length specifier.\n-     * \n+     *\n      * @param data\n      *            the field data to use\n      */\n \n     /**\n      * Get the length of the local data.\n-     * \n+     *\n      * @return the length of the local data\n      */\n     public ZipShort getLocalFileDataLength() {\n \n     /**\n      * Get the local data.\n-     * \n+     *\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n \n     /**\n      * Set the extra field data in central directory.\n-     * \n+     *\n      * @param data\n      *            the data to use\n      */\n     /**\n      * Get the central data length. If there is no central data, get the local\n      * file data length.\n-     * \n+     *\n      * @return the central data length\n      */\n     public ZipShort getCentralDirectoryLength() {\n \n     /**\n      * Get the central data.\n-     * \n+     *\n      * @return the central data if present, else return the local file data\n      */\n     public byte[] getCentralDirectoryData() {\n \n     /**\n      * Parse central directory format.\n-     * \n+     *\n      * @param data\n      * @param offset\n      * @param length\n \n     /**\n      * Parse file header format. (Password only?)\n-     * \n+     *\n      * @param data\n      * @param offset\n      * @param length\n         int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n         this.erdData = new byte[erdSize];\n         System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n-        \n+\n         this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n         System.out.println(\"rcount: \" + rcount);\n         if (rcount == 0) {\n             System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n             System.arraycopy(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, vCRC32, 0, 4);\n         }\n-        \n+\n         // validate values?\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0019_EncryptionRecipientCertificateList.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0019_EncryptionRecipientCertificateList.java\n \n /**\n  * PKCS#7 Encryption Recipient Certificate List (0x0019)\n- * \n+ *\n  * This field MAY contain information about each of the certificates used in\n  * encryption processing and it can be used to identify who is allowed to\n  * decrypt encrypted files. This field should only appear in the archive extra\n  * details. Refer to the section in this document entitled\n  * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n  * information.</b>\n- * \n+ *\n  * @NotThreadSafe\n  */\n public class X0019_EncryptionRecipientCertificateList extends PKWareExtraHeader implements ZipExtraField {\n \n     /**\n      * Get the header id.\n-     * \n+     *\n      * @return the header id\n      */\n     public ZipShort getHeaderId() {\n     /**\n      * Set the extra field data in the local file data - without Header-ID or\n      * length specifier.\n-     * \n+     *\n      * @param data\n      *            the field data to use\n      */\n \n     /**\n      * Get the length of the local data.\n-     * \n+     *\n      * @return the length of the local data\n      */\n     public ZipShort getLocalFileDataLength() {\n \n     /**\n      * Get the local data.\n-     * \n+     *\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n \n     /**\n      * Set the extra field data in central directory.\n-     * \n+     *\n      * @param data\n      *            the data to use\n      */\n     /**\n      * Get the central data length. If there is no central data, get the local\n      * file data length.\n-     * \n+     *\n      * @return the central data length\n      */\n     public ZipShort getCentralDirectoryLength() {\n \n     /**\n      * Get the central data.\n-     * \n+     *\n      * @return the central data if present, else return the local file data\n      */\n     public byte[] getCentralDirectoryData() {", "timestamp": 1450036182, "metainfo": ""}