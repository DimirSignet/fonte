{"sha": "c61c68d802266e0265a60e81f2eb5ae56e14b315", "log": "rename instance fields that look like class fields", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n  */\n public abstract class ArchiveInputStream extends InputStream {\n \n-    private final byte[] SINGLE = new byte[1];\n+    private final byte[] single = new byte[1];\n     private static final int BYTE_MASK = 0xFF;\n \n     /** holds the number of bytes read in this stream */\n      */\n     @Override\n     public int read() throws IOException {\n-        final int num = read(SINGLE, 0, 1);\n-        return num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n+        final int num = read(single, 0, 1);\n+        return num == -1 ? -1 : single[0] & BYTE_MASK;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n     private long entryOffset = -1;\n \n     // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n-    private final byte[] NAME_BUF = new byte[16];\n-    private final byte[] LAST_MODIFIED_BUF = new byte[12];\n-    private final byte[] ID_BUF = new byte[6];\n-    private final byte[] FILE_MODE_BUF = new byte[8];\n-    private final byte[] LENGTH_BUF = new byte[10];\n+    private final byte[] nameBuf = new byte[16];\n+    private final byte[] lastModifiedBuf = new byte[12];\n+    private final byte[] idBuf = new byte[6];\n+    private final byte[] fileModeBuf = new byte[8];\n+    private final byte[] lengthBuf = new byte[10];\n \n     /**\n      * Constructs an Ar input stream with the referenced stream\n             return null;\n         }\n \n-        IOUtils.readFully(this, NAME_BUF);\n-        IOUtils.readFully(this, LAST_MODIFIED_BUF);\n-        IOUtils.readFully(this, ID_BUF);\n-        final int userId = asInt(ID_BUF, true);\n-        IOUtils.readFully(this, ID_BUF);\n-        IOUtils.readFully(this, FILE_MODE_BUF);\n-        IOUtils.readFully(this, LENGTH_BUF);\n+        IOUtils.readFully(this, nameBuf);\n+        IOUtils.readFully(this, lastModifiedBuf);\n+        IOUtils.readFully(this, idBuf);\n+        final int userId = asInt(idBuf, true);\n+        IOUtils.readFully(this, idBuf);\n+        IOUtils.readFully(this, fileModeBuf);\n+        IOUtils.readFully(this, lengthBuf);\n \n         {\n             final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\n //        GNU ar uses a '/' to mark the end of the filename; this allows for the use of spaces without the use of an extended filename.\n \n         // entry name is stored as ASCII string\n-        String temp = ArchiveUtils.toAsciiString(NAME_BUF).trim();\n+        String temp = ArchiveUtils.toAsciiString(nameBuf).trim();\n         if (isGNUStringTable(temp)) { // GNU extended filenames entry\n-            currentEntry = readGNUStringTable(LENGTH_BUF);\n+            currentEntry = readGNUStringTable(lengthBuf);\n             return getNextArEntry();\n         }\n \n-        long len = asLong(LENGTH_BUF);\n+        long len = asLong(lengthBuf);\n         if (temp.endsWith(\"/\")) { // GNU terminator\n             temp = temp.substring(0, temp.length() - 1);\n         } else if (isGNULongName(temp)) {\n         }\n \n         currentEntry = new ArArchiveEntry(temp, len, userId,\n-                                          asInt(ID_BUF, true),\n-                                          asInt(FILE_MODE_BUF, 8),\n-                                          asLong(LAST_MODIFIED_BUF));\n+                                          asInt(idBuf, true),\n+                                          asInt(fileModeBuf, 8),\n+                                          asLong(lastModifiedBuf));\n         return currentEntry;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n     private final InputStream in;\n \n     // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n-    private final byte[] TWO_BYTES_BUF = new byte[2];\n-    private final byte[] FOUR_BYTES_BUF = new byte[4];\n-    private final byte[] SIX_BYTES_BUF = new byte[6];\n+    private final byte[] twoBytesBuf = new byte[2];\n+    private final byte[] fourBytesBuf = new byte[4];\n+    private final byte[] sixBytesBuf = new byte[6];\n \n     private final int blockSize;\n \n         if (this.entry != null) {\n             closeEntry();\n         }\n-        readFully(TWO_BYTES_BUF, 0, TWO_BYTES_BUF.length);\n-        if (CpioUtil.byteArray2long(TWO_BYTES_BUF, false) == MAGIC_OLD_BINARY) {\n+        readFully(twoBytesBuf, 0, twoBytesBuf.length);\n+        if (CpioUtil.byteArray2long(twoBytesBuf, false) == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(false);\n-        } else if (CpioUtil.byteArray2long(TWO_BYTES_BUF, true)\n+        } else if (CpioUtil.byteArray2long(twoBytesBuf, true)\n                    == MAGIC_OLD_BINARY) {\n             this.entry = readOldBinaryEntry(true);\n         } else {\n-            System.arraycopy(TWO_BYTES_BUF, 0, SIX_BYTES_BUF, 0,\n-                             TWO_BYTES_BUF.length);\n-            readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n-                      FOUR_BYTES_BUF.length);\n-            final String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n+            System.arraycopy(twoBytesBuf, 0, sixBytesBuf, 0,\n+                             twoBytesBuf.length);\n+            readFully(sixBytesBuf, twoBytesBuf.length,\n+                      fourBytesBuf.length);\n+            final String magicString = ArchiveUtils.toAsciiString(sixBytesBuf);\n             switch (magicString) {\n                 case MAGIC_NEW:\n                     this.entry = readNewEntry(false);\n     private void skip(final int bytes) throws IOException{\n         // bytes cannot be more than 3 bytes\n         if (bytes > 0) {\n-            readFully(FOUR_BYTES_BUF, 0, bytes);\n+            readFully(fourBytesBuf, 0, bytes);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n \n     private static final int SMALL_BUFFER_SIZE = 256;\n \n-    private final byte[] SMALL_BUF = new byte[SMALL_BUFFER_SIZE];\n+    private final byte[] smallBuf = new byte[SMALL_BUFFER_SIZE];\n \n     /** The size the TAR header */\n     private final int recordSize;\n         // read in the name\n         final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n         int length = 0;\n-        while ((length = read(SMALL_BUF)) >= 0) {\n-            longName.write(SMALL_BUF, 0, length);\n+        while ((length = read(smallBuf)) >= 0) {\n+            longName.write(smallBuf, 0, length);\n         }\n         getNextEntry();\n         if (currEntry == null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n     private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n \n     // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n-    private final byte[] LFH_BUF = new byte[LFH_LEN];\n-    private final byte[] SKIP_BUF = new byte[1024];\n-    private final byte[] SHORT_BUF = new byte[SHORT];\n-    private final byte[] WORD_BUF = new byte[WORD];\n-    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n+    private final byte[] lfhBuf = new byte[LFH_LEN];\n+    private final byte[] skipBuf = new byte[1024];\n+    private final byte[] shortBuf = new byte[SHORT];\n+    private final byte[] wordBuf = new byte[WORD];\n+    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n \n     private int entriesRead = 0;\n \n                 // first local file header - look for it and fail with\n                 // the appropriate error message if this is a split\n                 // archive.\n-                readFirstLocalFileHeader(LFH_BUF);\n+                readFirstLocalFileHeader(lfhBuf);\n             } else {\n-                readFully(LFH_BUF);\n+                readFully(lfhBuf);\n             }\n         } catch (final EOFException e) {\n             return null;\n         }\n \n-        final ZipLong sig = new ZipLong(LFH_BUF);\n+        final ZipLong sig = new ZipLong(lfhBuf);\n         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n             hitCentralDirectory = true;\n             skipRemainderOfArchive();\n         int off = WORD;\n         current = new CurrentEntry();\n \n-        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n+        final int versionMadeBy = ZipShort.getValue(lfhBuf, off);\n         off += SHORT;\n         current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n \n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n         current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n \n         off += SHORT;\n \n-        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n+        current.entry.setMethod(ZipShort.getValue(lfhBuf, off));\n         off += SHORT;\n \n-        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n+        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));\n         current.entry.setTime(time);\n         off += WORD;\n \n         ZipLong size = null, cSize = null;\n         if (!current.hasDataDescriptor) {\n-            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n+            current.entry.setCrc(ZipLong.getValue(lfhBuf, off));\n             off += WORD;\n \n-            cSize = new ZipLong(LFH_BUF, off);\n+            cSize = new ZipLong(lfhBuf, off);\n             off += WORD;\n \n-            size = new ZipLong(LFH_BUF, off);\n+            size = new ZipLong(lfhBuf, off);\n             off += WORD;\n         } else {\n             off += 3 * WORD;\n         }\n \n-        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n+        final int fileNameLen = ZipShort.getValue(lfhBuf, off);\n \n         off += SHORT;\n \n-        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n+        final int extraLen = ZipShort.getValue(lfhBuf, off);\n         off += SHORT;\n \n         final byte[] fileName = new byte[fileNameLen];\n             long skipped = 0;\n             while (skipped < value) {\n                 final long rem = value - skipped;\n-                final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n+                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                 if (x == -1) {\n                     return skipped;\n                 }\n     }\n \n     private void readDataDescriptor() throws IOException {\n-        readFully(WORD_BUF);\n-        ZipLong val = new ZipLong(WORD_BUF);\n+        readFully(wordBuf);\n+        ZipLong val = new ZipLong(wordBuf);\n         if (ZipLong.DD_SIG.equals(val)) {\n             // data descriptor with signature, skip sig\n-            readFully(WORD_BUF);\n-            val = new ZipLong(WORD_BUF);\n+            readFully(wordBuf);\n+            val = new ZipLong(wordBuf);\n         }\n         current.entry.setCrc(val.getValue());\n \n         // descriptor (ignoring archive decryption headers for now).\n         // If so, push back eight bytes and assume sizes are four\n         // bytes, otherwise sizes are eight bytes each.\n-        readFully(TWO_DWORD_BUF);\n-        final ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n+        readFully(twoDwordBuf);\n+        final ZipLong potentialSig = new ZipLong(twoDwordBuf, DWORD);\n         if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n-            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n-            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n-            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n+            pushback(twoDwordBuf, DWORD, DWORD);\n+            current.entry.setCompressedSize(ZipLong.getValue(twoDwordBuf));\n+            current.entry.setSize(ZipLong.getValue(twoDwordBuf, WORD));\n         } else {\n-            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n-            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n+            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(twoDwordBuf));\n+            current.entry.setSize(ZipEightByteInteger.getLongValue(twoDwordBuf, DWORD));\n         }\n     }\n \n         realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n         findEocdRecord();\n         realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n-        readFully(SHORT_BUF);\n+        readFully(shortBuf);\n         // file comment\n-        realSkip(ZipShort.getValue(SHORT_BUF));\n+        realSkip(ZipShort.getValue(shortBuf));\n     }\n \n     /**\n             long skipped = 0;\n             while (skipped < value) {\n                 final long rem = value - skipped;\n-                final int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n+                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                 if (x == -1) {\n                     return;\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n     private volatile boolean closed = true;\n \n     // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n-    private final byte[] DWORD_BUF = new byte[DWORD];\n-    private final byte[] WORD_BUF = new byte[WORD];\n-    private final byte[] CFH_BUF = new byte[CFH_LEN];\n-    private final byte[] SHORT_BUF = new byte[SHORT];\n-    private final ByteBuffer DWORD_BBUF = ByteBuffer.wrap(DWORD_BUF);\n-    private final ByteBuffer WORD_BBUF = ByteBuffer.wrap(WORD_BUF);\n-    private final ByteBuffer CFH_BBUF = ByteBuffer.wrap(CFH_BUF);\n-    private final ByteBuffer SHORT_BBUF = ByteBuffer.wrap(SHORT_BUF);\n+    private final byte[] dwordBuf = new byte[DWORD];\n+    private final byte[] wordBuf = new byte[WORD];\n+    private final byte[] cfhBuf = new byte[CFH_LEN];\n+    private final byte[] shortBuf = new byte[SHORT];\n+    private final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\n+    private final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\n+    private final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\n \n     /**\n      * Opens the given file for reading, assuming \"UTF8\" for file names.\n      */\n     public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n         final ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n-        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n+        Arrays.sort(allEntries, offsetComparator);\n         return Collections.enumeration(Arrays.asList(allEntries));\n     }\n \n         ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n         if (nameMap.containsKey(name)) {\n             entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n-            Arrays.sort(entriesOfThatName, OFFSET_COMPARATOR);\n+            Arrays.sort(entriesOfThatName, offsetComparator);\n         }\n         return Arrays.asList(entriesOfThatName);\n     }\n \n         positionAtCentralDirectory();\n \n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        long sig = ZipLong.getValue(WORD_BUF);\n+        wordBbuf.rewind();\n+        IOUtils.readFully(archive, wordBbuf);\n+        long sig = ZipLong.getValue(wordBuf);\n \n         if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n             throw new IOException(\"central directory is empty, can't expand\"\n \n         while (sig == CFH_SIG) {\n             readCentralDirectoryEntry(noUTF8Flag);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n-            sig = ZipLong.getValue(WORD_BUF);\n+            wordBbuf.rewind();\n+            IOUtils.readFully(archive, wordBbuf);\n+            sig = ZipLong.getValue(wordBuf);\n         }\n         return noUTF8Flag;\n     }\n     private void\n         readCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n         throws IOException {\n-        CFH_BBUF.rewind();\n-        IOUtils.readFully(archive, CFH_BBUF);\n+        cfhBbuf.rewind();\n+        IOUtils.readFully(archive, cfhBbuf);\n         int off = 0;\n         final OffsetEntry offset = new OffsetEntry();\n         final Entry ze = new Entry(offset);\n \n-        final int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n+        final int versionMadeBy = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n         ze.setVersionMadeBy(versionMadeBy);\n         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n \n-        ze.setVersionRequired(ZipShort.getValue(CFH_BUF, off));\n+        ze.setVersionRequired(ZipShort.getValue(cfhBuf, off));\n         off += SHORT; // version required\n \n-        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(CFH_BUF, off);\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);\n         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n         ze.setGeneralPurposeBit(gpFlag);\n-        ze.setRawFlag(ZipShort.getValue(CFH_BUF, off));\n+        ze.setRawFlag(ZipShort.getValue(cfhBuf, off));\n \n         off += SHORT;\n \n         //noinspection MagicConstant\n-        ze.setMethod(ZipShort.getValue(CFH_BUF, off));\n+        ze.setMethod(ZipShort.getValue(cfhBuf, off));\n         off += SHORT;\n \n-        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n+        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfhBuf, off));\n         ze.setTime(time);\n         off += WORD;\n \n-        ze.setCrc(ZipLong.getValue(CFH_BUF, off));\n+        ze.setCrc(ZipLong.getValue(cfhBuf, off));\n         off += WORD;\n \n-        ze.setCompressedSize(ZipLong.getValue(CFH_BUF, off));\n+        ze.setCompressedSize(ZipLong.getValue(cfhBuf, off));\n         off += WORD;\n \n-        ze.setSize(ZipLong.getValue(CFH_BUF, off));\n+        ze.setSize(ZipLong.getValue(cfhBuf, off));\n         off += WORD;\n \n-        final int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n+        final int fileNameLen = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n \n-        final int extraLen = ZipShort.getValue(CFH_BUF, off);\n+        final int extraLen = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n \n-        final int commentLen = ZipShort.getValue(CFH_BUF, off);\n+        final int commentLen = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n \n-        final int diskStart = ZipShort.getValue(CFH_BUF, off);\n+        final int diskStart = ZipShort.getValue(cfhBuf, off);\n         off += SHORT;\n \n-        ze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\n+        ze.setInternalAttributes(ZipShort.getValue(cfhBuf, off));\n         off += SHORT;\n \n-        ze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\n+        ze.setExternalAttributes(ZipLong.getValue(cfhBuf, off));\n         off += WORD;\n \n         final byte[] fileName = new byte[fileNameLen];\n         ze.setName(entryEncoding.decode(fileName), fileName);\n \n         // LFH offset,\n-        offset.headerOffset = ZipLong.getValue(CFH_BUF, off);\n+        offset.headerOffset = ZipLong.getValue(cfhBuf, off);\n         // data offset will be filled later\n         entries.add(ze);\n \n             archive.position() > ZIP64_EOCDL_LENGTH;\n         if (searchedForZip64EOCD) {\n             archive.position(archive.position() - ZIP64_EOCDL_LENGTH);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n+            wordBbuf.rewind();\n+            IOUtils.readFully(archive, wordBbuf);\n             found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG,\n-                                  WORD_BUF);\n+                                  wordBuf);\n         }\n         if (!found) {\n             // not a ZIP64 archive\n         throws IOException {\n         skipBytes(ZIP64_EOCDL_LOCATOR_OFFSET\n                   - WORD /* signature has already been read */);\n-        DWORD_BBUF.rewind();\n-        IOUtils.readFully(archive, DWORD_BBUF);\n-        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        if (!Arrays.equals(WORD_BUF, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n+        dwordBbuf.rewind();\n+        IOUtils.readFully(archive, dwordBbuf);\n+        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n+        wordBbuf.rewind();\n+        IOUtils.readFully(archive, wordBbuf);\n+        if (!Arrays.equals(wordBuf, ZipArchiveOutputStream.ZIP64_EOCD_SIG)) {\n             throw new ZipException(\"archive's ZIP64 end of central \"\n                                    + \"directory locator is corrupt.\");\n         }\n         skipBytes(ZIP64_EOCD_CFD_LOCATOR_OFFSET\n                   - WORD /* signature has already been read */);\n-        DWORD_BBUF.rewind();\n-        IOUtils.readFully(archive, DWORD_BBUF);\n-        archive.position(ZipEightByteInteger.getLongValue(DWORD_BUF));\n+        dwordBbuf.rewind();\n+        IOUtils.readFully(archive, dwordBbuf);\n+        archive.position(ZipEightByteInteger.getLongValue(dwordBuf));\n     }\n \n     /**\n     private void positionAtCentralDirectory32()\n         throws IOException {\n         skipBytes(CFD_LOCATOR_OFFSET);\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        archive.position(ZipLong.getValue(WORD_BUF));\n+        wordBbuf.rewind();\n+        IOUtils.readFully(archive, wordBbuf);\n+        archive.position(ZipLong.getValue(wordBuf));\n     }\n \n     /**\n             for (; off >= stopSearching; off--) {\n                 archive.position(off);\n                 try {\n-                    WORD_BBUF.rewind();\n-                    IOUtils.readFully(archive, WORD_BBUF);\n-                    WORD_BBUF.flip();\n+                    wordBbuf.rewind();\n+                    IOUtils.readFully(archive, wordBbuf);\n+                    wordBbuf.flip();\n                 } catch (EOFException ex) {\n                     break;\n                 }\n-                int curr = WORD_BBUF.get();\n+                int curr = wordBbuf.get();\n                 if (curr == sig[POS_0]) {\n-                    curr = WORD_BBUF.get();\n+                    curr = wordBbuf.get();\n                     if (curr == sig[POS_1]) {\n-                        curr = WORD_BBUF.get();\n+                        curr = wordBbuf.get();\n                         if (curr == sig[POS_2]) {\n-                            curr = WORD_BBUF.get();\n+                            curr = wordBbuf.get();\n                             if (curr == sig[POS_3]) {\n                                 found = true;\n                                 break;\n             final OffsetEntry offsetEntry = ze.getOffsetEntry();\n             final long offset = offsetEntry.headerOffset;\n             archive.position(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n-            WORD_BBUF.rewind();\n-            IOUtils.readFully(archive, WORD_BBUF);\n-            WORD_BBUF.flip();\n-            WORD_BBUF.get(SHORT_BUF);\n-            final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n-            WORD_BBUF.get(SHORT_BUF);\n-            final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n+            wordBbuf.rewind();\n+            IOUtils.readFully(archive, wordBbuf);\n+            wordBbuf.flip();\n+            wordBbuf.get(shortBuf);\n+            final int fileNameLen = ZipShort.getValue(shortBuf);\n+            wordBbuf.get(shortBuf);\n+            final int extraFieldLen = ZipShort.getValue(shortBuf);\n             skipBytes(fileNameLen);\n             final byte[] localExtraData = new byte[extraFieldLen];\n             IOUtils.readFully(archive, ByteBuffer.wrap(localExtraData));\n      */\n     private boolean startsWithLocalFileHeader() throws IOException {\n         archive.position(0);\n-        WORD_BBUF.rewind();\n-        IOUtils.readFully(archive, WORD_BBUF);\n-        return Arrays.equals(WORD_BUF, ZipArchiveOutputStream.LFH_SIG);\n+        wordBbuf.rewind();\n+        IOUtils.readFully(archive, wordBbuf);\n+        return Arrays.equals(wordBuf, ZipArchiveOutputStream.LFH_SIG);\n     }\n \n     /**\n      *\n      * @since 1.1\n      */\n-    private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n+    private final Comparator<ZipArchiveEntry> offsetComparator =\n         new Comparator<ZipArchiveEntry>() {\n         @Override\n         public int compare(final ZipArchiveEntry e1, final ZipArchiveEntry e2) {\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n  */\n abstract class StreamBridge extends FilterOutputStream {\n     private InputStream input;\n-    private final Object INPUT_LOCK = new Object();\n+    private final Object inputLock = new Object();\n \n     protected StreamBridge(final OutputStream out) {\n         super(out);\n      * Provides the input view.\n      */\n     InputStream getInput() throws IOException {\n-        synchronized (INPUT_LOCK) {\n+        synchronized (inputLock) {\n             if (input == null) {\n                 input = getInputView();\n             }\n      */\n     void stop() throws IOException {\n         close();\n-        synchronized (INPUT_LOCK) {\n+        synchronized (inputLock) {\n             if (input != null) {\n                 input.close();\n                 input = null;", "timestamp": 1482242458, "metainfo": ""}