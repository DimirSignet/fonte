{"sha": "b3c6bf720c1520276c927bb38b321d22a654590b", "log": "Remove Redundant specification of type (Java 7).", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n         localFileHeader.name = readString(basicHeader);\n         localFileHeader.comment = readString(basicHeader);\n \n-        final ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n+        final ArrayList<byte[]> extendedHeaders = new ArrayList<>();\n         int extendedHeaderSize;\n         while ((extendedHeaderSize = read16(in)) > 0) {\n             final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n     private final short entryFormat;\n \n     private final HashMap<String, CpioArchiveEntry> names =\n-        new HashMap<String, CpioArchiveEntry>();\n+        new HashMap<>();\n \n     private long crc = 0;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n         }\n \n         public static Set<PERMISSION> find(final int code) {\n-            final Set<PERMISSION> set = new HashSet<PERMISSION>();\n+            final Set<PERMISSION> set = new HashSet<>();\n \n             for (final PERMISSION p : PERMISSION.values()) {\n                 if ((code & p.code) == p.code) {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n     protected TapeInputStream raw;\n \n     // map of ino -> dirent entry. We can use this to reconstruct full paths.\n-    private final Map<Integer, Dirent> names = new HashMap<Integer, Dirent>();\n+    private final Map<Integer, Dirent> names = new HashMap<>();\n \n     // map of ino -> (directory) entry when we're missing one or more elements in the path.\n-    private final Map<Integer, DumpArchiveEntry> pending = new HashMap<Integer, DumpArchiveEntry>();\n+    private final Map<Integer, DumpArchiveEntry> pending = new HashMap<>();\n \n     // queue of (directory) entries where we now have the full path.\n     private Queue<DumpArchiveEntry> queue;\n \n         // use priority based on queue to ensure parent directories are\n         // released first.\n-        queue = new PriorityQueue<DumpArchiveEntry>(10,\n+        queue = new PriorityQueue<>(10,\n                 new Comparator<DumpArchiveEntry>() {\n                     @Override\n                     public int compare(final DumpArchiveEntry p, final DumpArchiveEntry q) {\n     private String getPath(final DumpArchiveEntry entry) {\n         // build the stack of elements. It's possible that we're \n         // still missing an intermediate value and if so we\n-        final Stack<String> elements = new Stack<String>();\n+        final Stack<String> elements = new Stack<>();\n         Dirent dirent = null;\n \n         for (int i = entry.getIno();; i = dirent.getParentIno()) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n      * from the output of the first and so on.</p>\n      */\n     Iterable<Coder> getOrderedCoders() {\n-        final LinkedList<Coder> l = new LinkedList<Coder>();\n+        final LinkedList<Coder> l = new LinkedList<>();\n         int current = (int) packedStreams[0]; // more that 2^31 coders?\n         while (current != -1) {\n             l.addLast(coders[current]);\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n      */\n     public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\n         if (methods != null) {\n-            final LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\n+            final LinkedList<SevenZMethodConfiguration> l = new LinkedList<>();\n             for (final SevenZMethodConfiguration m : methods) {\n                 l.addLast(m);\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n     private InputStream currentFolderInputStream = null;\n     private byte[] password;\n \n-    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n+    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<>();\n \n     static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n             new BufferedInputStream(\n               new BoundedRandomAccessFileInputStream(file,\n                   archive.packSizes[firstPackStreamIndex]));\n-        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n+        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<>();\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n  */\n public class SevenZOutputFile implements Closeable {\n     private final RandomAccessFile file;\n-    private final List<SevenZArchiveEntry> files = new ArrayList<SevenZArchiveEntry>();\n+    private final List<SevenZArchiveEntry> files = new ArrayList<>();\n     private int numNonEmptyStreams = 0;\n     private final CRC32 crc32 = new CRC32();\n     private final CRC32 compressedCrc32 = new CRC32();\n     private CountingOutputStream[] additionalCountingStreams;\n     private Iterable<? extends SevenZMethodConfiguration> contentMethods =\n             Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n-    private final Map<SevenZArchiveEntry, long[]> additionalSizes = new HashMap<SevenZArchiveEntry, long[]>();\n+    private final Map<SevenZArchiveEntry, long[]> additionalSizes = new HashMap<>();\n     \n     /**\n      * Opens file to write a 7z archive to.\n         }\n \n         OutputStream out = new OutputStreamWrapper();\n-        final ArrayList<CountingOutputStream> moreStreams = new ArrayList<CountingOutputStream>();\n+        final ArrayList<CountingOutputStream> moreStreams = new ArrayList<>();\n         boolean first = true;\n         for (final SevenZMethodConfiguration m : getContentMethods(files.get(files.size() - 1))) {\n             if (!first) {\n     }\n \n     private static <T> Iterable<T> reverse(final Iterable<T> i) {\n-        final LinkedList<T> l = new LinkedList<T>();\n+        final LinkedList<T> l = new LinkedList<>();\n         for (final T t : i) {\n             l.addFirst(t);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n     final String encoding;\n \n     // the global PAX header\n-    private Map<String, String> globalPaxHeaders = new HashMap<String, String>();\n+    private Map<String, String> globalPaxHeaders = new HashMap<>();\n \n     /**\n      * Constructor for TarInputStream.\n     // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n     Map<String, String> parsePaxHeaders(final InputStream i)\n         throws IOException {\n-        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n         // Format is \"length keyword=value\\n\";\n         while(true){ // get length\n             int ch;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n             throw new IOException(\"Stream has already been finished\");\n         }\n         final TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n-        final Map<String, String> paxHeaders = new HashMap<String, String>();\n+        final Map<String, String> paxHeaders = new HashMap<>();\n         final String entryName = entry.getName();\n         final boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n                                                        TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     private static final Map<ZipShort, Class<?>> implementations;\n \n     static {\n-        implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n+        implementations = new ConcurrentHashMap<>();\n         register(AsiExtraField.class);\n         register(X5455_ExtendedTimestamp.class);\n         register(X7875_NewUnix.class);\n     public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                         final UnparseableExtraField onUnparseableData)\n         throws ZipException {\n-        final List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n+        final List<ZipExtraField> v = new ArrayList<>();\n         int start = 0;\n         LOOP:\n         while (start <= data.length - WORD) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n         private static final Map<Integer, EncryptionAlgorithm> codeToEnum;\n \n         static {\n-            final Map<Integer, EncryptionAlgorithm> cte = new HashMap<Integer, EncryptionAlgorithm>();\n+            final Map<Integer, EncryptionAlgorithm> cte = new HashMap<>();\n             for (final EncryptionAlgorithm method : values()) {\n                 cte.put(Integer.valueOf(method.getCode()), method);\n             }\n         private static final Map<Integer, HashAlgorithm> codeToEnum;\n \n         static {\n-            final Map<Integer, HashAlgorithm> cte = new HashMap<Integer, HashAlgorithm>();\n+            final Map<Integer, HashAlgorithm> cte = new HashMap<>();\n             for (final HashAlgorithm method : values()) {\n                 cte.put(Integer.valueOf(method.getCode()), method);\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n     private final List<ScatterZipOutputStream> streams = synchronizedList(new ArrayList<ScatterZipOutputStream>());\n     private final ExecutorService es;\n     private final ScatterGatherBackingStoreSupplier backingStoreSupplier;\n-    private final List<Future<Object>> futures = new ArrayList<Future<Object>>();\n+    private final List<Future<Object>> futures = new ArrayList<>();\n \n     private final long startedAt = System.currentTimeMillis();\n     private long compressionDoneAt = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n  * @since 1.10\n  */\n public class ScatterZipOutputStream implements Closeable {\n-    private final Queue<CompressedEntry> items = new ConcurrentLinkedQueue<CompressedEntry>();\n+    private final Queue<CompressedEntry> items = new ConcurrentLinkedQueue<>();\n     private final ScatterGatherBackingStore backingStore;\n     private final StreamCompressor streamCompressor;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n     public Simple8BitZipEncoding(final char[] highChars) {\n         this.highChars = highChars.clone();\n         final List<Simple8BitChar> temp =\n-            new ArrayList<Simple8BitChar>(this.highChars.length);\n+            new ArrayList<>(this.highChars.length);\n \n         byte code = 127;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      * @param fields an array of extra fields\n      */\n     public void setExtraFields(final ZipExtraField[] fields) {\n-        final List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();\n+        final List<ZipExtraField> newFields = new ArrayList<>();\n         for (final ZipExtraField field : fields) {\n             if (field instanceof UnparseableExtraFieldData) {\n                 unparseableExtra = (UnparseableExtraFieldData) field;\n             throw new java.util.NoSuchElementException();\n         }\n \n-        final List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();\n+        final List<ZipExtraField> newResult = new ArrayList<>();\n         for (final ZipExtraField extraField : extraFields) {\n             if (!type.equals(extraField.getHeaderId())){\n                 newResult.add( extraField);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n      * List of ZipArchiveEntries written so far.\n      */\n     private final List<ZipArchiveEntry> entries =\n-        new LinkedList<ZipArchiveEntry>();\n+        new LinkedList<>();\n \n     private final StreamCompressor streamCompressor;\n \n      * Holds the offsets of the LFH starts for each entry.\n      */\n     private final Map<ZipArchiveEntry, Long> offsets =\n-        new HashMap<ZipArchiveEntry, Long>();\n+        new HashMap<>();\n \n     /**\n      * The encoding to use for filenames and the file comment.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n \n     static {\n         final Map<String, SimpleEncodingHolder> se =\n-            new HashMap<String, SimpleEncodingHolder>();\n+            new HashMap<>();\n \n         final char[] cp437_high_chars =\n             new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * directory.\n      */\n     private final List<ZipArchiveEntry> entries =\n-        new LinkedList<ZipArchiveEntry>();\n+        new LinkedList<>();\n \n     /**\n      * Maps String to list of ZipArchiveEntrys, name -> actual entries.\n      */\n     private final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\n-        new HashMap<String, LinkedList<ZipArchiveEntry>>(HASH_SIZE);\n+        new HashMap<>(HASH_SIZE);\n \n     private static final class OffsetEntry {\n         private long headerOffset = -1;\n     private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n         throws IOException {\n         final HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n-            new HashMap<ZipArchiveEntry, NameAndComment>();\n+            new HashMap<>();\n \n         positionAtCentralDirectory();\n \n             final String name = ze.getName();\n             LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n             if (entriesOfThatName == null) {\n-                entriesOfThatName = new LinkedList<ZipArchiveEntry>();\n+                entriesOfThatName = new LinkedList<>();\n                 nameMap.put(name, entriesOfThatName);\n             }\n             entriesOfThatName.addLast(ze);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n     private static final Map<Integer, ZipMethod> codeToEnum;\n \n     static {\n-        final Map<Integer, ZipMethod> cte = new HashMap<Integer, ZipMethod>();\n+        final Map<Integer, ZipMethod> cte = new HashMap<>();\n         for (final ZipMethod method : values()) {\n             cte.put(method.getCode(), method);\n         }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n  */\n public final class ChangeSet {\n \n-    private final Set<Change> changes = new LinkedHashSet<Change>();\n+    private final Set<Change> changes = new LinkedHashSet<>();\n \n     /**\n      * Deletes the file with the filename from the archive. \n      * @return the changes as a copy\n      */\n     Set<Change> getChanges() {\n-        return new LinkedHashSet<Change>(changes);\n+        return new LinkedHashSet<>(changes);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n             throws IOException {\n         final ChangeSetResults results = new ChangeSetResults();\n \n-        final Set<Change> workingSet = new LinkedHashSet<Change>(changes);\n+        final Set<Change> workingSet = new LinkedHashSet<>(changes);\n \n         for (final Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n             final Change change = it.next();\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n  * Stores the results of an performed ChangeSet operation.\n  */\n public class ChangeSetResults {\n-    private final List<String> addedFromChangeSet = new ArrayList<String>();\n-    private final List<String> addedFromStream = new ArrayList<String>();\n-    private final List<String> deleted = new ArrayList<String>();\n+    private final List<String> addedFromChangeSet = new ArrayList<>();\n+    private final List<String> addedFromStream = new ArrayList<>();\n+    private final List<String> deleted = new ArrayList<>();\n \n     /**\n      * Adds the filename of a recently deleted file to the result list.\n--- a/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n      * versions of those file types. For example: from \".tar\" to \".tgz\".\n      */\n     private final Map<String, String> compressSuffix =\n-        new HashMap<String, String>();\n+        new HashMap<>();\n \n     /**\n      * Map from common filename suffixes of compressed files to the\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n \n     static {\n         final Map<String, String> uncompressSuffix =\n-            new LinkedHashMap<String, String>();\n+            new LinkedHashMap<>();\n         // backwards compatibilty: BZip2Utils never created the short\n         // tbz form, so .tar.bz2 has to be added explicitly\n         uncompressSuffix.put(\".tar.bz2\", \".tar\");\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n         // compressed extension of .tar as FileNameUtil will use the\n         // first one found\n         final Map<String, String> uncompressSuffix =\n-            new LinkedHashMap<String, String>();\n+            new LinkedHashMap<>();\n         uncompressSuffix.put(\".tgz\", \".tar\");\n         uncompressSuffix.put(\".taz\", \".tar\");\n         uncompressSuffix.put(\".svgz\", \".svg\");\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n     private static volatile CachedAvailability cachedLZMAAvailability;\n \n     static {\n-        final Map<String, String> uncompressSuffix = new HashMap<String, String>();\n+        final Map<String, String> uncompressSuffix = new HashMap<>();\n         uncompressSuffix.put(\".lzma\", \"\");\n         uncompressSuffix.put(\"-lzma\", \"\");\n         fileNameUtil = new FileNameUtil(uncompressSuffix, \".lzma\");\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n     public static void normalize(final File from, final File to, Map<String, String> props)\n         throws IOException {\n         if (props == null) {\n-            props = new HashMap<String, String>();\n+            props = new HashMap<>();\n         }\n         props.put(Pack200.Packer.SEGMENT_LIMIT, \"-1\");\n         final File f = File.createTempFile(\"commons-compress\", \"pack200normalize\");\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n     private static volatile CachedAvailability cachedXZAvailability;\n \n     static {\n-        final Map<String, String> uncompressSuffix = new HashMap<String, String>();\n+        final Map<String, String> uncompressSuffix = new HashMap<>();\n         uncompressSuffix.put(\".txz\", \".tar\");\n         uncompressSuffix.put(\".xz\", \"\");\n         uncompressSuffix.put(\"-xz\", \"\");", "timestamp": 1466887083, "metainfo": ""}