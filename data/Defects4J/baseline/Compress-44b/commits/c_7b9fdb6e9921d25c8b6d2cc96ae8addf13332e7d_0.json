{"sha": "7b9fdb6e9921d25c8b6d2cc96ae8addf13332e7d", "log": "COMPRESS-246 raw Snappy compressor", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorOutputStream;\n+import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;\n+import org.apache.commons.compress.compressors.lz77support.Parameters;\n+\n+/**\n+ * CompressorOutputStream for the raw Snappy format.\n+ *\n+ * <p>This implementation uses an internal buffer in order to handle\n+ * the back-references that are at the heart of the LZ77 algorithm.\n+ * The size of the buffer must be at least as big as the biggest\n+ * offset used in the compressed stream.  The current version of the\n+ * Snappy algorithm as defined by Google works on 32k blocks and\n+ * doesn't contain offsets bigger than 32k which is the default block\n+ * size used by this class.</p>\n+ *\n+ * <p>The raw Snappy format requires the uncompressed size to be\n+ * written at the beginning of the stream using a varint\n+ * representation, i.e. the number of bytes needed to write the\n+ * information is not known before the uncompressed size is\n+ * known. We've chosen to make the uncompressedSize a parameter of the\n+ * constructor in favor of buffering the whole output until the size\n+ * is known. When using the {@link FramedSnappyCompressorOutputStream}\n+ * this limitation is taken care of by the warpping framing\n+ * format.</p>\n+ *\n+ * @see <a href=\"https://github.com/google/snappy/blob/master/format_description.txt\">Snappy compressed format description</a>\n+ * @since 1.14\n+ * @NotThreadSafe\n+ */\n+public class SnappyCompressorOutputStream extends CompressorOutputStream {\n+    private final LZ77Compressor compressor;\n+    private final OutputStream os;\n+\n+    // used in one-arg write method\n+    private final byte[] oneByte = new byte[1];\n+\n+    private boolean finished = false;\n+\n+    /**\n+     * Constructor using the default block size of 32k.\n+     *\n+     * @param os the outputstream to write compressed data to\n+     * @param uncompressedSize the uncompressed size of data\n+     * @throws IOException if writing of the size fails\n+     */\n+    public SnappyCompressorOutputStream(final OutputStream os, final long uncompressedSize) throws IOException {\n+        this(os, uncompressedSize, SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE);\n+    }\n+\n+    /**\n+     * Constructor using a configurable block size.\n+     *\n+     * @param os the outputstream to write compressed data to\n+     * @param uncompressedSize the uncompressed size of data\n+     * @param blockSize the block size used - must be a power of two\n+     * @throws IOException if writing of the size fails\n+     */\n+    public SnappyCompressorOutputStream(final OutputStream os, final long uncompressedSize, final int blockSize)\n+        throws IOException {\n+        this(os, uncompressedSize, createParams(blockSize));\n+    }\n+\n+    /**\n+     * Constructor providing full control over the underlying LZ77 compressor.\n+     *\n+     * @param os the outputstream to write compressed data to\n+     * @param uncompressedSize the uncompressed size of data\n+     * @param params the parameters to use by the compressor - note\n+     * that the format itself imposes some limits like a maximum match\n+     * length of 64 bytes\n+     * @throws IOException if writing of the size fails\n+     */\n+    public SnappyCompressorOutputStream(final OutputStream os, final long uncompressedSize, Parameters params)\n+        throws IOException {\n+        this.os = os;\n+        compressor = new LZ77Compressor(params, new LZ77Compressor.Callback() {\n+                public void accept(LZ77Compressor.Block block) throws IOException {\n+                    //System.err.println(block);\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        writeLiteralBlock((LZ77Compressor.LiteralBlock) block);\n+                    } else if (block instanceof LZ77Compressor.BackReference) {\n+                        writeBackReference((LZ77Compressor.BackReference) block);\n+                    }\n+                }\n+            });\n+        writeUncompressedSize(uncompressedSize);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        oneByte[0] = (byte) (b & 0xff);\n+        write(oneByte);\n+    }\n+\n+    @Override\n+    public void write(byte[] data, int off, int len) throws IOException {\n+        compressor.compress(data, off, len);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        finish();\n+        os.close();\n+    }\n+\n+    /**\n+     * Compresses all remaining data and writes it to the stream,\n+     * doesn't close the underlying stream.\n+     * @throws IOException if an error occurs\n+     */\n+    public void finish() throws IOException {\n+        if (!finished) {\n+            compressor.finish();\n+            finished = true;\n+        }\n+    }\n+\n+    private void writeUncompressedSize(long uncompressedSize) throws IOException {\n+        boolean more = false;\n+        do {\n+            int currentByte = (int) (uncompressedSize & 0x7F);\n+            more = uncompressedSize > currentByte;\n+            if (more) {\n+                currentByte |= 0x80;\n+            }\n+            os.write(currentByte);\n+            uncompressedSize >>= 7;\n+        } while (more);\n+    }\n+\n+    // literal length is stored as (len - 1) either inside the tag\n+    // (six bits minus four flags) or in 1 to 4 bytes after the tag\n+    private static final int MAX_LITERAL_SIZE_WITHOUT_SIZE_BYTES = 60;\n+    private static final int MAX_LITERAL_SIZE_WITH_ONE_SIZE_BYTE = 1 << 8;\n+    private static final int MAX_LITERAL_SIZE_WITH_TWO_SIZE_BYTES = 1 << 16;\n+    private static final int MAX_LITERAL_SIZE_WITH_THREE_SIZE_BYTES = 1 << 24;\n+\n+    private static final int ONE_SIZE_BYTE_MARKER = 60 << 2;\n+    private static final int TWO_SIZE_BYTE_MARKER = 61 << 2;\n+    private static final int THREE_SIZE_BYTE_MARKER = 62 << 2;\n+    private static final int FOUR_SIZE_BYTE_MARKER = 63 << 2;\n+\n+    private void writeLiteralBlock(LZ77Compressor.LiteralBlock block) throws IOException {\n+        int len = block.getLength();\n+        if (len <= MAX_LITERAL_SIZE_WITHOUT_SIZE_BYTES) {\n+            writeLiteralBlockNoSizeBytes(block, len);\n+        } else if (len <= MAX_LITERAL_SIZE_WITH_ONE_SIZE_BYTE) {\n+            writeLiteralBlockOneSizeByte(block, len);\n+        } else if (len <= MAX_LITERAL_SIZE_WITH_TWO_SIZE_BYTES) {\n+            writeLiteralBlockTwoSizeBytes(block, len);\n+        } else if (len <= MAX_LITERAL_SIZE_WITH_THREE_SIZE_BYTES) {\n+            writeLiteralBlockThreeSizeBytes(block, len);\n+        } else {\n+            writeLiteralBlockFourSizeBytes(block, len);\n+        }\n+    }\n+\n+    private void writeLiteralBlockNoSizeBytes(LZ77Compressor.LiteralBlock block, int len) throws IOException {\n+        writeLiteralBlockWithSize(len - 1 << 2, 0, len, block);\n+    }\n+\n+    private void writeLiteralBlockOneSizeByte(LZ77Compressor.LiteralBlock block, int len) throws IOException {\n+        writeLiteralBlockWithSize(ONE_SIZE_BYTE_MARKER, 1, len, block);\n+    }\n+\n+    private void writeLiteralBlockTwoSizeBytes(LZ77Compressor.LiteralBlock block, int len) throws IOException {\n+        writeLiteralBlockWithSize(TWO_SIZE_BYTE_MARKER, 2, len, block);\n+    }\n+\n+    private void writeLiteralBlockThreeSizeBytes(LZ77Compressor.LiteralBlock block, int len) throws IOException {\n+        writeLiteralBlockWithSize(THREE_SIZE_BYTE_MARKER, 3, len, block);\n+    }\n+\n+    private void writeLiteralBlockFourSizeBytes(LZ77Compressor.LiteralBlock block, int len) throws IOException {\n+        writeLiteralBlockWithSize(FOUR_SIZE_BYTE_MARKER, 4, len, block);\n+    }\n+\n+    private void writeLiteralBlockWithSize(int tagByte, int sizeBytes, int len, LZ77Compressor.LiteralBlock block)\n+        throws IOException {\n+        os.write(tagByte);\n+        writeLittleEndian(sizeBytes, len - 1);\n+        os.write(block.getData(), block.getOffset(), len);\n+    }\n+\n+    private void writeLittleEndian(final int numBytes, int num) throws IOException {\n+        for (int i = 0; i < numBytes; i++) {\n+            os.write(num & 0xff);\n+            num >>= 8;\n+        }\n+    }\n+\n+    // Back-references (\"copies\") have their offset/size information\n+    // in two, three or five bytes.\n+    private static final int MIN_MATCH_LENGTH_WITH_ONE_OFFSET_BYTE = 4;\n+    private static final int MAX_MATCH_LENGTH_WITH_ONE_OFFSET_BYTE = 11;\n+    private static final int MAX_OFFSET_WITH_ONE_OFFSET_BYTE = 1 << 11 - 1;\n+    private static final int MAX_OFFSET_WITH_TWO_OFFSET_BYTES = 1 << 16 - 1;\n+\n+    private static final int ONE_BYTE_COPY_TAG = 1;\n+    private static final int TWO_BYTE_COPY_TAG = 2;\n+    private static final int FOUR_BYTE_COPY_TAG = 3;\n+\n+    private void writeBackReference(LZ77Compressor.BackReference block) throws IOException {\n+        final int len = block.getLength();\n+        final int offset = block.getOffset();\n+        if (len >= MIN_MATCH_LENGTH_WITH_ONE_OFFSET_BYTE && len <= MAX_MATCH_LENGTH_WITH_ONE_OFFSET_BYTE\n+            && offset <= MAX_OFFSET_WITH_ONE_OFFSET_BYTE) {\n+            writeBackReferenceWithOneOffsetByte(len, offset);\n+        } else if (offset < MAX_OFFSET_WITH_TWO_OFFSET_BYTES) {\n+            writeBackReferenceWithTwoOffsetBytes(len, offset);\n+        } else {\n+            writeBackReferenceWithFourOffsetBytes(len, offset);\n+        }\n+    }\n+\n+    private void writeBackReferenceWithOneOffsetByte(int len, int offset) throws IOException {\n+        os.write(ONE_BYTE_COPY_TAG | ((len - 4) << 2) | ((offset & 0x700) >> 3));\n+        os.write(offset & 0xff);\n+    }\n+\n+    private void writeBackReferenceWithTwoOffsetBytes(int len, int offset) throws IOException {\n+        writeBackReferenceWithLittleEndianOffset(TWO_BYTE_COPY_TAG, 2, len, offset);\n+    }\n+\n+    private void writeBackReferenceWithFourOffsetBytes(int len, int offset) throws IOException {\n+        writeBackReferenceWithLittleEndianOffset(FOUR_BYTE_COPY_TAG, 4, len, offset);\n+    }\n+\n+    private void writeBackReferenceWithLittleEndianOffset(int tag, int offsetBytes, int len, int offset)\n+        throws IOException {\n+        os.write(tag | ((len - 1) << 2));\n+        writeLittleEndian(offsetBytes, offset);\n+    }\n+\n+    // technically the format could use shorter matches but with a\n+    // length of three the offset would be encoded as at least two\n+    // bytes in addition to the tag, so yield no compression at all\n+    private static final int MIN_MATCH_LENGTH = 4;\n+    // Snappy stores the match length in six bits of the tag\n+    private static final int MAX_MATCH_LENGTH = 64;\n+\n+    // package private for tests\n+    static Parameters createParams(int blockSize) {\n+        // the max offset and max literal length defined by the format\n+        // are 2^32 - 1 and 2^32 respectively - with blockSize being\n+        // an integer we will never exceed that\n+        return new Parameters(blockSize, MIN_MATCH_LENGTH, MAX_MATCH_LENGTH, blockSize, blockSize);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/SnappyRoundtripTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Random;\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.lz77support.Parameters;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public final class SnappyRoundtripTest extends AbstractTestCase {\n+\n+    private void roundTripTest(String testFile) throws IOException {\n+        roundTripTest(getFile(testFile),\n+            SnappyCompressorOutputStream.createParams(SnappyCompressorInputStream.DEFAULT_BLOCK_SIZE));\n+    }\n+\n+    private void roundTripTest(final File input, Parameters params) throws IOException {\n+        long start = System.currentTimeMillis();\n+        final File outputSz = new File(dir, input.getName() + \".raw.sz\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             FileOutputStream os = new FileOutputStream(outputSz);\n+             SnappyCompressorOutputStream sos = new SnappyCompressorOutputStream(os, input.length(), params)) {\n+            IOUtils.copy(is, sos);\n+        }\n+        System.err.println(input.getName() + \" written, uncompressed bytes: \" + input.length()\n+            + \", compressed bytes: \" + outputSz.length() + \" after \" + (System.currentTimeMillis() - start) + \"ms\");\n+        try (FileInputStream is = new FileInputStream(input);\n+             SnappyCompressorInputStream sis = new SnappyCompressorInputStream(new FileInputStream(outputSz),\n+                 params.getWindowSize())) {\n+            byte[] expected = IOUtils.toByteArray(is);\n+            byte[] actual = IOUtils.toByteArray(sis);\n+            Assert.assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    // should yield decent compression\n+    @Test\n+    public void blaTarRoundtrip() throws IOException {\n+        roundTripTest(\"bla.tar\");\n+    }\n+\n+    // yields no compression at all\n+    @Test\n+    public void gzippedLoremIpsumRoundtrip() throws IOException {\n+        roundTripTest(\"lorem-ipsum.txt.gz\");\n+    }\n+\n+    @Test\n+    public void biggerFileRoundtrip() throws IOException {\n+        roundTripTest(\"COMPRESS-256.7z\");\n+    }\n+\n+    @Test\n+    public void tryReallyBigOffset() throws IOException {\n+        // \"normal\" Snappy files will never reach offsets beyond\n+        // 16bits (i.e. those using four bytes to encode the length)\n+        // as the block size is only 32k. This means we never execute\n+        // the code for four-byte length copies in either stream class\n+        // using real-world Snappy files.\n+        // This is an artifical stream using a bigger block size that\n+        // may not even be expandable by other Snappy implementations.\n+        // Start with the four byte sequence 0000 after that add > 64k\n+        // of random noise that doesn't contain any 0000 at all, then\n+        // add 0000.\n+        File f = new File(dir, \"reallyBigOffsetTest\");\n+        try (FileOutputStream fs = new FileOutputStream(f)) {\n+            fs.write(0);\n+            fs.write(0);\n+            fs.write(0);\n+            fs.write(0);\n+            int cnt = 1 << 16 + 5;\n+            Random r = new Random();\n+            for (int i = 0 ; i < cnt; i++) {\n+                fs.write(r.nextInt(255) + 1);\n+            }\n+            fs.write(0);\n+            fs.write(0);\n+            fs.write(0);\n+            fs.write(0);\n+        }\n+        roundTripTest(f, new Parameters(1 << 17, 4, 64, 1 << 17 - 1, 1 << 17 - 1));\n+    }\n+\n+    @Test\n+    public void tryReallyLongLiterals() throws IOException {\n+        // \"normal\" Snappy files will never reach literal blocks with\n+        // length beyond 16bits (i.e. those using three or four bytes\n+        // to encode the length) as the block size is only 32k. This\n+        // means we never execute the code for the three/four byte\n+        // length literals in either stream class using real-world\n+        // Snappy files.\n+        // What we'd need would be a sequence of bytes with no four\n+        // byte subsequence repeated that is longer than 64k, we try\n+        // our best with random, but will probably only hit the three byte\n+        // methods in a few lucky cases.\n+        // The four byte methods would require even more luck and a\n+        // buffer (and a file written to disk) that was 2^5 bigger\n+        // than the buffer used here.\n+        File f = new File(dir, \"reallyBigLiteralTest\");\n+        try (FileOutputStream fs = new FileOutputStream(f)) {\n+            int cnt = 1 << 19;\n+            Random r = new Random();\n+            for (int i = 0 ; i < cnt; i++) {\n+                fs.write(r.nextInt(256));\n+            }\n+        }\n+        roundTripTest(f, new Parameters(1 << 18, 4, 64, 1 << 16 - 1, 1 << 18 - 1));\n+    }\n+\n+}", "timestamp": 1484023837, "metainfo": ""}