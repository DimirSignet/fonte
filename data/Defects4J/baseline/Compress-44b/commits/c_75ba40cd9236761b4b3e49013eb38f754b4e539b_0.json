{"sha": "75ba40cd9236761b4b3e49013eb38f754b4e539b", "log": "extract little endian formatting", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n import org.apache.commons.compress.utils.BoundedInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n     private long expectedChecksum = -1;\n     private final int blockSize;\n     private final PureJavaCrc32C checksum = new PureJavaCrc32C();\n+\n+    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return readOneByte();\n+        }\n+    };\n \n     /**\n      * Constructs a new input stream that decompresses\n         if (read != 4) {\n             throw new IOException(\"premature end of stream\");\n         }\n-        long crc = 0;\n-        for (int i = 0; i < 4; i++) {\n-            crc |= (b[i] & 0xFFL) << (8 * i);\n-        }\n-        return crc;\n+        return ByteUtils.fromLittleEndian(b);\n     }\n \n     static long unmask(long x) {\n     }\n \n     private int readSize() throws IOException {\n-        int b = 0;\n-        int sz = 0;\n-        for (int i = 0; i < 3; i++) {\n-            b = readOneByte();\n-            if (b == -1) {\n-                throw new IOException(\"premature end of stream\");\n-            }\n-            sz |= (b << (i * 8));\n-        }\n-        return sz;\n+        return (int) ByteUtils.fromLittleEndian(supplier, 3);\n     }\n \n     private void skipBlock() throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java\n import java.io.OutputStream;\n \n import org.apache.commons.compress.compressors.CompressorOutputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n \n /**\n  * CompressorOutputStream for the framing Snappy format.\n     private final byte[] buffer = new byte[MAX_COMPRESSED_BUFFER_SIZE];\n     private int currentIndex = 0;\n \n+    private final ByteUtils.ByteConsumer consumer;\n+\n     /**\n      * Constructs a new output stream that compresses\n      * snappy-framed-compressed data to the specified output stream.\n      */\n     public FramedSnappyCompressorOutputStream(final OutputStream out) throws IOException {\n         this.out = out;\n+        consumer = new ByteUtils.OutputStreamByteConsumer(out);\n         out.write(FramedSnappyCompressorInputStream.SZ_SIGNATURE);\n     }\n \n     }\n \n     private void writeLittleEndian(final int numBytes, long num) throws IOException {\n-        for (int i = 0; i < numBytes; i++) {\n-            out.write((int) (num & 0xff));\n-            num >>= 8;\n-        }\n+        ByteUtils.toLittleEndian(consumer, num, numBytes);\n     }\n \n     private void writeCrc() throws IOException {\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n import java.io.InputStream;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.ByteUtils;\n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n \n     private boolean endReached = false;\n \n+    private final ByteUtils.ByteSupplier supplier = new ByteUtils.ByteSupplier() {\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return readOneByte();\n+        }\n+    };\n+\n     /**\n      * Constructor using the default buffer size of 32k.\n      * \n                 length = (b >> 2) + 1;\n                 uncompressedBytesRemaining -= length;\n \n-                offset = readOneByte();\n-                offset |= readOneByte() << 8;\n+                offset = ByteUtils.fromLittleEndian(supplier, 2);\n \n                 if (expandCopy(offset, length)) {\n                     return;\n                 length = (b >> 2) + 1;\n                 uncompressedBytesRemaining -= length;\n \n-                offset = readOneByte();\n-                offset |= readOneByte() << 8;\n-                offset |= readOneByte() << 16;\n-                offset |= ((long) readOneByte()) << 24;\n+                offset = ByteUtils.fromLittleEndian(supplier, 4);\n \n                 if (expandCopy(offset, length)) {\n                     return;\n             length = readOneByte();\n             break;\n         case 61:\n-            length = readOneByte();\n-            length |= readOneByte() << 8;\n+            length = (int) ByteUtils.fromLittleEndian(supplier, 2);\n             break;\n         case 62:\n-            length = readOneByte();\n-            length |= readOneByte() << 8;\n-            length |= readOneByte() << 16;\n+            length = (int) ByteUtils.fromLittleEndian(supplier, 3);\n             break;\n         case 63:\n-            length = readOneByte();\n-            length |= readOneByte() << 8;\n-            length |= readOneByte() << 16;\n-            length |= (((long) readOneByte()) << 24);\n+            length = (int) ByteUtils.fromLittleEndian(supplier, 4);\n             break;\n         default:\n             length = b >> 2;\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorOutputStream.java\n import org.apache.commons.compress.compressors.CompressorOutputStream;\n import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;\n import org.apache.commons.compress.compressors.lz77support.Parameters;\n+import org.apache.commons.compress.utils.ByteUtils;\n \n /**\n  * CompressorOutputStream for the raw Snappy format.\n public class SnappyCompressorOutputStream extends CompressorOutputStream {\n     private final LZ77Compressor compressor;\n     private final OutputStream os;\n+    private final ByteUtils.ByteConsumer consumer;\n \n     // used in one-arg write method\n     private final byte[] oneByte = new byte[1];\n     public SnappyCompressorOutputStream(final OutputStream os, final long uncompressedSize, Parameters params)\n         throws IOException {\n         this.os = os;\n+        consumer = new ByteUtils.OutputStreamByteConsumer(os);\n         compressor = new LZ77Compressor(params, new LZ77Compressor.Callback() {\n                 public void accept(LZ77Compressor.Block block) throws IOException {\n                     //System.err.println(block);\n     }\n \n     private void writeLittleEndian(final int numBytes, int num) throws IOException {\n-        for (int i = 0; i < numBytes; i++) {\n-            os.write(num & 0xff);\n-            num >>= 8;\n-        }\n+        ByteUtils.toLittleEndian(consumer, num, numBytes);\n     }\n \n     // Back-references (\"copies\") have their offset/size information\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/ByteUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Utility methods for reading and writing bytes.\n+ * @since 1.14\n+ */\n+public final class ByteUtils {\n+    private ByteUtils() { /* no instances */ }\n+\n+    /**\n+     * Used to supply bytes.\n+     * @since 1.14\n+     */\n+    public interface ByteSupplier {\n+        /**\n+         * The contract is similar to {@link InputStream#read()}, return\n+         * the byte as an unsigned int, -1 if there are no more bytes.\n+         */\n+        int getAsByte() throws IOException;\n+    }\n+\n+    /**\n+     * Used to consume bytes.\n+     * @since 1.14\n+     */\n+    public interface ByteConsumer {\n+        /**\n+         * The contract is similar to {@link OutputStream#write(int)},\n+         * consume the lower eight bytes of the int as a byte.\n+         */\n+        void accept(int b) throws IOException;\n+    }\n+\n+    /**\n+     * Reads the given byte array as a little endian long.\n+     * @param bytes the byte array to convert\n+     */\n+    public static long fromLittleEndian(byte[] bytes) {\n+        return fromLittleEndian(bytes, 0, bytes.length);\n+    }\n+\n+    /**\n+     * Reads the given byte array as a little endian long.\n+     * @param bytes the byte array to convert\n+     * @param off the offset into the array that starts the value\n+     * @param length the number of bytes representing the value\n+     * @throws IllegalArgumentException if len is bigger than eight\n+     */\n+    public static long fromLittleEndian(byte[] bytes, final int off, final int length) {\n+        if (length > 8) {\n+            throw new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n+        }\n+        long l = 0;\n+        for (int i = 0; i < length; i++) {\n+            l |= (bytes[off + i] & 0xffl) << (8 * i);\n+        }\n+        return l;\n+    }\n+\n+    /**\n+     * Reads the given number of bytes from the given stream as a little endian long.\n+     * @param in the stream to read from\n+     * @param length the number of bytes representing the value\n+     * @throws IllegalArgumentException if len is bigger than eight\n+     * @throws IOException if reading fails or the stream doesn't\n+     * contain the given number of bytes anymore\n+     */\n+    public static long fromLittleEndian(InputStream in, int length) throws IOException {\n+        return fromLittleEndian(new InputStreamByteSupplier(in), length);\n+    }\n+\n+    /**\n+     * Reads the given number of bytes from the given supplier as a little endian long.\n+     * @param supplier the supplier for bytes\n+     * @param length the number of bytes representing the value\n+     * @throws IllegalArgumentException if len is bigger than eight\n+     * @throws IOException if the supplier fails or doesn't supply the\n+     * given number of bytes anymore\n+     */\n+    public static long fromLittleEndian(ByteSupplier supplier, final int length) throws IOException {\n+        if (length > 8) {\n+            throw new IllegalArgumentException(\"can't read more than eight bytes into a long value\");\n+        }\n+        long l = 0;\n+        for (int i = 0; i < length; i++) {\n+            int b = supplier.getAsByte();\n+            if (b == -1) {\n+                throw new IOException(\"premature end of data\");\n+            }\n+            l |= (b << (i * 8));\n+        }\n+        return l;\n+    }\n+\n+    /**\n+     * Writes the given value to the given stream as a little endian\n+     * array of the given length.\n+     * @param out the stream to write to\n+     * @param value the value to write\n+     * @param length the number of bytes to use to represent the value\n+     * @throws IOException if writing fails\n+     */\n+    public static void toLittleEndian(OutputStream out, final long value, final int length)\n+        throws IOException {\n+        toLittleEndian(new OutputStreamByteConsumer(out), value, length);\n+    }\n+\n+    /**\n+     * Provides the given value to the given consumer as a little endian\n+     * sequence of the given length.\n+     * @param consumer the consumer to provide the bytes to\n+     * @param value the value to provide\n+     * @param length the number of bytes to use to represent the value\n+     * @throws IOException if writing fails\n+     */\n+    public static void toLittleEndian(ByteConsumer consumer, final long value, final int length)\n+        throws IOException {\n+        long num = value;\n+        for (int i = 0; i < length; i++) {\n+            consumer.accept((int) (num & 0xff));\n+            num >>= 8;\n+        }\n+    }\n+\n+    /**\n+     * {@link ByteSupplier} based on {@link InputStream}.\n+     * @since 1.14\n+     */\n+    public static class InputStreamByteSupplier implements ByteSupplier {\n+        private final InputStream is;\n+        public InputStreamByteSupplier(InputStream is) {\n+            this.is = is;\n+        }\n+        @Override\n+        public int getAsByte() throws IOException {\n+            return is.read();\n+        }\n+    }\n+\n+    /**\n+     * {@link ByteConsumer} based on {@link OutputStream}.\n+     * @since 1.14\n+     */\n+    public static class OutputStreamByteConsumer implements ByteConsumer {\n+        private final OutputStream os;\n+        public OutputStreamByteConsumer(OutputStream os) {\n+            this.os = os;\n+        }\n+        @Override\n+        public void accept(int b) throws IOException {\n+            os.write(b);\n+        }\n+    }\n+}", "timestamp": 1484403126, "metainfo": ""}