{"sha": "e926d99b192110cb53332ab932bcb43e0d947d19", "log": "COMPRESS-327 read-only in memory SeekableByteChannel", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/SeekableInMemoryByteChannel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.NonWritableChannelException;\n+import java.nio.channels.SeekableByteChannel;\n+\n+/**\n+ * A {@link SeekableByteChannel} implementation that wraps a byte[].\n+ */\n+public class SeekableInMemoryByteChannel implements SeekableByteChannel {\n+\n+    private final byte[] data;\n+    private volatile boolean closed;\n+    private volatile long position, size;\n+\n+    public SeekableInMemoryByteChannel(byte[] data) {\n+        this.data = data;\n+        size = data.length;\n+    }\n+\n+    @Override\n+    public long position() {\n+        return position;\n+    }\n+\n+    @Override\n+    public SeekableByteChannel position(long newPosition) {\n+        position = newPosition;\n+        return this;\n+    }\n+\n+    @Override\n+    public long size() {\n+        return size;\n+    }\n+\n+    @Override\n+    public SeekableByteChannel truncate(long newSize) {\n+        size = newSize;\n+        return this;\n+    }\n+\n+    @Override\n+    public int read(ByteBuffer buf) throws IOException {\n+        if (!isOpen()) {\n+            throw new ClosedChannelException();\n+        }\n+        long pos = position;\n+        long sz = size;\n+        int wanted = buf.remaining();\n+        long possible = sz - pos;\n+        if (wanted > possible) {\n+            wanted = (int) possible;\n+        }\n+        buf.put(data, (int) pos, wanted);\n+        position = pos + wanted;\n+        return wanted;\n+    }\n+\n+    @Override\n+    public void close() {\n+        closed = true;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return !closed;\n+    }\n+\n+    // TODO implement writing\n+    @Override\n+    public int write(ByteBuffer b) throws IOException {\n+        throw new NonWritableChannelException();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n \n import java.io.ByteArrayOutputStream;\n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.security.NoSuchAlgorithmException;\n import java.util.Arrays;\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.PasswordRequiredException;\n+import org.apache.commons.compress.utils.IOUtils;\n+import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;\n import org.junit.Test;\n \n public class SevenZFileTest extends AbstractTestCase {\n         }\n     }\n \n+    @Test\n+    public void getEntriesOfUnarchiveInMemoryTest() throws IOException {\n+        byte[] data = null;\n+        try (FileInputStream fis = new FileInputStream(getFile(\"bla.7z\"))) {\n+            data = IOUtils.toByteArray(fis);\n+        }\n+        try (SevenZFile sevenZFile = new SevenZFile(new SeekableInMemoryByteChannel(data),\n+                                                    \"in memory\", null)) {\n+            final Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\n+            final Iterator<SevenZArchiveEntry> iter = entries.iterator();\n+            SevenZArchiveEntry entry = iter.next();\n+            assertEquals(\"test1.xml\", entry.getName());\n+            entry = iter.next();\n+            assertEquals(\"test2.xml\", entry.getName());\n+            assertFalse(iter.hasNext());\n+        }\n+    }\n+\n     /**\n      * @see \"https://issues.apache.org/jira/browse/COMPRESS-348\"\n      */\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.util.zip.ZipEntry;\n \n import org.apache.commons.compress.utils.IOUtils;\n+import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;\n import org.junit.After;\n import org.junit.Test;\n \n     }\n \n     @Test\n+    public void testCDOrderInMemory() throws Exception {\n+        byte[] data = null;\n+        try (FileInputStream fis = new FileInputStream(getFile(\"ordertest.zip\"))) {\n+            data = IOUtils.toByteArray(fis);\n+        }\n+\n+        zf = new ZipFile(new SeekableInMemoryByteChannel(data), \"in memory\",\n+                         ZipEncodingHelper.UTF8, true);\n+        final ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntries());\n+        assertEntryName(l, 0, \"AbstractUnicodeExtraField\");\n+        assertEntryName(l, 1, \"AsiExtraField\");\n+        assertEntryName(l, 2, \"ExtraFieldUtils\");\n+        assertEntryName(l, 3, \"FallbackZipEncoding\");\n+        assertEntryName(l, 4, \"GeneralPurposeBit\");\n+        assertEntryName(l, 5, \"JarMarker\");\n+        assertEntryName(l, 6, \"NioZipEncoding\");\n+        assertEntryName(l, 7, \"Simple8BitZipEncoding\");\n+        assertEntryName(l, 8, \"UnicodeCommentExtraField\");\n+        assertEntryName(l, 9, \"UnicodePathExtraField\");\n+        assertEntryName(l, 10, \"UnixStat\");\n+        assertEntryName(l, 11, \"UnparseableExtraFieldData\");\n+        assertEntryName(l, 12, \"UnrecognizedExtraField\");\n+        assertEntryName(l, 13, \"ZipArchiveEntry\");\n+        assertEntryName(l, 14, \"ZipArchiveInputStream\");\n+        assertEntryName(l, 15, \"ZipArchiveOutputStream\");\n+        assertEntryName(l, 16, \"ZipEncoding\");\n+        assertEntryName(l, 17, \"ZipEncodingHelper\");\n+        assertEntryName(l, 18, \"ZipExtraField\");\n+        assertEntryName(l, 19, \"ZipUtil\");\n+        assertEntryName(l, 20, \"ZipLong\");\n+        assertEntryName(l, 21, \"ZipShort\");\n+        assertEntryName(l, 22, \"ZipFile\");\n+    }\n+\n+    @Test\n     public void testPhysicalOrder() throws Exception {\n         readOrderTest();\n         final ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntriesInPhysicalOrder());", "timestamp": 1476357428, "metainfo": ""}