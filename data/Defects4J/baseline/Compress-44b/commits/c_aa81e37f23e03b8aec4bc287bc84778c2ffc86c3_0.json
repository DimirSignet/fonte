{"sha": "aa81e37f23e03b8aec4bc287bc84778c2ffc86c3", "log": "implement back-reference detection", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n     private int blockStart = 0;\n     // position of the current match\n     private int matchStart = NO_MATCH;\n+    // number of insertString calls for the up to three last bytes of the last match\n+    private int missedInserts = 0;\n \n     /**\n      * Initializes a compressor with parameters and a callback.\n         final int minMatch = params.getMinMatchSize();\n \n         while (lookahead >= minMatch) {\n+            catchUpMissedInserts();\n             int matchLength = 0;\n-            int hashHead = insertString();\n+            int hashHead = insertString(currentPosition);\n             if (hashHead != NO_MATCH && hashHead - currentPosition <= params.getMaxOffset()) {\n                 // sets matchStart as a side effect\n                 matchLength = longestMatch(hashHead);\n                     flushLiteralBlock();\n                     blockStart = NO_MATCH;\n                 }\n+                flushBackReference(matchLength);\n+                insertStringsInMatch(matchLength);\n                 lookahead -= matchLength;\n-                // inserts strings contained in current match\n-                for (int i = 0; i < matchLength - 1; i++) {\n-                    currentPosition++;\n-                    insertString();\n-                }\n-                currentPosition++;\n-                flushBackReference(matchLength);\n+                currentPosition += matchLength;\n                 blockStart = currentPosition;\n             } else {\n                 // no match, append to current or start a new literal\n      * <p>Updates <code>insertHash</code> and <code>prev</code> as a\n      * side effect.</p>\n      */\n-    private int insertString() {\n-        insertHash = nextHash(insertHash, window[currentPosition -1 + NUMBER_OF_BYTES_IN_HASH]);\n+    private int insertString(int pos) {\n+        insertHash = nextHash(insertHash, window[pos - 1 + NUMBER_OF_BYTES_IN_HASH]);\n         int hashHead = head[insertHash];\n         prev[currentPosition & wMask] = hashHead;\n-        head[insertHash] = currentPosition;\n+        head[insertHash] = pos;\n         return hashHead;\n     }\n \n+    private void insertStringsInMatch(int matchLength) {\n+        // inserts strings contained in current match\n+        // insertString inserts the byte 2 bytes after position, which may not yet be available -> missedInserts\n+        final int stop = Math.min(matchLength - 1, lookahead - NUMBER_OF_BYTES_IN_HASH);\n+        // currentPosition has been inserted already\n+        for (int i = 1; i <= stop; i++) {\n+            insertString(currentPosition + i);\n+        }\n+        missedInserts = matchLength - stop - 1;\n+    }\n+\n+    private void catchUpMissedInserts() {\n+        while (missedInserts > 0) {\n+            insertString(currentPosition - missedInserts--);\n+        }\n+    }\n+\n     private void flushBackReference(int matchLength) {\n-        callback.accept(new BackReference(matchStart, matchLength));\n+        callback.accept(new BackReference(currentPosition - matchStart, matchLength));\n     }\n \n     private void flushLiteralBlock() {\n         callback.accept(new LiteralBlock(window, blockStart, currentPosition - blockStart));\n     }\n \n+    /**\n+     * Searches the hash chain for real matches and returns the length\n+     * of the longest match (0 if none were found) that isn't too far\n+     * away (WRT maxOffset).\n+     *\n+     * <p>Sets matchStart to the index of the start position of the\n+     * longest match as a side effect.</p>\n+     */\n     private int longestMatch(int matchHead) {\n-        return 0;\n+        final int minLength = params.getMinMatchSize();\n+        int longestMatchLength = minLength - 1;\n+        final int maxPossibleLength = Math.min(params.getMaxMatchSize(), lookahead);\n+        final int minIndex = Math.max(0, currentPosition - params.getMaxOffset());\n+        while (matchHead >= minIndex) {\n+            int currentLength = 0;\n+            for (int i = 0; i < maxPossibleLength; i++) {\n+                if (window[matchHead + i] != window[currentPosition + i]) {\n+                    break;\n+                }\n+                currentLength++;\n+            }\n+            if (currentLength > longestMatchLength) {\n+                longestMatchLength = currentLength;\n+                matchStart = matchHead;\n+            }\n+            matchHead = prev[matchHead & wMask];\n+        }\n+        return longestMatchLength; // < minLength if no matches have been found, will be ignored in compress()\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/lz77support/LZ77CompressorTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/LZ77CompressorTest.java\n  */\n package org.apache.commons.compress.compressors.lz77support;\n \n+import java.io.UnsupportedEncodingException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import static org.junit.Assert.assertEquals;\n \n public class LZ77CompressorTest {\n+\n+    private static final byte[] BLA, SAM, ONE_TO_TEN;\n+\n+    static {\n+        try {\n+            /*\n+             * Example from \"An Explanation of the Deflate Algorithm\" by \"Antaeus Feldspar\".\n+             * @see \"http://zlib.net/feldspar.html\"\n+             */\n+            BLA = \"Blah blah blah blah blah!\".getBytes(\"ASCII\");\n+\n+            /*\n+             * Example from Wikipedia article about LZSS.\n+             * Note the example uses indices instead of offsets.\n+             * @see \"https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski\"\n+             */\n+            SAM = (\"I am Sam\\n\"\n+                   + \"\\n\"\n+                   + \"Sam I am\\n\"\n+                   + \"\\n\"\n+                   + \"That Sam-I-am!\\n\"\n+                   + \"That Sam-I-am!\\n\"\n+                   + \"I do not like\\n\"\n+                   + \"that Sam-I-am!\\n\"\n+                   + \"\\n\"\n+                   + \"Do you like green eggs and ham?\\n\"\n+                   + \"\\n\"\n+                   + \"I do not like them, Sam-I-am.\\n\"\n+                   + \"I do not like green eggs and ham.\").getBytes(\"ASCII\");\n+        } catch (UnsupportedEncodingException ex) {\n+            throw new RuntimeException(\"ASCII not supported\");\n+        }\n+        ONE_TO_TEN = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+    }\n \n     private List<LZ77Compressor.Block> compress(Parameters params, byte[]... chunks) {\n         final List<LZ77Compressor.Block> blocks = new ArrayList<>();\n         LZ77Compressor c = new LZ77Compressor(params, new LZ77Compressor.Callback() {\n                 @Override\n                 public void accept(LZ77Compressor.Block block) {\n+                    //System.err.println(block);\n                     if (block instanceof LZ77Compressor.LiteralBlock) {\n                         // replace with a real copy of data so tests\n                         // can see the results as they've been when\n \n     @Test\n     public void nonCompressableWithLengthSmallerThanLiteralMax() {\n-        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-        List<LZ77Compressor.Block> blocks = compress(new Parameters(128), data);\n-        assertEquals(2, blocks.size());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n-        assertArrayEquals(data, ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n-        assertEquals(LZ77Compressor.EOD.class, blocks.get(1).getClass());\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(128), ONE_TO_TEN);\n+        assertSize(2, blocks);\n+        assertLiteralBlock(ONE_TO_TEN, blocks.get(0));\n     }\n \n     @Test\n     public void nonCompressableWithLengthGreaterThanLiteralMaxButLessThanTwiceWindowSize() {\n-        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), data);\n-        assertEquals(3, blocks.size());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n-        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n-        assertArrayEquals(new byte[] { 9, 10 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n-        assertEquals(LZ77Compressor.EOD.class, blocks.get(2).getClass());\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), ONE_TO_TEN);\n+        assertSize(3, blocks);\n+        assertLiteralBlock(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, blocks.get(0));\n+        assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(1));\n     }\n \n     @Test\n     public void nonCompressableWithLengthThatForcesWindowSlide() {\n-        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-        List<LZ77Compressor.Block> blocks = compress(new Parameters(4), data);\n-        assertEquals(4, blocks.size());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n-        assertArrayEquals(new byte[] { 1, 2, 3, 4 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n-        assertArrayEquals(new byte[] { 5, 6, 7, 8 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(2).getClass());\n-        assertArrayEquals(new byte[] { 9, 10 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(2)).getData());\n-        assertEquals(LZ77Compressor.EOD.class, blocks.get(3).getClass());\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(4), ONE_TO_TEN);\n+        assertSize(4, blocks);\n+        assertLiteralBlock(new byte[] { 1, 2, 3, 4, }, blocks.get(0));\n+        assertLiteralBlock(new byte[] { 5, 6, 7, 8 }, blocks.get(1));\n+        assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(2));\n     }\n \n     @Test\n     public void nonCompressableSentAsSingleBytes() {\n-        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), new byte[][] {\n-                { 1 }, { 2 }, { 3 } , { 4 }, { 5 },\n-                { 6 }, { 7 }, { 8 } , { 9 }, { 10 },\n-            });\n-        assertEquals(3, blocks.size());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(0).getClass());\n-        assertArrayEquals(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(0)).getData());\n-        assertEquals(LZ77Compressor.LiteralBlock.class, blocks.get(1).getClass());\n-        assertArrayEquals(new byte[] { 9, 10 },\n-            ((LZ77Compressor.LiteralBlock) blocks.get(1)).getData());\n-        assertEquals(LZ77Compressor.EOD.class, blocks.get(2).getClass());\n-    }\n-\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), stagger(ONE_TO_TEN));\n+        assertSize(3, blocks);\n+        assertLiteralBlock(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }, blocks.get(0));\n+        assertLiteralBlock(new byte[] { 9, 10 }, blocks.get(1));\n+    }\n+\n+    @Test\n+    public void blaExampleWithFullArrayAvailableForCompression()\n+        throws UnsupportedEncodingException {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(128), BLA);\n+        assertSize(4, blocks);\n+        assertLiteralBlock(\"Blah b\", blocks.get(0));\n+        assertBackReference(5, 18, blocks.get(1));\n+        assertLiteralBlock(\"!\", blocks.get(2));\n+    }\n+\n+    @Test\n+    public void blaExampleWithShorterMatchLength() throws UnsupportedEncodingException {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(128, 3, 5, 0, 0), BLA);\n+        assertSize(7, blocks);\n+        assertLiteralBlock(\"Blah b\", blocks.get(0));\n+        assertBackReference(5, 5, blocks.get(1));\n+        assertBackReference(5, 5, blocks.get(2));\n+        assertBackReference(5, 5, blocks.get(3));\n+        assertBackReference(5, 3, blocks.get(4));\n+        assertLiteralBlock(\"!\", blocks.get(5));\n+    }\n+\n+    @Test\n+    public void blaExampleSmallerWindowSize() throws UnsupportedEncodingException {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(8), BLA);\n+        assertSize(5, blocks);\n+        assertLiteralBlock(\"Blah b\", blocks.get(0));\n+        assertEquals(LZ77Compressor.BackReference.class, blocks.get(1).getClass());\n+        assertBackReference(5, 8, blocks.get(1));\n+        assertBackReference(5, 8, blocks.get(2));\n+        assertLiteralBlock(\"ah!\", blocks.get(3));\n+    }\n+\n+    @Test\n+    public void blaExampleWithSingleByteWrites() throws UnsupportedEncodingException {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(128), stagger(BLA));\n+        assertEquals(9, blocks.size());\n+        assertLiteralBlock(\"Blah b\", blocks.get(0));\n+        assertBackReference(5, 3, blocks.get(1));\n+        assertBackReference(5, 3, blocks.get(2));\n+        assertBackReference(5, 3, blocks.get(3));\n+        assertBackReference(5, 3, blocks.get(4));\n+        assertBackReference(5, 3, blocks.get(5));\n+        assertBackReference(5, 3, blocks.get(6));\n+        assertLiteralBlock(\"!\", blocks.get(7));\n+    }\n+\n+    @Test\n+    public void samIAmExampleWithFullArrayAvailableForCompression() throws UnsupportedEncodingException {\n+        List<LZ77Compressor.Block> blocks = compress(new Parameters(1024), SAM);\n+        assertEquals(21, blocks.size());\n+        assertLiteralBlock(\"I am Sam\\n\\n\", blocks.get(0));\n+        assertBackReference(5, 3, blocks.get(1));\n+        assertLiteralBlock(\" \", blocks.get(2));\n+        assertBackReference(14, 4, blocks.get(3));\n+        assertLiteralBlock(\"\\n\\nThat\", blocks.get(4));\n+        assertBackReference(20, 4, blocks.get(5));\n+        assertLiteralBlock(\"-I-am!\", blocks.get(6));\n+        assertBackReference(15, 16, blocks.get(7));\n+        assertLiteralBlock(\"I do not like\\nt\", blocks.get(8));\n+        assertBackReference(29, 14, blocks.get(9));\n+        assertLiteralBlock(\"\\nDo you\", blocks.get(10));\n+        assertBackReference(28, 5, blocks.get(11));\n+        assertLiteralBlock(\" green eggs and ham?\\n\", blocks.get(12));\n+        assertBackReference(63, 14, blocks.get(13));\n+        assertLiteralBlock(\" them,\", blocks.get(14));\n+        assertBackReference(64, 9, blocks.get(15));\n+        assertLiteralBlock(\".\", blocks.get(16));\n+        assertBackReference(30, 15, blocks.get(17));\n+        assertBackReference(65, 18, blocks.get(18));\n+        assertLiteralBlock(\".\", blocks.get(19));\n+    }\n+\n+    private static final void assertSize(int expectedSize, List<LZ77Compressor.Block> blocks) {\n+        assertEquals(expectedSize, blocks.size());\n+        assertEquals(LZ77Compressor.EOD.class, blocks.get(expectedSize - 1).getClass());\n+    }\n+\n+    private static final void assertLiteralBlock(String expectedContent, LZ77Compressor.Block block)\n+        throws UnsupportedEncodingException {\n+        assertLiteralBlock(expectedContent.getBytes(\"ASCII\"), block);\n+    }\n+\n+    private static final void assertLiteralBlock(byte[] expectedContent, LZ77Compressor.Block block) {\n+        assertEquals(LZ77Compressor.LiteralBlock.class, block.getClass());\n+        assertArrayEquals(expectedContent, ((LZ77Compressor.LiteralBlock) block).getData());\n+    }\n+\n+    private static final void assertBackReference(int expectedOffset, int expectedLength, LZ77Compressor.Block block) {\n+        assertEquals(LZ77Compressor.BackReference.class, block.getClass());\n+        LZ77Compressor.BackReference b = (LZ77Compressor.BackReference) block;\n+        assertEquals(expectedOffset, b.getOffset());\n+        assertEquals(expectedLength, b.getLength());\n+    }\n+\n+    private static final byte[][] stagger(byte[] data) {\n+        byte[][] r = new byte[data.length][1];\n+        for (int i = 0; i < data.length; i++) {\n+            r[i][0] = data[i];\n+        }\n+        return r;\n+    }\n }", "timestamp": 1483808710, "metainfo": ""}