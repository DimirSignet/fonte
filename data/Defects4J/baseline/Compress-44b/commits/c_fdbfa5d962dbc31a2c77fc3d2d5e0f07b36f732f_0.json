{"sha": "fdbfa5d962dbc31a2c77fc3d2d5e0f07b36f732f", "log": "COMPRESS-375 Allow the deferred creation of `ZipArchiveEntry` for parallel zips  In some cases when creating parallel zip archive the `ZipArchiveEntry` to be added could not be created before the `InputStream` is read. In those cases there is no point in passing `ZipArchiveEntry` and `InputStreamSupplier` as you can't actually defer the creation of the `InputStream` as it's needed for the `ZipArchiveEntry`.  Add `ZipArchiveEntryRequestSupplier` to allow the deferred creation of both `ZipArchiveEntry` and `InputStream`.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n     }\n \n     /**\n+     * Adds an archive entry to this archive.\n+     * <p>\n+     * This method is expected to be called from a single client thread\n+     * </p>\n+     *\n+     * @param zipArchiveEntryRequestSupplier Should supply the entry to be added.\n+     * @since 1.13\n+     */\n+    public void addArchiveEntry(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n+        submit(createCallable(zipArchiveEntryRequestSupplier));\n+    }\n+\n+    /**\n      * Submit a callable for compression.\n      *\n      * @see ParallelScatterZipCreator#createCallable for details of if/when to use this.\n         };\n     }\n \n+    /**\n+     * Create a callable that will compress archive entry supplied by {@link ZipArchiveEntryRequestSupplier}.\n+     *\n+     * <p>This method is expected to be called from a single client thread.</p>\n+     *\n+     * The same as {@link #createCallable(ZipArchiveEntry, InputStreamSupplier)}, but the archive entry\n+     * to be added is supplied by a {@link ZipArchiveEntryRequestSupplier}.\n+     *\n+     * @see #createCallable(ZipArchiveEntry, InputStreamSupplier)\n+     *\n+     * @param zipArchiveEntryRequestSupplier Should supply the entry to be added.\n+     * @return A callable that should subsequently passed to #submit, possibly in a wrapped/adapted from. The\n+     * value of this callable is not used, but any exceptions happening inside the compression\n+     * will be propagated through the callable.\n+     * @since 1.13\n+     */\n+    public final Callable<Object> createCallable(final ZipArchiveEntryRequestSupplier zipArchiveEntryRequestSupplier) {\n+        return new Callable<Object>() {\n+            @Override\n+            public Object call() throws Exception {\n+                tlScatterStreams.get().addArchiveEntry(zipArchiveEntryRequestSupplier.get());\n+                return null;\n+            }\n+        };\n+    }\n \n     /**\n      * Write the contents this to the target {@link ZipArchiveOutputStream}.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequestSupplier.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.apache.commons.compress.parallel.InputStreamSupplier;\n+\n+import java.io.InputStream;\n+\n+/**\n+ * Supplies {@link ZipArchiveEntryRequest}.\n+ *\n+ * Implementations are required to support thread-handover. While an instance will\n+ * not be accessed concurrently by multiple threads, it will be called by\n+ * a different thread than it was created on.\n+ *\n+ * @since 1.13\n+ */\n+public interface ZipArchiveEntryRequestSupplier {\n+\n+    /**\n+     * Supply a {@link ZipArchiveEntryRequest} to be added to a parallel archive.\n+     * @return The {@link ZipArchiveEntryRequest} instance. Should never be null.\n+     */\n+    ZipArchiveEntryRequest get();\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n             final ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n-            zipCreator.addArchiveEntry(za, new InputStreamSupplier() {\n+            final InputStreamSupplier iss = new InputStreamSupplier() {\n                 @Override\n                 public InputStream get() {\n                     return new ByteArrayInputStream(payloadBytes);\n                 }\n-            });\n+            };\n+            if (i % 2 == 0) {\n+                zipCreator.addArchiveEntry(za, iss);\n+            } else {\n+                final ZipArchiveEntryRequestSupplier zaSupplier = new ZipArchiveEntryRequestSupplier() {\n+                    @Override\n+                    public ZipArchiveEntryRequest get() {\n+                        return ZipArchiveEntryRequest.createZipArchiveEntryRequest(za, iss);\n+                    }\n+                };\n+                zipCreator.addArchiveEntry(zaSupplier);\n+            }\n         }\n         return entries;\n     }\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n             final ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n-            final Callable<Object> callable = zipCreator.createCallable(za, new InputStreamSupplier() {\n+            final InputStreamSupplier iss = new InputStreamSupplier() {\n                 @Override\n                 public InputStream get() {\n                     return new ByteArrayInputStream(payloadBytes);\n                 }\n-            });\n+            };\n+            final Callable<Object> callable;\n+            if (i % 2 == 0) {\n+                callable = zipCreator.createCallable(za, iss);\n+            } else {\n+                final ZipArchiveEntryRequestSupplier zaSupplier = new ZipArchiveEntryRequestSupplier() {\n+                    @Override\n+                    public ZipArchiveEntryRequest get() {\n+                        return ZipArchiveEntryRequest.createZipArchiveEntryRequest(za, iss);\n+                    }\n+                };\n+                callable = zipCreator.createCallable(zaSupplier);\n+            }\n+\n             zipCreator.submit(callable);\n         }\n         return entries;", "timestamp": 1480850466, "metainfo": ""}