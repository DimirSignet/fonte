{"sha": "d8703230cc23d7c44c8ab694922ebc453144045f", "log": "Extract the 'search the archive backwards for a signature' logic so it can be reused to serach for the ZIP64 end of central directory locator  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n \n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT;\n \n /**\n  * Replacement for <code>java.util.ZipFile</code>.\n         /* zipfile comment length          */ + SHORT;\n \n     private static final int MAX_EOCD_SIZE = MIN_EOCD_SIZE\n-        /* maximum length of zipfile comment */ + 0xFFFF;\n+        /* maximum length of zipfile comment */ + ZIP64_MAGIC_SHORT;\n \n     private static final int CFD_LOCATOR_OFFSET =\n         /* end of central dir signature    */ WORD\n      */\n     private void positionAtCentralDirectory()\n         throws IOException {\n+        boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n+                                             ZipArchiveOutputStream.EOCD_SIG);\n+        if (!found) {\n+            throw new ZipException(\"archive is not a ZIP archive\");\n+        }\n+        archive.skipBytes(CFD_LOCATOR_OFFSET);\n+        byte[] cfdOffset = new byte[WORD];\n+        archive.readFully(cfdOffset);\n+        archive.seek(ZipLong.getValue(cfdOffset));\n+    }\n+\n+    /**\n+     * Searches the archive backwards from minDistance to maxDistance\n+     * for the given signature, positions the RandomaccessFile right\n+     * at the signature if it has been found.\n+     */\n+    private boolean tryToLocateSignature(long minDistanceFromEnd,\n+                                         long maxDistanceFromEnd,\n+                                         byte[] sig) throws IOException {\n         boolean found = false;\n-        long off = archive.length() - MIN_EOCD_SIZE;\n-        long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\n+        long off = archive.length() - minDistanceFromEnd;\n+        long stopSearching = Math.max(0L, archive.length() - maxDistanceFromEnd);\n         if (off >= 0) {\n             archive.seek(off);\n-            byte[] sig = ZipArchiveOutputStream.EOCD_SIG;\n             int curr = archive.read();\n             while (off >= stopSearching && curr != -1) {\n                 if (curr == sig[POS_0]) {\n                 curr = archive.read();\n             }\n         }\n-        if (!found) {\n-            throw new ZipException(\"archive is not a ZIP archive\");\n-        }\n-        archive.seek(off + CFD_LOCATOR_OFFSET);\n-        byte[] cfdOffset = new byte[WORD];\n-        archive.readFully(cfdOffset);\n-        archive.seek(ZipLong.getValue(cfdOffset));\n+        if (found) {\n+            archive.seek(off);\n+        }\n+        return found;\n     }\n \n     /**", "timestamp": 1312384615, "metainfo": ""}