{"sha": "af60df2bc3bd51c1a0f866b8106014be171b62e2", "log": "Cleaned up close semantics of backing store, made this governed by ScatterZipOutputStream  Also added a way to provide a custom supplier  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n     private List<ScatterZipOutputStream> streams = synchronizedList(new ArrayList<ScatterZipOutputStream>());\n     private List<ScatterGatherBackingStore> backingStores = synchronizedList(new ArrayList<ScatterGatherBackingStore>());\n     private final ExecutorService es;\n-    private final ScatterGatherBackingStoreSupplier defaultSupplier;\n+    private final ScatterGatherBackingStoreSupplier supplier;\n \n     private final long startedAt = System.currentTimeMillis();\n     private long compressionDoneAt = 0;\n         @Override\n         protected ScatterZipOutputStream initialValue() {\n             try {\n-                ScatterZipOutputStream scatterStream = createDeferred(defaultSupplier);\n+                ScatterZipOutputStream scatterStream = createDeferred(supplier);\n                 streams.add(scatterStream);\n                 return scatterStream;\n             } catch (IOException e) {\n      * @param nThreads the number of threads to use in parallel.\n      */\n     public ParallelScatterZipCreator(int nThreads) {\n-        defaultSupplier = new DefaultSupplier();\n+        this( nThreads, new DefaultSupplier());\n+    }\n+\n+    /**\n+     * Create a ParallelScatterZipCreator\n+     *\n+     * @param nThreads the number of threads to use in parallel.\n+     * @param backingStoreSupplier The supplier of backing store which shall be used\n+     */\n+    public ParallelScatterZipCreator(int nThreads, ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n+        supplier = backingStoreSupplier;\n         es = Executors.newFixedThreadPool(nThreads);\n     }\n \n \n         for (ScatterZipOutputStream scatterStream : streams) {\n             scatterStream.writeTo(targetStream);\n+            scatterStream.close();\n         }\n \n         scatterDoneAt = System.currentTimeMillis();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n \n import org.apache.commons.compress.utils.BoundedInputStream;\n \n+import java.io.Closeable;\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n  *\n  * @since 1.10\n  */\n-public class ScatterZipOutputStream  {\n+public class ScatterZipOutputStream implements Closeable {\n     private final Queue<CompressedEntry> items = new ConcurrentLinkedQueue<CompressedEntry>();\n     private final ScatterGatherBackingStore backingStore;\n     private final StreamCompressor streamCompressor;\n         data.close();\n     }\n \n+\n+    /**\n+     * Closes this stream, freeing all resources involved in the creation of this stream.\n+     * @throws IOException If closing fails\n+     */\n+    public void close() throws IOException {\n+        backingStore.close();\n+    }\n+\n     /**\n      * Create a ScatterZipOutputStream with default compression level that is backed by a file\n      *\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n         ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target);\n         scatterZipOutputStream.writeTo( outputStream);\n         outputStream.close();\n+        scatterZipOutputStream.close();\n \n         ZipFile zf = new ZipFile(target);\n         final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();", "timestamp": 1420278526, "metainfo": ""}