{"sha": "eb016437c84bc88e634eae8bea16552702484ed4", "log": "Zip64Mode.Never was still creating extra fields for entries of unknown size when writing to a file.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         if (entry.entry.getSize() >= ZIP64_MAGIC\n             || entry.entry.getCompressedSize() >= ZIP64_MAGIC\n             || (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n-                && raf != null)) {\n+                && raf != null\n+                && zip64Mode != Zip64Mode.Never)) {\n \n             Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n             if (entry.entry.getMethod() == STORED\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n \n     @Test public void writeBigStoredEntryUnnownSizeToFileModeNever()\n         throws Throwable {\n-        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFileModeNever\",\n                              writeBigStoredEntryModeNever(false),\n                              true);\n     }\n      * Creates a temporary archive of approx 1MB in size\n      */\n     private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize) {\n+        return writeSmallStoredEntry(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    private static ZipOutputTest writeSmallStoredEntry(final boolean knownSize,\n+                                                       final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n                 byte[] buf = new byte[ONE_MILLION];\n                 ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n \n                     // and now validate local file header: this one\n                     // has a ZIP64 extra field if and only if size was\n-                    // unknown\n+                    // unknown and mode was not Never or the mode was\n+                    // Always (regardless of size)\n+                    boolean hasExtra = mode == Zip64Mode.Always\n+                        || (mode == Zip64Mode.AsNeeded && !knownSize);\n                     a.seek(0);\n                     header = new byte[10];\n                     a.readFully(header);\n                             // file name length\n                             1, 0,\n                             // extra field length\n-                            (byte) (knownSize ? 0 : 20), 0,\n+                            (byte) (!hasExtra ? 0 : 20), 0,\n                             // file name\n                             (byte) '0'\n                         }, rest);\n-                    if (!knownSize) {\n+                    if (hasExtra) {\n                         byte[] extra = new byte[20];\n                         a.readFully(extra);\n                         assertArrayEquals(new byte[] {\n                              true);\n     }\n \n-    /*\n-     * One entry of length 1 million bytes, written with compression\n-     * to a stream.\n-     *\n-     * Compression + Stream => sizes are set to 0 in LFH, real values\n-     * are inside the data descriptor.  No ZIP64 extra field at all.\n-     */\n-    @Test public void writeSmallDeflatedEntryKnownSizeToStream()\n-        throws Throwable {\n-        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\",\n-                             new ZipOutputTest() {\n+    @Test public void writeSmallStoredEntryToStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryToStreamModeNever\",\n+                             writeSmallStoredEntry(true, Zip64Mode.Never),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallStoredEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryKnownSizeToFileModeNever\",\n+                             writeSmallStoredEntry(true, Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallStoredEntryUnnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallStoredEntryUnknownSizeToFileModeNever\",\n+                             writeSmallStoredEntry(false, Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryKnownSizeToStream(final Zip64Mode mode) {\n+        return new ZipOutputTest() {\n                                  public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n                                      byte[] buf = new byte[ONE_MILLION];\n                                      ZipArchiveEntry zae =\n                                          new ZipArchiveEntry(\"0\");\n                                                  // file name length\n                                                  1, 0,\n                                                  // extra field length\n-                                                 0, 0,\n+                                                 mode == Zip64Mode.Always\n+                                                 ? (byte) 20 : 0,\n+                                                 0,\n                                                  // file name\n                                                  (byte) '0'\n                                              }, rest);\n+                    if (mode == Zip64Mode.Always) {\n+                        byte[] extra = new byte[20];\n+                        a.readFully(extra);\n+                        assertArrayEquals(new byte[] {\n+                                // Header-ID\n+                                1, 0,\n+                                // size of extra\n+                                16, 0,\n+                                // original size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                                // compressed size\n+                                (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n+                                0, 0, 0, 0,\n+                            }, extra);\n+                    }\n+\n                                      } finally {\n                                          a.close();\n                                      }\n                                  }\n-                             },\n+        };\n+\n+    }\n+\n+    /*\n+     * One entry of length 1 million bytes, written with compression\n+     * to a stream.\n+     *\n+     * Compression + Stream => sizes are set to 0 in LFH, real values\n+     * are inside the data descriptor.  No ZIP64 extra field at all.\n+     */\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStream()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStream\",\n+                             writeSmallDeflatedEntryKnownSizeToStream(Zip64Mode\n+                                                                      .AsNeeded),\n+                             false);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToStreamModeNever\",\n+                             writeSmallDeflatedEntryKnownSizeToStream(Zip64Mode\n+                                                                      .Never),\n                              false);\n     }\n \n      * field if size was known.\n      */\n     private static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize) {\n+        return writeSmallDeflatedEntryToFile(knownSize, Zip64Mode.AsNeeded);\n+    }\n+\n+    private static ZipOutputTest\n+        writeSmallDeflatedEntryToFile(final boolean knownSize,\n+                                      final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             public void test(File f, ZipArchiveOutputStream zos)\n                 throws IOException {\n+                if (mode != Zip64Mode.AsNeeded) {\n+                    zos.setUseZip64(mode);\n+                }\n                 byte[] buf = new byte[ONE_MILLION];\n                 ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     a.skipBytes(4);\n                     rest = new byte[9];\n                     a.readFully(rest);\n+\n+                    boolean hasExtra = mode == Zip64Mode.Always\n+                        || (mode == Zip64Mode.AsNeeded && !knownSize);\n+\n                     assertArrayEquals(new byte[] {\n                             // Original Size\n                             (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0,\n                             // file name length\n                             1, 0,\n                             // extra field length\n-                            (byte) (knownSize ? 0 : 20), 0,\n+                            (byte) (!hasExtra ? 0 : 20), 0,\n                             // file name\n                             (byte) '0'\n                         }, rest);\n-                    if (!knownSize) {\n+                    if (hasExtra) {\n                         byte[] extra = new byte[12];\n                         a.readFully(extra);\n                         assertArrayEquals(new byte[] {\n         throws Throwable {\n         withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFile\",\n                              writeSmallDeflatedEntryToFile(false),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryKnownSizeToFileModeNever\",\n+                             writeSmallDeflatedEntryToFile(true,\n+                                                           Zip64Mode.Never),\n+                             true);\n+    }\n+\n+    @Test public void writeSmallDeflatedEntryUnknownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeSmallDeflatedEntryUnknownSizeToFileModeNever\",\n+                             writeSmallDeflatedEntryToFile(false,\n+                                                           Zip64Mode.Never),\n                              true);\n     }\n ", "timestamp": 1312885956, "metainfo": ""}