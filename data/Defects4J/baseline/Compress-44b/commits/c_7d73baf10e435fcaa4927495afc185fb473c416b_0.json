{"sha": "7d73baf10e435fcaa4927495afc185fb473c416b", "log": "COMPRESS-382 and COMPRESS-386 -- add memoryLimit to CompressorStreamFactory and ZCompressorInputStream and LZMACompressorInputStream", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorMemoryLimitException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+/**\n+ * If a stream checks for estimated memory allocation, and the estimate\n+ * goes above the memory limit, this is thrown.\n+ *\n+ * @since 1.14\n+ */\n+public class CompressorMemoryLimitException extends CompressorException {\n+\n+    public CompressorMemoryLimitException(String message) {\n+        super(message);\n+    }\n+\n+    public CompressorMemoryLimitException(String message, Exception e) {\n+        super(message, e);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.utils.Lists;\n import org.apache.commons.compress.utils.ServiceLoaderIterator;\n import org.apache.commons.compress.utils.Sets;\n+import org.tukaani.xz.MemoryLimitException;\n \n /**\n  * <p>\n      */\n     private volatile boolean decompressConcatenated = false;\n \n+    private final int memoryLimitInKb;\n     /**\n      * Create an instance with the decompress Concatenated option set to false.\n      */\n     public CompressorStreamFactory() {\n         this.decompressUntilEOF = null;\n-    }\n+        this.memoryLimitInKb = -1;\n+    }\n+\n+    /**\n+     * Create an instance with the provided decompress Concatenated option.\n+     *\n+     * @param decompressUntilEOF\n+     *            if true, decompress until the end of the input; if false, stop\n+     *            after the first stream and leave the input position to point\n+     *            to the next byte after the stream. This setting applies to the\n+     *            gzip, bzip2 and xz formats only.\n+     *\n+     * @param memoryLimitInKb\n+     *            Some streams require allocation of potentially significant\n+     *            byte arrays/tables, and they can offer checks to prevent OOMs\n+     *            on corrupt files.  Set the maximum allowed memory allocation in KBs.\n+     *\n+     * @since 1.14\n+     */\n+    public CompressorStreamFactory(final boolean decompressUntilEOF, final int memoryLimitInKb) {\n+        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n+        // Also copy to existing variable so can continue to use that as the\n+        // current value\n+        this.decompressConcatenated = decompressUntilEOF;\n+        this.memoryLimitInKb = memoryLimitInKb;\n+    }\n+\n \n     /**\n      * Create an instance with the provided decompress Concatenated option.\n      * @since 1.10\n      */\n     public CompressorStreamFactory(final boolean decompressUntilEOF) {\n-        this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n-        // Also copy to existing variable so can continue to use that as the\n-        // current value\n-        this.decompressConcatenated = decompressUntilEOF;\n+        this(decompressUntilEOF, -1);\n     }\n \n     /**\n                 if (!LZMAUtils.isLZMACompressionAvailable()) {\n                     throw new CompressorException(\"LZMA compression is not available\");\n                 }\n-                return new LZMACompressorInputStream(in);\n+                try {\n+                    return new LZMACompressorInputStream(in, memoryLimitInKb);\n+                } catch (MemoryLimitException e) {\n+                    throw new CompressorMemoryLimitException(\"exceeded calculated memory limit\", e);\n+                }\n             }\n \n             if (PACK200.equalsIgnoreCase(name)) {\n             }\n \n             if (Z.equalsIgnoreCase(name)) {\n-                return new ZCompressorInputStream(in);\n+                try {\n+                    return new ZCompressorInputStream(in, memoryLimitInKb);\n+                } catch (ZCompressorInputStream.IOExceptionWrappingMemoryLimitException e) {\n+                    throw new CompressorMemoryLimitException(e.getMessage());\n+                }\n             }\n \n             if (DEFLATE.equalsIgnoreCase(name)) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n      *\n      * @param       inputStream where to read the compressed data\n      *\n-     * @param       memoryLimitKb calculated memory use threshold.  Throws MemoryLimitException\n+     * @param       memoryLimitInKb calculated memory use threshold.  Throws MemoryLimitException\n      *                            if calculate memory use is above this threshold\n      *\n      * @throws      IOException if the input is not in the .lzma format,\n      *\n      * @since 1.14\n      */\n-    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitKb)\n+    public LZMACompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n             throws IOException {\n-        in = new LZMAInputStream(inputStream, memoryLimitKb);\n+        in = new LZMAInputStream(inputStream, memoryLimitInKb);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n import java.nio.ByteOrder;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.compressors.CompressorMemoryLimitException;\n import org.apache.commons.compress.utils.BitInputStream;\n \n /**\n     /**\n      * Initializes the arrays based on the maximum code size.\n      * @param maxCodeSize maximum code size\n+     * @param memoryLimitInKb maximum allowed table size in Kb\n+     * @throws CompressorMemoryLimitException if maxTableSize is > memoryLimitInKb\n+     */\n+    protected void initializeTables(final int maxCodeSize, final int memoryLimitInKb)\n+            throws CompressorMemoryLimitException {\n+        final int maxTableSize = 1 << maxCodeSize;\n+        if (memoryLimitInKb > -1 && maxTableSize > memoryLimitInKb*1024) {\n+            throw new CompressorMemoryLimitException(\"Tried to allocate \"+maxTableSize +\n+                    \" but memoryLimitInKb only allows \"+(memoryLimitInKb*1024));\n+        }\n+        initializeTables(maxCodeSize);\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n+     * @param maxCodeSize maximum code size\n      */\n     protected void initializeTables(final int maxCodeSize) {\n         final int maxTableSize = 1 << maxCodeSize;\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n import java.io.InputStream;\n import java.nio.ByteOrder;\n \n+import org.apache.commons.compress.compressors.CompressorMemoryLimitException;\n import org.apache.commons.compress.compressors.lzw.LZWInputStream;\n \n /**\n     private final boolean blockMode;\n     private final int maxCodeSize;\n     private long totalCodesRead = 0;\n-    \n-    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+\n+    public ZCompressorInputStream(final InputStream inputStream, int memoryLimitInKb)\n+            throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         final int firstByte = (int) in.readBits(8);\n         final int secondByte = (int) in.readBits(8);\n         if (blockMode) {\n             setClearCode(DEFAULT_CODE_SIZE);\n         }\n-        initializeTables(maxCodeSize);\n+        try {\n+            initializeTables(maxCodeSize, memoryLimitInKb);\n+        } catch (CompressorMemoryLimitException e) {\n+            throw new IOExceptionWrappingMemoryLimitException(e.getMessage());\n+        }\n         clearEntries();\n+    }\n+\n+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n+        this(inputStream, -1);\n     }\n     \n     private void clearEntries() {\n         return length > 3 && signature[0] == MAGIC_1 && signature[1] == (byte) MAGIC_2;\n     }\n \n+    /**\n+     * Wrapper that subclasses IOException to wrap a MemoryLimitException\n+     */\n+    public static class IOExceptionWrappingMemoryLimitException extends IOException {\n+        public IOExceptionWrappingMemoryLimitException(String message) {\n+            super(message);\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n         assertEquals(CompressorStreamFactory.SNAPPY_FRAMED, detect(\"bla.tar.sz\"));\n         assertEquals(CompressorStreamFactory.Z, detect(\"bla.tar.Z\"));\n \n+        //make sure we don't oom on detect\n+        assertEquals(CompressorStreamFactory.Z, detect(\"COMPRESS-386\"));\n+        assertEquals(CompressorStreamFactory.LZMA, detect(\"COMPRESS-382\"));\n+\n         try {\n             CompressorStreamFactory.detect(new BufferedInputStream(new ByteArrayInputStream(new byte[0])));\n             fail(\"shouldn't be able to detect empty stream\");\n         }\n         return name;\n     }\n+\n+    @Test\n+    public void testMemoryLimit() throws Exception {\n+        testMemoryLimit(\"COMPRESS-382\");\n+        testMemoryLimit(\"COMPRESS-386\");\n+    }\n+\n+    private void testMemoryLimit(String fileName) throws IOException, CompressorException {\n+        CompressorStreamFactory fac = new CompressorStreamFactory(true,\n+                100);\n+        try (InputStream is = new BufferedInputStream(\n+                new FileInputStream(getFile(fileName)))) {\n+            InputStream compressorInputStream = fac.createCompressorInputStream(is);\n+            fail(\"Should have thrown CompressorMemoryLimitException\");\n+        } catch (CompressorMemoryLimitException e) {\n+\n+        }\n+\n+    }\n+\n \n     @Test\n     public void testOverride() {", "timestamp": 1492816902, "metainfo": ""}