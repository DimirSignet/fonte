{"sha": "dfbdfee5deba0c2ad7af93018abda50d13721fe8", "log": "parse central directory part of extra fields.  SANDBOX-292  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n         data = null;\n     }\n \n+    /**\n+     * Doesn't do anything special since this class always uses the\n+     * same data in central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n+                                              int length)\n+        throws ZipException {\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n     }\n \n     /**\n+     * Doesn't do anything special since this class always uses the\n+     * same data in central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n+                                              int length)\n+        throws ZipException {\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n+\n+    /**\n      * Get the file mode for given permissions with the correct file type.\n      * @param mode the mode\n      * @return the type with the mode\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n \n     /**\n      * Split the array into ExtraFields and populate them with the\n-     * give data.\n-     * @param data an array of bytes\n+     * given data as local file data.\n+     * @param data an array of bytes as it appears in local file data\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      */\n     public static ZipExtraField[] parse(byte[] data) throws ZipException {\n+        return parse(data, true);\n+    }\n+\n+    /**\n+     * Split the array into ExtraFields and populate them with the\n+     * given data.\n+     * @param data an array of bytes\n+     * @param local whether data originates from the local file data\n+     * or the central directory\n+     * @return an array of ExtraFields\n+     * @throws ZipException on error\n+     */\n+    public static ZipExtraField[] parse(byte[] data, boolean local)\n+        throws ZipException {\n         List v = new ArrayList();\n         int start = 0;\n         while (start <= data.length - WORD) {\n             }\n             try {\n                 ZipExtraField ze = createExtraField(headerId);\n-                ze.parseFromLocalFileData(data, start + WORD, length);\n+                if (local) {\n+                    ze.parseFromLocalFileData(data, start + WORD, length);\n+                } else {\n+                    ze.parseFromCentralDirectoryData(data, start + WORD,\n+                                                     length);\n+                }\n                 v.add(ze);\n             } catch (InstantiationException ie) {\n                 throw new ZipException(ie.getMessage());\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n             throw new ZipException(\"JarMarker doesn't expect any data\");\n         }\n     }\n+\n+    /**\n+     * Doesn't do anything special since this class always uses the\n+     * same data in central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n+                                              int length)\n+        throws ZipException {\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n         setLocalFileDataData(tmp);\n     }\n \n+    /**\n+     * @param data the array of bytes.\n+     * @param offset the source location in the data array.\n+     * @param length the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset,\n+                                              int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+        if (localData == null) {\n+            setLocalFileDataData(tmp);\n+        }\n+    }\n+\n     private static byte[] copy(byte[] from) {\n         if (from != null) {\n             byte[] to = new byte[from.length];\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     public void setExtra(byte[] extra) throws RuntimeException {\n         try {\n-            setExtraFields(ExtraFieldUtils.parse(extra));\n+            ZipExtraField[] local = ExtraFieldUtils.parse(extra, true);\n+            mergeExtraFields(local, true);\n         } catch (Exception e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n      */\n     protected void setExtra() {\n         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n+    }\n+\n+    /**\n+     * Sets the central directory part of extra fields.\n+     */\n+    public void setCentralDirectoryExtra(byte[] b) {\n+        try {\n+            ZipExtraField[] central = ExtraFieldUtils.parse(b, false);\n+            mergeExtraFields(central, false);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n     }\n \n     /**\n         return (this == o);\n     }\n \n+    /**\n+     * If there are no extra fields, use the given fields as new extra\n+     * data - otherwise merge the fields assuming the existing fields\n+     * and the new fields stem from different locations inside the\n+     * archive.\n+     * @param f the extra fields to merge\n+     * @param local whether the new fields originate from local data\n+     */\n+    private void mergeExtraFields(ZipExtraField[] f, boolean local)\n+        throws ZipException {\n+        if (extraFields == null) {\n+            setExtraFields(f);\n+        } else {\n+            for (int i = 0; i < f.length; i++) {\n+                ZipExtraField existing = getExtraField(f[i].getHeaderId());\n+                if (existing == null) {\n+                    addExtraField(f[i]);\n+                } else {\n+                    if (local) {\n+                        byte[] b = f[i].getLocalFileDataData();\n+                        existing.parseFromLocalFileData(b, 0, b.length);\n+                    } else {\n+                        byte[] b = f[i].getCentralDirectoryData();\n+                        existing.parseFromCentralDirectoryData(b, 0, b.length);\n+                    }\n+                }\n+            }\n+            setExtra();\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipExtraField.java\n  * to be. {@link java.util.zip.ZipOutputStream java.util.zip.ZipOutputStream}\n  * will only use the local file data in both places.</p>\n  */\n-public interface ZipExtraField\n-{\n+public interface ZipExtraField {\n     /**\n      * The Header-ID.\n      *\n      * @param length the length of data\n      * @exception ZipException on error\n      */\n-    void parseFromLocalFileData( byte[] buffer, int offset, int length )\n+    void parseFromLocalFileData(byte[] buffer, int offset, int length)\n+        throws ZipException;\n+\n+    /**\n+     * Populate data from this array as if it was in central directory data.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n+     * @exception ZipException on error\n+     */\n+    void parseFromCentralDirectoryData(byte[] buffer, int offset, int length)\n         throws ZipException;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n \n             nameMap.put(ze.getName(), ze);\n \n-            int lenToSkip = extraLen;\n-            while (lenToSkip > 0) {\n-                int skipped = archive.skipBytes(lenToSkip);\n-                if (skipped <= 0) {\n-                    throw new RuntimeException(\"failed to skip extra data in\"\n-                                               + \" central directory\");\n-                }\n-                lenToSkip -= skipped;\n-            }\n+            byte[] cdExtraData = new byte[extraLen];\n+            archive.readFully(cdExtraData);\n+            ze.setCentralDirectoryExtra(cdExtraData);\n \n             byte[] comment = new byte[commentLen];\n             archive.readFully(comment);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n         }\n     }\n \n+    /*\n+     * WinZIP created archive, uses Unicode Extra Fields but only in\n+     * the central directory.\n+     */\n+    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n+        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n+        File archive = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(archive, null, true);\n+            assertNotNull(zf.getEntry(ASCII_TXT));\n+            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n+            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n     public void testZipFileReadsUnicodeFields() throws IOException {\n         File file = File.createTempFile(\"unicode-test\", \".zip\");\n         ZipFile zf = null;\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n \n     /**\n      * test handling of extra fields\n-     *\n-     * @since 1.1\n      */\n     public void testExtraFields() {\n         AsiExtraField a = new AsiExtraField();\n     }\n \n     /**\n+     * test handling of extra fields via central directory\n+     */\n+    public void testExtraFieldMerging() {\n+        AsiExtraField a = new AsiExtraField();\n+        a.setDirectory(true);\n+        a.setMode(0755);\n+        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        u.setHeaderId(new ZipShort(1));\n+        u.setLocalFileDataData(new byte[0]);\n+\n+        ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n+        ze.setExtraFields(new ZipExtraField[] {a, u});\n+\n+        // merge\n+        // Header-ID 1 + length 1 + one byte of data\n+        ze.setCentralDirectoryExtra(new byte[] {1, 0, 1, 0, 127});\n+\n+        ZipExtraField[] result = ze.getExtraFields();\n+        assertEquals(\"first pass\", 2, result.length);\n+        assertSame(a, result[0]);\n+        assertEquals(new ZipShort(1), result[1].getHeaderId());\n+        assertEquals(new ZipShort(0), result[1].getLocalFileDataLength());\n+        assertEquals(new ZipShort(1), result[1].getCentralDirectoryLength());\n+\n+        // add new\n+        // Header-ID 2 + length 0\n+        ze.setCentralDirectoryExtra(new byte[] {2, 0, 0, 0});\n+\n+        result = ze.getExtraFields();\n+        assertEquals(\"second pass\", 3, result.length);\n+\n+        // merge\n+        // Header-ID 2 + length 1 + one byte of data\n+        ze.setExtra(new byte[] {2, 0, 1, 0, 127});\n+\n+        result = ze.getExtraFields();\n+        assertEquals(\"third pass\", 3, result.length);\n+        assertSame(a, result[0]);\n+        assertEquals(new ZipShort(2), result[2].getHeaderId());\n+        assertEquals(new ZipShort(1), result[2].getLocalFileDataLength());\n+        assertEquals(new ZipShort(0), result[2].getCentralDirectoryLength());\n+    }\n+\n+    /**\n      * test handling of extra fields\n-     *\n-     * @since 1.1\n      */\n     public void testAddAsFirstExtraField() {\n         AsiExtraField a = new AsiExtraField();", "timestamp": 1236084148, "metainfo": ""}