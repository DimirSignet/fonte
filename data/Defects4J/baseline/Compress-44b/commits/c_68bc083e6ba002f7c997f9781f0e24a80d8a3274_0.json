{"sha": "68bc083e6ba002f7c997f9781f0e24a80d8a3274", "log": "COMPRESS-271 support for skipping skippable frames in lz4", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n     /*\n      * TODO before releasing 1.14:\n      *\n-     * + skippable frames\n      * + block dependence\n      */\n \n     static final byte[] LZ4_SIGNATURE = new byte[] { //NOSONAR\n         4, 0x22, 0x4d, 0x18\n     };\n+    private static final byte[] SKIPPABLE_FRAME_TRAILER = new byte[] {\n+        0x2a, 0x4d, 0x18\n+    };\n+    private static final byte SKIPPABLE_FRAME_PREFIX_BYTE_MASK = 0x50;\n \n     static final int VERSION_MASK = 0xC0;\n     static final int SUPPORTED_VERSION = 0x40;\n     }\n \n     private boolean readSignature(boolean firstFrame) throws IOException {\n+        String garbageMessage = firstFrame ? \"Not a LZ4 frame stream\" : \"LZ4 frame stream followed by garbage\";\n         final byte[] b = new byte[4];\n-        final int read = IOUtils.readFully(in, b);\n+        int read = IOUtils.readFully(in, b);\n         count(read);\n-        if (4 != read && !firstFrame) {\n+        if (0 == read && !firstFrame) {\n             endReached = true;\n             return false;\n         }\n+        if (4 != read) {\n+            throw new IOException(garbageMessage);\n+        }\n+\n+        read = skipSkippableFrame(b);\n+        if (0 == read && !firstFrame) {\n+            endReached = true;\n+            return false;\n+        }\n         if (4 != read || !matches(b, 4)) {\n-            throw new IOException(\"Not a LZ4 frame stream\");\n+            throw new IOException(garbageMessage);\n         }\n         return true;\n     }\n         }\n     }\n \n+    private static boolean isSkippableFrameSignature(byte[] b) {\n+        if ((b[0] & SKIPPABLE_FRAME_PREFIX_BYTE_MASK) != SKIPPABLE_FRAME_PREFIX_BYTE_MASK) {\n+            return false;\n+        }\n+        for (int i = 1; i < 4; i++) {\n+            if (b[i] != SKIPPABLE_FRAME_TRAILER[i - 1]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Skips over the contents of a skippable frame as well as\n+     * skippable frames following it.\n+     *\n+     * <p>It then tries to read four more bytes which are supposed to\n+     * hold an LZ4 signature and returns the number of bytes read\n+     * while storing the bytes in the given array.</p>\n+     */\n+    private int skipSkippableFrame(byte[] b) throws IOException {\n+        int read = 4;\n+        while (read == 4 && isSkippableFrameSignature(b)) {\n+            long len = ByteUtils.fromLittleEndian(supplier, 4);\n+            long skipped = IOUtils.skip(in, len);\n+            count(skipped);\n+            if (len != skipped) {\n+                throw new IOException(\"Premature end of stream while skipping frame\");\n+            }\n+            read = IOUtils.readFully(in, b);\n+            count(read);\n+        }\n+        return read;\n+    }\n+\n     /**\n      * Checks if the signature matches what is expected for a .lz4 file.\n      *\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n         }\n     }\n \n+    @Test\n+    public void skipsOverSkippableFrames() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x5f, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            1, 0, 0, (byte) 0x80, // 1 bytes length and uncompressed bit set\n+            '!', // content\n+            0, 0, 0, 0, // empty block marker\n+        };\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(new byte[] {\n+                    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '!'\n+                }, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void skipsOverTrailingSkippableFrames() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x51, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+        };\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(new byte[] {\n+                    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!'\n+                }, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameFollowedByJunk() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x50, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            1, 0x22, 0x4d, 0x18, // bad signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameFollowedByTooFewBytes() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x52, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            4, // too short for signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithPrematureEnd() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x50, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, // content of skippable frame (should be two bytes)\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"Premature end of stream while skipping frame\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithPrematureEndInLengthBytes() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x55, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, // should be four byte length\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"premature end of data\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithBadSignatureTrailer() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x51, 0x2a, 0x4d, 0x17, // broken skippable frame signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithBadSignaturePrefix() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x60, 0x2a, 0x4d, 0x18, // broken skippable frame signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsTrailingBytesAfterValidFrame() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x56, 0x2a, 0x4d, // too short for any signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n     interface StreamWrapper {\n         InputStream wrap(InputStream in) throws Exception;\n     }", "timestamp": 1486304437, "metainfo": ""}