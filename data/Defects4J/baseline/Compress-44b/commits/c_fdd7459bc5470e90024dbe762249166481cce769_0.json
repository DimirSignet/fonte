{"sha": "fdd7459bc5470e90024dbe762249166481cce769", "log": "[CVE-2012-2098] add fallback sorting algorithm of libbzip2 1.0.6 (actually added with 0.9.5)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n  * under the License.\n  */\n package org.apache.commons.compress.compressors.bzip2;\n+\n+import java.util.BitSet;\n \n /**\n  * Encapsulates the Burrows-Wheeler sorting algorithm needed by {@link\n     /*\n      * 2012-05-20 Stefan Bodewig:\n      *\n-     * The class seems to mix several revisions of libbzip2's code.\n+     * This class seems to mix several revisions of libbzip2's code.\n      * The mainSort function and those used by it look closer to the\n      * 0.9.5 version but show some variations introduced later.  At\n      * the same time the logic to randomize the block on bad input has\n      * been dropped after 0.9.0 and replaced by a fallback sorting\n      * algorithm.\n+     *\n+     * I've added the fallbackSort function of 1.0.6.\n      */\n \n     /*\n      */\n     private static final int QSORT_STACK_SIZE = 1000;\n \n+    private static final int FALLBACK_QSORT_STACK_SIZE = 100;\n+\n+    private static final int STACK_SIZE =\n+        QSORT_STACK_SIZE < FALLBACK_QSORT_STACK_SIZE\n+        ? FALLBACK_QSORT_STACK_SIZE : QSORT_STACK_SIZE;\n+\n     private boolean blockRandomised;\n \n     /*\n     private int workLimit;\n     private boolean firstAttempt;\n \n-    private final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte\n-    private final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte\n+    private final int[] stack_ll = new int[STACK_SIZE]; // 4000 byte\n+    private final int[] stack_hh = new int[STACK_SIZE]; // 4000 byte\n     private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte\n \n     private final int[] mainSort_runningOrder = new int[256]; // 1024 byte\n \n         // assert (data.origPtr != -1) : data.origPtr;\n         return blockRandomised;\n+    }\n+\n+/*---------------------------------------------*/\n+\n+/*---------------------------------------------*/\n+/*--- LBZ2: Fallback O(N log(N)^2) sorting        ---*/\n+/*--- algorithm, for repetitive blocks      ---*/\n+/*---------------------------------------------*/\n+\n+    /*\n+     * This is the fallback sorting algorithm libbzip2 1.0.6 uses for\n+     * repetitive or very short inputs.\n+     *\n+     * The idea is inspired by Manber-Myers string suffix sorting\n+     * algorithm.  First a bucket sort places each permutation of the\n+     * block into a bucket based on its first byte.  Permutations are\n+     * represented by pointers to their first character kept in\n+     * (partially) sorted order inside the array ftab.\n+     *\n+     * The next step visits all buckets in order and performs a\n+     * quicksort on all permutations of the bucket based on the index\n+     * of the bucket the second byte of the permutation belongs to,\n+     * thereby forming new buckets.  When arrived here the\n+     * permutations are sorted up to the second character and we have\n+     * buckets of permutations that are identical up to two\n+     * characters.\n+     *\n+     * Repeat the step of quicksorting each bucket, now based on the\n+     * bucket holding the sequence of the third and forth character\n+     * leading to four byte buckets.  Repeat this doubling of bucket\n+     * sizes until all buckets only contain single permutations or the\n+     * bucket size exceeds the block size.\n+     *\n+     * I.e.\n+     *\n+     * \"abraba\" form three buckets for the chars \"a\", \"b\", and \"r\" in\n+     * the first step with\n+     *\n+     * fmap = { 'a:' 5, 3, 0, 'b:' 4, 1, 'r', 2 }\n+     *\n+     * when looking at the bucket of \"a\"s the second characters are in\n+     * the buckets that start with fmap-index 0 (rolled over), 3 and 3\n+     * respectively, forming two new buckets \"aa\" and \"ab\", so we get\n+     *\n+     * fmap = { 'aa:' 5, 'ab:' 3, 0, 'ba:' 4, 'br': 1, 'ra:' 2 }\n+     *\n+     * since the last bucket only contained a single item it didn't\n+     * have to be sorted at all.\n+     *\n+     * There now is just one bucket with more than one permutation\n+     * that remains to be sorted.  For the permutation that starts\n+     * with index 3 the third and forth char are in bucket 'aa' at\n+     * index 0 and for the one starting at block index 0 they are in\n+     * bucket 'ra' with sort index 5.  The fully sorted order then becomes.\n+     *\n+     * fmap = { 5, 3, 0, 4, 1, 2 }\n+     * \n+     */\n+\n+    /**\n+     * @param fmap points to the index of the starting point of a\n+     *        permutation inside the block of data in the current\n+     *        partially sorted order\n+     * @param eclass points from the index of a character inside the\n+     *        block to the first index in fmap that contains the\n+     *        bucket of its suffix that is sorted in this step.\n+     * @param lo lower boundary of the fmap-interval to be sorted \n+     * @param hi upper boundary of the fmap-interval to be sorted \n+     */\n+    private void fallbackSimpleSort(int[] fmap, \n+                                    int[] eclass, \n+                                    int lo, \n+                                    int hi) {\n+        if (lo == hi) return;\n+\n+        int j;\n+        if (hi - lo > 3) {\n+            for (int i = hi - 4; i >= lo; i--) {\n+                int tmp = fmap[i];\n+                int ec_tmp = eclass[tmp];\n+                for (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];\n+                     j += 4) {\n+                    fmap[j - 4] = fmap[j];\n+                }\n+                fmap[j - 4] = tmp;\n+            }\n+        }\n+\n+        for (int i = hi - 1; i >= lo; i--) {\n+            int tmp = fmap[i];\n+            int ec_tmp = eclass[tmp];\n+            for (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {\n+                fmap[j - 1] = fmap[j];\n+            }\n+            fmap[j-1] = tmp;\n+        }\n+    }\n+\n+    private static final int FALLBACK_QSORT_SMALL_THRESH = 10;\n+\n+    /**\n+     * swaps two values in fmap\n+     */\n+    private void fswap(int[] fmap, int zz1, int zz2) {\n+        int zztmp = fmap[zz1];\n+        fmap[zz1] = fmap[zz2];\n+        fmap[zz2] = zztmp;\n+    }\n+\n+    /**\n+     * swaps two intervals starting at yyp1 and yyp2 of length yyn inside fmap.\n+     */\n+    private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\n+        while (yyn > 0) {\n+            fswap(fmap, yyp1, yyp2);\n+            yyp1++; yyp2++; yyn--;\n+        }\n+    }\n+\n+    private int fmin(int a, int b) {\n+        return a < b ? a : b;\n+    }\n+\n+    private void fpush(int sp, int lz, int hz) {\n+        stack_ll[sp] = lz;\n+        stack_hh[sp] = hz;\n+    }\n+\n+    private int[] fpop(int sp) {\n+        return new int[] { stack_ll[sp], stack_hh[sp] };\n+    }\n+\n+    /**\n+     * @param fmap points to the index of the starting point of a\n+     *        permutation inside the block of data in the current\n+     *        partially sorted order\n+     * @param eclass points from the index of a character inside the\n+     *        block to the first index in fmap that contains the\n+     *        bucket of its suffix that is sorted in this step.\n+     * @param loSt lower boundary of the fmap-interval to be sorted \n+     * @param hiSt upper boundary of the fmap-interval to be sorted \n+     */\n+    private void fallbackQSort3(int[] fmap, \n+                                int[] eclass, \n+                                int loSt, \n+                                int hiSt) {\n+        int lo, unLo, ltLo, hi, unHi, gtHi, n;\n+\n+        long r = 0;\n+        int sp = 0;\n+        fpush(sp++, loSt, hiSt);\n+\n+        while (sp > 0) {\n+            int[] s = fpop(--sp);\n+            lo = s[0]; hi = s[1];\n+\n+            if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\n+                fallbackSimpleSort(fmap, eclass, lo, hi);\n+                continue;\n+            }\n+\n+            /* LBZ2: Random partitioning.  Median of 3 sometimes fails to\n+               avoid bad cases.  Median of 9 seems to help but \n+               looks rather expensive.  This too seems to work but\n+               is cheaper.  Guidance for the magic constants \n+               7621 and 32768 is taken from Sedgewick's algorithms\n+               book, chapter 35.\n+            */\n+            r = ((r * 7621) + 1) % 32768;\n+            long r3 = r % 3, med;\n+            if (r3 == 0) {\n+                med = eclass[fmap[lo]]; \n+            } else if (r3 == 1) {\n+                med = eclass[fmap[(lo+hi)>>1]];\n+            } else {\n+                med = eclass[fmap[hi]];\n+            }\n+\n+            unLo = ltLo = lo;\n+            unHi = gtHi = hi;\n+\n+            // looks like the ternary partition attributed to Wegner\n+            // in the cited Sedgewick paper\n+            while (true) {\n+                while (true) {\n+                    if (unLo > unHi) break;\n+                    n = eclass[fmap[unLo]] - (int) med;\n+                    if (n == 0) { \n+                        fswap(fmap, unLo, ltLo); \n+                        ltLo++; unLo++; \n+                        continue; \n+                    };\n+                    if (n > 0) break;\n+                    unLo++;\n+                }\n+                while (true) {\n+                    if (unLo > unHi) break;\n+                    n = eclass[fmap[unHi]] - (int) med;\n+                    if (n == 0) {\n+                        fswap(fmap, unHi, gtHi); \n+                        gtHi--; unHi--; \n+                        continue; \n+                    };\n+                    if (n < 0) break;\n+                    unHi--;\n+                }\n+                if (unLo > unHi) break;\n+                fswap(fmap, unLo, unHi); unLo++; unHi--;\n+            }\n+\n+            if (gtHi < ltLo) continue;\n+\n+            n = fmin(ltLo - lo, unLo - ltLo);\n+            fvswap(fmap, lo, unLo - n, n);\n+            int m = fmin(hi - gtHi, gtHi - unHi);\n+            fvswap(fmap, unHi + 1, hi - m + 1, m);\n+\n+            n = lo + unLo - ltLo - 1;\n+            m = hi - (gtHi - unHi) + 1;\n+\n+            if (n - lo > hi - m) {\n+                fpush(sp++, lo, n);\n+                fpush(sp++, m, hi);\n+            } else {\n+                fpush(sp++, m, hi);\n+                fpush(sp++, lo, n);\n+            }\n+        }\n+    }\n+\n+\n+/*---------------------------------------------*/\n+\n+    private int[] eclass;\n+\n+    private int[] getEclass() {\n+        return eclass == null\n+            ? (eclass = new int[quadrant.length / 2]) : eclass;\n+    }\n+\n+    /*\n+     * The C code uses an array of ints to represents the bucket-start\n+     * flags (bhtab).  It also contains optimizations to skip over 32\n+     * consecutively set or consecutively unset bits on word\n+     * boundaries at once.  For now I've chosen to use the simpler but\n+     * potentially slower code using BitSet - also in the hope that\n+     * using the BitSet#nextXXX methods may be fast enough.\n+     */\n+\n+    /**\n+     * @param fmap points to the index of the starting point of a\n+     *        permutation inside the block of data in the current\n+     *        partially sorted order\n+     * @param block the original data\n+     * @param nblock size of the block\n+     * @param off offset of first byte to sort in block\n+     */\n+    final void fallbackSort(int[] fmap, byte[] block, int nblock) {\n+        int[] ftab = new int[257];\n+        int H, i, j, k, l, r, cc, cc1;\n+        int nNotDone;\n+        int nBhtab;\n+\n+        /*--\n+          LBZ2: Initial 1-char radix sort to generate\n+          initial fmap and initial BH bits.\n+          --*/\n+        for (i = 0; i < nblock; i++) ftab[block[i] & 0xff]++;\n+        for (i = 1; i < 257;    i++) ftab[i] += ftab[i - 1];\n+\n+        for (i = 0; i < nblock; i++) {\n+            j = block[i] & 0xff;\n+            k = ftab[j] - 1;\n+            ftab[j] = k;\n+            fmap[k] = i;\n+        }\n+\n+        nBhtab = 64 + nblock;\n+        BitSet bhtab = new BitSet(nBhtab);\n+        for (i = 0; i < 256; i++) bhtab.set(ftab[i]);\n+\n+        /*--\n+          LBZ2: Inductively refine the buckets.  Kind-of an\n+          \"exponential radix sort\" (!), inspired by the\n+          Manber-Myers suffix array construction algorithm.\n+          --*/\n+\n+        /*-- LBZ2: set sentinel bits for block-end detection --*/\n+        for (i = 0; i < 32; i++) { \n+            bhtab.set(nblock + 2 * i);\n+            bhtab.clear(nblock + 2 * i + 1);\n+        }\n+\n+        eclass = getEclass();\n+\n+        /*-- LBZ2: the log(N) loop --*/\n+        H = 1;\n+        while (true) {\n+\n+            j = 0;\n+            for (i = 0; i < nblock; i++) {\n+                if (bhtab.get(i)) {\n+                    j = i;\n+                }\n+                k = fmap[i] - H;\n+                if (k < 0) {\n+                    k += nblock;\n+                }\n+                eclass[k] = j;\n+            }\n+\n+            nNotDone = 0;\n+            r = -1;\n+            while (true) {\n+\n+                /*-- LBZ2: find the next non-singleton bucket --*/\n+                k = r + 1;\n+                k = bhtab.nextSetBit(k);\n+                l = k - 1;\n+                if (l >= nblock) break;\n+                k = bhtab.nextClearBit(k);\n+                r = k - 1;\n+                if (r >= nblock) break;\n+\n+                /*-- LBZ2: now [l, r] bracket current bucket --*/\n+                if (r > l) {\n+                    nNotDone += (r - l + 1);\n+                    fallbackQSort3(fmap, eclass, l, r);\n+\n+                    /*-- LBZ2: scan bucket and generate header bits-- */\n+                    cc = -1;\n+                    for (i = l; i <= r; i++) {\n+                        cc1 = eclass[fmap[i]];\n+                        if (cc != cc1) {\n+                            bhtab.set(i);\n+                            cc = cc1;\n+                        };\n+                    }\n+                }\n+            }\n+\n+            H *= 2;\n+            if (H > nblock || nNotDone == 0) break;\n+        }\n     }\n \n /*---------------------------------------------*/\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n     private static final byte[] FIXTURE_BWT = { (byte) 128, 0, 3, (byte) 254, 2, 1, \n                                                 (byte) 252, (byte) 255, (byte) 253 };\n \n+    private static final int[] FIXTURE_SORTED = {\n+        0, 1, 7, 6, 8, 2, 3, 5, 4\n+    };\n+\n     @Test\n     public void testSortFixture() {\n         BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n         }\n         assertEquals(0, data.origPtr);\n     }\n+\n+    @Test\n+    public void testFallbackSort() {\n+        BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n+        BlockSort s = new BlockSort(data);\n+        int[] fmap = new int[FIXTURE.length];\n+        s.fallbackSort(fmap, FIXTURE, FIXTURE.length);\n+        assertArrayEquals(FIXTURE_SORTED, fmap);\n+    }\n }", "timestamp": 1337529681, "metainfo": ""}