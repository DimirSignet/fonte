{"sha": "87f0f2ec35c600cae7a17621455c00e24256011a", "log": "COMPRESS-327 write 7z archives to arbirary SeekableByteChannels - needs optimization", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n import java.io.File;\n import java.io.IOException;\n import java.io.OutputStream;\n-import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Collections;\n import java.util.Date;\n+import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.List;\n import java.util.LinkedList;\n  * @since 1.6\n  */\n public class SevenZOutputFile implements Closeable {\n-    private final RandomAccessFile file;\n+    private final SeekableByteChannel channel;\n     private final List<SevenZArchiveEntry> files = new ArrayList<>();\n     private int numNonEmptyStreams = 0;\n     private final CRC32 crc32 = new CRC32();\n     private Iterable<? extends SevenZMethodConfiguration> contentMethods =\n             Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n     private final Map<SevenZArchiveEntry, long[]> additionalSizes = new HashMap<>();\n-    \n+\n     /**\n      * Opens file to write a 7z archive to.\n      *\n-     * @param filename name of the file to write to\n+     * @param filename the file to write to\n      * @throws IOException if opening the file fails\n      */\n     public SevenZOutputFile(final File filename) throws IOException {\n-        file = new RandomAccessFile(filename, \"rw\");\n-        file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n-    }\n-    \n+        this(Files.newByteChannel(filename.toPath(),\n+            EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE,\n+                       StandardOpenOption.TRUNCATE_EXISTING)));\n+    }\n+\n+    /**\n+     * Prepares channel to write a 7z archive to.\n+     *\n+     * @param channel the channel to write to\n+     * @throws IOException if the channel cannot be positioned properly\n+     */\n+    public SevenZOutputFile(final SeekableByteChannel channel) throws IOException {\n+        this.channel = channel;\n+        channel.position(SevenZFile.SIGNATURE_HEADER_SIZE);\n+    }\n+\n     /**\n      * Sets the default compression method to use for entry contents - the\n      * default is LZMA2.\n         if (!finished) {\n             finish();\n         }\n-        file.close();\n-    }\n-    \n+        channel.close();\n+    }\n+\n     /**\n      * Create an archive entry using the inputFile and entryName provided.\n      * \n         final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n         files.add(entry);\n     }\n-    \n+\n     /**\n      * Closes the archive entry.\n      * @throws IOException on error\n     public void write(final int b) throws IOException {\n         getCurrentOutputStream().write(b);\n     }\n-    \n+\n     /**\n      * Writes a byte array to the current archive entry.\n      * @param b The byte array to be written.\n     public void write(final byte[] b) throws IOException {\n         write(b, 0, b.length);\n     }\n-    \n+\n     /**\n      * Writes part of a byte array to the current archive entry.\n      * @param b The byte array to be written.\n             getCurrentOutputStream().write(b, off, len);\n         }\n     }\n-    \n+\n     /**\n      * Finishes the addition of entries to this archive, without closing it.\n      * \n             throw new IOException(\"This archive has already been finished\");\n         }\n         finished = true;\n-        \n-        final long headerPosition = file.getFilePointer();\n-        \n+\n+        final long headerPosition = channel.position();\n+\n+        // TODO use a properly sized buffer for both write operations\n+        // and re-write writeHeader and the startHeaderStream\n+        // operations to work on ByteBuffer directly.\n         final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n         final DataOutputStream header = new DataOutputStream(headerBaos);\n-        \n+\n         writeHeader(header);\n         header.flush();\n         final byte[] headerBytes = headerBaos.toByteArray();\n-        file.write(headerBytes);\n-        \n+        channel.write(ByteBuffer.wrap(headerBytes));\n+\n         final CRC32 crc32 = new CRC32();\n-        \n+\n         // signature header\n-        file.seek(0);\n-        file.write(SevenZFile.sevenZSignature);\n+        channel.position(0);\n+        ByteBuffer bb = ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2);\n+        bb.put(SevenZFile.sevenZSignature);\n         // version\n-        file.write(0);\n-        file.write(2);\n-        \n+        bb.put((byte) 0).put((byte) 2);\n+        bb.flip();\n+        channel.write(bb);\n+\n         // start header\n         final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n         final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n         final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n         crc32.reset();\n         crc32.update(startHeaderBytes);\n-        file.writeInt(Integer.reverseBytes((int) crc32.getValue()));\n-        file.write(startHeaderBytes);\n-    }\n-    \n+        bb = ByteBuffer.allocate(startHeaderBytes.length + 4);\n+        bb.putInt(Integer.reverseBytes((int) crc32.getValue()));\n+        bb.put(startHeaderBytes);\n+        bb.flip();\n+        channel.write(bb);\n+    }\n+\n     /*\n      * Creation of output stream is deferred until data is actually\n      * written as some codecs might write header information even for\n                 super.write(b);\n                 crc32.update(b);\n             }\n-    \n+\n             @Override\n             public void write(final byte[] b) throws IOException {\n                 super.write(b);\n                 crc32.update(b);\n             }\n-    \n+\n             @Override\n             public void write(final byte[] b, final int off, final int len)\n                 throws IOException {\n \n     private void writeHeader(final DataOutput header) throws IOException {\n         header.write(NID.kHeader);\n-        \n+\n         header.write(NID.kMainStreamsInfo);\n         writeStreamsInfo(header);\n         writeFilesInfo(header);\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writeStreamsInfo(final DataOutput header) throws IOException {\n         if (numNonEmptyStreams > 0) {\n             writePackInfo(header);\n             writeUnpackInfo(header);\n         }\n-        \n+\n         writeSubStreamsInfo(header);\n-        \n+\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writePackInfo(final DataOutput header) throws IOException {\n         header.write(NID.kPackInfo);\n-        \n+\n         writeUint64(header, 0);\n         writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n-        \n+\n         header.write(NID.kSize);\n         for (final SevenZArchiveEntry entry : files) {\n             if (entry.hasStream()) {\n                 writeUint64(header, entry.getCompressedSize());\n             }\n         }\n-        \n+\n         header.write(NID.kCRC);\n         header.write(1); // \"allAreDefined\" == true\n         for (final SevenZArchiveEntry entry : files) {\n                 header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n             }\n         }\n-        \n+\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writeUnpackInfo(final DataOutput header) throws IOException {\n         header.write(NID.kUnpackInfo);\n-        \n+\n         header.write(NID.kFolder);\n         writeUint64(header, numNonEmptyStreams);\n         header.write(0);\n                 writeUint64(header, entry.getSize());\n             }\n         }\n-        \n+\n         header.write(NID.kCRC);\n         header.write(1); // \"allAreDefined\" == true\n         for (final SevenZArchiveEntry entry : files) {\n                 header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n             }\n         }\n-        \n+\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry) throws IOException {\n         final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int numCoders = 0;\n             bos.write(properties);\n         }\n     }\n-    \n+\n     private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n         header.write(NID.kSubStreamsInfo);\n-//        \n+//\n //        header.write(NID.kCRC);\n //        header.write(1);\n //        for (final SevenZArchiveEntry entry : files) {\n //                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n //            }\n //        }\n-//        \n+//\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writeFilesInfo(final DataOutput header) throws IOException {\n         header.write(NID.kFilesInfo);\n-        \n+\n         writeUint64(header, files.size());\n \n         writeFileEmptyStreams(header);\n         writeFileWindowsAttributes(header);\n         header.write(NID.kEnd);\n     }\n-    \n+\n     private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n         boolean hasEmptyStreams = false;\n         for (final SevenZArchiveEntry entry : files) {\n             header.write(contents);\n         }\n     }\n-    \n+\n     private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n         boolean hasEmptyFiles = false;\n         int emptyStreamCounter = 0;\n             header.write(contents);\n         }\n     }\n-    \n+\n     private void writeFileAntiItems(final DataOutput header) throws IOException {\n         boolean hasAntiItems = false;\n         final BitSet antiItems = new BitSet(0);\n             header.write(contents);\n         }\n     }\n-    \n+\n     private void writeFileNames(final DataOutput header) throws IOException {\n         header.write(NID.kName);\n-        \n+\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         final DataOutputStream out = new DataOutputStream(baos);\n         out.write(0);\n     private class OutputStreamWrapper extends OutputStream {\n         @Override\n         public void write(final int b) throws IOException {\n-            file.write(b);\n+            // TODO use a cached ByteBuffer\n+            channel.write(ByteBuffer.wrap(new byte[] {(byte) b }));\n             compressedCrc32.update(b);\n             fileBytesWritten++;\n         }\n-    \n+\n         @Override\n         public void write(final byte[] b) throws IOException {\n             OutputStreamWrapper.this.write(b, 0, b.length);\n         }\n-    \n+\n         @Override\n         public void write(final byte[] b, final int off, final int len)\n             throws IOException {\n-            file.write(b, off, len);\n+            // TODO use a cached ByteBuffer\n+            channel.write(ByteBuffer.wrap(b, off, len));\n             compressedCrc32.update(b, off, len);\n             fileBytesWritten += len;\n         }\n \n         @Override\n         public void flush() throws IOException {\n-            // no reason to flush a RandomAccessFile\n+            // no reason to flush the channel\n         }\n \n         @Override", "timestamp": 1476280447, "metainfo": ""}