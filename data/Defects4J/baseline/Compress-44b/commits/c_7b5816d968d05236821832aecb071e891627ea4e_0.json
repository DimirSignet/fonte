{"sha": "7b5816d968d05236821832aecb071e891627ea4e", "log": "Merge branch 'PR13' closes #13 by @thomasmey", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.BitInputStream;\n+import org.apache.commons.compress.utils.CloseShieldFilterInputStream;\n \n /**\n  * An input stream that decompresses from the BZip2 format to be read as any other stream.\n \n     private boolean blockRandomised;\n \n-    private int bsBuff;\n-    private int bsLive;\n     private final CRC crc = new CRC();\n \n     private int nInUse;\n \n-    private InputStream in;\n+    private BitInputStream bin;\n     private final boolean decompressConcatenated;\n \n     private static final int EOF = 0;\n      *             if {@code in == null}, the stream content is malformed, or an I/O error occurs.\n      */\n     public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n-        this.in = in;\n+        this.bin = new BitInputStream(in == System.in ? new CloseShieldFilterInputStream(in) : in,\n+            ByteOrder.BIG_ENDIAN);\n         this.decompressConcatenated = decompressConcatenated;\n \n         init(true);\n \n     @Override\n     public int read() throws IOException {\n-        if (this.in != null) {\n+        if (this.bin != null) {\n             final int r = read0();\n             count(r < 0 ? -1 : 1);\n             return r;\n             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                 + len + \") > dest.length(\" + dest.length + \").\");\n         }\n-        if (this.in == null) {\n+        if (this.bin == null) {\n             throw new IOException(\"stream closed\");\n         }\n         if (len == 0) {\n         }\n     }\n \n+    private int readNextByte(BitInputStream in) throws IOException {\n+        long b = in.readBits(8);\n+        return (int) b;\n+    }\n+\n     private boolean init(final boolean isFirstStream) throws IOException {\n-        if (null == in) {\n+        if (null == bin) {\n             throw new IOException(\"No InputStream\");\n         }\n \n-        final int magic0 = this.in.read();\n+        if (!isFirstStream) {\n+            bin.clearBitCache();\n+        }\n+\n+        final int magic0 = readNextByte(this.bin);\n         if (magic0 == -1 && !isFirstStream) {\n             return false;\n         }\n-        final int magic1 = this.in.read();\n-        final int magic2 = this.in.read();\n+        final int magic1 = readNextByte(this.bin);\n+        final int magic2 = readNextByte(this.bin);\n \n         if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\n             throw new IOException(isFirstStream\n                     : \"Garbage after a valid BZip2 stream\");\n         }\n \n-        final int blockSize = this.in.read();\n+        final int blockSize = readNextByte(this.bin);\n         if ((blockSize < '1') || (blockSize > '9')) {\n             throw new IOException(\"BZip2 block size is invalid\");\n         }\n \n         this.blockSize100k = blockSize - '0';\n \n-        this.bsLive = 0;\n         this.computedCombinedCRC = 0;\n \n         return true;\n     }\n \n     private void initBlock() throws IOException {\n+        BitInputStream bin = this.bin;\n         char magic0;\n         char magic1;\n         char magic2;\n \n         while (true) {\n             // Get the block magic bytes.\n-            magic0 = bsGetUByte();\n-            magic1 = bsGetUByte();\n-            magic2 = bsGetUByte();\n-            magic3 = bsGetUByte();\n-            magic4 = bsGetUByte();\n-            magic5 = bsGetUByte();\n+            magic0 = bsGetUByte(bin);\n+            magic1 = bsGetUByte(bin);\n+            magic2 = bsGetUByte(bin);\n+            magic3 = bsGetUByte(bin);\n+            magic4 = bsGetUByte(bin);\n+            magic5 = bsGetUByte(bin);\n \n             // If isn't end of stream magic, break out of the loop.\n             if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n             this.currentState = EOF;\n             throw new IOException(\"bad block header\");\n         }\n-        this.storedBlockCRC = bsGetInt();\n-        this.blockRandomised = bsR(1) == 1;\n+        this.storedBlockCRC = bsGetInt(bin);\n+        this.blockRandomised = bsR(bin, 1) == 1;\n \n         /**\n          * Allocate data here instead in constructor, so we do not allocate\n     }\n \n     private boolean complete() throws IOException {\n-        this.storedCombinedCRC = bsGetInt();\n+        this.storedCombinedCRC = bsGetInt(bin);\n         this.currentState = EOF;\n         this.data = null;\n \n \n     @Override\n     public void close() throws IOException {\n-        final InputStream inShadow = this.in;\n+        final BitInputStream inShadow = this.bin;\n         if (inShadow != null) {\n             try {\n-                if (inShadow != System.in) {\n-                    inShadow.close();\n-                }\n+                inShadow.close();\n             } finally {\n                 this.data = null;\n-                this.in = null;\n-            }\n-        }\n-    }\n-\n-    private int bsR(final int n) throws IOException {\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-\n-        if (bsLiveShadow < n) {\n-            final InputStream inShadow = this.in;\n-            do {\n-                final int thech = inShadow.read();\n-\n-                if (thech < 0) {\n-                    throw new IOException(\"unexpected end of stream\");\n-                }\n-\n-                bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                bsLiveShadow += 8;\n-            } while (bsLiveShadow < n);\n-\n-            this.bsBuff = bsBuffShadow;\n-        }\n-\n-        this.bsLive = bsLiveShadow - n;\n-        return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n-    }\n-\n-    private boolean bsGetBit() throws IOException {\n-        return bsR(1) != 0;\n-    }\n-\n-    private char bsGetUByte() throws IOException {\n-        return (char) bsR(8);\n-    }\n-\n-    private int bsGetInt() throws IOException {\n-        return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n+                this.bin = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * read bits from the input stream\n+     * @param n the number of bits to read, must not exceed 32?\n+     * @return\n+     * @throws IOException\n+     */\n+    private static int bsR(BitInputStream bin, final int n) throws IOException {\n+        long thech = bin.readBits(n);\n+        if (thech < 0) {\n+            throw new IOException(\"unexpected end of stream\");\n+        }\n+        return (int) thech;\n+    }\n+\n+    private static boolean bsGetBit(BitInputStream bin) throws IOException {\n+        return bsR(bin, 1) != 0;\n+    }\n+\n+    private static char bsGetUByte(BitInputStream bin) throws IOException {\n+        return (char) bsR(bin, 8);\n+    }\n+\n+    private static int bsGetInt(BitInputStream bin) throws IOException {\n+        return (int) bsR(bin, 32);\n     }\n \n     /**\n     }\n \n     private void recvDecodingTables() throws IOException {\n+        final BitInputStream bin = this.bin;\n         final Data dataShadow = this.data;\n         final boolean[] inUse = dataShadow.inUse;\n         final byte[] pos = dataShadow.recvDecodingTables_pos;\n \n         /* Receive the mapping table */\n         for (int i = 0; i < 16; i++) {\n-            if (bsGetBit()) {\n+            if (bsGetBit(bin)) {\n                 inUse16 |= 1 << i;\n             }\n         }\n \n-        for (int i = 256; --i >= 0;) {\n-            inUse[i] = false;\n-        }\n-\n+        Arrays.fill(inUse, false);\n         for (int i = 0; i < 16; i++) {\n             if ((inUse16 & (1 << i)) != 0) {\n                 final int i16 = i << 4;\n                 for (int j = 0; j < 16; j++) {\n-                    if (bsGetBit()) {\n+                    if (bsGetBit(bin)) {\n                         inUse[i16 + j] = true;\n                     }\n                 }\n \n         makeMaps();\n         final int alphaSize = this.nInUse + 2;\n-\n         /* Now the selectors */\n-        final int nGroups = bsR(3);\n-        final int nSelectors = bsR(15);\n+        final int nGroups = bsR(bin, 3);\n+        final int nSelectors = bsR(bin, 15);\n \n         for (int i = 0; i < nSelectors; i++) {\n             int j = 0;\n-            while (bsGetBit()) {\n+            while (bsGetBit(bin)) {\n                 j++;\n             }\n             selectorMtf[i] = (byte) j;\n \n         /* Now the coding tables */\n         for (int t = 0; t < nGroups; t++) {\n-            int curr = bsR(5);\n+            int curr = bsR(bin, 5);\n             final char[] len_t = len[t];\n             for (int i = 0; i < alphaSize; i++) {\n-                while (bsGetBit()) {\n-                    curr += bsGetBit() ? -1 : 1;\n+                while (bsGetBit(bin)) {\n+                    curr += bsGetBit(bin) ? -1 : 1;\n                 }\n                 len_t[i] = (char) curr;\n             }\n     }\n \n     private void getAndMoveToFrontDecode() throws IOException {\n-        this.origPtr = bsR(24);\n+        final BitInputStream bin = this.bin;\n+        this.origPtr = bsR(bin, 24);\n         recvDecodingTables();\n \n-        final InputStream inShadow = this.in;\n         final Data dataShadow = this.data;\n         final byte[] ll8 = dataShadow.ll8;\n         final int[] unzftab = dataShadow.unzftab;\n         int groupPos = G_SIZE - 1;\n         final int eob = this.nInUse + 1;\n         int nextSym = getAndMoveToFrontDecode0(0);\n-        int bsBuffShadow = this.bsBuff;\n-        int bsLiveShadow = this.bsLive;\n         int lastShadow = -1;\n         int zt = selector[groupNo] & 0xff;\n         int[] base_zt = base[zt];\n                     }\n \n                     int zn = minLens_zt;\n-\n-                    // Inlined:\n-                    // int zvec = bsR(zn);\n-                    while (bsLiveShadow < zn) {\n-                        final int thech = inShadow.read();\n-                        if (thech >= 0) {\n-                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                            bsLiveShadow += 8;\n-                            continue;\n-                        }\n-                        throw new IOException(\"unexpected end of stream\");\n-                    }\n-                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n-                        & ((1 << zn) - 1);\n-                    bsLiveShadow -= zn;\n-\n-                    while (zvec > limit_zt[zn]) {\n+                    int zvec = (int) bsR(bin, zn);\n+                    while(zvec > limit_zt[zn]) {\n                         zn++;\n-                        while (bsLiveShadow < 1) {\n-                            final int thech = inShadow.read();\n-                            if (thech >= 0) {\n-                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                                bsLiveShadow += 8;\n-                                continue;\n-                            }\n-                            throw new IOException(\n-                                                  \"unexpected end of stream\");\n-                        }\n-                        bsLiveShadow--;\n-                        zvec = (zvec << 1)\n-                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                        zvec = (zvec << 1) | bsR(bin, 1);\n                     }\n                     nextSym = perm_zt[zvec - base_zt[zn]];\n                 }\n                 }\n \n                 int zn = minLens_zt;\n-\n-                // Inlined:\n-                // int zvec = bsR(zn);\n-                while (bsLiveShadow < zn) {\n-                    final int thech = inShadow.read();\n-                    if (thech >= 0) {\n-                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                        bsLiveShadow += 8;\n-                        continue;\n-                    }\n-                    throw new IOException(\"unexpected end of stream\");\n-                }\n-                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n-                    & ((1 << zn) - 1);\n-                bsLiveShadow -= zn;\n-\n-                while (zvec > limit_zt[zn]) {\n+                int zvec = (int) bsR(bin, zn);\n+                while(zvec > limit_zt[zn]) {\n                     zn++;\n-                    while (bsLiveShadow < 1) {\n-                        final int thech = inShadow.read();\n-                        if (thech >= 0) {\n-                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                            bsLiveShadow += 8;\n-                            continue;\n-                        }\n-                        throw new IOException(\"unexpected end of stream\");\n-                    }\n-                    bsLiveShadow--;\n-                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                    zvec = (zvec << 1) | (int) bsR(bin, 1);\n                 }\n                 nextSym = perm_zt[zvec - base_zt[zn]];\n             }\n         }\n \n         this.last = lastShadow;\n-        this.bsLive = bsLiveShadow;\n-        this.bsBuff = bsBuffShadow;\n     }\n \n     private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\n-        final InputStream inShadow = this.in;\n         final Data dataShadow = this.data;\n         final int zt = dataShadow.selector[groupNo] & 0xff;\n         final int[] limit_zt = dataShadow.limit[zt];\n         int zn = dataShadow.minLens[zt];\n-        int zvec = bsR(zn);\n-        int bsLiveShadow = this.bsLive;\n-        int bsBuffShadow = this.bsBuff;\n-\n+        int zvec = bsR(bin, zn);\n         while (zvec > limit_zt[zn]) {\n             zn++;\n-            while (bsLiveShadow < 1) {\n-                final int thech = inShadow.read();\n-\n-                if (thech >= 0) {\n-                    bsBuffShadow = (bsBuffShadow << 8) | thech;\n-                    bsLiveShadow += 8;\n-                    continue;\n-                }\n-                throw new IOException(\"unexpected end of stream\");\n-            }\n-            bsLiveShadow--;\n-            zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n-        }\n-\n-        this.bsLive = bsLiveShadow;\n-        this.bsBuff = bsBuffShadow;\n+            zvec = (zvec << 1) | (int) bsR(bin, 1);\n+        }\n \n         return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n     }\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n         this.in = in;\n         this.byteOrder = byteOrder;\n     }\n-    \n+\n     @Override\n     public void close() throws IOException {\n         in.close();\n     }\n-    \n+\n     /**\n      * Clears the cache of bits that have been read from the\n      * underlying stream but not yet provided via {@link #readBits}.\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n         }\n+        if (ensureCache(count)) {\n+            return -1;\n+        }\n+\n+        if (bitsCachedSize < count) {\n+            return processBitsGreater57(count);\n+        } else {\n+            final long bitsOut;\n+            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+                bitsOut = (bitsCached & MASKS[count]);\n+                bitsCached >>>= count;\n+            } else {\n+                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n+            }\n+            bitsCachedSize -= count;\n+            return bitsOut;\n+        }\n+    }\n+\n+    private long processBitsGreater57(final int count) throws IOException {\n+        final long bitsOut;\n+        int overflowBits = 0;\n+        long overflow = 0l;\n+\n+        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n+        int bitsToAddCount = count - bitsCachedSize;\n+        overflowBits = 8 - bitsToAddCount;\n+        final long nextByte = in.read();\n+        if (nextByte < 0) {\n+            return nextByte;\n+        }\n+        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+            long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n+            bitsCached |= (bitsToAdd << bitsCachedSize);\n+            overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n+        } else {\n+            bitsCached <<= bitsToAddCount;\n+            long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n+            bitsCached |= bitsToAdd;\n+            overflow = nextByte & MASKS[overflowBits];\n+        }\n+        bitsOut = bitsCached & MASKS[count];\n+        bitsCached = overflow;\n+        bitsCachedSize = overflowBits;\n+        return bitsOut;\n+    }\n+\n+    /**\n+     * Fills the cache up to 56 bits\n+     * @param count\n+     * @return return true, when EOF\n+     * @throws IOException\n+     */\n+    private boolean ensureCache(final int count) throws IOException {\n         while (bitsCachedSize < count && bitsCachedSize < 57) {\n             final long nextByte = in.read();\n             if (nextByte < 0) {\n-                return nextByte;\n+                return true;\n             }\n             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                 bitsCached |= (nextByte << bitsCachedSize);\n             }\n             bitsCachedSize += 8;\n         }\n-        int overflowBits = 0;\n-        long overflow = 0l;\n-        if (bitsCachedSize < count) {\n-            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n-            int bitsToAddCount = count - bitsCachedSize;\n-            overflowBits = 8 - bitsToAddCount;\n-            final long nextByte = in.read();\n-            if (nextByte < 0) {\n-                return nextByte;\n-            }\n-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n-                bitsCached |= (bitsToAdd << bitsCachedSize);\n-                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n-            } else {\n-                bitsCached <<= bitsToAddCount;\n-                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n-                bitsCached |= bitsToAdd;\n-                overflow = nextByte & MASKS[overflowBits];\n-            }\n-            bitsCachedSize = count;\n-        }\n-        \n-        final long bitsOut;\n-        if (overflowBits == 0) {\n-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-                bitsOut = (bitsCached & MASKS[count]);\n-                bitsCached >>>= count;\n-            } else {\n-                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n-            }\n-            bitsCachedSize -= count;\n-        } else {\n-            bitsOut = bitsCached & MASKS[count];\n-            bitsCached = overflow;\n-            bitsCachedSize = overflowBits;\n-        }\n-        return bitsOut;\n+        return false;\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/CloseShieldFilterInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Re-implements {@link FilterInputStream#close()} to do nothing.\n+ * @since 1.14\n+ */\n+public class CloseShieldFilterInputStream extends FilterInputStream {\n+\n+    public CloseShieldFilterInputStream(InputStream in) {\n+        super(in);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        // NO IMPLEMENTATION.\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n             }\n \n             if (LZ4_FRAMED.equalsIgnoreCase(name)) {\n-                return new FramedLZ4CompressorInputStream(in);\n+                return new FramedLZ4CompressorInputStream(in, actualDecompressConcatenated);\n             }\n \n         } catch (final IOException e) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/BlockLZ4CompressorOutputStream.java\n         if (!finished) {\n             compressor.finish();\n             finished = true;\n+        }\n+    }\n+\n+    /**\n+     * Adds some initial data to fill the window with.\n+     *\n+     * @param data the data to fill the window with.\n+     * @param off offset of real data into the array\n+     * @param len amount of data\n+     * @throws IllegalStateException if the stream has already started to write data\n+     * @see LZ77Compressor#prefill\n+     */\n+    public void prefill(byte[] data, int off, int len) {\n+        if (len > 0) {\n+            byte[] b = Arrays.copyOfRange(data, off, off + len);\n+            compressor.prefill(b);\n+            recordLiteral(b);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStream.java\n import org.apache.commons.compress.compressors.CompressorInputStream;\n import org.apache.commons.compress.utils.BoundedInputStream;\n import org.apache.commons.compress.utils.ByteUtils;\n+import org.apache.commons.compress.utils.ChecksumCalculatingInputStream;\n import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * @NotThreadSafe\n  */\n public class FramedLZ4CompressorInputStream extends CompressorInputStream {\n-    /*\n-     * TODO before releasing 1.14:\n-     *\n-     * + xxhash32 checksum validation\n-     * + skippable frames\n-     * + decompressConcatenated\n-     * + block dependence\n-     */\n \n     // used by FramedLZ4CompressorOutputStream as well\n     static final byte[] LZ4_SIGNATURE = new byte[] { //NOSONAR\n         4, 0x22, 0x4d, 0x18\n     };\n+    private static final byte[] SKIPPABLE_FRAME_TRAILER = new byte[] {\n+        0x2a, 0x4d, 0x18\n+    };\n+    private static final byte SKIPPABLE_FRAME_PREFIX_BYTE_MASK = 0x50;\n \n     static final int VERSION_MASK = 0xC0;\n     static final int SUPPORTED_VERSION = 0x40;\n     };\n \n     private final InputStream in;\n+    private final boolean decompressConcatenated;\n \n     private boolean expectBlockChecksum;\n+    private boolean expectBlockDependency;\n     private boolean expectContentSize;\n     private boolean expectContentChecksum;\n \n \n     // used for frame header checksum and content checksum, if present\n     private final XXHash32 contentHash = new XXHash32();\n+\n+    // used for block checksum, if present\n+    private final XXHash32 blockHash = new XXHash32();\n+\n+    // only created if the frame doesn't set the block independence flag\n+    private byte[] blockDependencyBuffer;\n+\n+    /**\n+     * Creates a new input stream that decompresses streams compressed\n+     * using the LZ4 frame format and stops after decompressing the\n+     * first frame.\n+     * @param in  the InputStream from which to read the compressed data\n+     * @throws IOException if reading fails\n+     */\n+    public FramedLZ4CompressorInputStream(InputStream in) throws IOException {\n+        this(in, false);\n+    }\n \n     /**\n      * Creates a new input stream that decompresses streams compressed\n      * using the LZ4 frame format.\n      * @param in  the InputStream from which to read the compressed data\n+     * @param decompressConcatenated if true, decompress until the end\n+     *          of the input; if false, stop after the first LZ4 frame\n+     *          and leave the input position to point to the next byte\n+     *          after the frame stream\n      * @throws IOException if reading fails\n      */\n-    public FramedLZ4CompressorInputStream(InputStream in) throws IOException {\n+    public FramedLZ4CompressorInputStream(InputStream in, boolean decompressConcatenated) throws IOException {\n         this.in = in;\n-        readSignature();\n-        readFrameDescriptor();\n-        nextBlock();\n+        this.decompressConcatenated = decompressConcatenated;\n+        init(true);\n     }\n \n     /** {@inheritDoc} */\n                 r = readOnce(b, off, len);\n             }\n         }\n-        if (expectContentChecksum && r != -1) {\n-            contentHash.update(b, off, r);\n+        if (r != -1) {\n+            if (expectBlockDependency) {\n+                appendToBlockDependencyBuffer(b, off, r);\n+            }\n+            if (expectContentChecksum) {\n+                contentHash.update(b, off, r);\n+            }\n         }\n         return r;\n     }\n \n-    private void readSignature() throws IOException {\n+    private void init(boolean firstFrame) throws IOException {\n+        if (readSignature(firstFrame)) {\n+            readFrameDescriptor();\n+            nextBlock();\n+        }\n+    }\n+\n+    private boolean readSignature(boolean firstFrame) throws IOException {\n+        String garbageMessage = firstFrame ? \"Not a LZ4 frame stream\" : \"LZ4 frame stream followed by garbage\";\n         final byte[] b = new byte[4];\n-        final int read = IOUtils.readFully(in, b);\n+        int read = IOUtils.readFully(in, b);\n         count(read);\n+        if (0 == read && !firstFrame) {\n+            // good LZ4 frame and nothing after it\n+            endReached = true;\n+            return false;\n+        }\n+        if (4 != read) {\n+            throw new IOException(garbageMessage);\n+        }\n+\n+        read = skipSkippableFrame(b);\n+        if (0 == read && !firstFrame) {\n+            // good LZ4 frame with only some skippable frames after it\n+            endReached = true;\n+            return false;\n+        }\n         if (4 != read || !matches(b, 4)) {\n-            throw new IOException(\"Not a LZ4 frame stream\");\n-        }\n+            throw new IOException(garbageMessage);\n+        }\n+        return true;\n     }\n \n     private void readFrameDescriptor() throws IOException {\n         if ((flags & VERSION_MASK) != SUPPORTED_VERSION) {\n             throw new IOException(\"Unsupported version \" + (flags >> 6));\n         }\n-        if ((flags & BLOCK_INDEPENDENCE_MASK) == 0) {\n-            throw new IOException(\"Block dependence is not supported\");\n+        expectBlockDependency = (flags & BLOCK_INDEPENDENCE_MASK) == 0;\n+        if (expectBlockDependency) {\n+            if (blockDependencyBuffer == null) {\n+                blockDependencyBuffer = new byte[BlockLZ4CompressorInputStream.WINDOW_SIZE];\n+            }\n+        } else {\n+            blockDependencyBuffer = null;\n         }\n         expectBlockChecksum = (flags & BLOCK_CHECKSUM_MASK) != 0;\n         expectContentSize = (flags & CONTENT_SIZE_MASK) != 0;\n         boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n         int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n         if (realLen == 0) {\n-            endReached = true;\n             verifyContentChecksum();\n+            if (!decompressConcatenated) {\n+                endReached = true;\n+            } else {\n+                init(false);\n+            }\n             return;\n         }\n         InputStream capped = new BoundedInputStream(in, realLen);\n+        if (expectBlockChecksum) {\n+            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n+        }\n         if (uncompressed) {\n             inUncompressed = true;\n             currentBlock = capped;\n         } else {\n             inUncompressed = false;\n-            currentBlock = new BlockLZ4CompressorInputStream(capped);\n+            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n+            if (expectBlockDependency) {\n+                s.prefill(blockDependencyBuffer);\n+            }\n+            currentBlock = s;\n         }\n     }\n \n             currentBlock.close();\n             currentBlock = null;\n             if (expectBlockChecksum) {\n-                int skipped = (int) IOUtils.skip(in, 4);\n-                count(skipped);\n-                if (4 != skipped) {\n-                    throw new IOException(\"Premature end of stream while reading block checksum\");\n-                }\n+                verifyChecksum(blockHash, \"block\");\n+                blockHash.reset();\n             }\n         }\n     }\n \n     private void verifyContentChecksum() throws IOException {\n         if (expectContentChecksum) {\n-            byte[] checksum = new byte[4];\n-            int read = IOUtils.readFully(in, checksum);\n-            count(read);\n-            if (4 != read) {\n-                throw new IOException(\"Premature end of stream while reading content checksum\");\n-            }\n-            long expectedHash = contentHash.getValue();\n-            if (expectedHash != ByteUtils.fromLittleEndian(checksum)) {\n-                throw new IOException(\"content checksum mismatch.\");\n-            }\n-            contentHash.reset();\n+            verifyChecksum(contentHash, \"content\");\n+        }\n+        contentHash.reset();\n+    }\n+\n+    private void verifyChecksum(XXHash32 hash, String kind) throws IOException {\n+        byte[] checksum = new byte[4];\n+        int read = IOUtils.readFully(in, checksum);\n+        count(read);\n+        if (4 != read) {\n+            throw new IOException(\"Premature end of stream while reading \" + kind + \" checksum\");\n+        }\n+        long expectedHash = hash.getValue();\n+        if (expectedHash != ByteUtils.fromLittleEndian(checksum)) {\n+            throw new IOException(kind + \" checksum mismatch.\");\n         }\n     }\n \n         }\n     }\n \n+    private static boolean isSkippableFrameSignature(byte[] b) {\n+        if ((b[0] & SKIPPABLE_FRAME_PREFIX_BYTE_MASK) != SKIPPABLE_FRAME_PREFIX_BYTE_MASK) {\n+            return false;\n+        }\n+        for (int i = 1; i < 4; i++) {\n+            if (b[i] != SKIPPABLE_FRAME_TRAILER[i - 1]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Skips over the contents of a skippable frame as well as\n+     * skippable frames following it.\n+     *\n+     * <p>It then tries to read four more bytes which are supposed to\n+     * hold an LZ4 signature and returns the number of bytes read\n+     * while storing the bytes in the given array.</p>\n+     */\n+    private int skipSkippableFrame(byte[] b) throws IOException {\n+        int read = 4;\n+        while (read == 4 && isSkippableFrameSignature(b)) {\n+            long len = ByteUtils.fromLittleEndian(supplier, 4);\n+            long skipped = IOUtils.skip(in, len);\n+            count(skipped);\n+            if (len != skipped) {\n+                throw new IOException(\"Premature end of stream while skipping frame\");\n+            }\n+            read = IOUtils.readFully(in, b);\n+            count(read);\n+        }\n+        return read;\n+    }\n+\n+    private void appendToBlockDependencyBuffer(final byte[] b, final int off, int len) {\n+        len = Math.min(len, blockDependencyBuffer.length);\n+        if (len > 0) {\n+            int keep = blockDependencyBuffer.length - len;\n+            if (keep > 0) {\n+                // move last keep bytes towards the start of the buffer\n+                System.arraycopy(blockDependencyBuffer, len, blockDependencyBuffer, 0, keep);\n+            }\n+            // append new data\n+            System.arraycopy(b, off, blockDependencyBuffer, keep, len);\n+        }\n+    }\n+\n     /**\n      * Checks if the signature matches what is expected for a .lz4 file.\n      *\n--- a/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorOutputStream.java\n  * @NotThreadSafe\n  */\n public class FramedLZ4CompressorOutputStream extends CompressorOutputStream {\n-    /*\n-     * TODO before releasing 1.14:\n-     *\n-     * + block dependence\n-     */\n \n     private static final byte[] END_MARK = new byte[4];\n \n     // used for block checksum, if requested\n     private final XXHash32 blockHash;\n \n+    // only created if the config requires block dependency\n+    private byte[] blockDependencyBuffer;\n+    private int collectedBlockDependencyBytes;\n+\n     /**\n      * The block sizes supported by the format.\n      */\n     public enum BlockSize {\n         /** Block size of 64K */\n-        K64(64 * 1024, 0),\n+        K64(64 * 1024, 4),\n         /** Block size of 256K */\n-        K256(256 * 1024, 1),\n+        K256(256 * 1024, 5),\n         /** Block size of 1M */\n-        M1(1024 * 1024, 2),\n+        M1(1024 * 1024, 6),\n         /** Block size of 4M */\n-        M4(1024 * 1024, 4);\n+        M4(1024 * 1024, 7);\n \n         private final int size, index;\n         private BlockSize(int size, int index) {\n      */\n     public static class Parameters {\n         private final BlockSize blockSize;\n-        private final boolean withContentChecksum, withBlockChecksum;\n+        private final boolean withContentChecksum, withBlockChecksum, withBlockDependency;\n \n         /**\n          * The default parameters of 4M block size, enabled content\n          *\n          * <p>This matches the defaults of the lz4 command line utility.</p>\n          */\n-        public static final Parameters DEFAULT = new Parameters(BlockSize.M4, true, false);\n+        public static final Parameters DEFAULT = new Parameters(BlockSize.M4, true, false, false);\n \n         /**\n          * Sets up custom a custom block size for the LZ4 stream but\n          * @param blockSize the size of a single block.\n          */\n         public Parameters(BlockSize blockSize) {\n-            this(blockSize, true, false);\n+            this(blockSize, true, false, false);\n         }\n         /**\n          * Sets up custom parameters for the LZ4 stream.\n          * @param withBlockChecksum whether to write a block checksum.\n          * Note that block checksums are not supported by the lz4\n          * command line utility\n+         * @param withBlockDependency whether a block may depend on\n+         * the content of a previous block. Enabling this may improve\n+         * compression ratio but makes it impossible to decompress the\n+         * output in parallel.\n          */\n-        public Parameters(BlockSize blockSize, boolean withContentChecksum, boolean withBlockChecksum) {\n+        public Parameters(BlockSize blockSize, boolean withContentChecksum, boolean withBlockChecksum,\n+            boolean withBlockDependency) {\n             this.blockSize = blockSize;\n             this.withContentChecksum = withContentChecksum;\n             this.withBlockChecksum = withBlockChecksum;\n+            this.withBlockDependency = withBlockDependency;\n         }\n \n         @Override\n         public String toString() {\n             return \"LZ4 Parameters with BlockSize \" + blockSize + \", withContentChecksum \" + withContentChecksum\n-                + \", withBlockChecksum \" + withBlockChecksum;\n+                + \", withBlockChecksum \" + withBlockChecksum + \", withBlockDependency \" + withBlockDependency;\n         }\n     }\n \n         blockHash = params.withBlockChecksum ? new XXHash32() : null;\n         out.write(FramedLZ4CompressorInputStream.LZ4_SIGNATURE);\n         writeFrameDescriptor();\n+        blockDependencyBuffer = params.withBlockDependency\n+            ? new byte[BlockLZ4CompressorInputStream.WINDOW_SIZE]\n+            : null;\n     }\n \n     @Override\n \n     @Override\n     public void write(byte[] data, int off, int len) throws IOException {\n-        contentHash.update(data, off, len);\n+        if (params.withContentChecksum) {\n+            contentHash.update(data, off, len);\n+        }\n         if (currentIndex + len > blockData.length) {\n             flushBlock();\n             while (len > blockData.length) {\n     }\n \n     private void writeFrameDescriptor() throws IOException {\n-        int flags = FramedLZ4CompressorInputStream.SUPPORTED_VERSION\n-            | FramedLZ4CompressorInputStream.BLOCK_INDEPENDENCE_MASK;\n+        int flags = FramedLZ4CompressorInputStream.SUPPORTED_VERSION;\n+        if (!params.withBlockDependency) {\n+            flags |= FramedLZ4CompressorInputStream.BLOCK_INDEPENDENCE_MASK;\n+        }\n         if (params.withContentChecksum) {\n             flags |= FramedLZ4CompressorInputStream.CONTENT_CHECKSUM_MASK;\n         }\n         }\n         out.write(flags);\n         contentHash.update(flags);\n-        int bd = params.blockSize.getIndex() << 4;\n+        int bd = (params.blockSize.getIndex() << 4) & FramedLZ4CompressorInputStream.BLOCK_MAX_SIZE_MASK;\n         out.write(bd);\n         contentHash.update(bd);\n         out.write((int) ((contentHash.getValue() >> 8) & 0xff));\n     }\n \n     private void flushBlock() throws IOException {\n+        final boolean withBlockDependency = params.withBlockDependency;\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (OutputStream o = new BlockLZ4CompressorOutputStream(baos)) {\n+        try (BlockLZ4CompressorOutputStream o = new BlockLZ4CompressorOutputStream(baos)) {\n+            if (withBlockDependency) {\n+                o.prefill(blockDependencyBuffer, blockDependencyBuffer.length - collectedBlockDependencyBytes,\n+                    collectedBlockDependencyBytes);\n+            }\n             o.write(blockData, 0, currentIndex);\n+        }\n+        if (withBlockDependency) {\n+            appendToBlockDependencyBuffer(blockData, 0, currentIndex);\n         }\n         byte[] b = baos.toByteArray();\n         if (b.length > currentIndex) { // compression increased size, maybe beyond blocksize\n \n     private void writeTrailer() throws IOException {\n         out.write(END_MARK);\n-        ByteUtils.toLittleEndian(out, contentHash.getValue(), 4);\n+        if (params.withContentChecksum) {\n+            ByteUtils.toLittleEndian(out, contentHash.getValue(), 4);\n+        }\n+    }\n+\n+    private void appendToBlockDependencyBuffer(final byte[] b, final int off, int len) {\n+        len = Math.min(len, blockDependencyBuffer.length);\n+        if (len > 0) {\n+            int keep = blockDependencyBuffer.length - len;\n+            if (keep > 0) {\n+                // move last keep bytes towards the start of the buffer\n+                System.arraycopy(blockDependencyBuffer, len, blockDependencyBuffer, 0, keep);\n+            }\n+            // append new data\n+            System.arraycopy(b, off, blockDependencyBuffer, keep, len);\n+            collectedBlockDependencyBytes = Math.min(collectedBlockDependencyBytes + len,\n+                blockDependencyBuffer.length);\n+        }\n     }\n \n }\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStream.java\n  *\n  * <p>Assumes the stream consists of blocks of literal data and\n  * back-references (called copies) in any order. Of course the first\n- * block must be a literal block for the scheme to work.</p>\n+ * block must be a literal block for the scheme to work - unless the\n+ * {@link #prefill prefill} method has been used to provide initial\n+ * data that is never returned by {@link #read read} but only used for\n+ * back-references.</p>\n+ *\n+ * <p>Subclasses must override the three-arg {@link #read read} method\n+ * as the no-arg version delegates to it and the default\n+ * implementation delegates to the no-arg version, leading to infinite\n+ * mutual recursion and a {@code StackOverflowError} otherwise.</p>\n+ *\n+ * <p>The contract for subclasses' {@code read} implementation is:</p>\n+ * <ul>\n+ *\n+ *  <li>keep track of the current state of the stream. Is it inside a\n+ *  literal block or a back-reference or in-between blocks?</li>\n+ *\n+ *  <li>Use {@link #readOneByte} to access the underlying stream\n+ *  directly.</li>\n+ *\n+ *  <li>If a new literal block starts, use {@link #startLiteral} to\n+ *  tell this class about it and read the literal data using {@link\n+ *  #readLiteral} until it returns {@code 0}. {@link\n+ *  #hasMoreDataInBlock} will return {@code false} before the next\n+ *  call to {@link #readLiteral} would return {@code 0}.</li>\n+ *\n+ *  <li>If a new back-reference starts, use {@link #startBackReference} to\n+ *  tell this class about it and read the literal data using {@link\n+ *  #readBackReference} until it returns {@code 0}. {@link\n+ *  #hasMoreDataInBlock} will return {@code false} before the next\n+ *  call to {@link #readBackReference} would return {@code 0}.</li>\n+ *\n+ *  <li>If the end of the stream has been reached, return {@code -1}\n+ *  as this class' methods will never do so themselves.</li>\n+ *\n+ * </ul>\n+ *\n+ * <p>{@link #readOneByte} and {@link #readLiteral} update the counter\n+ * for bytes read.</p>\n  *\n  * @since 1.14\n  */\n     /** Size of the window - must be bigger than the biggest offset expected. */\n     private final int windowSize;\n \n-    /** Buffer to write decompressed bytes to for back-references */\n+    /**\n+     * Buffer to write decompressed bytes to for back-references, will\n+     * be three times windowSize big.\n+     *\n+     * <p>Three times so we can slide the whole buffer a windowSize to\n+     * the left once we've read twice windowSize and still have enough\n+     * data inside of it to satisfy back-references.</p>\n+     */\n     private final byte[] buf;\n \n-    /** One behind the index of the last byte in the buffer that was written */\n+    /** One behind the index of the last byte in the buffer that was written, i.e. the next position to write to */\n     private int writeIndex;\n \n     /** Index of the next byte to be read. */\n      */\n     public int getSize() {\n         return size;\n+    }\n+\n+    /**\n+     * Adds some initial data to fill the window with.\n+     *\n+     * <p>This is used if the stream has been cut into blocks and\n+     * back-references of one block may refer to data of the previous\n+     * block(s). One such example is the LZ4 frame format using block\n+     * dependency.</p>\n+     *\n+     * @param data the data to fill the window with.\n+     * @throws IllegalStateException if the stream has already started to read data\n+     */\n+    public void prefill(byte[] data) {\n+        if (writeIndex != 0) {\n+            throw new IllegalStateException(\"the stream has already been read from, can't prefill anymore\");\n+        }\n+        // we don't need more data than the big offset could refer to, so cap it\n+        int len = Math.min(windowSize, data.length);\n+        // we need the last data as we are dealing with *back*-references\n+        System.arraycopy(data, data.length - len, buf, 0, len);\n+        writeIndex += len;\n+        readIndex += len;\n     }\n \n     /**\n     }\n \n     private void tryToReadLiteral(int bytesToRead) throws IOException {\n-        final int reallyTryToRead = (int) Math.min(Math.min(bytesToRead, bytesRemaining),\n-                                                   buf.length - writeIndex);\n+        // min of \"what is still inside the literal\", \"what does the user want\" and \"how muc can fit into the buffer\"\n+        final int reallyTryToRead = Math.min((int) Math.min(bytesToRead, bytesRemaining),\n+                                             buf.length - writeIndex);\n         final int bytesRead = reallyTryToRead > 0\n             ? IOUtils.readFully(in, buf, writeIndex, reallyTryToRead)\n             : 0 /* happens for bytesRemaining == 0 */;\n     private void tryToCopy(int bytesToCopy) {\n         // this will fit into the buffer without sliding and not\n         // require more than is available inside the back-reference\n-        int copy = (int) Math.min(Math.min(bytesToCopy, bytesRemaining),\n-                                  buf.length - writeIndex);\n+        int copy = Math.min((int) Math.min(bytesToCopy, bytesRemaining),\n+                            buf.length - writeIndex);\n         if (copy == 0) {\n             // NOP\n         } else if (backReferenceOffset == 1) { // pretty common special case\n             System.arraycopy(buf, writeIndex - backReferenceOffset, buf, writeIndex, copy);\n             writeIndex += copy;\n         } else {\n+            // back-reference overlaps with the bytes created from it\n+            // like go back two bytes and then copy six (by copying\n+            // the last two bytes three time).\n             final int fullRots = copy / backReferenceOffset;\n             for (int i = 0; i < fullRots; i++) {\n                 System.arraycopy(buf, writeIndex - backReferenceOffset, buf, writeIndex, backReferenceOffset);\n--- a/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lz77support/LZ77Compressor.java\n package org.apache.commons.compress.compressors.lz77support;\n \n import java.io.IOException;\n+import java.util.Arrays;\n \n /**\n  * Helper class for compression algorithms that use the ideas of LZ77.\n  * back-references - so it can be re-used. It follows the algorithm\n  * explained in section 4 of RFC 1951 (DEFLATE) and currently doesn't\n  * implement the \"lazy match\" optimization. The three-byte hash\n- * function used in this class is the same used by zlib and InfoZIP's\n- * ZIP implementation of DEFLATE. Strongly inspired by InfoZIP's\n- * implementation.</p>\n+ * function used in this class is the same as the one used by zlib and\n+ * InfoZIP's ZIP implementation of DEFLATE. The whole class is\n+ * strongly inspired by InfoZIP's implementation.</p>\n  *\n  * <p>LZ77 is used vaguely here (as well as many other places that\n  * talk about it :-), LZSS would likely be closer to the truth but\n  * <p>The API consists of a compressor that is fed <code>byte</code>s\n  * and emits {@link Block}s to a registered callback where the blocks\n  * represent either {@link LiteralBlock literal blocks}, {@link\n- * BackReference back references} or {@link EOD end of data\n+ * BackReference back-references} or {@link EOD end of data\n  * markers}. In order to ensure the callback receives all information,\n  * the {@code #finish} method must be used once all data has been fed\n  * into the compressor.</p>\n     private int blockStart = 0;\n     // position of the current match\n     private int matchStart = NO_MATCH;\n-    // number of insertString calls for the up to three last bytes of the last match\n+    // number of missed insertString calls for the up to three last\n+    // bytes of the last match that can only be performed once more\n+    // data has been read\n     private int missedInserts = 0;\n \n     /**\n         window = new byte[wSize * 2];\n         wMask = wSize - 1;\n         head = new int[HASH_SIZE];\n-        for (int i = 0; i < HASH_SIZE; i++) {\n-            head[i] = NO_MATCH;\n-        }\n+        Arrays.fill(head, NO_MATCH);\n         prev = new int[wSize];\n     }\n \n      */\n     public void compress(byte[] data, int off, int len) throws IOException {\n         final int wSize = params.getWindowSize();\n-        while (len > wSize) {\n+        while (len > wSize) { // chop into windowSize sized chunks\n             doCompress(data, off, wSize);\n             off += wSize;\n             len -= wSize;\n             flushLiteralBlock();\n         }\n         callback.accept(THE_EOD);\n+    }\n+\n+    /**\n+     * Adds some initial data to fill the window with.\n+     *\n+     * <p>This is used if the stream has been cut into blocks and\n+     * back-references of one block may refer to data of the previous\n+     * block(s). One such example is the LZ4 frame format using block\n+     * dependency.</p>\n+     *\n+     * @param data the data to fill the window with.\n+     * @throws IllegalStateException if the compressor has already started to accept data\n+     */\n+    public void prefill(byte[] data) {\n+        if (currentPosition != 0 || lookahead != 0) {\n+            throw new IllegalStateException(\"the compressor has already started to accept data, can't prefill anymore\");\n+        }\n+\n+        // don't need more than windowSize for back-references\n+        final int len = Math.min(params.getWindowSize(), data.length);\n+        System.arraycopy(data, data.length - len, window, 0, len);\n+\n+        if (len >= NUMBER_OF_BYTES_IN_HASH) {\n+            initialize();\n+            final int stop = len - NUMBER_OF_BYTES_IN_HASH + 1;\n+            for (int i = 0; i < stop; i++) {\n+                insertString(i);\n+            }\n+            missedInserts = NUMBER_OF_BYTES_IN_HASH - 1;\n+        } else { // not enough data to hash anything\n+            missedInserts = len;\n+        }\n+        blockStart = currentPosition = len;\n     }\n \n     // we use a 15 bit hashcode as calculated in updateHash\n \n     /**\n      * Inserts the current three byte sequence into the dictionary and\n-     * returns the previous previous head of the hash-chain.\n+     * returns the previous head of the hash-chain.\n      *\n      * <p>Updates <code>insertHash</code> and <code>prev</code> as a\n      * side effect.</p>\n             if (currentLength > longestMatchLength) {\n                 longestMatchLength = currentLength;\n                 matchStart = matchHead;\n+                if (currentLength == maxPossibleLength) {\n+                    // no need to search any further\n+                    break;\n+                }\n             }\n             matchHead = prev[matchHead & wMask];\n         }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * A stream that calculates the checksum of the data read.\n+ * @NotThreadSafe\n+ * @since 1.14\n+ */\n+public class ChecksumCalculatingInputStream extends InputStream {\n+    private final InputStream in;\n+    private final Checksum checksum;\n+\n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        this.checksum = checksum;\n+        this.in = in;\n+    }\n+\n+    /**\n+     * Reads a single byte from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        final int ret = in.read();\n+        if (ret >= 0) {\n+            checksum.update(ret);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Reads a byte array from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    /**\n+     * Reads from the stream into a byte array.\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the Checksum doesn't match the expected\n+     * value\n+     */\n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        final int ret = in.read(b, off, len);\n+        if (ret >= 0) {\n+            checksum.update(b, off, ret);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public long skip(final long n) throws IOException {\n+        // Can't really skip, we have to hash everything to verify the checksum\n+        if (read() >= 0) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Returns the calculated checksum.\n+     * @return the calculated checksum.\n+     */\n+    public long getValue() {\n+        return checksum.getValue();\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorInputStreamTest.java\n import java.io.FileInputStream;\n import java.io.InputStream;\n import java.io.IOException;\n+import java.util.Arrays;\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.compressors.CompressorStreamFactory;\n         }\n     }\n \n+    @Test\n+    public void readBlaLz4WithDecompressConcatenated() throws IOException {\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.tar.lz4\")), true);\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4WithDecompressConcatenatedTrue() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new FramedLZ4CompressorInputStream(in, true);\n+                }\n+            }, true);\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4WithDecompressConcatenatedFalse() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new FramedLZ4CompressorInputStream(in, false);\n+                }\n+            }, false);\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4WithoutExplicitDecompressConcatenated() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new FramedLZ4CompressorInputStream(in);\n+                }\n+            }, false);\n+    }\n+\n+    @Test\n+    public void readBlaLz4ViaFactoryWithDecompressConcatenated() throws Exception {\n+        try (InputStream a = new CompressorStreamFactory()\n+                 .createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(),\n+                                              new FileInputStream(getFile(\"bla.tar.lz4\")),\n+                                              true);\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4ViaFactoryWithDecompressConcatenatedTrue() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new CompressorStreamFactory()\n+                        .createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in, true);\n+                }\n+            }, true);\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4ViaFactoryWithDecompressConcatenatedFalse() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new CompressorStreamFactory()\n+                        .createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in, false);\n+                }\n+            }, false);\n+    }\n+\n+    @Test\n+    public void readDoubledBlaLz4ViaFactoryWithoutExplicitDecompressConcatenated() throws Exception {\n+        readDoubledBlaLz4(new StreamWrapper() {\n+                public InputStream wrap(InputStream in) throws Exception {\n+                    return new CompressorStreamFactory()\n+                        .createCompressorInputStream(CompressorStreamFactory.getLZ4Framed(), in);\n+                }\n+            }, false);\n+    }\n+\n+    @Test\n+    public void readBlaDumpLz4() throws IOException {\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.dump.lz4\")));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.dump\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n     @Test(expected = IOException.class)\n     public void rejectsNonLZ4Stream() throws IOException {\n         try (InputStream a = new FramedLZ4CompressorInputStream(new FileInputStream(getFile(\"bla.tar\")))) {\n             assertThat(ex.getMessage(), containsString(\"content checksum mismatch\"));\n         }\n     }\n+\n+    @Test\n+    public void skipsOverSkippableFrames() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x5f, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            1, 0, 0, (byte) 0x80, // 1 bytes length and uncompressed bit set\n+            '!', // content\n+            0, 0, 0, 0, // empty block marker\n+        };\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(new byte[] {\n+                    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '!'\n+                }, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void skipsOverTrailingSkippableFrames() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x51, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+        };\n+        try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(new byte[] {\n+                    'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!'\n+                }, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameFollowedByJunk() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x50, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            1, 0x22, 0x4d, 0x18, // bad signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameFollowedByTooFewBytes() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x52, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, 2, // content of skippable frame\n+            4, // too short for signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithPrematureEnd() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x50, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, 0, // skippable frame has length 2\n+            1, // content of skippable frame (should be two bytes)\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"Premature end of stream while skipping frame\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithPrematureEndInLengthBytes() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x55, 0x2a, 0x4d, 0x18, // skippable frame signature\n+            2, 0, 0, // should be four byte length\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"premature end of data\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithBadSignatureTrailer() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x51, 0x2a, 0x4d, 0x17, // broken skippable frame signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsSkippableFrameWithBadSignaturePrefix() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x60, 0x2a, 0x4d, 0x18, // broken skippable frame signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    @Test\n+    public void rejectsTrailingBytesAfterValidFrame() throws IOException {\n+        byte[] input = new byte[] {\n+            4, 0x22, 0x4d, 0x18, // signature\n+            0x60, // flag - Version 01, block independent, no block checksum, no content size, no content checksum\n+            0x70, // block size 4MB\n+            115, // checksum\n+            13, 0, 0, (byte) 0x80, // 13 bytes length and uncompressed bit set\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // content\n+            0, 0, 0, 0, // empty block marker\n+            0x56, 0x2a, 0x4d, // too short for any signature\n+        };\n+        try {\n+            try (InputStream a = new FramedLZ4CompressorInputStream(new ByteArrayInputStream(input), true)) {\n+                IOUtils.toByteArray(a);\n+                fail(\"expected exception\");\n+            }\n+        } catch (IOException ex) {\n+            assertThat(ex.getMessage(), containsString(\"garbage\"));\n+        }\n+    }\n+\n+    interface StreamWrapper {\n+        InputStream wrap(InputStream in) throws Exception;\n+    }\n+\n+    private void readDoubledBlaLz4(StreamWrapper wrapper, boolean expectDuplicateOutput) throws Exception {\n+        byte[] singleInput;\n+        try (InputStream i = new FileInputStream(getFile(\"bla.tar.lz4\"))) {\n+            singleInput = IOUtils.toByteArray(i);\n+        }\n+        byte[] input = duplicate(singleInput);\n+        try (InputStream a = wrapper.wrap(new ByteArrayInputStream(input));\n+            FileInputStream e = new FileInputStream(getFile(\"bla.tar\"))) {\n+            byte[] expected = IOUtils.toByteArray(e);\n+            byte[] actual = IOUtils.toByteArray(a);\n+            assertArrayEquals(expectDuplicateOutput ? duplicate(expected) : expected, actual);\n+        }\n+    }\n+\n+    private static byte[] duplicate(byte[] from) {\n+        byte[] to = Arrays.copyOf(from, 2 * from.length);\n+        System.arraycopy(from, 0, to, from.length, from.length);\n+        return to;\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorRoundtripTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz4/FramedLZ4CompressorRoundtripTest.java\n             new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.M1) },\n             new Object[] { FramedLZ4CompressorOutputStream.Parameters.DEFAULT },\n             // default without content checksum\n-            new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.M4, false, false) },\n+            new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.M4,\n+                false, false, false) },\n             // default with block checksum\n-            new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.M4, true, true) },\n+            new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.M4,\n+                true, true, false) },\n+            // small blocksize (so we get enough blocks) and enabled block dependency, otherwise defaults\n+            new Object[] { new FramedLZ4CompressorOutputStream.Parameters(FramedLZ4CompressorOutputStream.BlockSize.K64,\n+                true, false, true) },\n         });\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/AbstractLZ77CompressorInputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lz77support;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class AbstractLZ77CompressorInputStreamTest {\n+\n+    private static class TestStream extends AbstractLZ77CompressorInputStream {\n+        private boolean literal;\n+        TestStream(InputStream in) throws IOException {\n+            super(in, 1024);\n+        }\n+        @Override\n+        public int read(final byte[] b, final int off, final int len) throws IOException {\n+            if (literal) {\n+                return readLiteral(b, off, len);\n+            }\n+            return readBackReference(b, off, len);\n+        }\n+        void literal(int len) {\n+            startLiteral(len);\n+            literal = true;\n+        }\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void cantPrefillAfterDataHasBeenRead() throws IOException {\n+        byte[] data = new byte[] { 1, 2, 3, 4 };\n+        try (TestStream s = new TestStream(new ByteArrayInputStream(data))) {\n+            s.literal(3);\n+            assertEquals(1, s.read());\n+            s.prefill(new byte[] { 1, 2, 3 });\n+        }\n+    }\n+\n+    @Test\n+    public void prefillCanBeUsedForBackReferences() throws IOException {\n+        byte[] data = new byte[] { 1, 2, 3, 4 };\n+        try (TestStream s = new TestStream(new ByteArrayInputStream(new byte[0]))) {\n+            s.prefill(data);\n+            s.startBackReference(2, 4);\n+            byte[] r = new byte[4];\n+            assertEquals(4, s.read(r));\n+            assertArrayEquals(new byte[] { 3, 4, 3, 4 }, r);\n+        }\n+    }\n+\n+    @Test\n+    public void ifPrefillExceedsWindowSizeTheLastBytesAreUsed() throws IOException {\n+        byte[] data = new byte[2048];\n+        data[2046] = 3;\n+        data[2047] = 4;\n+        try (TestStream s = new TestStream(new ByteArrayInputStream(new byte[0]))) {\n+            s.prefill(data);\n+            s.startBackReference(2, 4);\n+            byte[] r = new byte[4];\n+            assertEquals(4, s.read(r));\n+            assertArrayEquals(new byte[] { 3, 4, 3, 4 }, r);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/compress/compressors/lz77support/LZ77CompressorTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lz77support/LZ77CompressorTest.java\n         assertLiteralBlock(\".\", blocks.get(19));\n     }\n \n+    @Test\n+    public void blaExampleWithPrefill() throws IOException {\n+        final List<LZ77Compressor.Block> blocks = new ArrayList<>();\n+        LZ77Compressor c = new LZ77Compressor(new Parameters(128), new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                    //System.err.println(block);\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        // replace with a real copy of data so tests\n+                        // can see the results as they've been when\n+                        // the callback has been called\n+                        LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\n+                        int len = b.getLength();\n+                        block = new LZ77Compressor.LiteralBlock(\n+                            Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len),\n+                            0, len);\n+                    }\n+                    blocks.add(block);\n+                }\n+            });\n+        c.prefill(Arrays.copyOfRange(BLA, 0, 6));\n+        c.compress(Arrays.copyOfRange(BLA, 6, BLA.length));\n+        c.finish();\n+        assertSize(3, blocks);\n+        assertBackReference(5, 18, blocks.get(0));\n+        assertLiteralBlock(\"!\", blocks.get(1));\n+    }\n+\n+    @Test\n+    public void blaExampleWithShortPrefill() throws IOException {\n+        final List<LZ77Compressor.Block> blocks = new ArrayList<>();\n+        LZ77Compressor c = new LZ77Compressor(new Parameters(128), new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                    //System.err.println(block);\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        // replace with a real copy of data so tests\n+                        // can see the results as they've been when\n+                        // the callback has been called\n+                        LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\n+                        int len = b.getLength();\n+                        block = new LZ77Compressor.LiteralBlock(\n+                            Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len),\n+                            0, len);\n+                    }\n+                    blocks.add(block);\n+                }\n+            });\n+        c.prefill(Arrays.copyOfRange(BLA, 0, 2));\n+        c.compress(Arrays.copyOfRange(BLA, 2, BLA.length));\n+        c.finish();\n+        assertSize(4, blocks);\n+        assertLiteralBlock(\"ah b\", blocks.get(0));\n+        assertBackReference(5, 18, blocks.get(1));\n+        assertLiteralBlock(\"!\", blocks.get(2));\n+    }\n+\n+    @Test\n+    public void blaExampleWithPrefillBiggerThanWindowSize() throws IOException {\n+        final List<LZ77Compressor.Block> blocks = new ArrayList<>();\n+        LZ77Compressor c = new LZ77Compressor(new Parameters(4), new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                    //System.err.println(block);\n+                    if (block instanceof LZ77Compressor.LiteralBlock) {\n+                        // replace with a real copy of data so tests\n+                        // can see the results as they've been when\n+                        // the callback has been called\n+                        LZ77Compressor.LiteralBlock b = (LZ77Compressor.LiteralBlock) block;\n+                        int len = b.getLength();\n+                        block = new LZ77Compressor.LiteralBlock(\n+                            Arrays.copyOfRange(b.getData(), b.getOffset(), b.getOffset() + len),\n+                            0, len);\n+                    }\n+                    blocks.add(block);\n+                }\n+            });\n+        c.prefill(Arrays.copyOfRange(BLA, 0, 6));\n+        c.compress(Arrays.copyOfRange(BLA, 6, BLA.length));\n+        c.finish();\n+        assertSize(6, blocks);\n+        assertLiteralBlock(\"lah \", blocks.get(0));\n+        assertLiteralBlock(\"blah\", blocks.get(1));\n+        assertLiteralBlock(\" bla\", blocks.get(2));\n+        assertLiteralBlock(\"h bl\", blocks.get(3));\n+        assertLiteralBlock(\"ah!\", blocks.get(4));\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void cantPrefillTwice() {\n+        LZ77Compressor c = new LZ77Compressor(new Parameters(128), new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                }\n+            });\n+        c.prefill(Arrays.copyOfRange(BLA, 0, 2));\n+        c.prefill(Arrays.copyOfRange(BLA, 2, 4));\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void cantPrefillAfterCompress() throws IOException {\n+        LZ77Compressor c = new LZ77Compressor(new Parameters(128), new LZ77Compressor.Callback() {\n+                @Override\n+                public void accept(LZ77Compressor.Block block) {\n+                }\n+            });\n+        c.compress(Arrays.copyOfRange(BLA, 0, 2));\n+        c.prefill(Arrays.copyOfRange(BLA, 2, 4));\n+    }\n+\n     private static final void assertSize(int expectedSize, List<LZ77Compressor.Block> blocks) {\n         assertEquals(expectedSize, blocks.size());\n         assertEquals(LZ77Compressor.EOD.class, blocks.get(expectedSize - 1).getClass());", "timestamp": 1487177470, "metainfo": ""}