{"sha": "fca65f84c0fd672b1db07198049d8efe797b3334", "log": "Merge pull request #29 from fge/master  Some random fixes", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/FormatSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/core/FormatSchema.java\n      * it is a short name of format itself, but it can also contain additional information\n      * in cases where data format supports multiple types of schemas.\n      */\n-    public String getSchemaType();\n+    String getSchemaType();\n }\n--- a/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n      * to output some other suitable and nice-looking separator\n      * (tab(s), space(s), linefeed(s) or any combination thereof).\n      */\n-    public void writeRootValueSeparator(JsonGenerator jg)\n+    void writeRootValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     // // Object handling\n      * to output a curly bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    public void writeStartObject(JsonGenerator jg)\n+    void writeStartObject(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfEntries Number of direct members of the array that\n      *   have been output\n      */\n-    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+    void writeEndObject(JsonGenerator jg, int nrOfEntries)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    public void writeObjectEntrySeparator(JsonGenerator jg)\n+    void writeObjectEntrySeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a colon as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n+    void writeObjectFieldValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     // // // Array handling\n      * to output a bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    public void writeStartArray(JsonGenerator jg)\n+    void writeStartArray(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfValues Number of direct members of the array that\n      *   have been output\n      */\n-    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n+    void writeEndArray(JsonGenerator jg, int nrOfValues)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    public void writeArrayValueSeparator(JsonGenerator jg)\n+    void writeArrayValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     /*\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    public void beforeArrayValues(JsonGenerator jg)\n+    void beforeArrayValues(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    public void beforeObjectEntries(JsonGenerator jg)\n+    void beforeObjectEntries(JsonGenerator jg)\n         throws IOException, JsonGenerationException;\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n      * Returns unquoted String that this object represents (and offers\n      * serialized forms for)\n      */\n-    public String getValue();\n+    String getValue();\n     \n     /**\n      * Returns length of the (unquoted) String as characters.\n      *   getValue().length();\n      *</pre>\n      */\n-    public int charLength();\n+    int charLength();\n \n     \n     /*\n      * Returns JSON quoted form of the String, as character array. Result\n      * can be embedded as-is in textual JSON as property name or JSON String.\n      */\n-    public char[] asQuotedChars();\n+    char[] asQuotedChars();\n \n     /**\n      * Returns UTF-8 encoded version of unquoted String.\n      * getValue().getBytes(\"UTF-8\");\n      *</pre>\n      */\n-    public byte[] asUnquotedUTF8();\n+    byte[] asUnquotedUTF8();\n \n     /**\n      * Returns UTF-8 encoded version of JSON-quoted String.\n      * new String(asQuotedChars()).getBytes(\"UTF-8\");\n      *</pre>\n      */\n-    public byte[] asQuotedUTF8();\n+    byte[] asQuotedUTF8();\n \n     /*\n     /**********************************************************\n      * \n      * @return Number of bytes appended, if successful, otherwise -1\n      */\n-    public int appendQuotedUTF8(byte[] buffer, int offset);\n+    int appendQuotedUTF8(byte[] buffer, int offset);\n \n     /**\n      * Method that will append quoted characters of this String into given\n      * \n      * @return Number of characters appended, if successful, otherwise -1\n      */\n-    public int appendQuoted(char[] buffer, int offset);\n+    int appendQuoted(char[] buffer, int offset);\n     \n     /**\n      * Method that will append unquoted ('raw') UTF-8 bytes of this String into given\n      * \n      * @return Number of bytes appended, if successful, otherwise -1\n      */\n-    public int appendUnquotedUTF8(byte[] buffer, int offset);\n+    int appendUnquotedUTF8(byte[] buffer, int offset);\n \n     \n     /**\n      * \n      * @return Number of characters appended, if successful, otherwise -1\n      */\n-    public int appendUnquoted(char[] buffer, int offset);\n+    int appendUnquoted(char[] buffer, int offset);\n \n     /*\n     /**********************************************************\n     /**\n      * @return Number of bytes written\n      */\n-    public int writeQuotedUTF8(OutputStream out) throws IOException;\n+    int writeQuotedUTF8(OutputStream out) throws IOException;\n \n     /**\n      * @return Number of bytes written\n      */\n-    public int writeUnquotedUTF8(OutputStream out) throws IOException;\n+    int writeUnquotedUTF8(OutputStream out) throws IOException;\n \n     /**\n      * @return Number of bytes put, if successful, otherwise -1\n      */\n-    public int putQuotedUTF8(ByteBuffer buffer) throws IOException;\n+    int putQuotedUTF8(ByteBuffer buffer) throws IOException;\n \n     /**\n      * @return Number of bytes put, if successful, otherwise -1\n      */\n-    public int putUnquotedUTF8(ByteBuffer out) throws IOException;\n+    int putUnquotedUTF8(ByteBuffer out) throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n      * stream event would produce (for most nodes there is just\n      * one token but for structured/container types multiple)\n      */\n-    public abstract JsonToken asToken();\n+    JsonToken asToken();\n \n     /**\n      * If this node is a numeric type (as per {@link JsonToken#isNumeric}),\n      * @return Type of number contained, if any; or null if node does not\n      *  contain numeric value.\n      */\n-    public abstract JsonParser.NumberType numberType();\n+    JsonParser.NumberType numberType();\n \n     /*\n     /**********************************************************\n      * {@link ObjectCodec} and then re-parsing but\n      * more efficient.\n      */\n-    public abstract JsonParser traverse();\n+    JsonParser traverse();\n \n }\n--- a/src/main/java/com/fasterxml/jackson/core/Versioned.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Versioned.java\n      * returned version should never be null, but may return specific \"not available\"\n      * instance (see {@link Version} for details).\n      */\n-    public Version version();\n+    Version version();\n }\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             writeBinary((byte[]) value);\n             return;\n         } else if (value instanceof Boolean) {\n-            writeBoolean(((Boolean) value).booleanValue());\n+            writeBoolean((Boolean) value);\n             return;\n         } else if (value instanceof AtomicBoolean) {\n             writeBoolean(((AtomicBoolean) value).get());\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n         // Separate types for int types\n         if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n             if ((_numTypesValid & NR_INT) != 0) {\n-                return Integer.valueOf(_numberInt);\n+                return _numberInt;\n             }\n             if ((_numTypesValid & NR_LONG) != 0) {\n-                return Long.valueOf(_numberLong);\n+                return _numberLong;\n             }\n             if ((_numTypesValid & NR_BIGINT) != 0) {\n                 return _numberBigInt;\n         if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check\n             _throwInternal();\n         }\n-        return Double.valueOf(_numberDouble);\n+        return _numberDouble;\n     }\n     \n     @Override\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n     \n-    private final void _parseSlowFloatValue(int expType)\n+    private void _parseSlowFloatValue(int expType)\n         throws IOException, JsonParseException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n         }\n     }\n     \n-    private final void _parseSlowIntValue(int expType, char[] buf, int offset, int len)\n+    private void _parseSlowIntValue(int expType, char[] buf, int offset, int len)\n         throws IOException, JsonParseException\n     {\n         String numStr = _textBuffer.contentsAsString();\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n                 {\n                     Object value = this.getEmbeddedObject();\n                     if (value instanceof Boolean) {\n-                        return ((Boolean) value).booleanValue();\n+                        return (Boolean) value;\n                     }\n                 }\n             case VALUE_STRING:\n--- a/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n      * Since this may result in more content to be read (at least\n      * one more byte), a {@link IOException} may get thrown.\n      */\n-    public boolean hasMoreBytes() throws IOException;\n+    boolean hasMoreBytes() throws IOException;\n \n     /**\n      * Returns next byte available, if any; if no more bytes are\n      * available, will throw {@link java.io.EOFException}.\n      */\n-    public byte nextByte() throws IOException;\n+    byte nextByte() throws IOException;\n \n     /**\n      * Method that can be called to reset accessor to read from beginning\n      * of input.\n      */\n-    public void reset();\n+    void reset();\n \n     /*\n     /**********************************************************\n      * Basic implementation that reads data from given\n      * {@link InputStream} and buffers it as necessary.\n      */\n-    public class Std implements InputAccessor\n+    class Std implements InputAccessor\n     {\n         protected final InputStream _in;\n \n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n         }\n     }\n \n-    public final static int[] getInputCodeLatin1() { return sInputCodes; }\n-    public final static int[] getInputCodeUtf8() { return sInputCodesUtf8; }\n-\n-    public final static int[] getInputCodeLatin1JsNames() { return sInputCodesJsNames; }\n-    public final static int[] getInputCodeUtf8JsNames() { return sInputCodesUtf8JsNames; }\n-\n-    public final static int[] getInputCodeComment() { return sInputCodesComment; }\n+    public static int[] getInputCodeLatin1() { return sInputCodes; }\n+    public static int[] getInputCodeUtf8() { return sInputCodesUtf8; }\n+\n+    public static int[] getInputCodeLatin1JsNames() { return sInputCodesJsNames; }\n+    public static int[] getInputCodeUtf8JsNames() { return sInputCodesUtf8JsNames; }\n+\n+    public static int[] getInputCodeComment() { return sInputCodesComment; }\n     \n     /**\n      * Accessor for getting a read-only encoding table for first 128 Unicode\n      * to use after backslash; and negative values that generic (backslash - u)\n      * escaping is to be used.\n      */\n-    public final static int[] get7BitOutputEscapes() { return sOutputEscapes128; }\n+    public static int[] get7BitOutputEscapes() { return sOutputEscapes128; }\n \n     public static int charToHex(int ch)\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n     /**********************************************************\n      */\n \n-    public final Object getSourceReference() { return _sourceRef; }\n-    public final JsonEncoding getEncoding() { return _encoding; }\n-    public final boolean isResourceManaged() { return _managedResource; }\n+    public Object getSourceReference() { return _sourceRef; }\n+    public JsonEncoding getEncoding() { return _encoding; }\n+    public boolean isResourceManaged() { return _managedResource; }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    public final TextBuffer constructTextBuffer() {\n+    public TextBuffer constructTextBuffer() {\n         return new TextBuffer(_bufferRecycler);\n     }\n \n      * Note: the method can only be called once during its life cycle.\n      * This is to protect against accidental sharing.\n      */\n-    public final byte[] allocReadIOBuffer()\n+    public byte[] allocReadIOBuffer()\n     {\n         if (_readIOBuffer != null) {\n             throw new IllegalStateException(\"Trying to call allocReadIOBuffer() second time\");\n         return _readIOBuffer;\n     }\n \n-    public final byte[] allocWriteEncodingBuffer()\n+    public byte[] allocWriteEncodingBuffer()\n     {\n         if (_writeEncodingBuffer != null) {\n             throw new IllegalStateException(\"Trying to call allocWriteEncodingBuffer() second time\");\n     /**\n      * @since 2.1\n      */\n-    public final byte[] allocBase64Buffer()\n+    public byte[] allocBase64Buffer()\n     {\n         if (_base64Buffer != null) {\n             throw new IllegalStateException(\"Trying to call allocBase64Buffer() second time\");\n         return _base64Buffer;\n     }\n     \n-    public final char[] allocTokenBuffer()\n+    public char[] allocTokenBuffer()\n     {\n         if (_tokenCBuffer != null) {\n             throw new IllegalStateException(\"Trying to call allocTokenBuffer() second time\");\n         return _tokenCBuffer;\n     }\n \n-    public final char[] allocConcatBuffer()\n+    public char[] allocConcatBuffer()\n     {\n         if (_concatCBuffer != null) {\n             throw new IllegalStateException(\"Trying to call allocConcatBuffer() second time\");\n         return _concatCBuffer;\n     }\n \n-    public final char[] allocNameCopyBuffer(int minSize)\n+    public char[] allocNameCopyBuffer(int minSize)\n     {\n         if (_nameCopyBuffer != null) {\n             throw new IllegalStateException(\"Trying to call allocNameCopyBuffer() second time\");\n      * Method to call when all the processing buffers can be safely\n      * recycled.\n      */\n-    public final void releaseReadIOBuffer(byte[] buf)\n+    public void releaseReadIOBuffer(byte[] buf)\n     {\n         if (buf != null) {\n             /* Let's do sanity checks to ensure once-and-only-once release,\n         }\n     }\n \n-    public final void releaseWriteEncodingBuffer(byte[] buf)\n+    public void releaseWriteEncodingBuffer(byte[] buf)\n     {\n         if (buf != null) {\n             /* Let's do sanity checks to ensure once-and-only-once release,\n         }\n     }\n \n-    public final void releaseBase64Buffer(byte[] buf)\n+    public void releaseBase64Buffer(byte[] buf)\n     {\n         if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n             if (buf != _base64Buffer) {\n         }\n     }\n     \n-    public final void releaseTokenBuffer(char[] buf)\n+    public void releaseTokenBuffer(char[] buf)\n     {\n         if (buf != null) {\n             if (buf != _tokenCBuffer) {\n         }\n     }\n \n-    public final void releaseConcatBuffer(char[] buf)\n+    public void releaseConcatBuffer(char[] buf)\n     {\n         if (buf != null) {\n             if (buf != _concatCBuffer) {\n         }\n     }\n \n-    public final void releaseNameCopyBuffer(char[] buf)\n+    public void releaseNameCopyBuffer(char[] buf)\n     {\n         if (buf != null) {\n             if (buf != _nameCopyBuffer) {\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n      *<p>\n      * Note: public to let unit tests call it\n      */\n-    public final static int parseInt(char[] digitChars, int offset, int len)\n+    public static int parseInt(char[] digitChars, int offset, int len)\n     {\n         int num = digitChars[offset] - '0';\n         len += offset;\n      * Helper method to (more) efficiently parse integer numbers from\n      * String values.\n      */\n-    public final static int parseInt(String str)\n+    public static int parseInt(String str)\n     {\n         /* Ok: let's keep strategy simple: ignoring optional minus sign,\n          * we'll accept 1 - 9 digits and parse things efficiently;\n         return negative ? -num : num;\n     }\n     \n-    public final static long parseLong(char[] digitChars, int offset, int len)\n+    public static long parseLong(char[] digitChars, int offset, int len)\n     {\n         // Note: caller must ensure length is [10, 18]\n         int len1 = len-9;\n         return val + (long) parseInt(digitChars, offset+len1, 9);\n     }\n \n-    public final static long parseLong(String str)\n+    public static long parseLong(String str)\n     {\n         /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n          * that is, if we know they must be ints, call int parsing\n      * @param negative Whether original number had a minus sign (which is\n      *    NOT passed to this method) or not\n      */\n-    public final static boolean inLongRange(char[] digitChars, int offset, int len,\n+    public static boolean inLongRange(char[] digitChars, int offset, int len,\n             boolean negative)\n     {\n         String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n      * @param negative Whether original number had a minus sign (which is\n      *    NOT passed to this method) or not\n      */\n-    public final static boolean inLongRange(String numberStr, boolean negative)\n+    public static boolean inLongRange(String numberStr, boolean negative)\n     {\n         String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n         int cmpLen = cmpStr.length();\n         return defaultValue;\n     }\n     \n-    public final static double parseDouble(String numStr) throws NumberFormatException\n+    public static double parseDouble(String numStr) throws NumberFormatException\n     {\n         // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n         /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n         return MatchStrength.NO_MATCH;\n     }\n \n-    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n+    private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n         throws IOException\n     {\n         for (int i = 0, len = matchStr.length(); i < len; ++i) {\n         return fullMatchStrength;\n     }\n     \n-    private final static int skipSpace(InputAccessor acc) throws IOException\n+    private static int skipSpace(InputAccessor acc) throws IOException\n     {\n         if (!acc.hasMoreBytes()) {\n             return -1;\n         return skipSpace(acc, acc.nextByte());\n     }\n     \n-    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n+    private static int skipSpace(InputAccessor acc, byte b) throws IOException\n     {\n         while (true) {\n             int ch = (int) b & 0xFF;\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n         _index = -1;\n     }\n \n-    protected final void reset(int type, int lineNr, int colNr)\n+    protected void reset(int type, int lineNr, int colNr)\n     {\n         _type = type;\n         _index = -1;\n         return new JsonReadContext(null, TYPE_ROOT, 1, 0);\n     }\n     \n-    public final JsonReadContext createChildArrayContext(int lineNr, int colNr)\n+    public JsonReadContext createChildArrayContext(int lineNr, int colNr)\n     {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n         return ctxt;\n     }\n \n-    public final JsonReadContext createChildObjectContext(int lineNr, int colNr)\n+    public JsonReadContext createChildObjectContext(int lineNr, int colNr)\n     {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n      */\n \n     @Override\n-    public final String getCurrentName() { return _currentName; }\n+    public String getCurrentName() { return _currentName; }\n \n     @Override\n-    public final JsonReadContext getParent() { return _parent; }\n+    public JsonReadContext getParent() { return _parent; }\n \n     /*\n     /**********************************************************\n      * @return Location pointing to the point where the context\n      *   start marker was found\n      */\n-    public final JsonLocation getStartLocation(Object srcRef)\n+    public JsonLocation getStartLocation(Object srcRef)\n     {\n         /* We don't keep track of offsets at this level (only\n          * reader does)\n     /**********************************************************\n      */\n \n-    public final boolean expectComma()\n+    public boolean expectComma()\n     {\n         /* Assumption here is that we will be getting a value (at least\n          * before calling this method again), and\n      * of the context.\n      */\n     @Override\n-    public final String toString()\n+    public String toString()\n     {\n         StringBuilder sb = new StringBuilder(64);\n         switch (_type) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n         return new JsonWriteContext(TYPE_ROOT, null);\n     }\n \n-    private final JsonWriteContext reset(int type) {\n+    private JsonWriteContext reset(int type) {\n         _type = type;\n         _index = -1;\n         _currentName = null;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     }\n \n     @Override\n-    protected final boolean loadMore() throws IOException\n+    protected boolean loadMore() throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n         _currInputRowStart -= _inputEnd;\n         return false;\n     }\n \n-    protected final char getNextChar(String eofMsg)\n+    protected char getNextChar(String eofMsg)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n      * Method can be called for any event.\n      */\n     @Override\n-    public final String getText()\n+    public String getText()\n         throws IOException, JsonParseException\n     {\n         JsonToken t = _currToken;\n     }\n     \n     \n-    protected final String _getText2(JsonToken t)\n+    protected String _getText2(JsonToken t)\n     {\n         if (t == null) {\n             return null;\n         return t;\n     }\n \n-    private final JsonToken _nextAfterName()\n+    private JsonToken _nextAfterName()\n     {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected final JsonToken parseNumberText(int ch)\n+    protected JsonToken parseNumberText(int ch)\n         throws IOException, JsonParseException\n     {\n         /* Although we will always be complete with respect to textual\n      * that it has to explicitly copy contents to the text buffer\n      * instead of just sharing the main input buffer.\n      */\n-    private final JsonToken parseNumberText2(boolean negative)\n+    private JsonToken parseNumberText2(boolean negative)\n         throws IOException, JsonParseException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private final char _verifyNoLeadingZeroes()\n+    private char _verifyNoLeadingZeroes()\n         throws IOException, JsonParseException\n     {\n         // Ok to have plain \"0\"\n     /**********************************************************\n      */\n \n-    protected final String _parseFieldName(int i)\n+    protected String _parseFieldName(int i)\n         throws IOException, JsonParseException\n     {\n         if (i != INT_QUOTE) {\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected final String _handleUnusualFieldName(int i)\n+    protected String _handleUnusualFieldName(int i)\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-173]: allow single quotes\n         return _parseUnusualFieldName2(start, hash, codes);\n     }\n \n-    protected final String _parseApostropheFieldName()\n+    protected String _parseApostropheFieldName()\n         throws IOException, JsonParseException\n     {\n         // Note: mostly copy of_parseFieldName\n      * Method for handling cases where first non-space character\n      * of an expected value token is not legal for standard JSON content.\n      */\n-    protected final JsonToken _handleUnexpectedValue(int i)\n+    protected JsonToken _handleUnexpectedValue(int i)\n         throws IOException, JsonParseException\n     {\n         // Most likely an error, unless we are to allow single-quote-strings\n         return null;\n     }\n     \n-    protected final JsonToken _handleApostropheValue()\n+    protected JsonToken _handleApostropheValue()\n         throws IOException, JsonParseException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected final void _skipCR() throws IOException\n+    protected void _skipCR() throws IOException\n     {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == '\\n') {\n         _currInputRowStart = _inputPtr;\n     }\n \n-    protected final void _skipLF() throws IOException\n+    protected void _skipLF() throws IOException\n     {\n         ++_currInputRow;\n         _currInputRowStart = _inputPtr;\n     }\n \n-    private final int _skipWS()\n+    private int _skipWS()\n         throws IOException, JsonParseException\n     {\n         while (_inputPtr < _inputEnd || loadMore()) {\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n \n-    private final int _skipWSOrEnd()\n+    private int _skipWSOrEnd()\n         throws IOException, JsonParseException\n     {\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n         return -1;\n     }\n \n-    private final void _skipComment()\n+    private void _skipComment()\n         throws IOException, JsonParseException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n         }\n     }\n \n-    private final void _skipCComment()\n+    private void _skipCComment()\n         throws IOException, JsonParseException\n     {\n         // Ok: need the matching '*/'\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private final void _skipCppComment()\n+    private void _skipCppComment()\n         throws IOException, JsonParseException\n     {\n         // Ok: need to find EOF or linefeed\n     }\n \n     @Override\n-    protected final char _decodeEscaped()\n+    protected char _decodeEscaped()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n     /**\n      * Helper method for checking whether input matches expected token\n      */\n-    protected final void _matchToken(String matchStr, int i)\n+    protected void _matchToken(String matchStr, int i)\n         throws IOException, JsonParseException\n     {\n         final int len = matchStr.length();\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n     \n-    private final void _writeLongString(String text)\n+    private void _writeLongString(String text)\n         throws IOException, JsonGenerationException\n     {\n         if (_outputTail >= _outputEnd) {\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n \n-    private final void _writeLongString(char[] text, int offset, int len)\n+    private void _writeLongString(char[] text, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         if (_outputTail >= _outputEnd) {\n      * Helper method called when it is possible that output of raw section\n      * to output may cross buffer boundary\n      */\n-    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len)\n+    private void _writeSegmentedRaw(char[] cbuf, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         final int end = _outputEnd;\n         _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n     }\n \n-    private final void _writeQuotedInt(int i) throws IOException {\n+    private void _writeQuotedInt(int i) throws IOException {\n         if ((_outputTail + 13) >= _outputEnd) {\n             _flushBuffer();\n         }\n         _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n     }\n \n-    private final void _writeQuotedLong(long l) throws IOException {\n+    private void _writeQuotedLong(long l) throws IOException {\n         if ((_outputTail + 23) >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n     }\n \n-    private final void _writeQuotedRaw(Object value) throws IOException\n+    private void _writeQuotedRaw(Object value) throws IOException\n     {\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     /**********************************************************\n      */\n \n-    private final void _writeBytes(byte[] bytes) throws IOException\n+    private void _writeBytes(byte[] bytes) throws IOException\n     {\n         final int len = bytes.length;\n         if ((_outputTail + len) > _outputEnd) {\n         _outputTail += len;\n     }\n \n-    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n+    private void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n     {\n         if ((_outputTail + len) > _outputEnd) {\n             _flushBuffer();\n      * to single-segment writes (instead of maximum slices that\n      * would fit in copy buffer)\n      */\n-    private final void _writeStringSegments(String text)\n+    private void _writeStringSegments(String text)\n         throws IOException, JsonGenerationException\n     {\n         int left = text.length();\n      * the output buffer. If so, we will need to choose smaller output\n      * chunks to write at a time.\n      */\n-    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen)\n+    private void _writeStringSegments(char[] cbuf, int offset, int totalLen)\n         throws IOException, JsonGenerationException\n     {\n         do {\n      * assuming case of all non-escaped ASCII characters, as well as\n      * potentially enough space for other cases (but not necessarily flushed)\n      */\n-    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n+    private void _writeStringSegment(char[] cbuf, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         // note: caller MUST ensure (via flushing) there's room for ASCII only\n      * Secondary method called when content contains characters to escape,\n      * and/or multi-byte UTF-8 characters.\n      */\n-    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end)\n+    private void _writeStringSegment2(final char[] cbuf, int offset, final int end)\n         throws IOException, JsonGenerationException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n      * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n      * additional escaping for high-range code points\n      */\n-    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end)\n+    private void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end)\n         throws IOException, JsonGenerationException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n      * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n      * additional checking for completely custom escapes\n      */\n-    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n+    private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n         throws IOException, JsonGenerationException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n      * to fit in the output buffer after escaping; as such, we just need to\n      * chunk writes.\n      */\n-    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n+    private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n         throws IOException, JsonGenerationException\n     {\n         do {\n         } while (totalLen > 0);\n     }\n     \n-    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n+    private void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n         throws IOException, JsonGenerationException\n     {\n         // fast loop to see if escaping is needed; don't copy, just look\n         _outputTail += len;\n     }\n \n-    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n+    private void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         int outputPtr = _outputTail;\n      * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n      * text (meaning it is not to be escaped or quoted)\n      */\n-    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen)\n+    private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen)\n         throws IOException\n     {\n         // Let's handle surrogates gracefully (as 4 byte output):\n      * \n      * @throws IOException\n      */\n-    private final int _outputMultiByteChar(int ch, int outputPtr)\n+    private int _outputMultiByteChar(int ch, int outputPtr)\n         throws IOException\n     {\n         byte[] bbuf = _outputBuffer;\n         return c;\n     }\n     \n-    private final void _writeNull() throws IOException\n+    private void _writeNull() throws IOException\n     {\n         if ((_outputTail + 4) >= _outputEnd) {\n             _flushBuffer();\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      */\n \n     @Override\n-    protected final boolean loadMore()\n+    protected boolean loadMore()\n         throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected final boolean _loadToHaveAtLeast(int minAvailable)\n+    protected boolean _loadToHaveAtLeast(int minAvailable)\n         throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         return super.getValueAsString(defValue);\n     }\n     \n-    protected final String _getText2(JsonToken t)\n+    protected String _getText2(JsonToken t)\n     {\n         if (t == null) {\n             return null;\n         return _currToken;\n     }\n \n-    private final JsonToken _nextTokenNotInObject(int i)\n+    private JsonToken _nextTokenNotInObject(int i)\n         throws IOException, JsonParseException\n     {\n         if (i == INT_QUOTE) {\n         return (_currToken = _handleUnexpectedValue(i));\n     }\n     \n-    private final JsonToken _nextAfterName()\n+    private JsonToken _nextAfterName()\n     {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n         return false;\n     }\n \n-    private final void _isNextTokenNameYes()\n+    private void _isNextTokenNameYes()\n         throws IOException, JsonParseException\n     {\n         // very first thing: common case, colon, value, no white space\n         _nextToken = _handleUnexpectedValue(i);\n     }\n     \n-    private final void _isNextTokenNameNo(int i)\n+    private void _isNextTokenNameNo(int i)\n             throws IOException, JsonParseException\n     {\n         // // // and this is back to standard nextToken()\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected final JsonToken parseNumberText(int c)\n+    protected JsonToken parseNumberText(int c)\n         throws IOException, JsonParseException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n      * Method called to handle parsing when input is split across buffer boundary\n      * (or output is longer than segment used to store it)\n      */\n-    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n+    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n             int intPartLength)\n         throws IOException, JsonParseException\n     {\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private final int _verifyNoLeadingZeroes()\n+    private int _verifyNoLeadingZeroes()\n         throws IOException, JsonParseException\n     {\n         // Ok to have plain \"0\"\n         return ch;\n     }\n     \n-    private final JsonToken _parseFloatText(char[] outBuf, int outPtr, int c,\n+    private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c,\n             boolean negative, int integerPartLength)\n         throws IOException, JsonParseException\n     {\n     /**********************************************************\n      */\n     \n-    protected final Name _parseFieldName(int i)\n+    protected Name _parseFieldName(int i)\n         throws IOException, JsonParseException\n     {\n         if (i != INT_QUOTE) {\n         return parseFieldName(0, q, 0); // quoting or invalid char\n     }\n \n-    protected final Name parseMediumFieldName(int q2, final int[] codes)\n+    protected Name parseMediumFieldName(int q2, final int[] codes)\n         throws IOException, JsonParseException\n     {\n         // Ok, got 5 name bytes so far\n         return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private final Name parseFieldName(int q1, int ch, int lastQuadBytes)\n+    private Name parseFieldName(int q1, int ch, int lastQuadBytes)\n         throws IOException, JsonParseException\n     {\n         return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private final Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes)\n+    private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes)\n         throws IOException, JsonParseException\n     {\n         _quadBuffer[0] = q1;\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected final Name _handleUnusualFieldName(int ch)\n+    protected Name _handleUnusualFieldName(int ch)\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-173]: allow single quotes\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected final Name _parseApostropheFieldName()\n+    protected Name _parseApostropheFieldName()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes)\n+    private Name findName(int q1, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes)\n+    private Name findName(int q1, int q2, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n+    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n         throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n+    private Name addName(int[] quads, int qlen, int lastQuadBytes)\n         throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n         _finishString2(outBuf, outPtr);\n     }\n \n-    private final void _finishString2(char[] outBuf, int outPtr)\n+    private void _finishString2(char[] outBuf, int outPtr)\n         throws IOException, JsonParseException\n     {\n         int c;\n         return null;\n     }\n \n-    protected final void _matchToken(String matchStr, int i)\n+    protected void _matchToken(String matchStr, int i)\n         throws IOException, JsonParseException\n     {\n         final int len = matchStr.length();\n     /**********************************************************\n      */\n \n-    private final int _skipWS()\n+    private int _skipWS()\n         throws IOException, JsonParseException\n     {\n         while (_inputPtr < _inputEnd || loadMore()) {\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n \n-    private final int _skipWSOrEnd()\n+    private int _skipWSOrEnd()\n         throws IOException, JsonParseException\n     {\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n      * Helper method for matching and skipping a colon character,\n      * optionally surrounded by white space\n      */\n-    private final int _skipColon()\n+    private int _skipColon()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n     \n-    private final void _skipComment()\n+    private void _skipComment()\n         throws IOException, JsonParseException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n         }\n     }\n \n-    private final void _skipCComment()\n+    private void _skipCComment()\n         throws IOException, JsonParseException\n     {\n         // Need to be UTF-8 aware here to decode content (for skipping)\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private final void _skipCppComment()\n+    private void _skipCppComment()\n         throws IOException, JsonParseException\n     {\n         // Ok: need to find EOF or linefeed\n     }\n \n     @Override\n-    protected final char _decodeEscaped()\n+    protected char _decodeEscaped()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n     /**********************************************************\n      */\n \n-    private final int _decodeUtf8_2(int c)\n+    private int _decodeUtf8_2(int c)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         return ((c & 0x1F) << 6) | (d & 0x3F);\n     }\n \n-    private final int _decodeUtf8_3(int c1)\n+    private int _decodeUtf8_3(int c1)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         return c;\n     }\n \n-    private final int _decodeUtf8_3fast(int c1)\n+    private int _decodeUtf8_3fast(int c1)\n         throws IOException, JsonParseException\n     {\n         c1 &= 0x0F;\n      * @return Character value <b>minus 0x10000</c>; this so that caller\n      *    can readily expand it to actual surrogates\n      */\n-    private final int _decodeUtf8_4(int c)\n+    private int _decodeUtf8_4(int c)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         return ((c << 6) | (d & 0x3F)) - 0x10000;\n     }\n \n-    private final void _skipUtf8_2(int c)\n+    private void _skipUtf8_2(int c)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n     /* Alas, can't heavily optimize skipping, since we still have to\n      * do validity checks...\n      */\n-    private final void _skipUtf8_3(int c)\n+    private void _skipUtf8_3(int c)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         }\n     }\n \n-    private final void _skipUtf8_4(int c)\n+    private void _skipUtf8_4(int c)\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected final void _skipCR() throws IOException\n+    protected void _skipCR() throws IOException\n     {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == BYTE_LF) {\n         _currInputRowStart = _inputPtr;\n     }\n \n-    protected final void _skipLF() throws IOException\n+    protected void _skipLF() throws IOException\n     {\n         ++_currInputRow;\n         _currInputRowStart = _inputPtr;\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n      */\n \n     @Override\n-    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    public void writeFieldName(String name)  throws IOException, JsonGenerationException\n     {\n         int status = _writeContext.writeFieldName(name);\n         if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n     }\n \n     @Override\n-    public final void writeFieldName(SerializableString name)\n+    public void writeFieldName(SerializableString name)\n         throws IOException, JsonGenerationException\n     {\n         // Object is a value, need to verify it's allowed\n      */\n \n     @Override\n-    public final void writeStartArray() throws IOException, JsonGenerationException\n+    public void writeStartArray() throws IOException, JsonGenerationException\n     {\n         _verifyValueWrite(\"start an array\");\n         _writeContext = _writeContext.createChildArrayContext();\n     }\n \n     @Override\n-    public final void writeEndArray() throws IOException, JsonGenerationException\n+    public void writeEndArray() throws IOException, JsonGenerationException\n     {\n         if (!_writeContext.inArray()) {\n             _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n     }\n \n     @Override\n-    public final void writeStartObject() throws IOException, JsonGenerationException\n+    public void writeStartObject() throws IOException, JsonGenerationException\n     {\n         _verifyValueWrite(\"start an object\");\n         _writeContext = _writeContext.createChildObjectContext();\n     }\n \n     @Override\n-    public final void writeEndObject() throws IOException, JsonGenerationException\n+    public void writeEndObject() throws IOException, JsonGenerationException\n     {\n         if (!_writeContext.inObject()) {\n             _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n      * Specialized version of <code>_writeFieldName</code>, off-lined\n      * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n      */\n-    protected final void _writePPFieldName(String name, boolean commaBefore)\n+    protected void _writePPFieldName(String name, boolean commaBefore)\n         throws IOException, JsonGenerationException\n     {\n         if (commaBefore) {\n         }\n     }\n \n-    protected final void _writePPFieldName(SerializableString name, boolean commaBefore)\n+    protected void _writePPFieldName(SerializableString name, boolean commaBefore)\n         throws IOException, JsonGenerationException\n     {\n         if (commaBefore) {\n     }\n \n     @Override\n-    public final void writeString(SerializableString sstr)\n+    public void writeString(SerializableString sstr)\n         throws IOException, JsonGenerationException\n     {\n         _verifyValueWrite(\"write text value\");\n         _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n     }\n \n-    private final void _writeQuotedInt(int i) throws IOException {\n+    private void _writeQuotedInt(int i) throws IOException {\n         if ((_outputTail + 13) >= _outputEnd) {\n             _flushBuffer();\n         }\n         _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n     }\n \n-    private final void _writeQuotedLong(long l) throws IOException {\n+    private void _writeQuotedLong(long l) throws IOException {\n         if ((_outputTail + 23) >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n     }\n \n-    private final void _writeQuotedRaw(Object value) throws IOException\n+    private void _writeQuotedRaw(Object value) throws IOException\n     {\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n      */\n \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n+    protected void _verifyValueWrite(String typeMsg)\n         throws IOException, JsonGenerationException\n     {\n         int status = _writeContext.writeValue();\n         _verifyPrettyValueWrite(typeMsg, status);\n     }\n \n-    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n+    protected void _verifyPrettyValueWrite(String typeMsg, int status)\n         throws IOException, JsonGenerationException\n     {\n         // If we have a pretty printer, it knows what to do:\n      */\n \n     @Override\n-    public final void flush()\n+    public void flush()\n         throws IOException\n     {\n         _flushBuffer();\n      * buffer, right after buffered content (if any). That's why only\n      * length of that text is passed, as buffer and offset are implied.\n      */\n-    private final void _writeSegment(int end)\n+    private void _writeSegment(int end)\n         throws IOException, JsonGenerationException\n     {\n         final int[] escCodes = _outputEscapes;\n      * This method called when the string content is already in\n      * a char buffer, and need not be copied for processing.\n      */\n-    private final void _writeString(char[] text, int offset, int len)\n+    private void _writeString(char[] text, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         if (_characterEscapes != null) {\n         }\n     }\n \n-    private final void _writeSegmentASCII(int end, final int maxNonEscaped)\n+    private void _writeSegmentASCII(int end, final int maxNonEscaped)\n         throws IOException, JsonGenerationException\n     {\n         final int[] escCodes = _outputEscapes;\n         }\n     }\n \n-    private final void _writeStringASCII(char[] text, int offset, int len,\n+    private void _writeStringASCII(char[] text, int offset, int len,\n             final int maxNonEscaped)\n         throws IOException, JsonGenerationException\n     {\n         }\n     }\n \n-    private final void _writeSegmentCustom(int end)\n+    private void _writeSegmentCustom(int end)\n         throws IOException, JsonGenerationException\n     {\n         final int[] escCodes = _outputEscapes;\n         }\n     }\n \n-    private final void _writeStringCustom(char[] text, int offset, int len)\n+    private void _writeStringCustom(char[] text, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         len += offset; // -> len marks the end from now on\n     /**********************************************************\n      */\n     \n-    private final void _writeNull() throws IOException\n+    private void _writeNull() throws IOException\n     {\n         if ((_outputTail + 4) >= _outputEnd) {\n             _flushBuffer();\n      * given buffer; or if not possible, to write it out directly.\n      * Uses head and tail pointers (and updates as necessary)\n      */\n-    private final void _prependOrWriteCharacterEscape(char ch, int escCode)\n+    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n         throws IOException, JsonGenerationException\n     {\n         if (escCode >= 0) { // \\\\N (2 char)\n      * @return Pointer to start of prepended entity (if prepended); or 'ptr'\n      *   if not.\n      */\n-    private final int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n+    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n             char ch, int escCode)\n         throws IOException, JsonGenerationException\n     {\n      * Method called to append escape sequence for given character, at the\n      * end of standard output buffer; or if not possible, write out directly.\n      */\n-    private final void _appendCharacterEscape(char ch, int escCode)\n+    private void _appendCharacterEscape(char ch, int escCode)\n         throws IOException, JsonGenerationException\n     {\n         if (escCode >= 0) { // \\\\N (2 char)\n         return buf;\n     }\n     \n-    protected final void _flushBuffer() throws IOException\n+    protected void _flushBuffer() throws IOException\n     {\n         int len = _outputTail - _outputHead;\n         if (len > 0) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n          */\n         long now = System.currentTimeMillis();\n         // ensure it's not 0; and might as well require to be odd so:\n-        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n+        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n         return createRoot(seed);\n     }\n \n     private final static int MULT2 = 65599;\n     private final static int MULT3 = 31;\n     \n-    public final int calcHash(int firstQuad)\n+    public int calcHash(int firstQuad)\n     {\n         int hash = firstQuad ^ _hashSeed;\n         hash += (hash >>> 15); // to xor hi- and low- 16-bits\n         return hash;\n     }\n \n-    public final int calcHash(int firstQuad, int secondQuad)\n+    public int calcHash(int firstQuad, int secondQuad)\n     {\n         /* For two quads, let's change algorithm a bit, to spice\n          * things up (can do bit more processing anyway)\n         return hash;\n     }\n \n-    public final int calcHash(int[] quads, int qlen)\n+    public int calcHash(int[] quads, int qlen)\n     {\n         // Note: may be called for qlen < 3; but has at least one int\n         if (qlen < 3) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n          */\n         long now = System.currentTimeMillis();\n         // ensure it's not 0; and might as well require to be odd so:\n-        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n+        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n         return createRoot(seed);\n     }\n     \n         _sizeThreshold = _thresholdSize(initialSize);\n     }\n \n-    private final static int _thresholdSize(int hashAreaSize) {\n+    private static int _thresholdSize(int hashAreaSize) {\n         return hashAreaSize - (hashAreaSize >> 2);\n     }\n     \n      * Helper method that takes in a \"raw\" hash value, shuffles it as necessary,\n      * and truncates to be used as the index.\n      */\n-    public final int _hashToIndex(int rawHash)\n+    public int _hashToIndex(int rawHash)\n     {\n         rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests\n         return (rawHash & _indexMask);\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n         mQuad = quad;\n     }\n \n-    final static Name1 getEmptyName() { return sEmptyName; }\n+    static Name1 getEmptyName() { return sEmptyName; }\n \n     @Override\n     public boolean equals(int quad)\n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n     /**********************************************************\n      */\n \n-    private final byte[] balloc(int size)\n+    private byte[] balloc(int size)\n     {\n         return new byte[size];\n     }\n \n-    private final char[] calloc(int size)\n+    private char[] calloc(int size)\n     {\n         return new char[size];\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      */\n     public interface Indenter\n     {\n-        public void writeIndentation(JsonGenerator jg, int level)\n+        void writeIndentation(JsonGenerator jg, int level)\n             throws IOException, JsonGenerationException;\n \n         /**\n          * @return True if indenter is considered inline (does not add linefeeds),\n          *   false otherwise\n          */\n-        public boolean isInline();\n+        boolean isInline();\n     }\n     \n     // // // Config, indentation\n--- a/src/main/java/com/fasterxml/jackson/core/util/Instantiatable.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/Instantiatable.java\n      * it is either this object (if stateless), or a newly created object\n      * with separate state.\n      */\n-    public T createInstance();\n+    T createInstance();\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n      * Helper method used to find a buffer to use, ideally one\n      * recycled earlier.\n      */\n-    private final char[] findBuffer(int needed)\n+    private char[] findBuffer(int needed)\n     {\n         if (_allocator != null) {\n             return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed);\n         return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n     }\n \n-    private final void clearSegments()\n+    private void clearSegments()\n     {\n         _hasSegments = false;\n         /* Let's start using _last_ segment from list; for one, it's\n         return _currentSegment;\n     }\n \n-    public final char[] emptyAndGetCurrentSegment()\n+    public char[] emptyAndGetCurrentSegment()\n     {\n         // inlined 'resetWithEmpty()'\n         _inputStart = -1; // indicates shared buffer not used\n         return result;\n     }\n \n-    private final char[] _charArray(int len) {\n+    private char[] _charArray(int len) {\n         return new char[len];\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n         gen.writeStartArray();\n \n         // simple wrappers first\n-        gen.writeObject(Integer.valueOf(1));\n-        gen.writeObject(Short.valueOf((short)-2));\n-        gen.writeObject(Long.valueOf(3));\n-        gen.writeObject(Byte.valueOf((byte)-4));\n-        gen.writeObject(Double.valueOf(0.25));\n-        gen.writeObject(Float.valueOf(-0.125f));\n+        gen.writeObject(1);\n+        gen.writeObject((short) -2);\n+        gen.writeObject((long) 3);\n+        gen.writeObject((byte) -4);\n+        gen.writeObject(0.25);\n+        gen.writeObject(-0.125f);\n         gen.writeObject(Boolean.TRUE);\n         gen.close();\n         String act = sw.toString().trim();", "timestamp": 1348937982, "metainfo": ""}