{"sha": "9c135008cf2e9d56c6843cae359e4f12a61a6606", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n  */\n public final class BytesToNameCanonicalizer\n {\n-    protected static final int DEFAULT_TABLE_SIZE = 64;\n+    private static final int DEFAULT_T_SIZE = 64;\n \n     /**\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n      * with unique (~= random) names.\n      */\n-    protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n+    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 256k mem\n     \n     /**\n      * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n      * this corresponds to 64k main hash index. This should allow for enough distinct\n      * names for almost any case.\n      */\n-    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n     /**\n      * Also: to thwart attacks based on hash collisions (which may or may not\n      * \n      * @since 2.1\n      */\n-    final static int MAX_COLL_CHAIN_LENGTH = 255;\n+    private final static int MAX_COLL_CHAIN_LENGTH = 255;\n \n     /**\n      * And to support reduce likelihood of accidental collisions causing\n      * \n      * @since 2.1\n      */\n-    final private int _hashSeed;\n+    final private int _seed;\n     \n     /*\n     /**********************************************************\n     private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed)\n     {\n         _parent = null;\n-        _hashSeed = seed;\n+        _seed = seed;\n         _intern = intern;\n         // Sanity check: let's now allow hash sizes below certain minimum value\n         if (hashSize < MIN_HASH_SIZE) {\n             TableInfo state)\n     {\n         _parent = parent;\n-        _hashSeed = seed;\n+        _seed = seed;\n         _intern = intern;\n         _tableInfo = null; // not used by child tables\n \n      * value should remain the same.\n      */\n     protected static BytesToNameCanonicalizer createRoot(int hashSeed) {\n-        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed);\n+        return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, hashSeed);\n     }\n     \n     /**\n     public BytesToNameCanonicalizer makeChild(boolean canonicalize,\n         boolean intern)\n     {\n-        return new BytesToNameCanonicalizer(this, intern, _hashSeed, _tableInfo.get());\n+        return new BytesToNameCanonicalizer(this, intern, _seed, _tableInfo.get());\n     }\n \n     /**\n              * thing to happen)\n              */\n             // At any rate, need to clean up the tables\n-            childState = initTableInfo(DEFAULT_TABLE_SIZE);\n+            childState = initTableInfo(DEFAULT_T_SIZE);\n         }\n         _tableInfo.compareAndSet(currState, childState);\n     }\n     /**\n      * @since 2.1\n      */\n-    public int hashSeed() { return _hashSeed; }\n+    public int hashSeed() { return _seed; }\n     \n     /**\n      * Method mostly needed by unit tests; calculates number of\n     \n     public int calcHash(int firstQuad)\n     {\n-        int hash = firstQuad ^ _hashSeed;\n+        int hash = firstQuad ^ _seed;\n         hash += (hash >>> 15); // to xor hi- and low- 16-bits\n         hash ^= (hash >>> 9); // as well as lowest 2 bytes\n         return hash;\n         int hash = firstQuad;\n         hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n         hash += (secondQuad * MULT); // then add second quad\n-        hash ^= _hashSeed;\n+        hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n         return hash;\n     }\n          * add seed bit later in the game, and switch plus/xor around,\n          * use different shift lengths.\n          */\n-        int hash = quads[0] ^ _hashSeed;\n+        int hash = quads[0] ^ _seed;\n         hash += (hash >>> 9);\n         hash *= MULT;\n         hash += quads[1];\n         /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n          *    large documents with unique (or mostly so) names\n          */\n-        if (newLen > MAX_TABLE_SIZE) {\n+        if (newLen > MAX_T_SIZE) {\n             nukeSymbols();\n             return;\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n         q = quad;\n     }\n \n-    static Name1 getEmptyName() { return EMPTY; }\n+    public static Name1 getEmptyName() { return EMPTY; }\n \n     @Override public boolean equals(int quad) { return (quad == q); }\n     @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }", "timestamp": 1387000706, "metainfo": ""}