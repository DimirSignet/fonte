{"sha": "c01dc8c89d052dad51f20300b5abdfb86fc5f40c", "log": "reorg char-based number parsing a bit", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicate by a more specific error message.\n              */\n-            t = _parseNumber(i, true);\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n         case '7':\n         case '8':\n         case '9':\n-            t = _parseNumber(i, false);\n+            t = _parsePosNumber(i);\n             break;\n         default:\n             t = _handleOddValue(i);\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected final JsonToken _parseNumber(int ch, boolean neg) throws IOException\n+    protected final JsonToken _parsePosNumber(int ch) throws IOException\n     {\n         /* Although we will always be complete with respect to textual\n          * representation (that is, all characters will be parsed),\n         int startPtr = ptr-1; // to include sign/digit already read\n         final int inputLen = _inputEnd;\n \n-        if (neg) { // need to read the next digit\n-            if (ptr >= inputLen) {\n-                _inputPtr = neg ? (startPtr+1) : startPtr;\n-                return _parseNumber2(neg);\n-            }\n-            ch = _inputBuffer[ptr++];\n-            // First check: must have a digit to follow minus sign\n-            if (ch > INT_9 || ch < INT_0) {\n-                _inputPtr = ptr;\n-                return _handleInvalidNumberStart(ch, true);\n-            }\n-            /* (note: has been checked for non-negative already, in\n-             * the dispatching code that determined it should be\n-             * a numeric value)\n-             */\n-        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n-            _inputPtr = neg ? (startPtr+1) : startPtr;\n-            return _parseNumber2(neg);\n+            _inputPtr = startPtr;\n+            return _parseNumber2(false);\n         }\n             \n         /* First, let's see if the whole number is contained within\n         int_loop:\n         while (true) {\n             if (ptr >= inputLen) {\n-                _inputPtr = neg ? (startPtr+1) : startPtr;\n-                return _parseNumber2(neg);\n+                _inputPtr = startPtr;\n+                return _parseNumber2(false);\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n             fract_loop:\n             while (true) {\n                 if (ptr >= inputLen) {\n-                    _inputPtr = neg ? (startPtr+1) : startPtr;\n-                    return _parseNumber2(neg);\n+                    _inputPtr = startPtr;\n+                    return _parseNumber2(false);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n         int expLen = 0;\n         if (ch == 'e' || ch == 'E') { // and/or exponent\n             if (ptr >= inputLen) {\n-                _inputPtr = neg ? (startPtr+1) : startPtr;\n-                return _parseNumber2(neg);\n+                _inputPtr = startPtr;\n+                return _parseNumber2(false);\n             }\n             // Sign indicator?\n             ch = (int) _inputBuffer[ptr++];\n             if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                 if (ptr >= inputLen) {\n-                    _inputPtr = neg ? (startPtr+1) : startPtr;\n-                    return _parseNumber2(neg);\n+                    _inputPtr = startPtr;\n+                    return _parseNumber2(false);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    _inputPtr = neg ? (startPtr+1) : startPtr;\n-                    return _parseNumber2(neg);\n+                    _inputPtr = startPtr;\n+                    return _parseNumber2(false);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n         }\n         int len = ptr-startPtr;\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-        return reset(neg, intLen, fractLen, expLen);\n-    }\n-\n+        return reset(false, intLen, fractLen, expLen);\n+    }\n+\n+    protected final JsonToken _parseNegNumber() throws IOException\n+    {\n+        int ptr = _inputPtr;\n+        int startPtr = ptr-1; // to include sign/digit already read\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr >= inputLen) {\n+            _inputPtr = startPtr+1;\n+            return _parseNumber2(true);\n+        }\n+        int ch = _inputBuffer[ptr++];\n+        // First check: must have a digit to follow minus sign\n+        if (ch > INT_9 || ch < INT_0) {\n+            _inputPtr = ptr;\n+            return _handleInvalidNumberStart(ch, true);\n+        }\n+        // One special case, leading zero(es):\n+        if (ch == INT_0) {\n+            _inputPtr = startPtr+1;\n+            return _parseNumber2(true);\n+        }\n+        int intLen = 1; // already got one\n+        \n+        // First let's get the obligatory integer part:\n+        int_loop:\n+        while (true) {\n+            if (ptr >= inputLen) {\n+                _inputPtr = (startPtr+1);\n+                return _parseNumber2(true);\n+            }\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch < INT_0 || ch > INT_9) {\n+                break int_loop;\n+            }\n+            ++intLen;\n+        }\n+\n+        int fractLen = 0;\n+        // And then see if we get other parts\n+        if (ch == '.') { // yes, fraction\n+            fract_loop:\n+            while (true) {\n+                if (ptr >= inputLen) {\n+                    _inputPtr = (startPtr+1);\n+                    return _parseNumber2(true);\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+                if (ch < INT_0 || ch > INT_9) {\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+        int expLen = 0;\n+        if (ch == 'e' || ch == 'E') { // and/or exponent\n+            if (ptr >= inputLen) {\n+                _inputPtr = (startPtr+1);\n+                return _parseNumber2(true);\n+            }\n+            // Sign indicator?\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n+                if (ptr >= inputLen) {\n+                    _inputPtr = (startPtr+1);\n+                    return _parseNumber2(true);\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+            }\n+            while (ch <= INT_9 && ch >= INT_0) {\n+                ++expLen;\n+                if (ptr >= inputLen) {\n+                    _inputPtr = (startPtr+1);\n+                    return _parseNumber2(true);\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+        // Got it all: let's add to text buffer for parsing, access\n+        --ptr; // need to push back following separator\n+        _inputPtr = ptr;\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n+        int len = ptr-startPtr;\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+        return reset(true, intLen, fractLen, expLen);\n+    }\n+    \n     /**\n      * Method called to parse a number, when the primary parse\n      * method has failed to parse it, due to it being split on", "timestamp": 1399134960, "metainfo": ""}