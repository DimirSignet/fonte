{"sha": "579668cc5701db10ab7ecfa4dffd6246dfdfcf19", "log": "Merge pull request #170 from Scytl/master  Adds head operation in JsonPointer class. Resolves issue #169.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n  */\n public class JsonPointer\n {\n+\n+    protected final static int NO_SLASH = -1;\n+\n     /**\n      * Marker instance used to represent segment that matches current\n      * node or position.\n      * segment.\n      */\n     protected final JsonPointer _nextSegment;\n-    \n+\n+    /**\n+     * Reference form currently matching segment (if any) to node\n+     * before leaf.\n+     */\n+    protected final JsonPointer _headSegment;\n+\n     /**\n      * We will retain representation of the pointer, as a String,\n      * so that {@link #toString} should be as efficient as possible.\n      */\n     protected JsonPointer() {\n         _nextSegment = null;\n+        _headSegment = null;\n         _matchingPropertyName = \"\";\n         _matchingElementIndex = -1;\n         _asString = \"\";\n     /**\n      * Constructor used for creating non-empty Segments\n      */\n-    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n+    protected JsonPointer(String fullString, String segment, JsonPointer next, JsonPointer head) {\n         _asString = fullString;\n         _nextSegment = next;\n+        _headSegment = head;\n         // Ok; may always be a property\n         _matchingPropertyName = segment;\n         _matchingElementIndex = _parseIndex(segment);\n         if (input.charAt(0) != '/') {\n             throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n         }\n-        return _parseTail(input);\n+        return _parseTailAndHead(input);\n     }\n \n     /**\n     public JsonPointer tail() {\n         return _nextSegment;\n     }\n-    \n+\n+    /**\n+     * Accessor for getting a \"pointer\", instance from current segment to\n+     * segment before segment leaf.\n+     */\n+    public JsonPointer head() {\n+        return _headSegment;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Standard method overrides\n         return NumberInput.parseInt(str);\n     }\n     \n-    protected static JsonPointer _parseTail(String input) {\n+    protected static JsonPointer _parseTailAndHead(String input) {\n         final int end = input.length();\n+\n+        int lastSlash = input.lastIndexOf('/');\n \n         // first char is the contextual slash, skip\n         for (int i = 1; i < end; ) {\n             char c = input.charAt(i);\n             if (c == '/') { // common case, got a segment\n-                return new JsonPointer(input, input.substring(1, i),\n-                        _parseTail(input.substring(i)));\n+                if(i == NO_SLASH) {\n+                    return new JsonPointer(input, input.substring(1, i),\n+                            _parseTailAndHead(input.substring(i)), EMPTY);\n+                } else {\n+                    return new JsonPointer(input, input.substring(1, i),\n+                            _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n+                }\n             }\n             ++i;\n             // quoting is different; offline this case\n             if (c == '~' && i < end) { // possibly, quote\n-                return _parseQuotedTail(input, i);\n+                return _parseQuotedTailAndHead(input, i);\n             }\n             // otherwise, loop on\n         }\n         // end of the road, no escapes\n-        return new JsonPointer(input, input.substring(1), EMPTY);\n+        return new JsonPointer(input, input.substring(1), EMPTY, EMPTY);\n     }\n \n     /**\n      * @param input Full input for the tail being parsed\n      * @param i Offset to character after tilde\n      */\n-    protected static JsonPointer _parseQuotedTail(String input, int i) {\n+    protected static JsonPointer _parseQuotedTailAndHead(String input, int i) {\n         final int end = input.length();\n         StringBuilder sb = new StringBuilder(Math.max(16, end));\n         if (i > 2) {\n             sb.append(input, 1, i-1);\n         }\n         _appendEscape(sb, input.charAt(i++));\n+\n+        int lastSlash = input.lastIndexOf('/');\n+\n         while (i < end) {\n             char c = input.charAt(i);\n             if (c == '/') { // end is nigh!\n-                return new JsonPointer(input, sb.toString(),\n-                        _parseTail(input.substring(i))); // need to push back slash\n+                if(i == NO_SLASH) {\n+                    return new JsonPointer(input, sb.toString(),\n+                            _parseTailAndHead(input.substring(i)), EMPTY);\n+                } else {\n+                    return new JsonPointer(input, sb.toString(),\n+                            _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n+                }\n             }\n             ++i;\n             if (c == '~' && i < end) {\n             sb.append(c);\n         }\n         // end of the road, last segment\n-        return new JsonPointer(input, sb.toString(), EMPTY);\n+        return new JsonPointer(input, sb.toString(), EMPTY, EMPTY);\n     }\n     \n     private static void _appendEscape(StringBuilder sb, char c) {\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"Image\", ptr.getMatchingProperty());\n+        assertEquals(\"/Image/15\", ptr.head().toString());\n         assertEquals(INPUT, ptr.toString());\n \n         ptr = ptr.tail();\n         assertFalse(ptr.matches());\n         assertEquals(15, ptr.getMatchingIndex());\n         assertEquals(\"15\", ptr.getMatchingProperty());\n+        assertEquals(\"/15\", ptr.head().toString());\n         assertEquals(\"/15/name\", ptr.toString());\n \n         ptr = ptr.tail();\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"name\", ptr.getMatchingProperty());\n         assertEquals(\"/name\", ptr.toString());\n+        assertEquals(\"\", ptr.head().toString());\n \n         // done!\n         ptr = ptr.tail();\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"w/out\", ptr.getMatchingProperty());\n+        assertEquals(\"/w~1out/til~0de\", ptr.head().toString());\n         assertEquals(INPUT, ptr.toString());\n \n         ptr = ptr.tail();\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"til~de\", ptr.getMatchingProperty());\n+        assertEquals(\"/til~0de\", ptr.head().toString());\n         assertEquals(\"/til~0de/a~1b\", ptr.toString());\n \n         ptr = ptr.tail();\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"a/b\", ptr.getMatchingProperty());\n         assertEquals(\"/a~1b\", ptr.toString());\n+        assertEquals(\"\", ptr.head().toString());\n \n         // done!\n         ptr = ptr.tail();", "timestamp": 1417812246, "metainfo": ""}