{"sha": "53621fd6b5fa63f247b4da034acaaba8c0c88f16", "log": "add more 'medium' symbol support. Missing something, since symbols do not stick but...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n \n     private final Name findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n     {\n+        Name name = _symbols.findName(q1, q2, q3);\n+        if (name != null) {\n+            return name;\n+        }\n         int[] quads = _quadBuffer;\n         quads[0] = q1;\n         quads[1] = q2;\n         quads[2] = pad(q3, lastQuadBytes);\n-        Name name = _symbols.findName(quads, 3);\n-        if (name != null) {\n-            return name;\n-        }\n         return addName(quads, 3, lastQuadBytes);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n         return null;\n     }\n \n+    public Name findName(int q1, int q2, int q3)\n+    {\n+        int hash = calcHash(q1, q2, q3);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n+        \n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(q1, q2, q3)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, q1, q2, q3);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+    \n     /**\n      * Finds and returns name matching the specified symbol, if such\n      * name already exists in the table; or if not, creates name object,\n      */\n     public Name findName(int[] q, int qlen)\n     {\n-        if (qlen < 3) { // another sanity check\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n             return findName(q[0], (qlen < 2) ? 0 : q[1]);\n         }\n         int hash = calcHash(q, qlen);\n             name = InternCache.instance.intern(name);\n         }\n         int hash;\n-        if (qlen < 3) {\n-            hash = (qlen == 1) ? calcHash(q[0]) : calcHash(q[0], q[1]);\n+        if (qlen < 4) {\n+            if (qlen == 1) {\n+                hash = calcHash(q[0]);\n+            } else if (qlen == 2) {\n+                hash = calcHash(q[0], q[1]);\n+            } else {\n+                hash = calcHash(q[0], q[1], q[2]);\n+            }\n         } else {\n             hash = calcHash(q, qlen);\n         }\n         return hash;\n     }\n \n+    public int calcHash(int q1, int q2, int q3)\n+    {\n+        // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q2;\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        hash += (hash >>> 17);\n+\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash << 9); // as well as lowest 2 bytes\n+\n+        return hash;\n+    }\n+    \n     public int calcHash(int[] q, int qlen)\n     {\n-        // Note: may be called for qlen < 3; but has at least one int\n-        if (qlen < 3) {\n+        if (qlen < 4) {\n             throw new IllegalArgumentException();\n         }\n \n             case 2:\n                 return new Name2(name, hash, quads[0], quads[1]);\n             case 3:\n+            default:\n                 return new Name3(name, hash, quads[0], quads[1], quads[2]);\n-            default:\n             }\n         }\n         return NameN.construct(name, hash, quads, qlen);\n             return null;\n         }\n \n+        public Name find(int h, int q1, int q2, int q3) {\n+            if (hash == h) {\n+                if (name.equals(q1, q2, q3)) {\n+                    return name;\n+                }\n+            }\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n+                    if (currName.equals(q1, q2, q3)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+        \n         public Name find(int h, int[] quads, int qlen) {\n             if (hash == h) {\n                 if (name.equals(quads, qlen)) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n     /**********************************************************\n      */\n \n-    public abstract boolean equals(int quad1);\n+    public abstract boolean equals(int q1);\n \n-    public abstract boolean equals(int quad1, int quad2);\n+    public abstract boolean equals(int q1, int q2);\n+\n+    /**\n+     * @since 2.6\n+     */\n+    public abstract boolean equals(int q1, int q2, int q3);\n \n     public abstract boolean equals(int[] quads, int qlen);\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n \n     @Override public boolean equals(int quad) { return (quad == q); }\n     @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }\n+    @Override public boolean equals(int q1, int q2, int q3) { return false; }\n+\n     @Override public boolean equals(int[] quads, int qlen) { return (qlen == 1 && quads[0] == q); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return (quad1 == q1) && (quad2 == q2); }\n \n+    @Override public boolean equals(int quad1, int quad2, int q3) { return false; }\n+    \n     @Override\n     public boolean equals(int[] quads, int qlen) { return (qlen == 2 && quads[0] == q1 && quads[1] == q2); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n     public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n+    public boolean equals(int quad1, int quad2, int quad3) {\n+        return (q1 == quad1) && (q2 == quad2) && (q3 == quad3);\n+    }\n+\n+    @Override\n     public boolean equals(int[] quads, int qlen) {\n         return (qlen == 3) && (quads[0] == q1) && (quads[1] == q2) && (quads[2] == q3);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return false; }\n \n+    // Implies quad length == 3, never matches\n+    @Override\n+    public boolean equals(int quad1, int quad2, int quad3) { return false; }\n+\n     @Override\n     public boolean equals(int[] quads, int len) {\n         if (len != qlen) { return false; }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n         _testSymbolsWithNull(f, false);\n         _testSymbolsWithNull(f, false);\n     }\n-    \n+\n     private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n         final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         final int SEED = 33333;\n         BytesToNameCanonicalizer symbols =\n                 BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n+\n         final int COUNT = 6000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n         assertEquals(1686, symbols.collisionCount());\n         // but not super long collision chains:\n         assertEquals(9, symbols.maxCollisionLength());\n+\n+        // But also verify entries are actually found?\n     }\n \n     // [Issue#145]", "timestamp": 1422946275, "metainfo": ""}