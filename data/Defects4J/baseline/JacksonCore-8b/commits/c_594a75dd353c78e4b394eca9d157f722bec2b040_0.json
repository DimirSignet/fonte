{"sha": "594a75dd353c78e4b394eca9d157f722bec2b040", "log": "Reimplement FilterJsonGenerator as a flag to JsonGeneratorDelegate.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n import java.io.InputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonParser.NumberType;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n public class JsonGeneratorDelegate extends JsonGenerator\n {\n      */\n     protected JsonGenerator delegate;\n \n+    /**\n+     * Delegate copy methods.  Defaults to true.\n+     */\n+    protected boolean delegateCopyMethods;\n+\n     /*\n     /**********************************************************\n     /* Construction, initialization\n      */\n     \n     public JsonGeneratorDelegate(JsonGenerator d) {\n+        this(d, true);\n+    }\n+    \n+    public JsonGeneratorDelegate(JsonGenerator d, boolean delegateCopyMethods) {\n         delegate = d;\n+        this.delegateCopyMethods = delegateCopyMethods;\n     }\n \n     @Override\n     \n     @Override\n     public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n-        delegate.writeObject(pojo);\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+        } else {\n+            if (pojo == null) {\n+                // important: call method that does check value write:\n+                writeNull();\n+            } else {\n+                /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n+                 *   because that will be done when codec actually serializes\n+                 *   contained POJO. If we did call it it would advance state\n+                 *   causing exception later on\n+                 */\n+                if (getCodec() != null) {\n+                    getCodec().writeValue(this, pojo);\n+                    return;\n+                }\n+                _writeSimpleObject(pojo);\n+            }\n+        }\n     }\n     \n     @Override\n     public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException {\n-        delegate.writeTree(rootNode);\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+        } else {\n+            // As with 'writeObject()', we are not check if write would work\n+            if (rootNode == null) {\n+                writeNull();\n+            } else {\n+                if (getCodec() == null) {\n+                    throw new IllegalStateException(\"No ObjectCodec defined\");\n+                }\n+                getCodec().writeValue(this, rootNode);\n+            }\n+        }\n     }\n \n     /*\n \n     @Override\n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n-        delegate.copyCurrentEvent(jp);\n+        if (delegateCopyMethods) {\n+            delegate.copyCurrentEvent(jp);\n+        } else {\n+            JsonToken t = jp.getCurrentToken();\n+            // sanity check; what to do?\n+            if (t == null) {\n+                _reportError(\"No current event to copy\");\n+            }\n+            switch (t.id()) {\n+            case ID_NOT_AVAILABLE:\n+                _reportError(\"No current event to copy\");\n+            case ID_START_OBJECT:\n+                writeStartObject();\n+                break;\n+            case ID_END_OBJECT:\n+                writeEndObject();\n+                break;\n+            case ID_START_ARRAY:\n+                writeStartArray();\n+                break;\n+            case ID_END_ARRAY:\n+                writeEndArray();\n+                break;\n+            case ID_FIELD_NAME:\n+                writeFieldName(jp.getCurrentName());\n+                break;\n+            case ID_STRING:\n+                if (jp.hasTextCharacters()) {\n+                    writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+                } else {\n+                    writeString(jp.getText());\n+                }\n+                break;\n+            case ID_NUMBER_INT:\n+            {\n+                NumberType n = jp.getNumberType();\n+                if (n == NumberType.INT) {\n+                    writeNumber(jp.getIntValue());\n+                } else if (n == NumberType.BIG_INTEGER) {\n+                    writeNumber(jp.getBigIntegerValue());\n+                } else {\n+                    writeNumber(jp.getLongValue());\n+                }\n+                break;\n+            }\n+            case ID_NUMBER_FLOAT:\n+            {\n+                NumberType n = jp.getNumberType();\n+                if (n == NumberType.BIG_DECIMAL) {\n+                    writeNumber(jp.getDecimalValue());\n+                } else if (n == NumberType.FLOAT) {\n+                    writeNumber(jp.getFloatValue());\n+                } else {\n+                    writeNumber(jp.getDoubleValue());\n+                }\n+                break;\n+            }\n+            case ID_TRUE:\n+                writeBoolean(true);\n+                break;\n+            case ID_FALSE:\n+                writeBoolean(false);\n+                break;\n+            case ID_NULL:\n+                writeNull();\n+                break;\n+            case ID_EMBEDDED_OBJECT:\n+                writeObject(jp.getEmbeddedObject());\n+                break;\n+            default:\n+                _throwInternal();\n+            }\n+        }\n     }\n \n     @Override\n     public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n-        delegate.copyCurrentStructure(jp);\n+        if (delegateCopyMethods) {\n+            delegate.copyCurrentStructure(jp);\n+        } else {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == null) {\n+                _reportError(\"No current event to copy\");\n+            }\n+            // Let's handle field-name separately first\n+            int id = t.id();\n+            if (id == ID_FIELD_NAME) {\n+                writeFieldName(jp.getCurrentName());\n+                t = jp.nextToken();\n+                id = t.id();\n+                // fall-through to copy the associated value\n+            }\n+            switch (id) {\n+            case ID_START_OBJECT:\n+                writeStartObject();\n+                while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                    copyCurrentStructure(jp);\n+                }\n+                writeEndObject();\n+                break;\n+            case ID_START_ARRAY:\n+                writeStartArray();\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    copyCurrentStructure(jp);\n+                }\n+                writeEndArray();\n+                break;\n+            default:\n+                copyCurrentEvent(jp);\n+            }\n+        }\n     }\n \n     /*\n     public boolean isClosed() {\n         return delegate.isClosed();\n     }\n+\n+    /**\n+     * Helper method used for constructing and throwing\n+     * {@link JsonGenerationException} with given base message.\n+     *<p>\n+     * Note that sub-classes may override this method to add more detail\n+     * or use a {@link JsonGenerationException} sub-class.\n+     */\n+    protected void _reportError(String msg)\n+        throws JsonGenerationException\n+    {\n+        throw new JsonGenerationException(msg);\n+    }\n+\n+    /**\n+     * Helper method to try to call appropriate write method for given\n+     * untyped Object. At this point, no structural conversions should be done,\n+     * only simple basic types are to be coerced as necessary.\n+     *\n+     * @param value Non-null value to write\n+     */\n+    protected void _writeSimpleObject(Object value) \n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n+         *    types even without codec. This can improve interoperability,\n+         *    and specifically help with TokenBuffer.\n+         */\n+        if (value == null) {\n+            writeNull();\n+            return;\n+        }\n+        if (value instanceof String) {\n+            writeString((String) value);\n+            return;\n+        }\n+        if (value instanceof Number) {\n+            Number n = (Number) value;\n+            if (n instanceof Integer) {\n+                writeNumber(n.intValue());\n+                return;\n+            } else if (n instanceof Long) {\n+                writeNumber(n.longValue());\n+                return;\n+            } else if (n instanceof Double) {\n+                writeNumber(n.doubleValue());\n+                return;\n+            } else if (n instanceof Float) {\n+                writeNumber(n.floatValue());\n+                return;\n+            } else if (n instanceof Short) {\n+                writeNumber(n.shortValue());\n+                return;\n+            } else if (n instanceof Byte) {\n+                writeNumber(n.byteValue());\n+                return;\n+            } else if (n instanceof BigInteger) {\n+                writeNumber((BigInteger) n);\n+                return;\n+            } else if (n instanceof BigDecimal) {\n+                writeNumber((BigDecimal) n);\n+                return;\n+                \n+            // then Atomic types\n+                \n+            } else if (n instanceof AtomicInteger) {\n+                writeNumber(((AtomicInteger) n).get());\n+                return;\n+            } else if (n instanceof AtomicLong) {\n+                writeNumber(((AtomicLong) n).get());\n+                return;\n+            }\n+        } else if (value instanceof byte[]) {\n+            writeBinary((byte[]) value);\n+            return;\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+            return;\n+        } else if (value instanceof AtomicBoolean) {\n+            writeBoolean(((AtomicBoolean) value).get());\n+            return;\n+        }\n+        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n+                +value.getClass().getName()+\")\");\n+    }    \n+\n+    protected final void _throwInternal() {\n+        VersionUtil.throwInternal();\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n         assertTrue(jg.isClosed());        \n         assertEquals(\"[13,null,false]\", sw.toString());\n     }\n+\n+    public void testNotDelegateCopyMethods() throws IOException\n+    {\n+        JsonParser jp = new JsonFactory().createParser(\"[{\\\"a\\\":[1,2,{\\\"b\\\":3}],\\\"c\\\":\\\"d\\\"},{\\\"e\\\":false},null]\");\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = new JsonGeneratorDelegate(new JsonFactory().createGenerator(sw), false) {\n+            @Override\n+            public void writeFieldName(String name) throws IOException, JsonGenerationException {\n+                super.writeFieldName(name+\"-test\");\n+                super.writeBoolean(true);\n+                super.writeFieldName(name);\n+            }\n+        };\n+        jp.nextToken();\n+        jg.copyCurrentStructure(jp);\n+        jg.flush();\n+        assertEquals(\"[{\\\"a-test\\\":true,\\\"a\\\":[1,2,{\\\"b-test\\\":true,\\\"b\\\":3}],\\\"c-test\\\":true,\\\"c\\\":\\\"d\\\"},{\\\"e-test\\\":true,\\\"e\\\":false},null]\", sw.toString());\n+    }\n }", "timestamp": 1381446952, "metainfo": ""}