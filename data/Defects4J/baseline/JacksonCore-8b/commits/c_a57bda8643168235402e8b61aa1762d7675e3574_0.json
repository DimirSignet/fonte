{"sha": "a57bda8643168235402e8b61aa1762d7675e3574", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n     {\n         // so, first tertiary, 4 cells shared by N/16 primary slots\n         int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n-\n         final int[] hashArea = _hashArea;\n-\n-        /*\n-        // Since tertiary uses 8 slots, let's loop\n-        for (int end = offset + 32; offset < end; offset += 4) {\n-            ;\n-        }\n-        */\n-        \n-        // then check up to 4 slots; don't worry about empty slots yet\n-        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        int len = hashArea[offset+3];\n-        if ((q1 == hashArea[offset]) && (1 == len)) {\n-            return _names[offset >> 2];\n-        }\n-        // and only at this point see if last slot was occupied or not, to see whether to continue\n-        if (len != 0) {\n-            // shared spillover starts at 7/8 of the main hash area\n-            // (which is sized at 2 * _hashSize), so:\n-            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n-                if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+        // Since tertiary uses 4 slots (of 4 ints), let's loop\n+        for (int end = offset + 16; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (1 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        // but if tertiary full, check out spill-over area as last resort\n+        // shared spillover starts at 7/8 of the main hash area\n+        // (which is sized at 2 * _hashSize), so:\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        final int[] hashArea = _hashArea;\n+\n+        for (int end = offset + 16; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        final int[] hashArea = _hashArea;\n+\n+        for (int end = offset + 16; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n+                    && (3 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        final int[] hashArea = _hashArea;\n+\n+        for (int end = offset + 16; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((hash == hashArea[offset]) && (qlen == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                     return _names[offset >> 2];\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private String _findSecondary(int origOffset, int q1, int q2)\n-    {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n-\n-        final int[] hashArea = _hashArea;\n-        \n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        int len = hashArea[offset+3];\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n-            return _names[offset >> 2];\n-        }\n-        // and only at this point see if last slot was occupied or not, to see whether to continue\n-        if (len != 0) {\n-            // shared spillover starts at 7/8 of the main hash area\n-            // (which is sized at 2 * _hashSize), so:\n-            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n-                if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n-                    return _names[offset >> 2];\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n-    {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n-\n-        final int[] hashArea = _hashArea;\n-        \n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n-            return _names[offset >> 2];\n-        }\n-        offset += 4;\n-        int len = hashArea[offset+3];\n-        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n-            return _names[offset >> 2];\n-        }\n-        // and only at this point see if last slot was occupied or not, to see whether to continue\n-        if (len != 0) {\n-            // shared spillover starts at 7/8 of the main hash area\n-            // (which is sized at 2 * _hashSize), so:\n-            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n-                if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n-                        && (3 == hashArea[offset+3])) {\n-                    return _names[offset >> 2];\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n-    {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n-        \n-        final int[] hashArea = _hashArea;\n-        \n-        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n-            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n-                return _names[offset >> 2];\n-            }\n-        }\n-        offset += 4;\n-        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n-            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n-                return _names[offset >> 2];\n-            }\n-        }\n-        offset += 4;\n-        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n-            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n-                return _names[offset >> 2];\n-            }\n-        }\n-        offset += 4;\n-        int len = hashArea[offset+3];\n-        if ((hash == hashArea[offset]) && (qlen == len)) {\n-            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n-                return _names[offset >> 2];\n-            }\n-        }\n-        // and only at this point see if last slot was occupied or not, to see whether to continue\n-        if (len != 0) {\n-            // shared spillover starts at 7/8 of the main hash area\n-            // (which is sized at 2 * _hashSize), so:\n-            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n-                if ((hash == hashArea[offset]) && (3 == len)) {\n-                    if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n-                        return _names[offset >> 2];\n-                    }\n                 }\n             }\n         }", "timestamp": 1423188046, "metainfo": ""}