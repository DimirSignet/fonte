{"sha": "6b9505b84e593edee49c5828c3ba6acc2e6b36a2", "log": "Bit more refining for tertiary buckets of symbol tables; distribution looks good now wrt spill-overs", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n     protected int _tertiaryStart;\n     \n     /**\n-     * Size of tertiary buckets within tertiary area, in ints.\n-     */\n-    protected int _tertiaryBucketSize;\n-\n-    /**\n-     * First part of shift used to get from primary offset into tertiary bucket\n-     * offset (0-based); basically divides primary physical offset into\n-     * logical tertiary bucket index.\n-     */\n-    protected int _tertiaryOffsetShift;\n-\n-    /**\n-     * Second part of shift used to get from primary offset into tertiary bucket\n-     * offset (0-based); given logical tertiary bucket index, multiplies by\n-     * size of tertiary slots to get relative physical offset from start of tertiary area.\n-     */\n-    protected int _tertiaryBucketShift;\n-    \n+     * Constant that determines size of buckets for tertiary entries:\n+     * <code>1 << _tertiaryShift</code> is the size, and shift value\n+     * is also used for translating from primary offset into\n+     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n+     *<p>\n+     * Default value is 2, for buckets of 4 slots; grows bigger with\n+     * bigger table sizes.\n+     */\n+    protected int _tertiaryShift;\n+\n     /**\n      * Total number of Strings in the symbol table; only used for child tables.\n      */\n         _hashSize = state.size;\n         _secondaryStart = _hashSize << 2; // right after primary area\n         _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = state.tertiaryShift;\n         \n         _hashArea = state.mainHash;\n         _names = state.names;\n \n     private String _findSecondary(int origOffset, int q1)\n     {\n-        // so, first tertiary, 4 cells shared by N/16 primary slots\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        // tertiary area division is dynamic. First; its size is N/4 compared to\n+        // primary hash size; and offsets are for 4 int slots. So to get to logical\n+        // index would shift by 4. But! Tertiary area is further split into buckets,\n+        // determined by shift value. And finally, from bucket back into physical offsets\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n         final int[] hashArea = _hashArea;\n-        // Since tertiary uses 4 slots (of 4 ints), let's loop\n-        for (int end = offset + 16; offset < end; offset += 4) {\n+        final int bucketSize = (4 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (1 == len)) {\n                 return _names[offset >> 2];\n \n     private String _findSecondary(int origOffset, int q1, int q2)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n         final int[] hashArea = _hashArea;\n \n-        for (int end = offset + 16; offset < end; offset += 4) {\n+        final int bucketSize = (4 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                 return _names[offset >> 2];\n \n     private String _findSecondary(int origOffset, int q1, int q2, int q3)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n         final int[] hashArea = _hashArea;\n \n-        for (int end = offset + 16; offset < end; offset += 4) {\n+        final int bucketSize = (4 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                 return _names[offset >> 2];\n \n     private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n         final int[] hashArea = _hashArea;\n \n-        for (int end = offset + 16; offset < end; offset += 4) {\n+        final int bucketSize = (4 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((hash == hashArea[offset]) && (qlen == len)) {\n                 return _names[offset >> 2];\n         // and finally; see if we really should rehash.\n         ++_count;\n \n-        // Yes if above 75%, or above 50% AND have spill-overs\n+        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n         if (_count > (_hashSize >> 1)) { // over 50%\n-            if ((_spilloverEnd > _spilloverStart())\n-                    || (_count > (_hashSize - (_hashSize >> 2)))) {\n+            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n+            \n+            if ((spillCount > (1 + _count >> 7))\n+                    || (_count > (_hashSize * 0.80))) {\n                 _needRehash = true;\n             }\n         }\n         }\n         // if not, tertiary?\n \n-        offset2 = _secondaryStart + (_secondaryStart >> 1);\n-        offset2 += (offset >> 6) << 2; // and add 1/16th of orig index (but on 4 int boundary)\n-\n-        if (hashArea[offset2+3] == 0) {\n-            return offset2;\n-        }\n-        offset2 += 4;\n-        if (hashArea[offset2+3] == 0) {\n-            return offset2;\n-        }\n-        offset2 += 4;\n-        if (hashArea[offset2+3] == 0) {\n-            return offset2;\n-        }\n-        offset2 += 4;\n-        if (hashArea[offset2+3] == 0) {\n-            return offset2;\n+        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n+        final int bucketSize = (4 << _tertiaryShift);\n+        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n+            if (hashArea[offset2+3] == 0) {\n+                return offset2;\n+            }\n         }\n \n         // and if even tertiary full, append at the end of spill area\n         return start;\n     }\n \n-    /**\n-     * Helper method that calculates start of the spillover area\n-     */\n-    private final int _spilloverStart() {\n-        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n-        // So basically multiply by 7\n-        int offset = _hashSize;\n-        return (offset << 3) - offset;\n-    }\n-\n-    protected void reportTooManyCollisions()\n-    {\n-        // First: do not fuzz about small symbol tables\n-        if (_hashSize <= 512) { // would have spill-over area of 64 entries\n-            return;\n-        }\n-        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n-                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n-                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions\");\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Hash calculation\n         // double up main hash area, but do not expand long-name area:\n         _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n         _hashSize = newSize;\n-        _secondaryStart = _hashSize << 2; // 4 ints per entry\n+        _secondaryStart = (newSize << 2); // 4 ints per entry\n         _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = _calcTertiaryShift(newSize);\n         \n         // and simply double up name array\n         _names = new String[oldNames.length << 1];\n \n     /*\n     /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that calculates start of the spillover area\n+     */\n+    private final int _spilloverStart() {\n+        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n+        // So basically multiply by 7\n+        int offset = _hashSize;\n+        return (offset << 3) - offset;\n+    }\n+\n+    protected void reportTooManyCollisions()\n+    {\n+        // First: do not fuzz about small symbol tables\n+        if (_hashSize <= 512) { // would have spill-over area of 64 entries\n+            return;\n+        }\n+        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n+                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n+                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions\");\n+    }\n+\n+    static int _calcTertiaryShift(int primarySlots)\n+    {\n+        // first: we only get 1/4 of slots of primary, to divide\n+        int tertSlots = (primarySlots) >> 2;\n+        \n+        // default is 2, meaning buckets of 4 (1 << 2) slots, up to 32 which is 8 buckets of 4 slots\n+        if (tertSlots < 64) {\n+            return 2;\n+        }\n+        // and then up to 256, with 32 buckets of 8 slots\n+        if (tertSlots < 256) {\n+            return 3;\n+        }\n+        // and 2048, with 128 buckets of 16 slots\n+        if (tertSlots < 1024) {\n+            return 4;\n+        }\n+        if (tertSlots < 4096) {\n+            return 5;\n+        }\n+        // and biggest buckets have 64 slots\n+        return 6;\n+    }\n+\n+    /*\n+    /**********************************************************\n     /* Helper classes\n     /**********************************************************\n      */\n     {\n         public final int size;\n         public final int count;\n+        public final int tertiaryShift;\n         public final int[] mainHash;\n         public final String[] names;\n         public final int spilloverEnd;\n         public final int longNameOffset;\n \n-        public TableInfo(int size, int count, int[] mainHash, String[] names,\n-                int spilloverEnd, int longNameOffset)\n+        public TableInfo(int size, int count, int tertiaryShift, \n+                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n         {\n             this.size = size;\n             this.count = count;\n+            this.tertiaryShift = tertiaryShift;\n             this.mainHash = mainHash;\n             this.names = names;\n             this.spilloverEnd = spilloverEnd;\n         {\n             size = src._hashSize;\n             count = src._count;\n+            tertiaryShift = src._tertiaryShift;\n             mainHash = src._hashArea;\n             names = src._names;\n             spilloverEnd = src._spilloverEnd;\n \n         public static TableInfo createInitial(int sz) {\n             int hashAreaSize = sz << 3;\n+            int tertShift = _calcTertiaryShift(sz);\n \n             return new TableInfo(sz, // hashSize\n                     0, // count\n+                    tertShift,\n                     new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n                     new String[sz << 1], // 2x slots\n                     hashAreaSize - sz, // at 7/8 of the total area\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n                 String n = symbolsB.findName(quads, quads.length);\n                 assertEquals(name, n);\n             }\n-System.out.println(\"New symbols: \"+symbolsB);\n+//System.out.println(\"New symbols: \"+symbolsB);\n             symbolsB.release();\n             \n             exp += 250;", "timestamp": 1423196924, "metainfo": ""}