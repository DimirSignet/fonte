{"sha": "e1880f4a41deae9232b8a0d4e79fd89f9e23b4af", "log": "Fix a regression in handling of negative numbers with reader-backed parser", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n \n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n-            _inputPtr = startPtr;\n-            return _parseNumber2(false);\n+            return _parseNumber2(false, startPtr);\n         }\n             \n         /* First, let's see if the whole number is contained within\n         while (true) {\n             if (ptr >= inputLen) {\n                 _inputPtr = startPtr;\n-                return _parseNumber2(false);\n+                return _parseNumber2(false, startPtr);\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n             fract_loop:\n             while (true) {\n                 if (ptr >= inputLen) {\n-                    _inputPtr = startPtr;\n-                    return _parseNumber2(false);\n+                    return _parseNumber2(neg, startPtr);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n         if (ch == 'e' || ch == 'E') { // and/or exponent\n             if (ptr >= inputLen) {\n                 _inputPtr = startPtr;\n-                return _parseNumber2(false);\n+                return _parseNumber2(neg, startPtr);\n             }\n             // Sign indicator?\n             ch = (int) _inputBuffer[ptr++];\n             if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                 if (ptr >= inputLen) {\n                     _inputPtr = startPtr;\n-                    return _parseNumber2(false);\n+                    return _parseNumber2(false, startPtr);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n                 ++expLen;\n                 if (ptr >= inputLen) {\n                     _inputPtr = startPtr;\n-                    return _parseNumber2(false);\n+                    return _parseNumber2(neg, startPtr);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n         final int inputLen = _inputEnd;\n \n         if (ptr >= inputLen) {\n-            _inputPtr = startPtr+1;\n-            return _parseNumber2(true);\n+            return _parseNumber2(true, startPtr);\n         }\n         int ch = _inputBuffer[ptr++];\n         // First check: must have a digit to follow minus sign\n         }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n-            _inputPtr = startPtr+1;\n-            return _parseNumber2(true);\n+            return _parseNumber2(true, startPtr);\n         }\n         int intLen = 1; // already got one\n         \n         int_loop:\n         while (true) {\n             if (ptr >= inputLen) {\n-                _inputPtr = (startPtr+1);\n-                return _parseNumber2(true);\n+                return _parseNumber2(true, startPtr);\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n      * that it has to explicitly copy contents to the text buffer\n      * instead of just sharing the main input buffer.\n      */\n-    private final JsonToken _parseNumber2(boolean neg) throws IOException\n-    {\n+    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n+    {\n+        _inputPtr = neg ? (startPtr+1) : startPtr;\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n     \n     public void testSimpleInt() throws Exception\n     {\n-        for (int EXP_I : new int[] { 1234, -999, 0, -2 }) {\n+        for (int EXP_I : new int[] { 1234, -999, 0, 1, -2 }) {\n             _testSimpleInt(EXP_I, false);\n             _testSimpleInt(EXP_I, true);\n         }\n     public void testSimpleDouble() throws Exception\n     {\n         final String[] INPUTS = new String[] {\n-            \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"0.0\", \"1.0\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\",\n-            \"-0.5\", \"-12.9\", \"-999.0\"\n+            \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"0.0\", \"1.0\", \"-1.0\", \n+            \"-0.5\", \"-12.9\", \"-999.0\",\n+            \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\",\n         };\n         for (int input = 0; input < 2; ++input) {\n             for (int i = 0; i < INPUTS.length; ++i) {", "timestamp": 1399525424, "metainfo": ""}