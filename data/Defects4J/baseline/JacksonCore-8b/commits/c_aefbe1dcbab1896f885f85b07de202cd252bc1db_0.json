{"sha": "aefbe1dcbab1896f885f85b07de202cd252bc1db", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      * size; essentially, hash array size - 1 (since hash array sizes\n      * are 2^N).\n      */\n-    protected int _mainHashMask;\n+    protected int _hashMask;\n \n     /**\n      * Array of 2^N size, which contains combination\n      * and 8-bit collision bucket index (0 to indicate empty\n      * collision bucket chain; otherwise subtract one from index)\n      */\n-    protected int[] _mainHash;\n+    protected int[] _hash;\n \n     /**\n      * Array that contains <code>Name</code> instances matching\n      * and when adding new collision list queues (i.e. creating a new\n      * collision list head entry)\n      */\n-    private boolean _mainHashShared;\n-\n-    private boolean _mainNamesShared;\n+    private boolean _hashShared;\n+\n+    private boolean _namesShared;\n \n     /**\n      * Flag that indicates whether underlying data structures for\n      * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n      * symbol tables: ones used for merging and sharing common symbols\n      * \n-     * @param hashSize Initial hash area size\n+     * @param sz Initial hash area size\n      * @param intern Whether Strings contained should be {@link String#intern}ed\n      * @param seed Random seed valued used to make it more difficult to cause\n      *   collisions (used for collision-based DoS attacks).\n      */\n-    private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed)\n-    {\n+    private BytesToNameCanonicalizer(int sz, boolean intern, int seed) {\n         _parent = null;\n         _seed = seed;\n         _intern = intern;\n         // Sanity check: let's now allow hash sizes below certain minimum value\n-        if (hashSize < MIN_HASH_SIZE) {\n-            hashSize = MIN_HASH_SIZE;\n+        if (sz < MIN_HASH_SIZE) {\n+            sz = MIN_HASH_SIZE;\n         } else {\n             /* Also; size must be 2^N; otherwise hash algorithm won't\n              * work... so let's just pad it up, if so\n              */\n-            if ((hashSize & (hashSize - 1)) != 0) { // only true if it's 2^N\n+            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n                 int curr = MIN_HASH_SIZE;\n-                while (curr < hashSize) {\n+                while (curr < sz) {\n                     curr += curr;\n                 }\n-                hashSize = curr;\n-            }\n-        }\n-        _tableInfo = new AtomicReference<TableInfo>(initTableInfo(hashSize));\n+                sz = curr;\n+            }\n+        }\n+        _tableInfo = new AtomicReference<TableInfo>(initTableInfo(sz));\n     }\n \n     /**\n      * Constructor used when creating a child instance\n      */\n-    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed,\n-            TableInfo state)\n+    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state)\n     {\n         _parent = parent;\n         _seed = seed;\n \n         // Then copy shared state\n         _count = state.count;\n-        _mainHashMask = state.mainHashMask;\n-        _mainHash = state.mainHash;\n+        _hashMask = state.mainHashMask;\n+        _hash = state.mainHash;\n         _mainNames = state.mainNames;\n         _collList = state.collList;\n         _collCount = state.collCount;\n \n         // and then set other state to reflect sharing status\n         _needRehash = false;\n-        _mainHashShared = true;\n-        _mainNamesShared = true;\n+        _hashShared = true;\n+        _namesShared = true;\n         _collListShared = true;\n     }\n \n         public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames,\n                 Bucket[] collList, int collCount, int collEnd, int longestCollisionList)\n      */\n-    private TableInfo initTableInfo(int hashSize)\n-    {\n+    private TableInfo initTableInfo(int sz) {\n         return new TableInfo(0, // count\n-                hashSize - 1, // mainHashMask\n-                new int[hashSize], // mainHash\n-                new Name[hashSize], // mainNames\n+                sz - 1, // mainHashMask\n+                new int[sz], // mainHash\n+                new Name[sz], // mainNames\n                 null, // collList\n                 0, // collCount,\n                 0, // collEnd\n      * Factory method to call to create a symbol table instance with a\n      * randomized seed value.\n      */\n-    public static BytesToNameCanonicalizer createRoot()\n-    {\n+    public static BytesToNameCanonicalizer createRoot() {\n         /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n          * based attacks.\n          */\n      * Factory method that should only be called from unit tests, where seed\n      * value should remain the same.\n      */\n-    protected static BytesToNameCanonicalizer createRoot(int hashSeed) {\n-        return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, hashSeed);\n+    protected static BytesToNameCanonicalizer createRoot(int seed) {\n+        return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, seed);\n     }\n     \n     /**\n      * @param intern Whether canonical symbol Strings should be interned\n      *   or not\n      */\n-    public BytesToNameCanonicalizer makeChild(boolean canonicalize,\n-        boolean intern)\n-    {\n+    public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern) {\n         return new BytesToNameCanonicalizer(this, intern, _seed, _tableInfo.get());\n     }\n \n             /* Let's also mark this instance as dirty, so that just in\n              * case release was too early, there's no corruption of possibly shared data.\n              */\n-            _mainHashShared = true;\n-            _mainNamesShared = true;\n+            _hashShared = true;\n+            _namesShared = true;\n             _collListShared = true;\n         }\n     }\n     /**\n      * @since 2.1\n      */\n-    public int bucketCount() { return _mainHash.length; }\n+    public int bucketCount() { return _hash.length; }\n     \n     /**\n      * Method called to check to quickly see if a child symbol table\n      * may have gotten additional entries. Used for checking to see\n      * if a child table should be merged into shared table.\n      */\n-    public boolean maybeDirty() {\n-        return !_mainHashShared;\n-    }\n+    public boolean maybeDirty() { return !_hashShared; }\n \n     /**\n      * @since 2.1\n      * \n      * @since 2.1\n      */\n-    public int collisionCount() {\n-        return _collCount;\n-    }\n+    public int collisionCount() { return _collCount; }\n \n     /**\n      * Method mostly needed by unit tests; calculates length of the\n     /**********************************************************\n      */\n     \n-    public static Name getEmptyName()\n-    {\n+    public static Name getEmptyName() {\n         return Name1.getEmptyName();\n     }\n \n      * Note: separate methods to optimize common case of\n      * short element/attribute names (4 or less ascii characters)\n      *\n-     * @param firstQuad int32 containing first 4 bytes of the name;\n+     * @param q1 int32 containing first 4 bytes of the name;\n      *   if the whole name less than 4 bytes, padded with zero bytes\n      *   in front (zero MSBs, ie. right aligned)\n      *\n      * @return Name matching the symbol passed (or constructed for\n      *   it)\n      */\n-    public Name findName(int firstQuad)\n-    {\n-        int hash = calcHash(firstQuad);\n-        int ix = (hash & _mainHashMask);\n-        int val = _mainHash[ix];\n+    public Name findName(int q1)\n+    {\n+        int hash = calcHash(q1);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n         \n         /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n          * are bucket index)... match?\n             if (name == null) { // main slot empty; can't find\n                 return null;\n             }\n-            if (name.equals(firstQuad)) {\n+            if (name.equals(q1)) {\n                 return name;\n             }\n         } else if (val == 0) { // empty slot? no match\n             val -= 1; // to convert from 1-based to 0...\n             Bucket bucket = _collList[val];\n             if (bucket != null) {\n-                return bucket.find(hash, firstQuad, 0);\n+                return bucket.find(hash, q1, 0);\n             }\n         }\n         // Nope, no match whatsoever\n      * Note: separate methods to optimize common case of relatively\n      * short element/attribute names (8 or less ascii characters)\n      *\n-     * @param firstQuad int32 containing first 4 bytes of the name.\n-     * @param secondQuad int32 containing bytes 5 through 8 of the\n+     * @param q1 int32 containing first 4 bytes of the name.\n+     * @param q2 int32 containing bytes 5 through 8 of the\n      *   name; if less than 8 bytes, padded with up to 3 zero bytes\n      *   in front (zero MSBs, ie. right aligned)\n      *\n      * @return Name matching the symbol passed (or constructed for it)\n      */\n-    public Name findName(int firstQuad, int secondQuad)\n-    {\n-        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\n-        int ix = (hash & _mainHashMask);\n-        int val = _mainHash[ix];\n+    public Name findName(int q1, int q2)\n+    {\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n         \n         /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n          * are bucket index)... match?\n             if (name == null) { // main slot empty; can't find\n                 return null;\n             }\n-            if (name.equals(firstQuad, secondQuad)) {\n+            if (name.equals(q1, q2)) {\n                 return name;\n             }\n         } else if (val == 0) { // empty slot? no match\n             val -= 1; // to convert from 1-based to 0...\n             Bucket bucket = _collList[val];\n             if (bucket != null) {\n-                return bucket.find(hash, firstQuad, secondQuad);\n+                return bucket.find(hash, q1, q2);\n             }\n         }\n         // Nope, no match whatsoever\n      * it is preferable to call the version optimized for short\n      * names.\n      *\n-     * @param quads Array of int32s, each of which contain 4 bytes of\n+     * @param q Array of int32s, each of which contain 4 bytes of\n      *   encoded name\n      * @param qlen Number of int32s, starting from index 0, in quads\n      *   parameter\n      *\n      * @return Name matching the symbol passed (or constructed for it)\n      */\n-    public Name findName(int[] quads, int qlen)\n+    public Name findName(int[] q, int qlen)\n     {\n         if (qlen < 3) { // another sanity check\n-            return findName(quads[0], (qlen < 2) ? 0 : quads[1]);\n-        }\n-        int hash = calcHash(quads, qlen);\n+            return findName(q[0], (qlen < 2) ? 0 : q[1]);\n+        }\n+        int hash = calcHash(q, qlen);\n         // (for rest of comments regarding logic, see method above)\n-        int ix = (hash & _mainHashMask);\n-        int val = _mainHash[ix];\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n         if ((((val >> 8) ^ hash) << 8) == 0) {\n             Name name = _mainNames[ix];\n             if (name == null // main slot empty; no collision list then either\n-                || name.equals(quads, qlen)) { // should be match, let's verify\n+                || name.equals(q, qlen)) { // should be match, let's verify\n                 return name;\n             }\n         } else if (val == 0) { // empty slot? no match\n             val -= 1; // to convert from 1-based to 0...\n             Bucket bucket = _collList[val];\n             if (bucket != null) {\n-                return bucket.find(hash, quads, qlen);\n+                return bucket.find(hash, q, qlen);\n             }\n         }\n         return null;\n     /**********************************************************\n      */\n \n-    public Name addName(String symbolStr, int q1, int q2)\n+    public Name addName(String name, int q1, int q2)\n     {\n         if (_intern) {\n-            symbolStr = InternCache.instance.intern(symbolStr);\n+            name = InternCache.instance.intern(name);\n         }\n         int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n-        Name symbol = constructName(hash, symbolStr, q1, q2);\n+        Name symbol = constructName(hash, name, q1, q2);\n         _addSymbol(hash, symbol);\n         return symbol;\n     }\n     \n-    public Name addName(String symbolStr, int[] quads, int qlen)\n+    public Name addName(String name, int[] q, int qlen)\n     {\n         if (_intern) {\n-            symbolStr = InternCache.instance.intern(symbolStr);\n+            name = InternCache.instance.intern(name);\n         }\n         int hash;\n         if (qlen < 3) {\n-            hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]);\n+            hash = (qlen == 1) ? calcHash(q[0]) : calcHash(q[0], q[1]);\n         } else {\n-            hash = calcHash(quads, qlen);\n-        }\n-        Name symbol = constructName(hash, symbolStr, quads, qlen);\n+            hash = calcHash(q, qlen);\n+        }\n+        Name symbol = constructName(hash, name, q, qlen);\n         _addSymbol(hash, symbol);\n         return symbol;\n     }\n     private final static int MULT2 = 65599;\n     private final static int MULT3 = 31;\n     \n-    public int calcHash(int firstQuad)\n-    {\n-        int hash = firstQuad ^ _seed;\n+    public int calcHash(int q1)\n+    {\n+        int hash = q1 ^ _seed;\n         hash += (hash >>> 15); // to xor hi- and low- 16-bits\n         hash ^= (hash >>> 9); // as well as lowest 2 bytes\n         return hash;\n     }\n \n-    public int calcHash(int firstQuad, int secondQuad)\n+    public int calcHash(int q1, int q2)\n     {\n         /* For two quads, let's change algorithm a bit, to spice\n          * things up (can do bit more processing anyway)\n          */\n-        int hash = firstQuad;\n+        int hash = q1;\n         hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n-        hash += (secondQuad * MULT); // then add second quad\n+        hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n         return hash;\n     }\n \n-    public int calcHash(int[] quads, int qlen)\n+    public int calcHash(int[] q, int qlen)\n     {\n         // Note: may be called for qlen < 3; but has at least one int\n         if (qlen < 3) {\n          * add seed bit later in the game, and switch plus/xor around,\n          * use different shift lengths.\n          */\n-        int hash = quads[0] ^ _seed;\n+        int hash = q[0] ^ _seed;\n         hash += (hash >>> 9);\n         hash *= MULT;\n-        hash += quads[1];\n+        hash += q[1];\n         hash *= MULT2;\n         hash += (hash >>> 15);\n-        hash ^= quads[2];\n+        hash ^= q[2];\n         hash += (hash >>> 17);\n         \n         for (int i = 3; i < qlen; ++i) {\n-            hash = (hash * MULT3) ^ quads[i];\n+            hash = (hash * MULT3) ^ q[i];\n             // for longer entries, mess a bit in-between too\n             hash += (hash >>> 3);\n             hash ^= (hash << 7);\n     }\n \n     // Method only used by unit tests\n-    protected static int[] calcQuads(byte[] wordBytes)\n-    {\n+    protected static int[] calcQuads(byte[] wordBytes) {\n         int blen = wordBytes.length;\n         int[] result = new int[(blen + 3) / 4];\n         for (int i = 0; i < blen; ++i) {\n \n     private void _addSymbol(int hash, Name symbol)\n     {\n-        if (_mainHashShared) { // always have to modify main entry\n+        if (_hashShared) { // always have to modify main entry\n             unshareMain();\n         }\n         // First, do we need to rehash?\n         /* Ok, enough about set up: now we need to find the slot to add\n          * symbol in:\n          */\n-        int ix = (hash & _mainHashMask);\n+        int ix = (hash & _hashMask);\n         if (_mainNames[ix] == null) { // primary empty?\n-            _mainHash[ix] = (hash << 8);\n-            if (_mainNamesShared) {\n+            _hash[ix] = (hash << 8);\n+            if (_namesShared) {\n                 unshareNames();\n             }\n             _mainNames[ix] = symbol;\n                 unshareCollision(); // also allocates if list was null\n             }\n             ++_collCount;\n-            int entryValue = _mainHash[ix];\n+            int entryValue = _hash[ix];\n             int bucket = entryValue & 0xFF;\n             if (bucket == 0) { // first spill over?\n                 if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                     bucket = findBestBucket();\n                 }\n                 // Need to mark the entry... and the spill index is 1-based\n-                _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1);\n+                _hash[ix] = (entryValue & ~0xFF) | (bucket + 1);\n             } else {\n                 --bucket; // 1-based index in value\n             }\n          * 50% fill rate no matter what:\n          */\n         {\n-            int hashSize = _mainHash.length;\n+            int hashSize = _hash.length;\n             if (_count > (hashSize >> 1)) {\n                 int hashQuarter = (hashSize >> 2);\n                 /* And either strictly above 75% (the usual) or\n     {\n         _needRehash = false;        \n         // Note: since we'll make copies, no need to unshare, can just mark as such:\n-        _mainNamesShared = false;\n+        _namesShared = false;\n \n         /* And then we can first deal with the main hash area. Since we\n          * are expanding linearly (double up), we know there'll be no\n          * collisions during this phase.\n          */\n-        int[] oldMainHash = _mainHash;\n+        int[] oldMainHash = _hash;\n         int len = oldMainHash.length;\n         int newLen = len+len;\n \n             return;\n         }\n         \n-        _mainHash = new int[newLen];\n-        _mainHashMask = (newLen - 1);\n+        _hash = new int[newLen];\n+        _hashMask = (newLen - 1);\n         Name[] oldNames = _mainNames;\n         _mainNames = new Name[newLen];\n         int symbolsSeen = 0; // let's do a sanity check\n             if (symbol != null) {\n                 ++symbolsSeen;\n                 int hash = symbol.hashCode();\n-                int ix = (hash & _mainHashMask);\n+                int ix = (hash & _hashMask);\n                 _mainNames[ix] = symbol;\n-                _mainHash[ix] = hash << 8; // will clear spill index\n+                _hash[ix] = hash << 8; // will clear spill index\n             }\n         }\n \n                 ++symbolsSeen;\n                 Name symbol = curr._name;\n                 int hash = symbol.hashCode();\n-                int ix = (hash & _mainHashMask);\n-                int val = _mainHash[ix];\n+                int ix = (hash & _hashMask);\n+                int val = _hash[ix];\n                 if (_mainNames[ix] == null) { // no primary entry?\n-                    _mainHash[ix] = (hash << 8);\n+                    _hash[ix] = (hash << 8);\n                     _mainNames[ix] = symbol;\n                 } else { // nope, it's a collision, need to spill over\n                     ++_collCount;\n                             bucket = findBestBucket();\n                         }\n                         // Need to mark the entry... and the spill index is 1-based\n-                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n+                        _hash[ix] = (val & ~0xFF) | (bucket + 1);\n                     } else {\n                         --bucket; // 1-based index in value\n                     }\n      * Helper method called to empty all shared symbols, but to leave\n      * arrays allocated\n      */\n-    private void nukeSymbols()\n-    {\n+    private void nukeSymbols() {\n         _count = 0;\n         _longestCollisionList = 0;\n-        Arrays.fill(_mainHash, 0);\n+        Arrays.fill(_hash, 0);\n         Arrays.fill(_mainNames, null);\n         Arrays.fill(_collList, null);\n         _collCount = 0;\n      * usually the first bucket that has only one entry, but in general\n      * first one of the buckets with least number of entries\n      */\n-    private int findBestBucket()\n-    {\n+    private int findBestBucket() {\n         Bucket[] buckets = _collList;\n         int bestCount = Integer.MAX_VALUE;\n         int bestIx = -1;\n      * even if addition is to the collision list (since collision list\n      * index comes from lowest 8 bits of the primary hash entry)\n      */\n-    private void unshareMain()\n-    {\n-        final int[] old = _mainHash;\n-        _mainHash = Arrays.copyOf(old, old.length);\n-        _mainHashShared = false;\n-    }\n-\n-    private void unshareCollision()\n-    {\n+    private void unshareMain() {\n+        final int[] old = _hash;\n+        _hash = Arrays.copyOf(old, old.length);\n+        _hashShared = false;\n+    }\n+\n+    private void unshareCollision() {\n         Bucket[] old = _collList;\n         if (old == null) {\n             _collList = new Bucket[INITIAL_COLLISION_LEN];\n         _collListShared = false;\n     }\n \n-    private void unshareNames()\n-    {\n+    private void unshareNames() {\n         final Name[] old = _mainNames;\n         _mainNames = Arrays.copyOf(old, old.length);\n-        _mainNamesShared = false;\n-    }\n-\n-    private void expandCollision()\n-    {\n+        _namesShared = false;\n+    }\n+\n+    private void expandCollision() {\n         final Bucket[] old = _collList;\n         _collList = Arrays.copyOf(old, old.length * 2);\n     }\n     /**********************************************************\n      */\n \n-    private static Name constructName(int hash, String name, int q1, int q2)\n-    {     \n+    private static Name constructName(int hash, String name, int q1, int q2) {\n         if (q2 == 0) { // one quad only?\n             return new Name1(name, hash, q1);\n         }\n         return new Name2(name, hash, q1, q2);\n     }\n \n-    private static Name constructName(int hash, String name, int[] quads, int qlen)\n-    {\n+    private static Name constructName(int hash, String name, int[] quads, int qlen) {\n         if (qlen < 4) { // Need to check for 3 quad one, can do others too\n             switch (qlen) {\n             case 1:\n         public TableInfo(BytesToNameCanonicalizer src)\n         {\n             count = src._count;\n-            mainHashMask = src._mainHashMask;\n-            mainHash = src._mainHash;\n+            mainHashMask = src._hashMask;\n+            mainHash = src._hash;\n             mainNames = src._mainNames;\n             collList = src._collList;\n             collCount = src._collCount;\n     \n     }\n     \n-    /**\n-     * \n-     */\n-    final static class Bucket\n+    final private static class Bucket\n     {\n         protected final Name _name;\n         protected final Bucket _next;", "timestamp": 1387001570, "metainfo": ""}