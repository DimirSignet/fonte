{"sha": "faa7d5415faf9b695907e541fe74d7ecc7e03eca", "log": "Add FilterJsonGenerator.", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/FilterJsonGenerator.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.TreeNode;\n+\n+/**\n+ * Delegating JsonGenerator with copies of the base copyCurrentStructure and\n+ * other methods to enable the creation filtering generators analogous to\n+ * extending java.io.FilterOutputStream.\n+ */\n+public class FilterJsonGenerator extends JsonGeneratorDelegate {\n+    public FilterJsonGenerator(JsonGenerator d) {\n+        super(d);\n+    }\n+\n+    @Override\n+    public void writeObject(Object value) throws IOException, JsonProcessingException {\n+        if (value == null) {\n+            // important: call method that does check value write:\n+            writeNull();\n+        } else {\n+            /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n+             *   because that will be done when codec actually serializes\n+             *   contained POJO. If we did call it it would advance state\n+             *   causing exception later on\n+             */\n+            ObjectCodec objectCodec = getCodec();\n+            if (objectCodec != null) {\n+                objectCodec.writeValue(this, value);\n+                return;\n+            }\n+            writeSimpleObject(value);\n+        }\n+    }\n+\n+    private void writeSimpleObject(Object value) throws IOException, JsonGenerationException {\n+        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n+         *    types even without codec. This can improve interoperability,\n+         *    and specifically help with TokenBuffer.\n+         */\n+        if (value == null) {\n+            writeNull();\n+            return;\n+        }\n+        if (value instanceof String) {\n+            writeString((String) value);\n+            return;\n+        }\n+        if (value instanceof Number) {\n+            Number n = (Number) value;\n+            if (n instanceof Integer) {\n+                writeNumber(n.intValue());\n+                return;\n+            } else if (n instanceof Long) {\n+                writeNumber(n.longValue());\n+                return;\n+            } else if (n instanceof Double) {\n+                writeNumber(n.doubleValue());\n+                return;\n+            } else if (n instanceof Float) {\n+                writeNumber(n.floatValue());\n+                return;\n+            } else if (n instanceof Short) {\n+                writeNumber(n.shortValue());\n+                return;\n+            } else if (n instanceof Byte) {\n+                writeNumber(n.byteValue());\n+                return;\n+            } else if (n instanceof BigInteger) {\n+                writeNumber((BigInteger) n);\n+                return;\n+            } else if (n instanceof BigDecimal) {\n+                writeNumber((BigDecimal) n);\n+                return;\n+                \n+            // then Atomic types\n+                \n+            } else if (n instanceof AtomicInteger) {\n+                writeNumber(((AtomicInteger) n).get());\n+                return;\n+            } else if (n instanceof AtomicLong) {\n+                writeNumber(((AtomicLong) n).get());\n+                return;\n+            }\n+        } else if (value instanceof byte[]) {\n+            writeBinary((byte[]) value);\n+            return;\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+            return;\n+        } else if (value instanceof AtomicBoolean) {\n+            writeBoolean(((AtomicBoolean) value).get());\n+            return;\n+        }\n+        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n+                +value.getClass().getName()+\")\");\n+    }\n+\n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException {\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            ObjectCodec objectCodec = getCodec();\n+            if (objectCodec == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            objectCodec.writeValue(this, rootNode);\n+        }\n+    }\n+\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n+        JsonToken t = jp.getCurrentToken();\n+        // sanity check; what to do?\n+        if (t == null) {\n+            throw new JsonGenerationException(\"No current event to copy\");\n+        }\n+        switch(t) {\n+        case START_OBJECT:\n+            writeStartObject();\n+            break;\n+        case END_OBJECT:\n+            writeEndObject();\n+            break;\n+        case START_ARRAY:\n+            writeStartArray();\n+            break;\n+        case END_ARRAY:\n+            writeEndArray();\n+            break;\n+        case FIELD_NAME:\n+            writeFieldName(jp.getCurrentName());\n+            break;\n+        case VALUE_STRING:\n+            if (jp.hasTextCharacters()) {\n+                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            } else {\n+                writeString(jp.getText());\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            switch (jp.getNumberType()) {\n+            case INT:\n+                writeNumber(jp.getIntValue());\n+                break;\n+            case BIG_INTEGER:\n+                writeNumber(jp.getBigIntegerValue());\n+                break;\n+            default:\n+                writeNumber(jp.getLongValue());\n+            }\n+            break;\n+        case VALUE_NUMBER_FLOAT:\n+            switch (jp.getNumberType()) {\n+            case BIG_DECIMAL:\n+                writeNumber(jp.getDecimalValue());\n+                break;\n+            case FLOAT:\n+                writeNumber(jp.getFloatValue());\n+                break;\n+            default:\n+                writeNumber(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            writeBoolean(true);\n+            break;\n+        case VALUE_FALSE:\n+            writeBoolean(false);\n+            break;\n+        case VALUE_NULL:\n+            writeNull();\n+            break;\n+        case VALUE_EMBEDDED_OBJECT:\n+            writeObject(jp.getEmbeddedObject());\n+            break;\n+        default:\n+            throw new RuntimeException(\"Internal error: this code path should never get executed\");\n+        }\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+        JsonToken t = jp.getCurrentToken();\n+\n+        // Let's handle field-name separately first\n+        if (t == JsonToken.FIELD_NAME) {\n+            writeFieldName(jp.getCurrentName());\n+            t = jp.nextToken();\n+            // fall-through to copy the associated value\n+        }\n+\n+        switch (t) {\n+        case START_ARRAY:\n+            writeStartArray();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndArray();\n+            break;\n+        case START_OBJECT:\n+            writeStartObject();\n+            while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndObject();\n+            break;\n+        default: // others are simple:\n+            copyCurrentEvent(jp);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestFilterJsonGenerator.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestFilterJsonGenerator extends BaseTest {\n+    public void testFilterJsonGenerator() throws IOException {\n+        JsonParser jp = new JsonFactory().createParser(\"[{\\\"a\\\":[1,2,{\\\"b\\\":3}],\\\"c\\\":\\\"d\\\"},{\\\"e\\\":false},null]\");\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = new FilterJsonGenerator(new JsonFactory().createGenerator(sw)) {\n+            @Override\n+            public void writeFieldName(String name) throws IOException, JsonGenerationException {\n+                super.writeFieldName(name+\"-test\");\n+                super.writeBoolean(true);\n+                super.writeFieldName(name);\n+            }\n+        };\n+        jp.nextToken();\n+        jg.copyCurrentStructure(jp);\n+        jg.flush();\n+        assertEquals(\"[{\\\"a-test\\\":true,\\\"a\\\":[1,2,{\\\"b-test\\\":true,\\\"b\\\":3}],\\\"c-test\\\":true,\\\"c\\\":\\\"d\\\"},{\\\"e-test\\\":true,\\\"e\\\":false},null]\", sw.toString());\n+    }\n+}", "timestamp": 1380673116, "metainfo": ""}