{"sha": "7ee38785ecdd2f5a56a41302d4482675ce0d7e68", "log": "Changing UTF8StreamJsonParser to be non-final; making private methods final (and small number of protected methods)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n /**\n  * This is a concrete implementation of {@link JsonParser}, which is\n  * based on a {@link java.io.InputStream} as the input source.\n+ *<p>\n+ * Note: non-final since version 2.3.\n  */\n-public final class UTF8StreamJsonParser\n+public class UTF8StreamJsonParser\n     extends ParserBase\n {\n     final static byte BYTE_LF = (byte) '\\n';\n      */\n \n     @Override\n-    protected boolean loadMore()\n+    protected final boolean loadMore()\n         throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected boolean _loadToHaveAtLeast(int minAvailable)\n+    protected final boolean _loadToHaveAtLeast(int minAvailable)\n         throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         return super.getValueAsString(defValue);\n     }\n     \n-    protected String _getText2(JsonToken t)\n+    protected final String _getText2(JsonToken t)\n     {\n         if (t == null) {\n             return null;\n         return _currToken;\n     }\n \n-    private JsonToken _nextTokenNotInObject(int i)\n+    private final JsonToken _nextTokenNotInObject(int i)\n         throws IOException, JsonParseException\n     {\n         if (i == INT_QUOTE) {\n         return (_currToken = _handleUnexpectedValue(i));\n     }\n     \n-    private JsonToken _nextAfterName()\n+    private final JsonToken _nextAfterName()\n     {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n         return _isNextTokenNameMaybe(i, str);\n     }\n \n-    private void _isNextTokenNameYes()\n+    private final void _isNextTokenNameYes()\n         throws IOException, JsonParseException\n     {\n         // very first thing: common case, colon, value, no white space\n         _nextToken = _handleUnexpectedValue(i);\n     }\n     \n-    private boolean _isNextTokenNameMaybe(int i, SerializableString str)\n+    private final boolean _isNextTokenNameMaybe(int i, SerializableString str)\n         throws IOException, JsonParseException\n     {\n         // // // and this is back to standard nextToken()\n      * Method called to handle parsing when input is split across buffer boundary\n      * (or output is longer than segment used to store it)\n      */\n-    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n+    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n             int intPartLength)\n         throws IOException, JsonParseException\n     {\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private int _verifyNoLeadingZeroes()\n+    private final int _verifyNoLeadingZeroes()\n         throws IOException, JsonParseException\n     {\n         // Ok to have plain \"0\"\n         return ch;\n     }\n     \n-    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n+    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n             boolean negative, int integerPartLength)\n         throws IOException, JsonParseException\n     {\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n+    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n     {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n+    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n     {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     /**********************************************************\n      */\n \n-    private Name findName(int q1, int lastQuadBytes)\n+    private final Name findName(int q1, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private Name findName(int q1, int q2, int lastQuadBytes)\n+    private final Name findName(int q1, int q2, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n+    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n         throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private Name addName(int[] quads, int qlen, int lastQuadBytes)\n+    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n         throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n         _finishString2(outBuf, outPtr);\n     }\n \n-    private void _finishString2(char[] outBuf, int outPtr)\n+    private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {\n         int c;\n         if (Character.isJavaIdentifierPart(c)) {\n             _reportInvalidToken(matchStr.substring(0, i));\n         }\n-    }\n-\n-    protected void _reportInvalidToken(String matchedPart)\n-       throws IOException\n-    {\n-        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n-    }\n-    \n-    protected void _reportInvalidToken(String matchedPart, String msg)\n-        throws IOException\n-    {\n-        StringBuilder sb = new StringBuilder(matchedPart);\n-\n-        /* Let's just try to find what appears to be the token, using\n-         * regular Java identifier character rules. It's just a heuristic,\n-         * nothing fancy here (nor fast).\n-         */\n-        while (true) {\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                break;\n-            }\n-            int i = (int) _inputBuffer[_inputPtr++];\n-            char c = (char) _decodeCharForError(i);\n-            if (!Character.isJavaIdentifierPart(c)) {\n-                break;\n-            }\n-            sb.append(c);\n-        }\n-        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n \n     /*\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n \n-    private int _skipWSOrEnd() throws IOException\n+    private final int _skipWSOrEnd() throws IOException\n     {\n         final int[] codes = _icWS;\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n      * Helper method for matching and skipping a colon character,\n      * optionally surrounded by white space\n      */\n-    private int _skipColon() throws IOException\n+    private final int _skipColon() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n     \n-    private void _skipComment() throws IOException\n+    private final void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n             _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n         }\n     }\n \n-    private void _skipCComment() throws IOException\n+    private final void _skipCComment() throws IOException\n     {\n         // Need to be UTF-8 aware here to decode content (for skipping)\n         final int[] codes = CharTypes.getInputCodeComment();\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private boolean _skipYAMLComment() throws IOException\n+    private final boolean _skipYAMLComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n             return false;\n      * Method for skipping contents of an input line; usually for CPP\n      * and YAML style comments.\n      */\n-    private void _skipLine() throws IOException\n+    private final void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         final int[] codes = CharTypes.getInputCodeComment();\n     /**********************************************************\n      */\n \n-    private int _decodeUtf8_2(int c) throws IOException\n+    private final int _decodeUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c & 0x1F) << 6) | (d & 0x3F);\n     }\n \n-    private int _decodeUtf8_3(int c1) throws IOException\n+    private final int _decodeUtf8_3(int c1) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return c;\n     }\n \n-    private int _decodeUtf8_3fast(int c1) throws IOException\n+    private final int _decodeUtf8_3fast(int c1) throws IOException\n     {\n         c1 &= 0x0F;\n         int d = (int) _inputBuffer[_inputPtr++];\n      * @return Character value <b>minus 0x10000</c>; this so that caller\n      *    can readily expand it to actual surrogates\n      */\n-    private int _decodeUtf8_4(int c) throws IOException\n+    private final int _decodeUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c << 6) | (d & 0x3F)) - 0x10000;\n     }\n \n-    private void _skipUtf8_2(int c) throws IOException\n+    private final void _skipUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n     /* Alas, can't heavily optimize skipping, since we still have to\n      * do validity checks...\n      */\n-    private void _skipUtf8_3(int c) throws IOException\n+    private final void _skipUtf8_3(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         }\n     }\n \n-    private void _skipUtf8_4(int c) throws IOException\n+    private final void _skipUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected void _skipCR() throws IOException\n+    protected final void _skipCR() throws IOException\n     {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == BYTE_LF) {\n     /**********************************************************\n      */\n \n+    protected void _reportInvalidToken(String matchedPart) throws IOException\n+     {\n+         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n+     }\n+\n+    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n+     {\n+         StringBuilder sb = new StringBuilder(matchedPart);\n+\n+         /* Let's just try to find what appears to be the token, using\n+          * regular Java identifier character rules. It's just a heuristic,\n+          * nothing fancy here (nor fast).\n+          */\n+         while (true) {\n+             if (_inputPtr >= _inputEnd && !loadMore()) {\n+                 break;\n+             }\n+             int i = (int) _inputBuffer[_inputPtr++];\n+             char c = (char) _decodeCharForError(i);\n+             if (!Character.isJavaIdentifierPart(c)) {\n+                 break;\n+             }\n+             sb.append(c);\n+         }\n+         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n+     }\n+        \n     protected void _reportInvalidChar(int c)\n         throws JsonParseException\n     {\n      * textual content.\n      */\n     @SuppressWarnings(\"resource\")\n-    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n+    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n     {\n         ByteArrayBuilder builder = _getByteArrayBuilder();\n ", "timestamp": 1380822666, "metainfo": ""}