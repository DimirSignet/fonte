{"sha": "fe5b69812cd70489f61bf844d9c99ef625377d2a", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/BaseReader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/BaseReader.java\n  * Simple basic class for optimized readers in this package; implements\n  * \"cookie-cutter\" methods that are used by all actual implementations.\n  */\n-abstract class BaseReader\n-    extends Reader\n+abstract class BaseReader extends Reader\n {\n     /**\n      * JSON actually limits available Unicode range in the high end\n--- a/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n  * writer) around original output destination, and apply additional\n  * processing during write operations.\n  */\n-public abstract class OutputDecorator\n-    implements java.io.Serializable // since 2.1\n+public abstract class OutputDecorator implements java.io.Serializable // since 2.1\n {\n     private static final long serialVersionUID = 1L;\n \n      * @return OutputStream to use; either passed in argument, or something that\n      *   calls it\n      */\n-    public abstract OutputStream decorate(IOContext ctxt, OutputStream out)\n-        throws IOException;\n+    public abstract OutputStream decorate(IOContext ctxt, OutputStream out) throws IOException;\n \n     /**\n      * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n--- a/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n  * if so, instance of this class can be given as the writer to\n  * <code>JsonGenerator</code>.\n  */\n-public final class SegmentedStringWriter\n-    extends Writer\n+public final class SegmentedStringWriter extends Writer\n {\n     final protected TextBuffer _buffer;\n \n-    public SegmentedStringWriter(BufferRecycler br)\n-    {\n+    public SegmentedStringWriter(BufferRecycler br) {\n         super();\n         _buffer = new TextBuffer(br);\n     }\n      */\n \n     @Override\n-    public Writer append(char c)\n-    {\n+    public Writer append(char c) {\n         write(c);\n         return this;\n     }\n \n     @Override\n-    public Writer append(CharSequence csq)\n-    {\n+    public Writer append(CharSequence csq) {\n         String str = csq.toString();\n         _buffer.append(str, 0, str.length());\n         return this;\n     }\n \n     @Override\n-    public Writer append(CharSequence csq, int start, int end)\n-    {\n+    public Writer append(CharSequence csq, int start, int end) {\n         String str = csq.subSequence(start, end).toString();\n         _buffer.append(str, 0, str.length());\n         return this;\n     }\n \n     @Override public void close() { } // NOP\n-\n     @Override public void flush() { } // NOP\n \n     @Override\n-    public void write(char[] cbuf) {\n-        _buffer.append(cbuf, 0, cbuf.length);\n-    }\n+    public void write(char[] cbuf) { _buffer.append(cbuf, 0, cbuf.length); }\n \n     @Override\n-    public void write(char[] cbuf, int off, int len) {\n-        _buffer.append(cbuf, off, len);\n-    }\n+    public void write(char[] cbuf, int off, int len) { _buffer.append(cbuf, off, len); }\n \n     @Override\n-    public void write(int c) {\n-        _buffer.append((char) c);\n-    }\n+    public void write(int c) { _buffer.append((char) c); }\n \n     @Override\n     public void write(String str) { _buffer.append(str, 0, str.length()); }\n \n     @Override\n-    public void write(String str, int off, int len) {\n-        _buffer.append(str, off, len);\n-    }\n+    public void write(String str, int off, int len) { _buffer.append(str, off, len); }\n \n     /*\n     /**********************************************************\n      * Note that the method is not idempotent -- if called second time,\n      * will just return an empty String.\n      */\n-    public String getAndClear()\n-    {\n+    public String getAndClear() {\n         String result = _buffer.contentsAsString();\n         _buffer.releaseBuffers();\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n     public final int charLength() { return _value.length(); }\n     \n     @Override\n-    public final char[] asQuotedChars()\n-    {\n+    public final char[] asQuotedChars() {\n         char[] result = _quotedChars;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsString(_value);\n      * quoting rules, and encoded using UTF-8 encoding.\n      */\n     @Override\n-    public final byte[] asUnquotedUTF8()\n-    {\n+    public final byte[] asUnquotedUTF8() {\n         byte[] result = _unquotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().encodeAsUTF8(_value);\n      * encoded using UTF-8 encoding.\n      */\n     @Override\n-    public final byte[] asQuotedUTF8()\n-    {\n+    public final byte[] asQuotedUTF8() {\n         byte[] result = _quotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsUTF8(_value);\n      */\n \n     @Override\n-    public int appendQuotedUTF8(byte[] buffer, int offset)\n-    {\n+    public int appendQuotedUTF8(byte[] buffer, int offset) {\n         byte[] result = _quotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsUTF8(_value);\n     }\n \n     @Override\n-    public int appendQuoted(char[] buffer, int offset)\n-    {\n+    public int appendQuoted(char[] buffer, int offset) {\n         char[] result = _quotedChars;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsString(_value);\n     }\n \n     @Override\n-    public int appendUnquotedUTF8(byte[] buffer, int offset)\n-    {\n+    public int appendUnquotedUTF8(byte[] buffer, int offset) {\n         byte[] result = _unquotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().encodeAsUTF8(_value);\n     }\n \n     @Override\n-    public int appendUnquoted(char[] buffer, int offset)\n-    {\n+    public int appendUnquoted(char[] buffer, int offset) {\n         String str = _value;\n         final int length = str.length();\n         if ((offset + length) > buffer.length) {\n     }\n \n     @Override\n-    public int writeQuotedUTF8(OutputStream out) throws IOException\n-    {\n+    public int writeQuotedUTF8(OutputStream out) throws IOException {\n         byte[] result = _quotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsUTF8(_value);\n     }\n \n     @Override\n-    public int writeUnquotedUTF8(OutputStream out) throws IOException\n-    {\n+    public int writeUnquotedUTF8(OutputStream out) throws IOException {\n         byte[] result = _unquotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().encodeAsUTF8(_value);\n     }\n \n     @Override\n-    public int putQuotedUTF8(ByteBuffer buffer)\n-    {\n+    public int putQuotedUTF8(ByteBuffer buffer) {\n         byte[] result = _quotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().quoteAsUTF8(_value);\n     }\n \n     @Override\n-    public int putUnquotedUTF8(ByteBuffer buffer)\n-    {\n+    public int putUnquotedUTF8(ByteBuffer buffer) {\n         byte[] result = _unquotedUTF8Ref;\n         if (result == null) {\n             result = JsonStringEncoder.getInstance().encodeAsUTF8(_value);\n     public final int hashCode() { return _value.hashCode(); }\n \n     @Override\n-    public final boolean equals(Object o)\n-    {\n+    public final boolean equals(Object o) {\n         if (o == this) return true;\n         if (o == null || o.getClass() != getClass()) return false;\n         SerializedString other = (SerializedString) o;\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n  * Since JDK does not come with UTF-32/UCS-4, let's implement a simple\n  * decoder to use.\n  */\n-public class UTF32Reader\n-    extends BaseReader\n+public class UTF32Reader extends BaseReader\n {\n     protected final boolean _bigEndian;\n \n     /**********************************************************\n      */\n \n-    public UTF32Reader(IOContext ctxt,\n-            InputStream in, byte[] buf, int ptr, int len,\n-            boolean isBigEndian)\n-    {\n+    public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian) {\n         super(ctxt, in, buf, ptr, len);\n         _bigEndian = isBigEndian;\n         _managedBuffers = (in != null);\n      */\n \n     @Override\n-\tpublic int read(char[] cbuf, int start, int len)\n-        throws IOException\n-    {\n+    public int read(char[] cbuf, int start, int len) throws IOException {\n         // Already EOF?\n-        if (_buffer == null) {\n-            return -1;\n-        }\n-        if (len < 1) {\n-            return len;\n-        }\n+        if (_buffer == null) { return -1; }\n+        if (len < 1) { return len; }\n         // Let's then ensure there's enough room...\n         if (start < 0 || (start+len) > cbuf.length) {\n             reportBounds(cbuf, start, len);\n     /**********************************************************\n      */\n \n-    private void reportUnexpectedEOF(int gotBytes, int needed)\n-        throws IOException\n-    {\n-        int bytePos = _byteCount + gotBytes;\n-        int charPos = _charCount;\n+    private void reportUnexpectedEOF(int gotBytes, int needed) throws IOException {\n+        int bytePos = _byteCount + gotBytes, charPos = _charCount;\n \n-        throw new CharConversionException(\"Unexpected EOF in the middle of a 4-byte UTF-32 char: got \"\n-                +gotBytes+\", needed \"+needed+\", at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+        throw new CharConversionException(\"Unexpected EOF in the middle of a 4-byte UTF-32 char: got \"+gotBytes+\", needed \"+needed+\", at char #\"+charPos+\", byte #\"+bytePos+\")\");\n     }\n \n-    private void reportInvalid(int value, int offset, String msg)\n-        throws IOException\n-    {\n-        int bytePos = _byteCount + _ptr - 1;\n-        int charPos = _charCount + offset;\n+    private void reportInvalid(int value, int offset, String msg) throws IOException {\n+        int bytePos = _byteCount + _ptr - 1, charPos = _charCount + offset;\n \n-        throw new CharConversionException(\"Invalid UTF-32 character 0x\"\n-                +Integer.toHexString(value)+msg+\" at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+        throw new CharConversionException(\"Invalid UTF-32 character 0x\"+Integer.toHexString(value)+msg+\" at char #\"+charPos+\", byte #\"+bytePos+\")\");\n     }\n \n     /**\n      * @return True, if enough bytes were read to allow decoding of at least\n      *   one full character; false if EOF was encountered instead.\n      */\n-    private boolean loadMore(int available)\n-        throws IOException\n-    {\n+    private boolean loadMore(int available) throws IOException {\n         _byteCount += (_length - available);\n \n         // Bytes that need to be moved to the beginning of buffer?", "timestamp": 1387002086, "metainfo": ""}