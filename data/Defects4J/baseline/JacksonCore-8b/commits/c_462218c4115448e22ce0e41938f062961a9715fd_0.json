{"sha": "462218c4115448e22ce0e41938f062961a9715fd", "log": "Merge branch '2.4' into 2.5  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n         assertEquals(doc, v.toString());\n     }\n \n+    // for [jackson-core#181]\n+    /**\n+     * Method that tries to test that number parsing works in cases where\n+     * input is split between buffer boundaries.\n+     */\n+    public void testParsingOfLongerSequencesWithNonNumeric() throws Exception\n+    {\n+        JsonFactory factory = new JsonFactory();\n+        factory.enable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);\n+        double[] values = new double[] {\n+                0.01, -10.5, 2.1e9, 4.0e-8,\n+                Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY\n+        };\n+        for (int i = 0; i < values.length; ++i) {\n+            int COUNT = 4096;\n+            // Don't see the failure with a multiple of 1\n+            int VCOUNT = 2 * COUNT;\n+            String arrayJson = toJsonArray(values[i], VCOUNT);\n+            StringBuilder sb = new StringBuilder(COUNT + arrayJson.length() + 20);\n+            for (int j = 0; j < COUNT; ++j) {\n+                sb.append(' ');\n+            }\n+            sb.append(arrayJson);\n+            String DOC = sb.toString();\n+            for (int input = 0; input < 2; ++input) {\n+                JsonParser jp;\n+                if (input == 0) {\n+                    jp = createParserUsingStream(factory, DOC, \"UTF-8\");\n+                } else {\n+                    jp = factory.createParser(DOC);\n+                }\n+                assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+                for (int j = 0; j < VCOUNT; ++j) {\n+                    assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                    assertEquals(values[i], jp.getDoubleValue());\n+                }\n+                assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+                jp.close();\n+            }\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests for invalid access\n         }\n         jp.close();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private String toJsonArray(double v, int n) {\n+        StringBuilder sb = new StringBuilder().append('[').append(v);\n+        for (int i = 1; i < n; ++i) {\n+            sb.append(',').append(v);\n+        }\n+        return sb.append(']').toString();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n      * This variant is what most people would think of \"the standard\"\n      * Base64 encoding.\n      *<p>\n-     * See <a href=\"\">wikipedia Base64 entry</a> for details.\n+     * See <a href=\"http://en.wikipedia.org/wiki/Base64\">wikipedia Base64 entry</a> for details.\n      *<p>\n      * Note that although this can be thought of as the standard variant,\n      * it is <b>not</b> the default for Jackson: no-linefeeds alternative\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n          * if format uses escaping mechanisms (which is generally true\n          * for textual formats but not for binary formats).\n          *<p>\n+         * Note that this setting may not necessarily make sense for all\n+         * data formats (for example, binary formats typically do not use\n+         * any escaping mechanisms; and some textual formats do not have\n+         * general-purpose escaping); if so, settings is simply ignored.\n+         * Put another way, effects of this feature are data-format specific.\n+         *<p>\n          * Feature is disabled by default.\n          */\n         ESCAPE_NON_ASCII(false),\n          *<p>\n          * Note that enabling this feature will incur performance overhead\n          * due to having to store and check additional information.\n+         *<p>\n+         * Feature is disabled by default.\n          * \n          * @since 2.3\n          */\n         STRICT_DUPLICATE_DETECTION(false),\n-            ;\n+\n+        /**\n+         * Feature that determines what to do if the underlying data format requires knowledge\n+         * of all properties to output, and if no definition is found for a property that\n+         * caller tries to write. If enabled, such properties will be quietly ignored;\n+         * if disabled, a {@link JsonProcessingException} will be thrown to indicate the\n+         * problem.\n+         * Typically most textual data formats do NOT require schema information (although\n+         * some do, such as CSV), whereas many binary data formats do require definitions\n+         * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n+         *<p>\n+         * Note that support for this feature is implemented by individual data format\n+         * module, if (and only if) it makes sense for the format in question. For JSON,\n+         * for example, this feature has no effect as properties need not be pre-defined.\n+         *<p>\n+         * Feature is disabled by default, meaning that if the underlying data format\n+         * requires knowledge of all properties to output, attempts to write an unknown\n+         * property will result in a {@link JsonProcessingException}\n+         *\n+         * @since 2.5\n+         */\n+        IGNORE_UNKNOWN(false),\n+        ;\n \n         private final boolean _defaultState;\n         private final int _mask;\n         return null;\n     }\n \n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getOutputContext().getCurrentValue();\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        JsonStreamContext ctxt = getOutputContext();\n+        return (ctxt == null) ? null : ctxt.getCurrentValue();\n+    }\n+\n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getOutputContext().setCurrentValue(v);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) {\n+        JsonStreamContext ctxt = getOutputContext();\n+        if (ctxt != null) {\n+            ctxt.setCurrentValue(v);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, Feature configuration\n      *   number of values written (before matching call to\n      *   {@link #writeEndArray()} MUST match; generator MAY verify\n      *   this is the case.\n+     *   \n+     * @since 2.4\n      */\n     public void writeStartArray(int size) throws IOException {\n         writeStartArray();\n      */\n     public abstract void writeUTF8String(byte[] text, int offset, int length)\n         throws IOException;\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, write methods, binary/raw content\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method that will force generator to copy\n      * input text verbatim with <b>no</b> modifications (including\n     public void writeRaw(SerializableString raw) throws IOException {\n         writeRaw(raw.getValue());\n     }\n-    \n+\n     /**\n      * Method that will force generator to copy\n      * input text verbatim without any modifications, but assuming\n     public abstract void writeRawValue(String text, int offset, int len) throws IOException;\n \n     public abstract void writeRawValue(char[] text, int offset, int len) throws IOException;\n+\n+    /**\n+     * Method similar to {@link #writeRawValue(String)}, but potentially more\n+     * efficient as it may be able to use pre-encoded content (similar to\n+     * {@link #writeRaw(SerializableString)}.\n+     * \n+     * @since 2.5\n+     */\n+    public void writeRawValue(SerializableString raw) throws IOException {\n+        writeRawValue(raw.getValue());\n+    }\n \n     /**\n      * Method that will output given chunk of binary data as base64\n      */\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      *\n+     * @param v Number value to write\n+     *\n      * @since 2.2\n      */\n     public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(int v) throws IOException;\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(long v) throws IOException;\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(BigInteger v) throws IOException;\n \n     /**\n-     * Method for outputting indicate Json numeric value.\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(double d) throws IOException;\n-\n-    /**\n-     * Method for outputting indicate Json numeric value.\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(double v) throws IOException;\n+\n+    /**\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(float f) throws IOException;\n-\n-    /**\n-     * Method for outputting indicate Json numeric value.\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(float v) throws IOException;\n+\n+    /**\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(BigDecimal dec) throws IOException;\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(BigDecimal v) throws IOException;\n \n     /**\n      * Write method that can be used for custom numeric types that can\n      *<p>\n      * Note: because of lack of type safety, some generator\n      * implementations may not be able to implement this\n-     * method. For example, if a binary json format is used,\n+     * method. For example, if a binary JSON format is used,\n      * it may require type information for encoding; similarly\n-     * for generator-wrappers around Java objects or Json nodes.\n+     * for generator-wrappers around Java objects or JSON nodes.\n      * If implementation does not implement this method,\n      * it needs to throw {@link UnsupportedOperationException}.\n      * \n         throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                 +value.getClass().getName()+\")\");\n     }    \n-\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n \n         /**\n          * Feature that can be enabled to accept quoting of all character\n-         * using backslash qooting mechanism: if not enabled, only characters\n+         * using backslash quoting mechanism: if not enabled, only characters\n          * that are explicitly listed by JSON specification can be thus\n          * escaped (see JSON spec for small list of these characters)\n          *<p>\n             }\n             return flags;\n         }\n-        \n+\n         private Feature(boolean defaultState) {\n             _mask = (1 << ordinal());\n             _defaultState = defaultState;\n         }\n-        \n+\n         public boolean enabledByDefault() { return _defaultState; }\n-        \n+\n         /**\n          * @since 2.3\n          */\n         public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n \n-        public int getMask() { return (1 << ordinal()); }\n+        public int getMask() { return _mask; }\n     }\n \n     /*\n      */\n     public Object getInputSource() { return null; }\n \n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getParsingContext().getCurrentValue();\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        JsonStreamContext ctxt = getParsingContext();\n+        return (ctxt == null) ? null : ctxt.getCurrentValue();\n+    }\n+\n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getParsingContext().setCurrentValue(v);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) {\n+        JsonStreamContext ctxt = getParsingContext();\n+        if (ctxt != null) {\n+            ctxt.setCurrentValue(v);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Format support\n     /**\n      * Method for checking whether specified {@link Feature} is enabled.\n      */\n-    public boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n+    public boolean isEnabled(Feature f) { return f.enabledIn(_features); }\n \n     /**\n      * Bulk access method for getting state of all standard {@link Feature}s.\n     public int getFeatureMask() { return _features; }\n \n     /**\n-     * Bulk set method for (re)settting states of all standard {@link Feature}s\n-     * \n+     * Bulk set method for (re)setting states of all standard {@link Feature}s\n+     *\n      * @since 2.3\n      * \n      * @return This parser object, to allow chaining of calls\n      * and returns result of that comparison.\n      * It is functionally equivalent to:\n      *<pre>\n-     *  return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n+     *  return (nextToken() == JsonToken.FIELD_NAME) &amp;&amp; str.getValue().equals(getCurrentName());\n      *</pre>\n      * but may be faster for parser to verify, and can therefore be used if caller\n      * expects to get such a property name from input next.\n      * \n-     * @param str Property name to compare next token to (if next token is <code>JsonToken.FIELD_NAME<code>)\n+     * @param str Property name to compare next token to (if next token is\n+     *   <code>JsonToken.FIELD_NAME</code>)\n      */\n     public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * verifies whether it is {@link JsonToken#FIELD_NAME}; if it is,\n+     * returns same as {@link #getCurrentName()}, otherwise null.\n+     * \n+     * @since 2.5\n+     */\n+    public String nextFieldName() throws IOException, JsonParseException {\n+        return (nextToken() == JsonToken.FIELD_NAME)\n+                ? getCurrentName() : null;\n     }\n \n     /**\n     public abstract boolean hasCurrentToken();\n \n     /**\n+     * Method that is functionally equivalent to:\n+     *<code>\n+     *  return getCurrentTokenId() == id\n+     *</code>\n+     * but may be more efficiently implemented.\n+     *<p>\n+     * Note that no traversal or conversion is performed; so in some\n+     * cases calling method like {@link #isExpectedStartArrayToken()}\n+     * is necessary instead.\n+     *\n+     * @since 2.5\n+     */\n+    public abstract boolean hasTokenId(int id);\n+\n+    /**\n      * Method that can be called to get the name associated with\n      * the current token: for {@link JsonToken#FIELD_NAME}s it will\n      * be the same as what {@link #getText} returns;\n      * token indicates start array (usually meaning that current token\n      * is {@link JsonToken#START_ARRAY}) when start array is expected.\n      * For some specialized parsers this can return true for other cases\n-     * as well; this is usually done to emulate arrays.\n+     * as well; this is usually done to emulate arrays in cases underlying\n+     * format is ambiguous (XML, for example, has no format-level difference\n+     * between Objects and Arrays; it just has elements).\n      *<p>\n      * Default implementation is equivalent to:\n      *<pre>\n      */\n     public boolean isExpectedStartArrayToken() { return getCurrentToken() == JsonToken.START_ARRAY; }\n \n+    /**\n+     * Similar to {@link #isExpectedStartArrayToken()}, but checks whether stream\n+     * currently points to {@link JsonToken#START_OBJECT}.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isExpectedStartObjectToken() { return getCurrentToken() == JsonToken.START_OBJECT; }\n+    \n     /*\n     /**********************************************************\n     /* Public API, token state overrides\n      * represented by root {@link TreeNode} of resulting model.\n      * For JSON Arrays it will an array node (with child nodes),\n      * for objects object node (with child nodes), and for other types\n-     * matching leaf node type\n+     * matching leaf node type. Empty or whitespace documents are null.\n+     *\n+     * @return root of the document, or null if empty or whitespace.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T extends TreeNode> T readValueAsTree() throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n  * Instances are fully immutable and can be shared, cached.\n  * \n  * @author Tatu Saloranta\n- * \n+ *\n  * @since 2.3\n  */\n public class JsonPointer\n {\n     /**\n      * Marker instance used to represent segment that matches current\n-     * node or position.\n+     * node or position (that is, returns true for\n+     * {@link #matches()}).\n      */\n     protected final static JsonPointer EMPTY = new JsonPointer();\n     \n     /**\n      * Reference to rest of the pointer beyond currently matching\n-     * segment (if any); null if this pointer refers to a matching\n+     * segment (if any); null if this pointer refers to the matching\n      * segment.\n      */\n     protected final JsonPointer _nextSegment;\n-    \n+\n+    /**\n+     * Reference from currently matching segment (if any) to node\n+     * before leaf.\n+     * Lazily constructed if/as needed.\n+     *<p>\n+     * NOTE: we'll use `volatile` here assuming that this is unlikely to\n+     * become a performance bottleneck. If it becomes one we can probably\n+     * just drop it and things still should work (despite warnings as per JMM\n+     * regarding visibility (and lack thereof) of unguarded changes).\n+     * \n+     * @since 2.5\n+     */\n+    protected volatile JsonPointer _head;\n+\n     /**\n      * We will retain representation of the pointer, as a String,\n      * so that {@link #toString} should be as efficient as possible.\n         _nextSegment = next;\n         // Ok; may always be a property\n         _matchingPropertyName = segment;\n+        // but could be an index, if parsable\n         _matchingElementIndex = _parseIndex(segment);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonPointer(String fullString, String segment, int matchIndex, JsonPointer next) {\n+        _asString = fullString;\n+        _nextSegment = next;\n+        _matchingPropertyName = segment;\n+        _matchingElementIndex = matchIndex;\n     }\n     \n     /*\n     public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n     public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n \n+    /**\n+     * Returns the leaf of current JSON Pointer expression.\n+     * Leaf is the last non-null segment of current JSON Pointer.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonPointer last() {\n+        JsonPointer current = this;\n+        if (current == EMPTY) {\n+            return null;\n+        }\n+        JsonPointer next;\n+        while ((next = current._nextSegment) != JsonPointer.EMPTY) {\n+            current = next;\n+        }\n+        return current;\n+    }\n+\n+    public JsonPointer append(JsonPointer tail) {\n+        if (this == EMPTY) {\n+            return tail;\n+        }\n+        if (tail == EMPTY) {\n+            return this;\n+        }\n+        String currentJsonPointer = _asString;\n+        if (currentJsonPointer.endsWith(\"/\")) {\n+            //removes final slash\n+            currentJsonPointer = currentJsonPointer.substring(0, currentJsonPointer.length()-1);\n+        }\n+        return compile(currentJsonPointer + tail._asString);\n+    }\n+\n+    /**\n+     * Method that may be called to see if the pointer would match property\n+     * (of a JSON Object) with given name.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean matchesProperty(String name) {\n+        return (_nextSegment != null) && _matchingPropertyName.equals(name);\n+    }\n+    \n     public JsonPointer matchProperty(String name) {\n         if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n             return null;\n         return _nextSegment;\n     }\n \n-    public JsonPointer matchElement (int index) {\n-        if ((index != _matchingElementIndex) || (index < 0)) {\n-            return null;\n-        }\n-        return _nextSegment;\n+    /**\n+     * Method that may be called to see if the pointer would match\n+     * array element (of a JSON Array) with given index.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean matchesElement(int index) {\n+        return (index == _matchingElementIndex) && (index >= 0);\n     }\n \n     /**\n      * Accessor for getting a \"sub-pointer\", instance where current segment\n-     * has been removed and pointer includes rest of segments;\n+     * has been removed and pointer includes rest of segments.\n+     * For matching state, will return null.\n      */\n     public JsonPointer tail() {\n         return _nextSegment;\n     }\n-    \n+\n+    /**\n+     * Accessor for getting a pointer instance that is identical to this\n+     * instance except that the last segment has been dropped.\n+     * For example, for JSON Point \"/root/branch/leaf\", this method would\n+     * return pointer \"/root/branch\" (compared to {@link #tail()} that\n+     * would return \"/branch/leaf\").\n+     * For leaf \n+     *\n+     * @since 2.5\n+     */\n+    public JsonPointer head() {\n+        JsonPointer h = _head;\n+        if (h == null) {\n+            if (this != EMPTY) {\n+                h = _constructHead();\n+            }\n+            _head = h;\n+        }\n+        return h;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Standard method overrides\n             char c = input.charAt(i);\n             if (c == '/') { // end is nigh!\n                 return new JsonPointer(input, sb.toString(),\n-                        _parseTail(input.substring(i))); // need to push back slash\n+                        _parseTail(input.substring(i)));\n             }\n             ++i;\n             if (c == '~' && i < end) {\n         }\n         // end of the road, last segment\n         return new JsonPointer(input, sb.toString(), EMPTY);\n+    }\n+\n+    protected JsonPointer _constructHead()\n+    {\n+        // ok; find out who we are to drop\n+        JsonPointer last = last();\n+        if (last == this) {\n+            return EMPTY;\n+        }\n+        // and from that, length of suffix to drop\n+        int suffixLength = last._asString.length();\n+        JsonPointer next = _nextSegment;\n+        return new JsonPointer(_asString.substring(0, _asString.length() - suffixLength), _matchingPropertyName,\n+                _matchingElementIndex, next._constructHead(suffixLength, last));\n+    }\n+\n+    protected JsonPointer _constructHead(int suffixLength, JsonPointer last)\n+    {\n+        if (this == last) {\n+            return EMPTY;\n+        }\n+        JsonPointer next = _nextSegment;\n+        String str = _asString;\n+        return new JsonPointer(str.substring(0, str.length() - suffixLength), _matchingPropertyName,\n+                _matchingElementIndex, next._constructHead(suffixLength, last));\n     }\n     \n     private static void _appendEscape(StringBuilder sb, char c) {\n--- a/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n      * follow field names; null for root level and array values.\n      */\n     public abstract String getCurrentName();\n+\n+    /**\n+     * Method for accessing currently active value being used by data-binding\n+     * (as the source of streaming data to write, or destination of data being\n+     * read), at this level in hierarchy.\n+     * The value may not exist or be available due to various limitations (at\n+     * least during reading of data, as target value object may not have yet\n+     * been constructed).\n+     * \n+     * @return Currently active value, if one has been assigned.\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        return null;\n+    }\n+\n+    /**\n+     * Method to call to pass value to be returned via {@link #getCurrentValue}; typically\n+     * called indirectly through {@link JsonParser#setCurrentValue}\n+     * or {@link JsonGenerator#setCurrentValue}).\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) { }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n      * using set of {@link TreeNode} instances. Returns\n      * root of the resulting tree (where root can consist\n      * of just a single node if the current event is a\n-     * value event, not container).\n+     * value event, not container). Empty or whitespace\n+     * documents return null.\n+     *\n+     * @return next tree from jp, or null if empty.\n      */\n     @Override\n     public abstract <T extends TreeNode> T readTree(JsonParser jp)\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n      * Functionally equivalent to first serializing tree using\n      * {@link ObjectCodec} and then re-parsing but\n      * more efficient.\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n+     *<p>\n+     * Also note that calling this method will <b>NOT</b> pass {@link ObjectCodec}\n+     * reference, so data-binding callback methods like {@link JsonParser#readValueAs(Class)}\n+     * will not work with calling {@link JsonParser#setCodec}).\n+     * It is often better to call {@link #traverse(ObjectCodec)} to pass the codec explicitly.\n      */\n     JsonParser traverse();\n \n      * Same as {@link #traverse()}, but additionally passes {@link com.fasterxml.jackson.core.ObjectCodec}\n      * to use if {@link JsonParser#readValueAs(Class)} is used (otherwise caller must call\n      * {@link JsonParser#setCodec} on response explicitly).\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n      * \n      * @since 2.1\n      */\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n  */\n public abstract class GeneratorBase extends JsonGenerator\n {\n+    public final static int SURR1_FIRST = 0xD800;\n+    public final static int SURR1_LAST = 0xDBFF;\n+    public final static int SURR2_FIRST = 0xDC00;\n+    public final static int SURR2_LAST = 0xDFFF;\n+\n     /**\n      * Set of feature masks related to features that need updates of other\n      * local configuration or state.\n      */\n     protected final static int DERIVED_FEATURES_MASK = Feature.WRITE_NUMBERS_AS_STRINGS.getMask()\n             | Feature.ESCAPE_NON_ASCII.getMask()\n-//            | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n+            | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n \n     /*\n     protected GeneratorBase(int features, ObjectCodec codec) {\n         super();\n         _features = features;\n+        _objectCodec = codec;\n         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                 ? DupDetector.rootDetector(this) : null;\n         _writeContext = JsonWriteContext.createRootContext(dups);\n+        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) {\n+        super();\n+        _features = features;\n         _objectCodec = codec;\n+        _writeContext = ctxt;\n         _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n     }\n \n      * package as the implementation class.\n      */\n     @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n-    \n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return _writeContext.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _writeContext.setCurrentValue(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Configuration\n     /**********************************************************\n      */\n \n+\n+    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n+    @Override public int getFeatureMask() { return _features; }\n+\n+    //public JsonGenerator configure(Feature f, boolean state) { }\n+    \n     @Override\n     public JsonGenerator enable(Feature f) {\n         final int mask = f.getMask();\n                 _cfgNumbersAsStrings = true;\n             } else if (f == Feature.ESCAPE_NON_ASCII) {\n                 setHighestNonEscapedChar(127);\n-                /*\n             } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n-            */\n-                // !!! TODO\n+                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n+                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n+                }\n             }\n         }\n         return this;\n                 _cfgNumbersAsStrings = false;\n             } else if (f == Feature.ESCAPE_NON_ASCII) {\n                 setHighestNonEscapedChar(0);\n-                /*\n             } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n-                // !!! TODO\n-                 */\n+                _writeContext = _writeContext.withDupDetector(null);\n             }\n         }\n         return this;\n     }\n-\n-    //public JsonGenerator configure(Feature f, boolean state) { }\n-\n-    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n-    @Override public int getFeatureMask() { return _features; }\n \n     @Override public JsonGenerator setFeatureMask(int newMask) {\n         int changed = newMask ^ _features;\n                     setHighestNonEscapedChar(0);\n                 }\n             }\n-            /*\n             if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changed)) {\n-                // !!! TODO\n-            }\n-            */\n+                if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n+                    if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n+                        _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n+                    }\n+                } else { // disabling\n+                    _writeContext = _writeContext.withDupDetector(null);\n+                }\n+            }\n         }\n         return this;\n     }\n     public void writeString(SerializableString text) throws IOException {\n         writeString(text.getValue());\n     }\n-    \n+\n     @Override public void writeRawValue(String text) throws IOException {\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text);\n     @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text, offset, len);\n+    }\n+\n+    @Override public void writeRawValue(SerializableString text) throws IOException {\n+        _verifyValueWrite(\"write raw value\");\n+        writeRaw(text);\n     }\n \n     @Override\n      *   if value output is NOT legal in current generator output state.\n      */\n     protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* UTF-8 related helper method(s)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException\n+    {\n+        // First is known to be valid, but how about the other?\n+        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n+            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n+            _reportError(msg);\n+        }\n+        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n+        return c;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n \n     @Override public Version version() { return PackageVersion.VERSION; }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return _parsingContext.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _parsingContext.setCurrentValue(v);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for Feature handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonParser enable(Feature f) {\n+        _features |= f.getMask();\n+        if (f == Feature.STRICT_DUPLICATE_DETECTION) { // enabling dup detection?\n+            if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n+                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n+            }\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser disable(Feature f) {\n+        _features &= ~f.getMask();\n+        if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n+            _parsingContext = _parsingContext.withDupDetector(null);\n+        }\n+        return this;\n+    }\n+    \n+    @Override\n+    public JsonParser setFeatureMask(int newMask) {\n+        int changes = (_features ^ newMask);\n+        if (changes != 0) {\n+            _features = newMask;\n+            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n+                if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n+                    _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n+                }\n+            } else { // disabling\n+                _parsingContext = _parsingContext.withDupDetector(null);\n+            }\n+        }\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonParser impl\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     /**********************************************************\n      */\n \n-    @Override public abstract JsonToken nextToken() throws IOException, JsonParseException;\n+    @Override public abstract JsonToken nextToken() throws IOException;\n     @Override public JsonToken getCurrentToken() { return _currToken; }\n \n     @Override public final int getCurrentTokenId() {\n         final JsonToken t = _currToken;\n         return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n     }\n-    \n+\n     @Override public boolean hasCurrentToken() { return _currToken != null; }\n+    @Override public boolean hasTokenId(int id) {\n+        final JsonToken t = _currToken;\n+        if (t == null) {\n+            return (JsonTokenId.ID_NO_TOKEN == id);\n+        }\n+        return t.id() == id;\n+    }\n+\n+    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n+    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n     \n     @Override\n     public JsonToken nextValue() throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n      *   Given that all code paths with common Jackson usage patterns go through\n      *   a few memory barriers (mostly with cache/reuse pool access) it seems safe\n      *   enough to omit volatiles here, given how simple lazy initialization is.\n-     *   This can be compared to how {@link String#intern} works; lazily and\n+     *   This can be compared to how {@link String#hashCode} works; lazily and\n      *   without synchronization or use of volatile keyword.\n      *\n      *   Change to remove volatile was a request by implementors of a high-throughput\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     \n     // // // Optional duplicate detection\n \n-    protected final DupDetector _dups;\n-    \n-    // // // Location information (minus source reference)\n-\n-    protected int _lineNr;\n-    protected int _columnNr;\n-\n-    protected String _currentName;\n-    \n+    protected DupDetector _dups;\n+\n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speeds up things\n \n     /*\n     /**********************************************************\n-    /* Instance construction, reuse\n+    /* Location/state information (minus source reference)\n+    /**********************************************************\n+     */\n+\n+    protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected Object _currentValue;\n+    \n+    protected int _lineNr;\n+    protected int _columnNr;\n+\n+    /*\n+    /**********************************************************\n+    /* Instance construction, config, reuse\n     /**********************************************************\n      */\n \n         _lineNr = lineNr;\n         _columnNr = colNr;\n         _currentName = null;\n+        _currentValue = null;\n         if (_dups != null) {\n             _dups.reset();\n         }\n     }\n     */\n \n-    // // // Factory methods\n+    public JsonReadContext withDupDetector(DupDetector dups) {\n+        _dups = dups;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _currentValue = v;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n \n     @Deprecated // since 2.3, use variant that takes dup detector\n     public static JsonReadContext createRootContext(int lineNr, int colNr) {\n         return createRootContext(lineNr, colNr, null);\n     }\n-    \n+\n     public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n     }\n         // We don't keep track of offsets at this level (only reader does)\n         long totalChars = -1L;\n         return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n+    }\n+\n+    public DupDetector getDupDetector() {\n+        return _dups;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n \n     // // // Optional duplicate detection\n \n-    protected final DupDetector _dups;\n-    \n+    protected DupDetector _dups;\n+\n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speed up things\n \n     protected JsonWriteContext _child = null;\n \n+    /*\n+    /**********************************************************\n+    /* Location/state information (minus source reference)\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Name of the field of which value is to be parsed; only\n      * used for OBJECT contexts\n      */\n     protected String _currentName;\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected Object _currentValue;\n+    \n     /**\n      * Marker used to indicate that we just received a name, and\n      * now expect a value\n         _index = -1;\n         _currentName = null;\n         _gotName = false;\n+        _currentValue = null;\n         if (_dups != null) { _dups.reset(); }\n         return this;\n     }\n-    \n-    // // // Factory methods\n+\n+    public JsonWriteContext withDupDetector(DupDetector dups) {\n+        _dups = dups;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _currentValue = v;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n \n     /**\n      * @deprecated Since 2.3; use method that takes argument\n \n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n+\n+    public DupDetector getDupDetector() {\n+        return _dups;\n+    }\n     \n     // // // API sub-classes are to implement\n \n      *\n      * @return Index of the field entry (0-based)\n      */\n-    public final int writeFieldName(String name) throws JsonProcessingException {\n+    public int writeFieldName(String name) throws JsonProcessingException {\n+        if (_gotName) {\n+            return JsonWriteContext.STATUS_EXPECT_VALUE;\n+        }\n         _gotName = true;\n         _currentName = name;\n         if (_dups != null) { _checkDup(_dups, name); }\n         if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n     }\n     \n-    public final int writeValue() {\n+    public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n             _gotName = false;\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n     private final static byte BYTE_QUOTE = (byte) '\"';\n-\n-    protected final static int SURR1_FIRST = 0xD800;\n-    protected final static int SURR1_LAST = 0xDBFF;\n-    protected final static int SURR2_FIRST = 0xDC00;\n-    protected final static int SURR2_LAST = 0xDFFF;\n \n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Output method implementations, unprocessed (\"raw\")\n             _writeBytes(raw);\n         }\n     }\n-    \n+\n+    // since 2.5\n+    @Override\n+    public void writeRawValue(SerializableString text) throws IOException {\n+        _verifyValueWrite(\"write raw value\");\n+        byte[] raw = text.asUnquotedUTF8();\n+        if (raw.length > 0) {\n+            _writeBytes(raw);\n+        }\n+    }\n+\n     // @TODO: rewrite for speed...\n     @Override\n     public final void writeRaw(char[] cbuf, int offset, int len)\n      * \n      * @throws IOException\n      */\n-    private final int _outputMultiByteChar(int ch, int outputPtr)\n-        throws IOException\n+    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n     {\n         byte[] bbuf = _outputBuffer;\n         if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n         }\n         return outputPtr;\n     }\n-\n-    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException\n-    {\n-        // First is known to be valid, but how about the other?\n-        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n-            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n-            _reportError(msg);\n-        }\n-        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n-        return c;\n-    }\n     \n     private final void _writeNull() throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      */\n \n     @Override\n-    protected final boolean loadMore()\n-        throws IOException\n+    protected final boolean loadMore() throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n         _currInputRowStart -= _inputEnd;\n         \n         if (_inputStream != null) {\n-            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n+            int space = _inputBuffer.length;\n+            if (space == 0) { // only occurs when we've been closed\n+                return false;\n+            }\n+            \n+            int count = _inputStream.read(_inputBuffer, 0, space);\n             if (count > 0) {\n                 _inputPtr = 0;\n                 _inputEnd = count;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected final boolean _loadToHaveAtLeast(int minAvailable)\n-        throws IOException\n+    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         if (_inputStream == null) {\n         if (_bufferRecyclable) {\n             byte[] buf = _inputBuffer;\n             if (buf != null) {\n-                _inputBuffer = null;\n+                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n+                 *   get slightly more meaningful error messages in case someone\n+                 *   closes parser indirectly, without realizing.\n+                 */\n+                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                 _ioContext.releaseReadIOBuffer(buf);\n             }\n         }\n     /* Public API, traversal, nextXxxValue/nextFieldName\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean nextFieldName(SerializableString str) throws IOException\n     {\n             }\n         }\n         return _isNextTokenNameMaybe(i, str);\n+    }\n+\n+    @Override\n+    public String nextFieldName() throws IOException\n+    {\n+        // // // Note: this is almost a verbatim copy of nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return null;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        _binaryValue = null;\n+\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return null;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return null;\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return null;\n+        }\n+\n+        Name n = _parseName(i);\n+        final String nameStr = n.getName();\n+        _parsingContext.setCurrentName(nameStr);\n+        _currToken = JsonToken.FIELD_NAME;\n+\n+        i = _skipColon();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameStr;\n+        }\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+             t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+\n+        default:\n+            t = _handleUnexpectedValue(i);\n+        }\n+        _nextToken = t;\n+        return nameStr;\n     }\n \n     // Variant called when we know there's at least 4 more bytes available\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consequtively. Happens rarely, so this is offlined;\n+     * to come consecutively. Happens rarely, so this is off-lined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected Name slowParseName() throws IOException\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n-            quads[qlen++] = currQuad;\n+            quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n-            quads[qlen++] = currQuad;\n+            quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n     private final Name findName(int q1, int lastQuadBytes)\n         throws JsonParseException\n     {\n+        q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         Name name = _symbols.findName(q1);\n         if (name != null) {\n     private final Name findName(int q1, int q2, int lastQuadBytes)\n         throws JsonParseException\n     {\n+        q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         Name name = _symbols.findName(q1, q2);\n         if (name != null) {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n         }\n-        quads[qlen++] = lastQuad;\n+        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             return addName(quads, qlen, lastQuadBytes);\n \n     /*\n     /**********************************************************\n-    /* Binary access\n+    /* Internal methods, binary access\n     /**********************************************************\n      */\n \n             builder.appendThreeBytes(decodedData);\n         }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method needed to fix [Issue#148], masking of 0x00 character\n+     */\n+    private final static int pad(int q, int bytes) {\n+        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     public void writeRaw(SerializableString text) throws IOException {\n         writeRaw(text.getValue());\n     }\n-    \n+\n     @Override\n     public void writeRaw(char[] text, int offset, int len) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n  * maps/sets, that hash codes are uniformly distributed. Also, collisions\n  * are slightly more expensive than with HashMap or HashSet, since hash codes\n  * are not used in resolving collisions; that is, equals() comparison is\n- * done with all symbols in same bucket index.<br />\n+ * done with all symbols in same bucket index.<br>\n  * Finally, rehashing is also more expensive, as hash codes are not\n  * stored; rehashing requires all entries' hash codes to be recalculated.\n  * Reason for not storing hash codes is reduced memory usage, hoping\n--- a/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n      * parameters (for its direct super-class and/or super-interfaces).\n      */\n     public abstract boolean hasGenericTypes();\n-    \n+\n+    /**\n+     * Accessor that can be used to find out type for which parameterization\n+     * is applied: this is often NOT same as what {@link #getRawClass} returns,\n+     * but rather one of it supertype.\n+     *<p>\n+     * For example: for type like {@link java.util.HashMap}, raw type is\n+     * {@link java.util.HashMap}; but this method would return\n+     * {@link java.util.Map}, because relevant type parameters that are\n+     * resolved (and accessible using {@link #containedType(int)} and\n+     * {@link #getKeyType()}) are parameter for {@link java.util.Map}\n+     * (which may or may not be same as type parameters for subtype;\n+     * in case of {@link java.util.HashMap} they are, but for further\n+     * subtypes they may be different parameters or possibly none at all).\n+     * \n+     * @since 2.5\n+     */\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+\n     /**\n      * Method for accessing key type for this type, assuming type\n      * has such a concept (only Map types do)\n--- a/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n  * to ensure that a Type argument is indeed given.\n  *<p>\n  * Usage is by sub-classing: here is one way to instantiate reference\n- * to generic type <code>List&lt;Integer></code>:\n+ * to generic type <code>List&lt;Integer&gt;</code>:\n  *<pre>\n- *  TypeReference ref = new TypeReference&lt;List&lt;Integer>>() { };\n+ *  TypeReference ref = new TypeReference&lt;List&lt;Integer&gt;&gt;() { };\n  *</pre>\n  * which can be passed to methods that accept TypeReference, or resolved\n  * using <code>TypeFactory</code> to obtain {@link ResolvedType}.\n--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n  */\n public final class ByteArrayBuilder extends OutputStream\n {\n-    private final static byte[] NO_BYTES = new byte[0];\n+    public final static byte[] NO_BYTES = new byte[0];\n     \n     // Size of the first block we will allocate.\n     private final static int INITIAL_BLOCK_SIZE = 500;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+/**\n+ * Default linefeed-based indenter, used by {@link DefaultPrettyPrinter} (unless\n+ * overridden). Uses system-specific linefeeds and 2 spaces for indentation per level.\n+ * \n+ * @since 2.5\n+ */\n+public class DefaultIndenter\n+    extends DefaultPrettyPrinter.NopIndenter\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static String SYS_LF;\n+    static {\n+        String lf;\n+        try {\n+            lf = System.getProperty(\"line.separator\");\n+        } catch (Throwable t) {\n+            lf = \"\\n\"; // fallback when security manager denies access\n+        }\n+        SYS_LF = lf;\n+    }\n+\n+    public static final DefaultIndenter SYSTEM_LINEFEED_INSTANCE = new DefaultIndenter(\"  \", SYS_LF);\n+\n+    /**\n+     * We expect to rarely get indentation deeper than this number of levels,\n+     * and try not to pre-generate more indentations than needed.\n+     */\n+    private final static int INDENT_LEVELS = 16;\n+    private final char[] indents;\n+    private final int charsPerLevel;\n+    private final String eol;\n+\n+    /** Indent with two spaces and the system's default line feed */\n+    public DefaultIndenter() {\n+        this(\"  \", SYS_LF);\n+    }\n+    \n+    /** Create an indenter which uses the <code>indent</code> string to indent one level\n+     *  and the <code>eol</code> string to separate lines.\n+     */\n+    public DefaultIndenter(String indent, String eol)\n+    {\n+        charsPerLevel = indent.length();\n+\n+        indents = new char[indent.length() * INDENT_LEVELS];\n+        int offset = 0;\n+        for (int i=0; i<INDENT_LEVELS; i++) {\n+            indent.getChars(0, indent.length(), indents, offset);\n+            offset += indent.length();\n+        }\n+\n+        this.eol = eol;\n+    }\n+    \n+    public DefaultIndenter withLinefeed(String lf)\n+    {\n+        if (lf.equals(eol)) {\n+            return this;\n+        }\n+        return new DefaultIndenter(getIndent(), lf);\n+    }\n+    \n+    public DefaultIndenter withIndent(String indent)\n+    {\n+        if (indent.equals(getIndent())) {\n+            return this;\n+        }\n+        return new DefaultIndenter(indent, eol);\n+    }\n+\n+    @Override\n+    public boolean isInline() { return false; }\n+\n+    @Override\n+    public void writeIndentation(JsonGenerator jg, int level) throws IOException\n+    {\n+        jg.writeRaw(eol);\n+        if (level > 0) { // should we err on negative values (as there's some flaw?)\n+            level *= charsPerLevel;\n+            while (level > indents.length) { // unlike to happen but just in case\n+                jg.writeRaw(indents, 0, indents.length); \n+                level -= indents.length;\n+            }\n+            jg.writeRaw(indents, 0, level);\n+        }\n+    }\n+    \n+    public String getEol() {\n+        return eol;\n+    }\n+    \n+    public String getIndent() {\n+        return new String(indents, 0, charsPerLevel);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n package com.fasterxml.jackson.core.util;\n \n import java.io.*;\n-import java.util.Arrays;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n     implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>,\n         java.io.Serializable\n {\n-    private static final long serialVersionUID = -5512586643324525213L;\n+    private static final long serialVersionUID = 1;\n \n     /**\n      * Constant that specifies default \"root-level\" separator to use between\n      */\n     public interface Indenter\n     {\n-        void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException;\n+        void writeIndentation(JsonGenerator jg, int level) throws IOException;\n \n         /**\n          * @return True if indenter is considered inline (does not add linefeeds),\n      * system-specific linefeeds, and 2 spaces per level (as opposed to,\n      * say, single tabs)\n      */\n-    protected Indenter _objectIndenter = Lf2SpacesIndenter.instance;\n+    protected Indenter _objectIndenter = DefaultIndenter.SYSTEM_LINEFEED_INSTANCE;\n \n     /**\n      * String printed between root-level values, if any.\n         public static final NopIndenter instance = new NopIndenter();\n \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n-        { }\n+        public void writeIndentation(JsonGenerator jg, int level) throws IOException { }\n \n         @Override\n         public boolean isInline() { return true; }\n         @Override\n         public boolean isInline() { return true; }\n     }\n-\n-    /**\n-     * Default linefeed-based indenter uses system-specific linefeeds and\n-     * 2 spaces for indentation per level.\n-     */\n-    public static class Lf2SpacesIndenter extends NopIndenter\n-    {\n-        private final static String SYS_LF;\n-        static {\n-            String lf = null;\n-            try {\n-                lf = System.getProperty(\"line.separator\");\n-            } catch (Throwable t) { } // access exception?\n-            SYS_LF = (lf == null) ? \"\\n\" : lf;\n-        }\n-\n-        final static int SPACE_COUNT = 64;\n-        final static char[] SPACES = new char[SPACE_COUNT];\n-        static {\n-            Arrays.fill(SPACES, ' ');\n-        }\n-\n+    \n+    /**\n+     * @deprecated Since 2.5 use {@link DefaultIndenter} instead\n+     */\n+    @Deprecated\n+    public static class Lf2SpacesIndenter extends DefaultIndenter\n+    {\n+        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n+         */\n         @SuppressWarnings(\"hiding\")\n+        @Deprecated\n         public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n \n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n+         */\n+        @Deprecated\n+        public Lf2SpacesIndenter() {\n+            super(\"  \", DefaultIndenter.SYS_LF);\n+        }\n+        \n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n+         */\n+        @Deprecated\n+        public Lf2SpacesIndenter(String lf) {\n+            super(\"  \", lf);\n+        }\n+\n         /**\n-         * Linefeed used; default value is the platform-specific linefeed.\n+         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n+         * later 2.5.x versions.\n          */\n-        protected final String _lf;\n-\n-        public Lf2SpacesIndenter() { this(SYS_LF); }\n-        \n-        /**\n-         * @since 2.3\n-         */\n-        public Lf2SpacesIndenter(String lf) {\n-            _lf = lf;\n-        }\n-\n-        /**\n-         * \"Mutant factory\" method that will return an instance that uses\n-         * specified String as linefeed.\n-         * \n-         * @since 2.3\n-         */\n-        public Lf2SpacesIndenter withLinefeed(String lf)\n-        {\n-            if (lf.equals(_lf)) {\n+        @Override\n+        public Lf2SpacesIndenter withLinefeed(String lf) {\n+            if (lf.equals(getEol())) {\n                 return this;\n             }\n             return new Lf2SpacesIndenter(lf);\n         }\n-        \n-        @Override\n-        public boolean isInline() { return false; }\n-\n-        @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n-        {\n-            jg.writeRaw(_lf);\n-            if (level > 0) { // should we err on negative values (as there's some flaw?)\n-                level += level; // 2 spaces per level\n-                while (level > SPACE_COUNT) { // should never happen but...\n-                    jg.writeRaw(SPACES, 0, SPACE_COUNT); \n-                    level -= SPACES.length;\n-                }\n-                jg.writeRaw(SPACES, 0, level);\n-            }\n-        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n         this.delegateCopyMethods = delegateCopyMethods;\n     }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return delegate.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        delegate.setCurrentValue(v);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended API\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n         delegate = d;\n     }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return delegate.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        delegate.setCurrentValue(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, configuration\n     @Override public JsonToken getCurrentToken() { return delegate.getCurrentToken(); }\n     @Override public int getCurrentTokenId() { return delegate.getCurrentTokenId(); }\n     @Override public boolean hasCurrentToken() { return delegate.hasCurrentToken(); }\n+    @Override public boolean hasTokenId(int id) { return delegate.hasTokenId(id); }\n+    \n     @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n     @Override public boolean isExpectedStartArrayToken() { return delegate.isExpectedStartArrayToken(); }\n+    @Override public boolean isExpectedStartObjectToken() { return delegate.isExpectedStartObjectToken(); }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     public int getCurrentSegmentSize() { return _currentSize; }\n     public void setCurrentLength(int len) { _currentSize = len; }\n \n+    /**\n+     * @since 2.6\n+     */\n+    public String setCurrentAndReturn(int len) {\n+        _currentSize = len;\n+        // We can simplify handling here compared to full `contentsAsString()`:\n+        if (_segmentSize > 0) { // longer text; call main method\n+            return contentsAsString();\n+        }\n+        // more common case: single segment\n+        int currLen = _currentSize;\n+        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n+        _resultString = str;\n+        return str;\n+    }\n+    \n     public char[] finishCurrentSegment() {\n         if (_segments == null) {\n             _segments = new ArrayList<char[]>();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    protected final static String FIELD_BASENAME = \"f\";\n+    \n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+\n+    protected void fieldNameFor(StringBuilder sb, int index)\n+    {\n+        /* let's do something like \"f1.1\" to exercise different\n+         * field names (important for byte-based codec)\n+         * Other name shuffling done mostly just for fun... :)\n+         */\n+        sb.append(FIELD_BASENAME);\n+        sb.append(index);\n+        if (index > 50) {\n+            sb.append('.');\n+            if (index > 200) {\n+                sb.append(index);\n+                if (index > 4000) { // and some even longer symbols...\n+                    sb.append(\".\").append(index);\n+                }\n+            } else {\n+                sb.append(index >> 3); // divide by 8\n+            }\n+        }\n+    }\n+\n+    protected String fieldNameFor(int index)\n+    {\n+        StringBuilder sb = new StringBuilder(16);\n+        fieldNameFor(sb, index);\n+        return sb.toString();\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n package com.fasterxml.jackson.core;\n \n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestExceptions extends BaseTest\n {\n--- a/src/test/java/com/fasterxml/jackson/core/TestJDKSerializability.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJDKSerializability.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit tests for [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n package com.fasterxml.jackson.core;\n \n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestJsonPointer extends BaseTest\n {\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"Image\", ptr.getMatchingProperty());\n+        assertEquals(\"/Image/15\", ptr.head().toString());\n         assertEquals(INPUT, ptr.toString());\n \n         ptr = ptr.tail();\n         assertEquals(15, ptr.getMatchingIndex());\n         assertEquals(\"15\", ptr.getMatchingProperty());\n         assertEquals(\"/15/name\", ptr.toString());\n+        assertEquals(\"/15\", ptr.head().toString());\n+\n+        assertEquals(\"\", ptr.head().head().toString());\n+        assertNull(ptr.head().head().head());\n \n         ptr = ptr.tail();\n         assertNotNull(ptr);\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"name\", ptr.getMatchingProperty());\n         assertEquals(\"/name\", ptr.toString());\n+        assertEquals(\"\", ptr.head().toString());\n+        assertSame(JsonPointer.EMPTY, ptr.head());\n \n         // done!\n         ptr = ptr.tail();\n         assertTrue(ptr.matches());\n         assertNull(ptr.tail());\n+        assertNull(ptr.head());\n         assertEquals(\"\", ptr.getMatchingProperty());\n         assertEquals(-1, ptr.getMatchingIndex());\n+    }\n+\n+    public void testSimplePathLonger() throws Exception\n+    {\n+        final String INPUT = \"/a/b/c/d/e/f/0\";\n+        JsonPointer ptr = JsonPointer.compile(INPUT);\n+        assertFalse(ptr.matches());\n+        assertEquals(-1, ptr.getMatchingIndex());\n+        assertEquals(\"a\", ptr.getMatchingProperty());\n+        assertEquals(\"/a/b/c/d/e/f\", ptr.head().toString());\n+        assertEquals(\"/b/c/d/e/f/0\", ptr.tail().toString());\n+        assertEquals(\"/0\", ptr.last().toString());\n+        assertEquals(INPUT, ptr.toString());\n     }\n \n     public void testWonkyNumber173() throws Exception\n         assertEquals(-1, ptr.getMatchingIndex());\n     }\n \n+    public void testLast()\n+    {\n+        final String INPUT = \"/Image/15/name\";\n+\n+        JsonPointer ptr = JsonPointer.compile(INPUT);\n+        JsonPointer leaf = ptr.last();\n+\n+        assertEquals(\"name\", leaf.getMatchingProperty());\n+    }\n+\n+    public void testEmpty()\n+    {\n+        // note: this is acceptable, to match property in '{\"\":3}', for example\n+        // and NOT same as what empty point, \"\", is.\n+        JsonPointer ptr = JsonPointer.compile(\"/\");\n+        assertNotNull(ptr);\n+        assertNotSame(JsonPointer.EMPTY, ptr);\n+        assertEquals(\"/\", ptr.toString());\n+    }\n+\n+    public void testAppend()\n+    {\n+        final String INPUT = \"/Image/15/name\";\n+        final String APPEND = \"/extension\";\n+\n+        JsonPointer ptr = JsonPointer.compile(INPUT);\n+        JsonPointer apd = JsonPointer.compile(APPEND);\n+\n+        JsonPointer appended = ptr.append(apd);\n+\n+        assertEquals(\"extension\", appended.last().getMatchingProperty());\n+    }\n+\n+    public void testAppendWithFinalSlash()\n+    {\n+        final String INPUT = \"/Image/15/name/\";\n+        final String APPEND = \"/extension\";\n+\n+        JsonPointer ptr = JsonPointer.compile(INPUT);\n+        JsonPointer apd = JsonPointer.compile(APPEND);\n+\n+        JsonPointer appended = ptr.append(apd);\n+\n+        assertEquals(\"extension\", appended.last().getMatchingProperty());\n+    }\n+\n     public void testQuotedPath() throws Exception\n     {\n         final String INPUT = \"/w~1out/til~0de/a~1b\";\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"w/out\", ptr.getMatchingProperty());\n+        assertEquals(\"/w~1out/til~0de\", ptr.head().toString());\n         assertEquals(INPUT, ptr.toString());\n \n         ptr = ptr.tail();\n         assertFalse(ptr.matches());\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"til~de\", ptr.getMatchingProperty());\n+        assertEquals(\"/til~0de\", ptr.head().toString());\n         assertEquals(\"/til~0de/a~1b\", ptr.toString());\n \n         ptr = ptr.tail();\n         assertEquals(-1, ptr.getMatchingIndex());\n         assertEquals(\"a/b\", ptr.getMatchingProperty());\n         assertEquals(\"/a~1b\", ptr.toString());\n+        assertEquals(\"\", ptr.head().toString());\n \n         // done!\n         ptr = ptr.tail();\n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n /**\n  * Tests to verify [JACKSON-278]\n  */\n-public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersions extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testCoreVersions() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Codec.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Codec.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Codec\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testProps()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Generation\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     static class ThrottledInputStream extends FilterInputStream\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Parsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testBase64UsingInputStream() throws Exception\n     {\n         return result;\n     }\n \n-    @SuppressWarnings(\"resource\")\n     private void _testStreaming(boolean useBytes) throws IOException\n     {\n         final int[] SIZES = new int[] {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n  * Tests for verifying that accessing base64 encoded content works ok.\n  */\n public class TestJsonParserBinary\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/format/TestJsonFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/core/format/TestJsonFormatDetection.java\n import com.fasterxml.jackson.core.format.DataFormatMatcher;\n import com.fasterxml.jackson.core.format.MatchStrength;\n \n-public class TestJsonFormatDetection extends com.fasterxml.jackson.test.BaseTest\n+public class TestJsonFormatDetection extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimpleValidArray() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestCharTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestCharTypes.java\n package com.fasterxml.jackson.core.io;\n \n public class TestCharTypes\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAppendQuoted0_31 ()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestIOContext\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAllocations() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n import com.fasterxml.jackson.core.*;\n \n public class TestJDKSerializable\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testLocationSerializability() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestJsonStringEncoder.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJsonStringEncoder.java\n import com.fasterxml.jackson.core.io.JsonStringEncoder;\n \n public class TestJsonStringEncoder\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testQuoteAsString() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestMergedStream.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestMergedStream.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestMergedStream\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimple() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestUTF8Writer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestUTF8Writer.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestUTF8Writer\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimple() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n  * functionality works as expected.\n  */\n public class TestCharEscaping\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // for [JACKSON-627]\n     @SuppressWarnings(\"serial\")\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestComments.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestComments.java\n  * works as expected.\n  */\n public class TestComments\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String DOC_WITH_SLASHSTAR_COMMENT =\n         \"[ /* comment:\\n ends here */ 1 /* one more ok to have \\\"unquoted\\\"  */ ]\"\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SerializedString;\n \n-public class TestCustomEscaping extends com.fasterxml.jackson.test.BaseTest\n+public class TestCustomEscaping extends com.fasterxml.jackson.core.BaseTest\n {\n     final static int TWO_BYTE_ESCAPED = 0x111;\n     final static int THREE_BYTE_ESCAPED = 0x1111;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestDecorators.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestDecorators.java\n  * @since 1.8\n  */\n @SuppressWarnings(\"serial\")\n-public class TestDecorators extends com.fasterxml.jackson.test.BaseTest\n+public class TestDecorators extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n import com.fasterxml.jackson.core.*;\n \n public class TestGeneratorDupHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n-    public void testSimpleDups() throws Exception\n+    public void testSimpleDupsEagerlyBytes() throws Exception {\n+        _testSimpleDups(true, false, new JsonFactory());\n+    }\n+    public void testSimpleDupsEagerlyChars() throws Exception {\n+        _testSimpleDups(false, false, new JsonFactory());\n+    }\n+\n+    // Testing ability to enable checking after construction of\n+    // generator, not just via JsonFactory\n+    public void testSimpleDupsLazilyBytes() throws Exception {\n+        final JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION));\n+        _testSimpleDups(true, true, f);\n+    }\n+\n+    public void testSimpleDupsLazilyChars() throws Exception {\n+        final JsonFactory f = new JsonFactory();\n+        _testSimpleDups(false, true, f);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    protected void _testSimpleDups(boolean useStream, boolean lazySetting, JsonFactory f)\n+            throws Exception\n     {\n-        _testSimpleDups(false);\n-        _testSimpleDups(true);\n-    }\n-    \n-    protected void _testSimpleDups(boolean useStream) throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        assertFalse(f.isEnabled(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION));\n-\n         // First: fine, when not checking\n-        _writeSimple0(_generator(f, useStream), \"a\");\n-        _writeSimple1(_generator(f, useStream), \"b\");\n+        if (!lazySetting) {\n+            _writeSimple0(_generator(f, useStream), \"a\");\n+            _writeSimple1(_generator(f, useStream), \"b\");\n+        }\n \n         // but not when checking\n-        f.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);\n+        JsonGenerator g1;\n+\n+        if (lazySetting) {\n+            g1 = _generator(f, useStream);            \n+            g1.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);\n+        } else {\n+            f.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);\n+            g1 = _generator(f, useStream);            \n+        }\n         try {\n-            _writeSimple0( _generator(f, useStream), \"a\");\n+            _writeSimple0(g1, \"a\");\n             fail(\"Should have gotten exception\");\n         } catch (JsonGenerationException e) {\n             verifyException(e, \"duplicate field 'a'\");\n         }\n \n+        JsonGenerator g2;\n+        if (lazySetting) {\n+            g2 = _generator(f, useStream);            \n+            g2.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);\n+        } else {\n+            g2 = _generator(f, useStream);            \n+        }\n         try {\n-            _writeSimple1( _generator(f, useStream), \"x\");\n+            _writeSimple1(g2, \"x\");\n             fail(\"Should have gotten exception\");\n         } catch (JsonGenerationException e) {\n             verifyException(e, \"duplicate field 'x'\");\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorWithSerializedString.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorWithSerializedString.java\n import com.fasterxml.jackson.core.io.SerializedString;\n \n public class TestGeneratorWithSerializedString\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String NAME_WITH_QUOTES = \"\\\"name\\\"\";\n     final static String NAME_WITH_LATIN1 = \"P\\u00f6ll\\u00f6\";\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java\n import com.fasterxml.jackson.core.*;\n \n public class TestJsonFactory\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testGeneratorFeatures() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n  * functionality works as expected.\n  */\n public class TestJsonGenerator\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // // // First, tests for primitive (non-structured) values\n \n-    @SuppressWarnings(\"resource\")\n     public void testStringWrite() throws Exception\n     {\n         JsonFactory jf = new JsonFactory();\n         \n         gen.close();\n     }\n-    \n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testDupFieldNameWrites(f, false);\n+        _testDupFieldNameWrites(f, true);        \n+    }\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n  * functionality works as expected.\n  */\n public class TestJsonGeneratorFeatures\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testConfigDefaults() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n  * functionality works as expected.\n  */\n public class TestJsonParser\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory JSON_FACTORY = new JsonFactory();\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n import com.fasterxml.jackson.core.*;\n \n // NOTE: just a stub so for, fill me!\n-public class TestLocation extends com.fasterxml.jackson.test.BaseTest\n+public class TestLocation extends com.fasterxml.jackson.core.BaseTest\n {\n     // Trivially simple unit test for basics wrt offsets\n     public void testSimpleInitialOffsets() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n import com.fasterxml.jackson.core.io.SerializedString;\n \n public class TestNextXxx\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /********************************************************\n         _testIsNextTokenName1(true);\n         _testIsNextTokenName2(false);\n         _testIsNextTokenName2(true);\n+        _testIsNextTokenName3(false);\n+        _testIsNextTokenName3(true);\n     }\n \n     // [Issue#34]\n         jp.close();\n     }\n \n+    private void _testIsNextTokenName3(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":123,\\\"name2\\\":14,\\\"x\\\":\\\"name\\\"}\";\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = useStream ?\n+            jf.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : jf.createParser(new StringReader(DOC));\n+        assertNull(jp.nextFieldName());\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken());\n+        assertEquals(\"name\", jp.nextFieldName());\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"name\", jp.getCurrentName());\n+        assertEquals(\"name\", jp.getText());\n+        assertNull(jp.nextFieldName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken());\n+        assertEquals(123, jp.getIntValue());\n+\n+        assertEquals(\"name2\", jp.nextFieldName());\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"name2\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        assertEquals(\"x\", jp.nextFieldName());\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"x\", jp.getCurrentName());\n+\n+        assertNull(jp.nextFieldName());\n+        assertToken(JsonToken.VALUE_STRING, jp.getCurrentToken());\n+\n+        assertNull(jp.nextFieldName());\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+\n+        assertNull(jp.nextFieldName());\n+        assertNull(jp.getCurrentToken());\n+\n+        jp.close();\n+    }\n+\n     private void _testIssue34(boolean useStream) throws Exception\n     {\n         final int TESTROUNDS = 223;\n         final String DOC_PART = \"{ \\\"fieldName\\\": 1 }\";\n-        \n+\n         // build the big document to trigger issue\n         StringBuilder sb = new StringBuilder(2000);\n         for (int i = 0; i < TESTROUNDS; ++i) {\n             sb.append(DOC_PART);\n         }\n         final String DOC = sb.toString();\n-        \n+\n         SerializableString fieldName = new SerializedString(\"fieldName\");\n         JsonFactory jf = new JsonFactory();\n         JsonParser parser = useStream ?\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n  */\n @SuppressWarnings(\"resource\")\n public class TestNumericValues\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory FACTORY = new JsonFactory();\n     \n             sb.append('9');\n         }\n         String NUM = sb.toString();\n+        // force use of new factory, just in case (might still recycle same buffers tho?)\n         JsonFactory f = new JsonFactory();\n         _testLongNumbers(f, NUM, false);\n         _testLongNumbers(f, NUM, true);\n     {\n         final String doc = \"[ \"+num+\" ]\";\n         JsonParser jp = useStream\n-                ? FACTORY.createParser(doc.getBytes(\"UTF-8\"))\n-                        : FACTORY.createParser(doc);\n+                ? f.createParser(doc.getBytes(\"UTF-8\"))\n+                        : f.createParser(doc);\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n         assertEquals(num, jp.getText());\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserDupHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserDupHandling.java\n import com.fasterxml.jackson.core.*;\n \n public class TestParserDupHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n-    public void testSimpleDups() throws Exception\n-    {\n-        for (String doc : new String[] {\n+    private final String[] DUP_DOCS = new String[] {\n             \"{ 'a':1, 'a':2 }\",\n             \"[{ 'a':1, 'a':2 }]\",\n             \"{ 'a':1, 'b':2, 'c':3,'a':true,'e':false }\",\n             \"{ 'foo': { 'bar': [ [ { 'x':3, 'a':1 } ]], 'x':0, 'a':'y', 'b':3,'a':13 } }\",\n             \"[{'b':1},{'b\\\":3},[{'a':3}], {'a':1,'a':2}]\",\n             \"{'b':1,'array':[{'b':3}],'ob':{'b':4,'x':0,'y':3,'a':true,'a':false }}\",\n-        }) {\n-            doc = doc.replace(\"'\", \"\\\"\");\n-            JsonFactory f = new JsonFactory();\n-            assertFalse(f.isEnabled(JsonParser.Feature.STRICT_DUPLICATE_DETECTION));\n+    };\n+    {\n+        for (int i = 0; i < DUP_DOCS.length; ++i) {\n+            DUP_DOCS[i] = DUP_DOCS[i].replace(\"'\", \"\\\"\");\n+        }\n+    }\n+    \n+    public void testSimpleDupsDisabled() throws Exception\n+    {\n+        // first: verify no problems if detection NOT enabled\n+        final JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonParser.Feature.STRICT_DUPLICATE_DETECTION));\n+        for (String doc : DUP_DOCS) {\n             _testSimpleDupsOk(doc, f, false);\n             _testSimpleDupsOk(doc, f, true);\n-    \n-            f.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);\n-            _testSimpleDupsFail(doc, f, false, \"a\");\n-            _testSimpleDupsFail(doc, f, true, \"a\");\n         }\n     }\n \n-    private void _testSimpleDupsOk(final String doc, JsonFactory f, boolean useStream) throws Exception\n+    public void testSimpleDupsBytes() throws Exception\n+    {\n+        JsonFactory nonDupF = new JsonFactory();\n+        JsonFactory dupF = new JsonFactory();\n+        dupF.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);\n+        for (String doc : DUP_DOCS) {\n+            // First, with static setting\n+            _testSimpleDupsFail(doc, dupF, true, \"a\", false);\n+\n+            // and then dynamic\n+            _testSimpleDupsFail(doc, nonDupF, true, \"a\", true);\n+        }\n+    }\n+\n+    public void testSimpleDupsChars() throws Exception\n+    {\n+        JsonFactory nonDupF = new JsonFactory();\n+        JsonFactory dupF = new JsonFactory();\n+        dupF.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);\n+        for (String doc : DUP_DOCS) {\n+            _testSimpleDupsFail(doc, dupF, false, \"a\", false);\n+            _testSimpleDupsFail(doc, nonDupF, false, \"a\", true);\n+        }\n+    }\n+    \n+    private void _testSimpleDupsOk(final String doc, JsonFactory f,\n+            boolean useStream) throws Exception\n     {\n         JsonParser jp = useStream ?\n                 createParserUsingStream(f, doc, \"UTF-8\") : createParserUsingReader(f, doc);\n     }\n \n     private void _testSimpleDupsFail(final String doc, JsonFactory f,\n-            boolean useStream, String name) throws Exception\n+            boolean useStream, String name, boolean lazily) throws Exception\n     {\n         JsonParser jp = useStream ?\n                 createParserUsingStream(f, doc, \"UTF-8\") : createParserUsingReader(f, doc);\n+        if (lazily) {\n+            jp.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION);\n+        }\n         JsonToken t = jp.nextToken();\n         assertNotNull(t);\n         assertTrue(t.isStructStart());\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n import com.fasterxml.jackson.core.JsonToken;\n \n public class TestParserErrorHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testInvalidKeywordsStream() throws Exception {\n         _testInvalidKeywords(true);\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n import com.fasterxml.jackson.core.*;\n \n public class TestParserNonStandard\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // // // And then tests to verify [JACKSON-69]:\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserOverrides.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserOverrides.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n \n-public class TestParserOverrides extends com.fasterxml.jackson.test.BaseTest\n+public class TestParserOverrides extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestParserSymbols\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    // For [Issue#148]\n+    public void testSymbolsWithNullBytes() throws Exception {\n+        _testSymbolsWithNull(true);\n+    }\n+\n+    // For [Issue#148]\n+    public void testSymbolsWithNullChars() throws Exception {\n+        _testSymbolsWithNull(false);\n+    }\n+    \n+    private void _testSymbolsWithNull(boolean useBytes) throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n+        JsonParser parser = useBytes ? f.createParser(INPUT.getBytes(\"UTF-8\"))\n+                : f.createParser(INPUT);\n+\n+        assertToken(JsonToken.START_OBJECT, parser.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n+        assertEquals(\"\\u0000abc\", parser.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n+        assertEquals(1, parser.getIntValue());\n+\n+        assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n+        assertEquals(\"abc\", parser.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n+        assertEquals(2, parser.getIntValue());\n+        \n+        assertToken(JsonToken.END_OBJECT, parser.nextToken());\n+        parser.close();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n import com.fasterxml.jackson.core.*;\n \n public class TestRootValues\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory JSON_F = new JsonFactory();\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n \n import com.fasterxml.jackson.core.*;\n \n-public class TestUnicode extends com.fasterxml.jackson.test.BaseTest\n+public class TestUnicode extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSurrogates() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestUtf8Generator\n     extends BaseTest\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n import java.util.Random;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestValueConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestValueConversions.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n \n-@SuppressWarnings(\"resource\")\n public class TestValueConversions\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAsInt() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestWithTonsaSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestWithTonsaSymbols.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Some unit tests to try to exercise part of parser code that\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n  * edge cases.\n  */\n public class TestArrayParsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testValidEmpty() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorArray.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorArray.java\n  * of {@link JsonGenerator} work as expected.\n  */\n public class TestGeneratorArray\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testEmptyArrayWrite()\n         throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorCopy.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorCopy.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n  * Set of basic unit tests for verifying basic generator\n  * features.\n  */\n-@SuppressWarnings(\"resource\")\n public class TestGeneratorMisc\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorObject.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorObject.java\n package com.fasterxml.jackson.core.main;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n import java.math.BigDecimal;\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestNumberParsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestNumberParsing.java\n  * handling methods work as expected.\n  */\n public class TestNumberParsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testIntParsing() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserClosing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserClosing.java\n import static org.junit.Assert.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n  * settings work as expected.\n  */\n public class TestParserFeatures\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testDefaultSettings()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.IOException;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n  * be accessed using JsonParser.\n  */\n public class TestParserWithObjects\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n \n     /*\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n  */\n @SuppressWarnings(\"serial\")\n public class TestPrettyPrinter\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     static class CountPrinter extends MinimalPrettyPrinter\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n import static org.junit.Assert.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n-/**\n- * @since 1.7\n- */\n-public class TestRawStringWriting extends com.fasterxml.jackson.test.BaseTest\n+public class TestRawStringWriting extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Unit test for \"JsonGenerator.writeRawUTF8String()\"\n         assertToken(JsonToken.END_ARRAY, jp.nextToken());\n         jp.close();\n     }\n+\n+    public void testWriteRawWithSerializable() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        \n+        _testWithRaw(jf, true);\n+        _testWithRaw(jf, false);\n+    }\n+    \n+    private void _testWithRaw(JsonFactory f, boolean useBytes) throws Exception\n+    {\n+        JsonGenerator jgen;\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        StringWriter sw = new StringWriter();\n+\n+        if (useBytes) {\n+            jgen = f.createGenerator(bytes, JsonEncoding.UTF8);\n+        } else {\n+            jgen = f.createGenerator(sw);\n+        }\n+\n+        jgen.writeStartArray();\n+        jgen.writeRawValue(new SerializedString(\"\\\"foo\\\"\"));\n+        jgen.writeRawValue(new SerializedString(\"12\"));\n+        jgen.writeRaw(new SerializedString(\", false\"));\n+        jgen.writeEndArray();\n+        jgen.close();\n+\n+        JsonParser p = useBytes\n+                ? f.createParser(bytes.toByteArray())\n+                : f.createParser(sw.toString());\n+\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(\"foo\", p.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(12, p.getIntValue());\n+        assertToken(JsonToken.VALUE_FALSE, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Set of basic unit tests for verifying that Array/Object scopes\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java\n \n import java.io.*;\n \n-\n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.util.Random;\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n  * good at catching it...).\n  */\n public class TestByteBasedSymbols\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String[] FIELD_NAMES = new String[] {\n         \"a\", \"b\", \"c\", \"x\", \"y\", \"b13\", \"abcdefg\", \"a123\",\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestHashCollisionChars.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestHashCollisionChars.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Some unit tests to try to exercise part of parser code that\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n  */\n @SuppressWarnings(\"serial\")\n public class TestJsonParserSymbols\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * To peek into state of \"root\" symbol tables (parent of all symbol\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n import com.fasterxml.jackson.core.JsonFactory;\n \n-public class TestSymbolTables extends com.fasterxml.jackson.test.BaseTest\n+public class TestSymbolTables extends com.fasterxml.jackson.core.BaseTest\n {\n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and character-based input\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestCharTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestCharTypes.java\n import com.fasterxml.jackson.core.io.CharTypes;\n \n public class TestCharTypes\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testQuoting()\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDefaultPrettyPrinter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+\n+public class TestDefaultPrettyPrinter\n+{\n+    @Test\n+    public void testSystemLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter();\n+        String LF = System.getProperty(\"line.separator\");\n+        assertEquals(\n+            \"{\" + LF +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\" + LF +\n+            \"  \\\"age\\\" : 3.14\" + LF +\n+            \"}\", _printTestData(pp));\n+    }\n+\n+    @Test\n+    public void testWithLineFeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter().withLinefeed(\"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"  \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testWithIndent() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter().withIndent(\" \"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \" \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \" \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testUnixLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+                .withObjectIndenter(new DefaultIndenter(\"  \", \"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"  \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testWindowsLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter(\"  \", \"\\r\\n\"));\n+        assertEquals(\n+            \"{\\r\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\r\\n\" +\n+            \"  \\\"age\\\" : 3.14\\r\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testTabIndent() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter(\"\\t\", \"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"\\t\\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"\\t\\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+\n+    private String _printTestData(PrettyPrinter pp) throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+        gen.setPrettyPrinter(pp);\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"name\");\n+        gen.writeString(\"John Doe\");\n+        gen.writeFieldName(\"age\");\n+        gen.writeNumber(3.14);\n+        gen.writeEndObject();\n+        gen.close();\n+        return sw.toString();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n \n import com.fasterxml.jackson.core.*;\n \n-public class TestDelegates extends com.fasterxml.jackson.test.BaseTest\n+public class TestDelegates extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Test default, non-overridden parser delegate.\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n  * printingg methods work as expected.\n  */\n public class TestNumberPrinting\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testIntPrinting()\n         throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestSerializedString.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestSerializedString.java\n  * {@link SerializableString} implementation works as expected.\n  */\n public class TestSerializedString\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAppending() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n import com.fasterxml.jackson.core.util.TextBuffer;\n \n public class TestTextBuffer\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Trivially simple basic test to ensure all basic append\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n import com.fasterxml.jackson.core.json.PackageVersion;\n import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n \n-public class TestVersionUtil extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersionUtil extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testVersionPartParsing()\n     {", "timestamp": 1424123271, "metainfo": ""}