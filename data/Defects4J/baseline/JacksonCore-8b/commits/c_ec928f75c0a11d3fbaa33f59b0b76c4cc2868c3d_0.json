{"sha": "ec928f75c0a11d3fbaa33f59b0b76c4cc2868c3d", "log": "minor trimming of number parsing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         int startPtr = ptr-1; // to include sign/digit already read\n         final int inputLen = _inputEnd;\n \n-        dummy_loop:\n-        do { // dummy loop, to be able to break out\n-            if (neg) { // need to read the next digit\n-                if (ptr >= inputLen) {\n-                    break dummy_loop;\n-                }\n-                ch = _inputBuffer[ptr++];\n-                // First check: must have a digit to follow minus sign\n-                if (ch > INT_9 || ch < INT_0) {\n-                    _inputPtr = ptr;\n-                    return _handleInvalidNumberStart(ch, true);\n-                }\n-                /* (note: has been checked for non-negative already, in\n-                 * the dispatching code that determined it should be\n-                 * a numeric value)\n-                 */\n-            }\n-            // One special case, leading zero(es):\n-            if (ch == INT_0) {\n-                break dummy_loop;\n-            }\n+        if (neg) { // need to read the next digit\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            ch = _inputBuffer[ptr++];\n+            // First check: must have a digit to follow minus sign\n+            if (ch > INT_9 || ch < INT_0) {\n+                _inputPtr = ptr;\n+                return _handleInvalidNumberStart(ch, true);\n+            }\n+            /* (note: has been checked for non-negative already, in\n+             * the dispatching code that determined it should be\n+             * a numeric value)\n+             */\n+        }\n+        // One special case, leading zero(es):\n+        if (ch == INT_0) {\n+            _inputPtr = neg ? (startPtr+1) : startPtr;\n+            return _parseNumber2(neg);\n+        }\n             \n-            /* First, let's see if the whole number is contained within\n-             * the input buffer unsplit. This should be the common case;\n-             * and to simplify processing, we will just reparse contents\n-             * in the alternative case (number split on buffer boundary)\n-             */\n-            \n-            int intLen = 1; // already got one\n-            \n-            // First let's get the obligatory integer part:\n-            \n-            int_loop:\n+        /* First, let's see if the whole number is contained within\n+         * the input buffer unsplit. This should be the common case;\n+         * and to simplify processing, we will just reparse contents\n+         * in the alternative case (number split on buffer boundary)\n+         */\n+        \n+        int intLen = 1; // already got one\n+        \n+        // First let's get the obligatory integer part:\n+        int_loop:\n+        while (true) {\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch < INT_0 || ch > INT_9) {\n+                break int_loop;\n+            }\n+            ++intLen;\n+        }\n+\n+        int fractLen = 0;\n+        // And then see if we get other parts\n+        if (ch == '.') { // yes, fraction\n+            fract_loop:\n             while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n-                    break int_loop;\n-                }\n-                ++intLen;\n-            }\n-\n-            int fractLen = 0;\n-            \n-            // And then see if we get other parts\n-            if (ch == '.') { // yes, fraction\n-                fract_loop:\n-                while (true) {\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                    if (ch < INT_0 || ch > INT_9) {\n-                        break fract_loop;\n-                    }\n-                    ++fractLen;\n-                }\n-                // must be followed by sequence of ints, one minimum\n-                if (fractLen == 0) {\n-                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n-                }\n-            }\n-\n-            int expLen = 0;\n-            if (ch == 'e' || ch == 'E') { // and/or exponent\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+        int expLen = 0;\n+        if (ch == 'e' || ch == 'E') { // and/or exponent\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            // Sign indicator?\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n-                }\n-                // Sign indicator?\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n+                }\n                 ch = (int) _inputBuffer[ptr++];\n-                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                }\n-                while (ch <= INT_9 && ch >= INT_0) {\n-                    ++expLen;\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                }\n-                // must be followed by sequence of ints, one minimum\n-                if (expLen == 0) {\n-                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n-                }\n-            }\n-            // Got it all: let's add to text buffer for parsing, access\n-            --ptr; // need to push back following separator\n-            _inputPtr = ptr;\n-            // As per #105, need separating space between root values; check here\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(ch);\n-            }\n-            int len = ptr-startPtr;\n-            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-            return reset(neg, intLen, fractLen, expLen);\n-        } while (false);\n-\n-        _inputPtr = neg ? (startPtr+1) : startPtr;\n-        return _parseNumber2(neg);\n+            }\n+            while (ch <= INT_9 && ch >= INT_0) {\n+                ++expLen;\n+                if (ptr >= inputLen) {\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+        // Got it all: let's add to text buffer for parsing, access\n+        --ptr; // need to push back following separator\n+        _inputPtr = ptr;\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n+        int len = ptr-startPtr;\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+        return reset(neg, intLen, fractLen, expLen);\n     }\n \n     /**", "timestamp": 1398228826, "metainfo": ""}