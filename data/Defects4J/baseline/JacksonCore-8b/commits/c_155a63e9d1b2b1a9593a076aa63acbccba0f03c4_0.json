{"sha": "155a63e9d1b2b1a9593a076aa63acbccba0f03c4", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * In general use of this accessor should be considered as\n      * \"last effort\", i.e. only used if no other mechanism is applicable.\n      */\n-    public Object getInputSource() {\n-        return null;\n-    }\n+    public Object getInputSource() { return null; }\n \n     /*\n     /**********************************************************\n      * \n      * @throws UnsupportedOperationException if parser does not support schema\n      */\n-    public void setSchema(FormatSchema schema)\n-    {\n+    public void setSchema(FormatSchema schema) {\n         throw new UnsupportedOperationException(\"Parser of type \"+getClass().getName()+\" does not support schema of type '\"\n                 +schema.getSchemaType()+\"'\");\n     }\n      *\n      * @since 2.1\n      */\n-    public FormatSchema getSchema() {\n-        return null;\n-    }\n+    public FormatSchema getSchema() { return null; }\n     \n     /**\n      * Method that can be used to verify that given schema can be used with\n      * \n      * @return True if this parser can use given schema; false if not\n      */\n-    public boolean canUseSchema(FormatSchema schema) {\n-        return false;\n-    }\n+    public boolean canUseSchema(FormatSchema schema) { return false; }\n \n     /*\n     /**********************************************************\n      * \n      * @since 2.1\n      */\n-    public boolean requiresCustomCodec() {\n-        return false;\n-    }\n+    public boolean requiresCustomCodec() { return false;}\n     \n     /*\n     /**********************************************************\n      *    \n      * @throws IOException if write to stream threw exception\n      */    \n-    public int releaseBuffered(OutputStream out) throws IOException\n-    {\n+    public int releaseBuffered(OutputStream out) throws IOException {\n         return -1;\n     }\n \n      *    \n      * @throws IOException if write using Writer threw exception\n      */    \n-    public int releaseBuffered(Writer w) throws IOException\n-    {\n-        return -1;\n-    }\n+    public int releaseBuffered(Writer w) throws IOException { return -1; }\n     \n     /*\n     /***************************************************\n      * Method for enabling specified parser feature\n      * (check {@link Feature} for list of features)\n      */\n-    public JsonParser enable(Feature f)\n-    {\n+    public JsonParser enable(Feature f) {\n         _features |= f.getMask();\n         return this;\n     }\n      * Method for disabling specified  feature\n      * (check {@link Feature} for list of features)\n      */\n-    public JsonParser disable(Feature f)\n-    {\n+    public JsonParser disable(Feature f) {\n         _features &= ~f.getMask();\n         return this;\n     }\n      */\n     public JsonParser configure(Feature f, boolean state)\n     {\n-        if (state) {\n-            enable(f);\n-        } else {\n-            disable(f);\n-        }\n+        if (state) { enable(f);\n+        } else { disable(f); }\n         return this;\n     }\n     \n     /**\n      * Method for checking whether specified {@link Feature} is enabled.\n      */\n-    public boolean isEnabled(Feature f) {\n-        return (_features & f.getMask()) != 0;\n-    }\n+    public boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n \n     /**\n      * Bulk access method for getting state of all standard {@link Feature}s.\n      *   to indicate end-of-input\n      */\n     public abstract JsonToken nextToken()\n-        throws IOException, JsonParseException;\n+        throws IOException;\n \n     /**\n      * Iteration method that will advance stream enough\n      *   parsers, {@link JsonToken#NOT_AVAILABLE} if no tokens were\n      *   available yet)\n      */\n-    public abstract JsonToken nextValue()\n-        throws IOException, JsonParseException;\n+    public abstract JsonToken nextValue() throws IOException;\n \n     /**\n      * Method that fetches next token (as if calling {@link #nextToken}) and\n      * \n      * @param str Property name to compare next token to (if next token is <code>JsonToken.FIELD_NAME<code>)\n      */\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException, JsonParseException\n-    {\n+    public boolean nextFieldName(SerializableString str) throws IOException {\n         return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public String nextTextValue()\n-        throws IOException, JsonParseException\n+    public String nextTextValue() throws IOException\n     {\n         return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n     }\n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public int nextIntValue(int defaultValue)\n-        throws IOException, JsonParseException\n-    {\n+    public int nextIntValue(int defaultValue) throws IOException {\n         return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public long nextLongValue(long defaultValue)\n-        throws IOException, JsonParseException\n-    {\n+    public long nextLongValue(long defaultValue) throws IOException {\n         return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public Boolean nextBooleanValue()\n-        throws IOException, JsonParseException\n+    public Boolean nextBooleanValue() throws IOException\n     {\n         JsonToken t = nextToken();\n-        if (t == JsonToken.VALUE_TRUE) {\n-            return Boolean.TRUE;\n-        }\n-        if (t == JsonToken.VALUE_FALSE) {\n-            return Boolean.FALSE;\n-        }\n+        if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; }\n+        if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }\n         return null;\n     }\n     \n      * will call {@link #nextToken} to point to the next\n      * available token, if any.\n      */\n-    public abstract JsonParser skipChildren()\n-        throws IOException, JsonParseException;\n+    public abstract JsonParser skipChildren() throws IOException;\n     \n     /**\n      * Method that can be called to determine whether this parser\n      * for field values it will be preceding field name;\n      * and for others (array values, root-level values) null.\n      */\n-    public abstract String getCurrentName()\n-        throws IOException, JsonParseException;\n+    public abstract String getCurrentName() throws IOException;\n \n     /**\n      * Method that can be used to access current parsing context reader\n      *   start-array marker (such {@link JsonToken#START_ARRAY});\n      *   false if not.\n      */\n-    public boolean isExpectedStartArrayToken() {\n-        return getCurrentToken() == JsonToken.START_ARRAY;\n-    }\n+    public boolean isExpectedStartArrayToken() { return getCurrentToken() == JsonToken.START_ARRAY; }\n \n     /*\n     /**********************************************************\n      * resort, as it is a work-around for regular operation.\n      * \n      * @param name Name to use as the current name; may be null.\n-     * \n-     * @since 2.0\n      */\n     public abstract void overrideCurrentName(String name);\n     \n      * after encountering end-of-input), returns null.\n      * Method can be called for any token type.\n      */\n-    public abstract String getText()\n-        throws IOException, JsonParseException;\n+    public abstract String getText() throws IOException;\n \n     /**\n      * Method similar to {@link #getText}, but that will return\n      * will make a copy of contents).\n      */\n     public abstract char[] getTextCharacters()\n-        throws IOException, JsonParseException;\n+        throws IOException;\n \n     /**\n      * Accessor used with {@link #getTextCharacters}, to know length\n      *   by {@link #getTextCharacters} that are part of\n      *   textual content of the current token.\n      */\n-    public abstract int getTextLength()\n-        throws IOException, JsonParseException;\n+    public abstract int getTextLength() throws IOException;\n \n     /**\n      * Accessor used with {@link #getTextCharacters}, to know offset\n      *   by {@link #getTextCharacters} that is part of\n      *   textual content of the current token.\n      */\n-    public abstract int getTextOffset()\n-        throws IOException, JsonParseException;\n+    public abstract int getTextOffset() throws IOException;\n \n     /**\n      * Method that can be used to determine whether calling of\n      * (simplest/smallest possible) wrapper object that can\n      * express the numeric value just parsed.\n      */\n-    public abstract Number getNumberValue()\n-        throws IOException, JsonParseException;\n+    public abstract Number getNumberValue() throws IOException;\n \n     /**\n      * If current token is of type \n      * {@link JsonToken#VALUE_NUMBER_FLOAT}, returns\n      * one of {@link NumberType} constants; otherwise returns null.\n      */\n-    public abstract NumberType getNumberType()\n-        throws IOException, JsonParseException;\n+    public abstract NumberType getNumberType() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * Java byte, a {@link JsonParseException}\n      * will be thrown to indicate numeric overflow/underflow.\n      */\n-    public byte getByteValue()\n-        throws IOException, JsonParseException\n+    public byte getByteValue() throws IOException\n     {\n         int value = getIntValue();\n         // So far so good: but does it fit?\n      * Java short, a {@link JsonParseException}\n      * will be thrown to indicate numeric overflow/underflow.\n      */\n-    public short getShortValue()\n-        throws IOException, JsonParseException\n+    public short getShortValue() throws IOException\n     {\n         int value = getIntValue();\n         if (value < MIN_SHORT_I || value > MAX_SHORT_I) {\n      * Java int, a {@link JsonParseException}\n      * may be thrown to indicate numeric overflow/underflow.\n      */\n-    public abstract int getIntValue()\n-        throws IOException, JsonParseException;\n+    public abstract int getIntValue() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * outside of range of Java long, a {@link JsonParseException}\n      * may be thrown to indicate numeric overflow/underflow.\n      */\n-    public abstract long getLongValue()\n-        throws IOException, JsonParseException;\n+    public abstract long getLongValue() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * if so, it is equivalent to calling {@link #getDecimalValue}\n      * and then constructing a {@link BigInteger} from that value.\n      */\n-    public abstract BigInteger getBigIntegerValue()\n-        throws IOException, JsonParseException;\n+    public abstract BigInteger getBigIntegerValue() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * outside of range of Java float, a {@link JsonParseException}\n      * will be thrown to indicate numeric overflow/underflow.\n      */\n-    public abstract float getFloatValue()\n-        throws IOException, JsonParseException;\n+    public abstract float getFloatValue() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * outside of range of Java double, a {@link JsonParseException}\n      * will be thrown to indicate numeric overflow/underflow.\n      */\n-    public abstract double getDoubleValue()\n-        throws IOException, JsonParseException;\n+    public abstract double getDoubleValue() throws IOException;\n \n     /**\n      * Numeric accessor that can be called when the current\n      * {@link JsonToken#VALUE_NUMBER_INT}. No under/overflow exceptions\n      * are ever thrown.\n      */\n-    public abstract BigDecimal getDecimalValue()\n-        throws IOException, JsonParseException;\n+    public abstract BigDecimal getDecimalValue() throws IOException;\n \n     /*\n     /**********************************************************\n      * outside of range of Java long, a {@link JsonParseException}\n      * may be thrown to indicate numeric overflow/underflow.\n      */\n-    public boolean getBooleanValue()\n-        throws IOException, JsonParseException\n-    {\n+    public boolean getBooleanValue() throws IOException {\n         JsonToken t = getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) return true;\n         if (t == JsonToken.VALUE_FALSE) return false;\n      * embedding of objects (usually ones that are facades on top\n      * of non-streaming sources, such as object trees).\n      */\n-    public abstract Object getEmbeddedObject()\n-        throws IOException, JsonParseException;\n+    public abstract Object getEmbeddedObject() throws IOException;\n \n     /*\n     /**********************************************************\n      *\n      * @return Decoded binary data\n      */\n-    public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException;\n+    public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n \n     /**\n      * Convenience alternative to {@link #getBinaryValue(Base64Variant)}\n      * that defaults to using\n      * {@link Base64Variants#getDefaultVariant} as the default encoding.\n      */\n-    public byte[] getBinaryValue() throws IOException, JsonParseException {\n+    public byte[] getBinaryValue() throws IOException {\n         return getBinaryValue(Base64Variants.getDefaultVariant());\n     }\n \n      * \n      * @since 2.1\n      */\n-    public int readBinaryValue(OutputStream out) throws IOException, JsonParseException {\n+    public int readBinaryValue(OutputStream out) throws IOException {\n         return readBinaryValue(Base64Variants.getDefaultVariant(), out);\n     }\n \n      * @since 2.1\n      */\n     public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-            throws IOException, JsonParseException\n+            throws IOException\n     {\n         _reportUnsupportedOperation();\n         return 0; // never gets here\n      * markers like start/end Object/Array)\n      * default value of <b>0</b> will be returned; no exceptions are thrown.\n      */\n-    public int getValueAsInt() throws IOException, JsonParseException {\n+    public int getValueAsInt() throws IOException {\n         return getValueAsInt(0);\n     }\n     \n      * markers like start/end Object/Array)\n      * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n      */\n-    public int getValueAsInt(int defaultValue) throws IOException, JsonParseException {\n+    public int getValueAsInt(int defaultValue) throws IOException {\n         return defaultValue;\n     }\n \n      * markers like start/end Object/Array)\n      * default value of <b>0</b> will be returned; no exceptions are thrown.\n      */\n-    public long getValueAsLong() throws IOException, JsonParseException {\n+    public long getValueAsLong() throws IOException {\n         return getValueAsLong(0);\n     }\n     \n      * markers like start/end Object/Array)\n      * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n      */\n-    public long getValueAsLong(long defaultValue) throws IOException, JsonParseException {\n+    public long getValueAsLong(long defaultValue) throws IOException {\n         return defaultValue;\n     }\n     \n      * like Objects and Arrays),\n      * default value of <b>0.0</b> will be returned; no exceptions are thrown.\n      */\n-    public double getValueAsDouble() throws IOException, JsonParseException {\n+    public double getValueAsDouble() throws IOException {\n         return getValueAsDouble(0.0);\n     }\n     \n      * like Objects and Arrays),\n      * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n      */\n-    public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException {\n+    public double getValueAsDouble(double defaultValue) throws IOException {\n         return defaultValue;\n     }\n \n      * like Objects and Arrays),\n      * default value of <b>false</b> will be returned; no exceptions are thrown.\n      */\n-    public boolean getValueAsBoolean() throws IOException, JsonParseException {\n+    public boolean getValueAsBoolean() throws IOException {\n         return getValueAsBoolean(false);\n     }\n \n      * like Objects and Arrays),\n      * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n      */\n-    public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException {\n+    public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n         return defaultValue;\n     }\n \n      * \n      * @since 2.1\n      */\n-    public String getValueAsString() throws IOException, JsonParseException {\n+    public String getValueAsString() throws IOException {\n         return getValueAsString(null);\n     }\n     \n      * \n      * @since 2.1\n      */\n-    public abstract String getValueAsString(String defaultValue)\n-        throws IOException, JsonParseException;\n+    public abstract String getValueAsString(String defaultValue) throws IOException;\n \n     /*\n     /**********************************************************\n      * \n      * @since 2.3\n      */\n-    public boolean canReadObjectId() {\n-        return false;\n-    }\n+    public boolean canReadObjectId() { return false; }\n \n     /**\n      * Introspection method that may be called to see if the underlying\n      * \n      * @since 2.3\n      */\n-    public Object getObjectId() throws IOException, JsonGenerationException {\n-        return null;\n-    }\n+    public Object getObjectId() throws IOException { return null; }\n \n     /**\n      * Method that can be called to check whether current token\n      * \n      * @since 2.3\n      */\n-    public Object getTypeId() throws IOException, JsonGenerationException {\n-        return null;\n-    }\n+    public Object getTypeId() throws IOException { return null; }\n \n     /*\n     /**********************************************************\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n      */\n-    public <T> T readValueAs(Class<T> valueType)\n-        throws IOException, JsonProcessingException\n+    public <T> T readValueAs(Class<T> valueType) throws IOException\n     {\n         ObjectCodec codec = getCodec();\n         if (codec == null) {\n      * stream is not advanced.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T readValueAs(TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException\n+    public <T> T readValueAs(TypeReference<?> valueTypeRef) throws IOException\n     {\n         ObjectCodec codec = getCodec();\n         if (codec == null) {\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public <T> Iterator<T> readValuesAs(Class<T> valueType)\n-        throws IOException, JsonProcessingException\n+    public <T> Iterator<T> readValuesAs(Class<T> valueType) throws IOException\n     {\n         ObjectCodec codec = getCodec();\n         if (codec == null) {\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public <T> Iterator<T> readValuesAs(TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException\n+    public <T> Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException\n     {\n         ObjectCodec codec = getCodec();\n         if (codec == null) {\n      * matching leaf node type\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public <T extends TreeNode> T readValueAsTree()\n-        throws IOException, JsonProcessingException\n-    {\n+    public <T extends TreeNode> T readValueAsTree() throws IOException {\n         ObjectCodec codec = getCodec();\n         if (codec == null) {\n             throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree\");\n      * Helper method for constructing {@link JsonParseException}s\n      * based on current state of the parser\n      */\n-    protected JsonParseException _constructError(String msg)\n-    {\n+    protected JsonParseException _constructError(String msg) {\n         return new JsonParseException(msg, getCurrentLocation());\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n         return \"'\"+c+\"' (code \"+ch+\")\";\n     }\n \n-    protected final void _reportError(String msg)\n-        throws JsonParseException\n-    {\n+    protected final void _reportError(String msg) throws JsonParseException {\n         throw _constructError(msg);\n     }\n \n-    protected final void _wrapError(String msg, Throwable t)\n-        throws JsonParseException\n-    {\n+    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n         throw _constructError(msg, t);\n     }\n \n         VersionUtil.throwInternal();\n     }\n \n-    protected final JsonParseException _constructError(String msg, Throwable t)\n-    {\n+    protected final JsonParseException _constructError(String msg, Throwable t) {\n         return new JsonParseException(msg, getCurrentLocation(), t);\n     }\n }", "timestamp": 1389852643, "metainfo": ""}