{"sha": "2e70a2a03007748110ba8887ad1db7ea34350819", "log": "Starting to implement streaming writing of binary data.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n         writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n     }\n \n+    /**\n+     * Similar to {@link #writeBinary(Base64Variant,InputStream)},\n+     * but assumes default to using the Jackson default Base64 variant \n+     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n+     * \n+     * @param data InputStream to use for reading binary data to write.\n+     *    Will be closed after successful write operation\n+     * @param dataLength (optional) number of bytes that will be available;\n+     *    or -1 to be indicate it is not known. Note that implementations\n+     *    need not support cases where length is not known in advance; this\n+     *    depends on underlying data format: JSON output does NOT require length,\n+     *    other formats may\n+     */\n+    public int writeBinary(InputStream data, int dataLength)\n+        throws IOException, JsonGenerationException {\n+        return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n+    }\n+    \n+    /**\n+     * Method similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n+     * but where input is provided through a stream, allowing for incremental\n+     * writes without holding the whole input in memory.\n+     * \n+     * @param b64variant Base64 variant to use\n+     * @param data InputStream to use for reading binary data to write.\n+     *    Will be closed after successful write operation\n+     * @param dataLength (optional) number of bytes that will be available;\n+     *    or -1 to be indicate it is not known. Note that implementations\n+     *    need not support cases where length is not known in advance; this\n+     *    depends on underlying data format: JSON output does NOT require length,\n+     *    other formats may\n+     * \n+     * @return Number of bytes read from {@link data} and written as binary payload\n+     * \n+     * @since 2.1\n+     */\n+    public abstract int writeBinary(Base64Variant b64variant,\n+            InputStream data, int dataLength)\n+        throws IOException, JsonGenerationException;\n+    \n     /*\n     /**********************************************************\n     /* Public API, write methods, other value types\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n     protected byte[] _writeEncodingBuffer = null;\n     \n     /**\n+     * Reference to the buffer allocated for temporary use with\n+     * base64 encoding or decoding.\n+     */\n+    protected byte[] _base64Buffer = null;\n+\n+    /**\n      * Reference to the buffer allocated for tokenization purposes,\n      * in which character input is read, and from which it can be\n      * further returned.\n         _writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER);\n         return _writeEncodingBuffer;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    public final byte[] allocBase64Buffer()\n+    {\n+        if (_base64Buffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocBase64Buffer() second time\");\n+        }\n+        _base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER);\n+        return _base64Buffer;\n+    }\n     \n     public final char[] allocTokenBuffer()\n     {\n             _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf);\n         }\n     }\n+\n+    public final void releaseBase64Buffer(byte[] buf)\n+    {\n+        if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n+            if (buf != _base64Buffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _base64Buffer = null;\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER, buf);\n+        }\n+    }\n     \n     public final void releaseTokenBuffer(char[] buf)\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n      */\n \n     @Override\n-    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+    public void writeBinary(Base64Variant b64variant,\n+            byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         _verifyValueWrite(\"write binary value\");\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant,\n+            InputStream data, int dataLength)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write binary value\");\n+        // Starting quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n+        int bytes;\n+        try {\n+            bytes = _writeBinary(b64variant, data, dataLength, encodingBuffer);\n+        } finally {\n+            _ioContext.releaseBase64Buffer(encodingBuffer);\n+        }\n+        // and closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        return bytes;\n     }\n     \n     /*\n     /**********************************************************\n      */\n     \n-    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd)\n+    protected void _writeBinary(Base64Variant b64variant,\n+            byte[] input, int inputPtr, final int inputEnd)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Encoding is by chunks of 3 input, 4 output chars, so:\n+        int safeInputEnd = inputEnd - 3;\n+        // Let's also reserve room for possible (and quoted) lf char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        while (inputPtr <= safeInputEnd) {\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) input[inputPtr++]) << 8;\n+            b24 |= ((int) input[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                // note: must quote in JSON value\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n+        if (inputLeft > 0) { // yes, but do we have room for output?\n+            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                _flushBuffer();\n+            }\n+            int b24 = ((int) input[inputPtr++]) << 16;\n+            if (inputLeft == 2) {\n+                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n+            }\n+            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n+        }\n+    }\n+\n+    protected int _writeBinary(Base64Variant b64variant,\n+            InputStream data, int dataLength, byte[] encodingBuffer)\n         throws IOException, JsonGenerationException\n     {\n         // Encoding is by chunks of 3 input, 4 output chars, so:\n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n          * example when requesting output as byte array.\n          */\n         ,WRITE_CONCAT_BUFFER(2000)\n+        \n+        /**\n+         * Buffer used for concatenating binary data that is either being\n+         * encoded as base64 output, or decoded from base64 input.\n+         * \n+         * @since 2.1\n+         */\n+        ,BASE64_CODEC_BUFFER(2000)\n         ;\n             \n         protected final int size;\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n package com.fasterxml.jackson.core.util;\n \n import java.io.IOException;\n+import java.io.InputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n     }\n \n     @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data)\n+        throws IOException, JsonGenerationException {\n+        return delegate.writeBinary(b64variant, data);\n+    }\n+    \n+    @Override\n     public void writeBoolean(boolean state) throws IOException, JsonGenerationException {\n         delegate.writeBoolean(state);\n     }", "timestamp": 1338873705, "metainfo": ""}