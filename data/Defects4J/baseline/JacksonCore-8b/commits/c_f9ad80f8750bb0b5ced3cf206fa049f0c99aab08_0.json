{"sha": "f9ad80f8750bb0b5ced3cf206fa049f0c99aab08", "log": "Impelmented #106", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n          * Feature is disabled by default.\n          */\n         ESCAPE_NON_ASCII(false),\n-        \n+\n+        /**\n+         * Feature that determines whether {@link JsonGenerator} will explicitly\n+         * check that no duplicate JSON Object field names are written.\n+         * If enabled, generator will check all names within context and report\n+         * duplicates by throwing a {@link JsonGenerationException}; if disabled,\n+         * no such checking will be done. Assumption in latter case is\n+         * that caller takes care of not trying to write duplicate names.\n+         *<p>\n+         * Note that enabling this feature will incur performance overhead\n+         * due to having to store and check additional information.\n+         * \n+         * @since 2.3\n+         */\n+        STRICT_DUPLICATE_DETECTION(false),\n             ;\n \n         private final boolean _defaultState;\n-        \n+\n         private final int _mask;\n         \n         /**\n             _mask = (1 << ordinal());\n             _defaultState = defaultState;\n         }\n-        \n+\n         public boolean enabledByDefault() { return _defaultState; }\n+\n+        /**\n+         * @since 2.3\n+         */\n+        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n+\n         public int getMask() { return _mask; }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n           * that caller takes care of handling duplicates at a higher level:\n           * data-binding, for example, has features to specify detection to\n           * be done there.\n+          *<p>\n+          * Note that enabling this feature will incur performance overhead\n+          * due to having to store and check additional information: this typically\n+          * adds 20-30% to execution time for basic parsing.\n           * \n           * @since 2.3\n           */\n          STRICT_DUPLICATE_DETECTION(false),\n-         \n             ;\n \n         /**\n          * Whether feature is enabled or disabled by default.\n          */\n         private final boolean _defaultState;\n+\n+        private final int _mask;\n         \n         /**\n          * Method that calculates bit set (flags) of all features that\n         }\n         \n         private Feature(boolean defaultState) {\n+            _mask = (1 << ordinal());\n             _defaultState = defaultState;\n         }\n         \n         /**\n          * @since 2.3\n          */\n-        public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n+        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n \n         public int getMask() { return (1 << ordinal()); }\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.JsonParser.NumberType;\n+import com.fasterxml.jackson.core.json.DupDetector;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.VersionUtil;\n     {\n         super();\n         _features = features;\n-        _writeContext = JsonWriteContext.createRootContext();\n+        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n+                ? DupDetector.rootDetector(this) : null;\n+        _writeContext = JsonWriteContext.createRootContext(dups);\n         _objectCodec = codec;\n-        _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS);\n+        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.json.DupDetector;\n import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.json.PackageVersion;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n         _features = features;\n         _ioContext = ctxt;\n         _textBuffer = ctxt.constructTextBuffer();\n-        JsonReadContext readCtxt = JsonReadContext.createRootContext();\n-        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)) {\n-            readCtxt.trackDups(this);\n-        }\n+        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n+                ? DupDetector.rootDetector(this) : null;\n+        JsonReadContext readCtxt = JsonReadContext.createRootContext(dups);\n         _parsingContext = readCtxt;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonLocation;\n-import com.fasterxml.jackson.core.JsonParseException;\n-import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.*;\n \n /**\n  * Helper class used if\n public class DupDetector\n {\n     /**\n-     * We need to store a back-reference here, unfortunately.\n+     * We need to store a back-reference here to parser/generator, unfortunately.\n      */\n-    protected final JsonParser _parser;\n+    protected final Object _source;\n \n     protected String _firstName;\n \n      */\n     protected HashSet<String> _seen;\n \n-    private DupDetector(JsonParser parser) {\n-        _parser = parser;\n+    private DupDetector(Object src) {\n+        _source = src;\n     }\n \n-    public static DupDetector rootDetector(JsonParser jp) {\n-        return new DupDetector(jp);\n+    public static DupDetector rootDetector(JsonParser p) {\n+        return new DupDetector(p);\n     }\n \n+    public static DupDetector rootDetector(JsonGenerator g) {\n+        return new DupDetector(g);\n+    }\n+    \n     public DupDetector child() {\n-        return new DupDetector(_parser);\n+        return new DupDetector(_source);\n     }\n \n     public void reset() {\n     }\n \n     public JsonLocation findLocation() {\n-        return _parser.getCurrentLocation();\n+        // ugly but:\n+        if (_source instanceof JsonParser) {\n+            return ((JsonParser)_source).getCurrentLocation();\n+        }\n+        // do generators have a way to provide Location? Apparently not...\n+        return null;\n     }\n     \n     public boolean isDup(String name) throws JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n {\n     // // // Configuration\n \n+    /**\n+     * Parent context for this context; null for root context.\n+     */\n     protected final JsonReadContext _parent;\n+    \n+    // // // Optional duplicate detection\n+\n+    protected final DupDetector _dups;\n     \n     // // // Location information (minus source reference)\n \n     protected int _columnNr;\n \n     protected String _currentName;\n-\n-    // // // Optional duplicate detection\n-\n-    protected DupDetector _dups;\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    public JsonReadContext(JsonReadContext parent, int type, int lineNr, int colNr)\n+    public JsonReadContext(JsonReadContext parent, DupDetector dups,\n+            int type, int lineNr, int colNr)\n     {\n         super();\n+        _parent = parent;\n+        _dups = dups;\n         _type = type;\n-        _parent = parent;\n         _lineNr = lineNr;\n         _columnNr = colNr;\n         _index = -1;\n         }\n     }\n \n+    /*\n     public void trackDups(JsonParser jp) {\n         _dups = DupDetector.rootDetector(jp);\n     }\n+    */\n \n     // // // Factory methods\n \n-    public static JsonReadContext createRootContext(int lineNr, int colNr)\n-    {\n-        return new JsonReadContext(null, TYPE_ROOT, lineNr, colNr);\n-    }\n-\n-    public static JsonReadContext createRootContext()\n-    {\n-        return new JsonReadContext(null, TYPE_ROOT, 1, 0);\n+    @Deprecated // since 2.3, use variant that takes dup detector\n+    public static JsonReadContext createRootContext(int lineNr, int colNr) {\n+        return createRootContext(lineNr, colNr, null);\n+    }\n+    \n+    public static JsonReadContext createRootContext(int lineNr, int colNr,\n+            DupDetector dups)\n+    {\n+        return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n+    }\n+\n+    @Deprecated // since 2.3, use variant that takes dup detector\n+    public static JsonReadContext createRootContext() {\n+        return createRootContext(null);\n+    }\n+\n+    public static JsonReadContext createRootContext(DupDetector dups) {\n+        return new JsonReadContext(null, dups, TYPE_ROOT, 1, 0);\n     }\n     \n     public JsonReadContext createChildArrayContext(int lineNr, int colNr)\n     {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonReadContext(this, TYPE_ARRAY, lineNr, colNr);\n+            _child = ctxt = new JsonReadContext(this,\n+                    (_dups == null) ? null : _dups.child(),\n+                            TYPE_ARRAY, lineNr, colNr);\n         } else {\n             ctxt.reset(TYPE_ARRAY, lineNr, colNr);\n         }\n-        if (_dups != null) {\n-            // must pass a placeholder to indicate that tracking is on; not used\n-            ctxt._dups = _dups;\n-        }\n         return ctxt;\n     }\n \n     {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr);\n-            if (_dups != null) {\n-                ctxt._dups = _dups.child();\n-            }\n+            _child = ctxt = new JsonReadContext(this,\n+                    (_dups == null) ? null : _dups.child(),\n+                    TYPE_OBJECT, lineNr, colNr);\n             return ctxt;\n         }\n         ctxt.reset(TYPE_OBJECT, lineNr, colNr);\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n      */\n     protected final JsonWriteContext _parent;\n \n+    // // // Optional duplicate detection\n+\n+    protected final DupDetector _dups;\n+    \n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speed up things\n     /**********************************************************\n      */\n \n-    protected JsonWriteContext(int type, JsonWriteContext parent)\n+    protected JsonWriteContext(int type, JsonWriteContext parent,\n+            DupDetector dups)\n     {\n         super();\n         _type = type;\n         _parent = parent;\n+        _dups = dups;\n         _index = -1;\n-    }\n-    \n-    // // // Factory methods\n-\n-    public static JsonWriteContext createRootContext()\n-    {\n-        return new JsonWriteContext(TYPE_ROOT, null);\n     }\n \n     protected JsonWriteContext reset(int type) {\n         _index = -1;\n         _currentName = null;\n         _gotName = false;\n+        if (_dups != null) {\n+            _dups.reset();\n+        }\n         return this;\n     }\n     \n+    // // // Factory methods\n+\n+    /**\n+     * @deprecated Since 2.3; use method that takes argument\n+     */\n+    @Deprecated\n+    public static JsonWriteContext createRootContext() {\n+        return createRootContext(null);\n+    }\n+\n+    public static JsonWriteContext createRootContext(DupDetector dd) {\n+        return new JsonWriteContext(TYPE_ROOT, null, dd);\n+    }\n+\n     public JsonWriteContext createChildArrayContext()\n     {\n         JsonWriteContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this);\n+            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this,\n+                    (_dups == null) ? null : _dups.child());\n             return ctxt;\n         }\n         return ctxt.reset(TYPE_ARRAY);\n     {\n         JsonWriteContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this);\n+            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this,\n+                    (_dups == null) ? null : _dups.child());\n             return ctxt;\n         }\n         return ctxt.reset(TYPE_OBJECT);\n      *\n      * @return Index of the field entry (0-based)\n      */\n-    public final int writeFieldName(String name)\n-    {\n-        _gotName = true;            \n+    public final int writeFieldName(String name) throws JsonProcessingException\n+    {\n+        _gotName = true;\n         _currentName = name;\n+        if (_dups != null) {\n+            _checkDup(_dups, name);\n+        }\n         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n+    }\n+\n+    private void _checkDup(DupDetector dd, String name) throws JsonProcessingException\n+    {\n+        if (dd.isDup(name)) {\n+            throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\");\n+        }\n     }\n     \n     public final int writeValue()\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestGeneratorDupHandling\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimpleDups() throws Exception\n+    {\n+        _testSimpleDups(false);\n+        _testSimpleDups(true);\n+    }\n+    \n+    protected void _testSimpleDups(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION));\n+\n+        // First: fine, when not checking\n+        _writeSimple0(_generator(f, useStream), \"a\");\n+        _writeSimple1(_generator(f, useStream), \"b\");\n+\n+        // but not when checking\n+        f.enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);\n+        try {\n+            _writeSimple0( _generator(f, useStream), \"a\");\n+            fail(\"Should have gotten exception\");\n+        } catch (JsonGenerationException e) {\n+            verifyException(e, \"duplicate field 'a'\");\n+        }\n+\n+        try {\n+            _writeSimple1( _generator(f, useStream), \"x\");\n+            fail(\"Should have gotten exception\");\n+        } catch (JsonGenerationException e) {\n+            verifyException(e, \"duplicate field 'x'\");\n+        }\n+    }\n+\n+    protected JsonGenerator _generator(JsonFactory f, boolean useStream) throws IOException\n+    {\n+        return useStream ?\n+                f.createGenerator(new ByteArrayOutputStream())\n+                : f.createGenerator(new StringWriter());\n+    }\n+\n+    protected void _writeSimple0(JsonGenerator g, String name) throws IOException\n+    {\n+        g.writeStartObject();\n+        g.writeNumberField(name, 1);\n+        g.writeNumberField(name, 2);\n+        g.writeEndObject();\n+        g.close();\n+    }\n+\n+    protected void _writeSimple1(JsonGenerator g, String name) throws IOException\n+    {\n+        g.writeStartArray();\n+        g.writeNumber(3);\n+        g.writeStartObject();\n+        g.writeNumberField(\"foo\", 1);\n+        g.writeNumberField(\"bar\", 1);\n+        g.writeNumberField(name, 1);\n+        g.writeNumberField(\"bar2\", 1);\n+        g.writeNumberField(name, 2);\n+        g.writeEndObject();\n+        g.writeEndArray();\n+        g.close();\n+    }\n+}", "timestamp": 1380083476, "metainfo": ""}