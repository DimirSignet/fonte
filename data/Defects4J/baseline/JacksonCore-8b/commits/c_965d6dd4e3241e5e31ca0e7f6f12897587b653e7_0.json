{"sha": "965d6dd4e3241e5e31ca0e7f6f12897587b653e7", "log": "more refactoring", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.Name;\n+\n+/**\n+ * Unit test(s) to verify that handling of (byte-based) symbol tables\n+ * is working. Created to verify fix to [JACKSON-5] (although not very\n+ * good at catching it...).\n+ */\n+public class TestByteBasedSymbols\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String[] FIELD_NAMES = new String[] {\n+        \"a\", \"b\", \"c\", \"x\", \"y\", \"b13\", \"abcdefg\", \"a123\",\n+        \"a0\", \"b0\", \"c0\", \"d0\", \"e0\", \"f0\", \"g0\", \"h0\",\n+        \"x2\", \"aa\", \"ba\", \"ab\", \"b31\", \"___x\", \"aX\", \"xxx\",\n+        \"a2\", \"b2\", \"c2\", \"d2\", \"e2\", \"f2\", \"g2\", \"h2\",\n+        \"a3\", \"b3\", \"c3\", \"d3\", \"e3\", \"f3\", \"g3\", \"h3\",\n+        \"a1\", \"b1\", \"c1\", \"d1\", \"e1\", \"f1\", \"g1\", \"h1\",\n+    };\n+\n+    /**\n+     * This unit test checks that [JACKSON-5] is fixed; if not, a\n+     * symbol table corruption should result in odd problems.\n+     */\n+    public void testSharedSymbols()\n+        throws Exception\n+    {\n+        // MUST share a single json factory\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* First things first: parse a dummy doc to populate\n+         * shared symbol table with some stuff\n+         */\n+        String DOC0 = \"{ \\\"a\\\" : 1, \\\"x\\\" : [ ] }\";\n+        JsonParser jp0 = createParser(jf, DOC0);\n+\n+        /* Important: don't close, don't traverse past end.\n+         * This is needed to create partial still-in-use symbol\n+         * table...\n+         */\n+        while (jp0.nextToken() != JsonToken.START_ARRAY) { }\n+\n+        String doc1 = createDoc(FIELD_NAMES, true);\n+        String doc2 = createDoc(FIELD_NAMES, false);\n+\n+        // Let's run it twice... shouldn't matter\n+        for (int x = 0; x < 2; ++x) {\n+            JsonParser jp1 = createParser(jf, doc1);\n+            JsonParser jp2 = createParser(jf, doc2);\n+\n+            assertToken(JsonToken.START_OBJECT, jp1.nextToken());\n+            assertToken(JsonToken.START_OBJECT, jp2.nextToken());\n+            \n+            int len = FIELD_NAMES.length;\n+            for (int i = 0; i < len; ++i) {\n+                assertToken(JsonToken.FIELD_NAME, jp1.nextToken());\n+                assertToken(JsonToken.FIELD_NAME, jp2.nextToken());\n+                assertEquals(FIELD_NAMES[i], jp1.getCurrentName());\n+                assertEquals(FIELD_NAMES[len-(i+1)], jp2.getCurrentName());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken());\n+                assertEquals(i, jp1.getIntValue());\n+                assertEquals(i, jp2.getIntValue());\n+            }\n+            \n+            assertToken(JsonToken.END_OBJECT, jp1.nextToken());\n+            assertToken(JsonToken.END_OBJECT, jp2.nextToken());\n+            \n+            jp1.close();\n+            jp2.close();\n+        }\n+    }\n+\n+    public void testAuxMethods()\n+        throws Exception\n+    {\n+        final int A_BYTES = 0x41414141; // \"AAAA\"\n+        final int B_BYTES = 0x42424242; // \"BBBB\"\n+\n+        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot();\n+        assertNull(nc.findName(A_BYTES));\n+        assertNull(nc.findName(A_BYTES, B_BYTES));\n+\n+        nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n+        Name n1 = nc.findName(A_BYTES);\n+        assertNotNull(n1);\n+        assertEquals(\"AAAA\", n1.getName());\n+        nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n+        Name n2 = nc.findName(A_BYTES, B_BYTES);\n+        assertEquals(\"AAAABBBB\", n2.getName());\n+        assertNotNull(n2);\n+\n+        /* and let's then just exercise this method so it gets covered;\n+         * it's only used for debugging.\n+         */\n+        assertNotNull(nc.toString());\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////\n+    // Helper methods\n+    ////////////////////////////////////////////\n+     */\n+\n+    protected JsonParser createParser(JsonFactory jf, String input)\n+        throws IOException, JsonParseException\n+    {\n+        byte[] data = input.getBytes(\"UTF-8\");\n+        InputStream is = new ByteArrayInputStream(data);\n+        return jf.createJsonParser(is);\n+    }\n+\n+    private String createDoc(String[] fieldNames, boolean add)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"{ \");\n+\n+        int len = fieldNames.length;\n+        for (int i = 0; i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append('\"');\n+            sb.append(add ? fieldNames[i] : fieldNames[len - (i+1)]);\n+            sb.append(\"\\\" : \");\n+            sb.append(i);\n+        }\n+        sb.append(\" }\");\n+        return sb.toString();\n+    }\n+}\n+\n+", "timestamp": 1343196934, "metainfo": ""}