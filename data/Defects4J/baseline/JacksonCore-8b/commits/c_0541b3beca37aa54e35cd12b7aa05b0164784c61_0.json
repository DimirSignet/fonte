{"sha": "0541b3beca37aa54e35cd12b7aa05b0164784c61", "log": "Start working on even more robust DoS handling for char-based symbol tables", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n     protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n         // As per [JACKSON-259], may want to fully disable canonicalization:\n         return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols,\n-                isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n-                isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /**\n      */\n     protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException {\n         return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n-                _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n-                        isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)));\n+                _rootCharSymbols.makeChild(_factoryFeatures));\n     }\n \n     /**\n     protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n             boolean recyclable) throws IOException {\n         return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec,\n-                _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n-                        isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)),\n-                        data, offset, offset+len,\n-                        recyclable);\n+                _rootCharSymbols.makeChild(_factoryFeatures),\n+                        data, offset, offset+len, recyclable);\n     }\n \n     /**\n     protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n     {\n         return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols,\n-                isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n-                isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n \n     public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n             BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n-            boolean canonicalize, boolean intern) throws IOException\n+            int factoryFeatures) throws IOException\n     {\n         JsonEncoding enc = detectEncoding();\n \n             /* and without canonicalization, byte-based approach is not performance; just use std UTF-8 reader\n              * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n              */\n-            if (canonicalize) {\n-                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern);\n+            if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\n+                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n                 return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n                         _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n             }\n         }\n         return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec,\n-                rootCharSymbols.makeChild(canonicalize, intern));\n+                rootCharSymbols.makeChild(factoryFeatures));\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.util.InternCache;\n \n /**\n     /**\n      * Factory method used to create actual symbol table instance to\n      * use for parsing.\n-     * \n-     * @param intern Whether canonical symbol Strings should be interned\n-     *   or not\n-     */\n-    public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern) {\n-        return new BytesToNameCanonicalizer(this, intern, _seed, _tableInfo.get());\n+     */\n+    public BytesToNameCanonicalizer makeChild(int flags) {\n+        return new BytesToNameCanonicalizer(this, JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+                _seed, _tableInfo.get());\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n package com.fasterxml.jackson.core.sym;\n \n import java.util.Arrays;\n-\n+import java.util.BitSet;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.util.InternCache;\n \n /**\n     /* If we use \"multiply-add\" based hash algorithm, this is the multiplier\n      * we use.\n      *<p>\n-     * Note that with versions 2.3 and before used value of 33; but 2.4\n-     * changed it to 31 to align with default hash code, to more easily\n-     * detect attempted DoS attacks (since HashMap would fall into it\n-     * if we used different hash multiplier).\n-     */\n-    public final static int HASH_MULT = 31;\n+     * Note that JDK uses 31; but it seems that 33 produces fewer collisions,\n+     * at least with tests we have.\n+     */\n+    public final static int HASH_MULT = 33;\n     \n     /**\n      * Default initial table size. Shouldn't be miniscule (as there's\n \n     /*\n     /**********************************************************\n+    /* Bit of DoS detection goodness\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed structure that is used to keep track of\n+     * collision buckets that have overflowed once: this is used\n+     * to detect likely attempts at denial-of-service attacks that\n+     * uses hash collisions.\n+     * \n+     * @since 2.4\n+     */\n+    protected BitSet _overflows;\n+    \n+    /*\n+    /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n      * on which only makeChild/mergeChild are called, but instance itself\n      * is not used as a symbol table.\n      */\n-    public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern) {\n+    public CharsToNameCanonicalizer makeChild(int flags) {\n         /* 24-Jul-2012, tatu: Trying to reduce scope of synchronization, assuming\n          *   that synchronizing construction is the (potentially) expensive part,\n          *   and not so much short copy-the-variables thing.\n         final int size;\n         final int hashSeed;\n         final int longestCollisionList;\n+\n+        final boolean canon = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags);\n+        final boolean intern = canon && JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags);\n         \n         synchronized (this) {\n             symbols = _symbols;\n             longestCollisionList = _longestCollisionList;\n         }\n         \n-        return new CharsToNameCanonicalizer(this, canonicalize, intern,\n+        return new CharsToNameCanonicalizer(this, canon, intern,\n                 symbols, buckets, size, hashSeed, longestCollisionList);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n         final int B_BYTES = 0x42424242; // \"BBBB\"\n \n         BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot()\n-                .makeChild(true, true);\n+                .makeChild(JsonFactory.Feature.collectDefaults());\n         assertNull(nc.findName(A_BYTES));\n         assertNull(nc.findName(A_BYTES, B_BYTES));\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n import java.io.IOException;\n \n+import com.fasterxml.jackson.core.JsonFactory;\n+\n public class TestSymbolTables extends com.fasterxml.jackson.test.BaseTest\n {\n-    // 11 3-char snippets that hash to 0xFFFF (with default JDK hashCode() calc),\n-    // and which can be combined as\n-    // sequences, like, say, 11x11x11 (1331) 9-character thingies\n-    final static String[] CHAR_COLLISION_SNIPPETS_31 = {\n-        \"@~}\", \"@\\u007f^\", \"A_}\", \"A`^\", \n-        \"Aa?\", \"B@}\", \"BA^\", \"BB?\", \n-        \"C!}\", \"C\\\"^\", \"C#?\"\n-    };\n-\n-    final static String[] CHAR_COLLISIONS;\n-    static {\n-        final String[] SNIPPETS = CHAR_COLLISION_SNIPPETS_31;\n-        \n-        final int len = SNIPPETS.length;\n-        CHAR_COLLISIONS = new String[len*len*len];\n-        int ix = 0;\n-        for (int i1 = 0; i1 < len; ++i1) {\n-            for (int i2 = 0; i2 < len; ++i2) {\n-                for (int i3 = 0; i3 < len; ++i3) {\n-                    CHAR_COLLISIONS[ix++] = SNIPPETS[i1]+SNIPPETS[i2] + SNIPPETS[i3];\n-                }\n-            }\n-        }\n-    }\n-\n-    /*\n-    public void testCharBasedCollisions()\n-    {\n-        CharsToNameCanonicalizer sym = CharsToNameCanonicalizer.createRoot(0);\n-\n-        // first, verify that we'd get a few collisions...\n-        try {\n-            int firstHash = 0;\n-            for (String str : CHAR_COLLISIONS) {\n-                int hash = sym.calcHash(str);\n-                if (firstHash == 0) {\n-                    firstHash = hash;\n-                } else {\n-                    assertEquals(firstHash, hash); \n-                }\n-                sym.findSymbol(str.toCharArray(), 0, str.length(), hash);\n-            }\n-            fail(\"Should have thrown exception\");\n-        } catch (IllegalStateException e) {\n-            verifyException(e, \"exceeds maximum\");\n-            // should fail right after addition:\n-            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+1, sym.maxCollisionLength());\n-            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+1, sym.collisionCount());\n-            // one \"non-colliding\" entry (head of collision chain), thus:\n-            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+2, sym.size());\n-        }\n-    }\n-    */\n-\n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and character-based input\n     public void testSyntheticWithChars()\n         // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n         // ... at least before shuffling. Shuffling helps quite a lot, so:\n \n-        /* 22-May-2014, tatu: With 33 we now should get 1401; but with\n-         *   31 bit more, 1858.\n-         */\n-//        assertEquals(1401, symbols.collisionCount());\n-        assertEquals(1858, symbols.collisionCount());\n+        assertEquals(1401, symbols.collisionCount()); // with 33\n+//        assertEquals(1858, symbols.collisionCount()); // with 31\n \n         // esp. with collisions; first got about 30;\n         // with fixes 4 (for 33), 5 (for 31)\n \n-//        assertEquals(4, symbols.maxCollisionLength());\n-        assertEquals(5, symbols.maxCollisionLength());\n+        assertEquals(4, symbols.maxCollisionLength()); // 33\n+//        assertEquals(5, symbols.maxCollisionLength()); // 31\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     {\n         // pass seed, to keep results consistent:\n         BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(33333).makeChild(true, true);\n+                BytesToNameCanonicalizer.createRoot(33333).makeChild(JsonFactory.Feature.collectDefaults());\n         final int COUNT = 6000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n--- a/src/test/java/failing/TestHashCollision.java\n+++ b/src/test/java/failing/TestHashCollision.java\n     // // // And then a nastier variant; collisions generated using\n     // // // CollisionGenerator\n \n-    /*\n     // for 33\n     final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n         // Ones generated for 33/65536...\n         \"9fa\", \"9g@\", \":Ea\", \":F@\", \";$a\", \";%@\"\n     };\n-    */\n \n     // for 31\n+    /*\n     final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n         // Ones generated for 31/65536...\n         \"@~~\", \"A_~\", \"A`_\", \"Aa@\", \"Ab!\", \"B@~\", // \"BA_\", \"BB@\", \"BC!\", \"C!~\"\n     };\n+    */\n     \n     public void testReaderCollisions() throws Exception\n     {\n         List<String> coll = collisions();\n \n         // First just verify we got collisions for JDK too\n+        // ... only works if we use 31\n+        /*\n         int hash = coll.get(0).hashCode();\n         for (int i = 1, end = coll.size(); i < end; ++i) {\n             if (coll.get(i).hashCode() != hash) {\n                         +\"), expected 0x\"+Integer.toHexString(hash));\n             }\n         }\n+        */\n         \n         for (String field : coll) {\n             if (sb.length() == 0) {", "timestamp": 1400901646, "metainfo": ""}