{"sha": "42bec38d9a4bcde590e3a56d74c75b8c1debbbc1", "log": "Merge branch '2.4'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     protected JsonToken _parsePosNumber(int c) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n-        int outPtr = 0;\n         // One special case: if first char is 0, must not be followed by a digit\n         if (c == INT_0) {\n             c = _verifyNoLeadingZeroes();\n         }\n         // Ok: we can first just add digit we saw first:\n-        outBuf[outPtr++] = (char) c;\n+        outBuf[0] = (char) c;\n         int intLen = 1;\n+        int outPtr = 1;\n         // And then figure out how far we can read without further checks\n         // for either input or output\n-        int end = _inputPtr + outBuf.length;\n+        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n         if (end > _inputEnd) {\n             end = _inputEnd;\n         }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n         }\n     }\n \n+    // [jackson-core#157]\n+    public void testLongNumbers() throws Exception\n+    {\n+        StringBuilder sb = new StringBuilder(9000);\n+        for (int i = 0; i < 9000; ++i) {\n+            sb.append('9');\n+        }\n+        String NUM = sb.toString();\n+        JsonFactory f = new JsonFactory();\n+        _testLongNumbers(f, NUM, false);\n+        _testLongNumbers(f, NUM, true);\n+    }\n+    \n+    private void _testLongNumbers(JsonFactory f, String num, boolean useStream) throws Exception\n+    {\n+        final String doc = \"[ \"+num+\" ]\";\n+        JsonParser jp = useStream\n+                ? FACTORY.createParser(doc.getBytes(\"UTF-8\"))\n+                        : FACTORY.createParser(doc);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(num, jp.getText());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests for invalid access\n     /**********************************************************\n      */\n     \n-    public void testInvalidBooleanAccess()\n-        throws Exception\n+    public void testInvalidBooleanAccess() throws Exception\n     {\n         JsonParser jp = FACTORY.createParser(\"[ \\\"abc\\\" ]\");\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      *   number of values written (before matching call to\n      *   {@link #writeEndArray()} MUST match; generator MAY verify\n      *   this is the case.\n+     *   \n+     * @since 2.4\n      */\n     public void writeStartArray(int size) throws IOException {\n         writeStartArray();\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n \n         /**\n          * Feature that can be enabled to accept quoting of all character\n-         * using backslash qooting mechanism: if not enabled, only characters\n+         * using backslash quoting mechanism: if not enabled, only characters\n          * that are explicitly listed by JSON specification can be thus\n          * escaped (see JSON spec for small list of these characters)\n          *<p>\n      * represented by root {@link TreeNode} of resulting model.\n      * For JSON Arrays it will an array node (with child nodes),\n      * for objects object node (with child nodes), and for other types\n-     * matching leaf node type\n+     * matching leaf node type. Empty or whitespace documents are null.\n+     *\n+     * @return root of the document, or null if empty or whitespace.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T extends TreeNode> T readValueAsTree() throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n      * using set of {@link TreeNode} instances. Returns\n      * root of the resulting tree (where root can consist\n      * of just a single node if the current event is a\n-     * value event, not container).\n+     * value event, not container). Empty or whitespace\n+     * documents return null.\n+     *\n+     * @return next tree from jp, or null if empty.\n      */\n     @Override\n     public abstract <T extends TreeNode> T readTree(JsonParser jp)\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n-            quads[qlen++] = currQuad;\n+            quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n     private final Name findName(int q1, int lastQuadBytes)\n         throws JsonParseException\n     {\n+        q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         Name name = _symbols.findName(q1);\n         if (name != null) {\n     private final Name findName(int q1, int q2, int lastQuadBytes)\n         throws JsonParseException\n     {\n+        q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         Name name = _symbols.findName(q1, q2);\n         if (name != null) {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n         }\n-        quads[qlen++] = lastQuad;\n+        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             return addName(quads, qlen, lastQuadBytes);\n \n     /*\n     /**********************************************************\n-    /* Binary access\n+    /* Internal methods, binary access\n     /**********************************************************\n      */\n \n             builder.appendThreeBytes(decodedData);\n         }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method needed to fix [Issue#148], masking of 0x00 character\n+     */\n+    private final static int pad(int q, int bytes) {\n+        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n      * parameters (for its direct super-class and/or super-interfaces).\n      */\n     public abstract boolean hasGenericTypes();\n-    \n+\n+    /**\n+     * Accessor that can be used to find out type for which parameterization\n+     * is applied: this is often NOT same as what {@link #getRawType} returns,\n+     * but rather one of it supertype.\n+     *<p>\n+     * For example: for type like {@link java.util.HashMap}, raw type is\n+     * {@link java.util.HashMap}; but this method would return\n+     * {@link java.util.Map}, because relevant type parameters that are\n+     * resolved (and accessible using {@link #containedType(int)} and\n+     * {@link #getKeyType()}) are parameter for {@link java.util.Map}\n+     * (which may or may not be same as type parameters for subtype;\n+     * in case of {@link java.util.HashMap} they are, but for further\n+     * subtypes they may be different parameters or possibly none at all).\n+     * \n+     * @since 2.5\n+     */\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+\n     /**\n      * Method for accessing key type for this type, assuming type\n      * has such a concept (only Map types do)\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    protected final static String FIELD_BASENAME = \"f\";\n+    \n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+\n+    protected void fieldNameFor(StringBuilder sb, int index)\n+    {\n+        /* let's do something like \"f1.1\" to exercise different\n+         * field names (important for byte-based codec)\n+         * Other name shuffling done mostly just for fun... :)\n+         */\n+        sb.append(FIELD_BASENAME);\n+        sb.append(index);\n+        if (index > 50) {\n+            sb.append('.');\n+            if (index > 200) {\n+                sb.append(index);\n+                if (index > 4000) { // and some even longer symbols...\n+                    sb.append(\".\").append(index);\n+                }\n+            } else {\n+                sb.append(index >> 3); // divide by 8\n+            }\n+        }\n+    }\n+\n+    protected String fieldNameFor(int index)\n+    {\n+        StringBuilder sb = new StringBuilder(16);\n+        fieldNameFor(sb, index);\n+        return sb.toString();\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n package com.fasterxml.jackson.core;\n \n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestExceptions extends BaseTest\n {\n--- a/src/test/java/com/fasterxml/jackson/core/TestJDKSerializability.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJDKSerializability.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit tests for [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n package com.fasterxml.jackson.core;\n \n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestJsonPointer extends BaseTest\n {\n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n /**\n  * Tests to verify [JACKSON-278]\n  */\n-public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersions extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testCoreVersions() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Codec.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Codec.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Codec\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testProps()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Generation\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     static class ThrottledInputStream extends FilterInputStream\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n import com.fasterxml.jackson.core.*;\n \n public class TestBase64Parsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testBase64UsingInputStream() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n  * Tests for verifying that accessing base64 encoded content works ok.\n  */\n public class TestJsonParserBinary\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/format/TestJsonFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/core/format/TestJsonFormatDetection.java\n import com.fasterxml.jackson.core.format.DataFormatMatcher;\n import com.fasterxml.jackson.core.format.MatchStrength;\n \n-public class TestJsonFormatDetection extends com.fasterxml.jackson.test.BaseTest\n+public class TestJsonFormatDetection extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimpleValidArray() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestCharTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestCharTypes.java\n package com.fasterxml.jackson.core.io;\n \n public class TestCharTypes\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAppendQuoted0_31 ()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestIOContext\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAllocations() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n import com.fasterxml.jackson.core.*;\n \n public class TestJDKSerializable\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testLocationSerializability() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestJsonStringEncoder.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJsonStringEncoder.java\n import com.fasterxml.jackson.core.io.JsonStringEncoder;\n \n public class TestJsonStringEncoder\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testQuoteAsString() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestMergedStream.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestMergedStream.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestMergedStream\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimple() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestUTF8Writer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestUTF8Writer.java\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n public class TestUTF8Writer\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimple() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n  * functionality works as expected.\n  */\n public class TestCharEscaping\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // for [JACKSON-627]\n     @SuppressWarnings(\"serial\")\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestComments.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestComments.java\n  * works as expected.\n  */\n public class TestComments\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String DOC_WITH_SLASHSTAR_COMMENT =\n         \"[ /* comment:\\n ends here */ 1 /* one more ok to have \\\"unquoted\\\"  */ ]\"\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SerializedString;\n \n-public class TestCustomEscaping extends com.fasterxml.jackson.test.BaseTest\n+public class TestCustomEscaping extends com.fasterxml.jackson.core.BaseTest\n {\n     final static int TWO_BYTE_ESCAPED = 0x111;\n     final static int THREE_BYTE_ESCAPED = 0x1111;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestDecorators.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestDecorators.java\n  * @since 1.8\n  */\n @SuppressWarnings(\"serial\")\n-public class TestDecorators extends com.fasterxml.jackson.test.BaseTest\n+public class TestDecorators extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n import com.fasterxml.jackson.core.*;\n \n public class TestGeneratorDupHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimpleDups() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorWithSerializedString.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorWithSerializedString.java\n import com.fasterxml.jackson.core.io.SerializedString;\n \n public class TestGeneratorWithSerializedString\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String NAME_WITH_QUOTES = \"\\\"name\\\"\";\n     final static String NAME_WITH_LATIN1 = \"P\\u00f6ll\\u00f6\";\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java\n import com.fasterxml.jackson.core.*;\n \n public class TestJsonFactory\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testGeneratorFeatures() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n  * functionality works as expected.\n  */\n public class TestJsonGenerator\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // // // First, tests for primitive (non-structured) values\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n  * functionality works as expected.\n  */\n public class TestJsonGeneratorFeatures\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testConfigDefaults() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n  * functionality works as expected.\n  */\n public class TestJsonParser\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory JSON_FACTORY = new JsonFactory();\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n import com.fasterxml.jackson.core.*;\n \n // NOTE: just a stub so for, fill me!\n-public class TestLocation extends com.fasterxml.jackson.test.BaseTest\n+public class TestLocation extends com.fasterxml.jackson.core.BaseTest\n {\n     // Trivially simple unit test for basics wrt offsets\n     public void testSimpleInitialOffsets() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n import com.fasterxml.jackson.core.io.SerializedString;\n \n public class TestNextXxx\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n  */\n @SuppressWarnings(\"resource\")\n public class TestNumericValues\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory FACTORY = new JsonFactory();\n     \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserDupHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserDupHandling.java\n import com.fasterxml.jackson.core.*;\n \n public class TestParserDupHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSimpleDups() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n import com.fasterxml.jackson.core.JsonToken;\n \n public class TestParserErrorHandling\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testInvalidKeywordsStream() throws Exception {\n         _testInvalidKeywords(true);\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n import com.fasterxml.jackson.core.*;\n \n public class TestParserNonStandard\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     // // // And then tests to verify [JACKSON-69]:\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserOverrides.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserOverrides.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n \n-public class TestParserOverrides extends com.fasterxml.jackson.test.BaseTest\n+public class TestParserOverrides extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestParserSymbols\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    // For [Issue#148]\n+    public void testSymbolsWithNullBytes() throws Exception {\n+        _testSymbolsWithNull(true);\n+    }\n+\n+    // For [Issue#148]\n+    public void testSymbolsWithNullChars() throws Exception {\n+        _testSymbolsWithNull(false);\n+    }\n+    \n+    private void _testSymbolsWithNull(boolean useBytes) throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\" : 2}\";\n+        JsonParser parser = useBytes ? f.createParser(INPUT.getBytes(\"UTF-8\"))\n+                : f.createParser(INPUT);\n+\n+        assertToken(JsonToken.START_OBJECT, parser.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n+        assertEquals(\"\\u0000abc\", parser.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n+        assertEquals(1, parser.getIntValue());\n+\n+        assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n+        assertEquals(\"abc\", parser.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n+        assertEquals(2, parser.getIntValue());\n+        \n+        assertToken(JsonToken.END_OBJECT, parser.nextToken());\n+        parser.close();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n import com.fasterxml.jackson.core.*;\n \n public class TestRootValues\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     private final JsonFactory JSON_F = new JsonFactory();\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n \n import com.fasterxml.jackson.core.*;\n \n-public class TestUnicode extends com.fasterxml.jackson.test.BaseTest\n+public class TestUnicode extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testSurrogates() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestUtf8Generator\n     extends BaseTest\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n import java.util.Random;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestValueConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestValueConversions.java\n \n @SuppressWarnings(\"resource\")\n public class TestValueConversions\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAsInt() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestWithTonsaSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestWithTonsaSymbols.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Some unit tests to try to exercise part of parser code that\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n  * edge cases.\n  */\n public class TestArrayParsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testValidEmpty() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorArray.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorArray.java\n  * of {@link JsonGenerator} work as expected.\n  */\n public class TestGeneratorArray\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testEmptyArrayWrite()\n         throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorCopy.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorCopy.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n  */\n @SuppressWarnings(\"resource\")\n public class TestGeneratorMisc\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorObject.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorObject.java\n package com.fasterxml.jackson.core.main;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n import java.math.BigDecimal;\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestNumberParsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestNumberParsing.java\n  * handling methods work as expected.\n  */\n public class TestNumberParsing\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testIntParsing() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserClosing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserClosing.java\n import static org.junit.Assert.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.*;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n  * settings work as expected.\n  */\n public class TestParserFeatures\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testDefaultSettings()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.io.IOException;\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n  * be accessed using JsonParser.\n  */\n public class TestParserWithObjects\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n \n     /*\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n  */\n @SuppressWarnings(\"serial\")\n public class TestPrettyPrinter\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     static class CountPrinter extends MinimalPrettyPrinter\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n /**\n  * @since 1.7\n  */\n-public class TestRawStringWriting extends com.fasterxml.jackson.test.BaseTest\n+public class TestRawStringWriting extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Unit test for \"JsonGenerator.writeRawUTF8String()\"\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n \n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Set of basic unit tests for verifying that Array/Object scopes\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java\n \n import java.io.*;\n \n-\n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.util.Random;\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n  * good at catching it...).\n  */\n public class TestByteBasedSymbols\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     final static String[] FIELD_NAMES = new String[] {\n         \"a\", \"b\", \"c\", \"x\", \"y\", \"b13\", \"abcdefg\", \"a123\",\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestHashCollisionChars.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestHashCollisionChars.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Some unit tests to try to exercise part of parser code that\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n  */\n @SuppressWarnings(\"serial\")\n public class TestJsonParserSymbols\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * To peek into state of \"root\" symbol tables (parent of all symbol\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n import com.fasterxml.jackson.core.JsonFactory;\n \n-public class TestSymbolTables extends com.fasterxml.jackson.test.BaseTest\n+public class TestSymbolTables extends com.fasterxml.jackson.core.BaseTest\n {\n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and character-based input\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestCharTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestCharTypes.java\n import com.fasterxml.jackson.core.io.CharTypes;\n \n public class TestCharTypes\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testQuoting()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n \n import com.fasterxml.jackson.core.*;\n \n-public class TestDelegates extends com.fasterxml.jackson.test.BaseTest\n+public class TestDelegates extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Test default, non-overridden parser delegate.\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n  * printingg methods work as expected.\n  */\n public class TestNumberPrinting\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testIntPrinting()\n         throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestSerializedString.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestSerializedString.java\n  * {@link SerializableString} implementation works as expected.\n  */\n public class TestSerializedString\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testAppending() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n import com.fasterxml.jackson.core.util.TextBuffer;\n \n public class TestTextBuffer\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends com.fasterxml.jackson.core.BaseTest\n {\n     /**\n      * Trivially simple basic test to ensure all basic append\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n import com.fasterxml.jackson.core.json.PackageVersion;\n import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n \n-public class TestVersionUtil extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersionUtil extends com.fasterxml.jackson.core.BaseTest\n {\n     public void testVersionPartParsing()\n     {", "timestamp": 1412809704, "metainfo": ""}