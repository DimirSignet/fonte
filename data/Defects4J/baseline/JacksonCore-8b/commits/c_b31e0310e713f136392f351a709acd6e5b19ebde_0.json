{"sha": "b31e0310e713f136392f351a709acd6e5b19ebde", "log": "More attempts at reproducing #142", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n public class TestJsonParser\n     extends com.fasterxml.jackson.test.BaseTest\n {\n+    private final JsonFactory JSON_FACTORY = new JsonFactory();\n+\n     public void testConfig() throws Exception\n     {\n         JsonParser jp = createParserUsingReader(\"[ ]\");\n         _testIntern(true, false, \"b\");\n     }\n \n-    public void testHandlingOfInvalidSpaceBytes() throws Exception\n-    {\n-        _testHandlingOfInvalidSpace(true);\n-    }\n-    \n-    public void testHandlingOfInvalidSpaceChars() throws Exception\n-    {\n-        _testHandlingOfInvalidSpace(false);\n-    }\n-\n-    // [#142]\n-    private void _testHandlingOfInvalidSpace(boolean useStream) throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        final String JSON = \"{ \\u00A0 \\\"a\\\":1}\";\n-        JsonParser jp = useStream ?\n-                createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n-        try {\n-            jp.nextToken();\n-            fail(\"Should have failed\");\n-        } catch (JsonParseException e) {\n-            verifyException(e, \"unexpected character\");\n-            // and correct error code\n-            verifyException(e, \"code 160\");\n-        }\n-        jp.close();\n-    }\n-    \n     public void testInterningWithReaders() throws Exception\n     {\n         _testIntern(false, true, \"c\");\n         jp.close();\n     }\n \n-    public void testSkipping()\n-        throws Exception\n+    public void testSkipping() throws Exception\n     {\n         String DOC =\n             \"[ 1, 3, [ true, null ], 3, { \\\"a\\\":\\\"b\\\" }, [ [ ] ], { } ]\";\n         NAME_MAP.put(\"Line\\\\nfeed\", \"Line\\nfeed\");\n         NAME_MAP.put(\"Yet even longer \\\\\\\"name\\\\\\\"!\", \"Yet even longer \\\"name\\\"!\");\n \n-        JsonFactory jf = new JsonFactory();\n         int entry = 0;\n         for (Map.Entry<String,String> en : NAME_MAP.entrySet()) {\n             ++entry;\n             String expResult = en.getValue();\n             final String DOC = \"{ \\\"\"+input+\"\\\":null}\";\n             JsonParser jp = useStream ?\n-                jf.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n-                : jf.createParser(new StringReader(DOC));\n+                    JSON_FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+                : JSON_FACTORY.createParser(new StringReader(DOC));\n \n             assertToken(JsonToken.START_OBJECT, jp.nextToken());\n             assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n      */\n     public void testLongText() throws Exception\n     {\n-        JsonFactory jf = new JsonFactory();\n         // lengths chosen to tease out problems with buffer allocation...\n-        _testLongText(jf, 7700);\n-        _testLongText(jf, 49000);\n-        _testLongText(jf, 96000);\n+        _testLongText(7700);\n+        _testLongText(49000);\n+        _testLongText(96000);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    private void _testLongText(JsonFactory jf, int LEN) throws Exception\n+    private void _testLongText(int LEN) throws Exception\n     {\n         StringBuilder sb = new StringBuilder(LEN + 100);\n         Random r = new Random(99);\n         \n         // Let's use real generator to get JSON done right\n         StringWriter sw = new StringWriter(LEN + (LEN >> 2));\n-        JsonGenerator jg = jf.createGenerator(sw);\n+        JsonGenerator jg = JSON_FACTORY.createGenerator(sw);\n         jg.writeStartObject();\n         jg.writeFieldName(\"doc\");\n         jg.writeString(VALUE);\n \n             switch (type) {\n             default:\n-                jp = jf.createParser(DOC.getBytes(\"UTF-8\"));\n+                jp = JSON_FACTORY.createParser(DOC.getBytes(\"UTF-8\"));\n                 break;\n             case 1:\n-                jp = jf.createParser(DOC);\n+                jp = JSON_FACTORY.createParser(DOC);\n                 break;\n             case 2: // NEW: let's also exercise UTF-32...\n-                jp = jf.createParser(encodeInUTF32BE(DOC));\n+                jp = JSON_FACTORY.createParser(encodeInUTF32BE(DOC));\n                 break;\n             }\n             assertToken(JsonToken.START_OBJECT, jp.nextToken());\n \n         System.arraycopy(b, 0, src, offset, len);\n \n-        JsonFactory jf = new JsonFactory();\n-        JsonParser jp = jf.createParser(src, offset, len);\n+        JsonParser jp = JSON_FACTORY.createParser(src, offset, len);\n \n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n         bytes.write(0xBB);\n         bytes.write(0xBF);\n         bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\"));\n-        JsonFactory jf = new JsonFactory();\n-        JsonParser jp = jf.createParser(bytes.toByteArray());\n+        JsonParser jp = JSON_FACTORY.createParser(bytes.toByteArray());\n         assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n         // should also have skipped first 3 bytes of BOM; but do we have offset available?\n         /* 08-Oct-2013, tatu: Alas, due to [Issue#111], we have to omit BOM in calculations\n         w.close();\n         URL url = f.toURI().toURL();\n \n-        JsonFactory jf = new JsonFactory();\n-        JsonParser jp = jf.createParser(url);\n+        JsonParser jp = JSON_FACTORY.createParser(url);\n         assertToken(JsonToken.START_OBJECT, jp.nextToken());\n         assertToken(JsonToken.END_OBJECT, jp.nextToken());\n         jp.close();\n     }\n \n+    // [#142]\n+    public void testHandlingOfInvalidSpaceBytes() throws Exception {\n+        _testHandlingOfInvalidSpace(true);\n+        _testHandlingOfInvalidSpaceFromResource(true);\n+    }\n+    \n+    // [#142]\n+    public void testHandlingOfInvalidSpaceChars() throws Exception {\n+        _testHandlingOfInvalidSpace(false);\n+        _testHandlingOfInvalidSpaceFromResource(false);\n+    }\n+\n+    private void _testHandlingOfInvalidSpace(boolean useStream) throws Exception\n+    {\n+        final String JSON = \"{ \\u00A0 \\\"a\\\":1}\";\n+        JsonParser jp = useStream\n+                ? createParserUsingStream(JSON_FACTORY, JSON, \"UTF-8\")\n+                : createParserUsingReader(JSON_FACTORY, JSON);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            fail(\"Should have failed\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"unexpected character\");\n+            // and correct error code\n+            verifyException(e, \"code 160\");\n+        }\n+        jp.close();\n+    }\n+\n+    private void _testHandlingOfInvalidSpaceFromResource(boolean useStream) throws Exception\n+    {\n+        InputStream in = getClass().getResourceAsStream(\"/test_0xA0.json\");\n+        @SuppressWarnings(\"resource\")\n+        JsonParser jp = useStream\n+                ? JSON_FACTORY.createParser(in)\n+                : JSON_FACTORY.createParser(new InputStreamReader(in, \"UTF-8\"));\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        try {\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"request\", jp.getCurrentName());\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"mac\", jp.getCurrentName());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertNotNull(jp.getText());\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"data\", jp.getCurrentName());\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+            // ... and from there on, just loop\n+            \n+            while (jp.nextToken()  != null) { }\n+            fail(\"Should have failed\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"unexpected character\");\n+            // and correct error code\n+            verifyException(e, \"code 160\");\n+        }\n+        jp.close();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n \n-    private void doTestSpec(boolean verify)\n-        throws IOException\n+    private void doTestSpec(boolean verify) throws IOException\n     {\n         // First, using a StringReader:\n         doTestSpecIndividual(null, verify);\n         doTestSpecIndividual(\"UTF-32\", verify);\n     }\n \n-    @SuppressWarnings(\"resource\")\n     private void doTestSpecIndividual(String enc, boolean verify) throws IOException\n     {\n         String doc = SAMPLE_DOC_JSON_SPEC;", "timestamp": 1402371149, "metainfo": ""}