{"sha": "bda3a91da70dede312fa0ad0eac0dfd99f543531", "log": "more hash collision work for 2.1 too", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n     /**\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n-     * with uniquer (~= random) names.\n+     * with unique (~= random) names.\n      */\n     protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n     \n      */\n     final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n+    /**\n+     * Also: to thwart attacks based on hash collisions (which may or may not\n+     * be cheap to calculate), we will need to detect \"too long\"\n+     * collision chains. Let's start with static value of 255 entries\n+     * for the longest legal chain.\n+     *<p>\n+     * Note: longest chain we have been able to produce without malicious\n+     * intent has been 60 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n+     * our setting should be reasonable here.\n+     * \n+     * @since 2.1\n+     */\n+    final static int MAX_COLL_CHAIN_LENGTH = 255;\n+\n+    /**\n+     * And to support reduce likelihood of accidental collisions causing\n+     * exceptions, let's prevent reuse of tables with long collision\n+     * overflow lists as well.\n+     * \n+     * @since 2.1\n+     */\n+    final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n+\n     final static int MIN_HASH_SIZE = 16;\n \n     final static int INITIAL_COLLISION_LEN = 32;\n      * Whether canonial symbol Strings are to be intern()ed before added\n      * to the table or not\n      */\n-    final boolean _intern;\n+    private final boolean _intern;\n     \n     // // // First, global information\n \n      */\n     private int _count;\n \n+    /**\n+     * We need to keep track of the longest collision list; this is needed\n+     * both to indicate problems with attacks and to allow flushing for\n+     * other cases.\n+     * \n+     * @since 2.1\n+     */\n+    protected int _longestCollisionList;\n+    \n     // // // Then information regarding primary hash array and its\n     // // // matching Name array\n \n         _collList = parent._collList;\n         _collCount = parent._collCount;\n         _collEnd = parent._collEnd;\n+        _longestCollisionList = parent._longestCollisionList;\n         _needRehash = false;\n         // And consider all shared, so far:\n         _mainHashShared = true;\n     private void initTables(int hashSize)\n     {\n         _count = 0;\n+        _longestCollisionList = 0;\n         _mainHash = new int[hashSize];\n         _mainNames = new Name[hashSize];\n         _mainHashShared = false;\n          * One way to do this is to just purge tables if they grow\n          * too large, and that's what we'll do here.\n          */\n-        if (child.size() > MAX_ENTRIES_FOR_REUSE) {\n+        if (child.size() > MAX_ENTRIES_FOR_REUSE\n+                || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n             /* Should there be a way to get notified about this\n              * event, to log it or such? (as it's somewhat abnormal\n              * thing to happen)\n             initTables(DEFAULT_TABLE_SIZE);\n         } else {\n             _count = child._count;\n+            _longestCollisionList = child._longestCollisionList;\n             _mainHash = child._mainHash;\n             _mainNames = child._mainNames;\n             _mainHashShared = true; // shouldn't matter for parent\n     public int size() { return _count; }\n \n     /**\n+     * @since 2.1\n+     */\n+    public int bucketCount() { return _mainHash.length; }\n+    \n+    /**\n      * Method called to check to quickly see if a child symbol table\n      * may have gotten additional entries. Used for checking to see\n      * if a child table should be merged into shared table.\n         return !_mainHashShared;\n     }\n \n+    /**\n+     * Method mostly needed by unit tests; calculates number of\n+     * entries that are in collision list. Value can be at most\n+     * ({@link #size} - 1), but should usually be much lower, ideally 0.\n+     * \n+     * @since 2.1\n+     */\n+    public int collisionCount() {\n+        return _collCount;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates length of the\n+     * longest collision chain. This should typically be a low number,\n+     * but may be up to {@link #size} - 1 in the pathological case\n+     * \n+     * @since 2.1\n+     */\n+    public int maxCollisionLength() {\n+        return _longestCollisionList;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessing symbols:\n+    /**********************************************************\n+     */\n+    \n     public static Name getEmptyName()\n     {\n         return Name1.getEmptyName();\n     /**********************************************************\n      */\n \n+    \n+    // JDK uses 33; other fine choices are 31 and 65599\n+    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n+    private final static int MULT = 33;\n+    \n     public final static int calcHash(int firstQuad)\n     {\n         int hash = firstQuad;\n \n     public final static int calcHash(int firstQuad, int secondQuad)\n     {\n-        int hash = (firstQuad * 31) + secondQuad;\n+        int hash = (firstQuad * MULT) + secondQuad;\n \n         // If this was called for single-quad instance:\n-        //int hash = (secondQuad == 0) ? firstQuad : ((firstQuad * 31) + secondQuad);\n+        //int hash = (secondQuad == 0) ? firstQuad : ((firstQuad * MULT) + secondQuad);\n \n         hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n         hash ^= (hash >>> 8); // as well as lowest 2 bytes\n         // Note: may be called for qlen < 3\n         int hash = quads[0];\n         for (int i = 1; i < qlen; ++i) {\n-            hash = (hash * 31) + quads[i];\n+            hash = (hash * MULT) + quads[i];\n         }\n \n         hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n         hash ^= (hash >>> 8); // as well as lowest 2 bytes\n-\n         return hash;\n     }\n \n-    /* 26-Nov-2008, tatu: not used currently; if not used in near future,\n-     *   let's just delete it.\n-     */\n-    /*\n-    public static int[] calcQuads(byte[] wordBytes)\n+    // Method only used by unit tests\n+    protected static int[] calcQuads(byte[] wordBytes)\n     {\n         int blen = wordBytes.length;\n         int[] result = new int[(blen + 3) / 4];\n         }\n         return result;\n     }\n-    */\n \n     /*\n     /**********************************************************\n             if (_collListShared) {\n                 unshareCollision(); // also allocates if list was null\n             }\n-\n             ++_collCount;\n             int entryValue = _mainHash[ix];\n             int bucket = entryValue & 0xFF;\n             }\n             \n             // And then just need to link the new bucket entry in\n-            _collList[bucket] = new Bucket(symbol, _collList[bucket]);\n+            Bucket newB = new Bucket(symbol, _collList[bucket]);\n+            _collList[bucket] = newB;\n+            // but, be careful wrt attacks\n+            _longestCollisionList = Math.max(newB.length(), _longestCollisionList);\n+            if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) {\n+                reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+            }\n         }\n \n         /* Ok. Now, do we need a rehash next time? Need to have at least\n          */\n         int oldEnd = _collEnd;\n         if (oldEnd == 0) { // no prior collisions...\n+            _longestCollisionList = 0;\n             return;\n         }\n \n         _collEnd = 0;\n         _collListShared = false;\n \n+        int maxColl = 0;\n+        \n         Bucket[] oldBuckets = _collList;\n         _collList = new Bucket[oldBuckets.length];\n         for (int i = 0; i < oldEnd; ++i) {\n                         --bucket; // 1-based index in value\n                     }\n                     // And then just need to link the new bucket entry in\n-                    _collList[bucket] = new Bucket(symbol, _collList[bucket]);\n+                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n+                    _collList[bucket] = newB;\n+                    maxColl = Math.max(maxColl, newB.length());\n                 }\n             } // for (... buckets in the chain ...)\n         } // for (... list of bucket heads ... )\n \n+        _longestCollisionList = maxColl;\n+        \n         if (symbolsSeen != _count) { // sanity check\n             throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n         }\n     private void nukeSymbols()\n     {\n         _count = 0;\n+        _longestCollisionList = 0;\n         Arrays.fill(_mainHash, 0);\n         Arrays.fill(_mainNames, null);\n         Arrays.fill(_collList, null);\n \n     /*\n     /**********************************************************\n+    /* Other helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 2.1\n+     */\n+    protected void reportTooManyCollisions(int maxLen)\n+    {\n+        throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_count\n+                +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Helper classes\n     /**********************************************************\n      */\n     {\n         protected final Name _name;\n         protected final Bucket _next;\n+        private final int _length;\n \n         Bucket(Name name, Bucket next)\n         {\n             _name = name;\n             _next = next;\n-        }\n-\n-        public int length()\n-        {\n-            int len = 1;\n-            for (Bucket curr = _next; curr != null; curr = curr._next) {\n-                ++len;\n-            }\n-            return len;\n-        }\n+            _length = (next == null) ? 1 : next._length+1;\n+        }\n+\n+        public int length() { return _length; }\n \n         public Name find(int hash, int firstQuad, int secondQuad)\n         {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * be cheap to calculate), we will need to detect \"too long\"\n      * collision chains. Let's start with static value of 255 entries\n      * for the longest legal chain.\n+     *<p>\n+     * Note: longest chain we have been able to produce without malicious\n+     * intent has been 38 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n+     * our setting should be reasonable here.\n      * \n      * @since 2.1\n      */\n         _size = 0;\n         _longestCollisionList = 0;\n         // Hard-coded fill factor is 75%\n-        _sizeThreshold = (initialSize - (initialSize >> 2));\n-    }\n-\n+        _sizeThreshold = _thresholdSize(initialSize);\n+    }\n+\n+    private final static int _thresholdSize(int hashAreaSize) {\n+        return hashAreaSize - (hashAreaSize >> 2);\n+    }\n+    \n     /**\n      * Internal constructor used when creating child instances.\n      */\n         _hashSeed = hashSeed;\n         // Hard-coded fill factor, 75%\n         int arrayLen = (symbols.length);\n-        _sizeThreshold = arrayLen - (arrayLen >> 2);\n+        _sizeThreshold = _thresholdSize(arrayLen);\n         _indexMask =  (arrayLen - 1);\n         _longestCollisionList = longestColl;\n \n \n     public int size() { return _size; }\n \n+    /**\n+     * Method for checking number of primary hash buckets this symbol\n+     * table uses.\n+     * \n+     * @since 2.1\n+     */\n+    public int bucketCount() { \n+       return _symbols.length; }\n+    \n     public boolean maybeDirty() { return _dirty; }\n \n     public int hashSeed() { return _hashSeed; }\n         _buckets = new Bucket[newSize >> 1];\n         // Let's update index mask, threshold, now (needed for rehashing)\n         _indexMask = newSize - 1;\n-        _sizeThreshold += _sizeThreshold;\n+        _sizeThreshold = _thresholdSize(newSize);\n         \n         int count = 0; // let's do sanity check\n \n--- a/src/test/java/com/fasterxml/jackson/core/main/TestWithTonsaSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestWithTonsaSymbols.java\n public class TestWithTonsaSymbols\n     extends BaseTest\n {\n-    final static String FIELD_BASENAME = \"f\";\n-\n     /**\n      * How many fields to generate? Since maximum symbol table\n      * size is defined as 6000 (above which table gets cleared,\n     }\n \n     /*\n-    //////////////////////////////////////////////////////\n-    // Helper methods\n-    //////////////////////////////////////////////////////\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n      */\n \n     private void _testWith(boolean useStream)\n             jp.close();\n         }\n     }\n-\n-    private void fieldNameFor(StringBuilder sb, int index)\n-    {\n-        /* let's do something like \"f1.1\" to exercise different\n-         * field names (important for byte-based codec)\n-         * Other name shuffling done mostly just for fun... :)\n-         */\n-        sb.append(FIELD_BASENAME);\n-        sb.append(index);\n-        if (index > 50) {\n-            sb.append('.');\n-            if (index > 200) {\n-                sb.append(index);\n-                if (index > 4000) { // and some even longer symbols...\n-                    sb.append(\".\").append(index);\n-                }\n-            } else {\n-                sb.append(index >> 3); // divide by 8\n-            }\n-        }\n-    }\n-\n-    private String fieldNameFor(int index)\n-    {\n-        StringBuilder sb = new StringBuilder(16);\n-        fieldNameFor(sb, index);\n-        return sb.toString();\n-    }\n         \n     private String buildDoc(int len)\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n package com.fasterxml.jackson.core.sym;\n+\n+import java.io.IOException;\n \n public class TestSymbolTables extends com.fasterxml.jackson.test.BaseTest\n {\n             assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+2, sym.size());\n         }\n     }\n+\n+    // Test for verifying stability of hashCode, wrt collisions, using\n+    // synthetic field name generation and character-based input\n+    public void testSyntheticWithChars()\n+    {\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(0);\n+        for (int i = 0; i < 5000; ++i) {\n+            String id = fieldNameFor(i);\n+            char[] ch = id.toCharArray();\n+            symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n+        }\n+\n+        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(5000, symbols.size());\n+        // holy guacamoley... there are way too many:\n+        assertEquals(3053, symbols.collisionCount());\n+        // but spread more evenly than byte-based ones?\n+        assertEquals(29, symbols.maxCollisionLength());\n+    }\n+\n+    // Test for verifying stability of hashCode, wrt collisions, using\n+    // synthetic field name generation and byte-based input (UTF-8)\n+    public void testSyntheticWithBytes() throws IOException\n+    {\n+        BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot();\n+        for (int i = 0; i < 5000; ++i) {\n+            String id = fieldNameFor(i);\n+            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(5000, symbols.size());\n+        assertEquals(8192, symbols.bucketCount());\n+        \n+        // holy guacamoley... even here we have too many; but surprisingly (?)\n+        // less than with chars\n+        assertEquals(1697, symbols.collisionCount());\n+        assertEquals(9, symbols.maxCollisionLength());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n public abstract class BaseTest\n     extends TestCase\n {\n+    protected final static String FIELD_BASENAME = \"f\";\n+    \n     /*\n     /**********************************************************\n     /* Some sample documents:\n     public String quote(String str) {\n         return '\"'+str+'\"';\n     }\n+\n+    protected void fieldNameFor(StringBuilder sb, int index)\n+    {\n+        /* let's do something like \"f1.1\" to exercise different\n+         * field names (important for byte-based codec)\n+         * Other name shuffling done mostly just for fun... :)\n+         */\n+        sb.append(FIELD_BASENAME);\n+        sb.append(index);\n+        if (index > 50) {\n+            sb.append('.');\n+            if (index > 200) {\n+                sb.append(index);\n+                if (index > 4000) { // and some even longer symbols...\n+                    sb.append(\".\").append(index);\n+                }\n+            } else {\n+                sb.append(index >> 3); // divide by 8\n+            }\n+        }\n+    }\n+\n+    protected String fieldNameFor(int index)\n+    {\n+        StringBuilder sb = new StringBuilder(16);\n+        fieldNameFor(sb, index);\n+        return sb.toString();\n+    }\n+\n }", "timestamp": 1342025122, "metainfo": ""}