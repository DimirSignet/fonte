{"sha": "3a00c863378daafb932b596c61bf89d60dae56cb", "log": "More work on alternate symbol table, passing most tests; not yet resizing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n import com.fasterxml.jackson.core.json.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n      * TODO: should clean up this; looks messy having 2 alternatives\n      * with not very clear differences.\n      */\n-    protected final transient BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n+    protected final transient ByteQuadsCanonicalizer _rootByteSymbols = ByteQuadsCanonicalizer.createRoot();\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n import com.fasterxml.jackson.core.format.InputAccessor;\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n \n /**\n     }\n \n     public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n-            BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n+            ByteQuadsCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n             int factoryFeatures) throws IOException\n     {\n         JsonEncoding enc = detectEncoding();\n              * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n              */\n             if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\n-                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n+                ByteQuadsCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n                 return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n                         _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n             }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n import com.fasterxml.jackson.core.base.ParserBase;\n import com.fasterxml.jackson.core.io.CharTypes;\n import com.fasterxml.jackson.core.io.IOContext;\n-import com.fasterxml.jackson.core.sym.*;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.util.*;\n \n import static com.fasterxml.jackson.core.JsonTokenId.*;\n     /**\n      * Symbol table that contains field names encountered so far\n      */\n-    final protected BytesToNameCanonicalizer _symbols;\n+    final protected ByteQuadsCanonicalizer _symbols;\n     \n     /*\n     /**********************************************************\n      */\n \n     public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n-            ObjectCodec codec, BytesToNameCanonicalizer sym,\n+            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n             byte[] inputBuffer, int start, int end,\n             boolean bufferRecyclable)\n     {\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n-        Name n = _parseName(i);\n-        _parsingContext.setCurrentName(n.getName());\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n             return null;\n         }\n \n-        Name n = _parseName(i);\n-        final String nameStr = n.getName();\n+        final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n-            \n-        Name n = _parseName(i);\n-        final boolean match;\n-        {\n-            String nameStr = n.getName();\n-            _parsingContext.setCurrentName(nameStr);\n-            match = nameStr.equals(str.getValue());\n-        }\n+\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n+        final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n     /**********************************************************\n      */\n     \n-    protected final Name _parseName(int i) throws IOException\n+    protected final String _parseName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) {\n             return _handleOddName(i);\n             return parseName(q, i, 1);\n         }     \n         if (q == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseName(0, q, 0); // quoting or invalid char\n     }\n \n-    protected final Name parseMediumName(int q2) throws IOException\n+    protected final String parseMediumName(int q2) throws IOException\n     {\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n     /**\n      * @since 2.6\n      */\n-    protected final Name parseMediumName2(int q3, final int q2) throws IOException\n+    protected final String parseMediumName2(int q3, final int q2) throws IOException\n     {\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n         return parseLongName(i, q2, q3);\n     }\n     \n-    protected final Name parseLongName(int q, final int q2, int q3) throws IOException\n+    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n     {\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n      * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n-    protected Name slowParseName() throws IOException\n+    protected String slowParseName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int i = _inputBuffer[_inputPtr++] & 0xFF;\n         if (i == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n-    private final Name parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n         _quadBuffer[0] = q1;\n         _quadBuffer[1] = q2;\n         return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n      * Needs to be able to handle more exceptional cases, gets slower,\n      * and hance is offlined to a separate method.\n      */\n-    protected final Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n+    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n             int currQuadBytes) throws IOException\n     {\n         /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected Name _handleOddName(int ch) throws IOException\n+    protected String _handleOddName(int ch) throws IOException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n             }\n             quads[qlen++] = currQuad;\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected Name _parseAposName() throws IOException\n+    protected String _parseAposName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int ch = _inputBuffer[_inputPtr++] & 0xFF;\n         if (ch == '\\'') { // special case, ''\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         int[] quads = _quadBuffer;\n         int qlen = 0;\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes) throws JsonParseException\n+    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n     {\n         q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1);\n+        String name = _symbols.findName(q1);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n+    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n     {\n         q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1, q2);\n+        String name = _symbols.findName(q1, q2);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n+    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n     {\n         q3 = pad(q3, lastQuadBytes);\n-        Name name = _symbols.findName(q1, q2, q3);\n+        String name = _symbols.findName(q1, q2, q3);\n         if (name != null) {\n             return name;\n         }\n         return addName(quads, 3, lastQuadBytes);\n     }\n     \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n+    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n         }\n         quads[qlen++] = pad(lastQuad, lastQuadBytes);\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             return addName(quads, qlen, lastQuadBytes);\n         }\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n          * needed, since unescaping has been done earlier as necessary\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n package com.fasterxml.jackson.core.sym;\n \n+import java.util.Arrays;\n import java.util.BitSet;\n import java.util.concurrent.atomic.AtomicReference;\n \n      * <code>1/2</code> \n      */\n     protected int _hashSize;\n+\n+    /**\n+     * Offset within {@link #_hash} where secondary entries start\n+     */\n+    protected int _secondaryOffset;\n     \n     /**\n      * Total number of Strings in the symbol table; only used for child tables.\n      */\n \n     /**\n-     * Number of entries that ended up in the shared spill-over\n-     * area (that is, did not fit in primary, secondary or tertiary slots).\n-     */\n-    protected int _spillOverCount;\n+     * Pointer to the offset within spill-over area where there is room\n+     * for more spilled over entries (if any).\n+     */\n+    protected int _spillOverEnd;\n \n     /**\n      * Offset within {@link #_hash} that follows main slots and contains\n      * long name.\n      */\n     protected int _longNameOffset;\n-\n-    /**\n-     * We need to keep track of the longest collision list; this is needed\n-     * both to indicate problems with attacks and to allow flushing for\n-     * other cases.\n-     */\n-    protected int _longestCollisionList;\n-\n-    /**\n-     * Total number of Names in collision buckets (included in\n-     * <code>_count</code> along with primary entries)\n-     */\n-    protected int _collCount;\n \n     /**\n      * This flag is set if, after adding a new entry, it is deemed\n         _count = state.count;\n         _hashSize = state.size;\n         _hashMask = _hashSize-1;\n+        _secondaryOffset = _hashSize << 2; // 4 ints per entry\n         _hash = state.mainHash;\n         _names = state.names;\n-        _collCount = state.collCount;\n-        _longestCollisionList = state.longestCollisionList;\n \n         // and then set other state to reflect sharing status\n         _needRehash = false;\n     \n     /**\n      * Method mostly needed by unit tests; calculates number of\n-     * entries that are in collision list. Value can be at most\n-     * ({@link #size} - 1), but should usually be much lower, ideally 0.\n-     */\n-    public int collisionCount() { return _collCount; }\n-\n-    /**\n-     * Method mostly needed by unit tests; calculates length of the\n-     * longest collision chain. This should typically be a low number,\n-     * but may be up to {@link #size} - 1 in the pathological case\n-     */\n-    public int maxCollisionLength() {\n-        return _longestCollisionList;\n+     * entries that are in the primary slot set. These are\n+     * \"perfect\" entries, accessible with a single lookup\n+     */\n+    public int primaryCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = _secondaryOffset; offset < end; offset += 4) {\n+            if (_hash[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in secondary buckets\n+     */\n+    public int secondaryCount() {\n+        int count = 0;\n+        int offset = _secondaryOffset + 3;\n+        for (int end = offset + (_hashSize << 1); offset < end; offset += 4) {\n+            if (_hash[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in tertiary buckets\n+     */\n+    public int tertiaryCount() {\n+        int count = 0;\n+        int offset = _secondaryOffset + (_hashSize << 1) + 3; // to 1.5x, starting point of tertiary\n+        for (int end = offset + _hashSize; offset < end; offset += 4) {\n+            if (_hash[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in shared spillover area\n+     */\n+    public int spillOverCount() {\n+        // difference between spillover end, start, divided by 4 (four ints per slot)\n+        return (_spillOverEnd - _spilloverStart()) >> 2;\n     }\n \n     /*\n \n         int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n-        \n+\n         if ((q1b == q1) && (len == 1)) {\n-            return _names[offset >> 4];\n+            return _names[offset >> 2];\n         }\n         if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n         }\n         // secondary? single slot shared by N/2 primaries\n-        int offset2 = _hashSize + (offset>>1);\n+        int offset2 = _secondaryOffset;\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n \n         if ((q1b == q1) && (len == 1)) {\n-            return _names[offset2 >> 4];\n+            return _names[offset2 >> 2];\n         }\n         if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n             return null;\n         }\n         // secondary?\n-        int offset2 = _hashSize + (offset>>1);\n+        int offset2 = _secondaryOffset;\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n             return null;\n         }\n         // secondary?\n-        int offset2 = _hashSize + (offset>>1);\n+        int offset2 = _secondaryOffset;\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n             return null;\n         }\n         // secondary?\n-        int offset2 = _hashSize + (offset>>1);\n+        int offset2 = _secondaryOffset;\n \n         h = hashArea[offset2];\n         len = hashArea[offset2+3];\n     private String _findSecondary(int origOffset, int q1)\n     {\n         // so, first tertiary, 4 cells shared by N/16 primary slots\n-        int offset = _hashSize;\n-        offset += (offset >> 1); // to skip secondary area\n-        offset += (origOffset >> 4);\n+        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n+        offset += (origOffset >> 6) << 2;\n \n         final int[] hashArea = _hash;\n-        \n+\n         // then check up to 4 slots; don't worry about empty slots yet\n         if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n             return _names[offset >> 2];\n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = (_hashSize << 1) - (_hashSize >> 8);\n-            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 16) {\n+            offset = _spilloverStart();\n+            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n                 if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n                 }\n \n     private String _findSecondary(int origOffset, int q1, int q2)\n     {\n-        int offset = _hashSize;\n-        offset += (offset >> 1);\n-        offset += (origOffset >> 4);\n+        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n+        offset += (origOffset >> 6) << 2;\n \n         final int[] hashArea = _hash;\n         \n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = (_hashSize << 1) - (_hashSize >> 8);\n-            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+            offset = _spilloverStart();\n+            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n                 if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n                 }\n \n     private String _findSecondary(int origOffset, int q1, int q2, int q3)\n     {\n-        int offset = _hashSize;\n-        offset += (offset >> 1);\n-        offset += (origOffset >> 4);\n+        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n+        offset += (origOffset >> 6) << 2;\n \n         final int[] hashArea = _hash;\n         \n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = (_hashSize << 1) - (_hashSize >> 8);\n-            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+            offset = _spilloverStart();\n+            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n                 if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                         && (3 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n \n     private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n     {\n-        int offset = _hashSize;\n-        offset += (offset >> 1);\n-        offset += (origOffset >> 4);\n+        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n+        offset += (origOffset >> 6) << 2;\n         \n         final int[] hashArea = _hash;\n         \n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = (_hashSize << 1) - (_hashSize >> 8);\n-            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+            offset = _spilloverStart();\n+            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n                 if ((hash == hashArea[offset]) && (3 == len)) {\n                     if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                         return _names[offset >> 2];\n     /**********************************************************\n      */\n \n-    public String addName(String name, int q1, int q2)\n-    {\n+    public String addName(String name, int[] q, int qlen)\n+    {\n+        _verifyRehashAndSharing();\n         if (_intern) {\n             name = InternCache.instance.intern(name);\n         }\n-        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n-//        return _addSymbol(hash, name);\n-        return null;\n-    }\n-    \n-    public String addName(String name, int[] q, int qlen)\n-    {\n-        if (_intern) {\n-            name = InternCache.instance.intern(name);\n-        }\n-        int hash;\n-        if (qlen < 4) {\n-            if (qlen == 1) {\n-                hash = calcHash(q[0]);\n-            } else if (qlen == 2) {\n-                hash = calcHash(q[0], q[1]);\n-            } else {\n-                hash = calcHash(q[0], q[1], q[2]);\n-            }\n-        } else {\n-            hash = calcHash(q, qlen);\n-        }\n-//        return _addSymbol(hash, name);\n-        return null;\n+        int offset;\n+        \n+        switch (qlen) {\n+        case 1:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0]));\n+                _hash[offset] = q[0];\n+                _hash[offset+3] = 1;\n+            }\n+            break;\n+        case 2:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n+                _hash[offset] = q[0];\n+                _hash[offset+1] = q[1];\n+                _hash[offset+3] = 2;\n+            }\n+            break;\n+        case 3:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n+                _hash[offset] = q[0];\n+                _hash[offset+1] = q[1];\n+                _hash[offset+2] = q[2];\n+                _hash[offset+3] = 3;\n+            }\n+            break;\n+        default:\n+            int hash = calcHash(q, qlen);\n+            offset = _findOffsetForAdd(hash);\n+            _hash[offset] = hash;\n+            _hash[offset+3] = qlen;\n+            _hash[offset+1] = _appendLongName(q, qlen);\n+        }\n+        // plus add the actual String\n+        _names[offset >> 2] = name;\n+\n+        // and finally; see if we really should rehash.\n+        ++_count;\n+\n+        // Yes if above 75%, or above 50% AND have spill-overs\n+        if (_count > (_hashSize >> 1)) { // over 50%\n+            if ((_spillOverEnd > _spilloverStart())\n+                    || (_count > (_hashSize - (_hashSize >> 2)))) {\n+                _needRehash = true;\n+            }\n+        }\n+        return name;\n+    }\n+\n+    private void _verifyRehashAndSharing()\n+    {\n+        if (_hashShared) {\n+            _hash = Arrays.copyOf(_hash, _hash.length);\n+            _names = Arrays.copyOf(_names, _names.length);\n+            _hashShared = false;\n+        }\n+        if (_needRehash) {\n+            throw new RuntimeException(\"Should resize: not yet implemented!\");\n+//            rehash();\n+        }\n+    }\n+    \n+    /**\n+     * Method called to find the location within hash table to add a new symbol in.\n+     */\n+    private int _findOffsetForAdd(int hash)\n+    {\n+        // first, check the primary:\n+        int offset = _calcOffset(hash);\n+        final int[] hashArea = _hash;\n+        if (hashArea[offset+3] == 0) {\n+            return offset;\n+        }\n+        // then secondary\n+        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        if (hashArea[offset2+3] == 0) {\n+            return offset;\n+        }\n+        // if not, tertiary?\n+\n+        offset2 = (_hashSize << 3) - _hashSize;\n+        offset2 += (offset >> 1); // so, 1.5x primary size\n+        offset2 += (offset >> 6) << 2; // and add 1/16th of orig index (but on 4 int boundary)\n+        \n+        if (hashArea[offset2+3] == 0) {\n+            return offset;\n+        }\n+        offset2 += 4;\n+        if (hashArea[offset2+3] == 0) {\n+            return offset;\n+        }\n+        offset2 += 4;\n+        if (hashArea[offset2+3] == 0) {\n+            return offset;\n+        }\n+        offset2 += 4;\n+        if (hashArea[offset2+3] == 0) {\n+            return offset;\n+        }\n+\n+        // and if even tertiary full, append at the end of spill area\n+        offset = _spillOverEnd;\n+        _spillOverEnd += 4;\n+        return offset;\n+    }\n+\n+    private int _appendLongName(int[] quads, int qlen)\n+    {\n+        int start = _longNameOffset;\n+        // note: at this point we must already be shared. But may not have enough space\n+        if ((start + qlen) > _hash.length) {\n+            // try to increment in reasonable chunks; at least space that we need\n+            int toAdd = (start + qlen) - _hash.length;\n+            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n+            int minAdd = Math.min(4096, _hashSize);\n+\n+            int newSize = _hash.length + Math.max(toAdd, minAdd);\n+            _hash = Arrays.copyOf(_hash, newSize);\n+        }\n+        System.arraycopy(quads, 0, _hash, start, qlen);\n+        _longNameOffset += qlen;\n+        return start;\n+    }\n+\n+    /**\n+     * Helper method that calculates start of the spillover area\n+     */\n+    private final int _spilloverStart() {\n+        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n+        // So basically multiply by 7\n+        int offset = _hashSize;\n+        return (offset << 3) - offset;\n     }\n     \n     /*\n         public final int count;\n         public final int[] mainHash;\n         public final String[] names;\n-        public final int collCount;\n-        public final int longestCollisionList;\n \n         public TableInfo(int size, int count, int[] mainHash, String[] names,\n                 int collCount, int longestCollisionList)\n             this.count = count;\n             this.mainHash = mainHash;\n             this.names = names;\n-            this.collCount = collCount;\n-            this.longestCollisionList = longestCollisionList;\n         }\n \n         public TableInfo(ByteQuadsCanonicalizer src)\n             count = src._count;\n             mainHash = src._hash;\n             names = src._names;\n-            collCount = src._collCount;\n-            longestCollisionList = src._longestCollisionList;\n         }\n \n         public static TableInfo createInitial(int sz) {\n             return new TableInfo(sz, // hashSize\n                     0, // count\n-                    new int[sz * 2], // mainHash\n+                    new int[sz * 8], // mainHash, 2x slots, 4 ints per slot\n                     new String[sz], // mainNames\n                     0, // collCount,\n                     0 // longestCollisionList", "timestamp": 1423117830, "metainfo": ""}