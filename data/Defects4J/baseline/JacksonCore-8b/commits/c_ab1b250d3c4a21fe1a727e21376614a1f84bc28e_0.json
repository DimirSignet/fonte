{"sha": "ab1b250d3c4a21fe1a727e21376614a1f84bc28e", "log": "Fixing #64, incomplete parsing error message", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         case VALUE_NUMBER_INT:\n         case VALUE_NUMBER_FLOAT:\n             return _textBuffer.contentsAsString();\n-        }\n-        return t.asString();\n+        default:\n+            return t.asString();\n+        }\n     }\n \n     @Override\n             case VALUE_NUMBER_INT:\n             case VALUE_NUMBER_FLOAT:\n                 return _textBuffer.getTextOffset();\n+            default:\n             }\n         }\n         return 0;\n             return Boolean.TRUE;\n         case VALUE_FALSE:\n             return Boolean.FALSE;\n-        }\n-        return null;\n+        default:\n+        \treturn null;\n+        }\n     }\n     \n     @Override\n         do {\n             if (_inputPtr >= _inputEnd) {\n                 if (!loadMore()) {\n-                    _reportInvalidEOFInValue();\n+                    _reportInvalidToken(matchStr.substring(0, i));\n                 }\n             }\n             if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n-                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+                _reportInvalidToken(matchStr.substring(0, i));\n             }\n             ++_inputPtr;\n         } while (++i < len);\n         }\n         // if Java letter, it's a problem tho\n         if (Character.isJavaIdentifierPart(c)) {\n-            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+            _reportInvalidToken(matchStr.substring(0, i));\n         }\n         return;\n     }\n     /**********************************************************\n      */\n \n+    protected void _reportInvalidToken(String matchedPart)\n+\t\t    throws IOException, JsonParseException {\n+    \t_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n+    }\n+    \n     protected void _reportInvalidToken(String matchedPart, String msg)\n         throws IOException, JsonParseException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         case VALUE_NUMBER_INT:\n         case VALUE_NUMBER_FLOAT:\n             return _textBuffer.contentsAsString();\n-        }\n-        return t.asString();\n+        default:\n+        \treturn t.asString();\n+        }\n     }\n \n     @Override\n             case VALUE_NUMBER_INT:\n             case VALUE_NUMBER_FLOAT:\n                 return _textBuffer.getTextOffset();\n+            default:\n             }\n         }\n         return 0;\n             return Boolean.TRUE;\n         case VALUE_FALSE:\n             return Boolean.FALSE;\n-        }\n-        return null;\n+        default:\n+        \treturn null;\n+        }\n     }\n     \n     /*\n         do {\n             if (_inputPtr >= _inputEnd) {\n                 if (!loadMore()) {\n-                    _reportInvalidEOF(\" in a value\");\n+                    _reportInvalidToken(matchStr.substring(0, i));\n                 }\n             }\n             if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n-                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+                _reportInvalidToken(matchStr.substring(0, i));\n             }\n             ++_inputPtr;\n         } while (++i < len);\n         // but actually only alphanums are problematic\n         char c = (char) _decodeCharForError(ch);\n         if (Character.isJavaIdentifierPart(c)) {\n-            ++_inputPtr;\n-            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n-        }\n+            _reportInvalidToken(matchStr.substring(0, i));\n+        }\n+    }\n+\n+    protected void _reportInvalidToken(String matchedPart)\n+            throws IOException, JsonParseException\n+    {\n+    \t_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n     \n     protected void _reportInvalidToken(String matchedPart, String msg)\n         throws IOException, JsonParseException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n+\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods, ws skipping, escape/unescape\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n         assertToken(JsonToken.END_OBJECT, jp.nextToken());\n     }\n \n-    public void testInvalidKeywords() throws Exception\n-    {\n+    public void testInvalidKeywordsStream() throws Exception {\n         _testInvalidKeywords(true);\n+    }\n+    \n+    public void testInvalidKeywordsReader() throws Exception {\n         _testInvalidKeywords(false);\n     }\n \n     private void _testInvalidKeywords(boolean useStream) throws Exception\n     {\n         doTestInvalidKeyword1(useStream, \"nul\");\n+        doTestInvalidKeyword1(useStream, \"Null\");\n         doTestInvalidKeyword1(useStream, \"nulla\");\n         doTestInvalidKeyword1(useStream, \"fal\");\n         doTestInvalidKeyword3(useStream, \"False\");\n+        doTestInvalidKeyword1(useStream, \"fals0\");\n         doTestInvalidKeyword1(useStream, \"falsett0\");\n         doTestInvalidKeyword1(useStream, \"tr\");\n         doTestInvalidKeyword1(useStream, \"truE\");\n+        doTestInvalidKeyword1(useStream, \"treu\");\n         doTestInvalidKeyword1(useStream, \"trueenough\");\n     }\n \n     {\n         final String doc = \"{ \\\"key1\\\" : \"+value+\" }\";\n         JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n-                : this.createParserUsingReader(doc);\n+                : createParserUsingReader(doc);\n         assertToken(JsonToken.START_OBJECT, jp.nextToken());\n         /* 24-Nov-2008, tatu: Note that depending on parser impl, we may\n          *   get the exception early or late...\n             fail(\"Expected an exception for malformed value keyword\");\n         } catch (JsonParseException jex) {\n             verifyException(jex, \"Unrecognized token\");\n+            verifyException(jex, value);\n+        } finally {\n+            jp.close();\n+        }\n+\n+        // Try as root-level value as well:\n+        jp = useStream ? createParserUsingStream(value, \"UTF-8\")\n+                : createParserUsingReader(value);\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected an exception for malformed value keyword\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"Unrecognized token\");\n+            verifyException(jex, value);\n         } finally {\n             jp.close();\n         }", "timestamp": 1362446300, "metainfo": ""}