{"sha": "1734a3ad83bc4429f17cbe9f885015947c20b98d", "log": "Implement #96", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n         return false;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Capability introspection\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method that can be called to determine if a custom\n      * {@link ObjectCodec} is needed for binding data parsed\n         return false;\n     }\n \n+    /**\n+     * Introspection method that higher-level functionality may call\n+     * to see whether underlying data format requires a stable ordering\n+     * of object properties or not.\n+     * This is usually used for determining\n+     * whether to force a stable ordering (like alphabetic ordering by name)\n+     * if no ordering if explicitly specified.\n+     *<p>\n+     * Default implementation returns <code>false</code> as JSON does NOT\n+     * require stable ordering. Formats that require ordering include positional\n+     * textual formats like <code>CSV</code>, and schema-based binary formats\n+     * like <code>Avro</code>.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean requiresPropertyOrdering() {\n+        return false;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Versioned\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     public boolean canUseSchema(FormatSchema schema) {\n         return delegate.canUseSchema(schema);\n     }\n+    \n+    @Override\n+    public Version version() {\n+        return delegate.version();\n+    }\n+\n+    @Override\n+    public Object getInputSource() {\n+        return delegate.getInputSource();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Capability introspection\n+    /**********************************************************\n+     */\n \n     @Override\n     public boolean requiresCustomCodec() {\n         return delegate.requiresCustomCodec();\n     }\n-    \n-    @Override\n-    public Version version() {\n-        return delegate.version();\n-    }\n-\n-    @Override\n-    public Object getInputSource() {\n-        return delegate.getInputSource();\n+\n+    @Override\n+    public boolean requiresPropertyOrdering() {\n+        return delegate.requiresPropertyOrdering();\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n          assertEquals(\"{\\\"long\\\":3,\\\"double\\\":0.25,\\\"float\\\":-0.25}\", sw.toString().trim());\n      }\n \n+    /**\n+     * Test to verify that output context actually contains useful information\n+     */\n+    public void testOutputContext() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+        JsonStreamContext ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inRoot());\n+\n+        gen.writeStartObject();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeFieldName(\"a\");\n+        assertEquals(\"a\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeStartArray();\n+        assertTrue(gen.getOutputContext().inArray());\n+\n+        gen.writeStartObject();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeFieldName(\"b\");\n+        ctxt = gen.getOutputContext();\n+        assertEquals(\"b\", ctxt.getCurrentName());\n+        gen.writeNumber(123);\n+        assertEquals(\"b\", ctxt.getCurrentName());\n+\n+        gen.writeFieldName(\"c\");\n+        assertEquals(\"c\", gen.getOutputContext().getCurrentName());\n+        gen.writeNumber(5);\n+//        assertEquals(\"c\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeFieldName(\"d\");\n+        assertEquals(\"d\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeStartArray();\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+        assertEquals(0, ctxt.getEntryCount());\n+\n+        gen.writeBoolean(true);\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        // NOTE: index still refers to currently output entry\n+        assertEquals(0, ctxt.getCurrentIndex());\n+        assertEquals(1, ctxt.getEntryCount());\n+\n+        gen.writeNumber(3);\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        assertEquals(1, ctxt.getCurrentIndex());\n+        assertEquals(2, ctxt.getEntryCount());\n+        \n+        gen.writeEndArray();\n+        assertTrue(gen.getOutputContext().inObject());\n+        \n+        gen.writeEndObject();\n+        assertTrue(gen.getOutputContext().inArray());\n+\n+        gen.writeEndArray();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeEndObject();\n+\n+        assertTrue(gen.getOutputContext().inRoot());\n+        \n+        gen.close();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods", "timestamp": 1377741980, "metainfo": ""}