{"sha": "c839ff8e92b088b611627db30dc6a3d4e075ed25", "log": "Merge branch '2.5'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n      * This variant is what most people would think of \"the standard\"\n      * Base64 encoding.\n      *<p>\n-     * See <a href=\"\">wikipedia Base64 entry</a> for details.\n+     * See <a href=\"http://en.wikipedia.org/wiki/Base64\">wikipedia Base64 entry</a> for details.\n      *<p>\n      * Note that although this can be thought of as the standard variant,\n      * it is <b>not</b> the default for Jackson: no-linefeeds alternative\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * Helper method, usually equivalent to:\n      *<code>\n      *   getOutputContext().getCurrentValue();\n-     *<code>\n+     *</code>\n      * \n      * @since 2.5\n      */\n      * Helper method, usually equivalent to:\n      *<code>\n      *   getOutputContext().setCurrentValue(v);\n-     *<code>\n+     *</code>\n      * \n      * @since 2.5\n      */\n      */\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      *\n+     * @param v Number value to write\n+     *\n      * @since 2.2\n      */\n     public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(int v) throws IOException;\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(long v) throws IOException;\n \n     /**\n-     * Method for outputting given value as Json number.\n+     * Method for outputting given value as JSON number.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n+     *\n+     * @param v Number value to write\n      */\n     public abstract void writeNumber(BigInteger v) throws IOException;\n \n     /**\n-     * Method for outputting indicate Json numeric value.\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(double d) throws IOException;\n-\n-    /**\n-     * Method for outputting indicate Json numeric value.\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(double v) throws IOException;\n+\n+    /**\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(float f) throws IOException;\n-\n-    /**\n-     * Method for outputting indicate Json numeric value.\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(float v) throws IOException;\n+\n+    /**\n+     * Method for outputting indicate JSON numeric value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n-     */\n-    public abstract void writeNumber(BigDecimal dec) throws IOException;\n+     *\n+     * @param v Number value to write\n+     */\n+    public abstract void writeNumber(BigDecimal v) throws IOException;\n \n     /**\n      * Write method that can be used for custom numeric types that can\n      *<p>\n      * Note: because of lack of type safety, some generator\n      * implementations may not be able to implement this\n-     * method. For example, if a binary json format is used,\n+     * method. For example, if a binary JSON format is used,\n      * it may require type information for encoding; similarly\n-     * for generator-wrappers around Java objects or Json nodes.\n+     * for generator-wrappers around Java objects or JSON nodes.\n      * If implementation does not implement this method,\n      * it needs to throw {@link UnsupportedOperationException}.\n      * \n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * Helper method, usually equivalent to:\n      *<code>\n      *   getParsingContext().getCurrentValue();\n-     *<code>\n+     *</code>\n      * \n      * @since 2.5\n      */\n      * Helper method, usually equivalent to:\n      *<code>\n      *   getParsingContext().setCurrentValue(v);\n-     *<code>\n+     *</code>\n      * \n      * @since 2.5\n      */\n      * and returns result of that comparison.\n      * It is functionally equivalent to:\n      *<pre>\n-     *  return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n+     *  return (nextToken() == JsonToken.FIELD_NAME) &amp;&amp; str.getValue().equals(getCurrentName());\n      *</pre>\n      * but may be faster for parser to verify, and can therefore be used if caller\n      * expects to get such a property name from input next.\n      * \n-     * @param str Property name to compare next token to (if next token is <code>JsonToken.FIELD_NAME<code>)\n+     * @param str Property name to compare next token to (if next token is\n+     *   <code>JsonToken.FIELD_NAME</code>)\n      */\n     public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n      * Method that is functionally equivalent to:\n      *<code>\n      *  return getCurrentTokenId() == id\n-     *<code>\n+     *</code>\n      * but may be more efficiently implemented.\n      *<p>\n      * Note that no traversal or conversion is performed; so in some\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n  * maps/sets, that hash codes are uniformly distributed. Also, collisions\n  * are slightly more expensive than with HashMap or HashSet, since hash codes\n  * are not used in resolving collisions; that is, equals() comparison is\n- * done with all symbols in same bucket index.<br />\n+ * done with all symbols in same bucket index.<br>\n  * Finally, rehashing is also more expensive, as hash codes are not\n  * stored; rehashing requires all entries' hash codes to be recalculated.\n  * Reason for not storing hash codes is reduced memory usage, hoping\n--- a/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n  * to ensure that a Type argument is indeed given.\n  *<p>\n  * Usage is by sub-classing: here is one way to instantiate reference\n- * to generic type <code>List&lt;Integer></code>:\n+ * to generic type <code>List&lt;Integer&gt;</code>:\n  *<pre>\n- *  TypeReference ref = new TypeReference&lt;List&lt;Integer>>() { };\n+ *  TypeReference ref = new TypeReference&lt;List&lt;Integer&gt;&gt;() { };\n  *</pre>\n  * which can be passed to methods that accept TypeReference, or resolved\n  * using <code>TypeFactory</code> to obtain {@link ResolvedType}.\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n     @Deprecated\n     public static class Lf2SpacesIndenter extends DefaultIndenter\n     {\n-        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead */\n+        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n+         */\n         @SuppressWarnings(\"hiding\")\n         @Deprecated\n         public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead */\n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n+         */\n         @Deprecated\n         public Lf2SpacesIndenter() {\n             super(\"  \", DefaultIndenter.SYS_LF);\n         }\n         \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead */\n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n+         */\n         @Deprecated\n         public Lf2SpacesIndenter(String lf) {\n             super(\"  \", lf);\n         }\n+\n+        /**\n+         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n+         * later 2.5.x versions.\n+         */\n+        @Override\n+        public Lf2SpacesIndenter withLinefeed(String lf) {\n+            if (lf.equals(getEol())) {\n+                return this;\n+            }\n+            return new Lf2SpacesIndenter(lf);\n+        }\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         _testDupFieldNameWrites(f, true);        \n     }\n \n+    // [core#177]\n+    // Also: should not try writing JSON String if field name expected\n+    // (in future maybe take one as alias... but not yet)\n+    /*\n+    public void testFailOnWritingStringNotFieldName() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testFailOnWritingStringNotFieldName(f, false);\n+        _testFailOnWritingStringNotFieldName(f, true);        \n+    }\n+    */\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n     private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n     {\n         JsonGenerator gen;\n             gen.writeFieldName(\"b\");\n             gen.flush();\n             String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n+            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"can not write a field name, expecting a value\");\n         }\n         gen.close();\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Internal methods\n-    /**********************************************************\n-     */\n-    \n-    private void doTestIntWrite(boolean pad)\n-        throws Exception\n+    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        \n+        try {\n+            gen.writeString(\"a\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let 'writeString()' be used in place of 'writeFieldName()': output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n+    private void doTestIntWrite(boolean pad) throws Exception\n     {\n         int[] VALUES = new int[] {\n             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,", "timestamp": 1420949729, "metainfo": ""}