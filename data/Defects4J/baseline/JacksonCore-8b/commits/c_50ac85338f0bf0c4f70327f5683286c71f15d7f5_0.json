{"sha": "50ac85338f0bf0c4f70327f5683286c71f15d7f5", "log": "Fixes to diagnostics, minor improvement to 2-quad hashing cache", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n     final static int MIN_HASH_SIZE = 16;\n     \n     /**\n-     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n-     * this corresponds to 64k main hash index. This should allow for enough distinct\n-     * names for almost any case.\n-     */\n-    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n+     * this corresponds to 256k main hash index. This should allow for enough distinct\n+     * names for almost any case, while preventing ballooning for cases where names\n+     * are unique (or close thereof).\n+     */\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n     /*\n     /**********************************************************\n         return (_spilloverEnd - _spilloverStart()) >> 2;\n     }\n \n+    public int totalCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        int pri = primaryCount();\n+        int sec = secondaryCount();\n+        int tert = tertiaryCount();\n+        int spill = spilloverCount();\n+        int total = totalCount();\n+        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n+                getClass().getName(), _count, _hashSize,\n+                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, accessing symbols\n                 _needRehash = true;\n             }\n         }\n+\n+        // !!! SANITY CHECK -- may uncomment for testing\n+        /*\n+        int pri = primaryCount();\n+        int sec = secondaryCount();\n+        int tert = tertiaryCount();\n+        int spill = spilloverCount();\n+        int sum = pri+sec+tert+spill;\n+\n+        if (sum != _count) {\n+            int total = totalCount();\n+            System.out.printf(\"Mismatch adding '%s' at %d (qlen %d)/%d: %d/%d/%d/%d=%d, total=%d, count=%d\\n\",\n+                    name, offset, qlen, _hashSize<<2,\n+                    pri, sec, tert, spill, sum, total, _count);\n+        }\n+        */\n+\n         return name;\n     }\n \n         _spilloverEnd += 4;\n \n         // one caveat: in the unlikely event if spill-over filling up,\n-        // force rehash for the add that follows\n+        // check if that could be considered a DoS attack; handle appropriately\n+        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n         if (_spilloverEnd >= hashArea.length) {\n+            if (_failOnDoS) {\n+                reportTooManyCollisions();\n+            }\n+            // and if we didn't fail, we'll simply force rehash for next add\n+            // (which, in turn, may double up or nuke contents, depending on size etc)\n             _needRehash = true;\n         }\n         return offset;\n         int offset = _hashSize;\n         return (offset << 3) - offset;\n     }\n+\n+    protected void reportTooManyCollisions()\n+    {\n+        // First: do not fuzz about small symbol tables\n+        if (_hashSize <= 512) { // would have spill-over area of 64 entries\n+            return;\n+        }\n+        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n+                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n+                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions\");\n+    }\n     \n     /*\n     /**********************************************************\n \n     public int calcHash(int q1, int q2)\n     {\n+        // For two quads, let's change algorithm a bit, to spice\n+        // things up (can do bit more processing anyway)\n         int hash = q1;\n-        hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n+\n+        hash += (hash >>> 15); // try mixing first and second byte pairs first\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n+        hash ^= (hash >>> 19);\n+        \n         return hash;\n     }\n \n \n     private void rehash()\n     {\n-        _needRehash = false;        \n+        _needRehash = false;\n         // Note: since we'll make copies, no need to unshare, can just mark as such:\n         _hashShared = false;\n \n         final int oldSize = _hashSize;\n         final int oldCount = _count;\n         final int newSize = oldSize + oldSize;\n+        final int oldEnd = _spilloverEnd;\n \n         /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n          *    large documents with unique (or mostly so) names\n         // double up main hash area, but do not expand long-name area:\n         _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n         _hashSize = newSize;\n+        _secondaryOffset = _hashSize << 2; // 4 ints per entry\n         \n         // and simply double up name array\n         _names = new String[oldNames.length << 1];\n \n         int copyCount = 0;\n         int[] q = new int[16];\n-        for (int offset = 0, end = oldSize<<3; offset < end; offset += 4) {\n+        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n             int len = oldHashArea[offset+3];\n             if (len == 0) { // empty slot, skip\n                 continue;\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      * this corresponds to 64k main hash index. This should allow for enough distinct\n      * names for almost any case.\n      */\n-    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n     /**\n      * Also: to thwart attacks based on hash collisions (which may or may not\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n+        hash ^= (hash >>> 19);\n         return hash;\n     }\n \n     /* Other helper methods\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @since 2.1\n      */\n         throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_count\n                 +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper classes\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n         jp0.close();\n     }\n \n-    public void testAuxMethods()\n-        throws Exception\n+    public void testAuxMethodsWithOldSymboTable() throws Exception\n     {\n         final int A_BYTES = 0x41414141; // \"AAAA\"\n         final int B_BYTES = 0x42424242; // \"BBBB\"\n         assertNotNull(nc.toString());\n     }\n \n+    public void testAuxMethodsWithNewSymboTable() throws Exception\n+    {\n+        final int A_BYTES = 0x41414141; // \"AAAA\"\n+        final int B_BYTES = 0x42424242; // \"BBBB\"\n+\n+        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot()\n+                .makeChild(JsonFactory.Feature.collectDefaults());\n+        assertNull(nc.findName(A_BYTES));\n+        assertNull(nc.findName(A_BYTES, B_BYTES));\n+\n+        nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n+        String n1 = nc.findName(A_BYTES);\n+        assertEquals(\"AAAA\", n1);\n+        nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n+        String n2 = nc.findName(A_BYTES, B_BYTES);\n+        assertEquals(\"AAAABBBB\", n2);\n+        assertNotNull(n2);\n+\n+        /* and let's then just exercise this method so it gets covered;\n+         * it's only used for debugging.\n+         */\n+        assertNotNull(nc.toString());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n //System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n     \n         // Fewer collisions than with chars, but still quite a few\n-        assertEquals(1686, symbols.collisionCount());\n+        assertEquals(1715, symbols.collisionCount());\n         // but not super long collision chains:\n         assertEquals(9, symbols.maxCollisionLength());\n \n     }\n \n     // [Issue#145]\n-    public void testThousandsOfSymbols() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n+    public void testThousandsOfSymbolsWithChars() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n         CharsToNameCanonicalizer symbolsCRoot = CharsToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n         \n         for (int doc = 0; doc < 100; ++doc) {\n             CharsToNameCanonicalizer symbolsC =\n                     symbolsCRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+                char[] ch = name.toCharArray();\n+                String str = symbolsC.findSymbol(ch, 0, ch.length,\n+                        symbolsC.calcHash(name));\n+                assertNotNull(str);\n+            }\n+            symbolsC.release();\n+            exp += 250;\n+            if (exp > CharsToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsCRoot.size());\n+        }\n+    }\n+    \n+    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+        \n+        for (int doc = 0; doc < 100; ++doc) {\n             BytesToNameCanonicalizer symbolsB =\n                     symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n             for (int i = 0; i < 250; ++i) {\n \n                 int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n                 symbolsB.addName(name, quads, quads.length);\n-\n-                char[] ch = name.toCharArray();\n-                String str = symbolsC.findSymbol(ch, 0, ch.length,\n-                        symbolsC.calcHash(name));\n-                assertNotNull(str);\n+                Name n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n.getName());\n             }\n             symbolsB.release();\n-            symbolsC.release();\n-        }\n-    }\n-\n+            exp += 250;\n+            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+    }\n+\n+    // Since 2.6\n+    public void testThousandsOfSymbolsWithNew() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+\n+        // loop to get \n+        for (int doc = 0; doc < 100; ++doc) {\n+            ByteQuadsCanonicalizer symbolsB =\n+                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+\n+                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n+                \n+                symbolsB.addName(name, quads, quads.length);\n+                String n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n);\n+            }\n+System.out.println(\"New symbols: \"+symbolsB);\n+            symbolsB.release();\n+            \n+            exp += 250;\n+            if (exp > ByteQuadsCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+    }\n+    \n     // And then one more test just for Bytes-based symbol table\n     public void testByteBasedSymbolTable() throws Exception\n     {", "timestamp": 1423183921, "metainfo": ""}