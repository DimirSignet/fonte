{"sha": "6209f812e69f00f4fbd49c82260142bf591d8091", "log": "@since markers Javadoc updates  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveEntry.java\n     /** True if the entry refers to a directory */\n     public boolean isDirectory();\n \n-    /** The last modified date of the entry */\n+    /**\n+     * The last modified date of the entry.\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     public Date getLastModifiedDate();\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * CpioConstants.FORMAT_NEW_CRC<br/>\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public CpioArchiveEntry(final short format, final String name) {\n         this(format);\n      * CpioConstants.FORMAT_NEW_CRC<br/>\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public CpioArchiveEntry(final short format, final String name,\n                             final long size) {\n      * CpioConstants.FORMAT_NEW_CRC<br/>\n      * CpioConstants.FORMAT_OLD_BINARY<br/>\n      * CpioConstants.FORMAT_OLD_ASCII<br/>\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public CpioArchiveEntry(final short format, File inputFile,\n                             String entryName) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      *            The format of the stream\n      * @param blockSize\n      *            The block size of the archive.\n+     *            \n+     * @since Apache Commons Compress 1.1\n      */\n     public CpioArchiveOutputStream(final OutputStream out, final short format,\n                                    final int blockSize) {\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n     /** The special trailer marker */\n     final String CPIO_TRAILER = \"TRAILER!!!\";\n \n-    /** The default block size */\n+    /**\n+     * The default block size.\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     final int BLOCK_SIZE = 512;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n         return getNextJarEntry();\n     }\n \n+    /**\n+     * Checks if the signature matches what is expected for a jar file\n+     * (in this case it is the same as for a zip file).\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a jar archive stream, false otherwise\n+     */\n     public static boolean matches(byte[] signature, int length ) {\n         return ZipArchiveInputStream.matches(signature, length);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      * @param name the entry name\n      * @param preserveLeadingSlashes whether to allow leading slashes\n      * in the name.\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n         this();\n \n     /**\n      * Set this entry's link name.\n+     * \n+     * @param link the link name to use.\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public void setLinkName(String link) {\n-        linkName = link;\n+        this.linkName = link;\n     }\n \n     /**\n      * Check if this is a Pax header.\n      * \n      * @return <code>true</code> if this is a Pax header.\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public boolean isPaxHeader(){\n         return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n      * Check if this is a Pax header.\n      * \n      * @return <code>true</code> if this is a Pax header.\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public boolean isGlobalPaxHeader(){\n         return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n         hasHitEOF = b;\n     }\n \n-    // ArchiveInputStream\n-\n+    /**\n+     * Checks if the signature matches what is expected for a tar file.\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a tar archive stream, false otherwise\n+     */\n     public static boolean matches(byte[] signature, int length) {\n         if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n \n     /**\n      * Identifies the entry as a Pax extended header.\n-     */\n-    byte LF_PAX_EXTENDED_HEADER_LC = (byte) 'x'; //\n-    byte LF_PAX_EXTENDED_HEADER_UC = (byte) 'X'; // SunOS tar -E\n+     * @since Apache Commons Compress 1.1\n+     */\n+    byte LF_PAX_EXTENDED_HEADER_LC = (byte) 'x';\n+\n+    /**\n+     * Identifies the entry as a Pax extended header (SunOS tar -E).\n+     *\n+     * @since Apache Commons Compress 1.1\n+     */\n+    byte LF_PAX_EXTENDED_HEADER_UC = (byte) 'X';\n     \n     /**\n      * Identifies the entry as a Pax global extended header.\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     byte LF_PAX_GLOBAL_EXTENDED_HEADER = (byte) 'g';\n     \n \n     /**\n      * The magic tag representing an Ant tar archive.\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     String MAGIC_ANT = \"ustar\\0\";\n+    \n+    /**\n+     * The \"version\" representing an Ant tar archive.\n+     *\n+     * @since Apache Commons Compress 1.1\n+     */\n     // Does not appear to have a version, however Ant does write 8 bytes,\n     // so assume the version is 2 nulls\n     String VERSION_ANT = \"\\0\\0\";\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n      * cannot be parsed.\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public static ZipExtraField[] parse(byte[] data, boolean local,\n                                         UnparseableExtraField onUnparseableData)\n     /**\n      * \"enum\" for the possible actions to take if the extra field\n      * cannot be parsed.\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public static final class UnparseableExtraField {\n         /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n  * {@link <a href=\"http://www.pkware.com/documents/casestudies/APPNOTE.TXT\">\n  * APPNOTE.TXT</a>}).  Since it isn't used anywhere except to satisfy the\n  * ZipExtraField contract it shouldn't matter anyway.</p>\n+ *\n+ * @since Apache Commons Compress 1.1\n  * @NotThreadSafe\n  */\n public final class UnparseableExtraFieldData implements ZipExtraField {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      * compression method has not been specified.\n      *\n      * @return compression method\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public int getMethod() {\n         return method;\n      * Sets the compression method of this entry.\n      *\n      * @param method compression method\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public void setMethod(int method) {\n         if (method < 0) {\n      * extra fields as {@link UnparseableExtraFieldData} if such data\n      * exists.\n      * @return an array of the extra fields\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n         if (extraFields == null) {\n \n     /**\n      * Removes unparseable extra field data.\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public void removeUnparseableExtraFieldData() {\n         if (unparseableExtra == null) {\n      * Looks up extra field data that couldn't be parsed correctly.\n      *\n      * @return null if no such field exists.\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n         return unparseableExtra;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         throw new IllegalArgumentException();\n     }\n \n-    /*\n-     *  This test assumes that the zip file does not have any additional leading content,\n-     *  which is something that is allowed by the specification (e.g. self-extracting zips)\n+    /**\n+     * Checks if the signature matches what is expected for a zip file.\n+     * Does not currently handle self-extracting zips which may have arbitrary\n+     * leading content.\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a zip archive stream, false otherwise\n      */\n     public static boolean matches(byte[] signature, int length) {\n         if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n      * Doesn't increment if the EOF has been hit (read == -1)\n      * \n      * @param read the number of bytes read\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     protected void count(int read) {\n         count((long) read);\n     /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n+     *\n+     * @since Apache Commons Compress 1.1\n      */\n     public long getBytesRead() {\n         return bytesRead;\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n \n     }\n \n+    /**\n+     * Checks if the signature matches what is expected for a bzip2 file.\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a bzip2 compressed stream, false otherwise\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     public static boolean matches(byte[] signature, int length) {\n \n         if (length < 3) {\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n         return read;\n     }\n \n-    /* (non-Javadoc)\n-     * @see java.io.InputStream#read(byte[])\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public int read(byte[] b) throws IOException {\n         int read = in.read(b);\n         return read;\n     }\n \n-    /* (non-Javadoc)\n-     * @see java.io.InputStream#read(byte[], int, int)\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @since Apache Commons Compress 1.1\n      */\n     public int read(byte[] b, int from, int length) throws IOException {\n         int read = in.read(b, from, length);\n         return read;\n     }\n \n+    /**\n+     * Checks if the signature matches what is expected for a gzip file.\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a gzipped compressed stream, false otherwise\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     public static boolean matches(byte[] signature, int length) {\n \n         if (length < 2) {\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n         out.write(b);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     public void write(byte[] b) throws IOException {\n         out.write(b);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @since Apache Commons Compress 1.1\n+     */\n     public void write(byte[] b, int from, int length) throws IOException {\n         out.write(b, from, length);\n     }", "timestamp": 1273513000, "metainfo": ""}