{"sha": "0e1d5a4385ec91ddc10900f8733f086513636609", "log": "COMPRESS-210 - handle zip extra field 0x5455 - Extended Timestamp  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n     static {\n         implementations = new ConcurrentHashMap<ZipShort, Class<?>>();\n         register(AsiExtraField.class);\n+        register(X5455_ExtendedTimestamp.class);\n         register(X7875_NewUnix.class);\n         register(JarMarker.class);\n         register(UnicodePathExtraField.class);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * <p>An extra field that stores additional file and directory timestamp data\n+ * for zip entries.   Each zip entry can include up to three timestamps\n+ * (modify, access, create*).  The timestamps are stored as 32 bit unsigned\n+ * integers representing seconds since UNIX epoch (Jan 1st, 1970, UTC).\n+ * This field improves on zip's default timestamp granularity, since it\n+ * allows one to store additional timestamps, and, in addition, the timestamps\n+ * are stored using per-second granularity (zip's default behaviour can only store\n+ * timestamps to the nearest <em>even</em> second).\n+ * <p/>\n+ * </p><p>\n+ * Unfortunately, 32 (unsigned) bits can only store dates up to the year 2106,\n+ * and so this extra field will eventually be obsolete.  Enjoy it while it lasts!\n+ * </p>\n+ * <ul>\n+ * <li><b>modifyTime:</b>\n+ * most recent time of file/directory modification\n+ * (or file/dir creation if the entry has not been\n+ * modified since it was created).\n+ * </li>\n+ * <li><b>accessTime:</b>\n+ * most recent time file/directory was opened\n+ * (e.g., read from disk).  Many people disable\n+ * their operating systems from updating this value\n+ * using the NOATIME mount option to optimize disk behaviour,\n+ * and thus it's not always reliable.  In those cases\n+ * it's always equal to modifyTime.\n+ * </li>\n+ * <li><b>*createTime:</b>\n+ * modern linux file systems (e.g., ext2 and newer)\n+ * do not appear to store a value like this, and so\n+ * it's usually omitted altogether in the zip extra\n+ * field.  Perhaps other unix systems track this.\n+ * </li></ul>\n+ * <p>\n+ * We're using the field definition given in Info-Zip's source archive:\n+ * zip-3.0.tar.gz/proginfo/extrafld.txt\n+ * </p>\n+ * <pre>\n+ * Value         Size        Description\n+ * -----         ----        -----------\n+ * 0x5455        Short       tag for this extra block type (\"UT\")\n+ * TSize         Short       total data size for this block\n+ * Flags         Byte        info bits\n+ * (ModTime)     Long        time of last modification (UTC/GMT)\n+ * (AcTime)      Long        time of last access (UTC/GMT)\n+ * (CrTime)      Long        time of original creation (UTC/GMT)\n+ *\n+ * Central-header version:\n+ *\n+ * Value         Size        Description\n+ * -----         ----        -----------\n+ * 0x5455        Short       tag for this extra block type (\"UT\")\n+ * TSize         Short       total data size for this block\n+ * Flags         Byte        info bits (refers to local header!)\n+ * (ModTime)     Long        time of last modification (UTC/GMT)\n+ * </pre>\n+ */\n+public class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x5455);\n+    private static final long serialVersionUID = 1L;\n+\n+    static final byte MODIFY_TIME_BIT = 1;\n+    static final byte ACCESS_TIME_BIT = 2;\n+    static final byte CREATE_TIME_BIT = 4;\n+\n+    // The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n+    // are ignored according to the current version of the spec (December 2012).\n+    private byte flags;\n+\n+    // Note: even if bit1 and bit2 are set, the Central data will still not contain\n+    // access/create fields:  only local data ever holds those!  This causes\n+    // some of our implementation to look a little odd, with seemingly spurious\n+    // != null and length checks.\n+    private boolean bit0_modifyTimePresent;\n+    private boolean bit1_accessTimePresent;\n+    private boolean bit2_createTimePresent;\n+\n+    private ZipLong modifyTime;\n+    private ZipLong accessTime;\n+    private ZipLong createTime;\n+\n+    /**\n+     * Constructor for X5455_ExtendedTimestamp.\n+     */\n+    public X5455_ExtendedTimestamp() {}\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return the value for the header id for this extrafield\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(1 +\n+                (bit0_modifyTimePresent ? 4 : 0) +\n+                (bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n+                (bit2_createTimePresent && createTime != null ? 4 : 0)\n+        );\n+    }\n+\n+    /**\n+     * Length of the extra field in the local file data - without\n+     * Header-ID or length specifier.\n+     * <p/>\n+     * For X5455 the central length is often smaller than the\n+     * local length, because central cannot contain access or create\n+     * timestamps.\n+     *\n+     * @return a <code>ZipShort</code> for the length of the data of this extra field\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return new ZipShort(1 +\n+                (bit0_modifyTimePresent ? 4 : 0)\n+        );\n+    }\n+\n+    /**\n+     * The actual data to put into local file data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return get the data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        byte[] data = new byte[getLocalFileDataLength().getValue()];\n+        int pos = 0;\n+        data[pos++] = 0;\n+        if (bit0_modifyTimePresent) {\n+            data[0] |= MODIFY_TIME_BIT;\n+            System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\n+            pos += 4;\n+        }\n+        if (bit1_accessTimePresent && accessTime != null) {\n+            data[0] |= ACCESS_TIME_BIT;\n+            System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\n+            pos += 4;\n+        }\n+        if (bit2_createTimePresent && createTime != null) {\n+            data[0] |= CREATE_TIME_BIT;\n+            System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\n+            pos += 4;\n+        }\n+        return data;\n+    }\n+\n+    /**\n+     * The actual data to put into central directory data - without Header-ID\n+     * or length specifier.\n+     *\n+     * @return the central directory data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n+        byte[] localData = getLocalFileDataData();\n+\n+        // Truncate out create & access time (last 8 bytes) from\n+        // the copy of the local data we obtained:\n+        System.arraycopy(localData, 0, centralData, 0, centralData.length);\n+        return centralData;\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param data   an array of bytes\n+     * @param offset the start offset\n+     * @param length the number of bytes in the array from offset\n+     * @throws java.util.zip.ZipException on error\n+     */\n+    public void parseFromLocalFileData(\n+            byte[] data, int offset, int length\n+    ) throws ZipException {\n+        reset();\n+        final int len = offset + length;\n+        setFlags(data[offset++]);\n+        if (bit0_modifyTimePresent) {\n+            modifyTime = new ZipLong(data, offset);\n+            offset += 4;\n+        }\n+\n+        // Notice the extra length check in case we are parsing the shorter\n+        // central data field (for both access and create timestamps).\n+        if (bit1_accessTimePresent && offset + 4 <= len) {\n+            accessTime = new ZipLong(data, offset);\n+            offset += 4;\n+        }\n+        if (bit2_createTimePresent && offset + 4 <= len) {\n+            createTime = new ZipLong(data, offset);\n+            offset += 4;\n+        }\n+    }\n+\n+    /**\n+     * Doesn't do anything special since this class always uses the\n+     * same parsing logic for both central directory and local file data.\n+     */\n+    public void parseFromCentralDirectoryData(\n+            byte[] buffer, int offset, int length\n+    ) throws ZipException {\n+        reset();\n+        parseFromLocalFileData(buffer, offset, length);\n+    }\n+\n+    /**\n+     * Reset state back to newly constructed state.  Helps us make sure\n+     * parse() calls always generate clean results.\n+     */\n+    private void reset() {\n+        setFlags((byte) 0);\n+        this.modifyTime = null;\n+        this.accessTime = null;\n+        this.createTime = null;\n+    }\n+\n+    /**\n+     * Sets flags byte.  The flags byte tells us which of the\n+     * three datestamp fields are present in the data:\n+     * <pre>\n+     * bit0 - modify time\n+     * bit1 - access time\n+     * bit2 - create time\n+     * </pre>\n+     * Only first 3 bits of flags are used according to the\n+     * latest version of the spec (December 2012).\n+     *\n+     * @param flags flags byte indicating which of the\n+     *              three datestamp fields are present.\n+     */\n+    public void setFlags(byte flags) {\n+        this.flags = flags;\n+        this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n+        this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n+        this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n+    }\n+\n+    /**\n+     * Gets flags byte.  The flags byte tells us which of the\n+     * three datestamp fields are present in the data:\n+     * <pre>\n+     * bit0 - modify time\n+     * bit1 - access time\n+     * bit2 - create time\n+     * </pre>\n+     * Only first 3 bits of flags are used according to the\n+     * latest version of the spec (December 2012).\n+     *\n+     * @return flags byte indicating which of the\n+     *         three datestamp fields are present.\n+     */\n+    public byte getFlags() { return flags; }\n+\n+    /**\n+     * Returns whether bit0 of the flags byte is set or not,\n+     * which should correspond to the presence or absence of\n+     * a modify timestamp in this particular zip entry.\n+     *\n+     * @return true if bit0 of the flags byte is set.\n+     */\n+    public boolean isBit0_modifyTimePresent() { return bit0_modifyTimePresent; }\n+\n+    /**\n+     * Returns whether bit1 of the flags byte is set or not,\n+     * which should correspond to the presence or absence of\n+     * a \"last access\" timestamp in this particular zip entry.\n+     *\n+     * @return true if bit1 of the flags byte is set.\n+     */\n+    public boolean isBit1_accessTimePresent() { return bit1_accessTimePresent; }\n+\n+    /**\n+     * Returns whether bit2 of the flags byte is set or not,\n+     * which should correspond to the presence or absence of\n+     * a create timestamp in this particular zip entry.\n+     *\n+     * @return true if bit2 of the flags byte is set.\n+     */\n+    public boolean isBit2_createTimePresent() { return bit2_createTimePresent; }\n+\n+    /**\n+     * Returns the modify time (seconds since epoch) of this zip entry\n+     * as a ZipLong object, or null if no such timestamp exists in the\n+     * zip entry.\n+     *\n+     * @return modify time (seconds since epoch) or null.\n+     */\n+    public ZipLong getModifyTime() { return modifyTime; }\n+\n+    /**\n+     * Returns the access time (seconds since epoch) of this zip entry\n+     * as a ZipLong object, or null if no such timestamp exists in the\n+     * zip entry.\n+     *\n+     * @return access time (seconds since epoch) or null.\n+     */\n+    public ZipLong getAccessTime() { return accessTime; }\n+\n+    /**\n+     * <p>\n+     * Returns the create time (seconds since epoch) of this zip entry\n+     * as a ZipLong object, or null if no such timestamp exists in the\n+     * zip entry.\n+     * </p><p>\n+     * Note: modern linux file systems (e.g., ext2)\n+     * do not appear to store a \"create time\" value, and so\n+     * it's usually omitted altogether in the zip extra\n+     * field.  Perhaps other unix systems track this.\n+     *\n+     * @return create time (seconds since epoch) or null.\n+     */\n+    public ZipLong getCreateTime() { return createTime; }\n+\n+    /**\n+     * Returns the modify time as a java.util.Date\n+     * of this zip entry, or null if no such timestamp exists in the zip entry.\n+     * The milliseconds are always zeroed out, since the underlying data\n+     * offers only per-second precision.\n+     *\n+     * @return modify time as java.util.Date or null.\n+     */\n+    public Date getModifyJavaTime() {\n+        return modifyTime != null ? new Date(modifyTime.getValue() * 1000) : null;\n+    }\n+\n+    /**\n+     * Returns the access time as a java.util.Date\n+     * of this zip entry, or null if no such timestamp exists in the zip entry.\n+     * The milliseconds are always zeroed out, since the underlying data\n+     * offers only per-second precision.\n+     *\n+     * @return access time as java.util.Date or null.\n+     */\n+    public Date getAccessJavaTime() {\n+        return accessTime != null ? new Date(accessTime.getValue() * 1000) : null;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the create time as a a java.util.Date\n+     * of this zip entry, or null if no such timestamp exists in the zip entry.\n+     * The milliseconds are always zeroed out, since the underlying data\n+     * offers only per-second precision.\n+     * </p><p>\n+     * Note: modern linux file systems (e.g., ext2)\n+     * do not appear to store a \"create time\" value, and so\n+     * it's usually omitted altogether in the zip extra\n+     * field.  Perhaps other unix systems track this.\n+     *\n+     * @return create time as java.util.Date or null.\n+     */\n+    public Date getCreateJavaTime() {\n+        return createTime != null ? new Date(createTime.getValue() * 1000) : null;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the modify time (seconds since epoch) of this zip entry\n+     * using a ZipLong object.\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param l ZipLong of the modify time (seconds per epoch)\n+     */\n+    public void setModifyTime(ZipLong l) { this.modifyTime = l; }\n+\n+    /**\n+     * <p>\n+     * Sets the access time (seconds since epoch) of this zip entry\n+     * using a ZipLong object\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param l ZipLong of the access time (seconds per epoch)\n+     */\n+    public void setAccessTime(ZipLong l) { this.accessTime = l; }\n+\n+    /**\n+     * <p>\n+     * Sets the create time (seconds since epoch) of this zip entry\n+     * using a ZipLong object\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param l ZipLong of the create time (seconds per epoch)\n+     */\n+    public void setCreateTime(ZipLong l) { this.createTime = l; }\n+\n+    /**\n+     * <p>\n+     * Sets the modify time as a java.util.Date\n+     * of this zip entry.  Supplied value is truncated to per-second\n+     * precision (milliseconds zeroed-out).\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param d modify time as java.util.Date\n+     */\n+    public void setModifyJavaTime(Date d) { setModifyTime(dateToZipLong(d)); }\n+\n+    /**\n+     * <p>\n+     * Sets the access time as a java.util.Date\n+     * of this zip entry.  Supplied value is truncated to per-second\n+     * precision (milliseconds zeroed-out).\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param d access time as java.util.Date\n+     */\n+    public void setAccessJavaTime(Date d) { setAccessTime(dateToZipLong(d)); }\n+\n+    /**\n+     * <p>\n+     * Sets the create time as a java.util.Date\n+     * of this zip entry.  Supplied value is truncated to per-second\n+     * precision (milliseconds zeroed-out).\n+     * </p><p>\n+     * Note: the setters for flags and timestamps are decoupled.\n+     * Even if the timestamp is not-null, it will only be written\n+     * out if the corresponding bit in the flags is also set.\n+     * </p>\n+     *\n+     * @param d create time as java.util.Date\n+     */\n+    public void setCreateJavaTime(Date d) { setCreateTime(dateToZipLong(d)); }\n+\n+    /**\n+     * Utility method converts java.util.Date (milliseconds since epoch)\n+     * into a ZipLong (seconds since epoch).\n+     * <p/>\n+     * Also makes sure the converted ZipLong is not too big to fit\n+     * in 32 unsigned bits.\n+     *\n+     * @param d java.util.Date to convert to ZipLong\n+     * @return ZipLong\n+     */\n+    private static ZipLong dateToZipLong(final Date d) {\n+        if (d == null) { return null; }\n+\n+        final long TWO_TO_32 = 0x100000000L;\n+        final long l = d.getTime() / 1000;\n+        if (l >= TWO_TO_32) {\n+            throw new IllegalArgumentException(\"Cannot set an X5455 timestamp larger than 2^32: \" + l);\n+        }\n+        return new ZipLong(l);\n+    }\n+\n+    /**\n+     * Returns a String representation of this class useful for\n+     * debugging purposes.\n+     *\n+     * @return A String representation of this class useful for\n+     *         debugging purposes.\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuilder buf = new StringBuilder();\n+        buf.append(\"0x5455 Zip Extra Field: Flags=\");\n+        buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\n+        if (bit0_modifyTimePresent && modifyTime != null) {\n+            Date m = getModifyJavaTime();\n+            buf.append(\" Modify:[\").append(m).append(\"] \");\n+        }\n+        if (bit1_accessTimePresent && accessTime != null) {\n+            Date a = getAccessJavaTime();\n+            buf.append(\" Access:[\").append(a).append(\"] \");\n+        }\n+        if (bit2_createTimePresent && createTime != null) {\n+            Date c = getCreateJavaTime();\n+            buf.append(\" Create:[\").append(c).append(\"] \");\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o instanceof X5455_ExtendedTimestamp) {\n+            X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n+\n+            // The ZipLong==ZipLong clauses handle the cases where both are null.\n+            // and only last 3 bits of flags matter.\n+            return ((flags & 0x07) == (xf.flags & 0x07)) &&\n+                    (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n+                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n+                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hc = (-123 * (flags & 0x07)); // only last 3 bits of flags matter\n+        if (modifyTime != null) {\n+            hc ^= modifyTime.hashCode();\n+        }\n+        if (accessTime != null) {\n+            // Since accessTime is often same as modifyTime,\n+            // this prevents them from XOR negating each other.\n+            hc ^= Integer.rotateLeft(accessTime.hashCode(), 11);\n+        }\n+        if (createTime != null) {\n+            hc ^= Integer.rotateLeft(createTime.hashCode(), 22);\n+        }\n+        return hc;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestampTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.net.URL;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.TimeZone;\n+import java.util.zip.ZipException;\n+\n+import static org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp.ACCESS_TIME_BIT;\n+import static org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp.CREATE_TIME_BIT;\n+import static org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp.MODIFY_TIME_BIT;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public class X5455_ExtendedTimestampTest {\n+    private final static ZipShort X5455 = new ZipShort(0x5455);\n+\n+    private final static ZipLong ZERO_TIME = new ZipLong(0);\n+    private final static ZipLong MAX_TIME_SECONDS = new ZipLong(0xFFFFFFFFL);\n+    private final static SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"YYYY-MM-dd/HH:mm:ss Z\");\n+\n+    static {\n+        DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    }\n+\n+\n+    /**\n+     * The extended field (xf) we are testing.\n+     */\n+    private X5455_ExtendedTimestamp xf;\n+\n+    @Before\n+    public void before() {\n+        xf = new X5455_ExtendedTimestamp();\n+    }\n+\n+    @Test\n+    public void testSampleFile() throws Exception {\n+\n+        /*\n+        Contains entries with zipTime, accessTime, and modifyTime.\n+        The file name tells you the year we tried to set the time to\n+        (Jan 1st, Midnight, UTC).\n+\n+        For example:\n+\n+        COMPRESS-210_unix_time_zip_test/1999\n+        COMPRESS-210_unix_time_zip_test/2000\n+        COMPRESS-210_unix_time_zip_test/2108\n+\n+        File's last-modified is 1st second after midnight.\n+        Zip-time's 2-second granularity rounds that up to 2nd second.\n+        File's last-access is 3rd second after midnight.\n+\n+        So, from example above:\n+\n+        1999's zip time:  Jan 1st, 1999-01-01/00:00:02\n+        1999's mod time:  Jan 1st, 1999-01-01/00:00:01\n+        1999's acc time:  Jan 1st, 1999-01-01/00:00:03\n+         */\n+\n+        URL zip = getClass().getResource(\"/COMPRESS-210_unix_time_zip_test.zip\");\n+        File archive = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+\n+        try {\n+            zf = new ZipFile(archive);\n+            Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+\n+            // We expect EVERY entry of this zip file\n+            // to contain extra field 0x5455.\n+            while (en.hasMoreElements()) {\n+\n+                ZipArchiveEntry zae = en.nextElement();\n+                String name = zae.getName();\n+                X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) zae.getExtraField(X5455);\n+\n+                Date z = zae.getLastModifiedDate();\n+                Date m = xf.getModifyJavaTime();\n+                Date a = xf.getAccessJavaTime();\n+\n+                String zipTime = DATE_FORMAT.format(z);\n+                String modTime = DATE_FORMAT.format(m);\n+                String accTime = DATE_FORMAT.format(a);\n+\n+                if (!zae.isDirectory()) {\n+                    int x = name.lastIndexOf('/');\n+                    String yearString = name.substring(x + 1);\n+                    int year;\n+                    try {\n+                        year = Integer.parseInt(yearString);\n+                    } catch (NumberFormatException nfe) {\n+                        year = -1;\n+                    }\n+                    if (year >= 0) {\n+                        switch (year) {\n+                            case 2107:\n+                                // Zip time is okay up to 2107.\n+                                assertEquals(zipTime, year + \"-01-01/00:00:02 +0000\");\n+                                // But the X5455 data has overflowed:\n+                                assertEquals(modTime, \"1970-11-24/17:31:45 +0000\");\n+                                assertEquals(accTime, \"1970-11-24/17:31:47 +0000\");\n+                                break;\n+                            case 2108:\n+                                // Zip time is still okay at Jan 1st midnight (UTC) in 2108\n+                                // because we created the zip file in pacific time zone, so it's\n+                                // actually still 2107 in the zip file!\n+                                assertEquals(zipTime, year + \"-01-01/00:00:02 +0000\");\n+                                // The X5455 data is still overflowed, of course:\n+                                assertEquals(modTime, \"1971-11-24/17:31:45 +0000\");\n+                                assertEquals(accTime, \"1971-11-24/17:31:47 +0000\");\n+                                break;\n+                            case 2109:\n+                                // All three timestamps have overflowed by 2109.\n+                                assertEquals(zipTime, \"1981-01-01/00:00:02 +0000\");\n+                                assertEquals(modTime, \"1972-11-24/17:31:45 +0000\");\n+                                assertEquals(accTime, \"1972-11-24/17:31:47 +0000\");\n+\n+                                // Hmmm.... looks like one could examine both DOS time\n+                                // and the Unix time together to hack a nice workaround to\n+                                // get timestamps past 2106 in a reverse-compatible way.\n+\n+                                break;\n+                            default:\n+                                // X5455 time is good from epoch (1970) to 2106.\n+                                // Zip time is good from 1980 to 2107.\n+                                if (year < 1980) {\n+                                    assertEquals(zipTime, \"1980-01-01/08:00:00 +0000\");\n+                                } else {\n+                                    assertEquals(zipTime, year + \"-01-01/00:00:02 +0000\");\n+                                }\n+                                assertEquals(modTime, year + \"-01-01/00:00:01 +0000\");\n+                                assertEquals(accTime, year + \"-01-01/00:00:03 +0000\");\n+                                break;\n+                        }\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (zf != null) {\n+                zf.close();\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMisc() throws Exception {\n+        assertFalse(xf.equals(new Object()));\n+        assertTrue(xf.toString().startsWith(\"0x5455 Zip Extra Field\"));\n+        assertTrue(!xf.toString().contains(\" Modify:\"));\n+        assertTrue(!xf.toString().contains(\" Access:\"));\n+        assertTrue(!xf.toString().contains(\" Create:\"));\n+        Object o = xf.clone();\n+        assertEquals(o.hashCode(), xf.hashCode());\n+        assertTrue(xf.equals(o));\n+\n+        xf.setModifyJavaTime(new Date(1111));\n+        xf.setAccessJavaTime(new Date(2222));\n+        xf.setCreateJavaTime(new Date(3333));\n+        xf.setFlags((byte) 7);\n+        assertFalse(xf.equals(o));\n+        assertTrue(xf.toString().startsWith(\"0x5455 Zip Extra Field\"));\n+        assertTrue(xf.toString().contains(\" Modify:\"));\n+        assertTrue(xf.toString().contains(\" Access:\"));\n+        assertTrue(xf.toString().contains(\" Create:\"));\n+        o = xf.clone();\n+        assertEquals(o.hashCode(), xf.hashCode());\n+        assertTrue(xf.equals(o));\n+    }\n+\n+    @Test\n+    public void testGettersSetters() {\n+        // X5455 is concerned with time, so let's\n+        // get a timestamp to play with (Jan 1st, 2000).\n+        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        cal.set(Calendar.YEAR, 2000);\n+        cal.set(Calendar.MONTH, Calendar.JANUARY);\n+        cal.set(Calendar.DATE, 1);\n+        cal.set(Calendar.HOUR_OF_DAY, 0);\n+        cal.set(Calendar.MINUTE, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        Date timeMillis = cal.getTime();\n+        ZipLong time = new ZipLong(timeMillis.getTime() / 1000);\n+\n+        // set too big\n+        try {\n+            // Java time is 1000 x larger (milliseconds).\n+            xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n+            fail(\"Time too big for 32 bits!\");\n+        } catch (IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+\n+        // get/set modify time\n+        xf.setModifyTime(time);\n+        assertEquals(time, xf.getModifyTime());\n+        assertEquals(timeMillis, xf.getModifyJavaTime());\n+        xf.setModifyJavaTime(timeMillis);\n+        assertEquals(time, xf.getModifyTime());\n+        assertEquals(timeMillis, xf.getModifyJavaTime());\n+        // Make sure milliseconds get zeroed out:\n+        xf.setModifyJavaTime(new Date(timeMillis.getTime() + 123));\n+        assertEquals(time, xf.getModifyTime());\n+        assertEquals(timeMillis, xf.getModifyJavaTime());\n+        // Null\n+        xf.setModifyTime(null);\n+        assertNull(xf.getModifyJavaTime());\n+        xf.setModifyJavaTime(null);\n+        assertNull(xf.getModifyTime());\n+\n+        // get/set access time\n+        xf.setAccessTime(time);\n+        assertEquals(time, xf.getAccessTime());\n+        assertEquals(timeMillis, xf.getAccessJavaTime());\n+        xf.setAccessJavaTime(timeMillis);\n+        assertEquals(time, xf.getAccessTime());\n+        assertEquals(timeMillis, xf.getAccessJavaTime());\n+        // Make sure milliseconds get zeroed out:\n+        xf.setAccessJavaTime(new Date(timeMillis.getTime() + 123));\n+        assertEquals(time, xf.getAccessTime());\n+        assertEquals(timeMillis, xf.getAccessJavaTime());\n+        // Null\n+        xf.setAccessTime(null);\n+        assertNull(xf.getAccessJavaTime());\n+        xf.setAccessJavaTime(null);\n+        assertNull(xf.getAccessTime());\n+\n+        // get/set create time\n+        xf.setCreateTime(time);\n+        assertEquals(time, xf.getCreateTime());\n+        assertEquals(timeMillis, xf.getCreateJavaTime());\n+        xf.setCreateJavaTime(timeMillis);\n+        assertEquals(time, xf.getCreateTime());\n+        assertEquals(timeMillis, xf.getCreateJavaTime());\n+        // Make sure milliseconds get zeroed out:\n+        xf.setCreateJavaTime(new Date(timeMillis.getTime() + 123));\n+        assertEquals(time, xf.getCreateTime());\n+        assertEquals(timeMillis, xf.getCreateJavaTime());\n+        // Null\n+        xf.setCreateTime(null);\n+        assertNull(xf.getCreateJavaTime());\n+        xf.setCreateJavaTime(null);\n+        assertNull(xf.getCreateTime());\n+\n+\n+        // initialize for flags\n+        xf.setModifyTime(time);\n+        xf.setAccessTime(time);\n+        xf.setCreateTime(time);\n+\n+        // get/set flags: 000\n+        xf.setFlags((byte) 0);\n+        assertEquals(0, xf.getFlags());\n+        assertFalse(xf.isBit0_modifyTimePresent());\n+        assertFalse(xf.isBit1_accessTimePresent());\n+        assertFalse(xf.isBit2_createTimePresent());\n+        // Local length=1, Central length=1 (flags only!)\n+        assertEquals(1, xf.getLocalFileDataLength().getValue());\n+        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n+\n+        // get/set flags: 001\n+        xf.setFlags((byte) 1);\n+        assertEquals(1, xf.getFlags());\n+        assertTrue(xf.isBit0_modifyTimePresent());\n+        assertFalse(xf.isBit1_accessTimePresent());\n+        assertFalse(xf.isBit2_createTimePresent());\n+        // Local length=5, Central length=5 (flags + mod)\n+        assertEquals(5, xf.getLocalFileDataLength().getValue());\n+        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n+\n+        // get/set flags: 010\n+        xf.setFlags((byte) 2);\n+        assertEquals(2, xf.getFlags());\n+        assertFalse(xf.isBit0_modifyTimePresent());\n+        assertTrue(xf.isBit1_accessTimePresent());\n+        assertFalse(xf.isBit2_createTimePresent());\n+        // Local length=5, Central length=1\n+        assertEquals(5, xf.getLocalFileDataLength().getValue());\n+        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n+\n+        // get/set flags: 100\n+        xf.setFlags((byte) 4);\n+        assertEquals(4, xf.getFlags());\n+        assertFalse(xf.isBit0_modifyTimePresent());\n+        assertFalse(xf.isBit1_accessTimePresent());\n+        assertTrue(xf.isBit2_createTimePresent());\n+        // Local length=5, Central length=1\n+        assertEquals(5, xf.getLocalFileDataLength().getValue());\n+        assertEquals(1, xf.getCentralDirectoryLength().getValue());\n+\n+        // get/set flags: 111\n+        xf.setFlags((byte) 7);\n+        assertEquals(7, xf.getFlags());\n+        assertTrue(xf.isBit0_modifyTimePresent());\n+        assertTrue(xf.isBit1_accessTimePresent());\n+        assertTrue(xf.isBit2_createTimePresent());\n+        // Local length=13, Central length=5\n+        assertEquals(13, xf.getLocalFileDataLength().getValue());\n+        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n+\n+        // get/set flags: 11111111\n+        xf.setFlags((byte) -1);\n+        assertEquals(-1, xf.getFlags());\n+        assertTrue(xf.isBit0_modifyTimePresent());\n+        assertTrue(xf.isBit1_accessTimePresent());\n+        assertTrue(xf.isBit2_createTimePresent());\n+        // Local length=13, Central length=5\n+        assertEquals(13, xf.getLocalFileDataLength().getValue());\n+        assertEquals(5, xf.getCentralDirectoryLength().getValue());\n+    }\n+\n+    @Test\n+    public void testGetHeaderId() {\n+        assertEquals(X5455, xf.getHeaderId());\n+    }\n+\n+    @Test\n+    public void testParseReparse() throws ZipException {\n+        /*\n+         * Recall the spec:\n+         *\n+         * 0x5455        Short       tag for this extra block type (\"UT\")\n+         * TSize         Short       total data size for this block\n+         * Flags         Byte        info bits\n+         * (ModTime)     Long        time of last modification (UTC/GMT)\n+         * (AcTime)      Long        time of last access (UTC/GMT)\n+         * (CrTime)      Long        time of original creation (UTC/GMT)\n+         */\n+        final byte[] NULL_FLAGS = {0};\n+        final byte[] AC_CENTRAL = {2}; // central data only contains the AC flag and no actual data\n+        final byte[] CR_CENTRAL = {4}; // central data only dontains the CR flag and no actual data\n+\n+        final byte[] MOD_ZERO = {1, 0, 0, 0, 0};\n+        final byte[] MOD_MAX = {1, -1, -1, -1, -1};\n+        final byte[] AC_ZERO = {2, 0, 0, 0, 0};\n+        final byte[] AC_MAX = {2, -1, -1, -1, -1};\n+        final byte[] CR_ZERO = {4, 0, 0, 0, 0};\n+        final byte[] CR_MAX = {4, -1, -1, -1, -1};\n+        final byte[] MOD_AC_ZERO = {3, 0, 0, 0, 0, 0, 0, 0, 0};\n+        final byte[] MOD_AC_MAX = {3, -1, -1, -1, -1, -1, -1, -1, -1};\n+        final byte[] MOD_AC_CR_ZERO = {7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+        final byte[] MOD_AC_CR_MAX = {7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n+\n+        parseReparse(null, NULL_FLAGS, NULL_FLAGS);\n+        parseReparse(ZERO_TIME, MOD_ZERO, MOD_ZERO);\n+        parseReparse(MAX_TIME_SECONDS, MOD_MAX, MOD_MAX);\n+        parseReparse(ZERO_TIME, AC_ZERO, AC_CENTRAL);\n+        parseReparse(MAX_TIME_SECONDS, AC_MAX, AC_CENTRAL);\n+        parseReparse(ZERO_TIME, CR_ZERO, CR_CENTRAL);\n+        parseReparse(MAX_TIME_SECONDS, CR_MAX, CR_CENTRAL);\n+        parseReparse(ZERO_TIME, MOD_AC_ZERO, MOD_ZERO);\n+        parseReparse(MAX_TIME_SECONDS, MOD_AC_MAX, MOD_MAX);\n+        parseReparse(ZERO_TIME, MOD_AC_CR_ZERO, MOD_ZERO);\n+        parseReparse(MAX_TIME_SECONDS, MOD_AC_CR_MAX, MOD_MAX);\n+\n+        // As far as the spec is concerned (December 2012) all of these flags\n+        // are spurious versions of 7 (a.k.a. binary 00000111).\n+        parseReparse((byte) 15, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+        parseReparse((byte) 31, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+        parseReparse((byte) 63, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+        parseReparse((byte) 71, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+        parseReparse((byte) 127, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+        parseReparse((byte) -1, MAX_TIME_SECONDS, (byte) 7, MOD_AC_CR_MAX, MOD_MAX);\n+    }\n+\n+    private void parseReparse(\n+            final ZipLong time,\n+            final byte[] expectedLocal,\n+            final byte[] almostExpectedCentral\n+    ) throws ZipException {\n+        parseReparse(null, time, null, expectedLocal, almostExpectedCentral);\n+    }\n+\n+    private void parseReparse(\n+            final Byte providedFlagsByte,\n+            final ZipLong time,\n+            final Byte expectedFlagsByte,\n+            final byte[] expectedLocal,\n+            final byte[] almostExpectedCentral\n+    ) throws ZipException {\n+        final byte providedFlags = providedFlagsByte == null ? expectedLocal[0] : providedFlagsByte;\n+        final byte expectedFlags = expectedFlagsByte == null ? expectedLocal[0] : expectedFlagsByte;\n+\n+        // We're responsible for expectedCentral's flags.  Too annoying to set in caller.\n+        final byte[] expectedCentral = new byte[almostExpectedCentral.length];\n+        System.arraycopy(almostExpectedCentral, 0, expectedCentral, 0, almostExpectedCentral.length);\n+        expectedCentral[0] = expectedFlags;\n+\n+        xf.setFlags(providedFlags);\n+        xf.setModifyTime(time);\n+        xf.setAccessTime(time);\n+        xf.setCreateTime(time);\n+        byte[] result = xf.getLocalFileDataData();\n+        assertTrue(Arrays.equals(expectedLocal, result));\n+\n+        // And now we re-parse:\n+        xf.parseFromLocalFileData(result, 0, result.length);\n+        assertEquals(expectedFlags, xf.getFlags());\n+        if (isFlagSet(expectedFlags, MODIFY_TIME_BIT)) {\n+            assertTrue(xf.isBit0_modifyTimePresent());\n+            assertEquals(time, xf.getModifyTime());\n+        }\n+        if (isFlagSet(expectedFlags, ACCESS_TIME_BIT)) {\n+            assertTrue(xf.isBit1_accessTimePresent());\n+            assertEquals(time, xf.getAccessTime());\n+        }\n+        if (isFlagSet(expectedFlags, CREATE_TIME_BIT)) {\n+            assertTrue(xf.isBit2_createTimePresent());\n+            assertEquals(time, xf.getCreateTime());\n+        }\n+\n+        // Do the same as above, but with Central Directory data:\n+        xf.setFlags(providedFlags);\n+        xf.setModifyTime(time);\n+        xf.setAccessTime(time);\n+        xf.setCreateTime(time);\n+        result = xf.getCentralDirectoryData();\n+        assertTrue(Arrays.equals(expectedCentral, result));\n+\n+        // And now we re-parse:\n+        xf.parseFromCentralDirectoryData(result, 0, result.length);\n+        assertEquals(expectedFlags, xf.getFlags());\n+        // Central Directory never contains ACCESS or CREATE, but\n+        // may contain MODIFY.\n+        if (isFlagSet(expectedFlags, MODIFY_TIME_BIT)) {\n+            assertTrue(xf.isBit0_modifyTimePresent());\n+            assertEquals(time, xf.getModifyTime());\n+        }\n+    }\n+\n+    private static boolean isFlagSet(byte data, byte flag) { return (data & flag) == flag; }\n+}", "timestamp": 1357682055, "metainfo": ""}