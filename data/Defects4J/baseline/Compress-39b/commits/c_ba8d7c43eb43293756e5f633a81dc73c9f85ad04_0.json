{"sha": "ba8d7c43eb43293756e5f633a81dc73c9f85ad04", "log": "COMPRESS-211 - handle zip extra field 0x7875.  I improved code coverage a little for the unit tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n     // BigInteger helps us with little-endian / big-endian conversions.\n     // (thanks to BigInteger.toByteArray() and a reverse() method we created).\n     // Also, the spec theoretically allows UID/GID up to 255 bytes long!\n+    //\n+    // NOTE:  equals() and hashCode() currently assume these can never be null.\n     private BigInteger uid;\n     private BigInteger gid;\n \n     public boolean equals(Object o) {\n         if (o instanceof X7875_NewUnix) {\n             X7875_NewUnix xf = (X7875_NewUnix) o;\n-            if (version == xf.version) {\n-                // The BigInteger==BigInteger clause handles the case where both are null.\n-                if (uid == xf.uid || (uid != null && uid.equals(xf.uid))) {\n-                    return gid == xf.gid || (gid != null && gid.equals(xf.gid));\n-                }\n-            }\n+            // We assume uid and gid can never be null.\n+            return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);\n         }\n         return false;\n     }\n     @Override\n     public int hashCode() {\n         int hc = (-1234567 * version);\n-        if (uid != null) {\n-            hc ^= uid.hashCode();\n-        }\n-        if (gid != null) {\n-            hc ^= gid.hashCode();\n-        }\n+        // Since most UID's and GID's are below 65,536, this is (hopefully!)\n+        // a nice way to make sure typical UID and GID values impact the hash\n+        // as much as possible.\n+        hc ^= Integer.rotateLeft(uid.hashCode(), 16);\n+        hc ^= gid.hashCode();\n         return hc;\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n import java.util.zip.ZipException;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n public class X7875_NewUnixTest {\n \n     @Test\n     public void testMisc() throws Exception {\n+        assertFalse(xf.equals(new Object()));\n         assertTrue(xf.toString().startsWith(\"0x7875 Zip Extra Field\"));\n         Object o = xf.clone();\n         assertEquals(o.hashCode(), xf.hashCode());\n         assertTrue(xf.equals(o));\n+        xf.setUID(12345);\n+        assertFalse(xf.equals(o));\n     }\n \n     @Test\n     @Test\n     public void testParseReparse() throws ZipException {\n \n+        // Version=1, Len=0, Len=0.\n+        final byte[] ZERO_LEN = {1, 0, 0};\n+\n         // Version=1, Len=1, zero, Len=1, zero.\n         final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n \n         final long TWO_TO_32 = 0x100000000L;\n         final long MAX = TWO_TO_32 - 2;\n \n+        parseReparse(0, 0, ZERO_LEN, 0, 0);\n         parseReparse(0, 0, ZERO_UID_GID, 0, 0);\n         parseReparse(1, 1, ONE_UID_GID, 1, 1);\n         parseReparse(1000, 1000, ONE_THOUSAND_UID_GID, 1000, 1000);\n             final long expectedUID,\n             final long expectedGID\n     ) throws ZipException {\n+\n+        // Initial local parse (init with garbage to avoid defaults causing test to pass).\n+        xf.setUID(54321);\n+        xf.setGID(12345);\n+        xf.parseFromLocalFileData(expected, 0, expected.length);\n+        assertEquals(expectedUID, xf.getUID());\n+        assertEquals(expectedGID, xf.getGID());\n+\n+        // Initial central parse (init with garbage to avoid defaults causing test to pass).\n+        xf.setUID(54321);\n+        xf.setGID(12345);\n+        xf.parseFromCentralDirectoryData(expected, 0, expected.length);\n+        assertEquals(expectedUID, xf.getUID());\n+        assertEquals(expectedGID, xf.getGID());\n+\n         xf.setUID(uid);\n         xf.setGID(gid);\n-        assertEquals(expected.length, xf.getLocalFileDataLength().getValue());\n+        if (expected.length < 5) {\n+            // We never emit zero-length entries.\n+            assertEquals(5, xf.getLocalFileDataLength().getValue());\n+        } else {\n+            assertEquals(expected.length, xf.getLocalFileDataLength().getValue());\n+        }\n         byte[] result = xf.getLocalFileDataData();\n-        assertTrue(Arrays.equals(expected, result));\n+        if (expected.length < 5) {\n+            // We never emit zero-length entries.\n+            assertTrue(Arrays.equals(new byte[]{1,1,0,1,0}, result));\n+        } else {\n+            assertTrue(Arrays.equals(expected, result));\n+        }\n+\n+\n \n         // And now we re-parse:\n         xf.parseFromLocalFileData(result, 0, result.length);\n         // Do the same as above, but with Central Directory data:\n         xf.setUID(uid);\n         xf.setGID(gid);\n-        assertEquals(expected.length, xf.getCentralDirectoryLength().getValue());\n+        if (expected.length < 5) {\n+            // We never emit zero-length entries.\n+            assertEquals(5, xf.getCentralDirectoryLength().getValue());\n+        } else {\n+            assertEquals(expected.length, xf.getCentralDirectoryLength().getValue());\n+        }\n         result = xf.getCentralDirectoryData();\n-        assertTrue(Arrays.equals(expected, result));\n+        if (expected.length < 5) {\n+            // We never emit zero-length entries.\n+            assertTrue(Arrays.equals(new byte[]{1,1,0,1,0}, result));\n+        } else {\n+            assertTrue(Arrays.equals(expected, result));\n+        }\n \n         // And now we re-parse:\n         xf.parseFromCentralDirectoryData(result, 0, result.length);", "timestamp": 1357681570, "metainfo": ""}