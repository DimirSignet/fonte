{"sha": "f69ccab744282fc7335dba46656f01ea92901678", "log": "Add preliminary read-only support for the 7z archive format, together with Copy and LZMA2 decompression, some tests, documentation, and Javadocs. Give attribution as per LEGAL-72.  Jira issue key: COMPRESS-54    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Archive.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.util.BitSet;\n+\n+class Archive {\n+    /// Offset from beginning of file + SIGNATURE_HEADER_SIZE to packed streams.\n+    long packPos;\n+    /// Size of each packed stream.\n+    long[] packSizes;\n+    /// Whether each particular packed streams has a CRC.\n+    BitSet packCrcsDefined;\n+    /// CRCs for each packed stream, valid only if that packed stream has one.\n+    int[] packCrcs;\n+    /// Properties of solid compression blocks.\n+    Folder[] folders;\n+    /// Temporary properties for non-empty files (subsumed into the files array later).\n+    SubStreamsInfo subStreamsInfo;\n+    /// The files and directories in the archive.\n+    SevenZArchiveEntry[] files;\n+    /// Mapping between folders, files and streams.\n+    StreamMap streamMap;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/BindPair.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+class BindPair {\n+    long inIndex;\n+    long outIndex;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coder.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+class Coder {\n+    byte[] decompressionMethodId;\n+    long numInStreams;\n+    long numOutStreams;\n+    byte[] properties = null;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+/**\n+ * The unit of solid compression.\n+ */\n+class Folder {\n+    /// List of coders used in this folder, eg. one for compression, one for encryption.\n+    Coder[] coders;\n+    /// Total number of input streams across all coders.\n+    long totalInputStreams;\n+    /// Total number of output streams across all coders.\n+    long totalOutputStreams;\n+    /// Mapping between input and output streams.\n+    BindPair[] bindPairs;\n+    /// Indeces of input streams, one per input stream not listed in bindPairs.\n+    long[] packedStreams;\n+    /// Unpack sizes, per each output stream.\n+    long[] unpackSizes;\n+    /// Whether the folder has a CRC.\n+    boolean hasCrc;\n+    /// The CRC, if present.\n+    int crc;\n+    /// The number of unpack substreams, one per non-empty file in this folder.\n+    int numUnpackSubStreams;\n+\n+    int findBindPairForInStream(final int index) {\n+        for (int i = 0; i < bindPairs.length; i++) {\n+            if (bindPairs[i].inIndex == index) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+    \n+    int findBindPairForOutStream(final int index) {\n+        for (int i = 0; i < bindPairs.length; i++) {\n+            if (bindPairs[i].outIndex == index) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+    \n+    long getUnpackSize() {\n+        if (totalOutputStreams == 0) {\n+            return 0;\n+        }\n+        for (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {\n+            if (findBindPairForOutStream(i) < 0) {\n+                return unpackSizes[i];\n+            }\n+        }\n+        return 0;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/NID.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+final class NID {\n+    public static final int kEnd = 0x00;\n+    public static final int kHeader = 0x01;\n+    public static final int kArchiveProperties = 0x02;\n+    public static final int kAdditionalStreamsInfo = 0x03;\n+    public static final int kMainStreamsInfo = 0x04;\n+    public static final int kFilesInfo = 0x05;\n+    public static final int kPackInfo = 0x06;\n+    public static final int kUnpackInfo = 0x07;\n+    public static final int kSubStreamsInfo = 0x08;\n+    public static final int kSize = 0x09;\n+    public static final int kCRC = 0x0A;\n+    public static final int kFolder = 0x0B;\n+    public static final int kCodersUnpackSize = 0x0C;\n+    public static final int kNumUnpackStream = 0x0D;\n+    public static final int kEmptyStream = 0x0E;\n+    public static final int kEmptyFile = 0x0F;\n+    public static final int kAnti = 0x10;\n+    public static final int kName = 0x11;\n+    public static final int kCTime = 0x12;\n+    public static final int kATime = 0x13;\n+    public static final int kMTime = 0x14;\n+    public static final int kWinAttributes = 0x15;\n+    public static final int kComment = 0x16;\n+    public static final int kEncodedHeader = 0x17;\n+    public static final int kStartPos = 0x18;\n+    public static final int kDummy = 0x19;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+\n+/**\n+ * An entry in a 7z archive.\n+ * \n+ * @NotThreadSafe\n+ */\n+public class SevenZArchiveEntry implements ArchiveEntry {\n+    private String name;\n+    private boolean hasStream;\n+    private boolean isDirectory;\n+    private boolean isAntiItem;\n+    private boolean hasCreationDate;\n+    private boolean hasLastModifiedDate;\n+    private boolean hasAcessDate;\n+    private long creationDate;\n+    private long lastModifiedDate;\n+    private long accessDate;\n+    private boolean hasWindowsAttributes;\n+    private int windowsAttributes;\n+    private boolean hasCrc;\n+    private int crc;\n+    private long size;\n+    \n+    public SevenZArchiveEntry() {\n+    }\n+    \n+    public String getName() {\n+        return name;\n+    }\n+    \n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public boolean hasStream() {\n+        return hasStream;\n+    }\n+\n+    public void setHasStream(boolean hasStream) {\n+        this.hasStream = hasStream;\n+    }\n+\n+    public boolean isDirectory() {\n+        return isDirectory;\n+    }\n+    \n+    public void setDirectory(boolean isDirectory) {\n+        this.isDirectory = isDirectory;\n+    }\n+    \n+    /**\n+     * Indicates whether this is an \"anti-item\" used in differential backups,\n+     * meaning it should delete the same file from a previous backup. \n+     * @return true if it is an anti-item, false otherwise\n+     */\n+    public boolean isAntiItem() {\n+        return isAntiItem;\n+    }\n+\n+    /**\n+     * Sets whether this is an \"anti-item\" used in differential backups,\n+     * meaning it should delete the same file from a previous backup.\n+     * @param isAntiItem true if it is an ait-item, false otherwise \n+     */\n+    public void setAntiItem(boolean isAntiItem) {\n+        this.isAntiItem = isAntiItem;\n+    }\n+\n+    public boolean getHasCreationDate() {\n+        return hasCreationDate;\n+    }\n+    \n+    public void setHasCreationDate(boolean hasCreationDate) {\n+        this.hasCreationDate = hasCreationDate;\n+    }\n+    \n+    public Date getCreationDate() {\n+        if (hasCreationDate) {\n+            return ntfsTimeToJavaTime(creationDate);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The entry doesn't have this timestamp\");\n+        }\n+    }\n+    \n+    public void setCreationDate(long ntfsCreationDate) {\n+        this.creationDate = ntfsCreationDate;\n+    }\n+    \n+    public void setCreationDate(Date creationDate) {\n+        this.creationDate = javaTimeToNtfsTime(creationDate);\n+    }\n+\n+    public boolean getHasLastModifiedDate() {\n+        return hasLastModifiedDate;\n+    }\n+\n+    public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\n+        this.hasLastModifiedDate = hasLastModifiedDate;\n+    }\n+\n+    public Date getLastModifiedDate() {\n+        if (hasLastModifiedDate) {\n+            return ntfsTimeToJavaTime(lastModifiedDate);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The entry doesn't have this timestamp\");\n+        }\n+    }\n+    \n+    public void setLastModifiedDate(long ntfsLastModifiedDate) {\n+        this.lastModifiedDate = ntfsLastModifiedDate;\n+    }\n+    \n+    public void setLastModifiedDate(Date lastModifiedDate) {\n+        this.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n+    }\n+    \n+    public boolean getHasAcessDate() {\n+        return hasAcessDate;\n+    }\n+\n+    public void setHasAcessDate(boolean hasAcessDate) {\n+        this.hasAcessDate = hasAcessDate;\n+    }\n+\n+    public Date getAccessDate() {\n+        if (hasAcessDate) {\n+            return ntfsTimeToJavaTime(accessDate);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"The entry doesn't have this timestamp\");\n+        }\n+    }\n+    \n+    public void setAccessDate(long ntfsAccessDate) {\n+        this.accessDate = ntfsAccessDate;\n+    }\n+    \n+    public void setAccessDate(Date accessDate) {\n+        this.accessDate = javaTimeToNtfsTime(accessDate);\n+    }\n+\n+    public boolean getHasWindowsAttributes() {\n+        return hasWindowsAttributes;\n+    }\n+\n+    public void setHasWindowsAttributes(boolean hasWindowsAttributes) {\n+        this.hasWindowsAttributes = hasWindowsAttributes;\n+    }\n+\n+    public int getWindowsAttributes() {\n+        return windowsAttributes;\n+    }\n+\n+    public void setWindowsAttributes(int windowsAttributes) {\n+        this.windowsAttributes = windowsAttributes;\n+    }\n+\n+    public boolean getHasCrc() {\n+        return hasCrc;\n+    }\n+\n+    public void setHasCrc(boolean hasCrc) {\n+        this.hasCrc = hasCrc;\n+    }\n+\n+    public int getCrc() {\n+        return crc;\n+    }\n+\n+    public void setCrc(int crc) {\n+        this.crc = crc;\n+    }\n+\n+    public long getSize() {\n+        return size;\n+    }\n+    \n+    public void setSize(long size) {\n+        this.size = size;\n+    }\n+\n+    /**\n+     * Converts NTFS time (100 nanosecond units since 1 January 1601)\n+     * to Java time.\n+     * @param ntfsTime the NTFS time in 100 nanosecond units\n+     * @return the Java time\n+     */\n+    public static Date ntfsTimeToJavaTime(final long ntfsTime) {\n+        final Calendar ntfsEpoch = Calendar.getInstance();\n+        ntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\n+        ntfsEpoch.set(1601, 0, 1, 0, 0, 0);\n+        ntfsEpoch.set(Calendar.MILLISECOND, 0);\n+        final long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\n+        return new Date(realTime);\n+    }\n+    \n+    /**\n+     * Converts Java time to NTFS time.\n+     * @param date the Java time\n+     * @return the NTFS time\n+     */\n+    public static long javaTimeToNtfsTime(final Date date) {\n+        final Calendar ntfsEpoch = Calendar.getInstance();\n+        ntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\n+        ntfsEpoch.set(1601, 0, 1, 0, 0, 0);\n+        ntfsEpoch.set(Calendar.MILLISECOND, 0);\n+        return ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.zip.CRC32;\n+\n+import org.apache.commons.compress.utils.CRC32VerifyingInputStream;\n+import org.tukaani.xz.LZMA2InputStream;\n+\n+/**\n+ * Reads a 7z file, using RandomAccessFile under\n+ * the covers.\n+ * <p>\n+ * The 7z file format is a flexible container\n+ * that can contain many compression types, but\n+ * at the moment only Copy and LZMA2 are\n+ * supported, and archive header compression\n+ * (which always uses the unsupported LZMA\n+ * compression) isn't. So the only archives\n+ * that can be read are the following:\n+ * <pre>\n+ * 7z -mhc=off -mx=0 archive.7z files\n+ * 7z -mhc=off -m0=LZMA2 archive.7z files\n+ * </pre>\n+ * <p>\n+ * The format is very Windows/Intel specific,\n+ * so it uses little-endian byte order,\n+ * doesn't store user/group or permission bits,\n+ * and represents times using NTFS timestamps\n+ * (100 nanosecond units since 1 January 1601).\n+ * Hence the official tools recommend against\n+ * using it for backup purposes on *nix, and\n+ * recommend .tar.7z or .tar.lzma or .tar.xz\n+ * instead.  \n+ * <p>\n+ * Both the header and file contents may be\n+ * compressed and/or encrypted. With both\n+ * encrypted, neither file names nor file\n+ * contents can be read, but the use of\n+ * encryption isn't plausibly deniable.\n+ * \n+ * @NotThreadSafe\n+ */\n+public class SevenZFile {\n+    private static final boolean DEBUG = false;\n+    private static final int SIGNATURE_HEADER_SIZE = 32;\n+    private RandomAccessFile file;\n+    private final Archive archive;\n+    private int currentEntryIndex = -1;\n+    private int currentFolderIndex = -1;\n+    private InputStream currentFolderInputStream = null;\n+    private InputStream currentEntryInputStream = null;\n+        \n+    private static final byte[] sevenZSignature = {\n+        (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n+    };\n+    \n+    public SevenZFile(final File filename) throws IOException {\n+        boolean succeeded = false;\n+        this.file = new RandomAccessFile(filename, \"r\");\n+        try {\n+            archive = readHeaders();\n+            succeeded = true;\n+        } finally {\n+            if (!succeeded) {\n+                this.file.close();\n+            }\n+        }\n+    }\n+    \n+    public void close() {\n+        if (file != null) {\n+            try {\n+                file.close();\n+            } catch (IOException ignored) { // NOPMD\n+            }\n+            file = null;\n+        }\n+    }\n+    \n+    private static void debug(String str) {\n+        if (DEBUG) {\n+            System.out.println(str);\n+        }\n+    }\n+    \n+    private static void debug(String fmt, Object... args) {\n+        if (DEBUG) {\n+            System.out.format(fmt, args);\n+        }\n+    }\n+    \n+    public SevenZArchiveEntry getNextEntry() throws IOException {\n+        if (currentEntryIndex >= (archive.files.length - 1)) {\n+            return null;\n+        }\n+        ++currentEntryIndex;\n+        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n+        buildDecodingStream();\n+        return entry;\n+    }\n+    \n+    private Archive readHeaders() throws IOException {\n+        debug(\"SignatureHeader\");\n+        \n+        final byte[] signature = new byte[6];\n+        file.readFully(signature);\n+        if (!Arrays.equals(signature, sevenZSignature)) {\n+            throw new IOException(\"Bad 7z signature\");\n+        }\n+        // 7zFormat.txt has it wrong - it's first major then minor\n+        final byte archiveVersionMajor = file.readByte();\n+        final byte archiveVersionMinor = file.readByte();\n+        debug(\"  archiveVersion major=%d, minor=%d\\n\",\n+                archiveVersionMajor, archiveVersionMinor);\n+        if (archiveVersionMajor != 0) {\n+            throw new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\n+                    archiveVersionMajor, archiveVersionMinor));\n+        }\n+\n+        final int startHeaderCrc = Integer.reverseBytes(file.readInt());\n+        final StartHeader startHeader = readStartHeader(startHeaderCrc);\n+        \n+        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n+        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n+            throw new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n+        }\n+        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n+        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n+        file.readFully(nextHeader);\n+        final CRC32 crc = new CRC32();\n+        crc.update(nextHeader);\n+        if (startHeader.nextHeaderCrc != (int) crc.getValue()) {\n+            throw new IOException(\"NextHeader CRC mismatch\");\n+        }\n+        \n+        final Archive archive = new Archive();\n+        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n+        final DataInputStream nextHeaderInputStream = new DataInputStream(\n+                byteStream);\n+        int nid = nextHeaderInputStream.readUnsignedByte();\n+        if (nid == NID.kEncodedHeader) {\n+            readEncodedHeader(nextHeaderInputStream, archive);\n+            nid = nextHeaderInputStream.readUnsignedByte();\n+        }\n+        if (nid == NID.kHeader) {\n+            readHeader(nextHeaderInputStream, archive);\n+        }\n+        return archive;\n+    }\n+    \n+    private StartHeader readStartHeader(final int startHeaderCrc) throws IOException {\n+        final StartHeader startHeader = new StartHeader();\n+        DataInputStream dataInputStream = null;\n+        try {\n+             dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n+                    new BoundedRandomAccessFileInputStream(20), 20, startHeaderCrc));\n+             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n+             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n+             startHeader.nextHeaderCrc = Integer.reverseBytes(dataInputStream.readInt());\n+             return startHeader;\n+        } finally {\n+            if (dataInputStream != null) {\n+                dataInputStream.close();\n+            }\n+        }\n+    }\n+    \n+    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"Header\");\n+\n+        int nid = header.readUnsignedByte();\n+        \n+        if (nid == NID.kArchiveProperties) {\n+            readArchiveProperties(header);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kAdditionalStreamsInfo) {\n+            throw new IOException(\"Additional streams unsupported\");\n+            //nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kMainStreamsInfo) {\n+            readStreamsInfo(header, archive);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kFilesInfo) {\n+            readFilesInfo(header, archive);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid != NID.kEnd) {\n+            throw new IOException(\"Badly terminated header\");\n+        }\n+    }\n+    \n+    private void readArchiveProperties(final DataInput input) throws IOException {\n+        // FIXME: the reference implementation just throws them away?\n+        debug(\"ArchiveProperties\");\n+\n+        int nid =  input.readUnsignedByte();\n+        while (nid != NID.kEnd) {\n+            final long propertySize = readUint64(input);\n+            final byte[] property = new byte[(int)propertySize];\n+            input.readFully(property);\n+            nid = input.readUnsignedByte();\n+        }\n+    }\n+    \n+    private void readEncodedHeader(final DataInputStream header, final Archive archive) throws IOException {\n+        debug(\"EncodedHeader\");\n+\n+        readStreamsInfo(header, archive);\n+        \n+        // FIXME: and decompress it etc.\n+        \n+        throw new IOException(\"LZMA compression unsupported, so files with compressed header cannot be read\");\n+        // FIXME: this extracts the header to an LZMA file which can then be\n+        // manually decompressed.\n+//        long offset = SIGNATURE_HEADER_SIZE + archive.packPos;\n+//        file.seek(offset);\n+//        long unpackSize = archive.folders[0].getUnpackSize();\n+//        byte[] packed = new byte[(int)archive.packSizes[0]];\n+//        file.readFully(packed);\n+//        \n+//        FileOutputStream fos = new FileOutputStream(new File(\"/tmp/encodedHeader.7z\"));\n+//        fos.write(archive.folders[0].coders[0].properties);\n+//        // size - assuming < 256\n+//        fos.write((int)(unpackSize & 0xff));\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(0);\n+//        fos.write(packed);\n+//        fos.close();\n+    }\n+    \n+    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"StreamsInfo\");\n+        \n+        int nid = header.readUnsignedByte();\n+        \n+        if (nid == NID.kPackInfo) {\n+            readPackInfo(header, archive);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kUnpackInfo) {\n+            readUnpackInfo(header, archive);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kSubStreamsInfo) {\n+            readSubStreamsInfo(header, archive);\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid != NID.kEnd) {\n+            throw new IOException(\"Badly terminated StreamsInfo\");\n+        }\n+    }\n+    \n+    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"PackInfo\");\n+        \n+        archive.packPos = readUint64(header);\n+        final long numPackStreams = readUint64(header);\n+        debug(\"  \" + numPackStreams + \" pack streams\");\n+        \n+        int nid = header.readUnsignedByte();\n+        if (nid == NID.kSize) {\n+            archive.packSizes = new long[(int)numPackStreams];\n+            for (int i = 0; i < archive.packSizes.length; i++) {\n+                archive.packSizes[i] = readUint64(header);\n+                debug(\"  pack size %d is %d\\n\", i, archive.packSizes[i]);\n+            }\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid == NID.kCRC) {\n+            archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n+            archive.packCrcs = new int[(int)numPackStreams];\n+            for (int i = 0; i < (int)numPackStreams; i++) {\n+                if (archive.packCrcsDefined.get(i)) {\n+                    archive.packCrcs[i] = Integer.reverseBytes(header.readInt());\n+                }\n+            }\n+            \n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid != NID.kEnd) {\n+            throw new IOException(\"Badly terminated PackInfo (\" + nid + \")\");\n+        }\n+    }\n+    \n+    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"UnpackInfo\");\n+\n+        int nid = header.readUnsignedByte();\n+        if (nid != NID.kFolder) {\n+            throw new IOException(\"Expected kFolder, got \" + nid);\n+        }\n+        final long numFolders = readUint64(header);\n+        debug(\"  \" + numFolders + \" folders\");\n+        final Folder[] folders = new Folder[(int)numFolders];\n+        archive.folders = folders;\n+        final int external = header.readUnsignedByte();\n+        if (external != 0) {\n+            throw new IOException(\"External unsupported\");\n+        } else {\n+            for (int i = 0; i < (int)numFolders; i++) {\n+                folders[i] = readFolder(header);\n+            }\n+        }\n+        \n+        nid = header.readUnsignedByte();\n+        if (nid != NID.kCodersUnpackSize) {\n+            throw new IOException(\"Expected kCodersUnpackSize, got \" + nid);\n+        }\n+        for (final Folder folder : folders) {\n+            folder.unpackSizes = new long[(int)folder.totalOutputStreams];\n+            for (int i = 0; i < folder.totalOutputStreams; i++) {\n+                folder.unpackSizes[i] = readUint64(header);\n+            }\n+        }\n+        \n+        nid = header.readUnsignedByte();\n+        if (nid == NID.kCRC) {\n+            final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);\n+            for (int i = 0; i < (int)numFolders; i++) {\n+                if (crcsDefined.get(i)) {\n+                    folders[i].hasCrc = true;\n+                    folders[i].crc = Integer.reverseBytes(header.readInt());\n+                } else {\n+                    folders[i].hasCrc = false;\n+                }\n+            }\n+            \n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid != NID.kEnd) {\n+            throw new IOException(\"Badly terminated UnpackInfo\");\n+        }\n+    }\n+    \n+    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"SubStreamsInfo\");\n+        \n+        for (final Folder folder : archive.folders) {\n+            folder.numUnpackSubStreams = 1;\n+        }\n+        int totalUnpackStreams = archive.folders.length;\n+        \n+        int nid = header.readUnsignedByte();\n+        if (nid == NID.kNumUnpackStream) {\n+            totalUnpackStreams = 0;\n+            for (final Folder folder : archive.folders) {\n+                final long numStreams = readUint64(header);\n+                folder.numUnpackSubStreams = (int)numStreams;\n+                totalUnpackStreams += numStreams;\n+            }\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n+        subStreamsInfo.unpackSizes = new long[(int)totalUnpackStreams];\n+        subStreamsInfo.hasCrc = new BitSet((int)totalUnpackStreams);\n+        subStreamsInfo.crcs = new int[(int)totalUnpackStreams];\n+        \n+        int nextUnpackStream = 0;\n+        for (final Folder folder : archive.folders) {\n+            if (folder.numUnpackSubStreams == 0) {\n+                continue;\n+            }\n+            long sum = 0;\n+            if (nid == NID.kSize) {\n+                for (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\n+                    final long size = readUint64(header);\n+                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n+                    sum += size;\n+                }\n+            }\n+            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n+        }\n+        if (nid == NID.kSize) {\n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        int numDigests = 0;\n+        for (final Folder folder : archive.folders) {\n+            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n+                numDigests += folder.numUnpackSubStreams;\n+            }\n+        }\n+        \n+        if (nid == NID.kCRC) {\n+            final BitSet hasMissingCrc = readAllOrBits(header, (int)numDigests);\n+            final int[] missingCrcs = new int[(int)numDigests];\n+            for (int i = 0; i < (int)numDigests; i++) {\n+                if (hasMissingCrc.get(i)) {\n+                    missingCrcs[i] = Integer.reverseBytes(header.readInt());\n+                }\n+            }\n+            int nextCrc = 0;\n+            int nextMissingCrc = 0;\n+            for (final Folder folder: archive.folders) {\n+                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\n+                    subStreamsInfo.hasCrc.set(nextCrc, true);\n+                    subStreamsInfo.crcs[nextCrc] = folder.crc;\n+                    ++nextCrc;\n+                } else {\n+                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {\n+                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n+                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n+                        ++nextCrc;\n+                        ++nextMissingCrc;\n+                    }\n+                }\n+            }\n+            \n+            nid = header.readUnsignedByte();\n+        }\n+        \n+        if (nid != NID.kEnd) {\n+            throw new IOException(\"Badly terminated SubStreamsInfo\");\n+        }\n+        \n+        archive.subStreamsInfo = subStreamsInfo;\n+    }\n+    \n+    private Folder readFolder(final DataInput header) throws IOException {\n+        final Folder folder = new Folder();\n+        \n+        final long numCoders = readUint64(header);\n+        final Coder[] coders = new Coder[(int)numCoders];\n+        long totalInStreams = 0;\n+        long totalOutStreams = 0;\n+        for (int i = 0; i < coders.length; i++) {\n+            coders[i] = new Coder();\n+            int bits = header.readUnsignedByte();\n+            final int idSize = bits & 0xf;\n+            final boolean isSimple = ((bits & 0x10) == 0);\n+            final boolean hasAttributes = ((bits & 0x20) != 0);\n+            final boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n+            \n+            coders[i].decompressionMethodId = new byte[idSize];\n+            header.readFully(coders[i].decompressionMethodId);\n+            if (isSimple) {\n+                coders[i].numInStreams = 1;\n+                coders[i].numOutStreams = 1;\n+            } else {\n+                coders[i].numInStreams = readUint64(header);\n+                coders[i].numOutStreams = readUint64(header);\n+            }\n+            totalInStreams += coders[i].numInStreams;\n+            totalOutStreams += coders[i].numOutStreams;\n+            if (hasAttributes) {\n+                final long propertiesSize = readUint64(header);\n+                coders[i].properties = new byte[(int)propertiesSize];\n+                header.readFully(coders[i].properties);\n+            }\n+            if (DEBUG) {\n+                final StringBuilder methodStr = new StringBuilder();\n+                for (final byte b : coders[i].decompressionMethodId) {\n+                    methodStr.append(String.format(\"%02X\", 0xff & b));\n+                }\n+                debug(\"  coder entry %d numInStreams=%d, numOutStreams=%d, method=%s, properties=%s\\n\", i,\n+                        coders[i].numInStreams, coders[i].numOutStreams, methodStr.toString(),\n+                        Arrays.toString(coders[i].properties));\n+            }\n+            // would need to keep looping as above:\n+            while (moreAlternativeMethods) {\n+                throw new IOException(\"Alternative methods are unsupported, please report. \" +\n+                        \"The reference implementation doesn't support them either.\");\n+            }\n+        }\n+        folder.coders = coders;\n+        folder.totalInputStreams = totalInStreams;\n+        folder.totalOutputStreams = totalOutStreams;\n+        \n+        if (totalOutStreams == 0) {\n+            throw new IOException(\"Total output streams can't be 0\");\n+        }\n+        final long numBindPairs = totalOutStreams - 1;\n+        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n+        for (int i = 0; i < bindPairs.length; i++) {\n+            bindPairs[i] = new BindPair();\n+            bindPairs[i].inIndex = readUint64(header);\n+            bindPairs[i].outIndex = readUint64(header);\n+            debug(\"  bind pair in=%d out=%d\\n\", bindPairs[i].inIndex, bindPairs[i].outIndex);\n+        }\n+        folder.bindPairs = bindPairs;\n+        \n+        if (totalInStreams < numBindPairs) {\n+            throw new IOException(\"Total input streams can't be less than the number of bind pairs\");\n+        }\n+        final long numPackedStreams = totalInStreams - numBindPairs;\n+        final long packedStreams[] = new long[(int)numPackedStreams];\n+        if (numPackedStreams == 1) {\n+            int i;\n+            for (i = 0; i < (int)totalInStreams; i++) {\n+                if (folder.findBindPairForInStream(i) < 0) {\n+                    break;\n+                }\n+            }\n+            if (i == (int)totalInStreams) {\n+                throw new IOException(\"Couldn't find stream's bind pair index\");\n+            }\n+            packedStreams[0] = i;\n+        } else {\n+            for (int i = 0; i < (int)numPackedStreams; i++) {\n+                packedStreams[i] = readUint64(header);\n+            }\n+        }\n+        folder.packedStreams = packedStreams;\n+        \n+        return folder;\n+    }\n+    \n+    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n+        final int areAllDefined = header.readUnsignedByte();\n+        final BitSet bits;\n+        if (areAllDefined != 0) {\n+            bits = new BitSet(size);\n+            for (int i = 0; i < size; i++) {\n+                bits.set(i, true);\n+            }\n+        } else {\n+            bits = readBits(header, size);\n+        }\n+        return bits;\n+    }\n+    \n+    private BitSet readBits(final DataInput header, final int size) throws IOException {\n+        final BitSet bits = new BitSet(size);\n+        int mask = 0;\n+        int cache = 0;\n+        for (int i = 0; i < size; i++) {\n+            if (mask == 0) {\n+                mask = 0x80;\n+                cache = header.readUnsignedByte();\n+            }\n+            bits.set(i, (cache & mask) != 0);\n+            mask >>>= 1;\n+        }\n+        return bits;\n+    }\n+    \n+    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n+        debug(\"FilesInfo\");\n+\n+        final long numFiles = readUint64(header);\n+        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n+        for (int i = 0; i < files.length; i++) {\n+            files[i] = new SevenZArchiveEntry();\n+        }\n+        BitSet isEmptyStream = null;\n+        BitSet isEmptyFile = null; \n+        BitSet isAnti = null;\n+        while (true) {\n+            final int propertyType = header.readUnsignedByte();\n+            if (propertyType == 0) {\n+                break;\n+            }\n+            long size = readUint64(header);\n+            switch (propertyType) {\n+                case NID.kEmptyStream: {\n+                    debug(\"  kEmptyStream\");\n+                    isEmptyStream = readBits(header, files.length);\n+                    break;\n+                }\n+                case NID.kEmptyFile: {\n+                    debug(\"  kEmptyFile\");\n+                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n+                    break;\n+                }\n+                case NID.kAnti: {\n+                    debug(\"  kAnti\");\n+                    isAnti = readBits(header, isEmptyStream.cardinality());\n+                    break;\n+                }\n+                case NID.kName: {\n+                    debug(\"  kNames\");\n+                    final int external = header.readUnsignedByte();\n+                    if (external != 0) {\n+                        throw new IOException(\"Not implemented\");\n+                    } else {\n+                        if (((size - 1) & 1) != 0) {\n+                            throw new IOException(\"File names length invalid\");\n+                        }\n+                        final byte[] names = new byte[(int)(size - 1)];\n+                        header.readFully(names);\n+                        int nextFile = 0;\n+                        int nextName = 0;\n+                        for (int i = 0; i < names.length; i += 2) {\n+                            if (names[i] == 0 && names[i+1] == 0) {\n+                                files[nextFile++].setName(new String(names, nextName, i-nextName, \"UTF-16LE\"));\n+                                nextName = i + 2;\n+                            }\n+                        }\n+                        if (nextName != names.length || nextFile != files.length) {\n+                            throw new IOException(\"Error parsing file names\");\n+                        }\n+                    }\n+                    break;\n+                }\n+                case NID.kCTime: {\n+                    debug(\"  kCreationTime\");\n+                    final BitSet timesDefined = readAllOrBits(header, files.length);\n+                    final int external = header.readUnsignedByte();\n+                    if (external != 0) {\n+                        throw new IOException(\"Unimplemented\");\n+                    } else {\n+                        for (int i = 0; i < files.length; i++) {\n+                            files[i].setHasCreationDate(timesDefined.get(i));\n+                            if (files[i].getHasCreationDate()) {\n+                                files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+                case NID.kATime: {\n+                    debug(\"  kLastAccessTime\");\n+                    final BitSet timesDefined = readAllOrBits(header, files.length);\n+                    final int external = header.readUnsignedByte();\n+                    if (external != 0) {\n+                        throw new IOException(\"Unimplemented\");\n+                    } else {\n+                        for (int i = 0; i < files.length; i++) {\n+                            files[i].setHasAcessDate(timesDefined.get(i));\n+                            if (files[i].getHasAcessDate()) {\n+                                files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+                case NID.kMTime: {\n+                    debug(\"  kLastWriteTime\");\n+                    final BitSet timesDefined = readAllOrBits(header, files.length);\n+                    final int external = header.readUnsignedByte();\n+                    if (external != 0) {\n+                        throw new IOException(\"Unimplemented\");\n+                    } else {\n+                        for (int i = 0; i < files.length; i++) {\n+                            files[i].setHasLastModifiedDate(timesDefined.get(i));\n+                            if (files[i].getHasLastModifiedDate()) {\n+                                files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+                case NID.kWinAttributes: {\n+                    debug(\"  kWinAttributes\");\n+                    final BitSet attributesDefined = readAllOrBits(header, files.length);\n+                    final int external = header.readUnsignedByte();\n+                    if (external != 0) {\n+                        throw new IOException(\"Unimplemented\");\n+                    } else {\n+                        for (int i = 0; i < files.length; i++) {\n+                            files[i].setHasWindowsAttributes(attributesDefined.get(i));\n+                            if (files[i].getHasWindowsAttributes()) {\n+                                files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+                case NID.kStartPos: {\n+                    debug(\"  kStartPos\");\n+                    throw new IOException(\"kStartPos is unsupported, please report\");\n+                }\n+                case NID.kDummy: {\n+                    debug(\"  kDummy\");\n+                    throw new IOException(\"kDummy is unsupported, please report\");\n+                }\n+                \n+                default: {\n+                    throw new IOException(\"Unknown property \" + propertyType);\n+                    // FIXME: Should actually:\n+                    //header.skipBytes((int)size);\n+                }\n+            }\n+        }\n+        int nonEmptyFileCounter = 0;\n+        int emptyFileCounter = 0;\n+        for (int i = 0; i < files.length; i++) {\n+            files[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\n+            if (files[i].hasStream()) {\n+                files[i].setDirectory(false);\n+                files[i].setAntiItem(false);\n+                files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n+                files[i].setCrc(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n+                files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n+                ++nonEmptyFileCounter;\n+            } else {\n+                files[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\n+                files[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\n+                files[i].setHasCrc(false);\n+                files[i].setSize(0);\n+                ++emptyFileCounter;\n+            }\n+        }\n+        archive.files = files;\n+        calculateStreamMap(archive);\n+    }\n+    \n+    private void calculateStreamMap(final Archive archive) throws IOException {\n+        final StreamMap streamMap = new StreamMap();\n+        \n+        int nextFolderPackStreamIndex = 0;\n+        streamMap.folderFirstPackStreamIndex = new int[archive.folders.length];\n+        for (int i = 0; i < archive.folders.length; i++) {\n+            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n+            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n+        }\n+        \n+        long nextPackStreamOffset = 0;\n+        streamMap.packStreamOffsets = new long[archive.packSizes.length];\n+        for (int i = 0; i < archive.packSizes.length; i++) {\n+            streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n+            nextPackStreamOffset += archive.packSizes[i]; \n+        }\n+        \n+        streamMap.folderFirstFileIndex = new int[archive.folders.length];\n+        streamMap.fileFolderIndex = new int[archive.files.length];\n+        int nextFolderIndex = 0;\n+        int nextFolderUnpackStreamIndex = 0;\n+        for (int i = 0; i < archive.files.length; i++) {\n+            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\n+                streamMap.fileFolderIndex[i] = -1;\n+                continue;\n+            }\n+            if (nextFolderUnpackStreamIndex == 0) {\n+                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\n+                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;\n+                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n+                        break;\n+                    }\n+                }\n+                if (nextFolderIndex >= archive.folders.length) {\n+                    throw new IOException(\"Too few folders in archive\");\n+                }\n+            }\n+            streamMap.fileFolderIndex[i] = nextFolderIndex;\n+            if (!archive.files[i].hasStream()) {\n+                continue;\n+            }\n+            ++nextFolderUnpackStreamIndex;\n+            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n+                ++nextFolderIndex;\n+                nextFolderUnpackStreamIndex = 0;\n+            }\n+        }\n+        \n+        archive.streamMap = streamMap;\n+    }\n+    \n+    private void buildDecodingStream() throws IOException {\n+        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n+        if (folderIndex < 0) {\n+            currentEntryInputStream = new BoundedInputStream(\n+                    new ByteArrayInputStream(new byte[0]), 0);\n+            return;\n+        }\n+        if (currentFolderIndex == folderIndex) {\n+            // need to advance the folder input stream past the current file\n+            drainPreviousEntry();\n+        } else {\n+            currentFolderIndex = folderIndex;\n+            if (currentFolderInputStream != null) {\n+                currentFolderInputStream.close();\n+                currentFolderInputStream = null;\n+            }\n+            \n+            final Folder folder = archive.folders[folderIndex];\n+            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n+            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n+                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n+            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex);\n+        }\n+        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n+        final InputStream fileStream = new BoundedInputStream(\n+                currentFolderInputStream, file.getSize());\n+        if (file.getHasCrc()) {\n+            currentEntryInputStream = new CRC32VerifyingInputStream(\n+                    fileStream, file.getSize(), file.getCrc());\n+        } else {\n+            currentEntryInputStream = fileStream;\n+        }\n+        \n+    }\n+    \n+    private void drainPreviousEntry() throws IOException {\n+        if (currentEntryInputStream != null) {\n+            final byte[] buffer = new byte[64*1024];\n+            while (currentEntryInputStream.read(buffer) >= 0) { // NOPMD\n+            }\n+            currentEntryInputStream.close();\n+            currentEntryInputStream = null;\n+        }\n+    }\n+    \n+    private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n+            final int firstPackStreamIndex) throws IOException {\n+        InputStream inputStreamStack = null;\n+        for (int i = 0; i < folder.coders.length; i++) {\n+            if (i > 0) {\n+                throw new IOException(\"Unsupported multi-codec stream\");\n+            }\n+            file.seek(folderOffset);\n+            if (folder.coders[i].decompressionMethodId.length == 1 &&\n+                    folder.coders[i].decompressionMethodId[0] == 0) {\n+                // 00 - Copy\n+                inputStreamStack = new BoundedRandomAccessFileInputStream(\n+                        archive.packSizes[firstPackStreamIndex]);\n+                // FIXME: LZMA is the default coder yet ironically we don't have it.\n+//            } else if (folder.coders[i].decompressionMethodId.length == 3 &&\n+//                    folder.coders[i].decompressionMethodId[0] == 3 &&\n+//                    folder.coders[i].decompressionMethodId[1] == 1 &&\n+//                    folder.coders[i].decompressionMethodId[2] == 1) {\n+//                // 03.. - 7z\n+//                //    01 - LZMA\n+//                //       01 - Version\n+            } else if (folder.coders[i].decompressionMethodId.length == 1 &&\n+                    folder.coders[i].decompressionMethodId[0] == 0x21) {\n+                // 21 - LZMA2\n+                final int dictionarySizeBits = 0xff & folder.coders[i].properties[0];\n+                if ((dictionarySizeBits & (~0x3f)) != 0) {\n+                    throw new IOException(\"Unsupported LZMA2 property bits\");\n+                }\n+                if (dictionarySizeBits > 40) {\n+                    throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n+                }\n+                final int dictionarySize;\n+                if (dictionarySizeBits == 40) {\n+                    dictionarySize = 0xFFFFffff;\n+                } else {\n+                    dictionarySize = (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n+                }\n+                inputStreamStack = new LZMA2InputStream(\n+                      new BoundedRandomAccessFileInputStream(\n+                              archive.packSizes[firstPackStreamIndex]),\n+                              dictionarySize);\n+                // FIXME: gives corrupt output:\n+//            } else if (folder.coders[i].decompressionMethodId.length == 3 &&\n+//                    folder.coders[i].decompressionMethodId[0] == 0x4 &&\n+//                    folder.coders[i].decompressionMethodId[1] == 0x1 && \n+//                    folder.coders[i].decompressionMethodId[2] == 0x8) {\n+//                // 04.. - Misc\n+//                //    00 - Reserved\n+//                //    01 - Zip\n+//                //       00 - Copy (not used). Use {00} instead\n+//                //       01 - Shrink\n+//                //       06 - Implode\n+//                //       08 - Deflate\n+//                return new DeflaterInputStream(\n+//                        new BoundedRandomAccessFileInputStream(\n+//                                archive.packSizes[firstPackStreamIndex]),\n+//                                new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n+            } else {\n+                throw new IOException(\"Unsupported compression method \" +\n+                        Arrays.toString(folder.coders[i].decompressionMethodId));\n+            }\n+        }\n+        if (folder.hasCrc) {\n+            return new CRC32VerifyingInputStream(inputStreamStack,\n+                    folder.getUnpackSize(), folder.crc);\n+        } else {\n+            return inputStreamStack;\n+        }\n+    }\n+    \n+    public int read() throws IOException {\n+        return currentEntryInputStream.read();\n+    }\n+    \n+    public int read(byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+    \n+    public int read(byte[] b, int off, int len) throws IOException {\n+        return currentEntryInputStream.read(b, off, len);\n+    }\n+    \n+    private static long readUint64(final DataInput in) throws IOException {\n+        int firstByte = in.readUnsignedByte();\n+        int mask = 0x80;\n+        int value = 0;\n+        for (int i = 0; i < 8; i++) {\n+            if ((firstByte & mask) == 0) {\n+                return value | ((firstByte & (mask - 1)) << (8 * i));\n+            }\n+            int nextByte = in.readUnsignedByte();\n+            value |= (nextByte << (8 * i));\n+            mask >>>= 1;\n+        }\n+        return value;\n+    }\n+    \n+    private class BoundedRandomAccessFileInputStream extends InputStream {\n+        private long bytesRemaining;\n+        \n+        public BoundedRandomAccessFileInputStream(final long size) {\n+            bytesRemaining = size;\n+        }\n+        \n+        @Override\n+        public int read() throws IOException {\n+            if (bytesRemaining > 0) {\n+                --bytesRemaining;\n+                return file.read();\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (bytesRemaining == 0) {\n+                return -1;\n+            }\n+            int bytesToRead = len;\n+            if (bytesToRead > bytesRemaining) {\n+                bytesToRead = (int) bytesRemaining;\n+            }\n+            final int bytesRead = file.read(b, off, bytesToRead);\n+            if (bytesRead >= 0) {\n+                bytesRemaining -= bytesRead;\n+            }\n+            return bytesRead;\n+        }\n+\n+        @Override\n+        public void close() {\n+        }\n+    }\n+\n+    private static class BoundedInputStream extends InputStream {\n+        private InputStream is;\n+        private long bytesRemaining;\n+        \n+        public BoundedInputStream(final InputStream is, final long size) {\n+            this.is = is;\n+            bytesRemaining = size;\n+        }\n+        \n+        @Override\n+        public int read() throws IOException {\n+            if (bytesRemaining > 0) {\n+                --bytesRemaining;\n+                return is.read();\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            if (bytesRemaining == 0) {\n+                return -1;\n+            }\n+            int bytesToRead = len;\n+            if (bytesToRead > bytesRemaining) {\n+                bytesToRead = (int) bytesRemaining;\n+            }\n+            final int bytesRead = is.read(b, off, bytesToRead);\n+            if (bytesRead >= 0) {\n+                bytesRemaining -= bytesRead;\n+            }\n+            return bytesRead;\n+        }\n+\n+        @Override\n+        public void close() {\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/StartHeader.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+class StartHeader {\n+    long nextHeaderOffset;\n+    long nextHeaderSize;\n+    int nextHeaderCrc;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/StreamMap.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+/// Map between folders, files and streams.\n+class StreamMap {\n+    /// The first Archive.packStream index of each folder.\n+    int[] folderFirstPackStreamIndex;\n+    /// Offset to beginning of this pack stream's data, relative to the beginning of the first pack stream.\n+    long[] packStreamOffsets;\n+    /// Index of first file for each folder.\n+    int[] folderFirstFileIndex;\n+    /// Index of folder for each file.\n+    int[] fileFolderIndex;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SubStreamsInfo.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.util.BitSet;\n+\n+/// Properties for non-empty files.\n+class SubStreamsInfo {\n+    /// Unpacked size of each unpacked stream.\n+    long[] unpackSizes;\n+    /// Whether CRC is present for each unpacked stream.\n+    BitSet hasCrc;\n+    /// CRCs of unpacked streams, if present.\n+    int[] crcs;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.zip.CRC32;\n+\n+public class CRC32VerifyingInputStream extends InputStream {\n+    private final InputStream is;\n+    private long bytesRemaining;\n+    private final int expectedCrc32;\n+    private final CRC32 crc32 = new CRC32();\n+    \n+    public CRC32VerifyingInputStream(final InputStream is, final long size, final int expectedCrc32) {\n+        this.is = is;\n+        this.expectedCrc32 = expectedCrc32;\n+        this.bytesRemaining = size;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        if (bytesRemaining <= 0) {\n+            return -1;\n+        }\n+        int ret = is.read();\n+        if (ret >= 0) {\n+            crc32.update(ret);\n+            --bytesRemaining;\n+        }\n+        if (bytesRemaining == 0 && expectedCrc32 != (int)crc32.getValue()) {\n+            throw new IOException(\"CRC32 verification failed\");\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public int read(byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int ret = is.read(b, off, len);\n+        if (ret >= 0) {\n+            crc32.update(b, off, ret);\n+            bytesRemaining -= ret;\n+        }\n+        if (bytesRemaining <= 0 && expectedCrc32 != (int)crc32.getValue()) {\n+            throw new IOException(\"CRC32 verification failed\");\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public long skip(long n) throws IOException {\n+        // Can't really skip, we have to hash everything to verify the checksum\n+        if (read() >= 0) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        is.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+\n+public class SevenZFileTest extends AbstractTestCase {\n+    public void testHelloWorldHeaderCompressionOffCopy() throws Exception {\n+        checkHelloWorld(\"7z-hello-mhc-off-copy.7z\");\n+    }\n+\n+    public void testHelloWorldHeaderCompressionOffLZMA2() throws Exception {\n+        checkHelloWorld(\"7z-hello-mhc-off-lzma2.7z\");\n+    }\n+\n+    private void checkHelloWorld(final String filename) throws Exception {\n+        SevenZFile sevenZFile = new SevenZFile(getFile(filename));\n+        try {\n+            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n+            assertEquals(\"Hello world.txt\", entry.getName());\n+            byte[] contents = new byte[(int)entry.getSize()];\n+            int off = 0;\n+            while ((off < contents.length)) {\n+                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n+                assert(bytesRead >= 0);\n+                off += bytesRead;\n+            }\n+            assertEquals(\"Hello, world!\\n\", new String(contents, \"UTF-8\"));\n+            assertNull(sevenZFile.getNextEntry());\n+        } finally {\n+            sevenZFile.close();\n+        }\n+    }\n+}", "timestamp": 1367957197, "metainfo": ""}