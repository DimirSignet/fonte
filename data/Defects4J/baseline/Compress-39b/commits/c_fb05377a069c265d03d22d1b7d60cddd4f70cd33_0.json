{"sha": "fb05377a069c265d03d22d1b7d60cddd4f70cd33", "log": "cases five and six of seven: unknown sizes, writing to a file, compressed and uncompressed.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n \n             raf.seek(localDataStart);\n             writeOut(ZipLong.getBytes(entry.getCrc()));\n-            if (!hasZip64Extra(entry)) {\n+            if (!hasZip64Extra(entry)\n+                || (entry.getSize() < ZIP64_MAGIC\n+                    && entry.getCompressedSize() < ZIP64_MAGIC)) {\n                 writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n                 writeOut(ZipLong.getBytes(entry.getSize()));\n             } else {\n                 writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n                 writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-\n+            }\n+\n+            if (hasZip64Extra(entry)) {\n                 // seek to ZIP64 extra, skip header and size information\n                 raf.seek(localDataStart + 3 * WORD + 2 * SHORT\n                          + getName(entry).limit() + 2 * SHORT);\n         }\n \n         // add a ZIP64 extended information extra field if we already\n-        // know it is going to be needed\n+        // know it is going to be needed or the size is unknown and we\n+        // can ensure it won't hurt other implementations if we add it\n+        // (i.e. we can erase its usage)\n         if (entry.getSize() >= ZIP64_MAGIC\n-            || entry.getCompressedSize() >= ZIP64_MAGIC) {\n+            || entry.getCompressedSize() >= ZIP64_MAGIC\n+            || (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN && raf != null)) {\n \n             Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry);\n-            if (entry.getMethod() == STORED) {\n+            if (entry.getMethod() == STORED\n+                && entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n                 ZipEightByteInteger size =\n                     new ZipEightByteInteger(entry.getSize());\n                 z64.setSize(size);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n                              true);\n     }\n \n+    @Test public void writeBigStoredEntryUnnownSizeToFile() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n+                             writeBigStoredEntry(false),\n+                             true);\n+    }\n+\n     /*\n      * One entry of length 5 billion bytes, written with\n      * compression to a stream.\n      *\n      * Creates a temporary archive of approx 4MB in size\n      */\n-    @Test public void writeBigDeflatedEntryKnownSizeToFile()\n-        throws Throwable {\n-        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\",\n-                             new ZipOutputTest() {\n+    private static ZipOutputTest writeBigDeflatedEntryToFile(final boolean knownSize) {\n+        return new ZipOutputTest() {\n                                  public void test(File f,\n                                                   ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      byte[] buf = new byte[1000 * 1000];\n                                      ZipArchiveEntry zae =\n                                          new ZipArchiveEntry(\"0\");\n+                                     if (knownSize) {\n                                      zae.setSize(FIVE_BILLION);\n+                                     }\n                                      zae.setMethod(ZipArchiveEntry.DEFLATED);\n                                      zos.putArchiveEntry(zae);\n                                      for (int j = 0;\n                                          a.close();\n                                      }\n                                  }\n-                             },\n+        };\n+    }\n+\n+    @Ignore\n+    @Test public void writeBigDeflatedEntryKnownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\",\n+                             writeBigDeflatedEntryToFile(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToFile()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFile\",\n+                             writeBigDeflatedEntryToFile(false),\n                              true);\n     }\n ", "timestamp": 1312139361, "metainfo": ""}