{"sha": "3502040234235cd85150617e754e558b925a6006", "log": "Javadoc fixes  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n \n     /**\n      * Get the date of this dump.\n-     * @return\n+     * @return the date of this dump.\n      */\n     public Date getDumpDate() {\n         return dumpDate;\n \n     /**\n      * Get volume (tape) number.\n-     * @return\n+     * @return volume (tape) number.\n      */\n     public int getVolume() {\n         return volume;\n      * 'n' this dump contains all files that have changed since the last dump\n      * at this level or lower. This is used to support different levels of\n      * incremental backups.\n-     * @return\n+     * @return dump level\n      */\n     public int getLevel() {\n         return level;\n     /**\n      * Get dump label. This may be autogenerated or it may be specified\n      * bu the user.\n-     * @return\n+     * @return dump label\n      */\n     public String getLabel() {\n         return label;\n \n     /**\n      * Get the last mountpoint, e.g., /home.\n-     * @return\n+     * @return last mountpoint\n      */\n     public String getFilesystem() {\n         return filesys;\n \n     /**\n      * Get the device name, e.g., /dev/sda3 or /dev/mapper/vg0-home.\n-     * @return\n+     * @return device name\n      */\n     public String getDevname() {\n         return devname;\n \n     /**\n      * Get the hostname of the system where the dump was performed.\n-     * @return\n+     * @return hostname\n      */\n     public String getHostname() {\n         return hostname;\n \n     /**\n      * Get the miscellaneous flags. See below.\n-     * @return\n+     * @return flags\n      */\n     public int getFlags() {\n         return flags;\n \n     /**\n      * Get the inode of the first record on this volume.\n-     * @return\n+     * @return inode of the first record on this volume.\n      */\n     public int getFirstRecord() {\n         return firstrec;\n     /**\n      * Get the number of records per tape block. This is typically\n      * between 10 and 32.\n-     * @return\n+     * @return the number of records per tape block\n      */\n     public int getNTRec() {\n         return ntrec;\n      * Is this the new header format? (We do not currently support the\n      * old format.)\n      *\n-     * @return\n+     * @return true if using new header format\n      */\n     public boolean isNewHeader() {\n         return (flags & 0x0001) == 0x0001;\n     /**\n      * Is this the new inode format? (We do not currently support the\n      * old format.)\n-     * @return\n+     * @return true if using new inode format\n      */\n     public boolean isNewInode() {\n         return (flags & 0x0002) == 0x0002;\n     /**\n      * Is this volume compressed? N.B., individual blocks may or may not be compressed.\n      * The first block is never compressed.\n-     * @return\n+     * @return true if volume is compressed\n      */\n     public boolean isCompressed() {\n         return (flags & 0x0080) == 0x0080;\n \n     /**\n      * Does this volume only contain metadata?\n-     * @return\n+     * @return true if volume only contains meta-data\n      */\n     public boolean isMetaDataOnly() {\n         return (flags & 0x0100) == 0x0100;\n \n     /**\n      * Does this volume cotain extended attributes.\n-     * @return\n+     * @return true if volume cotains extended attributes.\n      */\n     public boolean isExtendedAttributes() {\n         return (flags & 0x8000) == 0x8000;\n     }\n \n     /**\n-     * @see java.lang.hashCode()\n+     * @see java.lang.Object#hashCode()\n      */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n      * dump archive's actual block size since compression is handled at the\n      * block level.\n      *\n-     * @param blockSize\n-     *            actual blockSize according to dump archive\n+     * @param recsPerBlock\n+     *            records per block\n      * @param isCompressed\n      *            true if the archive is compressed\n      * @throws IOException\n     }\n \n     /**\n-     * {@see java.io.InputStream#available}\n+     * @see java.io.InputStream#available\n      */\n     @Override\n     public int available() throws IOException {\n     }\n \n     /**\n-     * {@see java.io.InputStream#read()\n+     * @see java.io.InputStream#read()\n      */\n     @Override\n     public int read() throws IOException {\n     }\n \n     /**\n-     * {@see java.io.InputStream#read(byte[], int, int) }\n+     * @see java.io.InputStream#read(byte[], int, int)\n      */\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n \n     /**\n      * Skip bytes. Same as read but without the arraycopy.\n-     * {@see java.io.InputStream#read(byte[], int, int) }\n+     * @see java.io.InputStream#read(byte[], int, int)\n      */\n     @Override\n     public long skip(long len) throws IOException {", "timestamp": 1313421810, "metainfo": ""}