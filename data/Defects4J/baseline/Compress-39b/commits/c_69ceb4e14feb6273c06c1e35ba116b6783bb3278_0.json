{"sha": "69ceb4e14feb6273c06c1e35ba116b6783bb3278", "log": "infrastructure for non-ASCII encoding of file names in tar.  COMPRESS-183  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n package org.apache.commons.compress.archivers.tar;\n \n import java.io.File;\n+import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.Date;\n import java.util.Locale;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n \n /**\n  * This class represents an entry in a Tar archive. It consists\n     /**\n      * Construct an empty entry and prepares the header values.\n      */\n-    private TarArchiveEntry () {\n+    private TarArchiveEntry() {\n         this.magic = MAGIC_POSIX;\n         this.version = VERSION_POSIX;\n         this.name = \"\";\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n      */\n     public TarArchiveEntry(byte[] headerBuf) {\n+        this(headerBuf, null);\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @param encoding encoding to use for file names\n+     * @since Commons Compress 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n+     */\n+    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding) {\n         this();\n-        parseTarHeader(headerBuf);\n+        try {\n+            parseTarHeader(headerBuf, encoding);\n+        } catch (IOException ex) {\n+            try {\n+                parseTarHeader(headerBuf, encoding, true);\n+            } catch (IOException ex2) {\n+                // impossible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n     }\n \n     /**\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n      */\n     public void parseTarHeader(byte[] header) {\n+        try {\n+            parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n+        } catch (IOException ex) {\n+            try {\n+                parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n+            } catch (IOException ex2) {\n+                // not really possible\n+                throw new RuntimeException(ex2);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse an entry's header information from a header buffer.\n+     *\n+     * @param header The tar entry header buffer to get information from.\n+     * @param encoding encoding to use for file names\n+     * @since Commons Compress 1.4\n+     * @throws IllegalArgumentException if any of the numeric fields\n+     * have an invalid format\n+     */\n+    public void parseTarHeader(byte[] header, ZipEncoding encoding)\n+        throws IOException {\n+        parseTarHeader(header, encoding, false);\n+    }\n+\n+    private void parseTarHeader(byte[] header, ZipEncoding encoding,\n+                                final boolean oldStyle)\n+        throws IOException {\n         int offset = 0;\n \n-        name = TarUtils.parseName(header, offset, NAMELEN);\n+        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n         offset += NAMELEN;\n         mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n         offset += MODELEN;\n         offset += MODTIMELEN;\n         offset += CHKSUMLEN;\n         linkFlag = header[offset++];\n-        linkName = TarUtils.parseName(header, offset, NAMELEN);\n+        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n+            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n         offset += NAMELEN;\n         magic = TarUtils.parseName(header, offset, MAGICLEN);\n         offset += MAGICLEN;\n         version = TarUtils.parseName(header, offset, VERSIONLEN);\n         offset += VERSIONLEN;\n-        userName = TarUtils.parseName(header, offset, UNAMELEN);\n+        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n+            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n         offset += UNAMELEN;\n-        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n+        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n+            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n         offset += GNAMELEN;\n         devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n         offset += DEVLEN;\n         }\n         case FORMAT_POSIX:\n         default: {\n-            String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n+            String prefix = oldStyle\n+                ? TarUtils.parseName(header, offset, PREFIXLEN)\n+                : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n             // SunOS tar -E does not add / to directory names, so fix\n             // up to be consistent\n             if (isDirectory() && !name.endsWith(\"/\")){\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.utils.ArchiveUtils;\n \n /**\n     private byte[] readBuf;\n     protected final TarBuffer buffer;\n     private TarArchiveEntry currEntry;\n+    private final ZipEncoding encoding;\n \n     /**\n      * Constructor for TarInputStream.\n      */\n     public TarArchiveInputStream(InputStream is) {\n         this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveInputStream(InputStream is, String encoding) {\n+        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE, encoding);\n     }\n \n     /**\n      */\n     public TarArchiveInputStream(InputStream is, int blockSize) {\n         this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     * @param blockSize the block size to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveInputStream(InputStream is, int blockSize,\n+                                 String encoding) {\n+        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE, encoding);\n     }\n \n     /**\n      * @param recordSize the record size to use\n      */\n     public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n+        this(is, blockSize, recordSize, null);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\n+                                 String encoding) {\n         this.buffer = new TarBuffer(is, blockSize, recordSize);\n         this.readBuf = null;\n         this.hasHitEOF = false;\n+        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n     }\n \n     /**\n         }\n \n         try {\n-            currEntry = new TarArchiveEntry(headerBuf);\n+            currEntry = new TarArchiveEntry(headerBuf, encoding);\n         } catch (IllegalArgumentException e) {\n             IOException ioe = new IOException(\"Error detected parsing the header\");\n             ioe.initCause(e);\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n import java.util.Map;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.utils.ArchiveUtils;\n import org.apache.commons.compress.utils.CountingOutputStream;\n \n     \n     private final OutputStream out;\n \n+    private final ZipEncoding encoding;\n+\n     /**\n      * Constructor for TarInputStream.\n      * @param os the output stream to use\n      */\n     public TarArchiveOutputStream(OutputStream os) {\n         this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveOutputStream(OutputStream os, String encoding) {\n+        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE, encoding);\n     }\n \n     /**\n      */\n     public TarArchiveOutputStream(OutputStream os, int blockSize) {\n         this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveOutputStream(OutputStream os, int blockSize,\n+                                  String encoding) {\n+        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE, encoding);\n     }\n \n     /**\n      * @param recordSize the record size to use\n      */\n     public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n+        this(os, blockSize, recordSize, null);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     */\n+    public TarArchiveOutputStream(OutputStream os, int blockSize,\n+                                  int recordSize, String encoding) {\n         out = new CountingOutputStream(os);\n+        this.encoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         this.buffer = new TarBuffer(out, blockSize, recordSize);\n         this.assemLen = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n  */\n package org.apache.commons.compress.archivers.tar;\n \n+import java.io.IOException;\n import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import org.apache.commons.compress.archivers.zip.ZipEncoding;\n+import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n \n /**\n  * This class provides static utility methods to work with byte streams.\n public class TarUtils {\n \n     private static final int BYTE_MASK = 255;\n+\n+    static final ZipEncoding DEFAULT_ENCODING =\n+        ZipEncodingHelper.getZipEncoding(null);\n \n     /** Private constructor to prevent instantiation of this utility class. */\n     private TarUtils(){    \n      * @return The entry name.\n      */\n     public static String parseName(byte[] buffer, final int offset, final int length) {\n+        try {\n+            return parseName(buffer, offset, length, DEFAULT_ENCODING);\n+        } catch (IOException ex) {\n+            return parseNameFallback(buffer, offset, length);\n+        }\n+    }\n+\n+    /*\n+     * Used if default encoding cannot encode name and no explicit\n+     * encoding has been specified.\n+     */\n+    private static String parseNameFallback(byte[] buffer, final int offset,\n+                                            final int length) {\n         StringBuffer result = new StringBuffer(length);\n         int          end = offset + length;\n \n         }\n \n         return result.toString();\n+    }\n+\n+    /**\n+     * Parse an entry name from a buffer.\n+     * Parsing stops when a NUL is found\n+     * or the buffer length is reached.\n+     *\n+     * @param buffer The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The maximum number of bytes to parse.\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n+     * @return The entry name.\n+     */\n+    public static String parseName(byte[] buffer, final int offset,\n+                                   final int length,\n+                                   final ZipEncoding encoding)\n+        throws IOException {\n+\n+        int len = length;\n+        for (; len > 0; len--) {\n+            if (buffer[offset + len - 1] != 0) {\n+                break;\n+            }\n+        }\n+        if (len > 0) {\n+            byte[] b = new byte[len];\n+            System.arraycopy(buffer, offset, b, 0, len);\n+            return encoding.decode(b);\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Copy a name into a buffer.\n+     * Copies characters from the name into the buffer\n+     * starting at the specified offset. \n+     * If the buffer is longer than the name, the buffer\n+     * is filled with trailing NULs.\n+     * If the name is longer than the buffer,\n+     * the output is truncated.\n+     *\n+     * @param name The header name from which to copy the characters.\n+     * @param buf The buffer where the name is to be stored.\n+     * @param offset The starting offset into the buffer\n+     * @param length The maximum number of header bytes to copy.\n+     * @return The updated offset, i.e. offset + length\n+     */\n+    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n+        try {\n+            return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n+        } catch (IOException ex) {\n+            return formatNameBytesFallback(name, buf, offset, length);\n+        }\n+    }\n+\n+    /*\n+     * Used if default encoding cannot format name and no explicit encoding\n+     * has been specified.\n+     */\n+    private static int formatNameBytesFallback(String name, byte[] buf,\n+                                               final int offset,\n+                                               final int length) {\n+        int i;\n+\n+        // copy until end of input or output is reached.\n+        for (i = 0; i < length && i < name.length(); ++i) {\n+            buf[offset + i] = (byte) name.charAt(i);\n+        }\n+\n+        // Pad any remaining output bytes with NUL\n+        for (; i < length; ++i) {\n+            buf[offset + i] = 0;\n+        }\n+\n+        return offset + length;\n     }\n \n     /**\n      * @param buf The buffer where the name is to be stored.\n      * @param offset The starting offset into the buffer\n      * @param length The maximum number of header bytes to copy.\n+     * @param encoding name of the encoding to use for file names\n+     * @since Commons Compress 1.4\n      * @return The updated offset, i.e. offset + length\n      */\n-    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n-        int i;\n-\n-        // copy until end of input or output is reached.\n-        for (i = 0; i < length && i < name.length(); ++i) {\n-            buf[offset + i] = (byte) name.charAt(i);\n-        }\n+    public static int formatNameBytes(String name, byte[] buf, final int offset,\n+                                      final int length,\n+                                      final ZipEncoding encoding)\n+        throws IOException {\n+        int len = name.length();\n+        ByteBuffer b = encoding.encode(name);\n+        while (b.limit() > length && len > 0) {\n+            b = encoding.encode(name.substring(0, --len));\n+        }\n+        final int limit = b.limit();\n+        System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\n \n         // Pad any remaining output bytes with NUL\n-        for (; i < length; ++i) {\n+        for (int i = limit; i < length; ++i) {\n             buf[offset + i] = 0;\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncoding.java\n  * <p>All implementations should implement this interface in a\n  * reentrant way.</p>\n  */\n-interface ZipEncoding {\n+public interface ZipEncoding {\n     /**\n      * Check, whether the given string may be losslessly encoded using this\n      * encoding.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n /**\n  * Static helper functions for robustly encoding filenames in zip files. \n  */\n-abstract class ZipEncodingHelper {\n+public abstract class ZipEncodingHelper {\n \n     /**\n      * A class, which holds the high characters of a simple encoding\n      *             the platform's default encoding.\n      * @return A zip encoding for the given encoding name.\n      */\n-    static ZipEncoding getZipEncoding(String name) {\n+    public static ZipEncoding getZipEncoding(String name) {\n  \n         // fallback encoding is good enough for utf-8.\n         if (isUTF8(name)) {\n--- a/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n     public void testCOMPRESS114() throws Exception {\n         final File input = getFile(\"COMPRESS-114.tar\");\n         final InputStream is = new FileInputStream(input);\n-        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n+        final ArchiveInputStream in = new TarArchiveInputStream(is,\n+                                                                \"iso-8859-1\");\n         TarArchiveEntry entry = (TarArchiveEntry)in.getNextEntry();\n         assertEquals(\"3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\n         entry = (TarArchiveEntry)in.getNextEntry();", "timestamp": 1332091011, "metainfo": ""}