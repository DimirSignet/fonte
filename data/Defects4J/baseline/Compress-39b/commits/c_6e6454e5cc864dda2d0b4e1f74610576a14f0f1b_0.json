{"sha": "6e6454e5cc864dda2d0b4e1f74610576a14f0f1b", "log": "write ZIP64 end of central directory if anything has used ZIP64.  Right now this means never.  COMPRESS-150.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n import static org.apache.commons.compress.archivers.zip.ZipConstants.BYTE_MASK;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DEFLATE_MIN_VERSION;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION;\n \n /**\n  * Reimplementation of {@link java.util.zip.ZipOutputStream\n     /**\n      * Holds the offsets of the LFH starts for each entry.\n      */\n-    private final Map<ZipArchiveEntry, byte[]> offsets =\n-        new HashMap<ZipArchiveEntry, byte[]>();\n+    private final Map<ZipArchiveEntry, Long> offsets =\n+        new HashMap<ZipArchiveEntry, Long>();\n \n     /**\n      * The encoding to use for filenames and the file comment.\n      * whether to create UnicodePathExtraField-s for each entry.\n      */\n     private UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\n+\n+    /**\n+     * Whether anything inside this archive has used a ZIP64 feature.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean hasUsedZip64 = false;\n \n     /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n             writeCentralFileHeader(ze);\n         }\n         cdLength = written - cdOffset;\n+        writeZip64CentralDirectory();\n         writeCentralDirectoryEnd();\n         offsets.clear();\n         entries.clear();\n      * end of central dir signature\n      */\n     static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n+    /**\n+     * ZIP64 end of central dir signature\n+     */\n+    static final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L);\n+    /**\n+     * ZIP64 end of central dir locator signature\n+     */\n+    static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L);\n \n     /**\n      * Writes next block of compressed data to the output stream.\n             }\n         }\n \n-        offsets.put(ze, ZipLong.getBytes(written));\n+        offsets.put(ze, Long.valueOf(written));\n \n         writeOut(LFH_SIG);\n         written += WORD;\n \n         // version made by\n         // CheckStyle:MagicNumber OFF\n-        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n+        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n+                                   (!hasUsedZip64 ? DEFLATE_MIN_VERSION\n+                                                  : ZIP64_MIN_VERSION)));\n         written += SHORT;\n \n         final int zipMethod = ze.getMethod();\n         written += WORD;\n \n         // relative offset of LFH\n-        writeOut(offsets.get(ze));\n+        writeOut(ZipLong.getBytes(offsets.get(ze).longValue()));\n         written += WORD;\n \n         // file name\n         ByteBuffer data = this.zipEncoding.encode(comment);\n         writeOut(ZipShort.getBytes(data.limit()));\n         writeOut(data.array(), data.arrayOffset(), data.limit());\n+    }\n+\n+    private static final byte[] ONE = ZipLong.getBytes(1L);\n+\n+    /**\n+     * Writes the &quot;ZIP64 End of central dir record&quot; and &quot;ZIP64 End of central dir locator&quot;.\n+     * @throws IOException on error\n+     * @since Apache Commons Compress 1.3\n+     */\n+    protected void writeZip64CentralDirectory() throws IOException {\n+        if (!hasUsedZip64) {\n+            return;\n+        }\n+\n+        long offset = written;\n+\n+        writeOut(ZIP64_EOCD_SIG);\n+        // size, we don't have any variable length as we don't support\n+        // the extensible data sector, yet\n+        writeOut(ZipEightByteInteger\n+                 .getBytes(SHORT   /* version made by */\n+                           + SHORT /* version needed to extract */\n+                           + WORD  /* disk number */\n+                           + WORD  /* disk with central directory */\n+                           + DWORD /* number of entries in CD on this disk */\n+                           + DWORD /* total number of entries */\n+                           + DWORD /* size of CD */\n+                           + DWORD /* offset of CD */\n+                           ));\n+\n+        // version made by and version needed to extract\n+        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n+        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n+\n+        // disk numbers - four bytes this time\n+        writeOut(LZERO);\n+        writeOut(LZERO);\n+\n+        // number of entries\n+        byte[] num = ZipEightByteInteger.getBytes(entries.size());\n+        writeOut(num);\n+        writeOut(num);\n+\n+        // length and location of CD\n+        writeOut(ZipEightByteInteger.getBytes(cdLength));\n+        writeOut(ZipEightByteInteger.getBytes(cdOffset));\n+\n+        // no \"zip64 extensible data sector\" for now\n+\n+        // and now the \"ZIP64 end of central directory locator\"\n+        writeOut(ZIP64_EOCD_LOC_SIG);\n+\n+        // disk number holding the ZIP64 EOCD record\n+        writeOut(LZERO);\n+        // relative offset of ZIP64 EOCD record\n+        writeOut(ZipEightByteInteger.getBytes(offset));\n+        // total number of disks\n+        writeOut(ONE);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipConstants.java\n     /** length of a ZipEightByteInteger in bytes */\n     static final int DWORD = 8;\n \n+    /** ZIP specification version that introduced DEFLATE method */\n+    static final int DEFLATE_MIN_VERSION = 20;\n+\n     /** ZIP specification version that introduced ZIP64 */\n     static final int ZIP64_MIN_VERSION = 45;\n }", "timestamp": 1311869593, "metainfo": ""}