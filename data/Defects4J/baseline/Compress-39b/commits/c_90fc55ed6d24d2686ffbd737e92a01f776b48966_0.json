{"sha": "90fc55ed6d24d2686ffbd737e92a01f776b48966", "log": "COMPRESS-147 initial SnappyDecompressor by BELUGA BEHR  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyDecompressor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.snappy;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * This class implements Snappy decompression. Snappy is a LZ77-type compressor\n+ * with a fixed, byte-oriented encoding created by Google(tm). It is originally\n+ * based on text by Zeev Tarantov. This approach works by allocating a buffer 3x\n+ * the compression block size. As the stream is decompressed, it is written to\n+ * the buffer. When the buffer becomes 2/3 full, the first third is flushed to\n+ * the underlying stream and the following bytes are all shifted down the array.\n+ * In this way, there is always at least one block-size of buffer available for\n+ * back-references.\n+ */\n+public class SnappyDecompressor {\n+\n+    /** Mask used to determine the type of \"tag\" is being processed */\n+    private static final int TAG_MASK = 0x03;\n+\n+    /** Default block size */\n+    public static final int BLOCK_SIZE = 32768;\n+\n+    /** Buffer to write decompressed bytes to for back-references */\n+    private final byte[] decompressBuf;\n+\n+    /** The index of the next byte in the buffer to write to */\n+    private int decompressBufIndex;\n+\n+    /** The actual block size specified */\n+    protected final int blockSize;\n+\n+    /** The underlying stream to read compressed data from */\n+    protected final InputStream in;\n+\n+    /** The size of the uncompressed data */\n+    protected final int size;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param buf\n+     *            An array of compressed data\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyDecompressor(final byte[] buf) throws IOException {\n+        this(new ByteArrayInputStream(buf), BLOCK_SIZE);\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param buf\n+     *            An array of compressed data\n+     * @param blockSize\n+     *            The block size used in compression\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyDecompressor(final byte[] buf, int blockSize)\n+            throws IOException {\n+        this(new ByteArrayInputStream(buf), blockSize);\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param is\n+     *            An InputStream to read compressed data from\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyDecompressor(final InputStream is) throws IOException {\n+        this(is, BLOCK_SIZE);\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param is\n+     *            An InputStream to read compressed data from\n+     * @param blockSize\n+     *            The block size used in compression\n+     * \n+     * @throws IOException\n+     */\n+    public SnappyDecompressor(final InputStream is, final int blockSize)\n+            throws IOException {\n+\n+        this.in = is;\n+        this.blockSize = blockSize;\n+        this.decompressBuf = new byte[blockSize * 3];\n+        this.decompressBufIndex = 0;\n+        this.size = (int) readSize();\n+    }\n+\n+    /**\n+     * Decompress the stream into an OutputStream\n+     * \n+     * @param os\n+     *            The OutputStream to write the decompressed data\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs. In particular, an\n+     *             <code>IOException</code> is thrown if the output stream is\n+     *             closed or the EOF is reached unexpectedly.\n+     */\n+    public void decompress(final OutputStream os) throws IOException {\n+\n+        int uncompressedSizeLength = getSize();\n+\n+        while (uncompressedSizeLength > 0) {\n+            final int b = readOneByte();\n+            int length = 0;\n+            int offset = 0;\n+\n+            switch (b & TAG_MASK) {\n+\n+            case 0x00:\n+\n+                /*\n+                 * For literals up to and including 60 bytes in length, the\n+                 * upper six bits of the tag byte contain (len-1). The literal\n+                 * follows immediately thereafter in the bytestream. - For\n+                 * longer literals, the (len-1) value is stored after the tag\n+                 * byte, little-endian. The upper six bits of the tag byte\n+                 * describe how many bytes are used for the length; 60, 61, 62\n+                 * or 63 for 1-4 bytes, respectively. The literal itself follows\n+                 * after the length.\n+                 */\n+\n+                switch (b >> 2) {\n+                case 60:\n+                    length = readOneByte();\n+                    break;\n+                case 61:\n+                    length = readOneByte();\n+                    length |= (readOneByte() << 8);\n+                    break;\n+                case 62:\n+                    length = readOneByte();\n+                    length |= (readOneByte() << 8);\n+                    length |= (readOneByte() << 16);\n+                    break;\n+                case 63:\n+                    length = readOneByte();\n+                    length |= (readOneByte() << 8);\n+                    length |= (readOneByte() << 16);\n+                    length |= (readOneByte() << 24);\n+                    break;\n+                default:\n+                    length = b >> 2;\n+                    break;\n+                }\n+\n+                length += 1;\n+\n+                if (expandLiteral(length)) {\n+                    flushDecompressBuffer(os);\n+                }\n+                break;\n+\n+            case 0x01:\n+\n+                /*\n+                 * These elements can encode lengths between [4..11] bytes and\n+                 * offsets between [0..2047] bytes. (len-4) occupies three bits\n+                 * and is stored in bits [2..4] of the tag byte. The offset\n+                 * occupies 11 bits, of which the upper three are stored in the\n+                 * upper three bits ([5..7]) of the tag byte, and the lower\n+                 * eight are stored in a byte following the tag byte.\n+                 */\n+\n+                length = 4 + ((b >> 2) & 0x07);\n+                offset = (b & 0xE0) << 3;\n+                offset |= readOneByte();\n+\n+                if (expandCopy(offset, length)) {\n+                    flushDecompressBuffer(os);\n+                }\n+                break;\n+\n+            case 0x02:\n+\n+                /*\n+                 * These elements can encode lengths between [1..64] and offsets\n+                 * from [0..65535]. (len-1) occupies six bits and is stored in\n+                 * the upper six bits ([2..7]) of the tag byte. The offset is\n+                 * stored as a little-endian 16-bit integer in the two bytes\n+                 * following the tag byte.\n+                 */\n+\n+                length = (b >> 2) + 1;\n+\n+                offset = readOneByte();\n+                offset |= readOneByte() << 8;\n+\n+                if (expandCopy(offset, length)) {\n+                    flushDecompressBuffer(os);\n+                }\n+                break;\n+\n+            case 0x03:\n+\n+                /*\n+                 * These are like the copies with 2-byte offsets (see previous\n+                 * subsection), except that the offset is stored as a 32-bit\n+                 * integer instead of a 16-bit integer (and thus will occupy\n+                 * four bytes).\n+                 */\n+\n+                length = (b >> 2) + 1;\n+\n+                offset = readOneByte();\n+                offset |= readOneByte() << 8;\n+                offset |= readOneByte() << 16;\n+                offset |= readOneByte() << 24;\n+\n+                if (expandCopy(offset, length)) {\n+                    flushDecompressBuffer(os);\n+                }\n+                break;\n+            }\n+\n+            uncompressedSizeLength -= length;\n+        }\n+        os.write(decompressBuf, 0, decompressBufIndex);\n+    }\n+\n+    /**\n+     * Flush the first block of the decompression buffer to the underlying out\n+     * stream. All subsequent bytes are moved down to the beginning of the\n+     * buffer.\n+     * \n+     * @param os\n+     *            The output stream to write to\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs. In particular, an\n+     *             <code>IOException</code> is thrown if the output stream is\n+     *             closed.\n+     */\n+    private void flushDecompressBuffer(final OutputStream os)\n+            throws IOException {\n+        os.write(decompressBuf, 0, this.blockSize);\n+        System.arraycopy(decompressBuf, BLOCK_SIZE, decompressBuf, 0,\n+                this.blockSize);\n+        decompressBufIndex -= this.blockSize;\n+    }\n+\n+    /**\n+     * Literals are uncompressed data stored directly in the byte stream.\n+     * \n+     * @param length\n+     *            The number of bytes to read from the underlying stream\n+     * \n+     * @throws IOException\n+     *             If the first byte cannot be read for any reason other than\n+     *             end of file, or if the input stream has been closed, or if\n+     *             some other I/O error occurs.\n+     * \n+     * @return True if the decompressed data should be flushed\n+     */\n+    private boolean expandLiteral(final int length) throws IOException {\n+        if (length != this.in.read(decompressBuf, decompressBufIndex, length)) {\n+            throw new IOException(\"Premature end of stream\");\n+        }\n+\n+        decompressBufIndex += length;\n+        return (decompressBufIndex >= (2 * this.blockSize));\n+    }\n+\n+    /**\n+     * Copies are references back into previous decompressed data, telling the\n+     * decompressor to reuse data it has previously decoded. They encode two\n+     * values: The offset, saying how many bytes back from the current position\n+     * to read, and the length, how many bytes to copy. Offsets of zero can be\n+     * encoded, but are not legal; similarly, it is possible to encode\n+     * backreferences that would go past the end of the block (offset > current\n+     * decompressed position), which is also nonsensical and thus not allowed.\n+     * \n+     * @param offset\n+     *            The offset from the backward from the end of expanded stream\n+     * @param length\n+     *            The number of bytes to copy\n+     * \n+     * @throws IOException\n+     *             An the offset expands past the front of the decompression\n+     *             buffer\n+     * @return True if the decompressed data should be flushed\n+     */\n+    private boolean expandCopy(final int offset, int length) throws IOException {\n+\n+        if (offset > blockSize) {\n+            throw new IOException(\"Offset is larger than block size\");\n+        }\n+\n+        if (offset == 1) {\n+            byte lastChar = decompressBuf[decompressBufIndex - 1];\n+            for (int i = 0; i < length; i++) {\n+                decompressBuf[decompressBufIndex++] = lastChar;\n+            }\n+        } else if (length < offset) {\n+            System.arraycopy(decompressBuf, decompressBufIndex - offset,\n+                    decompressBuf, decompressBufIndex, length);\n+            decompressBufIndex += length;\n+        } else {\n+            int fullRotations = length / offset;\n+            int pad = length - (offset * fullRotations);\n+\n+            while (fullRotations-- != 0) {\n+                System.arraycopy(decompressBuf, decompressBufIndex - offset,\n+                        decompressBuf, decompressBufIndex, offset);\n+                decompressBufIndex += offset;\n+            }\n+\n+            if (pad > 0) {\n+                System.arraycopy(decompressBuf, decompressBufIndex - offset,\n+                        decompressBuf, decompressBufIndex, pad);\n+\n+                decompressBufIndex += pad;\n+            }\n+        }\n+\n+        return (decompressBufIndex >= (2 * this.blockSize));\n+    }\n+\n+    /**\n+     * This helper method reads the next byte of data from the input stream. The\n+     * value byte is returned as an <code>int</code> in the range <code>0</code>\n+     * to <code>255</code>. If no byte is available because the end of the\n+     * stream has been reached, an Exception is thrown.\n+     * \n+     * @return The next byte of data\n+     * @throws IOException\n+     *             EOF is reached or error reading the stream\n+     */\n+    private int readOneByte() throws IOException {\n+        int b = in.read();\n+        if (b == -1) {\n+            throw new IOException(\"Premature end of stream\");\n+        }\n+        return b & 0xFF;\n+    }\n+\n+    /**\n+     * The stream starts with the uncompressed length (up to a maximum of 2^32 -\n+     * 1), stored as a little-endian varint. Varints consist of a series of\n+     * bytes, where the lower 7 bits are data and the upper bit is set iff there\n+     * are more bytes to be read. In other words, an uncompressed length of 64\n+     * would be stored as 0x40, and an uncompressed length of 2097150 (0x1FFFFE)\n+     * would be stored as 0xFE 0xFF 0x7F.\n+     * \n+     * @return The size of the uncompressed data\n+     * \n+     * @throws IOException\n+     *             Could not read a byte\n+     */\n+    private long readSize() throws IOException {\n+        int index = 0;\n+        long sz = 0;\n+        int b = 0;\n+\n+        do {\n+            b = readOneByte();\n+            sz |= (b & 0x7f) << (index++ * 7);\n+        } while (0 != (b & 0x80));\n+        return sz;\n+    }\n+\n+    /**\n+     * Get the uncompressed size of the stream\n+     * \n+     * @return the uncompressed size\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+}", "timestamp": 1383925456, "metainfo": ""}