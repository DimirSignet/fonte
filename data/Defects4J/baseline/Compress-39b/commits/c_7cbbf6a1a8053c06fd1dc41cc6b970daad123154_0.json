{"sha": "7cbbf6a1a8053c06fd1dc41cc6b970daad123154", "log": "whitespace only  ", "commit": "\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n      */\n     private static ZipOutputTest writeBigDeflatedEntryToFile(final boolean knownSize) {\n         return new ZipOutputTest() {\n-                                 public void test(File f,\n-                                                  ZipArchiveOutputStream zos)\n-                                     throws IOException {\n-                                     byte[] buf = new byte[1000 * 1000];\n-                                     ZipArchiveEntry zae =\n-                                         new ZipArchiveEntry(\"0\");\n-                                     if (knownSize) {\n-                                     zae.setSize(FIVE_BILLION);\n-                                     }\n-                                     zae.setMethod(ZipArchiveEntry.DEFLATED);\n-                                     zos.putArchiveEntry(zae);\n-                                     for (int j = 0;\n-                                          j < FIVE_BILLION / 1000 / 1000;\n-                                          j++) {\n-                                         zos.write(buf);\n-                                     }\n-                                     zos.closeArchiveEntry();\n-                                     zos.close();\n-\n-                                     RandomAccessFile a =\n-                                         new RandomAccessFile(f, \"r\");\n-                                     try {\n-                                         final long end =\n-                                             getLengthAndPositionAtCentralDirectory(a);\n-\n-                                         long cfhPos = a.getFilePointer();\n-                                         // grab first entry, verify\n-                                         // sizes are 0xFFFFFFFF and\n-                                         // it has a ZIP64 extended\n-                                         // information extra field\n-                                         byte[] header = new byte[12];\n-                                         a.readFully(header);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // sig\n-                                                 (byte) 0x50, (byte) 0x4b, 1, 2,\n-                                                 // version made by\n-                                                 45, 0,\n-                                                 // version needed to extract\n-                                                 45, 0,\n-                                                 // GPB (EFS + *no* Data\n-                                                 //            Descriptor)\n-                                                 0, 8,\n-                                                 // method\n-                                                 8, 0,\n-                                             }, header);\n-                                         // ignore timestamp\n-                                         a.skipBytes(4);\n-                                         byte[] rest = new byte[31];\n-                                         a.readFully(rest);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // CRC\n-                                                 (byte) 0x50, (byte) 0x6F,\n-                                                 (byte) 0x31, (byte) 0x5c,\n-                                                 // Compressed Size\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 // Original Size\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 // file name length\n-                                                 1, 0,\n-                                                 // extra field length\n-                                                 20, 0,\n-                                                 // comment length\n-                                                 0, 0,\n-                                                 // disk number\n-                                                 0, 0,\n-                                                 // attributes\n-                                                 0, 0,\n-                                                 0, 0, 0, 0,\n-                                                 // offset\n-                                                 0, 0, 0, 0,\n-                                                 // file name\n-                                                 (byte) '0'\n-                                             }, rest);\n-                                         byte[] extra = new byte[12];\n-                                         a.readFully(extra);\n-                                         // 5e9 == 0x12A05F200\n-                                         assertArrayEquals(new byte[] {\n-                                                 // Header-ID\n-                                                 1, 0,\n-                                                 // size of extra\n-                                                 16, 0,\n-                                                 // original size\n-                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n-                                                 1, 0, 0, 0,\n-                                                 // don't know the\n-                                                 // compressed size,\n-                                                 // don't want to\n-                                                 // hard-code it\n-                                             }, extra);\n-\n-                                         // and now validate local file header\n-                                         a.seek(0);\n-                                         header = new byte[10];\n-                                         a.readFully(header);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // sig\n-                                                 (byte) 0x50, (byte) 0x4b, 3, 4,\n-                                                 // version needed to extract\n-                                                 45, 0,\n-                                                 // GPB (EFS bit, no DD)\n-                                                 0, 8,\n-                                                 // method\n-                                                 8, 0,\n-                                             }, header);\n-                                         // ignore timestamp\n-                                         a.skipBytes(4);\n-                                         rest = new byte[17];\n-                                         a.readFully(rest);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // CRC\n-                                                 (byte) 0x50, (byte) 0x6F,\n-                                                 (byte) 0x31, (byte) 0x5c,\n-                                                 // Compressed Size\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 // Original Size\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 (byte) 0xFF, (byte) 0xFF,\n-                                                 // file name length\n-                                                 1, 0,\n-                                                 // extra field length\n-                                                 20, 0,\n-                                                 // file name\n-                                                 (byte) '0'\n-                                             }, rest);\n-                                         extra = new byte[12];\n-                                         a.readFully(extra);\n-                                         assertArrayEquals(new byte[] {\n-                                                 // Header-ID\n-                                                 1, 0,\n-                                                 // size of extra\n-                                                 16, 0,\n-                                                 // original size\n-                                                 0, (byte) 0xF2, 5, (byte) 0x2A,\n-                                                 1, 0, 0, 0,\n-                                                 // don't know the\n-                                                 // compressed size,\n-                                                 // don't want to\n-                                                 // hard-code it\n-                                             }, extra);\n-                                     } finally {\n-                                         a.close();\n-                                     }\n-                                 }\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                byte[] buf = new byte[1000 * 1000];\n+                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                if (knownSize) {\n+                    zae.setSize(FIVE_BILLION);\n+                }\n+                zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                zos.putArchiveEntry(zae);\n+                for (int j = 0;\n+                     j < FIVE_BILLION / 1000 / 1000;\n+                     j++) {\n+                    zos.write(buf);\n+                }\n+                zos.closeArchiveEntry();\n+                zos.close();\n+\n+                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                try {\n+                    final long end = getLengthAndPositionAtCentralDirectory(a);\n+\n+                    long cfhPos = a.getFilePointer();\n+                    // grab first entry, verify\n+                    // sizes are 0xFFFFFFFF and\n+                    // it has a ZIP64 extended\n+                    // information extra field\n+                    byte[] header = new byte[12];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 1, 2,\n+                            // version made by\n+                            45, 0,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS + *no* Data Descriptor)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    byte[] rest = new byte[31];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // comment length\n+                            0, 0,\n+                            // disk number\n+                            0, 0,\n+                            // attributes\n+                            0, 0,\n+                            0, 0, 0, 0,\n+                            // offset\n+                            0, 0, 0, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    byte[] extra = new byte[12];\n+                    a.readFully(extra);\n+                    // 5e9 == 0x12A05F200\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // don't know the\n+                            // compressed size,\n+                            // don't want to\n+                            // hard-code it\n+                        }, extra);\n+\n+                    // and now validate local file header\n+                    a.seek(0);\n+                    header = new byte[10];\n+                    a.readFully(header);\n+                    assertArrayEquals(new byte[] {\n+                            // sig\n+                            (byte) 0x50, (byte) 0x4b, 3, 4,\n+                            // version needed to extract\n+                            45, 0,\n+                            // GPB (EFS bit, no DD)\n+                            0, 8,\n+                            // method\n+                            8, 0,\n+                        }, header);\n+                    // ignore timestamp\n+                    a.skipBytes(4);\n+                    rest = new byte[17];\n+                    a.readFully(rest);\n+                    assertArrayEquals(new byte[] {\n+                            // CRC\n+                            (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c,\n+                            // Compressed Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // Original Size\n+                            (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,\n+                            // file name length\n+                            1, 0,\n+                            // extra field length\n+                            20, 0,\n+                            // file name\n+                            (byte) '0'\n+                        }, rest);\n+                    extra = new byte[12];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            16, 0,\n+                            // original size\n+                            0, (byte) 0xF2, 5, (byte) 0x2A,\n+                            1, 0, 0, 0,\n+                            // don't know the\n+                            // compressed size,\n+                            // don't want to\n+                            // hard-code it\n+                        }, extra);\n+                } finally {\n+                    a.close();\n+                }\n+            }\n         };\n     }\n ", "timestamp": 1312139525, "metainfo": ""}