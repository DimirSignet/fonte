{"sha": "008ca948dadacea8d1a2662c577fdcb25f32d5e2", "log": "support as much as possible of ZipFile as a stream can do in ZipArchiveInputStream, COMPRESS-47  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      */\n     public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n         super(entry);\n+        setName(entry.getName());\n         byte[] extra = entry.getExtra();\n         if (extra != null) {\n             setExtraFields(ExtraFieldUtils.parse(extra));\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.zip.ZipInputStream;\n+import java.io.PushbackInputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Inflater;\n+import java.util.zip.ZipException;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n public class ZipArchiveInputStream extends ArchiveInputStream {\n \n-    private final ZipInputStream input;\n+    private static final int SHORT = 2;\n+    private static final int WORD = 4;\n+\n+    /**\n+     * The zip encoding to use for filenames and the file comment.\n+     */\n+    private final ZipEncoding zipEncoding;\n+\n+    /**\n+     * Whether to look for and use Unicode extra fields.\n+     */\n+    private final boolean useUnicodeExtraFields;\n+\n+    private final InputStream in;\n+\n+    private final Inflater inf = new Inflater(true);\n+    private final CRC32 crc = new CRC32();\n+\n+    private final byte[] SINGLE = new byte[1];\n+    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n+\n+    private ZipArchiveEntry current = null;\n+    private boolean closed = false;\n+    private boolean hitCentralDirectory = false;\n+    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n+    private int bytesReadFromStream = 0;\n+    private int lengthOfLastRead = 0;\n+    private boolean hasDataDescriptor = false;\n+\n+    private static final int LFH_LEN = 30;\n+    /*\n+      local file header signature     4 bytes  (0x04034b50)\n+      version needed to extract       2 bytes\n+      general purpose bit flag        2 bytes\n+      compression method              2 bytes\n+      last mod file time              2 bytes\n+      last mod file date              2 bytes\n+      crc-32                          4 bytes\n+      compressed size                 4 bytes\n+      uncompressed size               4 bytes\n+      file name length                2 bytes\n+      extra field length              2 bytes\n+    */\n \n     public ZipArchiveInputStream(InputStream inputStream) {\n-        input = new ZipInputStream(inputStream);\n+        this(inputStream, ZipEncodingHelper.UTF8, true);\n+    }\n+\n+    /**\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n+     */\n+    public ZipArchiveInputStream(InputStream inputStream,\n+                                 String encoding,\n+                                 boolean useUnicodeExtraFields) {\n+        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        this.useUnicodeExtraFields = useUnicodeExtraFields;\n+        in = new PushbackInputStream(inputStream, buf.length);\n     }\n \n     public ZipArchiveEntry getNextZipEntry() throws IOException {\n-        java.util.zip.ZipEntry entry = input.getNextEntry();\n-        if(entry == null) {\n+        if (closed || hitCentralDirectory) {\n             return null;\n         }\n-        return new ZipArchiveEntry(entry);\n+        if (current != null) {\n+            closeEntry();\n+        }\n+        int x = 0, count = 0;\n+        byte[] lfh = new byte[LFH_LEN];\n+        try {\n+            readFully(lfh);\n+        } catch (EOFException e) {\n+            return null;\n+        }\n+        ZipLong sig = new ZipLong(lfh);\n+        if (sig.equals(ZipLong.CFH_SIG)) {\n+            hitCentralDirectory = true;\n+            return null;\n+        }\n+        if (!sig.equals(ZipLong.LFH_SIG)) {\n+            return null;\n+        }\n+\n+        int off = WORD;\n+        current = new ZipArchiveEntry();\n+\n+        int versionMadeBy = ZipShort.getValue(lfh, off);\n+        off += SHORT;\n+        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n+                            & ZipFile.NIBLET_MASK);\n+\n+        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n+        final boolean hasEFS = \n+            (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n+        final ZipEncoding entryEncoding =\n+            hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n+\n+        off += SHORT;\n+\n+        current.setMethod(ZipShort.getValue(lfh, off));\n+        off += SHORT;\n+\n+        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n+        current.setTime(time);\n+        off += WORD;\n+\n+        if (!hasDataDescriptor) {\n+            current.setCrc(ZipLong.getValue(lfh, off));\n+            off += WORD;\n+\n+            current.setCompressedSize(ZipLong.getValue(lfh, off));\n+            off += WORD;\n+\n+            current.setSize(ZipLong.getValue(lfh, off));\n+            off += WORD;\n+        } else {\n+            off += 3 * WORD;\n+        }\n+\n+        int fileNameLen = ZipShort.getValue(lfh, off);\n+\n+        off += SHORT;\n+\n+        int extraLen = ZipShort.getValue(lfh, off);\n+        off += SHORT;\n+\n+        byte[] fileName = new byte[fileNameLen];\n+        readFully(fileName);\n+        current.setName(entryEncoding.decode(fileName));\n+\n+        byte[] extraData = new byte[extraLen];\n+        readFully(extraData);\n+        current.setExtra(extraData);\n+\n+        ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n+\n+        return current;\n     }\n \n     public ArchiveEntry getNextEntry() throws IOException {\n         return getNextZipEntry();\n     }\n \n-    public int read(byte[] b, int off, int len) throws IOException {\n-        return input.read(b, off, len);\n+    public int read(byte[] buffer, int start, int length) throws IOException {\n+        if (closed) {\n+            throw new IOException(\"The stream is closed\");\n+        }\n+        if (inf.finished() || current == null) {\n+            return -1;\n+        }\n+\n+        // avoid int overflow, check null buffer\n+        if (start <= buffer.length && length >= 0 && start >= 0\n+            && buffer.length - start >= length) {\n+            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n+                int csize = (int) current.getSize();\n+                if (readBytesOfEntry >= csize) {\n+                    return -1;\n+                }\n+                if (offsetInBuffer >= lengthOfLastRead) {\n+                    offsetInBuffer = 0;\n+                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n+                        return -1;\n+                    }\n+                    bytesReadFromStream += lengthOfLastRead;\n+                }\n+                int toRead = length > lengthOfLastRead\n+                    ? lengthOfLastRead - offsetInBuffer\n+                    : length;\n+                if ((csize - readBytesOfEntry) < toRead) {\n+                    toRead = csize - readBytesOfEntry;\n+                }\n+                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n+                offsetInBuffer += toRead;\n+                readBytesOfEntry += toRead;\n+                crc.update(buffer, start, toRead);\n+                return toRead;\n+            }\n+            if (inf.needsInput()) {\n+                fill();\n+                if (lengthOfLastRead > 0) {\n+                    bytesReadFromStream += lengthOfLastRead;\n+                }\n+            }\n+            int read = 0;\n+            try {\n+                read = inf.inflate(buffer, start, length);\n+            } catch (DataFormatException e) {\n+                throw new ZipException(e.getMessage());\n+            }\n+            if (read == 0 && inf.finished()) {\n+                return -1;\n+            }\n+            crc.update(buffer, start, read);\n+            return read;\n+        }\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+\n+    public void close() throws IOException {\n+        if (!closed) {\n+            closed = true;\n+            in.close();\n+        }\n     }\n \n     public int read() throws IOException {\n-        return input.read();\n-    }\n-\n+        int num = read(SINGLE, 0, 1);\n+        return num == -1 ? -1 : SINGLE[0] & ZipArchiveOutputStream.BYTE_MASK;\n+    }\n+\n+    public long skip(long value) throws IOException {\n+        if (value >= 0) {\n+            long skipped = 0;\n+            byte[] b = new byte[1024];\n+            while (skipped != value) {\n+                long rem = value - skipped;\n+                int x = read(b, 0, (int) (b.length > rem ? rem : b.length));\n+                if (x == -1) {\n+                    return skipped;\n+                }\n+                skipped += x;\n+            }\n+            return skipped;\n+        }\n+        throw new IllegalArgumentException();\n+    }\n \n     public static boolean matches(byte[] signature, int length) {\n         if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n \n         return true;\n     }\n+\n+    private void closeEntry() throws IOException {\n+        if (closed) {\n+            throw new IOException(\"The stream is closed\");\n+        }\n+        if (current == null) {\n+            return;\n+        }\n+        // Ensure all entry bytes are read\n+        skip(Long.MAX_VALUE);\n+        int inB, out;\n+        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+            inB = inf.getTotalIn();\n+            out = inf.getTotalOut();\n+        } else {\n+            inB = readBytesOfEntry;\n+            out = readBytesOfEntry;\n+        }\n+        int diff = 0;\n+\n+        // Pushback any required bytes\n+        if ((diff = bytesReadFromStream - inB) != 0) {\n+            ((PushbackInputStream) in).unread(buf,\n+                                              lengthOfLastRead - diff, diff);\n+        }\n+\n+        if (hasDataDescriptor) {\n+            readFully(new byte[4 * WORD]);\n+        }\n+\n+        inf.reset();\n+        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =\n+            lengthOfLastRead = 0;\n+        crc.reset();\n+        current = null;\n+    }\n+\n+    private void fill() throws IOException {\n+        if (closed) {\n+            throw new IOException(\"The stream is closed\");\n+        }\n+        if ((lengthOfLastRead = in.read(buf)) > 0) {\n+            inf.setInput(buf, 0, lengthOfLastRead);\n+        }\n+    }\n+\n+    private void readFully(byte[] b) throws IOException {\n+        int count = 0, x = 0;\n+        while (count != b.length) {\n+            count += x = in.read(b, count, b.length - count);\n+            if (x == -1) {\n+                throw new EOFException();\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n  */\n public class ZipArchiveOutputStream extends ArchiveOutputStream {\n \n-    private static final int BYTE_MASK = 0xFF;\n+    static final int BYTE_MASK = 0xFF;\n     private static final int SHORT = 2;\n     private static final int WORD = 4;\n-    private static final int BUFFER_SIZE = 512;\n+    static final int BUFFER_SIZE = 512;\n     /* \n      * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n      * when it gets handed a really big buffer.  See\n     /**\n      * local file header signature\n      */\n-    static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);\n+    static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();\n     /**\n      * data descriptor signature\n      */\n     /**\n      * central file header signature\n      */\n-    static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);\n+    static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();\n     /**\n      * end of central dir signature\n      */\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.zip.CRC32;\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n import java.util.zip.ZipException;\n     private static final int HASH_SIZE = 509;\n     private static final int SHORT     =   2;\n     private static final int WORD      =   4;\n-    private static final int NIBLET_MASK = 0x0f;\n-    private static final int BYTE_SHIFT = 8;\n+    static final int NIBLET_MASK = 0x0f;\n+    static final int BYTE_SHIFT = 8;\n     private static final int POS_0 = 0;\n     private static final int POS_1 = 1;\n     private static final int POS_2 = 2;\n                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n \n             if (entriesWithoutEFS.containsKey(ze)) {\n-                setNameAndCommentFromExtraFields(ze,\n-                                                 (NameAndComment)\n-                                                 entriesWithoutEFS.get(ze));\n+                String orig = ze.getName();\n+                NameAndComment nc = (NameAndComment) entriesWithoutEFS.get(ze);\n+                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n+                                                         nc.comment);\n+                if (!orig.equals(ze.getName())) {\n+                    nameMap.remove(orig);\n+                    nameMap.put(ze.getName(), ze);\n+                }\n             }\n         }\n     }\n             }\n         }\n         return true;\n-    }\n-\n-    /**\n-     * If the entry has Unicode*ExtraFields and the CRCs of the\n-     * names/comments match those of the extra fields, transfer the\n-     * known Unicode values from the extra field.\n-     */\n-    private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\n-                                                  NameAndComment nc) {\n-        UnicodePathExtraField name = (UnicodePathExtraField)\n-            ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n-        String originalName = ze.getName();\n-        String newName = getUnicodeStringIfOriginalMatches(name, nc.name);\n-        if (newName != null && !originalName.equals(newName)) {\n-            ze.setName(newName);\n-            nameMap.remove(originalName);\n-            nameMap.put(newName, ze);\n-        }\n-\n-        if (nc.comment != null && nc.comment.length > 0) {\n-            UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\n-                ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n-            String newComment =\n-                getUnicodeStringIfOriginalMatches(cmt, nc.comment);\n-            if (newComment != null) {\n-                ze.setComment(newComment);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * If the stored CRC matches the one of the given name, return the\n-     * Unicode name of the given field.\n-     *\n-     * <p>If the field is null or the CRCs don't match, return null\n-     * instead.</p>\n-     */\n-    private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\n-                                                     byte[] orig) {\n-        if (f != null) {\n-            CRC32 crc32 = new CRC32();\n-            crc32.update(orig);\n-            long origCRC32 = crc32.getValue();\n-\n-            if (origCRC32 == f.getNameCRC32()) {\n-                try {\n-                    return ZipEncodingHelper\n-                        .UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n-                } catch (IOException ex) {\n-                    // UTF-8 unsupported?  should be impossible the\n-                    // Unicode*ExtraField must contain some bad bytes\n-\n-                    // TODO log this anywhere?\n-                    return null;\n-                }\n-            }\n-        }\n-        return null;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n     private static final int BYTE_3_SHIFT = 24;\n \n     private final long value;\n+\n+    public static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n+    public static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n \n     /**\n      * Create instance from a number.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.IOException;\n import java.util.Calendar;\n import java.util.Date;\n+import java.util.zip.CRC32;\n \n public abstract class ZipUtil {\n     /**\n         return cal.getTime().getTime();\n     }\n \n+    /**\n+     * If the entry has Unicode*ExtraFields and the CRCs of the\n+     * names/comments match those of the extra fields, transfer the\n+     * known Unicode values from the extra field.\n+     */\n+    static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\n+                                                 byte[] originalNameBytes,\n+                                                 byte[] commentBytes) {\n+        UnicodePathExtraField name = (UnicodePathExtraField)\n+            ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n+        String originalName = ze.getName();\n+        String newName = getUnicodeStringIfOriginalMatches(name,\n+                                                           originalNameBytes);\n+        if (newName != null && !originalName.equals(newName)) {\n+            ze.setName(newName);\n+        }\n+\n+        if (commentBytes != null && commentBytes.length > 0) {\n+            UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\n+                ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n+            String newComment =\n+                getUnicodeStringIfOriginalMatches(cmt, commentBytes);\n+            if (newComment != null) {\n+                ze.setComment(newComment);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If the stored CRC matches the one of the given name, return the\n+     * Unicode name of the given field.\n+     *\n+     * <p>If the field is null or the CRCs don't match, return null\n+     * instead.</p>\n+     */\n+    private static \n+        String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\n+                                                 byte[] orig) {\n+        if (f != null) {\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(orig);\n+            long origCRC32 = crc32.getValue();\n+\n+            if (origCRC32 == f.getNameCRC32()) {\n+                try {\n+                    return ZipEncodingHelper\n+                        .UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n+                } catch (IOException ex) {\n+                    // UTF-8 unsupported?  should be impossible the\n+                    // Unicode*ExtraField must contain some bad bytes\n+\n+                    // TODO log this anywhere?\n+                    return null;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n \n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n import java.net.URI;\n         }\n     }\n \n+    public void testRead7ZipArchiveForStream() throws IOException,\n+                                                      URISyntaxException {\n+        URL zip = getClass().getResource(\"/utf8-7zip-test.zip\");\n+        FileInputStream archive =\n+            new FileInputStream(new File(new URI(zip.toString())));\n+        ZipArchiveInputStream zi = null;\n+        try {\n+            zi = new ZipArchiveInputStream(archive, CP437, false);\n+            assertEquals(ASCII_TXT, zi.getNextEntry().getName());\n+            assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\n+            assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\n+        } finally {\n+            if (zi != null) {\n+                zi.close();\n+            }\n+        }\n+    }\n+\n     /*\n      * WinZIP created archive, uses Unicode Extra Fields but only in\n      * the central directory.\n         }\n     }\n \n+    public void testReadWinZipArchiveForStream() throws IOException,\n+                                                      URISyntaxException {\n+        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n+        FileInputStream archive =\n+            new FileInputStream(new File(new URI(zip.toString())));\n+        ZipArchiveInputStream zi = null;\n+        try {\n+            zi = new ZipArchiveInputStream(archive, null, true);\n+            assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\n+            assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\n+            assertEquals(ASCII_TXT, zi.getNextEntry().getName());\n+        } finally {\n+            if (zi != null) {\n+                zi.close();\n+            }\n+        }\n+    }\n+\n     public void testZipFileReadsUnicodeFields() throws IOException {\n+        File file = File.createTempFile(\"unicode-test\", \".zip\");\n+        ZipArchiveInputStream zi = null;\n+        try {\n+            createTestFile(file, US_ASCII, false, true);\n+            FileInputStream archive = new FileInputStream(file);\n+            zi = new ZipArchiveInputStream(archive, US_ASCII, true);\n+            assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\n+            assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\n+            assertEquals(ASCII_TXT, zi.getNextEntry().getName());\n+        } finally {\n+            if (zi != null) {\n+                zi.close();\n+            }\n+            if (file.exists()) {\n+                file.delete();\n+            }\n+        }\n+    }\n+\n+    public void testZipArchiveInputStreamReadsUnicodeFields()\n+        throws IOException {\n         File file = File.createTempFile(\"unicode-test\", \".zip\");\n         ZipFile zf = null;\n         try {", "timestamp": 1238106599, "metainfo": ""}