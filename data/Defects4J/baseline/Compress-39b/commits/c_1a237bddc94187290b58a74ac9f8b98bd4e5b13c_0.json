{"sha": "1a237bddc94187290b58a74ac9f8b98bd4e5b13c", "log": "COMPRESS-227 ensure ZipFile#getEntry only returns entries that will return non-null InputStreams in getInputStream.  nameMap isn't used before all local file headers are parsed so it is easier to only populate it then.  This not only ensure it only contains ZipArchiveEntries that are known to the entries map, it also simplifies the case where an entry's name changes due to extra fields.   ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n         // data offset will be filled later\n         entries.put(ze, offset);\n \n-        nameMap.put(ze.getName(), ze);\n-\n         byte[] cdExtraData = new byte[extraLen];\n         archive.readFully(cdExtraData);\n         ze.setCentralDirectoryExtra(cdExtraData);\n                 NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                          nc.comment);\n-                if (!orig.equals(ze.getName())) {\n-                    nameMap.remove(orig);\n-                    nameMap.put(ze.getName(), ze);\n-                }\n             }\n             entries.put(ze, offsetEntry);\n+            nameMap.put(ze.getName(), ze);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n         }\n     }\n \n+    public void XtestDuplicateEntry() throws Exception {\n+        File f = File.createTempFile(\"commons-compress-zipfiletest\", \".zip\");\n+        f.deleteOnExit();\n+        File f2 = File.createTempFile(\"commons-compress-zipfiletest\", \".txt\");\n+        f2.deleteOnExit();\n+\n+        OutputStream o = null;\n+        try {\n+            o = new FileOutputStream(f);\n+            ZipArchiveOutputStream zo = new ZipArchiveOutputStream(o);\n+            // simple way to ensure entries have extra data\n+            zo.setUseZip64(Zip64Mode.Always);\n+\n+            // add the same file twice\n+            ZipArchiveEntry ze = new ZipArchiveEntry(f2, \"foo\");\n+            zo.putArchiveEntry(ze);\n+            zo.write(new byte[0]);\n+            zo.closeArchiveEntry();\n+            ze = new ZipArchiveEntry(f2, \"foo\");\n+            zo.putArchiveEntry(ze);\n+            zo.write(new byte[0]);\n+            zo.closeArchiveEntry();\n+            zo.close();\n+\n+            o.close();\n+            o = null;\n+\n+            System.err.println(\"-------------------vvvvvvvvvvvvvvvvvvvvvvv-----------\");\n+            zf = new ZipFile(f);\n+            ze = zf.getEntry(\"foo\");\n+            assertNotNull(ze);\n+            assertNotNull(zf.getInputStream(ze));\n+        } finally {\n+            System.err.println(\"-------------------^^^^^^^^^^^^^^^^^^^^^^^-----------\");\n+            if (o != null) {\n+                o.close();\n+            }\n+            f.delete();\n+            f2.delete();\n+        }\n+    }\n+\n     /*\n      * ordertest.zip has been handcrafted.\n      *", "timestamp": 1369064037, "metainfo": ""}