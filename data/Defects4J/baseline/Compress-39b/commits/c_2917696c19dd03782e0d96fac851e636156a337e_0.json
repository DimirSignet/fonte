{"sha": "2917696c19dd03782e0d96fac851e636156a337e", "log": "Prove you can't trust Inflater/Deflater  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/DeflaterInflaterTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * Not really a test for Commons Compress but rather one for the JDK.\n+ */\n+@Ignore\n+public class DeflaterInflaterTest {\n+    /**\n+     * Verify Deflater.getBytesRead returns a number &gt; 0xFFFFFFFF\n+     * if the uncompressed size is bigger than that.\n+     */\n+    @Test public void deflaterBytesRead() throws Throwable {\n+        Deflater def = new Deflater();\n+        try {\n+            byte[] in = new byte[4096];\n+            byte[] out = new byte[8192];\n+            final int max = 1024 * 1024 + 1;\n+            for (int i = 0; i < max; i++) {\n+                def.setInput(in);\n+                while (!def.needsInput()) {\n+                    def.deflate(out, 0, out.length);\n+                }\n+            }\n+            def.finish();\n+            while (!def.finished()) {\n+                def.deflate(out, 0, out.length);\n+            }\n+            assertEquals(0x100001000L, def.getBytesRead());\n+        } finally {\n+            def.end();\n+        }\n+    }\n+\n+    /**\n+     * Verify Inflater.getBytesWritten returns a number &gt;\n+     * 0xFFFFFFFF if the uncompressed size is bigger than that.\n+     */\n+    @Test public void inflaterBytesWritten() throws Throwable {\n+        Deflater def = new Deflater();\n+        Inflater inf = new Inflater();\n+        try {\n+            byte[] in = new byte[4096];\n+            byte[] out = new byte[8192];\n+            byte[] out2 = new byte[8192];\n+            final int max = 1024 * 1024 + 1;\n+            for (int i = 0; i < max; i++) {\n+                def.setInput(in);\n+                while (!def.needsInput()) {\n+                    int len = def.deflate(out, 0, out.length);\n+                    if (len > 0) {\n+                        inf.setInput(out, 0, len);\n+                        while (!inf.needsInput()) {\n+                            inf.inflate(out2, 0, out2.length);\n+                        }\n+                    }\n+                }\n+            }\n+            def.finish();\n+            while (!def.finished()) {\n+                int len = def.deflate(out, 0, out.length);\n+                if (len > 0) {\n+                    inf.setInput(out, 0, len);\n+                    while (!inf.needsInput()) {\n+                        inf.inflate(out2, 0, out2.length);\n+                    }\n+                }\n+            }\n+            def.end();\n+            while (!inf.finished()) {\n+                inf.inflate(out2, 0, out2.length);\n+            }\n+            assertEquals(0x100001000L, inf.getBytesWritten());\n+        } finally {\n+            inf.end();\n+        }\n+    }\n+}", "timestamp": 1312258870, "metainfo": ""}