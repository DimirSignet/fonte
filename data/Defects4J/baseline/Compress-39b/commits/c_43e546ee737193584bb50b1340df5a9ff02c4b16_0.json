{"sha": "43e546ee737193584bb50b1340df5a9ff02c4b16", "log": "add ZIP64 extended information to the central directory if needed.  COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.util.zip.ZipException;\n+\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\n+import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n \n /**\n  * Holds size and other extended information for entries that use Zip64\n  * @NotThreadSafe\n  */\n public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n-    // TODO: the LFH should probably not contain relativeHeaderOffset\n-    // and diskStart but then ZipArchivePOutputStream won't write it to\n-    // the CD either - need to test interop with other implementations\n-    // to see whether they do have a problem with the extraneous\n-    // information inside the LFH\n \n     static final ZipShort HEADER_ID = new ZipShort(0x0001);\n \n-    private static final int WORD = 4, DWORD = 8;\n+    private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n+        \"Zip64 extended information must contain\"\n+        + \" both size values in the local file header.\";\n \n     private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n     private ZipLong diskStart;\n                                               ZipEightByteInteger compressedSize,\n                                               ZipEightByteInteger relativeHeaderOffset,\n                                               ZipLong diskStart) {\n-        if (size == null) {\n-            throw new IllegalArgumentException(\"size must not be null\");\n-        }\n-        if (compressedSize == null) {\n-            throw new IllegalArgumentException(\"compressedSize must not be null\");\n-        }\n         this.size = size;\n         this.compressedSize = compressedSize;\n         this.relativeHeaderOffset = relativeHeaderOffset;\n \n     /** {@inheritDoc} */\n     public ZipShort getLocalFileDataLength() {\n-        return getCentralDirectoryLength();\n+        return new ZipShort(size != null ? 2 * DWORD : 0);\n     }\n \n     /** {@inheritDoc} */\n     public ZipShort getCentralDirectoryLength() {\n-        return new ZipShort(2 * DWORD  // both size fields\n+        return new ZipShort((size != null ? DWORD : 0)\n+                            + (compressedSize != null ? DWORD : 0)\n                             + (relativeHeaderOffset != null ? DWORD : 0)\n                             + (diskStart != null ? WORD : 0));\n     }\n \n     /** {@inheritDoc} */\n     public byte[] getLocalFileDataData() {\n-        return getCentralDirectoryData();\n+        if (size != null || compressedSize != null) {\n+            if (size == null || compressedSize == null) {\n+                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n+            }\n+            byte[] data = new byte[2 * DWORD];\n+            addSizes(data);\n+            return data;\n+        }\n+        return new byte[0];\n     }\n \n     /** {@inheritDoc} */\n     public byte[] getCentralDirectoryData() {\n         byte[] data = new byte[getCentralDirectoryLength().getValue()];\n-        addSizes(data);\n-        int off = 2 * DWORD;\n+        int off = addSizes(data);\n         if (relativeHeaderOffset != null) {\n             System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n             off += DWORD;\n     public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n         throws ZipException {\n         if (length < 2 * DWORD) {\n-            throw new ZipException(\"Zip64 extended information must contain\"\n-                                   + \" both size values in the local file\"\n-                                   + \" header.\");\n+            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n         }\n         size = new ZipEightByteInteger(buffer, offset);\n         offset += DWORD;\n     }\n \n     /**\n+     * The uncompressed size stored in this extra field.\n+     */\n+    public void setSize(ZipEightByteInteger size) {\n+        this.size = size;\n+    }\n+\n+    /**\n      * The compressed size stored in this extra field.\n      */\n     public ZipEightByteInteger getCompressedSize() {\n     }\n \n     /**\n+     * The uncompressed size stored in this extra field.\n+     */\n+    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n+        this.compressedSize = compressedSize;\n+    }\n+\n+    /**\n      * The relative header offset stored in this extra field.\n      */\n     public ZipEightByteInteger getRelativeHeaderOffset() {\n     }\n \n     /**\n+     * The relative header offset stored in this extra field.\n+     */\n+    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n+        relativeHeaderOffset = rho;\n+    }\n+\n+    /**\n      * The disk start number stored in this extra field.\n      */\n     public ZipLong getDiskStartNumber() {\n         return diskStart;\n     }\n \n-    private void addSizes(byte[] data) {\n-        System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n-        System.arraycopy(compressedSize.getBytes(), 0, data, DWORD, DWORD);\n+    /**\n+     * The disk start number stored in this extra field.\n+     */\n+    public void setDiskStartNumber(ZipLong ds) {\n+        diskStart = ds;\n+    }\n+\n+    private int addSizes(byte[] data) {\n+        int off = 0;\n+        if (size != null) {\n+            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n+            off += DWORD;\n+        }\n+        if (compressedSize != null) {\n+            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n+            off += DWORD;\n+        }\n+        return off;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n \n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n-                                                         && fallbackToUTF8);\n+                                                         && fallbackToUTF8,\n+                                                         false);\n         written += WORD;\n \n         // compression method\n \n         final int zipMethod = ze.getMethod();\n         final boolean encodable = zipEncoding.canEncode(ze.getName());\n+\n+        final long lfhOffset = offsets.get(ze).longValue();\n+        final boolean needsZip64Extra = ze.getCompressedSize() >= ZIP64_MAGIC\n+            || ze.getSize() >= ZIP64_MAGIC\n+            || lfhOffset >= ZIP64_MAGIC;\n+\n+        if (needsZip64Extra) {\n+            hasUsedZip64 = true;\n+            Zip64ExtendedInformationExtraField z64 =  \n+                (Zip64ExtendedInformationExtraField)\n+                ze.getExtraField(Zip64ExtendedInformationExtraField\n+                                 .HEADER_ID);\n+            if (z64 == null) {\n+                z64 = new Zip64ExtendedInformationExtraField();\n+                ze.addExtraField(z64);\n+            }\n+            if (ze.getCompressedSize() >= ZIP64_MAGIC) {\n+                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n+            }\n+            if (ze.getSize() >= ZIP64_MAGIC) {\n+                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n+            }\n+            if (lfhOffset >= ZIP64_MAGIC) {\n+                z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n+            }\n+            ze.setExtra();\n+        }\n+\n         writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n                                                          !encodable\n-                                                         && fallbackToUTF8);\n+                                                         && fallbackToUTF8,\n+                                                         needsZip64Extra);\n         written += WORD;\n \n         // compression method\n         // compressed length\n         // uncompressed length\n         writeOut(ZipLong.getBytes(ze.getCrc()));\n-        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n-        writeOut(ZipLong.getBytes(ze.getSize()));\n+        writeOut(ZipLong.getBytes(Math.min(ze.getCompressedSize(), ZIP64_MAGIC)));\n+        writeOut(ZipLong.getBytes(Math.min(ze.getSize(), ZIP64_MAGIC)));\n         // CheckStyle:MagicNumber OFF\n         written += 12;\n         // CheckStyle:MagicNumber ON\n         written += WORD;\n \n         // relative offset of LFH\n-        writeOut(ZipLong.getBytes(offsets.get(ze).longValue()));\n+        writeOut(ZipLong.getBytes(Math.min(lfhOffset, ZIP64_MAGIC)));\n         written += WORD;\n \n         // file name\n     private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n                                                                   zipMethod,\n                                                                   final boolean\n-                                                                  utfFallback)\n+                                                                  utfFallback,\n+                                                                  final boolean\n+                                                                  zip64)\n         throws IOException {\n \n         // CheckStyle:MagicNumber OFF\n         if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n-            versionNeededToExtract =  20;\n+            versionNeededToExtract = DEFLATE_MIN_VERSION;\n             b.useDataDescriptor(true);\n+        }\n+        if (zip64) {\n+            versionNeededToExtract = ZIP64_MIN_VERSION;\n         }\n         // CheckStyle:MagicNumber ON\n ", "timestamp": 1311950485, "metainfo": ""}