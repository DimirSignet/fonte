{"sha": "46ad24db76c6f65480736006c2da8b8e5bf8ee25", "log": "applied patch from Christian Grobmeier  updated tar implementation from ant https://issues.apache.org/jira/browse/SANDBOX-273    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n \n /**\n- * This class represents an entry in a Tar archive. It consists of the entry's\n- * header, as well as the entry's File. Entries can be instantiated in one of\n- * three ways, depending on how they are to be used. <p>\n+ * This class represents an entry in a Tar archive. It consists\n+ * of the entry's header, as well as the entry's File. Entries\n+ * can be instantiated in one of three ways, depending on how\n+ * they are to be used.\n+ * <p>\n+ * TarEntries that are created from the header bytes read from\n+ * an archive are instantiated with the TarEntry( byte[] )\n+ * constructor. These entries will be used when extracting from\n+ * or listing the contents of an archive. These entries have their\n+ * header filled in using the header bytes. They also set the File\n+ * to null, since they reference an archive entry not a file.\n+ * <p>\n+ * TarEntries that are created from Files that are to be written\n+ * into an archive are instantiated with the TarEntry( File )\n+ * constructor. These entries have their header filled in using\n+ * the File's information. They also keep a reference to the File\n+ * for convenience when writing entries.\n+ * <p>\n+ * Finally, TarEntries can be constructed from nothing but a name.\n+ * This allows the programmer to construct the entry by hand, for\n+ * instance when only an InputStream is available for writing to\n+ * the archive, and the header information is constructed from\n+ * other information. In this case the header fields are set to\n+ * defaults and the File is set to null.\n  *\n- * TarEntries that are created from the header bytes read from an archive are\n- * instantiated with the TarEntry( byte[] ) constructor. These entries will be\n- * used when extracting from or listing the contents of an archive. These\n- * entries have their header filled in using the header bytes. They also set the\n- * File to null, since they reference an archive entry not a file. <p>\n- *\n- * TarEntries that are created from Files that are to be written into an archive\n- * are instantiated with the TarEntry( File ) constructor. These entries have\n- * their header filled in using the File's information. They also keep a\n- * reference to the File for convenience when writing entries. <p>\n- *\n- * Finally, TarEntries can be constructed from nothing but a name. This allows\n- * the programmer to construct the entry by hand, for instance when only an\n- * InputStream is available for writing to the archive, and the header\n- * information is constructed from other information. In this case the header\n- * fields are set to defaults and the File is set to null. <p>\n- *\n- * The C structure for a Tar Entry's header is: <pre>\n+ * <p>\n+ * The C structure for a Tar Entry's header is:\n+ * <pre>\n  * struct header {\n  * char name[NAMSIZ];\n  * char mode[8];\n  * char devminor[8];\n  * } header;\n  * </pre>\n+ *\n  */\n-public class TarArchiveEntry implements ArchiveEntry {\n-    /**\n-     * The length of the name field in a header buffer.\n-     */\n-    public static final int NAMELEN = 99;\n-\n-    /**\n-     * The entry's modification time.\n-     */\n-    private int m_checkSum;\n-\n-    /**\n-     * The entry's group name.\n-     */\n-    private int m_devMajor;\n-\n-    /**\n-     * The entry's major device number.\n-     */\n-    private int m_devMinor;\n-\n-    /**\n-     * The entry's minor device number.\n-     */\n-    private File m_file;\n-\n-    /**\n-     * The entry's user id.\n-     */\n-    private int m_groupID;\n-\n-    /**\n-     * The entry's user name.\n-     */\n-    private StringBuffer m_groupName;\n-\n-    /**\n-     * The entry's checksum.\n-     */\n-    private byte m_linkFlag;\n-\n-    /**\n-     * The entry's link flag.\n-     */\n-    private StringBuffer m_linkName;\n-\n-    /**\n-     * The entry's link name.\n-     */\n-    private StringBuffer m_magic;\n-\n-    /**\n-     * The entry's size.\n-     */\n-    private long m_modTime;\n-\n-    /**\n-     * The entry's name.\n-     */\n-    private int m_mode;\n-\n-    private StringBuffer m_name;\n-\n-    /**\n-     * The entry's group id.\n-     */\n-    private long m_size;\n-\n-    /**\n-     * The entry's permission mode.\n-     */\n-    private int m_userID;\n-\n-    /**\n-     * The entry's magic tag.\n-     */\n-    private StringBuffer m_userName;\n-\n-    /**\n-     * Construct an entry with only a name. This allows the programmer to\n-     * construct the entry's header \"by hand\". File is set to null.\n-     *\n-     * @param name the name of the entry\n-     */\n-    public TarArchiveEntry( final String name )\n-    {\n+\n+public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n+    /** The entry's name. */\n+    private StringBuffer name;\n+\n+    /** The entry's permission mode. */\n+    private int mode;\n+\n+    /** The entry's user id. */\n+    private int userId;\n+\n+    /** The entry's group id. */\n+    private int groupId;\n+\n+    /** The entry's size. */\n+    private long size;\n+\n+    /** The entry's modification time. */\n+    private long modTime;\n+\n+    /** The entry's link flag. */\n+    private byte linkFlag;\n+\n+    /** The entry's link name. */\n+    private StringBuffer linkName;\n+\n+    /** The entry's magic tag. */\n+    private StringBuffer magic;\n+\n+    /** The entry's user name. */\n+    private StringBuffer userName;\n+\n+    /** The entry's group name. */\n+    private StringBuffer groupName;\n+\n+    /** The entry's major device number. */\n+    private int devMajor;\n+\n+    /** The entry's minor device number. */\n+    private int devMinor;\n+\n+    /** The entry's file reference */\n+    private File file;\n+\n+    /** Maximum length of a user's name in the tar file */\n+    public static final int MAX_NAMELEN = 31;\n+\n+    /** Default permissions bits for directories */\n+    public static final int DEFAULT_DIR_MODE = 040755;\n+\n+    /** Default permissions bits for files */\n+    public static final int DEFAULT_FILE_MODE = 0100644;\n+\n+    /** Convert millis to seconds */\n+    public static final int MILLIS_PER_SECOND = 1000;\n+\n+    /**\n+     * Construct an empty entry and prepares the header values.\n+     */\n+    private TarArchiveEntry () {\n+        this.magic = new StringBuffer(TMAGIC);\n+        this.name = new StringBuffer();\n+        this.linkName = new StringBuffer();\n+\n+        String user = System.getProperty(\"user.name\", \"\");\n+\n+        if (user.length() > MAX_NAMELEN) {\n+            user = user.substring(0, MAX_NAMELEN);\n+        }\n+\n+        this.userId = 0;\n+        this.groupId = 0;\n+        this.userName = new StringBuffer(user);\n+        this.groupName = new StringBuffer(\"\");\n+        this.file = null;\n+    }\n+\n+    /**\n+     * Construct an entry with only a name. This allows the programmer\n+     * to construct the entry's header \"by hand\". File is set to null.\n+     *\n+     * @param name the entry name\n+     */\n+    public TarArchiveEntry(String name) {\n         this();\n \n-        final boolean isDir = name.endsWith( \"/\" );\n-\n-        m_name = new StringBuffer( name );\n-        m_mode = isDir ? 040755 : 0100644;\n-        m_linkFlag = isDir ? TarConstants.LF_DIR : TarConstants.LF_NORMAL;\n-        m_modTime = ( new Date() ).getTime() / 1000;\n-        m_linkName = new StringBuffer( \"\" );\n-        m_userName = new StringBuffer( \"\" );\n-        m_groupName = new StringBuffer( \"\" );\n-    }\n-\n-    /**\n-     * Construct an entry with a name an a link flag.\n-     *\n-     * @param name Description of Parameter\n-     * @param linkFlag Description of Parameter\n-     */\n-    public TarArchiveEntry( final String name, final byte linkFlag )\n-    {\n-        this( name );\n-        m_linkFlag = linkFlag;\n-    }\n-\n-    /**\n-     * Construct an entry for a file. File is set to file, and the header is\n-     * constructed from information from the file.\n+        boolean isDir = name.endsWith(\"/\");\n+\n+        this.devMajor = 0;\n+        this.devMinor = 0;\n+        this.name = new StringBuffer(name);\n+        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n+        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n+        this.userId = 0;\n+        this.groupId = 0;\n+        this.size = 0;\n+        this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\n+        this.linkName = new StringBuffer(\"\");\n+        this.userName = new StringBuffer(\"\");\n+        this.groupName = new StringBuffer(\"\");\n+        this.devMajor = 0;\n+        this.devMinor = 0;\n+\n+    }\n+\n+    /**\n+     * Construct an entry with a name and a link flag.\n+     *\n+     * @param name the entry name\n+     * @param linkFlag the entry link flag.\n+     */\n+    public TarArchiveEntry(String name, byte linkFlag) {\n+        this(name);\n+        this.linkFlag = linkFlag;\n+    }\n+\n+    /**\n+     * Construct an entry for a file. File is set to file, and the\n+     * header is constructed from information from the file.\n      *\n      * @param file The file that the entry represents.\n      */\n-    public TarArchiveEntry( final File file )\n-    {\n+    public TarArchiveEntry(File file) {\n         this();\n \n-        m_file = file;\n-\n-        String name = file.getPath();\n-\n-        // Strip off drive letters!\n-        final String osName =\n-            System.getProperty( \"os.name\" ).toLowerCase( Locale.US );\n-        if( -1 != osName.indexOf( \"netware\" ) )\n-        {\n-            if( name.length() > 2 )\n-            {\n-                final char ch1 = name.charAt( 0 );\n-                final char ch2 = name.charAt( 1 );\n-\n-                if( ch2 == ':' &&\n-                    ( ( ch1 >= 'a' && ch1 <= 'z' ) ||\n-                    ( ch1 >= 'A' && ch1 <= 'Z' ) ) )\n-                {\n-                    name = name.substring( 2 );\n+        this.file = file;\n+\n+        String fileName = file.getPath();\n+        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\n+\n+        if (osname != null) {\n+\n+            // Strip off drive letters!\n+            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n+\n+            if (osname.startsWith(\"windows\")) {\n+                if (fileName.length() > 2) {\n+                    char ch1 = fileName.charAt(0);\n+                    char ch2 = fileName.charAt(1);\n+\n+                    if (ch2 == ':'\n+                            && ((ch1 >= 'a' && ch1 <= 'z')\n+                                || (ch1 >= 'A' && ch1 <= 'Z'))) {\n+                        fileName = fileName.substring(2);\n+                    }\n+                }\n+            } else if (osname.indexOf(\"netware\") > -1) {\n+                int colon = fileName.indexOf(':');\n+                if (colon != -1) {\n+                    fileName = fileName.substring(colon + 1);\n                 }\n             }\n         }\n-        else if( -1 != osName.indexOf( \"netware\" ) )\n-        {\n-            final int colon = name.indexOf( ':' );\n-            if( colon != -1 )\n-            {\n-                name = name.substring( colon + 1 );\n-            }\n-        }\n-\n-        name = name.replace( File.separatorChar, '/' );\n+\n+        fileName = fileName.replace(File.separatorChar, '/');\n \n         // No absolute pathnames\n         // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n         // so we loop on starting /'s.\n-        while( name.startsWith( \"/\" ) )\n-        {\n-            name = name.substring( 1 );\n-        }\n-\n-        m_linkName = new StringBuffer( \"\" );\n-        m_name = new StringBuffer( name );\n-\n-        if( file.isDirectory() )\n-        {\n-            m_mode = 040755;\n-            m_linkFlag = TarConstants.LF_DIR;\n-\n-            if( m_name.charAt( m_name.length() - 1 ) != '/' )\n-            {\n-                m_name.append( \"/\" );\n+        while (fileName.startsWith(\"/\")) {\n+            fileName = fileName.substring(1);\n+        }\n+\n+        this.linkName = new StringBuffer(\"\");\n+        this.name = new StringBuffer(fileName);\n+\n+        if (file.isDirectory()) {\n+            this.mode = DEFAULT_DIR_MODE;\n+            this.linkFlag = LF_DIR;\n+\n+            if (this.name.charAt(this.name.length() - 1) != '/') {\n+                this.name.append(\"/\");\n             }\n-        }\n-        else\n-        {\n-            m_mode = 0100644;\n-            m_linkFlag = TarConstants.LF_NORMAL;\n-        }\n-\n-        m_size = file.length();\n-        m_modTime = file.lastModified() / 1000;\n-        m_checkSum = 0;\n-        m_devMajor = 0;\n-        m_devMinor = 0;\n-    }\n-\n-    /**\n-     * Construct an entry from an archive's header bytes. File is set to null.\n-     *\n-     * @param header The header bytes from a tar archive entry.\n-     */\n-    public TarArchiveEntry( final byte[] header )\n-    {\n+        } else {\n+            this.mode = DEFAULT_FILE_MODE;\n+            this.linkFlag = LF_NORMAL;\n+        }\n+\n+        this.size = file.length();\n+        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n+        this.devMajor = 0;\n+        this.devMinor = 0;\n+    }\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     */\n+    public TarArchiveEntry(byte[] headerBuf) {\n         this();\n-        parseTarHeader( header );\n-    }\n-\n-    /**\n-     * Construct an empty entry and prepares the header values.\n-     */\n-    private TarArchiveEntry()\n-    {\n-        m_magic = new StringBuffer( TarConstants.TMAGIC );\n-        m_name = new StringBuffer();\n-        m_linkName = new StringBuffer();\n-\n-        String user = System.getProperty( \"user.name\", \"\" );\n-        if( user.length() > 31 )\n-        {\n-            user = user.substring( 0, 31 );\n-        }\n-\n-        m_userName = new StringBuffer( user );\n-        m_groupName = new StringBuffer( \"\" );\n+        parseTarHeader(headerBuf);\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals(TarArchiveEntry it) {\n+        return getName().equals(it.getName());\n+    }\n+\n+    /**\n+     * Determine if the two entries are equal. Equality is determined\n+     * by the header names being equal.\n+     *\n+     * @param it Entry to be checked for equality.\n+     * @return True if the entries are equal.\n+     */\n+    public boolean equals(Object it) {\n+        if (it == null || getClass() != it.getClass()) {\n+            return false;\n+        }\n+        return equals((TarArchiveEntry) it);\n+    }\n+\n+    /**\n+     * Hashcodes are based on entry names.\n+     *\n+     * @return the entry hashcode\n+     */\n+    public int hashCode() {\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * Determine if the given entry is a descendant of this entry.\n+     * Descendancy is determined by the name of the descendant\n+     * starting with this entry's name.\n+     *\n+     * @param desc Entry to be checked as a descendent of this.\n+     * @return True if entry is a descendant of this.\n+     */\n+    public boolean isDescendent(TarArchiveEntry desc) {\n+        return desc.getName().startsWith(getName());\n+    }\n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n+    public String getName() {\n+        return name.toString();\n+    }\n+\n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n+    public void setName(String name) {\n+        this.name = new StringBuffer(name);\n+    }\n+\n+    /**\n+     * Set the mode for this entry\n+     *\n+     * @param mode the mode for this entry\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    /**\n+     * Get this entry's link name.\n+     *\n+     * @return This entry's link name.\n+     */\n+    public String getLinkName() {\n+        return linkName.toString();\n+    }\n+\n+    /**\n+     * Get this entry's user id.\n+     *\n+     * @return This entry's user id.\n+     */\n+    public int getUserId() {\n+        return userId;\n+    }\n+\n+    /**\n+     * Set this entry's user id.\n+     *\n+     * @param userId This entry's new user id.\n+     */\n+    public void setUserId(int userId) {\n+        this.userId = userId;\n+    }\n+\n+    /**\n+     * Get this entry's group id.\n+     *\n+     * @return This entry's group id.\n+     */\n+    public int getGroupId() {\n+        return groupId;\n     }\n \n     /**\n      *\n      * @param groupId This entry's new group id.\n      */\n-    public void setGroupID( final int groupId )\n-    {\n-        m_groupID = groupId;\n-    }\n-\n-    /**\n-     * Set this entry's group id.\n-     *\n+    public void setGroupId(int groupId) {\n+        this.groupId = groupId;\n+    }\n+\n+    /**\n+     * Get this entry's user name.\n+     *\n+     * @return This entry's user name.\n+     */\n+    public String getUserName() {\n+        return userName.toString();\n+    }\n+\n+    /**\n+     * Set this entry's user name.\n+     *\n+     * @param userName This entry's new user name.\n+     */\n+    public void setUserName(String userName) {\n+        this.userName = new StringBuffer(userName);\n+    }\n+\n+    /**\n+     * Get this entry's group name.\n+     *\n+     * @return This entry's group name.\n+     */\n+    public String getGroupName() {\n+        return groupName.toString();\n+    }\n+\n+    /**\n+     * Set this entry's group name.\n+     *\n+     * @param groupName This entry's new group name.\n+     */\n+    public void setGroupName(String groupName) {\n+        this.groupName = new StringBuffer(groupName);\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user ids.\n+     *\n+     * @param userId This entry's new user id.\n      * @param groupId This entry's new group id.\n-     * @deprecated Use setGroupID() instead\n-     * @see #setGroupID(int)\n-     */\n-    public void setGroupId( final int groupId )\n-    {\n-        m_groupID = groupId;\n-    }\n-\n-    /**\n-     * Set this entry's group name.\n-     *\n+     */\n+    public void setIds(int userId, int groupId) {\n+        setUserId(userId);\n+        setGroupId(groupId);\n+    }\n+\n+    /**\n+     * Convenience method to set this entry's group and user names.\n+     *\n+     * @param userName This entry's new user name.\n      * @param groupName This entry's new group name.\n      */\n-    public void setGroupName( final String groupName )\n-    {\n-        m_groupName = new StringBuffer( groupName );\n-    }\n-\n-    /**\n-     * Set this entry's modification time. The parameter passed to this method\n-     * is in \"Java time\".\n+    public void setNames(String userName, String groupName) {\n+        setUserName(userName);\n+        setGroupName(groupName);\n+    }\n+\n+    /**\n+     * Set this entry's modification time. The parameter passed\n+     * to this method is in \"Java time\".\n      *\n      * @param time This entry's new modification time.\n      */\n-    public void setModTime( final long time )\n-    {\n-        m_modTime = time / 1000;\n+    public void setModTime(long time) {\n+        modTime = time / MILLIS_PER_SECOND;\n     }\n \n     /**\n      *\n      * @param time This entry's new modification time.\n      */\n-    public void setModTime( final Date time )\n-    {\n-        m_modTime = time.getTime() / 1000;\n-    }\n-\n-    /**\n-     * Set the mode for this entry\n-     *\n-     * @param mode The new Mode value\n-     */\n-    public void setMode( final int mode )\n-    {\n-        m_mode = mode;\n-    }\n-\n-    /**\n-     * Set this entry's name.\n-     *\n-     * @param name This entry's new name.\n-     */\n-    public void setName( final String name )\n-    {\n-        m_name = new StringBuffer( name );\n+    public void setModTime(Date time) {\n+        modTime = time.getTime() / MILLIS_PER_SECOND;\n+    }\n+\n+    /**\n+     * Set this entry's modification time.\n+     *\n+     * @return time This entry's new modification time.\n+     */\n+    public Date getModTime() {\n+        return new Date(modTime * MILLIS_PER_SECOND);\n+    }\n+\n+    /**\n+     * Get this entry's file.\n+     *\n+     * @return This entry's file.\n+     */\n+    public File getFile() {\n+        return file;\n+    }\n+\n+    /**\n+     * Get this entry's mode.\n+     *\n+     * @return This entry's mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+\n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n+    public long getSize() {\n+        return size;\n     }\n \n     /**\n      *\n      * @param size This entry's new file size.\n      */\n-    public void setSize( final long size )\n-    {\n-        m_size = size;\n-    }\n-\n-    /**\n-     * Set this entry's user id.\n-     *\n-     * @param userId This entry's new user id.\n-     */\n-    public void setUserID( final int userId )\n-    {\n-        m_userID = userId;\n-    }\n-\n-    /**\n-     * Set this entry's user id.\n-     *\n-     * @param userId This entry's new user id.\n-     * @deprecated Use setUserID() instead\n-     * @see #setUserID(int)\n-     */\n-    public void setUserId( final int userId )\n-    {\n-        m_userID = userId;\n-    }\n-\n-    /**\n-     * Set this entry's user name.\n-     *\n-     * @param userName This entry's new user name.\n-     */\n-    public void setUserName( final String userName )\n-    {\n-        m_userName = new StringBuffer( userName );\n-    }\n-\n-    /**\n-     * If this entry represents a file, and the file is a directory, return an\n-     * array of TarEntries for this entry's children.\n+    public void setSize(long size) {\n+        this.size = size;\n+    }\n+\n+\n+    /**\n+     * Indicate if this entry is a GNU long name block\n+     *\n+     * @return true if this is a long name extension provided by GNU tar\n+     */\n+    public boolean isGNULongNameEntry() {\n+        return linkFlag == LF_GNUTYPE_LONGNAME\n+                           && name.toString().equals(GNU_LONGLINK);\n+    }\n+\n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n+    public boolean isDirectory() {\n+        if (file != null) {\n+            return file.isDirectory();\n+        }\n+\n+        if (linkFlag == LF_DIR) {\n+            return true;\n+        }\n+\n+        if (getName().endsWith(\"/\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * If this entry represents a file, and the file is a directory, return\n+     * an array of TarEntries for this entry's children.\n      *\n      * @return An array of TarEntry's for this entry's children.\n      */\n-    public TarArchiveEntry[] getDirectoryEntries()\n-    {\n-        if( null == m_file || !m_file.isDirectory() )\n-        {\n-            return new TarArchiveEntry[ 0 ];\n-        }\n-\n-        final String[] list = m_file.list();\n-        final TarArchiveEntry[] result = new TarArchiveEntry[ list.length ];\n-\n-        for( int i = 0; i < list.length; ++i )\n-        {\n-            result[ i ] = new TarArchiveEntry( new File( m_file, list[ i ] ) );\n+    public TarArchiveEntry[] getDirectoryEntries() {\n+        if (file == null || !file.isDirectory()) {\n+            return new TarArchiveEntry[0];\n+        }\n+\n+        String[]   list = file.list();\n+        TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n+\n+        for (int i = 0; i < list.length; ++i) {\n+            result[i] = new TarArchiveEntry(new File(file, list[i]));\n         }\n \n         return result;\n     }\n \n     /**\n-     * Get this entry's file.\n-     *\n-     * @return This entry's file.\n-     */\n-    public File getFile()\n-    {\n-        return m_file;\n-    }\n-\n-    /**\n-     * Get this entry's group id.\n-     *\n-     * @return This entry's group id.\n-     * @deprecated Use getGroupID() instead\n-     * @see #getGroupID()\n-     */\n-    public int getGroupId()\n-    {\n-        return m_groupID;\n-    }\n-\n-    /**\n-     * Get this entry's group id.\n-     *\n-     * @return This entry's group id.\n-     */\n-    public int getGroupID()\n-    {\n-        return m_groupID;\n-    }\n-\n-    /**\n-     * Get this entry's group name.\n-     *\n-     * @return This entry's group name.\n-     */\n-    public String getGroupName()\n-    {\n-        return m_groupName.toString();\n-    }\n-\n-    /**\n-     * Set this entry's modification time.\n-     *\n-     * @return The ModTime value\n-     */\n-    public Date getModTime()\n-    {\n-        return new Date( m_modTime * 1000 );\n-    }\n-\n-    /**\n-     * Get this entry's mode.\n-     *\n-     * @return This entry's mode.\n-     */\n-    public int getMode()\n-    {\n-        return m_mode;\n-    }\n-\n-    /**\n-     * Get this entry's name.\n-     *\n-     * @return This entry's name.\n-     */\n-    public String getName()\n-    {\n-        return m_name.toString();\n-    }\n-\n-    /**\n-     * Get this entry's file size.\n-     *\n-     * @return This entry's file size.\n-     */\n-    public long getSize()\n-    {\n-        return m_size;\n-    }\n-\n-    /**\n-     * Get this entry's checksum.\n-     *\n-     * @return This entry's checksum.\n-     */\n-    public int getCheckSum()\n-    {\n-        return m_checkSum;\n-    }\n-\n-    /**\n-     * Get this entry's user id.\n-     *\n-     * @return This entry's user id.\n-     * @deprecated Use getUserID() instead\n-     * @see #getUserID()\n-     */\n-    public int getUserId()\n-    {\n-        return m_userID;\n-    }\n-\n-    /**\n-     * Get this entry's user id.\n-     *\n-     * @return This entry's user id.\n-     */\n-    public int getUserID()\n-    {\n-        return m_userID;\n-    }\n-\n-    /**\n-     * Get this entry's user name.\n-     *\n-     * @return This entry's user name.\n-     */\n-    public String getUserName()\n-    {\n-        return m_userName.toString();\n-    }\n-\n-    /**\n-     * Determine if the given entry is a descendant of this entry. Descendancy\n-     * is determined by the name of the descendant starting with this entry's\n-     * name.\n-     *\n-     * @param desc Entry to be checked as a descendent of\n-     * @return True if entry is a descendant of\n-     */\n-    public boolean isDescendent( final TarArchiveEntry desc )\n-    {\n-        return desc.getName().startsWith( getName() );\n-    }\n-\n-    /**\n-     * Return whether or not this entry represents a directory.\n-     *\n-     * @return True if this entry is a directory.\n-     */\n-    public boolean isDirectory()\n-    {\n-        if( m_file != null )\n-        {\n-            return m_file.isDirectory();\n-        }\n-\n-        if( m_linkFlag == TarConstants.LF_DIR )\n-        {\n-            return true;\n-        }\n-\n-        if( getName().endsWith( \"/\" ) )\n-        {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    /**\n-     * Indicate if this entry is a GNU long name block\n-     *\n-     * @return true if this is a long name extension provided by GNU tar\n-     */\n-    public boolean isGNULongNameEntry()\n-    {\n-        return m_linkFlag == TarConstants.LF_GNUTYPE_LONGNAME &&\n-            m_name.toString().equals( TarConstants.GNU_LONGLINK );\n-    }\n-\n-    /**\n-     * Determine if the two entries are equal. Equality is determined by the\n-     * header names being equal.\n-     *\n-     * @param other Entry to be checked for equality.\n-     * @return True if the entries are equal.\n-     */\n-    public boolean equals( final TarArchiveEntry other )\n-    {\n-        return getName().equals( other.getName() );\n+     * Write an entry's header information to a header buffer.\n+     *\n+     * @param outbuf The tar entry header buffer to fill in.\n+     */\n+    public void writeEntryHeader(byte[] outbuf) {\n+        int offset = 0;\n+\n+        offset = TarUtils.getNameBytes(name, outbuf, offset, NAMELEN);\n+        offset = TarUtils.getOctalBytes(mode, outbuf, offset, MODELEN);\n+        offset = TarUtils.getOctalBytes(userId, outbuf, offset, UIDLEN);\n+        offset = TarUtils.getOctalBytes(groupId, outbuf, offset, GIDLEN);\n+        offset = TarUtils.getLongOctalBytes(size, outbuf, offset, SIZELEN);\n+        offset = TarUtils.getLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n+\n+        int csOffset = offset;\n+\n+        for (int c = 0; c < CHKSUMLEN; ++c) {\n+            outbuf[offset++] = (byte) ' ';\n+        }\n+\n+        outbuf[offset++] = linkFlag;\n+        offset = TarUtils.getNameBytes(linkName, outbuf, offset, NAMELEN);\n+        offset = TarUtils.getNameBytes(magic, outbuf, offset, MAGICLEN);\n+        offset = TarUtils.getNameBytes(userName, outbuf, offset, UNAMELEN);\n+        offset = TarUtils.getNameBytes(groupName, outbuf, offset, GNAMELEN);\n+        offset = TarUtils.getOctalBytes(devMajor, outbuf, offset, DEVLEN);\n+        offset = TarUtils.getOctalBytes(devMinor, outbuf, offset, DEVLEN);\n+\n+        while (offset < outbuf.length) {\n+            outbuf[offset++] = 0;\n+        }\n+\n+        long chk = TarUtils.computeCheckSum(outbuf);\n+\n+        TarUtils.getCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n     }\n \n     /**\n      *\n      * @param header The tar entry header buffer to get information from.\n      */\n-    private void parseTarHeader( final byte[] header )\n-    {\n+    public void parseTarHeader(byte[] header) {\n         int offset = 0;\n \n-        m_name = TarUtils.parseName( header, offset, NAMELEN );\n+        name = TarUtils.parseName(header, offset, NAMELEN);\n         offset += NAMELEN;\n-        m_mode = (int)TarUtils.parseOctal( header, offset, TarConstants.MODELEN );\n-        offset += TarConstants.MODELEN;\n-        m_userID = (int)TarUtils.parseOctal( header, offset, TarConstants.UIDLEN );\n-        offset += TarConstants.UIDLEN;\n-        m_groupID = (int)TarUtils.parseOctal( header, offset, TarConstants.GIDLEN );\n-        offset += TarConstants.GIDLEN;\n-        m_size = TarUtils.parseOctal( header, offset, TarConstants.SIZELEN );\n-        offset += TarConstants.SIZELEN;\n-        m_modTime = TarUtils.parseOctal( header, offset, TarConstants.MODTIMELEN );\n-        offset += TarConstants.MODTIMELEN;\n-        m_checkSum = (int)TarUtils.parseOctal( header, offset, TarConstants.CHKSUMLEN );\n-        offset += TarConstants.CHKSUMLEN;\n-        m_linkFlag = header[ offset++ ];\n-        m_linkName = TarUtils.parseName( header, offset, NAMELEN );\n+        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n+        offset += MODELEN;\n+        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n+        offset += UIDLEN;\n+        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n+        offset += GIDLEN;\n+        size = TarUtils.parseOctal(header, offset, SIZELEN);\n+        offset += SIZELEN;\n+        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n+        offset += MODTIMELEN;\n+        offset += CHKSUMLEN;\n+        linkFlag = header[offset++];\n+        linkName = TarUtils.parseName(header, offset, NAMELEN);\n         offset += NAMELEN;\n-        m_magic = TarUtils.parseName( header, offset, TarConstants.MAGICLEN );\n-        offset += TarConstants.MAGICLEN;\n-        m_userName = TarUtils.parseName( header, offset, TarConstants.UNAMELEN );\n-        offset += TarConstants.UNAMELEN;\n-        m_groupName = TarUtils.parseName( header, offset, TarConstants.GNAMELEN );\n-        offset += TarConstants.GNAMELEN;\n-        m_devMajor = (int)TarUtils.parseOctal( header, offset, TarConstants.DEVLEN );\n-        offset += TarConstants.DEVLEN;\n-        m_devMinor = (int)TarUtils.parseOctal( header, offset, TarConstants.DEVLEN );\n-    }\n-\n-    /**\n-     * Write an entry's header information to a header buffer.\n-     *\n-     * @param buffer The tar entry header buffer to fill in.\n-     */\n-    public void writeEntryHeader( final byte[] buffer )\n-    {\n-        int offset = 0;\n-\n-        offset = TarUtils.getNameBytes( m_name, buffer, offset, NAMELEN );\n-        offset = TarUtils.getOctalBytes( m_mode, buffer, offset, TarConstants.MODELEN );\n-        offset = TarUtils.getOctalBytes( m_userID, buffer, offset, TarConstants.UIDLEN );\n-        offset = TarUtils.getOctalBytes( m_groupID, buffer, offset, TarConstants.GIDLEN );\n-        offset = TarUtils.getLongOctalBytes( m_size, buffer, offset, TarConstants.SIZELEN );\n-        offset = TarUtils.getLongOctalBytes( m_modTime, buffer, offset, TarConstants.MODTIMELEN );\n-\n-        final int checkSumOffset = offset;\n-        for( int i = 0; i < TarConstants.CHKSUMLEN; ++i )\n-        {\n-            buffer[ offset++ ] = (byte)' ';\n-        }\n-\n-        buffer[ offset++ ] = m_linkFlag;\n-        offset = TarUtils.getNameBytes( m_linkName, buffer, offset, NAMELEN );\n-        offset = TarUtils.getNameBytes( m_magic, buffer, offset, TarConstants.MAGICLEN );\n-        offset = TarUtils.getNameBytes( m_userName, buffer, offset, TarConstants.UNAMELEN );\n-        offset = TarUtils.getNameBytes( m_groupName, buffer, offset, TarConstants.GNAMELEN );\n-        offset = TarUtils.getOctalBytes( m_devMajor, buffer, offset, TarConstants.DEVLEN );\n-        offset = TarUtils.getOctalBytes( m_devMinor, buffer, offset, TarConstants.DEVLEN );\n-\n-        while( offset < buffer.length )\n-        {\n-            buffer[ offset++ ] = 0;\n-        }\n-\n-        final long checkSum = TarUtils.computeCheckSum( buffer );\n-        TarUtils.getCheckSumOctalBytes( checkSum, buffer, checkSumOffset, TarConstants.CHKSUMLEN );\n+        magic = TarUtils.parseName(header, offset, MAGICLEN);\n+        offset += MAGICLEN;\n+        userName = TarUtils.parseName(header, offset, UNAMELEN);\n+        offset += UNAMELEN;\n+        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n+        offset += GNAMELEN;\n+        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n+        offset += DEVLEN;\n+        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n     }\n }\n+\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n import java.util.Arrays;\n \n /**\n- * The TarBuffer class implements the tar archive concept of a buffered input\n- * stream. This concept goes back to the days of blocked tape drives and special\n- * io devices. In the Java universe, the only real function that this class\n- * performs is to ensure that files have the correct \"block\" size, or other tars\n- * will complain. <p>\n+ * The TarBuffer class implements the tar archive concept\n+ * of a buffered input stream. This concept goes back to the\n+ * days of blocked tape drives and special io devices. In the\n+ * Java universe, the only real function that this class\n+ * performs is to ensure that files have the correct \"block\"\n+ * size, or other tars will complain.\n+ * <p>\n+ * You should never have a need to access this class directly.\n+ * TarBuffers are created by Tar IO Streams.\n  *\n- * You should never have a need to access this class directly. TarBuffers are\n- * created by Tar IO Streams.\n  */\n-class TarBuffer\n-{\n-    public static final int DEFAULT_RECORDSIZE = ( 512 );\n-    public static final int DEFAULT_BLOCKSIZE = ( DEFAULT_RECORDSIZE * 20 );\n-\n-    private byte[] m_blockBuffer;\n-    private int m_blockSize;\n-    private int m_currBlkIdx;\n-    private int m_currRecIdx;\n-    private boolean m_debug;\n-\n-    private InputStream m_input;\n-    private OutputStream m_output;\n-    private int m_recordSize;\n-    private int m_recsPerBlock;\n-\n-    public TarBuffer( final InputStream input )\n-    {\n-        this( input, TarBuffer.DEFAULT_BLOCKSIZE );\n-    }\n-\n-    public TarBuffer( final InputStream input, final int blockSize )\n-    {\n-        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    public TarBuffer( final InputStream input,\n-                      final int blockSize,\n-                      final int recordSize )\n-    {\n-        m_input = input;\n-        initialize( blockSize, recordSize );\n-    }\n-\n-    public TarBuffer( final OutputStream output )\n-    {\n-        this( output, TarBuffer.DEFAULT_BLOCKSIZE );\n-    }\n-\n-    public TarBuffer( final OutputStream output, final int blockSize )\n-    {\n-        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    public TarBuffer( final OutputStream output,\n-                      final int blockSize,\n-                      final int recordSize )\n-    {\n-        m_output = output;\n-        initialize( blockSize, recordSize );\n+\n+public class TarBuffer {\n+\n+    /** Default record size */\n+    public static final int DEFAULT_RCDSIZE = (512);\n+\n+    /** Default block size */\n+    public static final int DEFAULT_BLKSIZE = (DEFAULT_RCDSIZE * 20);\n+\n+    private InputStream     inStream;\n+    private OutputStream    outStream;\n+    private byte[]          blockBuffer;\n+    private int             currBlkIdx;\n+    private int             currRecIdx;\n+    private int             blockSize;\n+    private int             recordSize;\n+    private int             recsPerBlock;\n+    private boolean         debug;\n+\n+    /**\n+     * Constructor for a TarBuffer on an input stream.\n+     * @param inStream the input stream to use\n+     */\n+    public TarBuffer(InputStream inStream) {\n+        this(inStream, TarBuffer.DEFAULT_BLKSIZE);\n+    }\n+\n+    /**\n+     * Constructor for a TarBuffer on an input stream.\n+     * @param inStream the input stream to use\n+     * @param blockSize the block size to use\n+     */\n+    public TarBuffer(InputStream inStream, int blockSize) {\n+        this(inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for a TarBuffer on an input stream.\n+     * @param inStream the input stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\n+        this.inStream = inStream;\n+        this.outStream = null;\n+\n+        this.initialize(blockSize, recordSize);\n+    }\n+\n+    /**\n+     * Constructor for a TarBuffer on an output stream.\n+     * @param outStream the output stream to use\n+     */\n+    public TarBuffer(OutputStream outStream) {\n+        this(outStream, TarBuffer.DEFAULT_BLKSIZE);\n+    }\n+\n+    /**\n+     * Constructor for a TarBuffer on an output stream.\n+     * @param outStream the output stream to use\n+     * @param blockSize the block size to use\n+     */\n+    public TarBuffer(OutputStream outStream, int blockSize) {\n+        this(outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for a TarBuffer on an output stream.\n+     * @param outStream the output stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\n+        this.inStream = null;\n+        this.outStream = outStream;\n+\n+        this.initialize(blockSize, recordSize);\n+    }\n+\n+    /**\n+     * Initialization common to all constructors.\n+     */\n+    private void initialize(int blockSize, int recordSize) {\n+        this.debug = false;\n+        this.blockSize = blockSize;\n+        this.recordSize = recordSize;\n+        this.recsPerBlock = (this.blockSize / this.recordSize);\n+        this.blockBuffer = new byte[this.blockSize];\n+\n+        if (this.inStream != null) {\n+            this.currBlkIdx = -1;\n+            this.currRecIdx = this.recsPerBlock;\n+        } else {\n+            this.currBlkIdx = 0;\n+            this.currRecIdx = 0;\n+        }\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's block size. Blocks consist of multiple records.\n+     * @return the block size\n+     */\n+    public int getBlockSize() {\n+        return this.blockSize;\n+    }\n+\n+    /**\n+     * Get the TAR Buffer's record size.\n+     * @return the record size\n+     */\n+    public int getRecordSize() {\n+        return this.recordSize;\n     }\n \n     /**\n      *\n      * @param debug If true, print debugging output.\n      */\n-    public void setDebug( final boolean debug )\n-    {\n-        m_debug = debug;\n-    }\n-\n-    /**\n-     * Get the TAR Buffer's block size. Blocks consist of multiple records.\n-     *\n-     * @return The BlockSize value\n-     */\n-    public int getBlockSize()\n-    {\n-        return m_blockSize;\n-    }\n-\n-    /**\n-     * Get the current block number, zero based.\n-     *\n-     * @return The current zero based block number.\n-     */\n-    public int getCurrentBlockNum()\n-    {\n-        return m_currBlkIdx;\n-    }\n-\n-    /**\n-     * Get the current record number, within the current block, zero based.\n-     * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.\n-     *\n-     * @return The current zero based record number.\n-     */\n-    public int getCurrentRecordNum()\n-    {\n-        return m_currRecIdx - 1;\n-    }\n-\n-    /**\n-     * Get the TAR Buffer's record size.\n-     *\n-     * @return The RecordSize value\n-     */\n-    public int getRecordSize()\n-    {\n-        return m_recordSize;\n-    }\n-\n-    /**\n-     * Determine if an archive record indicate End of Archive. End of archive is\n-     * indicated by a record that consists entirely of null bytes.\n+    public void setDebug(boolean debug) {\n+        this.debug = debug;\n+    }\n+\n+    /**\n+     * Determine if an archive record indicate End of Archive. End of\n+     * archive is indicated by a record that consists entirely of null bytes.\n      *\n      * @param record The record data to check.\n-     * @return The EOFRecord value\n-     */\n-    public boolean isEOFRecord( final byte[] record )\n-    {\n-        final int size = getRecordSize();\n-        for( int i = 0; i < size; ++i )\n-        {\n-            if( record[ i ] != 0 )\n-            {\n+     * @return true if the record data is an End of Archive\n+     */\n+    public boolean isEOFRecord(byte[] record) {\n+        for (int i = 0, sz = getRecordSize(); i < sz; ++i) {\n+            if (record[i] != 0) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * Close the TarBuffer. If this is an output buffer, also flush the current\n-     * block before closing.\n-     */\n-    public void close()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            debug( \"TarBuffer.closeBuffer().\" );\n-        }\n-\n-        if( null != m_output )\n-        {\n-            flushBlock();\n-\n-            if( m_output != System.out && m_output != System.err )\n-            {\n-                m_output.close();\n-                m_output = null;\n-            }\n-        }\n-        else if( m_input != null )\n-        {\n-            if( m_input != System.in )\n-            {\n-                m_input.close();\n-                m_input = null;\n-            }\n-        }\n+     * Skip over a record on the input stream.\n+     * @throws IOException on error\n+     */\n+    public void skipRecord() throws IOException {\n+        if (debug) {\n+            System.err.println(\"SkipRecord: recIdx = \" + currRecIdx\n+                               + \" blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (inStream == null) {\n+            throw new IOException(\"reading (via skip) from an output buffer\");\n+        }\n+\n+        if (currRecIdx >= recsPerBlock) {\n+            if (!readBlock()) {\n+                return;    // UNDONE\n+            }\n+        }\n+\n+        currRecIdx++;\n     }\n \n     /**\n      * Read a record from the input stream and return the data.\n      *\n      * @return The record data.\n-     * @exception IOException Description of Exception\n-     */\n-    public byte[] readRecord()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"ReadRecord: recIdx = \" + m_currRecIdx +\n-                \" blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_input )\n-        {\n-            final String message = \"reading from an output buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        if( m_currRecIdx >= m_recsPerBlock )\n-        {\n-            if( !readBlock() )\n-            {\n+     * @throws IOException on error\n+     */\n+    public byte[] readRecord() throws IOException {\n+        if (debug) {\n+            System.err.println(\"ReadRecord: recIdx = \" + currRecIdx\n+                               + \" blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (inStream == null) {\n+            throw new IOException(\"reading from an output buffer\");\n+        }\n+\n+        if (currRecIdx >= recsPerBlock) {\n+            if (!readBlock()) {\n                 return null;\n             }\n         }\n \n-        final byte[] result = new byte[ m_recordSize ];\n-        System.arraycopy( m_blockBuffer,\n-                          ( m_currRecIdx * m_recordSize ),\n-                          result,\n-                          0,\n-                          m_recordSize );\n-\n-        m_currRecIdx++;\n+        byte[] result = new byte[recordSize];\n+\n+        System.arraycopy(blockBuffer,\n+                         (currRecIdx * recordSize), result, 0,\n+                         recordSize);\n+\n+        currRecIdx++;\n \n         return result;\n     }\n \n     /**\n-     * Skip over a record on the input stream.\n-     */\n-    public void skipRecord()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"SkipRecord: recIdx = \" + m_currRecIdx +\n-                \" blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_input )\n-        {\n-            final String message = \"reading (via skip) from an output buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        if( m_currRecIdx >= m_recsPerBlock )\n-        {\n-            if( !readBlock() )\n-            {\n-                return;// UNDONE\n-            }\n-        }\n-\n-        m_currRecIdx++;\n-    }\n-\n-    /**\n-     * Write an archive record to the archive.\n-     *\n-     * @param record The record data to write to the archive.\n-     */\n-    public void writeRecord( final byte[] record )\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n-                \" blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_output )\n-        {\n-            final String message = \"writing to an input buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        if( record.length != m_recordSize )\n-        {\n-            final String message = \"record to write has length '\" +\n-                record.length + \"' which is not the record size of '\" +\n-                m_recordSize + \"'\";\n-            throw new IOException( message );\n-        }\n-\n-        if( m_currRecIdx >= m_recsPerBlock )\n-        {\n-            writeBlock();\n-        }\n-\n-        System.arraycopy( record,\n-                          0,\n-                          m_blockBuffer,\n-                          ( m_currRecIdx * m_recordSize ),\n-                          m_recordSize );\n-\n-        m_currRecIdx++;\n-    }\n-\n-    /**\n-     * Write an archive record to the archive, where the record may be inside of\n-     * a larger array buffer. The buffer must be \"offset plus record size\" long.\n-     *\n-     * @param buffer The buffer containing the record data to write.\n-     * @param offset The offset of the record data within buf.\n-     */\n-    public void writeRecord( final byte[] buffer, final int offset )\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"WriteRecord: recIdx = \" + m_currRecIdx +\n-                \" blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_output )\n-        {\n-            final String message = \"writing to an input buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        if( ( offset + m_recordSize ) > buffer.length )\n-        {\n-            final String message = \"record has length '\" + buffer.length +\n-                \"' with offset '\" + offset + \"' which is less than the record size of '\" +\n-                m_recordSize + \"'\";\n-            throw new IOException( message );\n-        }\n-\n-        if( m_currRecIdx >= m_recsPerBlock )\n-        {\n-            writeBlock();\n-        }\n-\n-        System.arraycopy( buffer,\n-                          offset,\n-                          m_blockBuffer,\n-                          ( m_currRecIdx * m_recordSize ),\n-                          m_recordSize );\n-\n-        m_currRecIdx++;\n-    }\n-\n-    /**\n-     * Flush the current data block if it has any data in it.\n-     */\n-    private void flushBlock()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"TarBuffer.flushBlock() called.\";\n-            debug( message );\n-        }\n-\n-        if( m_output == null )\n-        {\n-            final String message = \"writing to an input buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        if( m_currRecIdx > 0 )\n-        {\n-            writeBlock();\n-        }\n-    }\n-\n-    /**\n-     * Initialization common to all constructors.\n-     */\n-    private void initialize( final int blockSize, final int recordSize )\n-    {\n-        m_debug = false;\n-        m_blockSize = blockSize;\n-        m_recordSize = recordSize;\n-        m_recsPerBlock = ( m_blockSize / m_recordSize );\n-        m_blockBuffer = new byte[ m_blockSize ];\n-\n-        if( null != m_input )\n-        {\n-            m_currBlkIdx = -1;\n-            m_currRecIdx = m_recsPerBlock;\n-        }\n-        else\n-        {\n-            m_currBlkIdx = 0;\n-            m_currRecIdx = 0;\n-        }\n-    }\n-\n-    /**\n      * @return false if End-Of-File, else true\n      */\n-    private boolean readBlock()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"ReadBlock: blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_input )\n-        {\n-            final String message = \"reading from an output buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        m_currRecIdx = 0;\n+    private boolean readBlock() throws IOException {\n+        if (debug) {\n+            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (inStream == null) {\n+            throw new IOException(\"reading from an output buffer\");\n+        }\n+\n+        currRecIdx = 0;\n \n         int offset = 0;\n-        int bytesNeeded = m_blockSize;\n-\n-        while( bytesNeeded > 0 )\n-        {\n-            final long numBytes = m_input.read( m_blockBuffer, offset, bytesNeeded );\n+        int bytesNeeded = blockSize;\n+\n+        while (bytesNeeded > 0) {\n+            long numBytes = inStream.read(blockBuffer, offset,\n+                                               bytesNeeded);\n \n             //\n             // NOTE\n             //\n             // Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n             //\n-            if( numBytes == -1 )\n-            {\n+            if (numBytes == -1) {\n+                if (offset == 0) {\n+                    // Ensure that we do not read gigabytes of zeros\n+                    // for a corrupt tar file.\n+                    // See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\n+                    return false;\n+                }\n                 // However, just leaving the unread portion of the buffer dirty does\n                 // cause problems in some cases.  This problem is described in\n                 // http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n                 //\n                 // The solution is to fill the unused portion of the buffer with zeros.\n \n-                Arrays.fill(m_blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n+                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n \n                 break;\n             }\n             offset += numBytes;\n             bytesNeeded -= numBytes;\n \n-            if( numBytes != m_blockSize )\n-            {\n-                if( m_debug )\n-                {\n-                    System.err.println( \"ReadBlock: INCOMPLETE READ \"\n-                                        + numBytes + \" of \" + m_blockSize\n-                                        + \" bytes read.\" );\n+            if (numBytes != blockSize) {\n+                if (debug) {\n+                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n+                                       + numBytes + \" of \" + blockSize\n+                                       + \" bytes read.\");\n                 }\n             }\n         }\n \n-        m_currBlkIdx++;\n+        currBlkIdx++;\n \n         return true;\n     }\n \n     /**\n+     * Get the current block number, zero based.\n+     *\n+     * @return The current zero based block number.\n+     */\n+    public int getCurrentBlockNum() {\n+        return currBlkIdx;\n+    }\n+\n+    /**\n+     * Get the current record number, within the current block, zero based.\n+     * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.\n+     *\n+     * @return The current zero based record number.\n+     */\n+    public int getCurrentRecordNum() {\n+        return currRecIdx - 1;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive.\n+     *\n+     * @param record The record data to write to the archive.\n+     * @throws IOException on error\n+     */\n+    public void writeRecord(byte[] record) throws IOException {\n+        if (debug) {\n+            System.err.println(\"WriteRecord: recIdx = \" + currRecIdx\n+                               + \" blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (outStream == null) {\n+            throw new IOException(\"writing to an input buffer\");\n+        }\n+\n+        if (record.length != recordSize) {\n+            throw new IOException(\"record to write has length '\"\n+                                  + record.length\n+                                  + \"' which is not the record size of '\"\n+                                  + recordSize + \"'\");\n+        }\n+\n+        if (currRecIdx >= recsPerBlock) {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy(record, 0, blockBuffer,\n+                         (currRecIdx * recordSize),\n+                         recordSize);\n+\n+        currRecIdx++;\n+    }\n+\n+    /**\n+     * Write an archive record to the archive, where the record may be\n+     * inside of a larger array buffer. The buffer must be \"offset plus\n+     * record size\" long.\n+     *\n+     * @param buf The buffer containing the record data to write.\n+     * @param offset The offset of the record data within buf.\n+     * @throws IOException on error\n+     */\n+    public void writeRecord(byte[] buf, int offset) throws IOException {\n+        if (debug) {\n+            System.err.println(\"WriteRecord: recIdx = \" + currRecIdx\n+                               + \" blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (outStream == null) {\n+            throw new IOException(\"writing to an input buffer\");\n+        }\n+\n+        if ((offset + recordSize) > buf.length) {\n+            throw new IOException(\"record has length '\" + buf.length\n+                                  + \"' with offset '\" + offset\n+                                  + \"' which is less than the record size of '\"\n+                                  + recordSize + \"'\");\n+        }\n+\n+        if (currRecIdx >= recsPerBlock) {\n+            writeBlock();\n+        }\n+\n+        System.arraycopy(buf, offset, blockBuffer,\n+                         (currRecIdx * recordSize),\n+                         recordSize);\n+\n+        currRecIdx++;\n+    }\n+\n+    /**\n      * Write a TarBuffer block to the archive.\n-     *\n-     * @exception IOException Description of Exception\n-     */\n-    private void writeBlock()\n-        throws IOException\n-    {\n-        if( m_debug )\n-        {\n-            final String message = \"WriteBlock: blkIdx = \" + m_currBlkIdx;\n-            debug( message );\n-        }\n-\n-        if( null == m_output )\n-        {\n-            final String message = \"writing to an input buffer\";\n-            throw new IOException( message );\n-        }\n-\n-        m_output.write( m_blockBuffer, 0, m_blockSize );\n-        m_output.flush();\n-\n-        m_currRecIdx = 0;\n-        m_currBlkIdx++;\n-    }\n-\n-    protected void debug( final String message )\n-    {\n-        if( m_debug )\n-        {\n-            System.err.println( message );\n+     */\n+    private void writeBlock() throws IOException {\n+        if (debug) {\n+            System.err.println(\"WriteBlock: blkIdx = \" + currBlkIdx);\n+        }\n+\n+        if (outStream == null) {\n+            throw new IOException(\"writing to an input buffer\");\n+        }\n+\n+        outStream.write(blockBuffer, 0, blockSize);\n+        outStream.flush();\n+\n+        currRecIdx = 0;\n+        currBlkIdx++;\n+    }\n+\n+    /**\n+     * Flush the current data block if it has any data in it.\n+     */\n+    private void flushBlock() throws IOException {\n+        if (debug) {\n+            System.err.println(\"TarBuffer.flushBlock() called.\");\n+        }\n+\n+        if (outStream == null) {\n+            throw new IOException(\"writing to an input buffer\");\n+        }\n+\n+        if (currRecIdx > 0) {\n+            writeBlock();\n+        }\n+    }\n+\n+    /**\n+     * Close the TarBuffer. If this is an output buffer, also flush the\n+     * current block before closing.\n+     * @throws IOException on error\n+     */\n+    public void close() throws IOException {\n+        if (debug) {\n+            System.err.println(\"TarBuffer.closeBuffer().\");\n+        }\n+\n+        if (outStream != null) {\n+            flushBlock();\n+\n+            if (outStream != System.out\n+                    && outStream != System.err) {\n+                outStream.close();\n+\n+                outStream = null;\n+            }\n+        } else if (inStream != null) {\n+            if (inStream != System.in) {\n+                inStream.close();\n+\n+                inStream = null;\n+            }\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n \n /**\n  * This interface contains all the definitions used in the package.\n+ *\n  */\n-interface TarConstants\n-{\n+// CheckStyle:InterfaceIsTypeCheck OFF (bc)\n+public interface TarConstants {\n+\n+    /**\n+     * The length of the name field in a header buffer.\n+     */\n+    int    NAMELEN = 100;\n+\n     /**\n      * The length of the mode field in a header buffer.\n      */\n-    int MODELEN = 8;\n+    int    MODELEN = 8;\n \n     /**\n      * The length of the user id field in a header buffer.\n      */\n-    int UIDLEN = 8;\n+    int    UIDLEN = 8;\n \n     /**\n      * The length of the group id field in a header buffer.\n      */\n-    int GIDLEN = 8;\n+    int    GIDLEN = 8;\n \n     /**\n      * The length of the checksum field in a header buffer.\n      */\n-    int CHKSUMLEN = 8;\n+    int    CHKSUMLEN = 8;\n \n     /**\n      * The length of the size field in a header buffer.\n      */\n-    int SIZELEN = 12;\n+    int    SIZELEN = 12;\n+\n+    /**\n+     * The maximum size of a file in a tar archive (That's 11 sevens, octal).\n+     */\n+    long   MAXSIZE = 077777777777L;\n \n     /**\n      * The length of the magic field in a header buffer.\n      */\n-    int MAGICLEN = 8;\n+    int    MAGICLEN = 8;\n \n     /**\n      * The length of the modification time field in a header buffer.\n      */\n-    int MODTIMELEN = 12;\n+    int    MODTIMELEN = 12;\n \n     /**\n      * The length of the user name field in a header buffer.\n      */\n-    int UNAMELEN = 32;\n+    int    UNAMELEN = 32;\n \n     /**\n      * The length of the group name field in a header buffer.\n      */\n-    int GNAMELEN = 32;\n+    int    GNAMELEN = 32;\n \n     /**\n      * The length of the devices field in a header buffer.\n      */\n-    int DEVLEN = 8;\n+    int    DEVLEN = 8;\n \n     /**\n      * LF_ constants represent the \"link flag\" of an entry, or more commonly,\n      * the \"entry type\". This is the \"old way\" of indicating a normal file.\n      */\n-    byte LF_OLDNORM = 0;\n+    byte   LF_OLDNORM = 0;\n \n     /**\n      * Normal file type.\n      */\n-    byte LF_NORMAL = (byte)'0';\n+    byte   LF_NORMAL = (byte) '0';\n \n     /**\n      * Link file type.\n      */\n-    byte LF_LINK = (byte)'1';\n+    byte   LF_LINK = (byte) '1';\n \n     /**\n      * Symbolic link file type.\n      */\n-    byte LF_SYMLINK = (byte)'2';\n+    byte   LF_SYMLINK = (byte) '2';\n \n     /**\n      * Character device file type.\n      */\n-    byte LF_CHR = (byte)'3';\n+    byte   LF_CHR = (byte) '3';\n \n     /**\n      * Block device file type.\n      */\n-    byte LF_BLK = (byte)'4';\n+    byte   LF_BLK = (byte) '4';\n \n     /**\n      * Directory file type.\n      */\n-    byte LF_DIR = (byte)'5';\n+    byte   LF_DIR = (byte) '5';\n \n     /**\n      * FIFO (pipe) file type.\n      */\n-    byte LF_FIFO = (byte)'6';\n+    byte   LF_FIFO = (byte) '6';\n \n     /**\n      * Contiguous file type.\n      */\n-    byte LF_CONTIG = (byte)'7';\n+    byte   LF_CONTIG = (byte) '7';\n \n     /**\n      * The magic tag representing a POSIX tar archive.\n     /**\n      * Identifies the *next* file on the tape as having a long name.\n      */\n-    byte LF_GNUTYPE_LONGNAME = (byte)'L';\n+    byte LF_GNUTYPE_LONGNAME = (byte) 'L';\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n /*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n  */\n+\n+/*\n+ * This package is based on the work done by Timothy Gerard Endres\n+ * (time@ice.com) to whom the Ant project is very grateful for his great code.\n+ */\n+\n package org.apache.commons.compress.archivers.tar;\n \n import java.io.FilterInputStream;\n import java.io.OutputStream;\n \n /**\n- * The TarInputStream reads a UNIX tar archive as an InputStream. methods are\n- * provided to position at each successive entry in the archive, and the read\n- * each entry as a normal input stream using read().\n+ * The TarInputStream reads a UNIX tar archive as an InputStream.\n+ * methods are provided to position at each successive entry in\n+ * the archive, and the read each entry as a normal input stream\n+ * using read().\n+ *\n  */\n-public class TarInputStream\n-    extends FilterInputStream\n-{\n-    private TarBuffer m_buffer;\n-    private TarArchiveEntry m_currEntry;\n-    private boolean m_debug;\n-    private int m_entryOffset;\n-    private int m_entrySize;\n-    private boolean m_hasHitEOF;\n-    private byte[] m_oneBuf;\n-    private byte[] m_readBuf;\n-\n-    /**\n-     * Construct a TarInputStream using specified input\n-     * stream and default block and record sizes.\n-     *\n-     * @param input stream to create TarInputStream from\n-     * @see TarBuffer#DEFAULT_BLOCKSIZE\n-     * @see TarBuffer#DEFAULT_RECORDSIZE\n-     */\n-    public TarInputStream( final InputStream input )\n-    {\n-        this( input, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    /**\n-     * Construct a TarInputStream using specified input\n-     * stream, block size and default record sizes.\n-     *\n-     * @param input stream to create TarInputStream from\n+public class TarInputStream extends FilterInputStream {\n+    private static final int SMALL_BUFFER_SIZE = 256;\n+    private static final int BUFFER_SIZE = 8 * 1024;\n+    private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n+    private static final int BYTE_MASK = 0xFF;\n+\n+    // CheckStyle:VisibilityModifier OFF - bc\n+    protected boolean debug;\n+    protected boolean hasHitEOF;\n+    protected long entrySize;\n+    protected long entryOffset;\n+    protected byte[] readBuf;\n+    protected TarBuffer buffer;\n+    protected TarArchiveEntry currEntry;\n+\n+    /**\n+     * This contents of this array is not used at all in this class,\n+     * it is only here to avoid repreated object creation during calls\n+     * to the no-arg read method.\n+     */\n+    protected byte[] oneBuf;\n+\n+    // CheckStyle:VisibilityModifier ON\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     */\n+    public TarInputStream(InputStream is) {\n+        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n      * @param blockSize the block size to use\n-     * @see TarBuffer#DEFAULT_RECORDSIZE\n-     */\n-    public TarInputStream( final InputStream input,\n-                           final int blockSize )\n-    {\n-        this( input, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    /**\n-     * Construct a TarInputStream using specified input\n-     * stream, block size and record sizes.\n-     *\n-     * @param input stream to create TarInputStream from\n+     */\n+    public TarInputStream(InputStream is, int blockSize) {\n+        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n      * @param blockSize the block size to use\n      * @param recordSize the record size to use\n      */\n-    public TarInputStream( final InputStream input,\n-                           final int blockSize,\n-                           final int recordSize )\n-    {\n-        super( input );\n-\n-        m_buffer = new TarBuffer( input, blockSize, recordSize );\n-        m_oneBuf = new byte[ 1 ];\n+    public TarInputStream(InputStream is, int blockSize, int recordSize) {\n+        super(is);\n+\n+        this.buffer = new TarBuffer(is, blockSize, recordSize);\n+        this.readBuf = null;\n+        this.oneBuf = new byte[1];\n+        this.debug = false;\n+        this.hasHitEOF = false;\n     }\n \n     /**\n      * Sets the debugging flag.\n      *\n-     * @param debug The new Debug value\n-     */\n-    public void setDebug( final boolean debug )\n-    {\n-        m_debug = debug;\n-        m_buffer.setDebug( debug );\n-    }\n-\n-    /**\n-     * Get the next entry in this tar archive. This will skip over any remaining\n-     * data in the current entry, if there is one, and place the input stream at\n-     * the header of the next entry, and read the header and instantiate a new\n-     * TarEntry from the header bytes and return that entry. If there are no\n-     * more entries in the archive, null will be returned to indicate that the\n-     * end of the archive has been reached.\n+     * @param debug True to turn on debugging.\n+     */\n+    public void setDebug(boolean debug) {\n+        this.debug = debug;\n+        buffer.setDebug(debug);\n+    }\n+\n+    /**\n+     * Closes this stream. Calls the TarBuffer's close() method.\n+     * @throws IOException on error\n+     */\n+    public void close() throws IOException {\n+        buffer.close();\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize() {\n+        return buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Get the available data that can be read from the current\n+     * entry in the archive. This does not indicate how much data\n+     * is left in the entire archive, only in the current entry.\n+     * This value is determined from the entry's size header field\n+     * and the amount of data already read from the current entry.\n+     * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE\n+     * bytes are left in the current entry in the archive.\n+     *\n+     * @return The number of available bytes for the current entry.\n+     * @throws IOException for signature\n+     */\n+    public int available() throws IOException {\n+        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        }\n+        return (int) (entrySize - entryOffset);\n+    }\n+\n+    /**\n+     * Skip bytes in the input buffer. This skips bytes in the\n+     * current entry's data, not the entire archive, and will\n+     * stop at the end of the current entry's data if the number\n+     * to skip extends beyond that point.\n+     *\n+     * @param numToSkip The number of bytes to skip.\n+     * @return the number actually skipped\n+     * @throws IOException on error\n+     */\n+    public long skip(long numToSkip) throws IOException {\n+        // REVIEW\n+        // This is horribly inefficient, but it ensures that we\n+        // properly skip over bytes via the TarBuffer...\n+        //\n+        byte[] skipBuf = new byte[BUFFER_SIZE];\n+        long skip = numToSkip;\n+        while (skip > 0) {\n+            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n+            int numRead = read(skipBuf, 0, realSkip);\n+            if (numRead == -1) {\n+                break;\n+            }\n+            skip -= numRead;\n+        }\n+        return (numToSkip - skip);\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we return false.\n+     *\n+     * @return False.\n+     */\n+    public boolean markSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     *\n+     * @param markLimit The limit to mark.\n+     */\n+    public void mark(int markLimit) {\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     */\n+    public void reset() {\n+    }\n+\n+    /**\n+     * Get the next entry in this tar archive. This will skip\n+     * over any remaining data in the current entry, if there\n+     * is one, and place the input stream at the header of the\n+     * next entry, and read the header and instantiate a new\n+     * TarEntry from the header bytes and return that entry.\n+     * If there are no more entries in the archive, null will\n+     * be returned to indicate that the end of the archive has\n+     * been reached.\n      *\n      * @return The next TarEntry in the archive, or null.\n-     * @exception IOException Description of Exception\n-     */\n-    public TarArchiveEntry getNextEntry()\n-        throws IOException\n-    {\n-        if( m_hasHitEOF )\n-        {\n+     * @throws IOException on error\n+     */\n+    public TarArchiveEntry getNextEntry() throws IOException {\n+        if (hasHitEOF) {\n             return null;\n         }\n \n-        if( m_currEntry != null )\n-        {\n-            final int numToSkip = m_entrySize - m_entryOffset;\n-\n-            if( m_debug )\n-            {\n-                final String message = \"TarInputStream: SKIP currENTRY '\" +\n-                    m_currEntry.getName() + \"' SZ \" + m_entrySize +\n-                    \" OFF \" + m_entryOffset + \"  skipping \" + numToSkip + \" bytes\";\n-                debug( message );\n-            }\n-\n-            if( numToSkip > 0 )\n-            {\n-                skip( numToSkip );\n-            }\n-\n-            m_readBuf = null;\n-        }\n-\n-        final byte[] headerBuf = m_buffer.readRecord();\n-        if( headerBuf == null )\n-        {\n-            if( m_debug )\n-            {\n-                debug( \"READ NULL RECORD\" );\n-            }\n-            m_hasHitEOF = true;\n-        }\n-        else if( m_buffer.isEOFRecord( headerBuf ) )\n-        {\n-            if( m_debug )\n-            {\n-                debug( \"READ EOF RECORD\" );\n-            }\n-            m_hasHitEOF = true;\n-        }\n-\n-        if( m_hasHitEOF )\n-        {\n-            m_currEntry = null;\n-        }\n-        else\n-        {\n-            m_currEntry = new TarArchiveEntry( headerBuf );\n-\n-            if( !( headerBuf[ 257 ] == 'u' && headerBuf[ 258 ] == 's' &&\n-                headerBuf[ 259 ] == 't' && headerBuf[ 260 ] == 'a' &&\n-                headerBuf[ 261 ] == 'r' ) )\n-            {\n-                //Must be v7Format\n-            }\n-\n-            if( m_debug )\n-            {\n-                final String message = \"TarInputStream: SET CURRENTRY '\" +\n-                    m_currEntry.getName() + \"' size = \" + m_currEntry.getSize();\n-                debug( message );\n-            }\n-\n-            m_entryOffset = 0;\n-\n-            // REVIEW How do we resolve this discrepancy?!\n-            m_entrySize = (int)m_currEntry.getSize();\n-        }\n-\n-        if( null != m_currEntry && m_currEntry.isGNULongNameEntry() )\n-        {\n+        if (currEntry != null) {\n+            long numToSkip = entrySize - entryOffset;\n+\n+            if (debug) {\n+                System.err.println(\"TarInputStream: SKIP currENTRY '\"\n+                        + currEntry.getName() + \"' SZ \"\n+                        + entrySize + \" OFF \"\n+                        + entryOffset + \"  skipping \"\n+                        + numToSkip + \" bytes\");\n+            }\n+\n+            if (numToSkip > 0) {\n+                skip(numToSkip);\n+            }\n+\n+            readBuf = null;\n+        }\n+\n+        byte[] headerBuf = buffer.readRecord();\n+\n+        if (headerBuf == null) {\n+            if (debug) {\n+                System.err.println(\"READ NULL RECORD\");\n+            }\n+            hasHitEOF = true;\n+        } else if (buffer.isEOFRecord(headerBuf)) {\n+            if (debug) {\n+                System.err.println(\"READ EOF RECORD\");\n+            }\n+            hasHitEOF = true;\n+        }\n+\n+        if (hasHitEOF) {\n+            currEntry = null;\n+        } else {\n+            currEntry = new TarArchiveEntry(headerBuf);\n+\n+            if (debug) {\n+                System.err.println(\"TarInputStream: SET CURRENTRY '\"\n+                        + currEntry.getName()\n+                        + \"' size = \"\n+                        + currEntry.getSize());\n+            }\n+\n+            entryOffset = 0;\n+\n+            entrySize = currEntry.getSize();\n+        }\n+\n+        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n             // read in the name\n-            final StringBuffer longName = new StringBuffer();\n-            final byte[] buffer = new byte[ 256 ];\n+            StringBuffer longName = new StringBuffer();\n+            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n             int length = 0;\n-            while( ( length = read( buffer ) ) >= 0 )\n-            {\n-                final String str = new String( buffer, 0, length );\n-                longName.append( str );\n+            while ((length = read(buf)) >= 0) {\n+                longName.append(new String(buf, 0, length));\n             }\n             getNextEntry();\n-\n+            if (currEntry == null) {\n+                // Bugzilla: 40334\n+                // Malformed tar file - long entry name not followed by entry\n+                return null;\n+            }\n             // remove trailing null terminator\n             if (longName.length() > 0\n                 && longName.charAt(longName.length() - 1) == 0) {\n                 longName.deleteCharAt(longName.length() - 1);\n             }\n-            \n-            m_currEntry.setName( longName.toString() );\n-        }\n-\n-        return m_currEntry;\n-    }\n-\n-    /**\n-     * Get the record size being used by this stream's TarBuffer.\n-     *\n-     * @return The TarBuffer record size.\n-     */\n-    public int getRecordSize()\n-    {\n-        return m_buffer.getRecordSize();\n-    }\n-\n-    /**\n-     * Get the available data that can be read from the current entry in the\n-     * archive. This does not indicate how much data is left in the entire\n-     * archive, only in the current entry. This value is determined from the\n-     * entry's size header field and the amount of data already read from the\n-     * current entry.\n-     *\n-     * @return The number of available bytes for the current entry.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public int available()\n-        throws IOException\n-    {\n-        return m_entrySize - m_entryOffset;\n-    }\n-\n-    /**\n-     * Closes this stream. Calls the TarBuffer's close() method.\n-     *\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void close()\n-        throws IOException\n-    {\n-        m_buffer.close();\n-    }\n-\n-    /**\n-     * Copies the contents of the current tar archive entry directly into an\n-     * output stream.\n-     *\n-     * @param output The OutputStream into which to write the entry's data.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void copyEntryContents( final OutputStream output )\n-        throws IOException\n-    {\n-        final byte[] buffer = new byte[ 32 * 1024 ];\n-        while( true )\n-        {\n-            final int numRead = read( buffer, 0, buffer.length );\n-            if( numRead == -1 )\n-            {\n+            currEntry.setName(longName.toString());\n+        }\n+\n+        return currEntry;\n+    }\n+\n+    /**\n+     * Reads a byte from the current tar archive entry.\n+     *\n+     * This method simply calls read( byte[], int, int ).\n+     *\n+     * @return The byte read, or -1 at EOF.\n+     * @throws IOException on error\n+     */\n+    public int read() throws IOException {\n+        int num = read(oneBuf, 0, 1);\n+        return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry.\n+     *\n+     * This method is aware of the boundaries of the current\n+     * entry in the archive and will deal with them as if they\n+     * were this stream's start and EOF.\n+     *\n+     * @param buf The buffer into which to place bytes read.\n+     * @param offset The offset at which to place bytes read.\n+     * @param numToRead The number of bytes to read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @throws IOException on error\n+     */\n+    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n+        int totalRead = 0;\n+\n+        if (entryOffset >= entrySize) {\n+            return -1;\n+        }\n+\n+        if ((numToRead + entryOffset) > entrySize) {\n+            numToRead = (int) (entrySize - entryOffset);\n+        }\n+\n+        if (readBuf != null) {\n+            int sz = (numToRead > readBuf.length) ? readBuf.length\n+                    : numToRead;\n+\n+            System.arraycopy(readBuf, 0, buf, offset, sz);\n+\n+            if (sz >= readBuf.length) {\n+                readBuf = null;\n+            } else {\n+                int newLen = readBuf.length - sz;\n+                byte[] newBuf = new byte[newLen];\n+\n+                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n+\n+                readBuf = newBuf;\n+            }\n+\n+            totalRead += sz;\n+            numToRead -= sz;\n+            offset += sz;\n+        }\n+\n+        while (numToRead > 0) {\n+            byte[] rec = buffer.readRecord();\n+\n+            if (rec == null) {\n+                // Unexpected EOF!\n+                throw new IOException(\"unexpected EOF with \" + numToRead\n+                        + \" bytes unread\");\n+            }\n+\n+            int sz = numToRead;\n+            int recLen = rec.length;\n+\n+            if (recLen > sz) {\n+                System.arraycopy(rec, 0, buf, offset, sz);\n+\n+                readBuf = new byte[recLen - sz];\n+\n+                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n+            } else {\n+                sz = recLen;\n+\n+                System.arraycopy(rec, 0, buf, offset, recLen);\n+            }\n+\n+            totalRead += sz;\n+            numToRead -= sz;\n+            offset += sz;\n+        }\n+\n+        entryOffset += totalRead;\n+\n+        return totalRead;\n+    }\n+\n+    /**\n+     * Copies the contents of the current tar archive entry directly into\n+     * an output stream.\n+     *\n+     * @param out The OutputStream into which to write the entry's data.\n+     * @throws IOException on error\n+     */\n+    public void copyEntryContents(OutputStream out) throws IOException {\n+        byte[] buf = new byte[LARGE_BUFFER_SIZE];\n+\n+        while (true) {\n+            int numRead = read(buf, 0, buf.length);\n+\n+            if (numRead == -1) {\n                 break;\n             }\n \n-            output.write( buffer, 0, numRead );\n-        }\n-    }\n-\n-    /**\n-     * Since we do not support marking just yet, we do nothing.\n-     *\n-     * @param markLimit The limit to mark.\n-     */\n-    public void mark( int markLimit )\n-    {\n-    }\n-\n-    /**\n-     * Since we do not support marking just yet, we return false.\n-     *\n-     * @return False.\n-     */\n-    public boolean markSupported()\n-    {\n-        return false;\n-    }\n-\n-    /**\n-     * Reads a byte from the current tar archive entry. This method simply calls\n-     * read( byte[], int, int ).\n-     *\n-     * @return The byte read, or -1 at EOF.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public int read()\n-        throws IOException\n-    {\n-        final int num = read( m_oneBuf, 0, 1 );\n-        if( num == -1 )\n-        {\n-            return num;\n-        }\n-        else\n-        {\n-            return (int)m_oneBuf[ 0 ] & 0xFF;\n-        }\n-    }\n-\n-    /**\n-     * Reads bytes from the current tar archive entry. This method simply calls\n-     * read( byte[], int, int ).\n-     *\n-     * @param buffer The buffer into which to place bytes read.\n-     * @return The number of bytes read, or -1 at EOF.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public int read( final byte[] buffer )\n-        throws IOException\n-    {\n-        return read( buffer, 0, buffer.length );\n-    }\n-\n-    /**\n-     * Reads bytes from the current tar archive entry. This method is aware of\n-     * the boundaries of the current entry in the archive and will deal with\n-     * them as if they were this stream's start and EOF.\n-     *\n-     * @param buffer The buffer into which to place bytes read.\n-     * @param offset The offset at which to place bytes read.\n-     * @param count The number of bytes to read.\n-     * @return The number of bytes read, or -1 at EOF.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public int read( final byte[] buffer,\n-                     final int offset,\n-                     final int count )\n-        throws IOException\n-    {\n-        int position = offset;\n-        int numToRead = count;\n-        int totalRead = 0;\n-\n-        if( m_entryOffset >= m_entrySize )\n-        {\n-            return -1;\n-        }\n-\n-        if( ( numToRead + m_entryOffset ) > m_entrySize )\n-        {\n-            numToRead = ( m_entrySize - m_entryOffset );\n-        }\n-\n-        if( null != m_readBuf )\n-        {\n-            final int size =\n-                ( numToRead > m_readBuf.length ) ? m_readBuf.length : numToRead;\n-\n-            System.arraycopy( m_readBuf, 0, buffer, position, size );\n-\n-            if( size >= m_readBuf.length )\n-            {\n-                m_readBuf = null;\n-            }\n-            else\n-            {\n-                final int newLength = m_readBuf.length - size;\n-                final byte[] newBuffer = new byte[ newLength ];\n-\n-                System.arraycopy( m_readBuf, size, newBuffer, 0, newLength );\n-\n-                m_readBuf = newBuffer;\n-            }\n-\n-            totalRead += size;\n-            numToRead -= size;\n-            position += size;\n-        }\n-\n-        while( numToRead > 0 )\n-        {\n-            final byte[] rec = m_buffer.readRecord();\n-            if( null == rec )\n-            {\n-                // Unexpected EOF!\n-                final String message =\n-                    \"unexpected EOF with \" + numToRead + \" bytes unread\";\n-                throw new IOException( message );\n-            }\n-\n-            int size = numToRead;\n-            final int recordLength = rec.length;\n-\n-            if( recordLength > size )\n-            {\n-                System.arraycopy( rec, 0, buffer, position, size );\n-\n-                m_readBuf = new byte[ recordLength - size ];\n-\n-                System.arraycopy( rec, size, m_readBuf, 0, recordLength - size );\n-            }\n-            else\n-            {\n-                size = recordLength;\n-\n-                System.arraycopy( rec, 0, buffer, position, recordLength );\n-            }\n-\n-            totalRead += size;\n-            numToRead -= size;\n-            position += size;\n-        }\n-\n-        m_entryOffset += totalRead;\n-\n-        return totalRead;\n-    }\n-\n-    /**\n-     * Since we do not support marking just yet, we do nothing.\n-     */\n-    public void reset()\n-    {\n-    }\n-\n-    /**\n-     * Skip bytes in the input buffer. This skips bytes in the current entry's\n-     * data, not the entire archive, and will stop at the end of the current\n-     * entry's data if the number to skip extends beyond that point.\n-     *\n-     * @param numToSkip The number of bytes to skip.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void skip( final int numToSkip )\n-        throws IOException\n-    {\n-        // REVIEW\n-        // This is horribly inefficient, but it ensures that we\n-        // properly skip over bytes via the TarBuffer...\n-        //\n-        final byte[] skipBuf = new byte[ 8 * 1024 ];\n-        int num = numToSkip;\n-        while( num > 0 )\n-        {\n-            final int count = ( num > skipBuf.length ) ? skipBuf.length : num;\n-            final int numRead = read( skipBuf, 0, count );\n-            if( numRead == -1 )\n-            {\n-                break;\n-            }\n-\n-            num -= numRead;\n-        }\n-    }\n-\n-    /**\n-     * Utility method to do debugging.\n-     * Capable of being overidden in sub-classes.\n-     *\n-     * @param message the message to use in debugging\n-     */\n-    protected void debug( final String message )\n-    {\n-        if( m_debug )\n-        {\n-            System.err.println( message );\n+            out.write(buf, 0, numRead);\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n import java.io.OutputStream;\n \n /**\n- * The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are\n- * provided to put entries, and then write their contents by writing to this\n- * stream using write().\n+ * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n+ * Methods are provided to put entries, and then write their contents\n+ * by writing to this stream using write().\n+ *\n  */\n-public class TarOutputStream\n-    extends FilterOutputStream\n-{\n-    /**\n-     * Flag to indicate that an error should be generated if\n-     * an attempt is made to write an entry that exceeds the 100 char\n-     * POSIX limit.\n-     */\n+public class TarOutputStream extends FilterOutputStream {\n+    /** Fail if a long file name is required in the archive. */\n     public static final int LONGFILE_ERROR = 0;\n \n-    /**\n-     * Flag to indicate that entry name should be truncated if\n-     * an attempt is made to write an entry that exceeds the 100 char\n-     * POSIX limit.\n-     */\n+    /** Long paths will be truncated in the archive. */\n     public static final int LONGFILE_TRUNCATE = 1;\n \n-    /**\n-     * Flag to indicate that entry name should be formatted\n-     * according to GNU tar extension if an attempt is made\n-     * to write an entry that exceeds the 100 char POSIX\n-     * limit. Note that this makes the jar unreadable by\n-     * non-GNU tar commands.\n-     */\n+    /** GNU tar extensions are used to store long file names in the archive. */\n     public static final int LONGFILE_GNU = 2;\n \n-    private int m_longFileMode = LONGFILE_ERROR;\n-    private byte[] m_assemBuf;\n-    private int m_assemLen;\n-    private TarBuffer m_buffer;\n-    private int m_currBytes;\n-    private int m_currSize;\n-\n-    private byte[] m_oneBuf;\n-    private byte[] m_recordBuf;\n-\n-    /**\n-     * Construct a TarOutputStream using specified input\n-     * stream and default block and record sizes.\n-     *\n-     * @param output stream to create TarOutputStream from\n-     * @see TarBuffer#DEFAULT_BLOCKSIZE\n-     * @see TarBuffer#DEFAULT_RECORDSIZE\n-     */\n-    public TarOutputStream( final OutputStream output )\n-    {\n-        this( output, TarBuffer.DEFAULT_BLOCKSIZE, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    /**\n-     * Construct a TarOutputStream using specified input\n-     * stream, block size and default record sizes.\n-     *\n-     * @param output stream to create TarOutputStream from\n-     * @param blockSize the block size\n-     * @see TarBuffer#DEFAULT_RECORDSIZE\n-     */\n-    public TarOutputStream( final OutputStream output,\n-                            final int blockSize )\n-    {\n-        this( output, blockSize, TarBuffer.DEFAULT_RECORDSIZE );\n-    }\n-\n-    /**\n-     * Construct a TarOutputStream using specified input\n-     * stream, block size and record sizes.\n-     *\n-     * @param output stream to create TarOutputStream from\n-     * @param blockSize the block size\n-     * @param recordSize the record size\n-     */\n-    public TarOutputStream( final OutputStream output,\n-                            final int blockSize,\n-                            final int recordSize )\n-    {\n-        super( output );\n-\n-        m_buffer = new TarBuffer( output, blockSize, recordSize );\n-        m_assemLen = 0;\n-        m_assemBuf = new byte[ recordSize ];\n-        m_recordBuf = new byte[ recordSize ];\n-        m_oneBuf = new byte[ 1 ];\n+    // CheckStyle:VisibilityModifier OFF - bc\n+    protected boolean   debug;\n+    protected long      currSize;\n+    protected String    currName;\n+    protected long      currBytes;\n+    protected byte[]    oneBuf;\n+    protected byte[]    recordBuf;\n+    protected int       assemLen;\n+    protected byte[]    assemBuf;\n+    protected TarBuffer buffer;\n+    protected int       longFileMode = LONGFILE_ERROR;\n+    // CheckStyle:VisibilityModifier ON\n+\n+    private boolean closed = false;\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     */\n+    public TarOutputStream(OutputStream os) {\n+        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     */\n+    public TarOutputStream(OutputStream os, int blockSize) {\n+        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarOutputStream(OutputStream os, int blockSize, int recordSize) {\n+        super(os);\n+\n+        this.buffer = new TarBuffer(os, blockSize, recordSize);\n+        this.debug = false;\n+        this.assemLen = 0;\n+        this.assemBuf = new byte[recordSize];\n+        this.recordBuf = new byte[recordSize];\n+        this.oneBuf = new byte[1];\n+    }\n+\n+    /**\n+     * Set the long file mode.\n+     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n+     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n+     * Default is LONGFILE_ERROR.\n+     * @param longFileMode the mode to use\n+     */\n+    public void setLongFileMode(int longFileMode) {\n+        this.longFileMode = longFileMode;\n+    }\n+\n+\n+    /**\n+     * Sets the debugging flag.\n+     *\n+     * @param debugF True to turn on debugging.\n+     */\n+    public void setDebug(boolean debugF) {\n+        this.debug = debugF;\n     }\n \n     /**\n      * Sets the debugging flag in this stream's TarBuffer.\n      *\n-     * @param debug The new BufferDebug value\n-     */\n-    public void setBufferDebug( boolean debug )\n-    {\n-        m_buffer.setDebug( debug );\n-    }\n-\n-    /**\n-     * Set the mode used to work with entrys exceeding\n-     * 100 chars (and thus break the POSIX standard).\n-     * Must be one of the LONGFILE_* constants.\n-     *\n-     * @param longFileMode the mode\n-     */\n-    public void setLongFileMode( final int longFileMode )\n-    {\n-        if( LONGFILE_ERROR != longFileMode &&\n-            LONGFILE_GNU != longFileMode &&\n-            LONGFILE_TRUNCATE != longFileMode )\n-        {\n-            throw new IllegalArgumentException( \"longFileMode\" );\n-        }\n-        m_longFileMode = longFileMode;\n+     * @param debug True to turn on debugging.\n+     */\n+    public void setBufferDebug(boolean debug) {\n+        buffer.setDebug(debug);\n+    }\n+\n+    /**\n+     * Ends the TAR archive without closing the underlying OutputStream.\n+     * The result is that the two EOF records of nulls are written.\n+     * @throws IOException on error\n+     */\n+    public void finish() throws IOException {\n+        // See Bugzilla 28776 for a discussion on this\n+        // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776\n+        writeEOFRecord();\n+        writeEOFRecord();\n+    }\n+\n+    /**\n+     * Ends the TAR archive and closes the underlying OutputStream.\n+     * This means that finish() is called followed by calling the\n+     * TarBuffer's close().\n+     * @throws IOException on error\n+     */\n+    public void close() throws IOException {\n+        if (!closed) {\n+            finish();\n+            buffer.close();\n+            out.close();\n+            closed = true;\n+        }\n     }\n \n     /**\n      *\n      * @return The TarBuffer record size.\n      */\n-    public int getRecordSize()\n-    {\n-        return m_buffer.getRecordSize();\n-    }\n-\n-    /**\n-     * Ends the TAR archive and closes the underlying OutputStream. This means\n-     * that finish() is called followed by calling the TarBuffer's close().\n-     *\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void close()\n-        throws IOException\n-    {\n-        finish();\n-        m_buffer.close();\n-    }\n-\n-    /**\n-     * Close an entry. This method MUST be called for all file entries that\n-     * contain data. The reason is that we must buffer data written to the\n-     * stream in order to satisfy the buffer's record based writes. Thus, there\n-     * may be data fragments still being assembled that must be written to the\n-     * output stream before this entry is closed and the next entry written.\n-     *\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void closeEntry()\n-        throws IOException\n-    {\n-        if( m_assemLen > 0 )\n-        {\n-            for( int i = m_assemLen; i < m_assemBuf.length; ++i )\n-            {\n-                m_assemBuf[ i ] = 0;\n+    public int getRecordSize() {\n+        return buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Put an entry on the output stream. This writes the entry's\n+     * header record and positions the output stream for writing\n+     * the contents of the entry. Once this method is called, the\n+     * stream is ready for calls to write() to write the entry's\n+     * contents. Once the contents are written, closeEntry()\n+     * <B>MUST</B> be called to ensure that all buffered data\n+     * is completely written to the output stream.\n+     *\n+     * @param entry The TarEntry to be written to the archive.\n+     * @throws IOException on error\n+     */\n+    public void putNextEntry(TarArchiveEntry entry) throws IOException {\n+        if (entry.getName().length() >= TarConstants.NAMELEN) {\n+\n+            if (longFileMode == LONGFILE_GNU) {\n+                // create a TarEntry for the LongLink, the contents\n+                // of which are the entry's name\n+                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n+                                                      TarConstants.LF_GNUTYPE_LONGNAME);\n+\n+                longLinkEntry.setSize(entry.getName().length() + 1);\n+                putNextEntry(longLinkEntry);\n+                write(entry.getName().getBytes());\n+                write(0);\n+                closeEntry();\n+            } else if (longFileMode != LONGFILE_TRUNCATE) {\n+                throw new RuntimeException(\"file name '\" + entry.getName()\n+                                             + \"' is too long ( > \"\n+                                             + TarConstants.NAMELEN + \" bytes)\");\n             }\n-\n-            m_buffer.writeRecord( m_assemBuf );\n-\n-            m_currBytes += m_assemLen;\n-            m_assemLen = 0;\n-        }\n-\n-        if( m_currBytes < m_currSize )\n-        {\n-            final String message = \"entry closed at '\" + m_currBytes +\n-                \"' before the '\" + m_currSize +\n-                \"' bytes specified in the header were written\";\n-            throw new IOException( message );\n-        }\n-    }\n-\n-    /**\n-     * Ends the TAR archive without closing the underlying OutputStream. The\n-     * result is that the EOF record of nulls is written.\n-     *\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void finish()\n-        throws IOException\n-    {\n-        writeEOFRecord();\n-    }\n-\n-    /**\n-     * Put an entry on the output stream. This writes the entry's header record\n-     * and positions the output stream for writing the contents of the entry.\n-     * Once this method is called, the stream is ready for calls to write() to\n-     * write the entry's contents. Once the contents are written, closeEntry()\n-     * <B>MUST</B> be called to ensure that all buffered data is completely\n-     * written to the output stream.\n-     *\n-     * The entry must be 0 terminated. Maximum filename is 99 chars, \n-     * according to V7 specification.\n-     * \n-     * @param entry The TarArchiveEntry to be written to the archive.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void putNextEntry( final TarArchiveEntry entry )\n-        throws IOException\n-    {\n-        if( entry.getName().length() > TarArchiveEntry.NAMELEN )\n-        {\n-            if( m_longFileMode == LONGFILE_GNU )\n-            {\n-                // create a TarArchiveEntry for the LongLink, the contents\n-                // of which are the entry's name\n-                final TarArchiveEntry longLinkEntry =\n-                    new TarArchiveEntry( TarConstants.GNU_LONGLINK,\n-                                  TarConstants.LF_GNUTYPE_LONGNAME );\n-\n-                longLinkEntry.setSize( entry.getName().length() + 1);\n-                putNextEntry( longLinkEntry );\n-                write( entry.getName().getBytes() );\n-                write( 0 );\n-                closeEntry();\n+        }\n+\n+        entry.writeEntryHeader(recordBuf);\n+        buffer.writeRecord(recordBuf);\n+\n+        currBytes = 0;\n+\n+        if (entry.isDirectory()) {\n+            currSize = 0;\n+        } else {\n+            currSize = entry.getSize();\n+        }\n+        currName = entry.getName();\n+    }\n+\n+    /**\n+     * Close an entry. This method MUST be called for all file\n+     * entries that contain data. The reason is that we must\n+     * buffer data written to the stream in order to satisfy\n+     * the buffer's record based writes. Thus, there may be\n+     * data fragments still being assembled that must be written\n+     * to the output stream before this entry is closed and the\n+     * next entry written.\n+     * @throws IOException on error\n+     */\n+    public void closeEntry() throws IOException {\n+        if (assemLen > 0) {\n+            for (int i = assemLen; i < assemBuf.length; ++i) {\n+                assemBuf[i] = 0;\n             }\n-            else if( m_longFileMode != LONGFILE_TRUNCATE )\n-            {\n-                final String message = \"file name '\" + entry.getName() +\n-                    \"' is too long ( > \" + TarArchiveEntry.NAMELEN + \" bytes)\";\n-                throw new IOException( message );\n-            }\n-        }\n-\n-        entry.writeEntryHeader( m_recordBuf );\n-        m_buffer.writeRecord( m_recordBuf );\n-\n-        m_currBytes = 0;\n-\n-        if( entry.isDirectory() )\n-        {\n-            m_currSize = 0;\n-        }\n-        else\n-        {\n-            m_currSize = (int)entry.getSize();\n-        }\n-    }\n-\n-    /**\n-     * Copies the contents of the specified stream into current tar\n-     * archive entry.\n-     *\n-     * @param input The InputStream from which to read entrys data\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void copyEntryContents( final InputStream input )\n-        throws IOException\n-    {\n-        final byte[] buffer = new byte[ 32 * 1024 ];\n-        while( true )\n-        {\n-            final int numRead = input.read( buffer, 0, buffer.length );\n-            if( numRead == -1 )\n-            {\n-                break;\n-            }\n-\n-            write( buffer, 0, numRead );\n-        }\n-    }\n-\n-    /**\n-     * Writes a byte to the current tar archive entry. This method simply calls\n-     * read( byte[], int, int ).\n-     *\n-     * @param data The byte written.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void write( final int data )\n-        throws IOException\n-    {\n-        m_oneBuf[ 0 ] = (byte)data;\n-\n-        write( m_oneBuf, 0, 1 );\n-    }\n-\n-    /**\n-     * Writes bytes to the current tar archive entry. This method simply calls\n-     * write( byte[], int, int ).\n-     *\n-     * @param buffer The buffer to write to the archive.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void write( final byte[] buffer )\n-        throws IOException\n-    {\n-        write( buffer, 0, buffer.length );\n-    }\n-\n-    /**\n-     * Writes bytes to the current tar archive entry. This method is aware of\n-     * the current entry and will throw an exception if you attempt to write\n-     * bytes past the length specified for the current entry. The method is also\n-     * (painfully) aware of the record buffering required by TarBuffer, and\n-     * manages buffers that are not a multiple of recordsize in length,\n-     * including assembling records from small buffers.\n-     *\n-     * @param buffer The buffer to write to the archive.\n-     * @param offset The offset in the buffer from which to get bytes.\n-     * @param count The number of bytes to write.\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    public void write( final byte[] buffer,\n-                       final int offset,\n-                       final int count )\n-        throws IOException\n-    {\n-        int position = offset;\n-        int numToWrite = count;\n-        if( ( m_currBytes + numToWrite ) > m_currSize )\n-        {\n-            final String message = \"request to write '\" + numToWrite +\n-                \"' bytes exceeds size in header of '\" + m_currSize + \"' bytes\";\n-            throw new IOException( message );\n+\n+            buffer.writeRecord(assemBuf);\n+\n+            currBytes += assemLen;\n+            assemLen = 0;\n+        }\n+\n+        if (currBytes < currSize) {\n+            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n+                                  + currBytes\n+                                  + \"' before the '\" + currSize\n+                                  + \"' bytes specified in the header were written\");\n+        }\n+    }\n+\n+    /**\n+     * Writes a byte to the current tar archive entry.\n+     *\n+     * This method simply calls read( byte[], int, int ).\n+     *\n+     * @param b The byte written.\n+     * @throws IOException on error\n+     */\n+    public void write(int b) throws IOException {\n+        oneBuf[0] = (byte) b;\n+\n+        write(oneBuf, 0, 1);\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry.\n+     *\n+     * This method simply calls write( byte[], int, int ).\n+     *\n+     * @param wBuf The buffer to write to the archive.\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] wBuf) throws IOException {\n+        write(wBuf, 0, wBuf.length);\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method\n+     * is aware of the current entry and will throw an exception if\n+     * you attempt to write bytes past the length specified for the\n+     * current entry. The method is also (painfully) aware of the\n+     * record buffering required by TarBuffer, and manages buffers\n+     * that are not a multiple of recordsize in length, including\n+     * assembling records from small buffers.\n+     *\n+     * @param wBuf The buffer to write to the archive.\n+     * @param wOffset The offset in the buffer from which to get bytes.\n+     * @param numToWrite The number of bytes to write.\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n+        if ((currBytes + numToWrite) > currSize) {\n+            throw new IOException(\"request to write '\" + numToWrite\n+                                  + \"' bytes exceeds size in header of '\"\n+                                  + currSize + \"' bytes for entry '\"\n+                                  + currName + \"'\");\n+\n             //\n             // We have to deal with assembly!!!\n             // The programmer can be writing little 32 byte chunks for all\n             //\n         }\n \n-        if( m_assemLen > 0 )\n-        {\n-            if( ( m_assemLen + numToWrite ) >= m_recordBuf.length )\n-            {\n-                final int length = m_recordBuf.length - m_assemLen;\n-\n-                System.arraycopy( m_assemBuf, 0, m_recordBuf, 0,\n-                                  m_assemLen );\n-                System.arraycopy( buffer, position, m_recordBuf,\n-                                  m_assemLen, length );\n-                m_buffer.writeRecord( m_recordBuf );\n-\n-                m_currBytes += m_recordBuf.length;\n-                position += length;\n-                numToWrite -= length;\n-                m_assemLen = 0;\n-            }\n-            else\n-            {\n-                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n-                                  numToWrite );\n-\n-                position += numToWrite;\n-                m_assemLen += numToWrite;\n+        if (assemLen > 0) {\n+            if ((assemLen + numToWrite) >= recordBuf.length) {\n+                int aLen = recordBuf.length - assemLen;\n+\n+                System.arraycopy(assemBuf, 0, recordBuf, 0,\n+                                 assemLen);\n+                System.arraycopy(wBuf, wOffset, recordBuf,\n+                                 assemLen, aLen);\n+                buffer.writeRecord(recordBuf);\n+\n+                currBytes += recordBuf.length;\n+                wOffset += aLen;\n+                numToWrite -= aLen;\n+                assemLen = 0;\n+            } else {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n+                                 numToWrite);\n+\n+                wOffset += numToWrite;\n+                assemLen += numToWrite;\n                 numToWrite -= numToWrite;\n             }\n         }\n         // o An empty \"assemble\" buffer.\n         // o No bytes to write (numToWrite == 0)\n         //\n-        while( numToWrite > 0 )\n-        {\n-            if( numToWrite < m_recordBuf.length )\n-            {\n-                System.arraycopy( buffer, position, m_assemBuf, m_assemLen,\n-                                  numToWrite );\n-\n-                m_assemLen += numToWrite;\n+        while (numToWrite > 0) {\n+            if (numToWrite < recordBuf.length) {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n+                                 numToWrite);\n+\n+                assemLen += numToWrite;\n \n                 break;\n             }\n \n-            m_buffer.writeRecord( buffer, position );\n-\n-            int num = m_recordBuf.length;\n-\n-            m_currBytes += num;\n+            buffer.writeRecord(wBuf, wOffset);\n+\n+            int num = recordBuf.length;\n+\n+            currBytes += num;\n             numToWrite -= num;\n-            position += num;\n-        }\n-    }\n-\n-    /**\n-     * Write an EOF (end of archive) record to the tar archive. An EOF record\n-     * consists of a record of all zeros.\n-     *\n-     * @exception IOException when an IO error causes operation to fail\n-     */\n-    private void writeEOFRecord()\n-        throws IOException\n-    {\n-        for( int i = 0; i < m_recordBuf.length; ++i )\n-        {\n-            m_recordBuf[ i ] = 0;\n-        }\n-\n-        m_buffer.writeRecord( m_recordBuf );\n+            wOffset += num;\n+        }\n+    }\n+\n+    /**\n+     * Write an EOF (end of archive) record to the tar archive.\n+     * An EOF record consists of a record of all zeros.\n+     */\n+    private void writeEOFRecord() throws IOException {\n+        for (int i = 0; i < recordBuf.length; ++i) {\n+            recordBuf[i] = 0;\n+        }\n+\n+        buffer.writeRecord(recordBuf);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n \n /**\n  * This class provides static utility methods to work with byte streams.\n+ *\n  */\n-class TarUtils\n-{\n-    /**\n-     * Parse the checksum octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The integer value of the entry's checksum.\n-     */\n-    public static int getCheckSumOctalBytes( final long value,\n-                                             final byte[] buf,\n-                                             final int offset,\n-                                             final int length )\n-    {\n-        getOctalBytes( value, buf, offset, length );\n-\n-        buf[ offset + length - 1 ] = (byte)' ';\n-        buf[ offset + length - 2 ] = 0;\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Parse an octal long integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param value Description of Parameter\n-     * @param buf Description of Parameter\n-     * @return The long value of the octal bytes.\n-     */\n-    public static int getLongOctalBytes( final long value,\n-                                         final byte[] buf,\n-                                         final int offset,\n-                                         final int length )\n-    {\n-        byte[] temp = new byte[ length + 1 ];\n-\n-        getOctalBytes( value, temp, 0, length + 1 );\n-        System.arraycopy( temp, 0, buf, offset, length );\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Determine the number of bytes in an entry name.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @param name Description of Parameter\n-     * @param buffer Description of Parameter\n-     * @return The number of bytes in a header's entry name.\n-     */\n-    public static int getNameBytes( final StringBuffer name,\n-                                    final byte[] buffer,\n-                                    final int offset,\n-                                    final int length )\n-    {\n-        int i;\n-\n-        for( i = 0; i < length && i < name.length(); ++i )\n-        {\n-            buffer[ offset + i ] = (byte)name.charAt( i );\n-        }\n-\n-        for( ; i < length; ++i )\n-        {\n-            buffer[ offset + i ] = 0;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Parse an octal integer from a header buffer.\n-     *\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The integer value of the octal bytes.\n-     */\n-    public static int getOctalBytes( final long value,\n-                                     final byte[] buffer,\n-                                     final int offset,\n-                                     final int length )\n-    {\n-        int idx = length - 1;\n-\n-        buffer[ offset + idx ] = 0;\n-        --idx;\n-        buffer[ offset + idx ] = (byte)' ';\n-        --idx;\n-\n-        if( value == 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)'0';\n-            --idx;\n-        }\n-        else\n-        {\n-            long val = value;\n-            while( idx >= 0 && val > 0 )\n-            {\n-                buffer[ offset + idx ] = (byte)( (byte)'0' + (byte)( val & 7 ) );\n-                val = val >> 3;\n-                idx--;\n-            }\n-        }\n-\n-        while( idx >= 0 )\n-        {\n-            buffer[ offset + idx ] = (byte)' ';\n-            idx--;\n-        }\n-\n-        return offset + length;\n-    }\n-\n-    /**\n-     * Compute the checksum of a tar entry header.\n-     *\n-     * @param buffer The tar entry's header buffer.\n-     * @return The computed checksum.\n-     */\n-    public static long computeCheckSum( final byte[] buffer )\n-    {\n-        long sum = 0;\n-\n-        for( int i = 0; i < buffer.length; ++i )\n-        {\n-            sum += 255 & buffer[ i ];\n-        }\n-\n-        return sum;\n-    }\n-\n-    /**\n-     * Parse an entry name from a header buffer.\n+// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\n+public class TarUtils {\n+\n+    private static final int BYTE_MASK = 255;\n+\n+    /**\n+     * Parse an octal string from a header buffer. This is used for the\n+     * file permission mode value.\n      *\n      * @param header The header buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The number of header bytes to parse.\n-     * @return The header's entry name.\n-     */\n-    public static StringBuffer parseName( final byte[] header,\n-                                          final int offset,\n-                                          final int length )\n-    {\n-        StringBuffer result = new StringBuffer( length );\n-        int end = offset + length;\n-\n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n+     * @return The long value of the octal string.\n+     */\n+    public static long parseOctal(byte[] header, int offset, int length) {\n+        long    result = 0;\n+        boolean stillPadding = true;\n+        int     end = offset + length;\n+\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n                 break;\n             }\n \n-            result.append( (char)header[ i ] );\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Parse an octal string from a header buffer. This is used for the file\n-     * permission mode value.\n-     *\n-     * @param header The header buffer from which to parse.\n-     * @param offset The offset into the buffer from which to parse.\n-     * @param length The number of header bytes to parse.\n-     * @return The long value of the octal string.\n-     */\n-    public static long parseOctal( final byte[] header,\n-                                   final int offset,\n-                                   final int length )\n-    {\n-        long result = 0;\n-        boolean stillPadding = true;\n-        int end = offset + length;\n-\n-        for( int i = offset; i < end; ++i )\n-        {\n-            if( header[ i ] == 0 )\n-            {\n-                break;\n-            }\n-\n-            if( header[ i ] == (byte)' ' || header[ i ] == '0' )\n-            {\n-                if( stillPadding )\n-                {\n+            if (header[i] == (byte) ' ' || header[i] == '0') {\n+                if (stillPadding) {\n                     continue;\n                 }\n \n-                if( header[ i ] == (byte)' ' )\n-                {\n+                if (header[i] == (byte) ' ') {\n                     break;\n                 }\n             }\n \n             stillPadding = false;\n-            result = ( result << 3 ) + ( header[ i ] - '0' );\n+            // CheckStyle:MagicNumber OFF\n+            result = (result << 3) + (header[i] - '0');\n+            // CheckStyle:MagicNumber ON\n         }\n \n         return result;\n     }\n+\n+    /**\n+     * Parse an entry name from a header buffer.\n+     *\n+     * @param header The header buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The header's entry name.\n+     */\n+    public static StringBuffer parseName(byte[] header, int offset, int length) {\n+        StringBuffer result = new StringBuffer(length);\n+        int          end = offset + length;\n+\n+        for (int i = offset; i < end; ++i) {\n+            if (header[i] == 0) {\n+                break;\n+            }\n+\n+            result.append((char) header[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Determine the number of bytes in an entry name.\n+     *\n+     * @param name The header name from which to parse.\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The number of bytes in a header's entry name.\n+     */\n+    public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) {\n+        int i;\n+\n+        for (i = 0; i < length && i < name.length(); ++i) {\n+            buf[offset + i] = (byte) name.charAt(i);\n+        }\n+\n+        for (; i < length; ++i) {\n+            buf[offset + i] = 0;\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the octal bytes.\n+     */\n+    public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n+        int    idx = length - 1;\n+\n+        buf[offset + idx] = 0;\n+        --idx;\n+        buf[offset + idx] = (byte) ' ';\n+        --idx;\n+\n+        if (value == 0) {\n+            buf[offset + idx] = (byte) '0';\n+            --idx;\n+        } else {\n+            for (long val = value; idx >= 0 && val > 0; --idx) {\n+                // CheckStyle:MagicNumber OFF\n+                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));\n+                val = val >> 3;\n+                // CheckStyle:MagicNumber ON\n+            }\n+        }\n+\n+        for (; idx >= 0; --idx) {\n+            buf[offset + idx] = (byte) ' ';\n+        }\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse an octal long integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The long value of the octal bytes.\n+     */\n+    public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n+        byte[] temp = new byte[length + 1];\n+\n+        getOctalBytes(value, temp, 0, length + 1);\n+        System.arraycopy(temp, 0, buf, offset, length);\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Parse the checksum octal integer from a header buffer.\n+     *\n+     * @param value The header value\n+     * @param buf The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The number of header bytes to parse.\n+     * @return The integer value of the entry's checksum.\n+     */\n+    public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n+        getOctalBytes(value, buf, offset, length);\n+\n+        buf[offset + length - 1] = (byte) ' ';\n+        buf[offset + length - 2] = 0;\n+\n+        return offset + length;\n+    }\n+\n+    /**\n+     * Compute the checksum of a tar entry header.\n+     *\n+     * @param buf The tar entry's header buffer.\n+     * @return The computed checksum.\n+     */\n+    public static long computeCheckSum(byte[] buf) {\n+        long sum = 0;\n+\n+        for (int i = 0; i < buf.length; ++i) {\n+            sum += BYTE_MASK & buf[i];\n+        }\n+\n+        return sum;\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n         final TarArchiveEntry entry = new TarArchiveEntry(\"testdata/test1.xml\");\n         entry.setModTime(0);\n         entry.setSize(file1.length());\n-        entry.setUserID(0);\n-        entry.setGroupID(0);\n+        entry.setUserId(0);\n+        entry.setGroupId(0);\n         entry.setUserName(\"avalon\");\n         entry.setGroupName(\"excalibur\");\n         entry.setMode(0100000);\n         final TarArchiveEntry entry = new TarArchiveEntry(name);\n         entry.setModTime(0);\n         entry.setSize(file1.length());\n-        entry.setUserID(0);\n-        entry.setGroupID(0);\n+        entry.setUserId(0);\n+        entry.setGroupId(0);\n         entry.setUserName(\"avalon\");\n         entry.setGroupName(\"excalibur\");\n         entry.setMode(0100000);\n         \tfinal TarArchiveEntry entry2 = new TarArchiveEntry(toLongName);\n         \tentry2.setModTime(0);\n         \tentry2.setSize(file1.length());\n-        \tentry2.setUserID(0);\n-        \tentry2.setGroupID(0);\n+        \tentry2.setUserId(0);\n+        \tentry2.setGroupId(0);\n         \tentry2.setUserName(\"avalon\");\n         \tentry2.setGroupName(\"excalibur\");\n         \tentry2.setMode(0100000);", "timestamp": 1231412965, "metainfo": ""}