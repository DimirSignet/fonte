{"sha": "07ec353c6066f81e619a7f90039aae0dbcd3b69a", "log": "reduce public API of dump package, fix equals in DumpArchiveSummary. COMPRESS-132  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n-\n /**\n  * Directory entry.\n  */\n-public class Dirent {\n+class Dirent {\n     private int ino;\n     private int parentIno;\n     private int type;\n      * @param type\n      * @param name\n      */\n-    public Dirent(int ino, int parentIno, int type, String name) {\n+    Dirent(int ino, int parentIno, int type, String name) {\n         this.ino = ino;\n         this.parentIno = parentIno;\n         this.type = type;\n      * Get ino.\n      * @return the i-node\n      */\n-    public int getIno() {\n+    int getIno() {\n         return ino;\n     }\n \n      * Get ino of parent directory.\n      * @return the parent i-node\n      */\n-    public int getParentIno() {\n+    int getParentIno() {\n         return parentIno;\n     }\n \n      * Get entry type.\n      * @return the entry type\n      */\n-    public int getType() {\n+    int getType() {\n         return type;\n     }\n \n      * Get name of directory entry.\n      * @return the directory name\n      */\n-    public String getName() {\n+    String getName() {\n         return name;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n      * @param buffer\n      * @throws Exception\n      */\n-    public static DumpArchiveEntry parse(byte[] buffer) {\n+    static DumpArchiveEntry parse(byte[] buffer) {\n         DumpArchiveEntry entry = new DumpArchiveEntry();\n         TapeSegmentHeader header = entry.header;\n \n     /**\n      * Update entry with information from next tape segment header.\n      */\n-    public void update(byte[] buffer) {\n+    void update(byte[] buffer) {\n         header.volume = DumpArchiveUtil.convert32(buffer, 16);\n         header.count = DumpArchiveUtil.convert32(buffer, 160);\n \n      * Archive entry as stored on tape. There is one TSH for (at most)\n      * every 512k in the file.\n      */\n-    public static class TapeSegmentHeader {\n+    static class TapeSegmentHeader {\n         private DumpArchiveConstants.SEGMENT_TYPE type;\n         private int volume;\n         private int ino;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n     /**\n      * Read CLRI (deleted inode) segment.\n      */\n-    public void readCLRI() throws IOException {\n+    private void readCLRI() throws IOException {\n         byte[] readBuf = raw.readRecord();\n \n         if (!DumpArchiveUtil.verify(readBuf)) {\n     /**\n      * Read BITS segment.\n      */\n-    public void readBITS() throws IOException {\n+    private void readBITS() throws IOException {\n         byte[] readBuf = raw.readRecord();\n \n         if (!DumpArchiveUtil.verify(readBuf)) {\n     /**\n      * Read directory entry.\n      */\n-    public void readDirectoryEntry(DumpArchiveEntry entry)\n+    private void readDirectoryEntry(DumpArchiveEntry entry)\n         throws IOException {\n         long size = entry.getSize();\n         boolean first = true;\n      * @param entry\n      * @return  full path for specified archive entry, or null if there's a gap.\n      */\n-    public String getPath(DumpArchiveEntry entry) {\n+    private String getPath(DumpArchiveEntry entry) {\n         // build the stack of elements. It's possible that we're \n         // still missing an intermediate value and if so we\n         Stack<String> elements = new Stack<String>();\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n     private int firstrec;\n     private int ntrec;\n \n-    public DumpArchiveSummary(byte[] buffer) {\n+    DumpArchiveSummary(byte[] buffer) {\n         dumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 4));\n         previousDumpDate = new Date(1000L * DumpArchiveUtil.convert32(buffer, 8));\n         volume = DumpArchiveUtil.convert32(buffer, 12);\n             return true;\n         }\n \n-        if (!(o instanceof DumpArchiveSummary)) {\n+        if (!o.getClass().equals(getClass())) {\n             return false;\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n /**\n  * Various utilities for dump archives.\n  */\n-public class DumpArchiveUtil {\n+class DumpArchiveUtil {\n     /**\n      * Private constructor to prevent instantiation.\n      */\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n  *\n  * @NotThreadSafe\n  */\n-public class TapeInputStream extends FilterInputStream {\n+class TapeInputStream extends FilterInputStream {\n     private byte[] blockBuffer = new byte[DumpArchiveConstants.TP_SIZE];\n     private int currBlkIdx = -1;\n     private int blockSize = DumpArchiveConstants.TP_SIZE;", "timestamp": 1313464412, "metainfo": ""}