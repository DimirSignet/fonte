{"sha": "dd71368488dd8e0fb0bf8f7aabd4f702502d5615", "log": "COMPRESS-289 use a stable last modified time for long name entry, based on patch by  Bob Robertson   ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n         TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n         Map<String, String> paxHeaders = new HashMap<String, String>();\n         final String entryName = entry.getName();\n-        boolean paxHeaderContainsPath = handleLongName(entryName, paxHeaders, \"path\",\n+        boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n                                                        TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n \n         final String linkName = entry.getLinkName();\n         boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n-            && handleLongName(linkName, paxHeaders, \"linkpath\",\n+            && handleLongName(entry, linkName, paxHeaders, \"linkpath\",\n                               TarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\n \n         if (bigNumberMode == BIGNUMBER_POSIX) {\n      *   <li>it truncates the name if longFileMode is TRUNCATE</li>\n      * </ul></p>\n      *\n+     * @param entry entry the name belongs to\n      * @param name the name to write\n      * @param paxHeaders current map of pax headers\n      * @param paxHeaderName name of the pax header to write\n      * @param fieldName the name of the field\n      * @return whether a pax header has been written.\n      */\n-    private boolean handleLongName(String name,\n+    private boolean handleLongName(TarArchiveEntry entry , String name,\n                                    Map<String, String> paxHeaders,\n                                    String paxHeaderName, byte linkType, String fieldName)\n         throws IOException {\n                 TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n \n                 longLinkEntry.setSize(len + 1); // +1 for NUL\n+                longLinkEntry.setModTime(entry.getModTime());\n                 putArchiveEntry(longLinkEntry);\n                 write(encodedName.array(), encodedName.arrayOffset(), len);\n                 write(0); // NUL terminator\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.security.MessageDigest;\n import java.util.Calendar;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.TimeZone;\n \n import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n import org.apache.commons.compress.utils.CharsetNames;\n import org.apache.commons.compress.utils.IOUtils;\n+\n+import org.junit.Assert;\n \n public class TarArchiveOutputStreamTest extends AbstractTestCase {\n \n             tos.putArchiveEntry(t);\n             tos.closeArchiveEntry();\n             tos.close();\n-            \n+\n             fail(\"Truncated name didn't throw an exception\");\n         } catch (RuntimeException e) {\n             // expected\n                 + \"01234567890123456789012345678901234567890123456789/test\";\n         TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n-        \n+\n         try {\n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n             tos.putArchiveEntry(entry);\n             tos.closeArchiveEntry();\n             tos.close();\n-            \n+\n             fail(\"Truncated link name didn't throw an exception\");\n         } catch (RuntimeException e) {\n             // expected\n             + \"01234567890123456789012345678901234567890123456789/\";\n         TarArchiveEntry entry = new TarArchiveEntry(\"test\" , TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n-        \n+\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_TRUNCATE);\n         tos.putArchiveEntry(entry);\n         tos.closeArchiveEntry();\n         tos.close();\n-        \n+\n         byte[] data = bos.toByteArray();\n         TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n             + \"01234567890123456789012345678901234567890123456789/test\";\n         TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n-        \n+\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(mode);\n         tos.putArchiveEntry(entry);\n         tos.closeArchiveEntry();\n         tos.close();\n-        \n+\n         byte[] data = bos.toByteArray();\n         TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(TarConstants.DEFAULT_BLKSIZE, f.length());\n     }\n \n+    /**\n+     * When using long file names the longLinkEntry included the\n+     * current timestamp as the Entry modification date. This was\n+     * never exposed to the client but it caused identical archives to\n+     * have different MD5 hashes.\n+     *\n+     * @throws Exception\n+     */\n+    public void testLongNameMd5Hash() throws Exception {\n+        final String longFileName = \"a/considerably/longer/file/name/which/forces/use/of/the/long/link/header/which/appears/to/always/use/the/current/time/as/modification/date\";\n+        String fname = longFileName;\n+        final Date modificationDate = new Date();\n+\n+        byte[] archive1 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n+        byte[] digest1 = MessageDigest.getInstance(\"MD5\").digest(archive1);\n+\n+        // let a second elapse otherwise the modification dates will be equal\n+        Thread.sleep(1000L);\n+\n+        // now recreate exactly the same tar file\n+        byte[] archive2 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n+        // and I would expect the MD5 hash to be the same, but for long names it isn't\n+        byte[] digest2 = MessageDigest.getInstance(\"MD5\").digest(archive2);\n+\n+        Assert.assertArrayEquals(digest1, digest2);\n+\n+        // do I still have the correct modification date?\n+        // let a second elapse so we don't get the current time\n+        Thread.sleep(1000);\n+        TarArchiveInputStream tarIn = new TarArchiveInputStream(new ByteArrayInputStream(archive2));\n+        ArchiveEntry nextEntry = tarIn.getNextEntry();\n+        assertEquals(longFileName, nextEntry.getName());\n+        // tar archive stores modification time to second granularity only (floored)\n+        assertEquals(modificationDate.getTime() / 1000, nextEntry.getLastModifiedDate().getTime() / 1000);\n+        tarIn.close();\n+    }\n+\n+    private static byte[] createTarArchiveContainingOneDirectory(String fname, Date modificationDate) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        TarArchiveOutputStream tarOut = new TarArchiveOutputStream(baos, 1024);\n+        tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+        TarArchiveEntry tarEntry = new TarArchiveEntry(\"d\");\n+        tarEntry.setModTime(modificationDate);\n+        tarEntry.setMode(TarArchiveEntry.DEFAULT_DIR_MODE);\n+        tarEntry.setModTime(modificationDate.getTime());\n+        tarEntry.setName(fname);\n+        tarOut.putArchiveEntry(tarEntry);\n+        tarOut.closeArchiveEntry();\n+        tarOut.close();\n+\n+        return baos.toByteArray();\n+    }\n+\n }", "timestamp": 1411148295, "metainfo": ""}