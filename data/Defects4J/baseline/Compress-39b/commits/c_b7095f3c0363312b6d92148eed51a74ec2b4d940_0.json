{"sha": "b7095f3c0363312b6d92148eed51a74ec2b4d940", "log": "Pack200 support.  COMPRESS-142  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n+import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n+import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;\n \n /**\n  * <p>Factory to create Compressor[In|Out]putStreams from names. To add other\n  *      new CompressorStreamFactory().createCompressorOutputStream(CompressorStreamFactory.BZIP2, out);\n  * IOUtils.copy(new FileInputStream(input), cos);\n  * cos.close();\n- * </pre>    \n+ * </pre>\n  * \n  * Example (Compressing a file):\n  * <pre>\n      * @since Commons Compress 1.1\n      */\n     public static final String GZIP = \"gz\";\n+    /**\n+     * Constant used to identify the PACK200 compression algorithm.\n+     * @since Commons Compress 1.3\n+     */\n+    public static final String PACK200 = \"pack200\";\n \n     /**\n      * Create an compressor input stream from an input stream, autodetecting\n         try {\n             int signatureLength = in.read(signature);\n             in.reset();\n-            \n+\n             if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n                 return new BZip2CompressorInputStream(in);\n             }\n-            \n+\n             if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n                 return new GzipCompressorInputStream(in);\n+            }\n+\n+            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n+                return new Pack200CompressorInputStream(in);\n             }\n \n         } catch (IOException e) {\n \n         throw new CompressorException(\"No Compressor found for the stream signature.\");\n     }\n-    \n+\n     /**\n      * Create a compressor input stream from a compressor name and an input stream.\n      * \n-     * @param name of the compressor, i.e. \"gz\" or \"bzip2\"\n+     * @param name of the compressor, i.e. \"gz\", \"bzip2\" or \"pack200\"\n      * @param in the input stream\n      * @return compressor input stream\n      * @throws CompressorException if the compressor name is not known\n         }\n \n         try {\n-            \n+\n             if (GZIP.equalsIgnoreCase(name)) {\n                 return new GzipCompressorInputStream(in);\n             }\n-            \n+\n             if (BZIP2.equalsIgnoreCase(name)) {\n                 return new BZip2CompressorInputStream(in);\n             }\n-            \n+\n+            if (PACK200.equalsIgnoreCase(name)) {\n+                return new Pack200CompressorInputStream(in);\n+            }\n+\n         } catch (IOException e) {\n             throw new CompressorException(\n                     \"Could not create CompressorInputStream.\", e);\n     /**\n      * Create an compressor output stream from an compressor name and an input stream.\n      * \n-     * @param name the compressor name, i.e. \"gz\" or \"bzip2\"\n+     * @param name the compressor name, i.e. \"gz\", \"bzip2\" or \"pack200\"\n      * @param out the output stream\n      * @return the compressor output stream\n      * @throws CompressorException if the archiver name is not known\n             if (GZIP.equalsIgnoreCase(name)) {\n                 return new GzipCompressorOutputStream(out);\n             }\n-            \n+\n             if (BZIP2.equalsIgnoreCase(name)) {\n                 return new BZip2CompressorOutputStream(out);\n             }\n-        \n+\n+            if (PACK200.equalsIgnoreCase(name)) {\n+                return new Pack200CompressorOutputStream(out);\n+            }\n+\n         } catch (IOException e) {\n             throw new CompressorException(\n                     \"Could not create CompressorOutputStream\", e);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/InMemoryStreamSwitcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * StreamSwitcher that caches all data written to the output side in\n+ * memory.\n+ * @since Apache Commons Compress 1.3\n+ */\n+class InMemoryStreamSwitcher extends StreamSwitcher {\n+    InMemoryStreamSwitcher() {\n+        super(new ByteArrayOutputStream());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    InputStream getInputView() throws IOException {\n+        return new ByteArrayInputStream(((ByteArrayOutputStream) out)\n+                                        .toByteArray());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.File;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Pack200;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * An input stream that decompresses from the Pack200 format to be read\n+ * as any other stream.\n+ * \n+ * @NotThreadSafe\n+ * @since Apache Commons Compress 1.3\n+ */\n+public class Pack200CompressorInputStream extends CompressorInputStream {\n+    private final InputStream originalInput;\n+    private final StreamSwitcher streamSwitcher;\n+\n+    /**\n+     * Decompresses the given stream, caching the decompressed data in\n+     * memory.\n+     *\n+     * <p>When reading from a file the File-arg constructor may\n+     * provide better performance.</p>\n+     */\n+    public Pack200CompressorInputStream(final InputStream in)\n+        throws IOException {\n+        this(in, StreamMode.IN_MEMORY);\n+    }\n+\n+    /**\n+     * Decompresses the given stream using the given strategy to cache\n+     * the results.\n+     *\n+     * <p>When reading from a file the File-arg constructor may\n+     * provide better performance.</p>\n+     */\n+    public Pack200CompressorInputStream(final InputStream in,\n+                                        final StreamMode mode)\n+        throws IOException {\n+        this(in, null, mode, null);\n+    }\n+\n+    /**\n+     * Decompresses the given stream, caching the decompressed data in\n+     * memory and using the given properties.\n+     *\n+     * <p>When reading from a file the File-arg constructor may\n+     * provide better performance.</p>\n+     */\n+    public Pack200CompressorInputStream(final InputStream in,\n+                                        final Map<String, String> props)\n+        throws IOException {\n+        this(in, StreamMode.IN_MEMORY, props);\n+    }\n+\n+    /**\n+     * Decompresses the given stream using the given strategy to cache\n+     * the results and the given properties.\n+     *\n+     * <p>When reading from a file the File-arg constructor may\n+     * provide better performance.</p>\n+     */\n+    public Pack200CompressorInputStream(final InputStream in,\n+                                        final StreamMode mode,\n+                                        final Map<String, String> props)\n+        throws IOException {\n+        this(in, null, mode, props);\n+    }\n+\n+    /**\n+     * Decompresses the given file, caching the decompressed data in\n+     * memory.\n+     */\n+    public Pack200CompressorInputStream(final File f) throws IOException {\n+        this(f, StreamMode.IN_MEMORY);\n+    }\n+\n+    /**\n+     * Decompresses the given file using the given strategy to cache\n+     * the results.\n+     */\n+    public Pack200CompressorInputStream(final File f, final StreamMode mode)\n+        throws IOException {\n+        this(null, f, mode, null);\n+    }\n+\n+    /**\n+     * Decompresses the given file, caching the decompressed data in\n+     * memory and using the given properties.\n+     */\n+    public Pack200CompressorInputStream(final File f,\n+                                        final Map<String, String> props)\n+        throws IOException {\n+        this(f, StreamMode.IN_MEMORY, props);\n+    }\n+\n+    /**\n+     * Decompresses the given file using the given strategy to cache\n+     * the results and the given properties.\n+     */\n+    public Pack200CompressorInputStream(final File f, final StreamMode mode,\n+                                        final Map<String, String> props)\n+        throws IOException {\n+        this(null, f, mode, props);\n+    }\n+\n+    private Pack200CompressorInputStream(final InputStream in, final File f,\n+                                         final StreamMode mode,\n+                                         final Map<String, String> props)\n+        throws IOException {\n+        originalInput = in;\n+        streamSwitcher = mode.newStreamSwitcher();\n+        JarOutputStream jarOut = new JarOutputStream(streamSwitcher);\n+        Pack200.Unpacker u = Pack200.newUnpacker();\n+        if (props != null) {\n+            u.properties().putAll(props);\n+        }\n+        if (f == null) {\n+            u.unpack(new FilterInputStream(in) {\n+                    @Override\n+                        public void close() {\n+                        // unpack would close this stream but we\n+                        // want to give the user code more control\n+                    }\n+                },\n+                jarOut);\n+        } else {\n+            u.unpack(f, jarOut);\n+        }\n+        jarOut.close();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read() throws IOException {\n+        return streamSwitcher.getInput().read();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] b) throws IOException {\n+        return streamSwitcher.getInput().read(b);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int read(byte[] b, int off, int count) throws IOException {\n+        return streamSwitcher.getInput().read(b, off, count);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int available() throws IOException {\n+        return streamSwitcher.getInput().available();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean markSupported() {\n+        try {\n+            return streamSwitcher.getInput().markSupported();\n+        } catch (IOException ex) {\n+            return false;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void mark(int limit) {\n+        try {\n+            streamSwitcher.getInput().mark(limit);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void reset() throws IOException {\n+        streamSwitcher.getInput().reset();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public long skip(long count) throws IOException {\n+        return streamSwitcher.getInput().skip(count);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        try {\n+            streamSwitcher.stop();\n+        } finally {\n+            if (originalInput != null) {\n+                originalInput.close();\n+            }\n+        }\n+    }\n+\n+    private static final byte[] CAFE_DOOD = new byte[] {\n+        (byte) 0xCA, (byte) 0xFE, (byte) 0xD0, (byte) 0x0D\n+    };\n+\n+    /**\n+     * Checks if the signature matches what is expected for a pack200\n+     * file (0xCAFED00D).\n+     * \n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is a pack200 compressed stream,\n+     * false otherwise\n+     */\n+    public static boolean matches(byte[] signature, int length) {\n+        if (length < 4) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < 4; i++) {\n+            if (signature[i] != CAFE_DOOD[i]) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Map;\n+import java.util.jar.JarInputStream;\n+import java.util.jar.Pack200;\n+\n+import org.apache.commons.compress.compressors.CompressorOutputStream;\n+\n+/**\n+ * An output stream that compresses using the Pack200 format.\n+ * \n+ * @NotThreadSafe\n+ * @since Apache Commons Compress 1.3\n+ */\n+public class Pack200CompressorOutputStream extends CompressorOutputStream {\n+    private boolean finished = false;\n+    private final OutputStream originalOutput;\n+    private final StreamSwitcher streamSwitcher;\n+    private final Map<String, String> properties;\n+\n+    /**\n+     * Compresses the given stream, caching the compressed data in\n+     * memory.\n+     */\n+    public Pack200CompressorOutputStream(final OutputStream out)\n+        throws IOException {\n+        this(out, StreamMode.IN_MEMORY);\n+    }\n+\n+    /**\n+     * Compresses the given stream using the given strategy to cache\n+     * the results.\n+     */\n+    public Pack200CompressorOutputStream(final OutputStream out,\n+                                         final StreamMode mode)\n+        throws IOException {\n+        this(out, mode, null);\n+    }\n+\n+    /**\n+     * Compresses the given stream, caching the compressed data in\n+     * memory and using the given properties.\n+     */\n+    public Pack200CompressorOutputStream(final OutputStream out,\n+                                         final Map<String, String> props)\n+        throws IOException {\n+        this(out, StreamMode.IN_MEMORY, props);\n+    }\n+\n+    /**\n+     * Compresses the given stream using the given strategy to cache\n+     * the results and the given properties.\n+     */\n+    public Pack200CompressorOutputStream(final OutputStream out,\n+                                         final StreamMode mode,\n+                                         final Map<String, String> props)\n+        throws IOException {\n+        originalOutput = out;\n+        streamSwitcher = mode.newStreamSwitcher();\n+        properties = props;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void write(int b) throws IOException {\n+        streamSwitcher.write(b);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void write(byte[] b) throws IOException {\n+        streamSwitcher.write(b);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void write(byte[] b, int from, int length) throws IOException {\n+        streamSwitcher.write(b, from, length);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        finish();\n+        try {\n+            streamSwitcher.stop();\n+        } finally {\n+            originalOutput.close();\n+        }\n+    }\n+\n+    public void finish() throws IOException {\n+        if (!finished) {\n+            finished = true;\n+            Pack200.Packer p = Pack200.newPacker();\n+            if (properties != null) {\n+                p.properties().putAll(properties);\n+            }\n+            p.pack(new JarInputStream(streamSwitcher.getInput()),\n+                   originalOutput);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/StreamMode.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.IOException;\n+\n+/**\n+ * The different modes the Pack200 streams can use to wrap input and\n+ * output.\n+ * @since Apache Commons Compress 1.3\n+ */\n+public enum StreamMode {\n+    /** Cache output in memory */\n+    IN_MEMORY() {\n+        StreamSwitcher newStreamSwitcher() {\n+            return new InMemoryStreamSwitcher();\n+        }\n+    },\n+    /** Cache output in a temporary file */\n+    TEMP_FILE() {\n+        StreamSwitcher newStreamSwitcher() throws IOException {\n+            return new TempFileStreamSwitcher();\n+        }\n+    };\n+\n+    abstract StreamSwitcher newStreamSwitcher() throws IOException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/StreamSwitcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides an InputStream to read all data written to this\n+ * OutputStream.\n+ *\n+ * @ThreadSafe\n+ * @since Apache Commons Compress 1.3\n+ */\n+abstract class StreamSwitcher extends FilterOutputStream {\n+    private InputStream input;\n+    private final Object INPUT_LOCK = new Object();\n+\n+    protected StreamSwitcher(OutputStream out) {\n+        super(out);\n+    }\n+\n+    protected StreamSwitcher() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Provides the input view.\n+     */\n+    InputStream getInput() throws IOException {\n+        synchronized (INPUT_LOCK) {\n+            if (input == null) {\n+                input = getInputView();\n+            }\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Creates the input view.\n+     */\n+    abstract InputStream getInputView() throws IOException;\n+\n+    /**\n+     * Closes input and output and releases all associated resources.\n+     */\n+    void stop() throws IOException {\n+        close();\n+        synchronized (INPUT_LOCK) {\n+            if (input != null) {\n+                input.close();\n+                input = null;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/TempFileStreamSwitcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * StreamSwitcher that caches all data written to the output side in\n+ * a temporary file.\n+ * @since Apache Commons Compress 1.3\n+ */\n+class TempFileStreamSwitcher extends StreamSwitcher {\n+    private final File f;\n+\n+    TempFileStreamSwitcher() throws IOException {\n+        f = File.createTempFile(\"commons-compress\", \"packtemp\");\n+        f.deleteOnExit();\n+        out = new FileOutputStream(f);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    InputStream getInputView() throws IOException {\n+        out.close();\n+        return new FileInputStream(f) {\n+            @Override\n+            public void close() throws IOException {\n+                super.close();\n+                f.delete();\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/Pack200TestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n+import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;\n+import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;\n+import org.apache.commons.compress.compressors.pack200.StreamMode;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class Pack200TestCase extends AbstractTestCase {\n+\n+    public void testJarUnarchiveAllInMemory() throws Exception {\n+        jarUnarchiveAll(false, StreamMode.IN_MEMORY);\n+    }\n+\n+    public void testJarUnarchiveAllFileArgInMemory() throws Exception {\n+        jarUnarchiveAll(true, StreamMode.IN_MEMORY);\n+    }\n+\n+    public void testJarUnarchiveAllTempFile() throws Exception {\n+        jarUnarchiveAll(false, StreamMode.TEMP_FILE);\n+    }\n+\n+    public void testJarUnarchiveAllFileTempFile() throws Exception {\n+        jarUnarchiveAll(true, StreamMode.TEMP_FILE);\n+    }\n+\n+    private void jarUnarchiveAll(boolean useFile, StreamMode mode)\n+        throws Exception {\n+        final File input = getFile(\"bla.pack\");\n+        final InputStream is = useFile\n+            ? new Pack200CompressorInputStream(input, mode)\n+            : new Pack200CompressorInputStream(new FileInputStream(input),\n+                                               mode);\n+        try {\n+            final ArchiveInputStream in = new ArchiveStreamFactory()\n+                .createArchiveInputStream(\"jar\", is);\n+\n+            ArchiveEntry entry = in.getNextEntry();\n+            while (entry != null) {\n+                File archiveEntry = new File(dir, entry.getName());\n+                archiveEntry.getParentFile().mkdirs();\n+                if (entry.isDirectory()) {\n+                    archiveEntry.mkdir();\n+                    entry = in.getNextEntry();\n+                    continue;\n+                }\n+                OutputStream out = new FileOutputStream(archiveEntry);\n+                IOUtils.copy(in, out);\n+                out.close();\n+                entry = in.getNextEntry();\n+            }\n+\n+            in.close();\n+        } finally {\n+            is.close();\n+        }\n+    }\n+\n+    public void testJarArchiveCreationInMemory() throws Exception {\n+        jarArchiveCreation(StreamMode.IN_MEMORY);\n+    }\n+\n+    public void testJarArchiveCreationTempFile() throws Exception {\n+        jarArchiveCreation(StreamMode.TEMP_FILE);\n+    }\n+\n+    private void jarArchiveCreation(StreamMode mode) throws Exception {\n+        final File output = new File(dir, \"bla.pack\");\n+\n+        final File file1 = getFile(\"test1.xml\");\n+        final File file2 = getFile(\"test2.xml\");\n+\n+        final OutputStream out = \n+            new Pack200CompressorOutputStream(new FileOutputStream(output),\n+                                              mode);\n+        try {\n+            final ArchiveOutputStream os = new ArchiveStreamFactory()\n+                .createArchiveOutputStream(\"jar\", out);\n+\n+            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n+            IOUtils.copy(new FileInputStream(file1), os);\n+            os.closeArchiveEntry();\n+\n+            os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n+            IOUtils.copy(new FileInputStream(file2), os);\n+            os.closeArchiveEntry();\n+\n+            os.close();\n+        } finally {\n+            out.close();\n+        }\n+\n+        final InputStream is = new Pack200CompressorInputStream(output);\n+        try {\n+            final ArchiveInputStream in = new ArchiveStreamFactory()\n+                .createArchiveInputStream(\"jar\", is);\n+            List<String> files = new ArrayList<String>();\n+            files.add(\"testdata/test1.xml\");\n+            files.add(\"testdata/test2.xml\");\n+            checkArchiveContent(in, files);\n+            in.close();\n+        } finally {\n+            is.close();\n+        }\n+    }\n+\n+    public void testGoodSignature() throws Exception {\n+        final InputStream is = new FileInputStream(getFile(\"bla.pack\"));\n+        try {\n+            byte[] sig = new byte[4];\n+            is.read(sig);\n+            assertTrue(Pack200CompressorInputStream.matches(sig, 4));\n+        } finally {\n+            is.close();\n+        }\n+    }\n+\n+    public void testBadSignature() throws Exception {\n+        final InputStream is = new FileInputStream(getFile(\"bla.jar\"));\n+        try {\n+            byte[] sig = new byte[4];\n+            is.read(sig);\n+            assertFalse(Pack200CompressorInputStream.matches(sig, 4));\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}", "timestamp": 1315107747, "metainfo": ""}