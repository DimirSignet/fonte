{"sha": "db52cdc5c56ab73e8e8f9b6c7bdab01c2d6e25e9", "log": "Add read-only support for the .Z file format.    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.z;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * Input stream that decompresses .Z files.\n+ * @NotThreadSafe\n+ * @since 1.7\n+ */\n+public class ZCompressorInputStream extends CompressorInputStream {\n+    private static final int MAGIC_1 = 0x1f;\n+    private static final int MAGIC_2 = 0x9d;\n+    private static final int BLOCK_MODE_MASK = 0x80;\n+    private static final int MAX_CODE_SIZE_MASK = 0x1f;\n+    private final InputStream in;\n+    private final boolean blockMode;\n+    private final int clearCode;\n+    private final int maxCodeSize;\n+    private int codeSize = 9;\n+    private int bitsCached = 0;\n+    private int bitsCachedSize = 0;\n+    private long totalCodesRead = 0;\n+    private int previousEntry = -1;\n+    private int tableSize = 0;\n+    private final int[] prefixes;\n+    private final byte[] characters;\n+    private final byte[] outputStack;\n+    private int outputStackLocation;\n+    \n+    public ZCompressorInputStream(InputStream inputStream) throws IOException {\n+        this.in = inputStream;\n+        int firstByte = in.read();\n+        int secondByte = in.read();\n+        int thirdByte = in.read();\n+        if (firstByte != MAGIC_1 || secondByte != MAGIC_2 || thirdByte < 0) {\n+            throw new IOException(\"Input is not in .Z format\");\n+        }\n+        blockMode = ((thirdByte & BLOCK_MODE_MASK) != 0);\n+        maxCodeSize = thirdByte & MAX_CODE_SIZE_MASK;\n+        if (blockMode) {\n+            clearCode = (1 << (codeSize - 1));\n+        } else {\n+            clearCode = -1; // unused\n+        }\n+        final int maxTableSize = 1 << maxCodeSize;\n+        prefixes = new int[maxTableSize];\n+        characters = new byte[maxTableSize];\n+        outputStack = new byte[maxTableSize];\n+        outputStackLocation = maxTableSize;\n+        for (int i = 0; i < (1 << 8); i++) {\n+            prefixes[i] = -1;\n+            characters[i] = (byte)i;\n+        }\n+        clearEntries();\n+    }\n+    \n+    private void clearEntries() {\n+        tableSize = (1 << 8);\n+        if (blockMode) {\n+            tableSize++;\n+        }\n+    }\n+\n+    private int readNextCode() throws IOException {\n+        while (bitsCachedSize < codeSize) {\n+            final int nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            bitsCached |= (nextByte << bitsCachedSize);\n+            bitsCachedSize += 8;\n+        }\n+        final int mask = (1 << codeSize) - 1;\n+        final int code = (bitsCached & mask);\n+        bitsCached >>>= codeSize;\n+        bitsCachedSize -= codeSize;\n+        ++totalCodesRead;\n+        return code;\n+    }\n+    \n+    private void reAlignReading() throws IOException {\n+        // \"compress\" works in multiples of 8 symbols, each codeBits bits long.\n+        // When codeBits changes, the remaining unused symbols in the current\n+        // group of 8 are still written out, in the old codeSize,\n+        // as garbage values (usually zeroes) that need to be skipped.\n+        long codeReadsToThrowAway = 8 - (totalCodesRead % 8);\n+        if (codeReadsToThrowAway == 8) {\n+            codeReadsToThrowAway = 0;\n+        }\n+        for (long i = 0; i < codeReadsToThrowAway; i++) {\n+            readNextCode();\n+        }\n+        bitsCached = 0;\n+        bitsCachedSize = 0;\n+    }\n+    \n+    private void addEntry(int previousEntry, byte character) throws IOException {\n+        if (tableSize >= ((1 << codeSize) - 1)) {\n+            if (tableSize == ((1 << codeSize) - 1)) {\n+                if (codeSize < maxCodeSize) {\n+                    reAlignReading();\n+                    codeSize++;\n+                    prefixes[tableSize] = previousEntry;\n+                    characters[tableSize] = character;\n+                    tableSize++;\n+                } else {\n+                    prefixes[tableSize] = previousEntry;\n+                    characters[tableSize] = character;\n+                    tableSize++;\n+                }\n+            }\n+        } else {\n+            prefixes[tableSize] = previousEntry;\n+            characters[tableSize] = character;\n+            tableSize++;\n+        }\n+    }\n+\n+    public int read() throws IOException {\n+        byte[] b = new byte[1];\n+        int ret = read(b);\n+        if (ret < 0) {\n+            return ret;\n+        }\n+        return 0xff & b[0];\n+    }\n+    \n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int bytesRead = 0;\n+        int remainingInStack = outputStack.length - outputStackLocation;\n+        if (remainingInStack > 0) {\n+            int maxLength = Math.min(remainingInStack, len);\n+            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+            outputStackLocation += maxLength;\n+            off += maxLength;\n+            len -= maxLength;\n+            bytesRead += maxLength;\n+        }\n+        while (len > 0) {\n+            int result = decompressNextSymbol();\n+            if (result < 0) {\n+                return (bytesRead > 0) ? bytesRead : result;\n+            }\n+            remainingInStack = outputStack.length - outputStackLocation;\n+            if (remainingInStack > 0) {\n+                int maxLength = Math.min(remainingInStack, len);\n+                System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+                outputStackLocation += maxLength;\n+                off += maxLength;\n+                len -= maxLength;\n+                bytesRead += maxLength;\n+            }\n+        }\n+        return bytesRead;\n+    }\n+    \n+    private int decompressNextSymbol() throws IOException {\n+        //\n+        //                   table entry    table entry\n+        //                  _____________   _____\n+        //    table entry  /             \\ /     \\\n+        //    ____________/               \\       \\\n+        //   /           / \\             / \\       \\\n+        //  +---+---+---+---+---+---+---+---+---+---+\n+        //  | . | . | . | . | . | . | . | . | . | . |\n+        //  +---+---+---+---+---+---+---+---+---+---+\n+        //  |<--------->|<------------->|<----->|<->|\n+        //     symbol        symbol      symbol  symbol\n+        //\n+        // Symbols are indexes into a table of table entries. Indexes\n+        // sequentially increase up to the maximum size of the table.\n+        // The bit count used by each index increases up to the minimum\n+        // size needed the index the highest table entry.\n+        //\n+        // To construct a table entry for a symbol,\n+        // we need the symbol's text, and the first character of the\n+        // next symbol's text. When a symbol is the immediately previous\n+        // table entry's symbol, that symbol's text is the previous symbol's text + 1 character.\n+        //\n+        // The compression process adds table entries after writing the symbol.\n+        // Since adding entries can increase the code size, the \n+        //\n+        final int code = readNextCode();\n+        if (code < 0) {\n+            return -1;\n+        } else if (blockMode && code == clearCode) {\n+            clearEntries();\n+            reAlignReading();\n+            codeSize = 9;\n+            previousEntry = -1;\n+            return 0;\n+        } else {\n+            boolean addedUnfinishedEntry = false;\n+            if (code == tableSize) {\n+                // must be a repeat of the previous entry we haven't added yet\n+                if (previousEntry == -1) {\n+                    // ... which isn't possible for the very first code\n+                    throw new IOException(\"The first code can't be a reference to code before itself\");\n+                }\n+                byte firstCharacter = 0;\n+                for (int last = previousEntry; last >= 0; last = prefixes[last]) {\n+                    firstCharacter = characters[last];\n+                }\n+                addEntry(previousEntry, firstCharacter);\n+                addedUnfinishedEntry = true;\n+            } else if (code > tableSize) {\n+                throw new IOException(String.format(\"Invalid %d bit code 0x%x\", codeSize, code));\n+            }\n+            for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n+                outputStack[--outputStackLocation] = characters[entry];\n+            }\n+            if (previousEntry != -1 && !addedUnfinishedEntry) {\n+                addEntry(previousEntry, outputStack[outputStackLocation]);\n+            }\n+            previousEntry = code;\n+            return outputStackLocation;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/ZTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.compressors.z.ZCompressorInputStream;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class ZTestCase extends AbstractTestCase {\n+\n+    public void testZUnarchive() throws Exception {\n+        final File input = getFile(\"bla.tar.Z\");\n+        final File output = new File(dir, \"bla.tar\");\n+        final InputStream is = new FileInputStream(input);\n+        try {\n+            final CompressorInputStream in = new ZCompressorInputStream(is);\n+            FileOutputStream out = null;\n+            try {\n+                out = new FileOutputStream(output);\n+                IOUtils.copy(in, out);\n+            } finally {\n+                if (out != null) {\n+                    out.close();\n+                }\n+                in.close();\n+            }\n+        } finally {\n+            is.close();\n+        }\n+    }\n+}", "timestamp": 1385800076, "metainfo": ""}