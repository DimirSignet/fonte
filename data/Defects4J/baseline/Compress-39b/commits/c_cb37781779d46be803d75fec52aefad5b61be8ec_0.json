{"sha": "cb37781779d46be803d75fec52aefad5b61be8ec", "log": "Implement Zip64Mode.Never.  COMPRESS-36 and COMPRESS-150  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n \n     private static final long serialVersionUID = 20110809L;\n \n+    /**\n+     * Helper to format \"entry too big\" messages.\n+     */\n+    static String getEntryTooBigMessage(ZipArchiveEntry ze) {\n+        return ze.getName() + \"'s size exceeds the limit of 4GByte.\";\n+    }\n+\n+    static final String ARCHIVE_TOO_BIG_MESSAGE =\n+        \"archive's size exceeds the limit of 4GByte.\";\n+\n+    static final String TOO_MANY_ENTRIES_MESSAGE =\n+        \"archive contains more than 65535 entries.\";\n+\n     public Zip64RequiredException(String reason) {\n         super(reason);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         zip64Mode = mode;\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * {@inheritDoc}\n+     * @throws Zip64RequiredException if the archive's size exceeds 4\n+     * GByte or there are more than 65535 entries inside the archive\n+     */\n     @Override\n     public void finish() throws IOException {\n         if (finished) {\n     /**\n      * Writes all necessary data for this entry.\n      * @throws IOException on error\n+     * @throws Zip64RequiredException if the entry's uncompressed or\n+     * compressed size exceeds 4 GByte\n      */\n     @Override\n     public void closeArchiveEntry() throws IOException {\n             entry.entry.setCrc(realCrc);\n         }\n \n+        boolean actuallyNeedsZip64 = entry.entry.getSize() >= ZIP64_MAGIC\n+            || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n+        if (actuallyNeedsZip64 && zip64Mode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                                             .getEntryTooBigMessage(entry.entry));\n+        }\n+\n         // If random access output, write the local file header containing\n         // the correct CRC and compressed/uncompressed sizes\n         if (raf != null) {\n             long save = raf.getFilePointer();\n-            boolean actuallyNeedsZip64 = entry.entry.getSize() >= ZIP64_MAGIC\n-                || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n \n             raf.seek(entry.localDataStart);\n             writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n     /**\n      * {@inheritDoc} \n      * @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n+     * @throws Zip64RequiredException if the entry's uncompressed or\n+     * compressed size is known to exceed 4 GByte\n      */\n     @Override\n     public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n                                        + \" method when not writing to a file\");\n             }\n             entry.entry.setCompressedSize(entry.entry.getSize());\n+        }\n+\n+        if ((entry.entry.getSize() >= ZIP64_MAGIC\n+             || entry.entry.getCompressedSize() >= ZIP64_MAGIC)\n+            && zip64Mode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                                             .getEntryTooBigMessage(entry.entry));\n         }\n \n         // add a ZIP64 extended information extra field if we already\n      * associated with the stream.\n      *\n      * @exception  IOException  if an I/O error occurs.\n+     * @throws Zip64RequiredException if the archive's size exceeds 4\n+     * GByte or there are more than 65535 entries inside the archive\n      */\n     @Override\n     public void close() throws IOException {\n      * Writes the central file header entry.\n      * @param ze the entry to write\n      * @throws IOException on error\n+     * @throws Zip64RequiredException if the archive's size exceeds 4\n+     * GByte\n      */\n     protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n         writeOut(CFH_SIG);\n         final boolean needsZip64Extra = ze.getCompressedSize() >= ZIP64_MAGIC\n             || ze.getSize() >= ZIP64_MAGIC\n             || lfhOffset >= ZIP64_MAGIC;\n+\n+        if (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n+            // must be the offset that is too big, otherwise an\n+            // exception would have been throw in putArchiveEntry or\n+            // closeArchiveEntry\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                                             .ARCHIVE_TOO_BIG_MESSAGE);\n+        }\n \n         if (needsZip64Extra) {\n             Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n     /**\n      * Writes the &quot;End of central dir record&quot;.\n      * @throws IOException on error\n+     * @throws Zip64RequiredException if the archive's size exceeds 4\n+     * GByte or there are more than 65535 entries inside the archive\n      */\n     protected void writeCentralDirectoryEnd() throws IOException {\n         writeOut(EOCD_SIG);\n         writeOut(ZERO);\n \n         // number of entries\n-        byte[] num = ZipShort.getBytes(Math.min(entries.size(),\n+        int numberOfEntries = entries.size();\n+        if (numberOfEntries > ZIP64_MAGIC_SHORT\n+            && zip64Mode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                                             .TOO_MANY_ENTRIES_MESSAGE);\n+        }\n+        if (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                                             .ARCHIVE_TOO_BIG_MESSAGE);\n+        }\n+\n+        byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n                                                 ZIP64_MAGIC_SHORT));\n         writeOut(num);\n         writeOut(num);\n      * @since Apache Commons Compress 1.3\n      */\n     protected void writeZip64CentralDirectory() throws IOException {\n+        if (zip64Mode == Zip64Mode.Never) {\n+            return;\n+        }\n+\n         if (!hasUsedZip64) {\n             if (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n                 || entries.size() >= ZIP64_MAGIC_SHORT) {\n \n     private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n         return getEntryEncoding(ze).encode(ze.getName());\n+    }\n+\n+    /**\n+     * Closes the underlying stream/file without finishing the\n+     * archive, the result will likely be a corrupt archive.\n+     *\n+     * <p>This method only exists to support tests that generate\n+     * corrupt archives so they can clean up any temporary files.</p>\n+     */\n+    void destroy() throws IOException {\n+        if (raf != null) {\n+            raf.close();\n+        }\n+        if (out != null) {\n+            out.close();\n+        }\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportTest.java\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n import static org.junit.Assume.assumeNotNull;\n import static org.junit.Assume.assumeTrue;\n \n             }\n         };\n \n-    @Ignore\n     @Test public void write100KFilesFile() throws Throwable {\n         withTemporaryArchive(\"write100KFilesFile\", write100KFiles, true);\n     }\n \n-    @Ignore\n     @Test public void write100KFilesStream() throws Throwable {\n         withTemporaryArchive(\"write100KFilesStream\", write100KFiles, false);\n+    }\n+\n+    private static final ZipOutputTest write100KFilesModeNever =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    write100KFilesToStream(zos);\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertEquals(Zip64RequiredException.TOO_MANY_ENTRIES_MESSAGE,\n+                                 ex.getMessage());\n+                }\n+            }\n+        };\n+\n+    @Test public void write100KFilesFileModeNever() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesFileModeNever\",\n+                             write100KFilesModeNever, true);\n+    }\n+\n+    @Test public void write100KFilesStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"write100KFilesStreamModeNever\",\n+                             write100KFilesModeNever, false);\n     }\n \n     @Ignore\n             }\n         };\n \n-    @Ignore\n     @Test public void write3EntriesCreatingBigArchiveFile() throws Throwable {\n         withTemporaryArchive(\"write3EntriesCreatingBigArchiveFile\",\n                              write3EntriesCreatingBigArchive,\n                              true);\n     }\n \n-    @Ignore\n     @Test public void write3EntriesCreatingBigArchiveStream() throws Throwable {\n         withTemporaryArchive(\"write3EntriesCreatingBigArchiveStream\",\n                              write3EntriesCreatingBigArchive,\n+                             false);\n+    }\n+\n+    private static final ZipOutputTest write3EntriesCreatingBigArchiveModeNever =\n+        new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    write3EntriesCreatingBigArchiveToStream(zos);\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertEquals(Zip64RequiredException.ARCHIVE_TOO_BIG_MESSAGE,\n+                                 ex.getMessage());\n+                }\n+            }\n+        };\n+\n+    @Test public void write3EntriesCreatingBigArchiveFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveFileModeNever\",\n+                             write3EntriesCreatingBigArchiveModeNever,\n+                             true);\n+    }\n+\n+    @Test public void write3EntriesCreatingBigArchiveStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"write3EntriesCreatingBigArchiveStreamModeNever\",\n+                             write3EntriesCreatingBigArchiveModeNever,\n                              false);\n     }\n \n      * No Compression + Stream => sizes must be known before data is\n      * written.\n      */\n-    @Ignore\n     @Test public void writeBigStoredEntryToStream() throws Throwable {\n         withTemporaryArchive(\"writeBigStoredEntryToStream\",\n                              writeBigStoredEntry(true),\n                              false);\n     }\n \n-    @Ignore\n     @Test public void writeBigStoredEntryKnownSizeToFile() throws Throwable {\n         withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFile\",\n                              writeBigStoredEntry(true),\n                              true);\n     }\n \n-    @Ignore\n     @Test public void writeBigStoredEntryUnnownSizeToFile() throws Throwable {\n         withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n                              writeBigStoredEntry(false),\n+                             true);\n+    }\n+\n+    private static ZipOutputTest writeBigStoredEntryModeNever(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    byte[] buf = new byte[ONE_MILLION];\n+                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    if (knownSize) {\n+                        zae.setSize(FIVE_BILLION);\n+                        zae.setCrc(0x5c316f50L);\n+                    }\n+                    zae.setMethod(ZipArchiveEntry.STORED);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertTrue(ex.getMessage().startsWith(\"0's size\"));\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigStoredEntryToStreamModeNever() throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryToStreamModeNever\",\n+                             writeBigStoredEntryModeNever(true),\n+                             false);\n+    }\n+\n+    @Test public void writeBigStoredEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryKnownSizeToFileModeNever\",\n+                             writeBigStoredEntryModeNever(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigStoredEntryUnnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigStoredEntryUnknownSizeToFile\",\n+                             writeBigStoredEntryModeNever(false),\n                              true);\n     }\n \n      *\n      * Creates a temporary archive of approx 4MB in size\n      */\n-    @Ignore\n     @Test public void writeBigDeflatedEntryKnownSizeToStream()\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStream\",\n         };\n     }\n \n-    @Ignore\n     @Test public void writeBigDeflatedEntryKnownSizeToFile()\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFile\",\n                              true);\n     }\n \n-    @Ignore\n     @Test public void writeBigDeflatedEntryUnknownSizeToFile()\n         throws Throwable {\n         withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFile\",\n                              writeBigDeflatedEntryToFile(false),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToStreamModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeNever\",\n+                             new ZipOutputTest() {\n+                                 public void test(File f,\n+                                                  ZipArchiveOutputStream zos)\n+                                     throws IOException {\n+                                     zos.setUseZip64(Zip64Mode.Never);\n+                                     try {\n+                                         byte[] buf = new byte[ONE_MILLION];\n+                                         ZipArchiveEntry zae =\n+                                             new ZipArchiveEntry(\"0\");\n+                                         zae.setSize(FIVE_BILLION);\n+                                         zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                                         zos.putArchiveEntry(zae);\n+                                         fail(\"expected a\"\n+                                              + \" Zip64RequiredException\");\n+                                     } catch (Zip64RequiredException ex) {\n+                                         assertTrue(ex.getMessage()\n+                                                    .startsWith(\"0's size\"));\n+                                     }\n+                                 }\n+                             },\n+                             false);\n+    }\n+\n+    /*\n+     * One entry of length 5 billion bytes, written with\n+     * compression to a file.\n+     *\n+     * Writing to a file => sizes are stored directly inside the LFH.\n+     * No Data Descriptor at all.\n+     *\n+     * Creates a temporary archive of approx 4MB in size\n+     */\n+    private static ZipOutputTest writeBigDeflatedEntryToFileModeNever(final boolean knownSize) {\n+        return new ZipOutputTest() {\n+            public void test(File f, ZipArchiveOutputStream zos)\n+                throws IOException {\n+                zos.setUseZip64(Zip64Mode.Never);\n+                try {\n+                    byte[] buf = new byte[ONE_MILLION];\n+                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    if (knownSize) {\n+                        zae.setSize(FIVE_BILLION);\n+                    }\n+                    zae.setMethod(ZipArchiveEntry.DEFLATED);\n+                    zos.putArchiveEntry(zae);\n+                    for (int j = 0;\n+                         j < FIVE_BILLION / 1000 / 1000;\n+                         j++) {\n+                        zos.write(buf);\n+                    }\n+                    zos.closeArchiveEntry();\n+                    fail(\"expected a Zip64RequiredException\");\n+                } catch (Zip64RequiredException ex) {\n+                    assertTrue(ex.getMessage().startsWith(\"0's size\"));\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test public void writeBigDeflatedEntryKnownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToFileModeNever\",\n+                             writeBigDeflatedEntryToFileModeNever(true),\n+                             true);\n+    }\n+\n+    @Test public void writeBigDeflatedEntryUnknownSizeToFileModeNever()\n+        throws Throwable {\n+        withTemporaryArchive(\"writeBigDeflatedEntryUnknownSizeToFileModeNever\",\n+                             writeBigDeflatedEntryToFileModeNever(false),\n                              true);\n     }\n \n             assumeTrue(false);\n         } finally {\n             try {\n-                zos.close();\n+                zos.destroy();\n             } finally {\n                 if (os != null) {\n                     os.close();\n                 }\n-            }\n-            f.delete();\n+                f.delete();\n+            }\n         }\n     }\n ", "timestamp": 1312880880, "metainfo": ""}