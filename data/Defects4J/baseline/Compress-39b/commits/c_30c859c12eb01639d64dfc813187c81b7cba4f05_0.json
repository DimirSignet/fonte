{"sha": "30c859c12eb01639d64dfc813187c81b7cba4f05", "log": "support for concatenated streams in Gzip input.  COMPRESS-154.  Submitted by Lasse Collin  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n package org.apache.commons.compress.compressors.gzip;\n \n import java.io.IOException;\n+import java.io.EOFException;\n import java.io.InputStream;\n-import java.util.zip.GZIPInputStream;\n+import java.io.DataInputStream;\n+import java.io.BufferedInputStream;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Inflater;\n+import java.util.zip.CRC32;\n \n import org.apache.commons.compress.compressors.CompressorInputStream;\n \n /**\n- * Implements the \"gz\" compression format as an input stream.\n- * This classes wraps the standard java classes for working with gz. \n+ * Input stream that decompresses .gz files.\n+ * This supports decompressing concatenated .gz files which is important\n+ * when decompressing standalone .gz files.\n+ * <p>\n+ * {@link java.util.zip.GZIPInputStream} doesn't decompress concatenated .gz\n+ * files: it stops after the first member and silently ignores the rest.\n+ * It doesn't leave the read position to point to the beginning of the next\n+ * member, which makes it difficult workaround the lack of concatenation\n+ * support.\n+ * <p>\n+ * Instead of using <code>GZIPInputStream</code>, this class has its own .gz\n+ * container format decoder. The actual decompression is done with\n+ * {@link java.util.zip.Inflater}.\n  */\n public class GzipCompressorInputStream extends CompressorInputStream {\n-    /* reference to the compressed stream */\n-    private final GZIPInputStream in; \n-\n-    /**\n-     * Constructs a new GZip compressed input stream by the referenced\n-     * InputStream.\n-     * \n-     * @param inputStream the InputStream from which this object should be created of\n+    // Header flags\n+    // private static final int FTEXT = 0x01; // Uninteresting for us\n+    private static final int FHCRC = 0x02;\n+    private static final int FEXTRA = 0x04;\n+    private static final int FNAME = 0x08;\n+    private static final int FCOMMENT = 0x10;\n+    private static final int FRESERVED = 0xE0;\n+\n+    // Compressed input stream, possibly wrapped in a BufferedInputStream\n+    private final InputStream in;\n+\n+    // True if decompressing multimember streams.\n+    private final boolean decompressConcatenated;\n+\n+    // Buffer to hold the input data\n+    private final byte[] buf = new byte[8192];\n+\n+    // Amount of data in buf.\n+    private int bufUsed = 0;\n+\n+    // Decompressor\n+    private Inflater inf = new Inflater(true);\n+\n+    // CRC32 from uncompressed data\n+    private CRC32 crc = new CRC32();\n+\n+    private int memberSize;\n+\n+    // True once everything has been decompressed\n+    private boolean endReached = false;\n+\n+    /**\n+     * Constructs a new input stream that decompresses gzip-compressed data\n+     * from the specified input stream.\n+     * <p>\n+     * This is equivalent to\n+     * <code>GzipCompressorInputStream(inputStream, false)</code> and thus\n+     * will not decompress concatenated .gz files.\n+     *\n+     * @param inputStream  the InputStream from which this object should\n+     *                     be created of\n+     *\n      * @throws IOException if the stream could not be created\n      */\n-    public GzipCompressorInputStream(InputStream inputStream) throws IOException {\n-        in = new GZIPInputStream(inputStream);\n+    public GzipCompressorInputStream(InputStream inputStream)\n+            throws IOException {\n+        this(inputStream, false);\n+    }\n+\n+    /**\n+     * Constructs a new input stream that decompresses gzip-compressed data\n+     * from the specified input stream.\n+     * <p>\n+     * If <code>decompressConcatenated</code> is <code>false</code>:\n+     * This decompressor might read more input than it will actually use.\n+     * If <code>inputStream</code> supports <code>mark</code> and\n+     * <code>reset</code>, then the input position will be adjusted\n+     * so that it is right after the last byte of the compressed stream.\n+     * If <code>mark</code> isn't supported, the input position will be\n+     * undefined.\n+     *\n+     * @param inputStream  the InputStream from which this object should\n+     *                     be created of\n+     * @param decompressConcatenated\n+     *                     if true, decompress until the end of the input;\n+     *                     if false, stop after the first .gz member\n+     *\n+     * @throws IOException if the stream could not be created\n+     */\n+    public GzipCompressorInputStream(InputStream inputStream,\n+                                     boolean decompressConcatenated)\n+            throws IOException {\n+        // Mark support is strictly needed for concatenated files only,\n+        // but it's simpler if it is always available.\n+        if (inputStream.markSupported())\n+            in = inputStream;\n+        else\n+            in = new BufferedInputStream(inputStream);\n+\n+        this.decompressConcatenated = decompressConcatenated;\n+        init(true);\n+    }\n+\n+    private boolean init(boolean isFirstMember) throws IOException {\n+        assert isFirstMember || decompressConcatenated;\n+\n+        // Check the magic bytes without a possibility of EOFException.\n+        int magic0 = in.read();\n+        int magic1 = in.read();\n+\n+        // If end of input was reached after decompressing at least\n+        // one .gz member, we have reached the end of the file successfully.\n+        if (magic0 == -1 && !isFirstMember)\n+            return false;\n+\n+        if (magic0 != 31 || magic1 != 139)\n+            throw new IOException(isFirstMember\n+                                  ? \"Input is not in the .gz format\"\n+                                  : \"Garbage after a valid .gz stream\");\n+\n+        // Parsing the rest of the header may throw EOFException.\n+        DataInputStream inData = new DataInputStream(in);\n+        int method = inData.readUnsignedByte();\n+        if (method != 8)\n+            throw new IOException(\"Unsupported compression method \"\n+                                  + method + \" in the .gz header\");\n+\n+        int flg = inData.readUnsignedByte();\n+        if ((flg & FRESERVED) != 0)\n+            throw new IOException(\n+                    \"Reserved flags are set in the .gz header\");\n+\n+        inData.readInt(); // mtime, ignored\n+        inData.readUnsignedByte(); // extra flags, ignored\n+        inData.readUnsignedByte(); // operating system, ignored\n+\n+        // Extra field, ignored\n+        if ((flg & FEXTRA) != 0) {\n+            int xlen = inData.readUnsignedByte();\n+            xlen |= inData.readUnsignedByte() << 8;\n+\n+            // This isn't as efficient as calling in.skip would be,\n+            // but it's lazier to handle unexpected end of input this way.\n+            // Most files don't have an extra field anyway.\n+            while (xlen-- > 0)\n+                inData.readUnsignedByte();\n+        }\n+\n+        // Original file name, ignored\n+        if ((flg & FNAME) != 0)\n+            while (inData.readUnsignedByte() != 0x00) ;\n+\n+        // Comment, ignored\n+        if ((flg & FCOMMENT) != 0)\n+            while (inData.readUnsignedByte() != 0x00) ;\n+\n+        // Header \"CRC16\" which is actually a truncated CRC32 (which isn't\n+        // as good as real CRC16). I don't know if any encoder implementation\n+        // sets this, so it's not worth trying to verify it. GNU gzip 1.4\n+        // doesn't support this field, but zlib seems to be able to at least\n+        // skip over it.\n+        if ((flg & FHCRC) != 0)\n+            inData.readShort();\n+\n+        // Reset\n+        inf.reset();\n+        crc.reset();\n+        memberSize = 0;\n+\n+        return true;\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n     public int read() throws IOException {\n-        int read = in.read();\n-        this.count(read < 0 ? -1 : 1);\n-        return read;\n+        byte[] buf = new byte[1];\n+        return read(buf, 0, 1) == -1 ? -1 : (buf[0] & 0xFF);\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * @since Apache Commons Compress 1.1\n      */\n-    @Override\n-    public int read(byte[] b) throws IOException {\n-        int read = in.read(b);\n-        this.count(read);\n-        return read;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     * \n-     * @since Apache Commons Compress 1.1\n-     */\n-    @Override\n-    public int read(byte[] b, int from, int length) throws IOException {\n-        int read = in.read(b, from, length);\n-        this.count(read);\n-        return read;\n-    }\n-\n-    /**\n-     * Checks if the signature matches what is expected for a gzip file.\n-     * \n-     * @param signature\n-     *            the bytes to check\n-     * @param length\n-     *            the number of bytes to check\n-     * @return true, if this stream is a gzipped compressed stream, false otherwise\n-     * \n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (endReached)\n+            return -1;\n+\n+        int size = 0;\n+\n+        while (len > 0) {\n+            if (inf.needsInput()) {\n+                // Remember the current position because we may need to\n+                // rewind after reading too much input.\n+                in.mark(buf.length);\n+\n+                bufUsed = in.read(buf);\n+                if (bufUsed == -1)\n+                    throw new EOFException();\n+\n+                inf.setInput(buf, 0, bufUsed);\n+            }\n+\n+            int ret;\n+            try {\n+                ret = inf.inflate(b, off, len);\n+            } catch (DataFormatException e) {\n+                throw new IOException(\"Gzip-compressed data is corrupt\");\n+            }\n+\n+            crc.update(b, off, ret);\n+            memberSize += ret;\n+            off += ret;\n+            len -= ret;\n+            size += ret;\n+            count(ret);\n+\n+            if (inf.finished()) {\n+                // We may have read too many bytes. Rewind the read\n+                // position to match the actual amount used.\n+                //\n+                // NOTE: The \"if\" is there just in case. Since we used\n+                // in.mark earler, it should always skip enough.\n+                in.reset();\n+\n+                int skipAmount = bufUsed - inf.getRemaining();\n+                if (in.skip(skipAmount) != skipAmount)\n+                    throw new IOException();\n+\n+                bufUsed = 0;\n+\n+                DataInputStream inData = new DataInputStream(in);\n+\n+                // CRC32\n+                long crcStored = 0;\n+                for (int i = 0; i < 4; ++i)\n+                    crcStored |= (long)inData.readUnsignedByte() << (i * 8);\n+\n+                if (crcStored != crc.getValue())\n+                    throw new IOException(\"Gzip-compressed data is corrupt \"\n+                                          + \"(CRC32 error)\");\n+\n+                // Uncompressed size modulo 2^32 (ISIZE in the spec)\n+                int isize = 0;\n+                for (int i = 0; i < 4; ++i)\n+                    isize |= inData.readUnsignedByte() << (i * 8);\n+\n+                if (isize != memberSize)\n+                    throw new IOException(\"Gzip-compressed data is corrupt\"\n+                                          + \"(uncompressed size mismatch)\");\n+\n+                // See if this is the end of the file.\n+                if (!decompressConcatenated || !init(false)) {\n+                    inf.end();\n+                    inf = null;\n+                    endReached = true;\n+                    return size == 0 ? -1 : size;\n+                }\n+            }\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Checks if the signature matches what is expected for a .gz file.\n+     *\n+     * @param signature the bytes to check\n+     * @param length    the number of bytes to check\n+     * @return          true if this is a .gz stream, false otherwise\n+     *\n      * @since Apache Commons Compress 1.1\n      */\n     public static boolean matches(byte[] signature, int length) {\n         if (length < 2) {\n             return false;\n         }\n-        \n+\n         if (signature[0] != 31) {\n             return false;\n         }\n         if (signature[1] != -117) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n-    \n+\n     /**\n      * Closes the input stream (unless it is System.in).\n-     * \n+     *\n      * @since 1.2\n      */\n-    @Override\n     public void close() throws IOException {\n+        if (inf != null) {\n+            inf.end();\n+            inf = null;\n+        }\n+\n         if (this.in != System.in) {\n             this.in.close();\n         }", "timestamp": 1320854110, "metainfo": ""}