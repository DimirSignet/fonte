{"sha": "1ce7ae0e8c9927d1d28c1ebd82aea9a8ec034670", "log": "Explicit boxing  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n      */\n     @Override\n     public String toString() {\n-        return String.format(\"[%d]: %s\", ino, name);\n+        return String.format(\"[%d]: %s\", Integer.valueOf(ino), name);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n \n         // put in a dummy record for the root node.\n         Dirent root = new Dirent(2, 2, 4, \".\");\n-        names.put(2, root);\n+        names.put(Integer.valueOf(2), root);\n \n         // use priority based on queue to ensure parent directories are\n         // released first.\n         }\n \n         entry.setName(path);\n-        entry.setSimpleName(names.get(entry.getIno()).getName());\n+        entry.setSimpleName(names.get(Integer.valueOf(entry.getIno())).getName());\n         entry.setOffset(filepos);\n \n         return entry;\n                 raw.readRecord();\n             }\n \n-            if (!names.containsKey(entry.getIno()) &&\n+            if (!names.containsKey(Integer.valueOf(entry.getIno())) &&\n                     (DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType())) {\n-                pending.put(entry.getIno(), entry);\n+                pending.put(Integer.valueOf(entry.getIno()), entry);\n             }\n \n             int datalen = DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\n                 }\n                 */\n \n-                names.put(ino, d);\n+                names.put(Integer.valueOf(ino), d);\n \n                 // check whether this allows us to fill anything in the pending list.\n                 for (Map.Entry<Integer, DumpArchiveEntry> e : pending.entrySet()) {\n                 // remove anything that we found. (We can't do it earlier\n                 // because of concurrent modification exceptions.)\n                 for (DumpArchiveEntry e : queue) {\n-                    pending.remove(e.getIno());\n+                    pending.remove(Integer.valueOf(e.getIno()));\n                 }\n             }\n \n         Dirent dirent = null;\n \n         for (int i = entry.getIno();; i = dirent.getParentIno()) {\n-            if (!names.containsKey(i)) {\n+            if (!names.containsKey(Integer.valueOf(i))) {\n                 elements.clear();\n                 break;\n             }\n \n-            dirent = names.get(i);\n+            dirent = names.get(Integer.valueOf(i));\n             elements.push(dirent.getName());\n \n             if (dirent.getIno() == dirent.getParentIno()) {\n \n         // if an element is missing defer the work and read next entry.\n         if (elements.isEmpty()) {\n-            pending.put(entry.getIno(), entry);\n+            pending.put(Integer.valueOf(entry.getIno()), entry);\n \n             return null;\n         }", "timestamp": 1320863753, "metainfo": ""}