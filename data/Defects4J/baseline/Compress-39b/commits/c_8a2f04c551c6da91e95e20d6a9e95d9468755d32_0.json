{"sha": "8a2f04c551c6da91e95e20d6a9e95d9468755d32", "log": "Remove some unnecessary parentheses.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n-        result = prime * result + ((name == null) ? 0 : name.hashCode());\n+        result = prime * result + (name == null ? 0 : name.hashCode());\n         return result;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n         }\n         final int ret = this.input.read(b, off, toRead);\n         count(ret);\n-        offset += (ret > 0 ? ret : 0);\n+        offset += ret > 0 ? ret : 0;\n         return ret;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n         if (prevEntry == null || !haveUnclosedEntry){\n             throw new IOException(\"No current entry to close\");\n         }\n-        if ((entryOffset % 2) != 0) {\n+        if (entryOffset % 2 != 0) {\n             out.write('\\n'); // Pad byte\n         }\n         haveUnclosedEntry = false;\n         }\n \n         offset = fill(offset, 16, ' ');\n-        final String m = \"\" + (pEntry.getLastModified());\n+        final String m = \"\" + pEntry.getLastModified();\n         if (m.length() > 12) {\n             throw new IOException(\"modified too long\");\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n      * account if the archive has beeen created on Unix.</p>\n      */\n     public Date getLastModifiedDate() {\n-        long ts = isHostOsUnix() ? (localFileHeader.dateTimeModified * 1000l)\n+        long ts = isHostOsUnix() ? localFileHeader.dateTimeModified * 1000l\n             : ZipUtil.dosToJavaTime(0xFFFFFFFFL & localFileHeader.dateTimeModified);\n         return new Date(ts);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      */\n     public long getNumberOfLinks() {\n         return nlink == 0 ?\n-            (isDirectory() ? 2 : 1)\n+            isDirectory() ? 2 : 1\n             : nlink;\n     }\n \n     public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n-        result = prime * result + ((name == null) ? 0 : name.hashCode());\n+        result = prime * result + (name == null ? 0 : name.hashCode());\n         return result;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n         queue = new PriorityQueue<DumpArchiveEntry>(10,\n                 new Comparator<DumpArchiveEntry>() {\n                     public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n-                        if ((p.getOriginalName() == null) || (q.getOriginalName() == null)) {\n+                        if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                             return Integer.MAX_VALUE;\n                         }\n \n         boolean first = true;\n \n         while (first ||\n-                (DumpArchiveConstants.SEGMENT_TYPE.ADDR == entry.getHeaderType())) {\n+                DumpArchiveConstants.SEGMENT_TYPE.ADDR == entry.getHeaderType()) {\n             // read the header that we just peeked at.\n             if (!first) {\n                 raw.readRecord();\n             }\n \n             if (!names.containsKey(Integer.valueOf(entry.getIno())) &&\n-                    (DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType())) {\n+                    DumpArchiveConstants.SEGMENT_TYPE.INODE == entry.getHeaderType()) {\n                 pending.put(Integer.valueOf(entry.getIno()), entry);\n             }\n \n \n             int reclen = 0;\n \n-            for (int i = 0; (i < (datalen - 8)) && (i < (size - 8));\n+            for (int i = 0; i < datalen - 8 && i < size - 8;\n                     i += reclen) {\n                 int ino = DumpArchiveUtil.convert32(blockBuffer, i);\n                 reclen = DumpArchiveUtil.convert16(blockBuffer, i + 4);\n     public int read(byte[] buf, int off, int len) throws IOException {\n         int totalRead = 0;\n \n-        if (hasHitEOF || isClosed || (entryOffset >= entrySize)) {\n+        if (hasHitEOF || isClosed || entryOffset >= entrySize) {\n             return -1;\n         }\n \n-        if ((len + entryOffset) > entrySize) {\n+        if (len + entryOffset > entrySize) {\n             len = (int) (entrySize - entryOffset);\n         }\n \n         while (len > 0) {\n-            int sz = (len > (readBuf.length - recordOffset))\n-                ? (readBuf.length - recordOffset) : len;\n+            int sz = len > readBuf.length - recordOffset\n+                ? readBuf.length - recordOffset : len;\n \n             // copy any data we have\n-            if ((recordOffset + sz) <= readBuf.length) {\n+            if (recordOffset + sz <= readBuf.length) {\n                 System.arraycopy(readBuf, recordOffset, buf, off, sz);\n                 totalRead += sz;\n                 recordOffset += sz;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n      * @throws IOException if the next entry could not be read\n      */\n     public SevenZArchiveEntry getNextEntry() throws IOException {\n-        if (currentEntryIndex >= (archive.files.length - 1)) {\n+        if (currentEntryIndex >= archive.files.length - 1) {\n             return null;\n         }\n         ++currentEntryIndex;\n             }\n             long sum = 0;\n             if (nid == NID.kSize) {\n-                for (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\n+                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\n                     final long size = readUint64(header);\n                     subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                     sum += size;\n             coders[i] = new Coder();\n             int bits = header.readUnsignedByte();\n             final int idSize = bits & 0xf;\n-            final boolean isSimple = ((bits & 0x10) == 0);\n-            final boolean hasAttributes = ((bits & 0x20) != 0);\n-            final boolean moreAlternativeMethods = ((bits & 0x80) != 0);\n+            final boolean isSimple = (bits & 0x10) == 0;\n+            final boolean hasAttributes = (bits & 0x20) != 0;\n+            final boolean moreAlternativeMethods = (bits & 0x80) != 0;\n             \n             coders[i].decompressionMethodId = new byte[idSize];\n             header.readFully(coders[i].decompressionMethodId);\n                     if (external != 0) {\n                         throw new IOException(\"Not implemented\");\n                     } else {\n-                        if (((size - 1) & 1) != 0) {\n+                        if ((size - 1 & 1) != 0) {\n                             throw new IOException(\"File names length invalid\");\n                         }\n                         final byte[] names = new byte[(int)(size - 1)];\n         int nonEmptyFileCounter = 0;\n         int emptyFileCounter = 0;\n         for (int i = 0; i < files.length; i++) {\n-            files[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\n+            files[i].setHasStream(isEmptyStream == null ? true : !isEmptyStream.get(i));\n             if (files[i].hasStream()) {\n                 files[i].setDirectory(false);\n                 files[i].setAntiItem(false);\n                 files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                 ++nonEmptyFileCounter;\n             } else {\n-                files[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\n-                files[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\n+                files[i].setDirectory(isEmptyFile == null ? true : !isEmptyFile.get(emptyFileCounter));\n+                files[i].setAntiItem(isAnti == null ? false : isAnti.get(emptyFileCounter));\n                 files[i].setHasCrc(false);\n                 files[i].setSize(0);\n                 ++emptyFileCounter;\n         final StreamMap streamMap = new StreamMap();\n         \n         int nextFolderPackStreamIndex = 0;\n-        final int numFolders = (archive.folders != null) ? archive.folders.length : 0;\n+        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n         streamMap.folderFirstPackStreamIndex = new int[numFolders];\n         for (int i = 0; i < numFolders; i++) {\n             streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n         }\n         \n         long nextPackStreamOffset = 0;\n-        final int numPackSizes = (archive.packSizes != null) ? archive.packSizes.length : 0;\n+        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n         streamMap.packStreamOffsets = new long[numPackSizes];\n         for (int i = 0; i < numPackSizes; i++) {\n             streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n         long value = 0;\n         for (int i = 0; i < 8; i++) {\n             if ((firstByte & mask) == 0) {\n-                return value | ((firstByte & (mask - 1)) << (8 * i));\n+                return value | (firstByte & mask - 1) << 8 * i;\n             }\n             long nextByte = in.readUnsignedByte();\n-            value |= (nextByte << (8 * i));\n+            value |= nextByte << 8 * i;\n             mask >>>= 1;\n         }\n         return value;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n         this.name = name;\n         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n         this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n-        this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\n+        this.modTime = new Date().getTime() / MILLIS_PER_SECOND;\n         this.userName = \"\";\n     }\n \n     private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n                                       int length, boolean starMode) {\n         if (!starMode && (value < 0\n-                          || value >= (1l << (3 * (length - 1))))) {\n+                          || value >= 1l << 3 * (length - 1))) {\n             // value doesn't fit into field when written as octal\n             // number, will be written to PAX header or causes an\n             // error\n                     char ch2 = fileName.charAt(1);\n \n                     if (ch2 == ':'\n-                        && ((ch1 >= 'a' && ch1 <= 'z')\n-                            || (ch1 >= 'A' && ch1 <= 'Z'))) {\n+                        && (ch1 >= 'a' && ch1 <= 'z'\n+                            || ch1 >= 'A' && ch1 <= 'Z')) {\n                         fileName = fileName.substring(2);\n                     }\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n      */\n     @Override\n     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n-        if ((currBytes + numToWrite) > currSize) {\n+        if (currBytes + numToWrite > currSize) {\n             throw new IOException(\"request to write '\" + numToWrite\n                                   + \"' bytes exceeds size in header of '\"\n                                   + currSize + \"' bytes for entry '\"\n         }\n \n         if (assemLen > 0) {\n-            if ((assemLen + numToWrite) >= recordBuf.length) {\n+            if (assemLen + numToWrite >= recordBuf.length) {\n                 int aLen = recordBuf.length - assemLen;\n \n                 System.arraycopy(assemBuf, 0, recordBuf, 0,\n      */\n     private void writeRecord(byte[] buf, int offset) throws IOException {\n  \n-        if ((offset + recordSize) > buf.length) {\n+        if (offset + recordSize > buf.length) {\n             throw new IOException(\"record has length '\" + buf.length\n                                   + \"' with offset '\" + offset\n                                   + \"' which is less than the record size of '\"\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n public interface TarConstants {\n \n     /** Default record size */\n-    int DEFAULT_RCDSIZE = (512);\n+    int DEFAULT_RCDSIZE = 512;\n \n     /** Default block size */\n-    int DEFAULT_BLKSIZE = (DEFAULT_RCDSIZE * 20);\n+    int DEFAULT_BLKSIZE = DEFAULT_RCDSIZE * 20;\n \n     /**\n      * GNU format as per before tar 1.12.\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n         if (negative) {\n             // 2's complement\n             val--;\n-            val ^= ((long) Math.pow(2, (length - 1) * 8) - 1);\n+            val ^= (long) Math.pow(2, (length - 1) * 8) - 1;\n         }\n         return negative ? -val : val;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         LOOP:\n         while (start <= data.length - WORD) {\n             ZipShort headerId = new ZipShort(data, start);\n-            int length = (new ZipShort(data, start + 2)).getValue();\n+            int length = new ZipShort(data, start + 2).getValue();\n             if (start + WORD + length > data.length) {\n                 switch(onUnparseableData.getKey()) {\n                 case UnparseableExtraField.THROW_KEY:\n             } catch (IllegalAccessException iae) {\n                 throw (ZipException) new ZipException(iae.getMessage()).initCause(iae);\n             }\n-            start += (length + WORD);\n+            start += length + WORD;\n         }\n \n         ZipExtraField[] result = new ZipExtraField[v.size()];\n                              0, result, start + 2, 2);\n             byte[] local = data[i].getLocalFileDataData();\n             System.arraycopy(local, 0, result, start + WORD, local.length);\n-            start += (local.length + WORD);\n+            start += local.length + WORD;\n         }\n         if (lastIsUnparseableHolder) {\n             byte[] local = data[data.length - 1].getLocalFileDataData();\n                              0, result, start + 2, 2);\n             byte[] local = data[i].getCentralDirectoryData();\n             System.arraycopy(local, 0, result, start + WORD, local.length);\n-            start += (local.length + WORD);\n+            start += local.length + WORD;\n         }\n         if (lastIsUnparseableHolder) {\n             byte[] local = data[data.length - 1].getCentralDirectoryData();\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n         b.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\n         b.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\n         b.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\n-        b.slidingDictionarySize = ((generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0) ? 8192 : 4096;\n-        b.numberOfShannonFanoTrees = ((generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0) ? 3 : 2;\n+        b.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\n+        b.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\n         return b;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n \n     @Override\n     public int hashCode() {\n-        int hc = (-1234567 * version);\n+        int hc = -1234567 * version;\n         // Since most UID's and GID's are below 65,536, this is (hopefully!)\n         // a nice way to make sure typical UID and GID values impact the hash\n         // as much as possible.\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n             return nestedEnum.hasMoreElements();\n         }\n         public ArchiveEntry next() {\n-            return (current = nestedEnum.nextElement());\n+            return current = nestedEnum.nextElement();\n         }\n         public InputStream getInputStream() throws IOException {\n             return in.getInputStream(current);\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n     public static String toString(ArchiveEntry entry){\n         StringBuilder sb = new StringBuilder();\n         sb.append(entry.isDirectory()? 'd' : '-');// c.f. \"ls -l\" output\n-        String size = Long.toString((entry.getSize()));\n+        String size = Long.toString(entry.getSize());\n         sb.append(' ');\n         // Pad output to 7 places, leading spaces\n         for(int i=7; i > size.length(); i--){\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n             }\n             numToSkip -= skipped;\n         }\n-        return (available - numToSkip);\n+        return available - numToSkip;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n \n             ZipArchiveEntry entry = null;\n             while((entry = (ZipArchiveEntry)in.getNextEntry()) != null) {\n-                results.add((entry.getName()));\n+                results.add(entry.getName());\n \n                 ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n                 ZipArchiveEntry nestedEntry = null;\n--- a/src/test/java/org/apache/commons/compress/compressors/XZTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/XZTestCase.java\n \n     public void testXZCreation()  throws Exception {\n         long max = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax();\n-        System.out.println(\"XZTestCase: HeapMax=\"+max+\" bytes \"+((double)max/(1024*1024))+\" MB\");\n+        System.out.println(\"XZTestCase: HeapMax=\"+max+\" bytes \"+(double)max/(1024*1024)+\" MB\");\n         final File input = getFile(\"test1.xml\");\n         final File output = new File(dir, \"test1.xml.xz\");\n         final OutputStream out = new FileOutputStream(output);", "timestamp": 1387559487, "metainfo": ""}