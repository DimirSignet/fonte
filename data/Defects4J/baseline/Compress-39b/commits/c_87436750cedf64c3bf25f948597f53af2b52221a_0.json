{"sha": "87436750cedf64c3bf25f948597f53af2b52221a", "log": "Utility class that \"normalizes\" a JAR archive so it can be signed without Pack200 breaking the signature  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Map;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Pack200;\n+\n+/**\n+ * Utility methods for Pack200.\n+ *\n+ * @ThreadSafe\n+ * @since Apache Commons Compress 1.3\n+ */\n+public class Pack200Utils {\n+    private Pack200Utils() { }\n+\n+    /**\n+     * Normalizes a JAR archive so it can be savely signed and packed.\n+     *\n+     * <p>As stated in <a\n+     * href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/util/jar/Pack200.Packer.html\">Pack200.Packer's</a>\n+     * javadocs applying a Pack200 compression to a JAR archive will\n+     * in general make its sigantures invalid.  In order to prepare a\n+     * JAR for signing it should be \"normalized\" by packing and\n+     * unpacking it.  This is what this method does.</p>\n+     *\n+     * <p>This method does not replace the existing archive but create\n+     * a new one.</p>\n+     *\n+     * @param from the JAR archive to normalize\n+     * @param to the normalized archive\n+     * @param props properties to set for the pack operation.  This\n+     * method will implicitly set the segment limit to -1.\n+     */\n+    public static void normalize(File from, File to, Map<String, String> props)\n+        throws IOException {\n+        props.put(Pack200.Packer.SEGMENT_LIMIT, \"-1\");\n+        File f = File.createTempFile(\"commons-compress\", \"pack200normalize\");\n+        f.deleteOnExit();\n+        try {\n+            OutputStream os = new FileOutputStream(f);\n+            try {\n+                Pack200.Packer p = Pack200.newPacker();\n+                p.properties().putAll(props);\n+                p.pack(new JarFile(from), os);\n+                os.close();\n+                os = null;\n+\n+                Pack200.Unpacker u = Pack200.newUnpacker();\n+                os = new JarOutputStream(new FileOutputStream(to));\n+                u.unpack(f, (JarOutputStream) os);\n+            } finally {\n+                if (os != null) {\n+                    os.close();\n+                }\n+            }\n+        } finally {\n+            f.delete();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/compressors/pack200/Pack200UtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.pack200;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class Pack200UtilsTest extends AbstractTestCase {\n+\n+    public void testNormalize() throws Throwable {\n+        final File input = getFile(\"bla.jar\");\n+        final File[] output = createTempDirAndFile();\n+        try {\n+            Pack200Utils.normalize(input, output[1],\n+                                   new HashMap<String, String>());\n+            final FileInputStream is = new FileInputStream(output[1]);\n+            try {\n+                final ArchiveInputStream in = new ArchiveStreamFactory()\n+                    .createArchiveInputStream(\"jar\", is);\n+\n+                ArchiveEntry entry = in.getNextEntry();\n+                while (entry != null) {\n+                    File archiveEntry = new File(dir, entry.getName());\n+                    archiveEntry.getParentFile().mkdirs();\n+                    if (entry.isDirectory()) {\n+                        archiveEntry.mkdir();\n+                        entry = in.getNextEntry();\n+                        continue;\n+                    }\n+                    OutputStream out = new FileOutputStream(archiveEntry);\n+                    IOUtils.copy(in, out);\n+                    out.close();\n+                    entry = in.getNextEntry();\n+                }\n+\n+                in.close();\n+            } finally {\n+                is.close();\n+            }\n+        } finally {\n+            output[1].delete();\n+            output[0].delete();\n+        }\n+    }\n+\n+}", "timestamp": 1316010828, "metainfo": ""}