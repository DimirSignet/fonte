{"sha": "d321829894b49a1f69cf396b596098f4497735b8", "log": "extract the various fields that hold state for the active ZipArchiveEntry into a separate structure  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     /**\n      * Current entry.\n      */\n-    private ZipArchiveEntry entry;\n+    private CurrentEntry entry;\n \n     /**\n      * The file comment.\n     private long written = 0;\n \n     /**\n-     * Data for local header data\n-     */\n-    private long dataStart = 0;\n-\n-    /**\n-     * Offset for CRC entry in the local file header data for the\n-     * current entry starts here.\n-     */\n-    private long localDataStart = 0;\n-\n-    /**\n      * Start of central directory.\n      */\n     private long cdOffset = 0;\n      * Length of central directory.\n      */\n     private long cdLength = 0;\n-\n-    /**\n-     * Number of bytes read for the current entry (can't rely on\n-     * Deflater#getBytesRead) when using DEFLATED.\n-     *\n-     * @since Apache Commons Compress 1.3\n-     */\n-    private long bytesRead = 0;\n \n     /**\n      * Helper, a 0 as ZipShort.\n      * @since Apache Commons Compress 1.3\n      */\n     private boolean hasUsedZip64 = false;\n-\n-    /**\n-     * Whether current entry was the first one using ZIP64 features.\n-     *\n-     * @since Apache Commons Compress 1.3\n-     */\n-    private boolean entryCausedUseOfZip64 = false;\n \n     /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n         long realCrc = crc.getValue();\n         crc.reset();\n \n-        if (entry.getMethod() == DEFLATED) {\n+        if (entry.entry.getMethod() == DEFLATED) {\n             def.finish();\n             while (!def.finished()) {\n                 deflate();\n             /* It turns out def.getBytesRead() returns wrong values if\n              * the size exceeds 4 GB - no idea whether one can trust\n              * def.getBytesWritten()\n-            entry.setSize(def.getBytesRead());\n+            entry.entry.setSize(def.getBytesRead());\n             */\n-            entry.setSize(bytesRead);\n-            entry.setCompressedSize(def.getBytesWritten());\n-            entry.setCrc(realCrc);\n+            entry.entry.setSize(entry.bytesRead);\n+            entry.entry.setCompressedSize(def.getBytesWritten());\n+            entry.entry.setCrc(realCrc);\n \n             def.reset();\n \n-            written += entry.getCompressedSize();\n+            written += entry.entry.getCompressedSize();\n         } else if (raf == null) {\n-            if (entry.getCrc() != realCrc) {\n+            if (entry.entry.getCrc() != realCrc) {\n                 throw new ZipException(\"bad CRC checksum for entry \"\n-                                       + entry.getName() + \": \"\n-                                       + Long.toHexString(entry.getCrc())\n+                                       + entry.entry.getName() + \": \"\n+                                       + Long.toHexString(entry.entry.getCrc())\n                                        + \" instead of \"\n                                        + Long.toHexString(realCrc));\n             }\n \n-            if (entry.getSize() != written - dataStart) {\n+            if (entry.entry.getSize() != written - entry.dataStart) {\n                 throw new ZipException(\"bad size for entry \"\n-                                       + entry.getName() + \": \"\n-                                       + entry.getSize()\n+                                       + entry.entry.getName() + \": \"\n+                                       + entry.entry.getSize()\n                                        + \" instead of \"\n-                                       + (written - dataStart));\n+                                       + (written - entry.dataStart));\n             }\n         } else { /* method is STORED and we used RandomAccessFile */\n-            long size = written - dataStart;\n-\n-            entry.setSize(size);\n-            entry.setCompressedSize(size);\n-            entry.setCrc(realCrc);\n+            long size = written - entry.dataStart;\n+\n+            entry.entry.setSize(size);\n+            entry.entry.setCompressedSize(size);\n+            entry.entry.setCrc(realCrc);\n         }\n \n         // If random access output, write the local file header containing\n         // the correct CRC and compressed/uncompressed sizes\n         if (raf != null) {\n             long save = raf.getFilePointer();\n-            boolean actuallyNeedsZip64 = entry.getSize() >= ZIP64_MAGIC\n-                || entry.getCompressedSize() >= ZIP64_MAGIC;\n-\n-            raf.seek(localDataStart);\n-            writeOut(ZipLong.getBytes(entry.getCrc()));\n-            if (!hasZip64Extra(entry) || !actuallyNeedsZip64) {\n-                writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n-                writeOut(ZipLong.getBytes(entry.getSize()));\n+            boolean actuallyNeedsZip64 = entry.entry.getSize() >= ZIP64_MAGIC\n+                || entry.entry.getCompressedSize() >= ZIP64_MAGIC;\n+\n+            raf.seek(entry.localDataStart);\n+            writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n+            if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n+                writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n+                writeOut(ZipLong.getBytes(entry.entry.getSize()));\n             } else {\n                 writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n                 writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n             }\n \n-            if (hasZip64Extra(entry)) {\n+            if (hasZip64Extra(entry.entry)) {\n                 // seek to ZIP64 extra, skip header and size information\n-                raf.seek(localDataStart + 3 * WORD + 2 * SHORT\n-                         + getName(entry).limit() + 2 * SHORT);\n+                raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n+                         + getName(entry.entry).limit() + 2 * SHORT);\n                 // inside the ZIP64 extra uncompressed size comes\n                 // first, unlike the LFH, CD or data descriptor\n-                writeOut(ZipEightByteInteger.getBytes(entry.getSize()));\n-                writeOut(ZipEightByteInteger.getBytes(entry.getCompressedSize()));\n+                writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n+                writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n \n                 if (!actuallyNeedsZip64) {\n                     // do some cleanup:\n                     // * rewrite version needed to extract\n-                    raf.seek(localDataStart  - 5 * SHORT);\n+                    raf.seek(entry.localDataStart  - 5 * SHORT);\n                     writeOut(ZipShort.getBytes(INITIAL_VERSION));\n \n                     // * remove ZIP64 extra so it doesn't get written\n                     //   to the central directory\n-                    entry.removeExtraField(Zip64ExtendedInformationExtraField\n-                                           .HEADER_ID);\n-                    entry.setExtra();\n+                    entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n+                                                 .HEADER_ID);\n+                    entry.entry.setExtra();\n \n                     // * reset hasUsedZip64 if it has been set because\n                     //   of this entry\n-                    hasUsedZip64 &= !entryCausedUseOfZip64;\n+                    hasUsedZip64 &= !entry.causedUseOfZip64;\n                 }\n             }\n             raf.seek(save);\n         }\n \n-        writeDataDescriptor(entry);\n+        writeDataDescriptor(entry.entry);\n         entry = null;\n-        bytesRead = 0;\n-        entryCausedUseOfZip64 = false;\n     }\n \n     /**\n             closeArchiveEntry();\n         }\n \n-        entry = ((ZipArchiveEntry) archiveEntry);\n-        entries.add(entry);\n-\n-        if (entry.getMethod() == -1) { // not specified\n-            entry.setMethod(method);\n-        }\n-\n-        if (entry.getTime() == -1) { // not specified\n-            entry.setTime(System.currentTimeMillis());\n+        entry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\n+        entries.add(entry.entry);\n+\n+        if (entry.entry.getMethod() == -1) { // not specified\n+            entry.entry.setMethod(method);\n+        }\n+\n+        if (entry.entry.getTime() == -1) { // not specified\n+            entry.entry.setTime(System.currentTimeMillis());\n         }\n \n         // Size/CRC not required if RandomAccessFile is used\n-        if (entry.getMethod() == STORED && raf == null) {\n-            if (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n+        if (entry.entry.getMethod() == STORED && raf == null) {\n+            if (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n                 throw new ZipException(\"uncompressed size is required for\"\n                                        + \" STORED method when not writing to a\"\n                                        + \" file\");\n             }\n-            if (entry.getCrc() == -1) {\n+            if (entry.entry.getCrc() == -1) {\n                 throw new ZipException(\"crc checksum is required for STORED\"\n                                        + \" method when not writing to a file\");\n             }\n-            entry.setCompressedSize(entry.getSize());\n+            entry.entry.setCompressedSize(entry.entry.getSize());\n         }\n \n         // add a ZIP64 extended information extra field if we already\n         // know it is going to be needed or the size is unknown and we\n         // can ensure it won't hurt other implementations if we add it\n         // (i.e. we can erase its usage)\n-        if (entry.getSize() >= ZIP64_MAGIC\n-            || entry.getCompressedSize() >= ZIP64_MAGIC\n-            || (entry.getSize() == ArchiveEntry.SIZE_UNKNOWN && raf != null)) {\n-\n-            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry);\n-            if (entry.getMethod() == STORED\n-                && entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n+        if (entry.entry.getSize() >= ZIP64_MAGIC\n+            || entry.entry.getCompressedSize() >= ZIP64_MAGIC\n+            || (entry.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN\n+                && raf != null)) {\n+\n+            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n+            if (entry.entry.getMethod() == STORED\n+                && entry.entry.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n                 ZipEightByteInteger size =\n-                    new ZipEightByteInteger(entry.getSize());\n+                    new ZipEightByteInteger(entry.entry.getSize());\n                 z64.setSize(size);\n                 z64.setCompressedSize(size);\n             } else {\n                 z64.setSize(ZipEightByteInteger.ZERO);\n                 z64.setCompressedSize(ZipEightByteInteger.ZERO);\n             }\n-            entry.setExtra();\n-        }\n-\n-        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n+            entry.entry.setExtra();\n+        }\n+\n+        if (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n             def.setLevel(level);\n             hasCompressionLevelChanged = false;\n         }\n-        writeLocalFileHeader(entry);\n+        writeLocalFileHeader(entry.entry);\n     }\n \n     /**\n      */\n     @Override\n     public void write(byte[] b, int offset, int length) throws IOException {\n-        ZipUtil.checkRequestedFeatures(entry);\n-        if (entry.getMethod() == DEFLATED) {\n+        ZipUtil.checkRequestedFeatures(entry.entry);\n+        if (entry.entry.getMethod() == DEFLATED) {\n             if (length > 0 && !def.finished()) {\n-                bytesRead += length;\n+                entry.bytesRead += length;\n                 if (length <= DEFLATER_BLOCK_SIZE) {\n                     def.setInput(b, offset, length);\n                     deflateUntilInputIsNeeded();\n         // CRC\n         // compressed length\n         // uncompressed length\n-        localDataStart = written;\n+        entry.localDataStart = written;\n         if (zipMethod == DEFLATED || raf != null) {\n             writeOut(LZERO);\n             writeOut(LZERO);\n         writeOut(extra);\n         written += extra.length;\n \n-        dataStart = written;\n+        entry.dataStart = written;\n     }\n \n     /**\n         writeOut(ZipShort.getBytes(versionNeededToExtract));\n         // general purpose bit flag\n         writeOut(b.encode());\n+    }\n+\n+    /**\n+     * Creates a new zip entry taking some information from the given\n+     * file and using the provided name.\n+     *\n+     * <p>The name will be adjusted to end with a forward slash \"/\" if\n+     * the file is a directory.  If the file is not a directory a\n+     * potential trailing forward slash will be stripped from the\n+     * entry name.</p>\n+     *\n+     * <p>Must not be used if the stream has already been closed.</p>\n+     */\n+    @Override\n+    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n+            throws IOException {\n+        if (finished) {\n+            throw new IOException(\"Stream has already been finished\");\n+        }\n+        return new ZipArchiveEntry(inputFile, entryName);\n+    }\n+\n+    /**\n+     * Get the existing ZIP64 extended information extra field or\n+     * create a new one and add it to the entry.\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private Zip64ExtendedInformationExtraField\n+        getZip64Extra(ZipArchiveEntry ze) {\n+        if (entry != null) {\n+            entry.causedUseOfZip64 = !hasUsedZip64;\n+        }\n+        hasUsedZip64 = true;\n+        Zip64ExtendedInformationExtraField z64 =\n+            (Zip64ExtendedInformationExtraField)\n+            ze.getExtraField(Zip64ExtendedInformationExtraField\n+                             .HEADER_ID);\n+        if (z64 == null) {\n+            /*\n+            System.err.println(\"Adding z64 for \" + ze.getName()\n+                               + \", method: \" + ze.getMethod()\n+                               + \" (\" + (ze.getMethod() == STORED) + \")\"\n+                               + \", raf: \" + (raf != null));\n+            */\n+            z64 = new Zip64ExtendedInformationExtraField();\n+        }\n+\n+        // even if the field is there already, make sure it is the first one\n+        ze.addAsFirstExtraField(z64);\n+\n+        return z64;\n+    }\n+\n+    /**\n+     * Is there a ZIP64 extended information extra field for the\n+     * entry?\n+     *\n+     * @since Apache Commons Compress 1.3\n+     */\n+    private boolean hasZip64Extra(ZipArchiveEntry ze) {\n+        return ze.getExtraField(Zip64ExtendedInformationExtraField\n+                                .HEADER_ID)\n+            != null;\n+    }\n+\n+    private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {\n+        boolean encodable = zipEncoding.canEncode(ze.getName());\n+        return !encodable && fallbackToUTF8\n+            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+    }\n+\n+    private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n+        return getEntryEncoding(ze).encode(ze.getName());\n     }\n \n     /**\n     }\n \n     /**\n-     * Creates a new zip entry taking some information from the given\n-     * file and using the provided name.\n-     *\n-     * <p>The name will be adjusted to end with a forward slash \"/\" if\n-     * the file is a directory.  If the file is not a directory a\n-     * potential trailing forward slash will be stripped from the\n-     * entry name.</p>\n-     *\n-     * <p>Must not be used if the stream has already been closed.</p>\n-     */\n-    @Override\n-    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n-            throws IOException {\n-        if (finished) {\n-            throw new IOException(\"Stream has already been finished\");\n-        }\n-        return new ZipArchiveEntry(inputFile, entryName);\n-    }\n-\n-    /**\n-     * Get the existing ZIP64 extended information extra field or\n-     * create a new one and add it to the entry.\n-     *\n-     * @since Apache Commons Compress 1.3\n-     */\n-    private Zip64ExtendedInformationExtraField\n-        getZip64Extra(ZipArchiveEntry ze) {\n-        entryCausedUseOfZip64 = !hasUsedZip64;\n-        hasUsedZip64 = true;\n-        Zip64ExtendedInformationExtraField z64 =\n-            (Zip64ExtendedInformationExtraField)\n-            ze.getExtraField(Zip64ExtendedInformationExtraField\n-                             .HEADER_ID);\n-        if (z64 == null) {\n-            /*\n-            System.err.println(\"Adding z64 for \" + ze.getName()\n-                               + \", method: \" + ze.getMethod()\n-                               + \" (\" + (ze.getMethod() == STORED) + \")\"\n-                               + \", raf: \" + (raf != null));\n-            */\n-            z64 = new Zip64ExtendedInformationExtraField();\n-        }\n-\n-        // even if the field is there already, make sure it is the first one\n-        ze.addAsFirstExtraField(z64);\n-\n-        return z64;\n-    }\n-\n-    /**\n-     * Is there a ZIP64 extended information extra field for the\n-     * entry?\n-     *\n-     * @since Apache Commons Compress 1.3\n-     */\n-    private boolean hasZip64Extra(ZipArchiveEntry ze) {\n-        return ze.getExtraField(Zip64ExtendedInformationExtraField\n-                                .HEADER_ID)\n-            != null;\n-    }\n-\n-    private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {\n-        boolean encodable = zipEncoding.canEncode(ze.getName());\n-        return !encodable && fallbackToUTF8\n-            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-    }\n-\n-    private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n-        return getEntryEncoding(ze).encode(ze.getName());\n-    }\n+     * Structure collecting information for the entry that is\n+     * currently being written.\n+     */\n+    private static final class CurrentEntry {\n+        private CurrentEntry(ZipArchiveEntry entry) {\n+            this.entry = entry;\n+        }\n+        /**\n+         * Current ZIP entry.\n+         */\n+        private final ZipArchiveEntry entry;\n+        /**\n+         * Offset for CRC entry in the local file header data for the\n+         * current entry starts here.\n+         */\n+        private long localDataStart = 0;\n+        /**\n+         * Data for local header data\n+         */\n+        private long dataStart = 0;\n+        /**\n+         * Number of bytes read for the current entry (can't rely on\n+         * Deflater#getBytesRead) when using DEFLATED.\n+         */\n+        private long bytesRead = 0;\n+        /**\n+         * Whether current entry was the first one using ZIP64 features.\n+         */\n+        private boolean causedUseOfZip64 = false;\n+    }\n+\n }", "timestamp": 1312170007, "metainfo": ""}