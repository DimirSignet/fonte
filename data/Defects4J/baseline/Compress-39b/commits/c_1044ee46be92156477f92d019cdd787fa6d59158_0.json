{"sha": "1044ee46be92156477f92d019cdd787fa6d59158", "log": "Add support for BZIP2 decompression and AES-256 + SHA-256 decryption to the 7z archive format.    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedRandomAccessFileInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.RandomAccessFile;\n+\n+class BoundedRandomAccessFileInputStream extends InputStream {\n+    private final RandomAccessFile file;\n+    private long bytesRemaining;\n+\n+    public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\n+            final long size) {\n+        this.file = file;\n+        this.bytesRemaining = size;\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        if (bytesRemaining > 0) {\n+            --bytesRemaining;\n+            return file.read();\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (bytesRemaining == 0) {\n+            return -1;\n+        }\n+        int bytesToRead = len;\n+        if (bytesToRead > bytesRemaining) {\n+            bytesToRead = (int) bytesRemaining;\n+        }\n+        final int bytesRead = file.read(b, off, bytesToRead);\n+        if (bytesRead >= 0) {\n+            bytesRemaining -= bytesRead;\n+        }\n+        return bytesRead;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.GeneralSecurityException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n+import org.tukaani.xz.LZMA2InputStream;\n+\n+class Coders {\n+    static InputStream addDecoder(final InputStream is,\n+            final Coder coder, final String password) throws IOException {\n+        for (final CoderId coderId : coderTable) {\n+            if (Arrays.equals(coderId.id, coder.decompressionMethodId)) {\n+                return coderId.coder.decode(is, coder, password);\n+            }\n+        }\n+        throw new IOException(\"Unsupported compression method \" +\n+                Arrays.toString(coder.decompressionMethodId));\n+    }\n+    \n+    static CoderId[] coderTable = new CoderId[] {\n+        new CoderId(new byte[] { (byte)0x00 }, new CopyDecoder()),\n+        new CoderId(new byte[] { (byte)0x21 }, new LZMA2Decoder()),\n+        // FIXME: gives corrupt output\n+        //new CoderId(new byte[] { (byte)0x04, (byte)0x01, (byte)0x08 }, new DeflateDecoder()),\n+        new CoderId(new byte[] { (byte)0x04, (byte)0x02, (byte)0x02 }, new BZIP2Decoder()),\n+        new CoderId(new byte[] { (byte)0x06, (byte)0xf1, (byte)0x07, (byte)0x01 }, new AES256SHA256Decoder())\n+    };\n+    \n+    static class CoderId {\n+        CoderId(final byte[] id, final CoderBase coder) {\n+            this.id = id;\n+            this.coder = coder;\n+        }\n+\n+        final byte[] id;\n+        final CoderBase coder;\n+    }\n+    \n+    static abstract class CoderBase {\n+        abstract InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException;\n+    }\n+    \n+    static class CopyDecoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException {\n+            return in; \n+        }\n+    }\n+    \n+    static class LZMA2Decoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException {\n+            final int dictionarySizeBits = 0xff & coder.properties[0];\n+            if ((dictionarySizeBits & (~0x3f)) != 0) {\n+                throw new IOException(\"Unsupported LZMA2 property bits\");\n+            }\n+            if (dictionarySizeBits > 40) {\n+                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n+            }\n+            final int dictionarySize;\n+            if (dictionarySizeBits == 40) {\n+                dictionarySize = 0xFFFFffff;\n+            } else {\n+                dictionarySize = (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n+            }\n+            return new LZMA2InputStream(in, dictionarySize);\n+        }\n+    }\n+    \n+//    static class DeflateDecoder extends CoderBase {\n+//        @Override\n+//        InputStream decode(final InputStream in, final Coder coder, final String password)\n+//                throws IOException {\n+//            System.out.println(\"deflate prop count = \" + (coder.properties == null ? -1 : coder.properties.length));\n+//            return new DeflaterInputStream(in, new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n+//            //return new GZIPInputStream(in);\n+//        }\n+//    }\n+\n+    static class BZIP2Decoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder, final String password)\n+                throws IOException {\n+            return new BZip2CompressorInputStream(in);\n+        }\n+    }\n+\n+    static class AES256SHA256Decoder extends CoderBase {\n+        @Override\n+        InputStream decode(final InputStream in, final Coder coder,\n+                String password) throws IOException {\n+            final int byte0 = 0xff & coder.properties[0];\n+            final int numCyclesPower = byte0 & 0x3f;\n+            final int byte1 = 0xff & coder.properties[1];\n+            final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n+            final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n+            //debug(\"numCyclesPower=\" + numCyclesPower + \", saltSize=\" + saltSize + \", ivSize=\" + ivSize);\n+            if (2 + saltSize + ivSize > coder.properties.length) {\n+                throw new IOException(\"Salt size + IV size too long\");\n+            }\n+            final byte[] salt = new byte[saltSize];\n+            System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n+            final byte[] iv = new byte[16];\n+            System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n+            \n+            if (password == null) {\n+                throw new IOException(\"Cannot read encrypted files without a password\");\n+            }\n+            final byte[] passwordBytes = password.getBytes(\"UTF-16LE\");\n+            final byte[] aesKeyBytes;\n+            if (numCyclesPower == 0x3f) {\n+                aesKeyBytes = new byte[32];\n+                System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n+                System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n+                        Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n+            } else {\n+                final MessageDigest digest;\n+                try {\n+                    digest = MessageDigest.getInstance(\"SHA-256\");\n+                } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n+                    throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n+                            noSuchAlgorithmException);\n+                }\n+                final byte[] extra = new byte[8];\n+                for (long j = 0; j < (1L << numCyclesPower); j++) {\n+                    digest.update(salt);\n+                    digest.update(passwordBytes);\n+                    digest.update(extra);\n+                    for (int k = 0; k < extra.length; k++) {\n+                        ++extra[k];\n+                        if (extra[k] != 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                aesKeyBytes = digest.digest();\n+            }\n+            \n+            final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n+            try {\n+                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+                cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n+                return new CipherInputStream(in, cipher);\n+            } catch (GeneralSecurityException generalSecurityException) {\n+                throw new IOException(\"Decryption error \" +\n+                        \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n+                        generalSecurityException);\n+            }\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.util.zip.CRC32;\n \n import org.apache.commons.compress.utils.CRC32VerifyingInputStream;\n-import org.tukaani.xz.LZMA2InputStream;\n \n /**\n  * Reads a 7z file, using RandomAccessFile under\n  * the covers.\n  * <p>\n  * The 7z file format is a flexible container\n- * that can contain many compression types, but\n- * at the moment only Copy and LZMA2 are\n- * supported, and archive header compression\n+ * that can contain many compression and\n+ * encryption types, but at the moment only\n+ * only Copy, LZMA2, BZIP2, and AES-256 + SHA-256\n+ * are supported, and archive header compression\n  * (which always uses the unsupported LZMA\n  * compression) isn't. So the only archives\n  * that can be read are the following:\n  * <pre>\n- * 7z -mhc=off -mx=0 archive.7z files\n- * 7z -mhc=off -m0=LZMA2 archive.7z files\n+ * 7z -mhc=off -mx=0 [-ppassword] archive.7z files\n+ * 7z -mhc=off -m0=LZMA2 [-ppassword] archive.7z files\n+ * 7z -mhc=off -m0=BZIP2 [-ppassword] archive.7z files\n  * </pre>\n  * <p>\n  * The format is very Windows/Intel specific,\n     private int currentFolderIndex = -1;\n     private InputStream currentFolderInputStream = null;\n     private InputStream currentEntryInputStream = null;\n+    private String password;\n         \n     private static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n         }\n     }\n     \n+    public SevenZFile(final File filename, final String password) throws IOException {\n+        this(filename);\n+        this.password = password;\n+    }\n+\n     public void close() {\n         if (file != null) {\n             try {\n         DataInputStream dataInputStream = null;\n         try {\n              dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n-                    new BoundedRandomAccessFileInputStream(20), 20, startHeaderCrc));\n+                    new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n              startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n              startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n              startHeader.nextHeaderCrc = Integer.reverseBytes(dataInputStream.readInt());\n     \n     private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n             final int firstPackStreamIndex) throws IOException {\n-        InputStream inputStreamStack = null;\n-        for (int i = 0; i < folder.coders.length; i++) {\n-            if (i > 0) {\n-                throw new IOException(\"Unsupported multi-codec stream\");\n-            }\n-            file.seek(folderOffset);\n-            if (folder.coders[i].decompressionMethodId.length == 1 &&\n-                    folder.coders[i].decompressionMethodId[0] == 0) {\n-                // 00 - Copy\n-                inputStreamStack = new BoundedRandomAccessFileInputStream(\n-                        archive.packSizes[firstPackStreamIndex]);\n-                // FIXME: LZMA is the default coder yet ironically we don't have it.\n-//            } else if (folder.coders[i].decompressionMethodId.length == 3 &&\n-//                    folder.coders[i].decompressionMethodId[0] == 3 &&\n-//                    folder.coders[i].decompressionMethodId[1] == 1 &&\n-//                    folder.coders[i].decompressionMethodId[2] == 1) {\n-//                // 03.. - 7z\n-//                //    01 - LZMA\n-//                //       01 - Version\n-            } else if (folder.coders[i].decompressionMethodId.length == 1 &&\n-                    folder.coders[i].decompressionMethodId[0] == 0x21) {\n-                // 21 - LZMA2\n-                final int dictionarySizeBits = 0xff & folder.coders[i].properties[0];\n-                if ((dictionarySizeBits & (~0x3f)) != 0) {\n-                    throw new IOException(\"Unsupported LZMA2 property bits\");\n-                }\n-                if (dictionarySizeBits > 40) {\n-                    throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n-                }\n-                final int dictionarySize;\n-                if (dictionarySizeBits == 40) {\n-                    dictionarySize = 0xFFFFffff;\n-                } else {\n-                    dictionarySize = (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n-                }\n-                inputStreamStack = new LZMA2InputStream(\n-                      new BoundedRandomAccessFileInputStream(\n-                              archive.packSizes[firstPackStreamIndex]),\n-                              dictionarySize);\n-                // FIXME: gives corrupt output:\n-//            } else if (folder.coders[i].decompressionMethodId.length == 3 &&\n-//                    folder.coders[i].decompressionMethodId[0] == 0x4 &&\n-//                    folder.coders[i].decompressionMethodId[1] == 0x1 && \n-//                    folder.coders[i].decompressionMethodId[2] == 0x8) {\n-//                // 04.. - Misc\n-//                //    00 - Reserved\n-//                //    01 - Zip\n-//                //       00 - Copy (not used). Use {00} instead\n-//                //       01 - Shrink\n-//                //       06 - Implode\n-//                //       08 - Deflate\n-//                return new DeflaterInputStream(\n-//                        new BoundedRandomAccessFileInputStream(\n-//                                archive.packSizes[firstPackStreamIndex]),\n-//                                new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n-            } else {\n-                throw new IOException(\"Unsupported compression method \" +\n-                        Arrays.toString(folder.coders[i].decompressionMethodId));\n-            }\n+        file.seek(folderOffset);\n+        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n+                archive.packSizes[firstPackStreamIndex]);\n+        for (final Coder coder : folder.coders) {\n+            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n+                throw new IOException(\"Multi input/output stream coders are not yet supported\");\n+            }\n+            inputStreamStack = Coders.addDecoder(inputStreamStack, coder, password);\n         }\n         if (folder.hasCrc) {\n             return new CRC32VerifyingInputStream(inputStreamStack,\n         return value;\n     }\n     \n-    private class BoundedRandomAccessFileInputStream extends InputStream {\n-        private long bytesRemaining;\n-        \n-        public BoundedRandomAccessFileInputStream(final long size) {\n-            bytesRemaining = size;\n-        }\n-        \n-        @Override\n-        public int read() throws IOException {\n-            if (bytesRemaining > 0) {\n-                --bytesRemaining;\n-                return file.read();\n-            } else {\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int read(byte[] b, int off, int len) throws IOException {\n-            if (bytesRemaining == 0) {\n-                return -1;\n-            }\n-            int bytesToRead = len;\n-            if (bytesToRead > bytesRemaining) {\n-                bytesToRead = (int) bytesRemaining;\n-            }\n-            final int bytesRead = file.read(b, off, bytesToRead);\n-            if (bytesRead >= 0) {\n-                bytesRemaining -= bytesRead;\n-            }\n-            return bytesRead;\n-        }\n-\n-        @Override\n-        public void close() {\n-        }\n-    }\n-\n     private static class BoundedInputStream extends InputStream {\n         private InputStream is;\n         private long bytesRemaining;", "timestamp": 1368353536, "metainfo": ""}