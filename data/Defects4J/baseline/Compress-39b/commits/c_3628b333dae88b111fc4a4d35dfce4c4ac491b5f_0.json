{"sha": "3628b333dae88b111fc4a4d35dfce4c4ac491b5f", "log": "javadocs  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n  * An entry in an ARJ archive.\n  * \n  * @NotThreadSafe\n+ * @since 1.6\n  */\n public class ArjArchiveEntry implements ArchiveEntry {\n     private final LocalFileHeader localFileHeader;\n         this.localFileHeader = localFileHeader;\n     }\n \n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n     public String getName() {\n         if ((localFileHeader.arjFlags & LocalFileHeader.Flags.PATHSYM) != 0) {\n             return localFileHeader.name.replaceAll(\"/\",\n         }\n     }\n \n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n     public long getSize() {\n         return localFileHeader.originalSize;\n     }\n \n+    /** True if the entry refers to a directory */\n     public boolean isDirectory() {\n         return localFileHeader.fileType == LocalFileHeader.FileTypes.DIRECTORY;\n     }\n \n+    /**\n+     * The last modified date of the entry.\n+     */\n     public Date getLastModifiedDate() {\n         long ts = isHostOsUnix() ? (localFileHeader.dateTimeModified * 1000l)\n             : ZipUtil.dosToJavaTime(0xFFFFFFFFL & localFileHeader.dateTimeModified);\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n  * <p>\n  * <a href=\"http://farmanager.com/svn/trunk/plugins/multiarc/arc.doc/arj.txt\">Reference</a>\n  * @NotThreadSafe\n+ * @since 1.6\n  */\n public class ArjArchiveInputStream extends ArchiveInputStream {\n     private static final boolean DEBUG = false;\n         return localFileHeader;\n     }\n     \n+    /**\n+     * Checks if the signature matches what is expected for an arj file.\n+     *\n+     * @param signature\n+     *            the bytes to check\n+     * @param length\n+     *            the number of bytes to check\n+     * @return true, if this stream is an arj archive stream, false otherwise\n+     */\n     public static boolean matches(final byte[] signature, final int length) {\n         return length >= 2 &&\n                 (0xff & signature[0]) == ARJ_MAGIC_1 &&\n                 (0xff & signature[1]) == ARJ_MAGIC_2;\n     }\n     \n+    /**\n+     * Gets the archive's recorded name.\n+     */\n     public String getArchiveName() {\n         return mainHeader.name;\n     }\n     \n+    /**\n+     * Gets the archive's comment.\n+     */\n     public String getArchiveComment() {\n         return mainHeader.comment;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n  * An entry in a 7z archive.\n  * \n  * @NotThreadSafe\n+ * @since 1.6\n  */\n public class SevenZArchiveEntry implements ArchiveEntry {\n     private String name;\n     \n     public SevenZArchiveEntry() {\n     }\n-    \n+\n+    /**\n+     * Get this entry's name.\n+     *\n+     * @return This entry's name.\n+     */\n     public String getName() {\n         return name;\n     }\n     \n+    /**\n+     * Set this entry's name.\n+     *\n+     * @param name This entry's new name.\n+     */\n     public void setName(String name) {\n         this.name = name;\n     }\n \n+    /**\n+     * Whether there is any content associated with this entry.\n+     * @return whether there is any content associated with this entry.\n+     */\n     public boolean hasStream() {\n         return hasStream;\n     }\n \n+    /**\n+     * Sets whether there is any content associated with this entry.\n+     * @param hasStream whether there is any content associated with this entry.\n+     */\n     public void setHasStream(boolean hasStream) {\n         this.hasStream = hasStream;\n     }\n \n+    /**\n+     * Return whether or not this entry represents a directory.\n+     *\n+     * @return True if this entry is a directory.\n+     */\n     public boolean isDirectory() {\n         return isDirectory;\n     }\n     \n+    /**\n+     * Sets whether or not this entry represents a directory.\n+     *\n+     * @param isDirectory True if this entry is a directory.\n+     */\n     public void setDirectory(boolean isDirectory) {\n         this.isDirectory = isDirectory;\n     }\n         this.isAntiItem = isAntiItem;\n     }\n \n+    /**\n+     * Returns whether this entry has got a creation date at all.\n+     */\n     public boolean getHasCreationDate() {\n         return hasCreationDate;\n     }\n     \n+    /**\n+     * Sets whether this entry has got a creation date at all.\n+     */\n     public void setHasCreationDate(boolean hasCreationDate) {\n         this.hasCreationDate = hasCreationDate;\n     }\n     \n+    /**\n+     * Gets the creation date.\n+     * @throws UnsupportedOperationException if the entry hasn't got a\n+     * creation date.\n+     */\n     public Date getCreationDate() {\n         if (hasCreationDate) {\n             return ntfsTimeToJavaTime(creationDate);\n         }\n     }\n     \n+    /**\n+     * Sets the creation date using NTFS time (100 nanosecond units\n+     * since 1 January 1601)\n+     */\n     public void setCreationDate(long ntfsCreationDate) {\n         this.creationDate = ntfsCreationDate;\n     }\n     \n+    /**\n+     * Sets the creation date,\n+     */\n     public void setCreationDate(Date creationDate) {\n         hasCreationDate = creationDate != null;\n         if (hasCreationDate) {\n         }\n     }\n \n+    /**\n+     * Returns whether this entry has got a last modified date at all.\n+     */\n     public boolean getHasLastModifiedDate() {\n         return hasLastModifiedDate;\n     }\n \n+    /**\n+     * Sets whether this entry has got a last modified date at all.\n+     */\n     public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\n         this.hasLastModifiedDate = hasLastModifiedDate;\n     }\n \n+    /**\n+     * Gets the last modified date.\n+     * @throws UnsupportedOperationException if the entry hasn't got a\n+     * last modified date.\n+     */\n     public Date getLastModifiedDate() {\n         if (hasLastModifiedDate) {\n             return ntfsTimeToJavaTime(lastModifiedDate);\n         }\n     }\n     \n+    /**\n+     * Sets the last modified date using NTFS time (100 nanosecond\n+     * units since 1 January 1601)\n+     */\n     public void setLastModifiedDate(long ntfsLastModifiedDate) {\n         this.lastModifiedDate = ntfsLastModifiedDate;\n     }\n     \n+    /**\n+     * Sets the last modified date,\n+     */\n     public void setLastModifiedDate(Date lastModifiedDate) {\n         hasLastModifiedDate = lastModifiedDate != null;\n         if (hasLastModifiedDate) {\n         }\n     }\n     \n+    /**\n+     * Returns whether this entry has got an access date at all.\n+     */\n     public boolean getHasAccessDate() {\n         return hasAccessDate;\n     }\n \n+    /**\n+     * Sets whether this entry has got an access date at all.\n+     */\n     public void setHasAccessDate(boolean hasAcessDate) {\n         this.hasAccessDate = hasAcessDate;\n     }\n \n+    /**\n+     * Gets the access date.\n+     * @throws UnsupportedOperationException if the entry hasn't got a\n+     * access date.\n+     */\n     public Date getAccessDate() {\n         if (hasAccessDate) {\n             return ntfsTimeToJavaTime(accessDate);\n         }\n     }\n     \n+    /**\n+     * Sets the access date using NTFS time (100 nanosecond units\n+     * since 1 January 1601)\n+     */\n     public void setAccessDate(long ntfsAccessDate) {\n         this.accessDate = ntfsAccessDate;\n     }\n     \n+    /**\n+     * Sets the access date,\n+     */\n     public void setAccessDate(Date accessDate) {\n         hasAccessDate = accessDate != null;\n         if (hasAccessDate) {\n         }\n     }\n \n+    /**\n+     * Returns whether this entry has windows attributes.\n+     */\n     public boolean getHasWindowsAttributes() {\n         return hasWindowsAttributes;\n     }\n \n+    /**\n+     * Sets whether this entry has windows attributes.\n+     */\n     public void setHasWindowsAttributes(boolean hasWindowsAttributes) {\n         this.hasWindowsAttributes = hasWindowsAttributes;\n     }\n \n+    /**\n+     * Gets the windows attributes.\n+     */\n     public int getWindowsAttributes() {\n         return windowsAttributes;\n     }\n \n+    /**\n+     * Sets the windows attributes.\n+     */\n     public void setWindowsAttributes(int windowsAttributes) {\n         this.windowsAttributes = windowsAttributes;\n     }\n \n+    /**\n+     * Returns whether this entry has got a crc.\n+     *\n+     * In general entries without streams don't have a CRC either.\n+     */\n     public boolean getHasCrc() {\n         return hasCrc;\n     }\n \n+    /**\n+     * Sets whether this entry has got a crc.\n+     */\n     public void setHasCrc(boolean hasCrc) {\n         this.hasCrc = hasCrc;\n     }\n \n+    /**\n+     * Gets the CRC.\n+     */\n     public int getCrc() {\n         return crc;\n     }\n \n+    /**\n+     * Sets the CRC.\n+     */\n     public void setCrc(int crc) {\n         this.crc = crc;\n     }\n \n+    /**\n+     * Get this entry's file size.\n+     *\n+     * @return This entry's file size.\n+     */\n     public long getSize() {\n         return size;\n     }\n     \n+    /**\n+     * Set this entry's file size.\n+     *\n+     * @param size This entry's new file size.\n+     */\n     public void setSize(long size) {\n         this.size = size;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n  * encryption isn't plausibly deniable.\n  * \n  * @NotThreadSafe\n+ * @since 1.6\n  */\n public class SevenZFile {\n     private static final boolean DEBUG = false;\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n     \n+    /**\n+     * Reads a file as 7z archive\n+     *\n+     * @param filename the file to read\n+     * @param password optional password if the archive is encrypted\n+     */\n     public SevenZFile(final File filename, final String password) throws IOException {\n         boolean succeeded = false;\n         this.password = password;\n         }\n     }\n     \n+    /**\n+     * Reads a file as unecrypted 7z archive\n+     *\n+     * @param filename the file to read\n+     */\n     public SevenZFile(final File filename) throws IOException {\n         this(filename, null);\n     }\n \n+    /**\n+     * Closes the archive.\n+     */\n     public void close() {\n         if (file != null) {\n             try {\n         }\n     }\n     \n+    /**\n+     * Returns the next Archive Entry in this archive.\n+     *\n+     * @return the next entry,\n+     *         or {@code null} if there are no more entries\n+     * @throws IOException if the next entry could not be read\n+     */\n     public SevenZArchiveEntry getNextEntry() throws IOException {\n         if (currentEntryIndex >= (archive.files.length - 1)) {\n             return null;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n \n /**\n  * Writes a 7z file.\n+ * @since 1.6\n  */\n public class SevenZOutputFile {\n     private final RandomAccessFile file;\n         file.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n     }\n     \n+    /**\n+     * Closes the archive, calling {@link #finish} if necessary.\n+     */\n     public void close() {\n         try {\n             if (!finished) {\n         }\n     }\n     \n+    /**\n+     * Create an archive entry using the inputFile and entryName provided.\n+     * \n+     * @param inputFile\n+     * @param entryName \n+     * @return the ArchiveEntry set up with details from the file\n+     * \n+     * @throws IOException\n+     */\n     public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n             final String entryName) throws IOException {\n         final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n         return entry;\n     }\n \n+    /**\n+     * Records an archive entry to add.\n+     *\n+     * The caller must then write the content to the archive and call\n+     * {@link #closeArchiveEntry()} to complete the process.\n+     * \n+     * @param entry describes the entry\n+     * @throws IOException\n+     */\n     public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n         files.add(entry);\n     }\n     \n+    /**\n+     * Closes the archive entry.\n+     * @throws IOException\n+     */\n     public void closeArchiveEntry() throws IOException {\n         final SevenZArchiveEntry entry = files.get(files.size() - 1);\n         if (fileBytesWritten > 0) {\n         fileBytesWritten = 0;\n     }\n     \n+    /**\n+     * Writes a byte to the current archive entry.\n+     * @param b The byte to be written.\n+     * @throws IOException on error\n+     */\n     public void write(final int b) throws IOException {\n         file.write(b);\n         crc32.update(b);\n         fileBytesWritten++;\n     }\n     \n+    /**\n+     * Writes a byte array to the current archive entry.\n+     * @param b The byte array to be written.\n+     * @throws IOException on error\n+     */\n     public void write(final byte[] b) throws IOException {\n         write(b, 0, b.length);\n     }\n     \n+    /**\n+     * Writes part of a byte array to the current archive entry.\n+     * @param b The byte array to be written.\n+     * @param off offset into the array to start writing from\n+     * @param len number of bytes to write\n+     * @throws IOException on error\n+     */\n     public void write(final byte[] b, final int off, final int len) throws IOException {\n         file.write(b, off, len);\n         crc32.update(b, off, len);\n         fileBytesWritten += len;\n     }\n     \n+    /**\n+     * Finishes the addition of entries to this archive, without closing it.\n+     * \n+     * @throws IOException if archive is already closed.\n+     */\n     public void finish() throws IOException {\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n--- a/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+/**\n+ * A stream that limits reading from a wrapped stream to a given number of bytes.\n+ * @NotThreadSafe\n+ * @since 1.6\n+ */\n public class BoundedInputStream extends InputStream {\n     private final InputStream in;\n     private long bytesRemaining;\n     @Override\n     public void close() {\n     }\n-}\n+}\n--- a/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n import java.io.InputStream;\n import java.util.zip.CRC32;\n \n+/**\n+ * A stream that verifies the CRC of the data read once the stream is\n+ * exhausted.\n+ * @NotThreadSafe\n+ * @since 1.6\n+ */\n public class CRC32VerifyingInputStream extends InputStream {\n     private final InputStream in;\n     private long bytesRemaining;\n         this.bytesRemaining = size;\n     }\n \n+    /**\n+     * Reads a single byte from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the CRC doesn't match the expected\n+     * value\n+     */\n     @Override\n     public int read() throws IOException {\n         if (bytesRemaining <= 0) {\n         return ret;\n     }\n \n+    /**\n+     * Reads a byte array from the stream\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the CRC doesn't match the expected\n+     * value\n+     */\n     @Override\n     public int read(byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n \n+    /**\n+     * Reads from the stream into a byte array.\n+     * @throws IOException if the underlying stream throws or the\n+     * stream is exhausted and the CRC doesn't match the expected\n+     * value\n+     */\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n         int ret = in.read(b, off, len);", "timestamp": 1381435935, "metainfo": ""}