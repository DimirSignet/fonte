{"sha": "62cb9c480ecd71491e6b2452ff8add4d35706290", "log": "provide access to the general purpose bit flag field of a zip entry and fail when a STORED entry requires a data descriptor.  COMPRESS-100  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n  * Parser/encoder for the \"general purpose bit\" field in ZIP's local\n  * file and central directory headers.\n  * @since Apache Commons Compress 1.1\n+ * @NotThreadSafe\n  */\n-public class GeneralPurposeBit {\n+public final class GeneralPurposeBit {\n     /**\n      * Indicates that the file is encrypted.\n      */\n         b.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\n         return b;\n     }\n+\n+    public int hashCode() {\n+        return 3 * (7 * (13 * (17 * (encryptionFlag ? 1 : 0)\n+                               + (strongEncryptionFlag ? 1 : 0))\n+                         + (languageEncodingFlag ? 1 : 0))\n+                    + (dataDescriptorFlag ? 1 : 0));\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (!(o instanceof GeneralPurposeBit)) {\n+            return false;\n+        }\n+        GeneralPurposeBit g = (GeneralPurposeBit) o;\n+        return g.encryptionFlag == encryptionFlag\n+            && g.strongEncryptionFlag == strongEncryptionFlag\n+            && g.languageEncodingFlag == languageEncodingFlag\n+            && g.dataDescriptorFlag == dataDescriptorFlag;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n          * The entry used an unsupported compression method.\n          */\n         public static Feature METHOD = new Feature(\"compression method\");\n+        /**\n+         * The entry uses a data descriptor.\n+         */\n+        public static Feature DATA_DESCRIPTOR = new Feature(\"data descriptor\");\n         \n         private final String name;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n-    private boolean encrypted;\n-    private boolean stronglyEncrypted;\n+    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n \n     /**\n      * Creates a new zip entry with the specified name.\n     }\n \n     /**\n-     * Whether the entry is encrypted.\n+     * The \"general purpose bit\" field.\n      * @since Apache Commons Compress 1.1\n      */\n-    public boolean isEncrypted() {\n-        return encrypted;\n-    }\n-\n-    /**\n-     * Whether the entry is encrypted using strong encryption.\n+    public GeneralPurposeBit getGeneralPurposeBit() {\n+        return gpb;\n+    }\n+\n+    /**\n+     * The \"general purpose bit\" field.\n      * @since Apache Commons Compress 1.1\n      */\n-    public boolean isStronglyEncrypted() {\n-        return stronglyEncrypted && encrypted;\n-    }\n-\n-    /**\n-     * Whether the entry is encrypted.\n-     * @since Apache Commons Compress 1.1\n-     */\n-    public void setEncrypted(boolean b) {\n-        encrypted = b;\n-    }\n-\n-    /**\n-     * Whether the entry is encrypted using strong encryption.\n-     * @since Apache Commons Compress 1.1\n-     */\n-    public void setStronglyEncrypted(boolean b) {\n-        stronglyEncrypted = b;\n-        if (b) {\n-            setEncrypted(true);\n-        }\n+    public void setGeneralPurposeBit(GeneralPurposeBit b) {\n+        gpb = b;\n     }\n \n     /**\n             && Arrays.equals(getCentralDirectoryExtra(),\n                              other.getCentralDirectoryExtra())\n             && Arrays.equals(getLocalFileDataExtra(),\n-                             other.getLocalFileDataExtra());\n+                             other.getLocalFileDataExtra())\n+            && gpb.equals(other.gpb);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n         hasDataDescriptor = gpFlag.usesDataDescriptor();\n-        current.setEncrypted(gpFlag.usesEncryption());\n-        current.setStronglyEncrypted(gpFlag.usesStrongEncryption());\n+        current.setGeneralPurposeBit(gpFlag);\n \n         off += SHORT;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n             final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n             final ZipEncoding entryEncoding =\n                 hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-            ze.setEncrypted(gpFlag.usesEncryption());\n-            ze.setStronglyEncrypted(gpFlag.usesStrongEncryption());\n+            ze.setGeneralPurposeBit(gpFlag);\n \n             off += SHORT;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n      * Whether this library is able to read or write the given entry.\n      */\n     static boolean canHandleEntryData(ZipArchiveEntry entry) {\n-        return supportsEncryptionOf(entry) && supportsMethodOf(entry);\n+        return supportsEncryptionOf(entry) && supportsMethodOf(entry)\n+            && supportsDataDescriptorFor(entry);\n     }\n \n     /**\n      * @return true if the entry isn't encrypted at all\n      */\n     private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\n-        return !entry.isEncrypted();\n+        return !entry.getGeneralPurposeBit().usesEncryption();\n     }\n \n     /**\n      */\n     private static boolean supportsMethodOf(ZipArchiveEntry entry) {\n         return entry.getMethod() == ZipArchiveEntry.STORED\n+            || entry.getMethod() == ZipArchiveEntry.DEFLATED;\n+    }\n+\n+    /**\n+     * Whether this entry requires a data descriptor this library can work with.\n+     *\n+     * @return true if the entry doesn't require any data descriptor\n+     * or the method is DEFLATED).\n+     */\n+    private static boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n+        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n             || entry.getMethod() == ZipArchiveEntry.DEFLATED;\n     }\n \n                 new UnsupportedZipFeatureException(UnsupportedZipFeatureException\n                                                    .Feature.METHOD, ze);\n         }\n+        if (!supportsDataDescriptorFor(ze)) {\n+            throw\n+                new UnsupportedZipFeatureException(UnsupportedZipFeatureException\n+                                                   .Feature.DATA_DESCRIPTOR, ze);\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n         try {\n             zf = new ZipFile(file);\n             ZipArchiveEntry zae = zf.getEntry(\"LICENSE.txt\");\n-            assertTrue(zae.isEncrypted());\n-            assertFalse(zae.isStronglyEncrypted());\n+            assertTrue(zae.getGeneralPurposeBit().usesEncryption());\n+            assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\n             assertFalse(zf.canReadEntryData(zae));\n             try {\n                 zf.getInputStream(zae);\n             zin = new ZipArchiveInputStream(new FileInputStream(file));\n             ZipArchiveEntry zae = zin.getNextZipEntry();\n             assertEquals(\"LICENSE.txt\", zae.getName());\n-            assertTrue(zae.isEncrypted());\n-            assertFalse(zae.isStronglyEncrypted());\n+            assertTrue(zae.getGeneralPurposeBit().usesEncryption());\n+            assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\n             assertFalse(zin.canReadEntryData(zae));\n             try {\n                 byte[] buf = new byte[1024];", "timestamp": 1268409980, "metainfo": ""}