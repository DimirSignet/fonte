{"sha": "6846564d8345aba5d64ce943656a60ccf3635978", "log": "Add read-support for big files using GNU tar extensions.  write support will be added later.  Based on patch by John Kodis.  COMPRESS-16  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n         offset += UIDLEN;\n         groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n         offset += GIDLEN;\n-        size = TarUtils.parseOctal(header, offset, SIZELEN);\n+        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n         offset += SIZELEN;\n         modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n         offset += MODTIMELEN;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n         return result;\n     }\n \n+    /** \n+     * Compute the value contained in a byte buffer.  If the most\n+     * significant bit of the first byte in the buffer is set, this\n+     * bit is ignored and the rest of the buffer is interpreted as a\n+     * binary number.  Otherwise, the buffer is interpreted as an\n+     * octal number as per the parseOctal function above.\n+     *\n+     * @param buffer The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The maximum number of bytes to parse.\n+     * @return The long value of the octal or binary string.\n+     * @throws IllegalArgumentException if the trailing space/NUL is\n+     * missing or an invalid byte is detected in an octal number, or\n+     * if a binary number would exceed the size of a signed long\n+     * 64-bit integer.\n+     */\n+    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n+                                          final int length) {\n+\n+        if ((buffer[offset] & 0x80) == 0) {\n+            return parseOctal(buffer, offset, length);\n+        }\n+\n+        long val = buffer[offset] & 0x7f;\n+        for (int i = 1; i < length; i++) {\n+            if (val >= (1L << (63 - 8))) {\n+                throw new IllegalArgumentException(\n+                    \"At offset \" + offset + \", \" + length + \" byte \" +\n+                    \"binary number exceeds maximum signed long value\");\n+            }\n+            val = (val << 8) + (buffer[offset + i] & 0xff);\n+        }\n+        return val;\n+    }\n+\n     /**\n      * Parse a boolean byte from a buffer.\n      * Leading spaces and NUL are ignored.", "timestamp": 1323079084, "metainfo": ""}