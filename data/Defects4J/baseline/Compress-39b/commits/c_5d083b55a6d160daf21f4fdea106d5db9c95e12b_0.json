{"sha": "5d083b55a6d160daf21f4fdea106d5db9c95e12b", "log": "Review comments from Emmanuel Bourg  - Added @since tags - Improved javadocs in several places - Extracted ScatterStatistics class  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/InputStreamSupplier.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/InputStreamSupplier.java\n \n import java.io.InputStream;\n \n+/**\n+ * Supplies input streams.\n+ *\n+ * Implementations are required to be thread safe.\n+ *\n+ * @since 1.10\n+ */\n public interface InputStreamSupplier {\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n  * The client can supply an ExecutorService, but for reasons of memory model consistency,\n  * this will be shut down by this class prior to completion.\n  * </p>\n+ * @since 1.10\n  */\n public class ParallelScatterZipCreator {\n     private final List<ScatterZipOutputStream> streams = synchronizedList(new ArrayList<ScatterZipOutputStream>());\n     };\n \n     /**\n-     * Create a ParallelScatterZipCreator with default threads\n+     * Create a ParallelScatterZipCreator with default threads, which is set to the number of available\n+     * processors, as defined by java.lang.Runtime#availableProcessors()\n      */\n     public ParallelScatterZipCreator() {\n         this(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));\n     }\n \n     /**\n-     * Submit a callable for compression\n-     * @param callable The callable to run\n+     * Submit a callable for compression.\n+     *\n+     * @see #createCallable for details of if/when to use this.\n+     *\n+     * @param callable The callable to run, created by #createCallable, possibly wrapped by caller.\n      */\n     public final void submit(Callable<Object> callable) {\n         futures.add(es.submit(callable));\n      *\n      * <p>This method is expected to be called from a single client thread.</p>\n      * <p>\n-     * This method is used by clients that want finer grained control over how the callable is\n-     * created, possibly wanting to wrap this callable in a different callable</p>\n+     * Consider using #addArchiveEntry, which wraps this method and #submit. The most common use case\n+     * for using #createCallable and #submit from a client is if you want to wrap the callable in something\n+     * that can be prioritized by the supplied #ExecutorService, for instance to process large or slow files first.\n+     * Since the creation of the #ExecutorService is handled by the client, all of this is up to the client.\n      *\n      * @param zipArchiveEntry The entry to add.\n      * @param source    The source input stream supplier\n-     * @return   A callable that will be used to check for errors\n+     * @return   A callable that should subsequently passed to #submit, possibly in a wrapped/adapted from. The\n+     *          value of this callable is not used, but any exceptions happening inside the compression\n+     *          will be propagated through the callable.\n      */\n \n     public final Callable<Object> createCallable(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier source) {\n         final int method = zipArchiveEntry.getMethod();\n         if (method == ZipMethod.UNKNOWN_CODE) {\n-            throw new IllegalArgumentException(\"Method must be set on the supplied zipArchiveEntry\");\n+            throw new IllegalArgumentException(\"Method must be set on zipArchiveEntry: \" + zipArchiveEntry);\n         }\n         final ZipArchiveEntryRequest zipArchiveEntryRequest = createZipArchiveEntryRequest(zipArchiveEntry, source);\n         return new Callable<Object>() {\n      *\n      * @return A string\n      */\n-    public String getStatisticsMessage() {\n-        return \"Compression: \" + (compressionDoneAt - startedAt) + \"ms,\" +\n-                \"Merging files: \" + (scatterDoneAt - compressionDoneAt) + \"ms\";\n+    public ScatterStatistics getStatisticsMessage() {\n+        return new ScatterStatistics(compressionDoneAt - startedAt, scatterDoneAt - compressionDoneAt);\n     }\n }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterGatherBackingStoreSupplier.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterGatherBackingStoreSupplier.java\n \n import java.io.IOException;\n \n+/**\n+ * Supplies ScatterGatherBackingStore instances.\n+ *\n+ * @since 1.10\n+ */\n public interface ScatterGatherBackingStoreSupplier {\n     /**\n      * Get a ScatterGatherBackingStore.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+ package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Provides information about a scatter compression run.\n+ *\n+ * @since 1.10\n+ */\n+public class ScatterStatistics {\n+    private final long compressionElapsed;\n+    private final long mergingElapsed;\n+\n+    ScatterStatistics(long compressionElapsed, long mergingElapsed) {\n+        this.compressionElapsed = compressionElapsed;\n+        this.mergingElapsed = mergingElapsed;\n+    }\n+\n+    /**\n+     * The number of milliseconds elapsed in the parallel compression phase\n+     * @return The number of milliseconds elapsed\n+     */\n+    public long getCompressionElapsed() {\n+        return compressionElapsed;\n+    }\n+\n+    /**\n+     * The number of milliseconds elapsed in merging the results of the parallel compression, the IO phase\n+     * @return The number of milliseconds elapsed\n+     */\n+    public long getMergingElapsed() {\n+        return mergingElapsed;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"compressionElapsed=\" + compressionElapsed + \"ms, mergingElapsed=\" + mergingElapsed + \"ms\";\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryPredicate.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryPredicate.java\n /**\n  *  A predicate to test if a #ZipArchiveEntry matches a criteria.\n  *  Some day this can extend java.util.function.Predicate\n+ *\n+ *  @since 1.10\n  */\n public interface ZipArchiveEntryPredicate {\n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequest.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequest.java\n \n /**\n  * A Thread-safe representation of a ZipArchiveEntry that is used to add entries to parallel archives.\n+ *\n+ * @since 1.10\n  */\n public class ZipArchiveEntryRequest {\n     /*", "timestamp": 1422037325, "metainfo": ""}