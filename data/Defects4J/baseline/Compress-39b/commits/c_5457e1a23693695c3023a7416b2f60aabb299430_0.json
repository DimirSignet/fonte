{"sha": "5457e1a23693695c3023a7416b2f60aabb299430", "log": "whitespace", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n     private void buildDecodingStream() throws IOException {\n         final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n         if (folderIndex < 0) {\n-        \tdeferredBlockStreams.clear();\n+            deferredBlockStreams.clear();\n             // TODO: previously it'd return an empty stream?\n-        \t// new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\n+            // new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\n             return;\n         }\n         final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n         if (currentFolderIndex == folderIndex) {\n-        \t// (COMPRESS-320).\n-        \t// The current entry is within the same (potentially opened) folder. The\n-        \t// previous stream has to be fully decoded before we can start reading\n-        \t// but don't do it eagerly -- if the user skips over the entire folder nothing\n-        \t// is effectively decompressed.\n-\n-            // need to advance the folder input stream past the current file\n+            // (COMPRESS-320).\n+            // The current entry is within the same (potentially opened) folder. The\n+            // previous stream has to be fully decoded before we can start reading\n+            // but don't do it eagerly -- if the user skips over the entire folder nothing\n+            // is effectively decompressed.\n+\n             file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n         } else {\n-        \t// We're opening a new folder. Discard any queued streams/ folder stream.\n+            // We're opening a new folder. Discard any queued streams/ folder stream.\n             currentFolderIndex = folderIndex;\n-        \tdeferredBlockStreams.clear();\n+            deferredBlockStreams.clear();\n             if (currentFolderInputStream != null) {\n                 currentFolderInputStream.close();\n                 currentFolderInputStream = null;\n      *             if an I/O error has occurred\n      */\n     public int read() throws IOException {\n-    \treturn getCurrentStream().read();\n+        return getCurrentStream().read();\n     }\n     \n     private InputStream getCurrentStream() throws IOException {\n         }\n         \n         while (deferredBlockStreams.size() > 1) {\n-        \t// In solid compression mode we need to decompress all leading folder' \n-        \t// streams to get access to an entry. We defer this until really needed\n-        \t// so that entire blocks can be skipped without wasting time for decompression.\n-        \tInputStream stream = deferredBlockStreams.remove(0);\n-        \tIOUtils.skip(stream, Long.MAX_VALUE);\n-        \tstream.close();\n-        }\n-\n-\t\treturn deferredBlockStreams.get(0);\n-\t}\n-\n-\t/**\n+            // In solid compression mode we need to decompress all leading folder'\n+            // streams to get access to an entry. We defer this until really needed\n+            // so that entire blocks can be skipped without wasting time for decompression.\n+            InputStream stream = deferredBlockStreams.remove(0);\n+            IOUtils.skip(stream, Long.MAX_VALUE);\n+            stream.close();\n+        }\n+\n+        return deferredBlockStreams.get(0);\n+    }\n+\n+    /**\n      * Reads data into an array of bytes.\n      * \n      * @param b the array to write data to\n      *             if an I/O error has occurred\n      */\n     public int read(byte[] b) throws IOException {\n-    \treturn read(b, 0, b.length);\n+        return read(b, 0, b.length);\n     }\n     \n     /**\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n     // https://issues.apache.org/jira/browse/COMPRESS-320\n     @Test\n     public void testRandomlySkippingEntries() throws Exception {\n-    \t// Read sequential reference.\n-    \tMap<String, byte[]> entriesByName = new HashMap<String, byte[]>();\n-\t    SevenZFile archive = new SevenZFile(getFile(\"COMPRESS-320/Copy.7z\"));\n-\t    SevenZArchiveEntry entry;\n-\t    while ((entry = archive.getNextEntry()) != null) {\n-\t    \tif (entry.hasStream()) {\n-\t    \t\tentriesByName.put(entry.getName(), readFully(archive));\n-\t    \t}\n-\t    }\n-\t    archive.close();\n-\n-\t\tString[] variants = {\n-\t\t\t\"BZip2-solid.7z\", \n-\t\t\t\"BZip2.7z\", \n-\t\t\t\"Copy-solid.7z\", \n-\t\t\t\"Copy.7z\", \n-\t\t\t\"Deflate-solid.7z\", \n-\t\t\t\"Deflate.7z\",\n-\t\t\t\"LZMA-solid.7z\", \n-\t\t\t\"LZMA.7z\", \n-\t\t\t\"LZMA2-solid.7z\", \n-\t\t\t\"LZMA2.7z\", \n-\t\t\t// TODO: unsupported compression method.\n-\t\t\t// \"PPMd-solid.7z\", \n-\t\t\t// \"PPMd.7z\", \n-\t\t};\n-\n-\t\t// TODO: use randomizedtesting for predictable, but different, randomness.\n-\t\tRandom rnd = new Random(0xdeadbeef);\n-\t\tfor (String fileName : variants) {\n-\t\t    archive = new SevenZFile(getFile(\"COMPRESS-320/\" + fileName));\n-\n-\t\t    while ((entry = archive.getNextEntry()) != null) {\n-\t\t\t\t// Sometimes skip reading entries.\n-\t\t    \tif (rnd.nextBoolean()) {\n-\t\t    \t\tcontinue;\n-\t\t    \t}\n-\n-\t\t\t\tif (entry.hasStream()) {\n-\t\t\t\t    assertTrue(entriesByName.containsKey(entry.getName()));\n-\t\t\t\t    byte [] content = readFully(archive);\n-\t\t\t\t    assertTrue(\"Content mismatch on: \" + fileName + \"!\" + entry.getName(), \n-\t\t\t\t    \t\tArrays.equals(content, entriesByName.get(entry.getName())));\n-\t\t\t\t}\n-\t\t    }\n-\t\n-\t\t    archive.close();\n-\t\t}\n-    }\n-\n-\tprivate byte [] readFully(SevenZFile archive) throws IOException {\n-\t    byte [] buf = new byte [1024];\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\t\tfor (int len = 0; (len = archive.read(buf)) > 0;) {\n-\t\t    baos.write(buf, 0, len);\n-\t\t}\n-\t\treturn baos.toByteArray();\n-\t}\n+        // Read sequential reference.\n+        Map<String, byte[]> entriesByName = new HashMap<String, byte[]>();\n+        SevenZFile archive = new SevenZFile(getFile(\"COMPRESS-320/Copy.7z\"));\n+        SevenZArchiveEntry entry;\n+        while ((entry = archive.getNextEntry()) != null) {\n+            if (entry.hasStream()) {\n+                entriesByName.put(entry.getName(), readFully(archive));\n+            }\n+        }\n+        archive.close();\n+\n+        String[] variants = {\n+            \"BZip2-solid.7z\",\n+            \"BZip2.7z\",\n+            \"Copy-solid.7z\",\n+            \"Copy.7z\",\n+            \"Deflate-solid.7z\",\n+            \"Deflate.7z\",\n+            \"LZMA-solid.7z\",\n+            \"LZMA.7z\",\n+            \"LZMA2-solid.7z\",\n+            \"LZMA2.7z\",\n+            // TODO: unsupported compression method.\n+            // \"PPMd-solid.7z\",\n+            // \"PPMd.7z\",\n+        };\n+\n+        // TODO: use randomizedtesting for predictable, but different, randomness.\n+        Random rnd = new Random(0xdeadbeef);\n+        for (String fileName : variants) {\n+            archive = new SevenZFile(getFile(\"COMPRESS-320/\" + fileName));\n+\n+            while ((entry = archive.getNextEntry()) != null) {\n+                // Sometimes skip reading entries.\n+                if (rnd.nextBoolean()) {\n+                    continue;\n+                }\n+\n+                if (entry.hasStream()) {\n+                    assertTrue(entriesByName.containsKey(entry.getName()));\n+                    byte [] content = readFully(archive);\n+                    assertTrue(\"Content mismatch on: \" + fileName + \"!\" + entry.getName(),\n+                               Arrays.equals(content, entriesByName.get(entry.getName())));\n+                }\n+            }\n+\n+            archive.close();\n+        }\n+    }\n+\n+    private byte[] readFully(SevenZFile archive) throws IOException {\n+        byte [] buf = new byte [1024];\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        for (int len = 0; (len = archive.read(buf)) > 0;) {\n+            baos.write(buf, 0, len);\n+        }\n+        return baos.toByteArray();\n+    }\n \n     @Test\n     public void testAllEmptyFilesArchive() throws Exception {\n             archive.close();\n         }\n     }\n-    \n+\n     @Test\n     public void testHelloWorldHeaderCompressionOffCopy() throws Exception {\n         checkHelloWorld(\"7z-hello-mhc-off-copy.7z\");", "timestamp": 1456325315, "metainfo": ""}