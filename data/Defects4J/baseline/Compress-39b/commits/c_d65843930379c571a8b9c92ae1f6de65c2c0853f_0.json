{"sha": "d65843930379c571a8b9c92ae1f6de65c2c0853f", "log": "CRC32 is supposed to be an unsigned int  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n             if (basicHeaderSize <= 2600) {\n                 basicHeaderBytes = new byte[basicHeaderSize];\n                 readFully(in, basicHeaderBytes);\n-                final int basicHeaderCrc32 = read32(in);\n+                final long basicHeaderCrc32 = read32(in) & 0xFFFFFFFFL;\n                 final CRC32 crc32 = new CRC32();\n                 crc32.update(basicHeaderBytes);\n-                if (basicHeaderCrc32 == (int)crc32.getValue()) {\n+                if (basicHeaderCrc32 == crc32.getValue()) {\n                     found = true;\n                 }\n             }\n         if (extendedHeaderSize > 0) {\n             mainHeader.extendedHeaderBytes = new byte[extendedHeaderSize];\n             readFully(in, mainHeader.extendedHeaderBytes);\n-            final int extendedHeaderCrc32 = read32(in);\n+            final long extendedHeaderCrc32 = 0xffffFFFFL & read32(in);\n             final CRC32 crc32 = new CRC32();\n             crc32.update(mainHeader.extendedHeaderBytes);\n-            if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n+            if (extendedHeaderCrc32 != crc32.getValue()) {\n                 throw new IOException(\"Extended header CRC32 verification failure\");\n             }\n         }\n         localFileHeader.dateTimeModified = read32(firstHeader);\n         localFileHeader.compressedSize = 0xffffFFFFL & read32(firstHeader);\n         localFileHeader.originalSize = 0xffffFFFFL & read32(firstHeader);\n-        localFileHeader.originalCrc32 = read32(firstHeader);\n+        localFileHeader.originalCrc32 = 0xffffFFFFL & read32(firstHeader);\n         localFileHeader.fileSpecPosition = read16(firstHeader);\n         localFileHeader.fileAccessMode = read16(firstHeader);\n         pushedBackBytes(20);\n         while ((extendedHeaderSize = read16(in)) > 0) {\n             final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n             readFully(in, extendedHeaderBytes);\n-            final int extendedHeaderCrc32 = read32(in);\n+            final long extendedHeaderCrc32 = 0xffffFFFFL & read32(in);\n             final CRC32 crc32 = new CRC32();\n             crc32.update(extendedHeaderBytes);\n-            if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n+            if (extendedHeaderCrc32 != crc32.getValue()) {\n                 throw new IOException(\"Extended header CRC32 verification failure\");\n             }\n             extendedHeaders.add(extendedHeaderBytes);\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/LocalFileHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/LocalFileHeader.java\n     int dateTimeModified;\n     long compressedSize;\n     long originalSize;\n-    int originalCrc32;\n+    long originalCrc32;\n     int fileSpecPosition;\n     int fileAccessMode;\n     int firstChapter;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Archive.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Archive.java\n     /// Whether each particular packed streams has a CRC.\n     BitSet packCrcsDefined;\n     /// CRCs for each packed stream, valid only if that packed stream has one.\n-    int[] packCrcs;\n+    long[] packCrcs;\n     /// Properties of solid compression blocks.\n     Folder[] folders;\n     /// Temporary properties for non-empty files (subsumed into the files array later).\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n     /// Whether the folder has a CRC.\n     boolean hasCrc;\n     /// The CRC, if present.\n-    int crc;\n+    long crc;\n     /// The number of unpack substreams, one per non-empty file in this folder.\n     int numUnpackSubStreams;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n     private boolean hasWindowsAttributes;\n     private int windowsAttributes;\n     private boolean hasCrc;\n-    private int crc, compressedCrc;\n+    private long crc, compressedCrc;\n     private long size, compressedSize;\n     \n     public SevenZArchiveEntry() {\n \n     /**\n      * Gets the CRC.\n+     * @deprecated use getCrcValue instead.\n      */\n     public int getCrc() {\n-        return crc;\n+        return (int) crc;\n     }\n \n     /**\n      * Sets the CRC.\n+     * @deprecated use setCrcValue instead.\n      */\n     public void setCrc(int crc) {\n         this.crc = crc;\n     }\n \n     /**\n+     * Gets the CRC.\n+     * @since Compress 1.7\n+     */\n+    public long getCrcValue() {\n+        return crc;\n+    }\n+\n+    /**\n+     * Sets the CRC.\n+     * @since Compress 1.7\n+     */\n+    public void setCrcValue(long crc) {\n+        this.crc = crc;\n+    }\n+\n+    /**\n      * Gets the compressed CRC.\n+     * @deprecated use getCompressedCrcValue instead.\n      */\n     int getCompressedCrc() {\n+        return (int) compressedCrc;\n+    }\n+\n+    /**\n+     * Sets the compressed CRC.\n+     * @deprecated use setCompressedCrcValue instead.\n+     */\n+    void setCompressedCrc(int crc) {\n+        this.compressedCrc = crc;\n+    }\n+\n+    /**\n+     * Gets the compressed CRC.\n+     * @since Compress 1.7\n+     */\n+    long getCompressedCrcValue() {\n         return compressedCrc;\n     }\n \n     /**\n      * Sets the compressed CRC.\n-     */\n-    void setCompressedCrc(int crc) {\n+     * @since Compress 1.7\n+     */\n+    void setCompressedCrcValue(long crc) {\n         this.compressedCrc = crc;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n                     archiveVersionMajor, archiveVersionMinor));\n         }\n \n-        final int startHeaderCrc = Integer.reverseBytes(file.readInt());\n+        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n         final StartHeader startHeader = readStartHeader(startHeaderCrc);\n         \n         final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n         file.readFully(nextHeader);\n         final CRC32 crc = new CRC32();\n         crc.update(nextHeader);\n-        if (startHeader.nextHeaderCrc != (int) crc.getValue()) {\n+        if (startHeader.nextHeaderCrc != crc.getValue()) {\n             throw new IOException(\"NextHeader CRC mismatch\");\n         }\n         \n         return archive;\n     }\n     \n-    private StartHeader readStartHeader(final int startHeaderCrc) throws IOException {\n+    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n         final StartHeader startHeader = new StartHeader();\n         DataInputStream dataInputStream = null;\n         try {\n                     new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n              startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n              startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n-             startHeader.nextHeaderCrc = Integer.reverseBytes(dataInputStream.readInt());\n+             startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n              return startHeader;\n         } finally {\n             if (dataInputStream != null) {\n         \n         if (nid == NID.kCRC) {\n             archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);\n-            archive.packCrcs = new int[(int)numPackStreams];\n+            archive.packCrcs = new long[(int)numPackStreams];\n             for (int i = 0; i < (int)numPackStreams; i++) {\n                 if (archive.packCrcsDefined.get(i)) {\n-                    archive.packCrcs[i] = Integer.reverseBytes(header.readInt());\n+                    archive.packCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                 }\n             }\n             \n             for (int i = 0; i < (int)numFolders; i++) {\n                 if (crcsDefined.get(i)) {\n                     folders[i].hasCrc = true;\n-                    folders[i].crc = Integer.reverseBytes(header.readInt());\n+                    folders[i].crc = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                 } else {\n                     folders[i].hasCrc = false;\n                 }\n         final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n         subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n         subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n-        subStreamsInfo.crcs = new int[totalUnpackStreams];\n+        subStreamsInfo.crcs = new long[totalUnpackStreams];\n         \n         int nextUnpackStream = 0;\n         for (final Folder folder : archive.folders) {\n         \n         if (nid == NID.kCRC) {\n             final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n-            final int[] missingCrcs = new int[numDigests];\n+            final long[] missingCrcs = new long[numDigests];\n             for (int i = 0; i < numDigests; i++) {\n                 if (hasMissingCrc.get(i)) {\n-                    missingCrcs[i] = Integer.reverseBytes(header.readInt());\n+                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                 }\n             }\n             int nextCrc = 0;\n                 files[i].setDirectory(false);\n                 files[i].setAntiItem(false);\n                 files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n-                files[i].setCrc(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n+                files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                 files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                 ++nonEmptyFileCounter;\n             } else {\n                 currentFolderInputStream, file.getSize());\n         if (file.getHasCrc()) {\n             currentEntryInputStream = new CRC32VerifyingInputStream(\n-                    fileStream, file.getSize(), file.getCrc());\n+                    fileStream, file.getSize(), file.getCrcValue());\n         } else {\n             currentEntryInputStream = fileStream;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n             ++numNonEmptyStreams;\n             entry.setSize(currentOutputStream.getBytesWritten());\n             entry.setCompressedSize(fileBytesWritten);\n-            entry.setCrc((int) crc32.getValue());\n-            entry.setCompressedCrc((int) compressedCrc32.getValue());\n+            entry.setCrcValue(crc32.getValue());\n+            entry.setCompressedCrcValue(compressedCrc32.getValue());\n             entry.setHasCrc(true);\n         } else {\n             entry.setHasStream(false);\n         final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n         crc32.reset();\n         crc32.update(startHeaderBytes);\n-        file.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n+        file.writeInt(Integer.reverseBytes((int) crc32.getValue()));\n         file.write(startHeaderBytes);\n     }\n     \n         header.write(1);\n         for (final SevenZArchiveEntry entry : files) {\n             if (entry.hasStream()) {\n-                header.writeInt(Integer.reverseBytes(entry.getCompressedCrc()));\n+                header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n             }\n         }\n         \n         header.write(1);\n         for (final SevenZArchiveEntry entry : files) {\n             if (entry.hasStream()) {\n-                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n+                header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n             }\n         }\n         \n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/StartHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/StartHeader.java\n class StartHeader {\n     long nextHeaderOffset;\n     long nextHeaderSize;\n-    int nextHeaderCrc;\n+    long nextHeaderCrc;\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SubStreamsInfo.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SubStreamsInfo.java\n     /// Whether CRC is present for each unpacked stream.\n     BitSet hasCrc;\n     /// CRCs of unpacked streams, if present.\n-    int[] crcs;\n+    long[] crcs;\n }\n--- a/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CRC32VerifyingInputStream.java\n public class CRC32VerifyingInputStream extends InputStream {\n     private final InputStream in;\n     private long bytesRemaining;\n-    private final int expectedCrc32;\n+    private final long expectedCrc32;\n     private final CRC32 crc32 = new CRC32();\n     \n-    public CRC32VerifyingInputStream(final InputStream in, final long size, final int expectedCrc32) {\n+    public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\n         this.in = in;\n         this.expectedCrc32 = expectedCrc32;\n         this.bytesRemaining = size;\n             crc32.update(ret);\n             --bytesRemaining;\n         }\n-        if (bytesRemaining == 0 && expectedCrc32 != (int)crc32.getValue()) {\n+        if (bytesRemaining == 0 && expectedCrc32 != crc32.getValue()) {\n             throw new IOException(\"CRC32 verification failed\");\n         }\n         return ret;\n             crc32.update(b, off, ret);\n             bytesRemaining -= ret;\n         }\n-        if (bytesRemaining <= 0 && expectedCrc32 != (int)crc32.getValue()) {\n+        if (bytesRemaining <= 0 && expectedCrc32 != crc32.getValue()) {\n             throw new IOException(\"CRC32 verification failed\");\n         }\n         return ret;", "timestamp": 1386432234, "metainfo": ""}