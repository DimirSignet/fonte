{"sha": "70c8320f7f592d325e8c89a294a1b2db70595f65", "log": "applied patch from Christian Grobmeier  https://issues.apache.org/jira/browse/SANDBOX-241  added the cpio implementation, added a cpio archive and improved the testcases, some nitpicking    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n \n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n         \treturn new TarArchiveInputStream(in);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n         \treturn new JarArchiveInputStream(in);\n+        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        \treturn new CpioArchiveInputStream(in);\n         }\n     \treturn null;\n     }\n         \treturn new TarArchiveOutputStream(out);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n         \treturn new JarArchiveOutputStream(out);\n+        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        \treturn new CpioArchiveOutputStream(out);\n         }\n     \treturn null;\n     }\n \t\t\treturn new TarArchiveInputStream(input);\n \t\t} else if(ArArchiveInputStream.matches(signature)) {\n \t\t\treturn new ArArchiveInputStream(input);\n+\t\t} else if(CpioArchiveInputStream.matches(signature)) {\n+\t\t\treturn new CpioArchiveInputStream(input);\n \t\t} \n \t\treturn null;\n \t}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.cpio;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+\n+/**\n+ * A cpio archive consists of a sequence of files. There are several types of\n+ * headers defided in two categories of new and old format. The headers are\n+ * recognized by magic numbers: \"070701\" ascii for \"new\" portable format\n+ * \"070702\" ascii for \"new\" portable format with CRC format \"070707\" ascii for\n+ * old ascii \"070707\" short for old binary CPIO 2.5 knows also about tar, but it\n+ * is not recognized here.\n+ * \n+ * OLD FORMAT: Each file has a 76(ascii)/26(binary) byte header, a variable\n+ * length, NUL terminated filename, and variable length file data. A header for\n+ * a filename \"TRAILER!!!\" indicates the end of the archive.\n+ * \n+ * All the fields in the header are ISO 646 (approximately ASCII) strings of\n+ * octal numbers, left padded, not NUL terminated.\n+ * \n+ * Field Name Length in Bytes Notes ASCII / BINARY c_magic 6 / 2 c_dev 6 / 2\n+ * Device that contains a directory entry for this file c_ino 6 / 2 I-node\n+ * number that identifies the input file to the file system c_mode 6 / 2 Mode of\n+ * the input file c_uid 6 / 2 User ID of the owner of the input file c_gid 6 / 2\n+ * Group ID of the owner of the input file c_nlink 6 / 2 Number of links that\n+ * are connected to the input file c_rdev 6 / 2 ID of the remote device from\n+ * which the input file is taken only valid for chr and blk special files\n+ * c_mtime 11 / 4 Time when data was last modified. For remote files, this field\n+ * contains the time at the server c_namesize 6 / 2 Length of the path name,\n+ * including the terminating null byte c_filesize 11 / 4 Length of the file in\n+ * bytes. This is the length of the data section that follows the header\n+ * structure. Must be 0 for FIFOs and directories\n+ * \n+ * Special files, directories, and the trailer are recorded with the h_filesize\n+ * field equal to 0.\n+ * \n+ * NEW FORMAT: Each file has a 110 byte header, a variable length, NUL\n+ * terminated filename, and variable length file data. A header for a filename\n+ * \"TRAILER!!!\" indicates the end of the archive. All the fields in the header\n+ * are ISO 646 (approximately ASCII) strings of hexadecimal numbers, left\n+ * padded, not NUL terminated.\n+ * \n+ * Field Name Length in Bytes Notes c_magic 6 c_ino 8 c_mode 8 c_uid 8 c_gid 8\n+ * c_nlink 8 c_mtime 8 c_filesize 8 must be 0 for FIFOs and directories c_maj 8\n+ * c_min 8 c_rmaj 8 only valid for chr and blk special files c_rmin 8 only valid\n+ * for chr and blk special files c_namesize 8 count includes terminating NUL in\n+ * pathname c_chksum 8 0 for \"new\" portable format; for CRC format the sum of\n+ * all the bytes in the file\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net) \n+ */\n+public class CpioArchiveEntry implements CpioConstants, ArchiveEntry {\n+\t\n+    private long chksum = 0;\n+\n+    private short fileFormat = -1;\n+\n+    private long filesize = 0;\n+\n+    private long gid = 0;\n+\n+    private long headerSize = -1;\n+\n+    private long inode = 0;\n+\n+    private long maj = 0;\n+\n+    private long min = 0;\n+\n+    private long mode = -1;\n+\n+    private long mtime = -1;\n+\n+    private String name;\n+\n+    private long nlink = 0;\n+\n+    private long rmaj = 0;\n+\n+    private long rmin = 0;\n+\n+    private long uid = 0;\n+\n+    /**\n+     * Ceates a CPIOArchiveEntry without a cpio format.\n+     */\n+    public CpioArchiveEntry() {\n+        // do nothing\n+    }\n+\n+    /**\n+     * Ceates a CPIOArchiveEntry with a specified format.\n+     * \n+     * @param format\n+     *            The cpio format for this entry.\n+     */\n+    public CpioArchiveEntry(final short format) {\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry will\n+     * be the new format.\n+     * \n+     * @param name\n+     *            The name of this entry.\n+     */\n+    public CpioArchiveEntry(final String name) {\n+        this(FORMAT_NEW);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry will\n+     * be the new format.\n+     * \n+     * @param name\n+     *            The name of this entry.\n+     * @param size\n+     * \t\t\t  The size of this entry\n+     */\n+    public CpioArchiveEntry(final String name, final long size) {\n+        this(FORMAT_NEW);\n+        this.name = name;\n+        this.setSize(size);\n+    }\n+    \n+    /**\n+     * Check if the method is allowed for the defined format.\n+     */\n+    private void checkNewFormat() {\n+        if ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Check if the method is allowed for the defined format.\n+     */\n+    private void checkOldFormat() {\n+        if ((this.fileFormat & FORMAT_OLD_MASK) == 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Get the checksum.\n+     * \n+     * @return Returns the checksum.\n+     */\n+    public long getChksum() {\n+        checkNewFormat();\n+        return this.chksum;\n+    }\n+\n+    /**\n+     * Get the device id.\n+     * \n+     * @return Returns the device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     */\n+    public long getDevice() {\n+        checkOldFormat();\n+        return this.min;\n+    }\n+\n+    /**\n+     * Get the major device id.\n+     * \n+     * @return Returns the major device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     */\n+    public long getDeviceMaj() {\n+        checkNewFormat();\n+        return this.maj;\n+    }\n+\n+    /**\n+     * Get the minor device id\n+     * \n+     * @return Returns the minor device id.\n+     */\n+    public long getDeviceMin() {\n+        checkNewFormat();\n+        return this.min;\n+    }\n+\n+    /**\n+     * Get the filesize.\n+     * \n+     * @return Returns the filesize.\n+     */\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n+     */\n+    public long getSize() {\n+        return this.filesize;\n+    }\n+\n+    /**\n+     * Get the format for this entry.\n+     * \n+     * @return Returns the format.\n+     */\n+    public short getFormat() {\n+        return this.fileFormat;\n+    }\n+\n+    /**\n+     * Get the group id.\n+     * \n+     * @return Returns the group id.\n+     */\n+    public long getGID() {\n+        return this.gid;\n+    }\n+\n+    /**\n+     * Get the size of this entry on the stream\n+     * \n+     * @return Returns the size.\n+     */\n+    public long getHeaderSize() {\n+        return this.headerSize;\n+    }\n+\n+    /**\n+     * Set the inode.\n+     * \n+     * @return Returns the inode.\n+     */\n+    public long getInode() {\n+        return this.inode;\n+    }\n+\n+    /**\n+     * Get the mode of this entry (e.g. directory, regular file).\n+     * \n+     * @return Returns the mode.\n+     */\n+    public long getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Get the name.\n+     * \n+     * @return Returns the name.\n+     */\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Get the number of links.\n+     * \n+     * @return Returns the number of links.\n+     */\n+    public long getNumberOfLinks() {\n+        return this.nlink;\n+    }\n+\n+    /**\n+     * Get the remote device id.\n+     * \n+     * @return Returns the remote device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     */\n+    public long getRemoteDevice() {\n+        checkOldFormat();\n+        return this.rmin;\n+    }\n+\n+    /**\n+     * Get the remote major device id.\n+     * \n+     * @return Returns the remote major device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     */\n+    public long getRemoteDeviceMaj() {\n+        checkNewFormat();\n+        return this.rmaj;\n+    }\n+\n+    /**\n+     * Get the remote minor device id.\n+     * \n+     * @return Returns the remote minor device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     */\n+    public long getRemoteDeviceMin() {\n+        checkNewFormat();\n+        return this.rmin;\n+    }\n+\n+    /**\n+     * Get the time in seconds.\n+     * \n+     * @return Returns the time.\n+     */\n+    public long getTime() {\n+        return this.mtime;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     * \n+     * @return Returns the user id.\n+     */\n+    public long getUID() {\n+        return this.uid;\n+    }\n+\n+    /**\n+     * Check if this entry represents a block device.\n+     * \n+     * @return TRUE if this entry is a block device.\n+     */\n+    public boolean isBlockDevice() {\n+        return (this.mode & S_IFMT) == C_ISBLK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a character device.\n+     * \n+     * @return TRUE if this entry is a character device.\n+     */\n+    public boolean isCharacterDevice() {\n+        return (this.mode & S_IFMT) == C_ISCHR;\n+    }\n+\n+    /**\n+     * Check if this entry represents a directory.\n+     * \n+     * @return TRUE if this entry is a directory.\n+     */\n+    public boolean isDirectory() {\n+        return (this.mode & S_IFMT) == C_ISDIR;\n+    }\n+\n+    /**\n+     * Check if this entry represents a network device.\n+     * \n+     * @return TRUE if this entry is a network device.\n+     */\n+    public boolean isNetwork() {\n+        return (this.mode & S_IFMT) == C_ISNWK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a pipe.\n+     * \n+     * @return TRUE if this entry is a pipe.\n+     */\n+    public boolean isPipe() {\n+        return (this.mode & S_IFMT) == C_ISFIFO;\n+    }\n+\n+    /**\n+     * Check if this entry represents a regular file.\n+     * \n+     * @return TRUE if this entry is a regular file.\n+     */\n+    public boolean isRegularFile() {\n+        return (this.mode & S_IFMT) == C_ISREG;\n+    }\n+\n+    /**\n+     * Check if this entry represents a socket.\n+     * \n+     * @return TRUE if this entry is a socket.\n+     */\n+    public boolean isSocket() {\n+        return (this.mode & S_IFMT) == C_ISSOCK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a symbolic link.\n+     * \n+     * @return TRUE if this entry is a symbolic link.\n+     */\n+    public boolean isSymbolicLink() {\n+        return (this.mode & S_IFMT) == C_ISLNK;\n+    }\n+\n+    /**\n+     * Set the checksum. The checksum is calculated by adding all bytes of a\n+     * file to transfer (crc += buf[pos] & 0xFF).\n+     * \n+     * @param chksum\n+     *            The checksum to set.\n+     */\n+    public void setChksum(final long chksum) {\n+        checkNewFormat();\n+        this.chksum = chksum;\n+    }\n+\n+    /**\n+     * Set the device id.\n+     * \n+     * @param device\n+     *            The device id to set.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     */\n+    public void setDevice(final long device) {\n+        checkOldFormat();\n+        this.min = device;\n+    }\n+\n+    /**\n+     * Set major device id.\n+     * \n+     * @param maj\n+     *            The major device id to set.\n+     */\n+    public void setDeviceMaj(final long maj) {\n+        checkNewFormat();\n+        this.maj = maj;\n+    }\n+\n+    /**\n+     * Set the minor device id\n+     * \n+     * @param min\n+     *            The minor device id to set.\n+     */\n+    public void setDeviceMin(final long min) {\n+        checkNewFormat();\n+        this.min = min;\n+    }\n+\n+    /**\n+     * Set the filesize.\n+     * \n+     * @param size\n+     *            The filesize to set.\n+     */\n+    public void setSize(final long size) {\n+        if (size < 0 || size > 0xFFFFFFFFL) {\n+            throw new IllegalArgumentException(\"invalid entry size <\" + size\n+                    + \">\");\n+        }\n+        this.filesize = size;\n+    }\n+\n+    /**\n+     * Set the format for this entry. Possible values are:\n+     * CPIOConstants.FORMAT_NEW, CPIOConstants.FORMAT_NEW_CRC,\n+     * CPIOConstants.FORMAT_OLD_BINARY, CPIOConstants.FORMAT_OLD_ASCII\n+     * \n+     * @param format\n+     *            The format to set.\n+     */\n+    void setFormat(final short format) {\n+        switch (format) {\n+        case FORMAT_NEW:\n+            this.fileFormat = FORMAT_NEW;\n+            this.headerSize = 110;\n+            break;\n+        case FORMAT_NEW_CRC:\n+            this.fileFormat = FORMAT_NEW_CRC;\n+            this.headerSize = 110;\n+            break;\n+        case FORMAT_OLD_ASCII:\n+            this.fileFormat = FORMAT_OLD_ASCII;\n+            this.headerSize = 76;\n+            break;\n+        case FORMAT_OLD_BINARY:\n+            this.fileFormat = FORMAT_OLD_BINARY;\n+            this.headerSize = 26;\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"Unknown header type\");\n+        }\n+    }\n+\n+    /**\n+     * Set the group id.\n+     * \n+     * @param gid\n+     *            The group id to set.\n+     */\n+    public void setGID(final long gid) {\n+        this.gid = gid;\n+    }\n+\n+    /**\n+     * Set the inode.\n+     * \n+     * @param inode\n+     *            The inode to set.\n+     */\n+    public void setInode(final long inode) {\n+        this.inode = inode;\n+    }\n+\n+    /**\n+     * Set the mode of this entry (e.g. directory, regular file).\n+     * \n+     * @param mode\n+     *            The mode to set.\n+     */\n+    public void setMode(final long mode) {\n+        switch ((int) (mode & S_IFMT)) {\n+        case C_ISDIR:\n+        case C_ISLNK:\n+        case C_ISREG:\n+        case C_ISFIFO:\n+        case C_ISCHR:\n+        case C_ISBLK:\n+        case C_ISSOCK:\n+        case C_ISNWK:\n+            break;\n+        default:\n+            new IllegalArgumentException(\"Unknown mode\");\n+        }\n+\n+        this.mode = mode;\n+    }\n+\n+    /**\n+     * Set the name.\n+     * \n+     * @param name\n+     *            The name to set.\n+     */\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Set the number of links.\n+     * \n+     * @param nlink\n+     *            The number of links to set.\n+     */\n+    public void setNumberOfLinks(final long nlink) {\n+        this.nlink = nlink;\n+    }\n+\n+    /**\n+     * Set the remote device id.\n+     * \n+     * @param device\n+     *            The remote device id to set.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new format.\n+     */\n+    public void setRemoteDevice(final long device) {\n+        checkOldFormat();\n+        this.rmin = device;\n+    }\n+\n+    /**\n+     * Set the remote major device id.\n+     * \n+     * @param rmaj\n+     *            The remote major device id to set.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     */\n+    public void setRemoteDeviceMaj(final long rmaj) {\n+        checkNewFormat();\n+        this.rmaj = rmaj;\n+    }\n+\n+    /**\n+     * Set the remote minor device id.\n+     * \n+     * @param rmin\n+     *            The remote minor device id to set.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old format.\n+     */\n+    public void setRemoteDeviceMin(final long rmin) {\n+        checkNewFormat();\n+        this.rmin = rmin;\n+    }\n+\n+    /**\n+     * Set the time in seconds.\n+     * \n+     * @param time\n+     *            The time to set.\n+     */\n+    public void setTime(final long time) {\n+        this.mtime = time;\n+    }\n+\n+    /**\n+     * Set the user id.\n+     * \n+     * @param uid\n+     *            The user id to set.\n+     */\n+    public void setUID(final long uid) {\n+        this.uid = uid;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.cpio;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+\n+/**\n+ * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of cpio are\n+ * supported (old ascii, old binary, new portable format and the new portable\n+ * format with crc).\n+ * <p/>\n+ * <p/>\n+ * The stream can be read by extracting a cpio entry (containing all\n+ * informations about a entry) and afterwards reading from the stream the file\n+ * specified by the entry.\n+ * <p/>\n+ * <code><pre>\n+ * CPIOArchiveInputStream cpioIn = new CPIOArchiveInputStream(new BufferedInputStream(\n+ *         new FileInputStream(new File(&quot;test.cpio&quot;))));\n+ * CPIOArchiveEntry cpioEntry;\n+ * <p/>\n+ * while ((cpioEntry = cpioIn.getNextEntry()) != null) {\n+ *     System.out.println(cpioEntry.getName());\n+ *     int tmp;\n+ *     StringBuffer buf = new StringBuffer();\n+ *     while ((tmp = cpIn.read()) != -1) {\n+ *         buf.append((char) tmp);\n+ *     }\n+ *     System.out.println(buf.toString());\n+ * }\n+ * cpioIn.close();\n+ * </pre></code>\n+ * <p/>\n+ * Note: This implementation should be compatible to cpio 2.5\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net) \n+ */\n+\n+public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants {\n+\t\n+    private boolean closed = false;\n+\n+    private CpioArchiveEntry entry;\n+\n+    private long entryBytesRead = 0;\n+\n+    private boolean entryEOF = false;\n+\n+    private byte[] singleByteBuf = new byte[1];\n+\n+    private byte tmpbuf[] = new byte[4096];\n+\n+    private long crc = 0;\n+    \n+    private InputStream in = null;\n+\n+    /**\n+     * Construct the cpio input stream\n+     *\n+     * @param in The cpio stream\n+     */\n+    public CpioArchiveInputStream(final InputStream in) {\n+        this.in = in;\n+    }\n+\n+    /**\n+     * Returns 0 after EOF has reached for the current entry data, otherwise\n+     * always return 1.\n+     * <p/>\n+     * Programs should not count on this method to return the actual number of\n+     * bytes that could be read without blocking.\n+     *\n+     * @return 1 before EOF and 0 after EOF has reached for current entry.\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public int available() throws IOException {\n+        ensureOpen();\n+        if (this.entryEOF) {\n+            return 0;\n+        }\n+        return 1;\n+    }\n+\n+    /**\n+     * Converts a byte array to a long. Halfwords can be swaped with setting\n+     * swapHalfWord=true.\n+     *\n+     * @param number       An array of bytes containing a number\n+     * @param swapHalfWord Swap halfwords ([0][1][2][3]->[1][0][3][2])\n+     * @return The long value\n+     */\n+    private long byteArray2long(final byte[] number, final boolean swapHalfWord) {\n+        long ret = 0;\n+        int pos = 0;\n+        byte tmp_number[] = new byte[number.length];\n+        System.arraycopy(number, 0, tmp_number, 0, number.length);\n+\n+        if (tmp_number.length % 2 != 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        if (!swapHalfWord) {\n+            byte tmp = 0;\n+            for (pos = 0; pos < tmp_number.length; pos++) {\n+                tmp = tmp_number[pos];\n+                tmp_number[pos++] = tmp_number[pos];\n+                tmp_number[pos] = tmp;\n+            }\n+        }\n+\n+        ret = tmp_number[0] & 0xFF;\n+        for (pos = 1; pos < tmp_number.length; pos++) {\n+            ret <<= 8;\n+            ret |= tmp_number[pos] & 0xFF;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Closes the CPIO input stream.\n+     *\n+     * @throws IOException if an I/O error has occurred\n+     */\n+    public void close() throws IOException {\n+        if (!this.closed) {\n+            super.close();\n+            this.closed = true;\n+        }\n+    }\n+\n+    /**\n+     * Closes the current CPIO entry and positions the stream for reading the\n+     * next entry.\n+     *\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public void closeEntry() throws IOException {\n+        ensureOpen();\n+        while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) {\n+            // do nothing\n+        }\n+\n+        this.entryEOF = true;\n+    }\n+\n+    /**\n+     * Check to make sure that this stream has not been closed\n+     *\n+     * @throws IOException if the stream is already closed\n+     */\n+    private void ensureOpen() throws IOException {\n+        if (this.closed) {\n+            throw new IOException(\"Stream closed\");\n+        }\n+    }\n+\n+    /**\n+     * Reads the next CPIO file entry and positions stream at the beginning of\n+     * the entry data.\n+     *\n+     * @return the CPIOArchiveEntry just read\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public CpioArchiveEntry getNextCPIOEntry() throws IOException {\n+        ensureOpen();\n+        if (this.entry != null) {\n+            closeEntry();\n+        }\n+        byte magic[] = new byte[2];\n+        readFully(magic, 0, magic.length);\n+        if (byteArray2long(magic, false) == MAGIC_OLD_BINARY) {\n+            this.entry = readOldBinaryEntry(false);\n+        } else if (byteArray2long(magic, true) == MAGIC_OLD_BINARY) {\n+            this.entry = readOldBinaryEntry(true);\n+        } else {\n+            byte more_magic[] = new byte[4];\n+            readFully(more_magic, 0, more_magic.length);\n+            byte tmp[] = new byte[6];\n+            System.arraycopy(magic, 0, tmp, 0, magic.length);\n+            System.arraycopy(more_magic, 0, tmp, magic.length,\n+                    more_magic.length);\n+            String magicString = new String(tmp);\n+            if (magicString.equals(MAGIC_NEW)) {\n+                this.entry = readNewEntry(false);\n+            } else if (magicString.equals(MAGIC_NEW_CRC)) {\n+                this.entry = readNewEntry(true);\n+            } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n+                this.entry = readOldAsciiEntry();\n+            } else {\n+                throw new IOException(\"Unknown magic [\" + magicString + \"]\");\n+            }\n+        }\n+\n+        this.entryBytesRead = 0;\n+        this.entryEOF = false;\n+        this.crc = 0;\n+\n+        if (this.entry.getName().equals(\"TRAILER!!!\")) {\n+            this.entryEOF = true;\n+            return null;\n+        }\n+        return this.entry;\n+    }\n+\n+    private long pad(final long count, final int border) throws IOException {\n+        long skip = count % border;\n+        if (skip > 0) {\n+            skip = this.in.skip(border - skip);\n+        }\n+        return skip;\n+    }\n+\n+    /**\n+     * Reads a byte of data. This method will block until enough input is\n+     * available.\n+     *\n+     * @return the byte read, or -1 if end of input is reached\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public int read() throws IOException {\n+        return read(this.singleByteBuf, 0, 1) == -1 ? -1\n+                : this.singleByteBuf[0] & 0xff;\n+    }\n+\n+    /**\n+     * Reads from the current CPIO entry into an array of bytes. Blocks until\n+     * some input is available.\n+     *\n+     * @param b   the buffer into which the data is read\n+     * @param off the start offset of the data\n+     * @param len the maximum number of bytes read\n+     * @return the actual number of bytes read, or -1 if the end of the entry is\n+     *         reached\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public int read(final byte[] b, final int off, final int len)\n+            throws IOException {\n+        ensureOpen();\n+        if (off < 0 || len < 0 || off > b.length - len) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return 0;\n+        }\n+\n+        if (this.entry == null || this.entryEOF) {\n+            return -1;\n+        }\n+        if (this.entryBytesRead == this.entry.getSize()) {\n+            if ((this.entry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n+                pad(this.entry.getSize(), 4);\n+            } else if ((this.entry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n+                pad(this.entry.getSize(), 2);\n+            }\n+            this.entryEOF = true;\n+            if ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+                if (this.crc != this.entry.getChksum()) {\n+                    throw new IOException(\"CRC Error\");\n+                }\n+            }\n+            return -1;\n+        }\n+        int tmplength = (int) Math.min(len, this.entry.getSize()\n+                - this.entryBytesRead);\n+        if (tmplength < 0) {\n+            return -1;\n+        }\n+\n+        int tmpread = this.in.read(b, off, tmplength);\n+        if ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+            for (int pos = 0; pos < tmpread; pos++) {\n+                this.crc += b[pos] & 0xFF;\n+            }\n+        }\n+        this.entryBytesRead += tmpread;\n+\n+        return tmpread;\n+    }\n+\n+    private final int readFully(final byte[] b, final int off, final int len)\n+            throws IOException {\n+        if (len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+        int n = 0;\n+        while (n < len) {\n+            int count = this.in.read(b, off + n, len - n);\n+            if (count < 0) {\n+                throw new EOFException();\n+            }\n+            n += count;\n+        }\n+        return n;\n+    }\n+\n+    private long readBinaryLong(final int length, final boolean swapHalfWord)\n+            throws IOException {\n+        byte tmp[] = new byte[length];\n+        readFully(tmp, 0, tmp.length);\n+        return byteArray2long(tmp, swapHalfWord);\n+    }\n+\n+    private long readAsciiLong(final int length, final int radix)\n+            throws IOException {\n+        byte tmpBuffer[] = new byte[length];\n+        readFully(tmpBuffer, 0, tmpBuffer.length);\n+        return Long.parseLong(new String(tmpBuffer), radix);\n+    }\n+\n+    private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException {\n+        CpioArchiveEntry ret;\n+        if (hasCrc) {\n+            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n+        } else {\n+            ret = new CpioArchiveEntry(FORMAT_NEW);\n+        }\n+\n+        ret.setInode(readAsciiLong(8, 16));\n+        ret.setMode(readAsciiLong(8, 16));\n+        ret.setUID(readAsciiLong(8, 16));\n+        ret.setGID(readAsciiLong(8, 16));\n+        ret.setNumberOfLinks(readAsciiLong(8, 16));\n+        ret.setTime(readAsciiLong(8, 16));\n+        ret.setSize(readAsciiLong(8, 16));\n+        ret.setDeviceMaj(readAsciiLong(8, 16));\n+        ret.setDeviceMin(readAsciiLong(8, 16));\n+        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n+        ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n+        long namesize = readAsciiLong(8, 16);\n+        ret.setChksum(readAsciiLong(8, 16));\n+        ret.setName(readCString((int) namesize));\n+        pad(ret.getHeaderSize() + namesize, 4);\n+\n+        return ret;\n+    }\n+\n+    private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n+        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n+\n+        ret.setDevice(readAsciiLong(6, 8));\n+        ret.setInode(readAsciiLong(6, 8));\n+        ret.setMode(readAsciiLong(6, 8));\n+        ret.setUID(readAsciiLong(6, 8));\n+        ret.setGID(readAsciiLong(6, 8));\n+        ret.setNumberOfLinks(readAsciiLong(6, 8));\n+        ret.setRemoteDevice(readAsciiLong(6, 8));\n+        ret.setTime(readAsciiLong(11, 8));\n+        long namesize = readAsciiLong(6, 8);\n+        ret.setSize(readAsciiLong(11, 8));\n+        ret.setName(readCString((int) namesize));\n+\n+        return ret;\n+    }\n+\n+    private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n+            throws IOException {\n+        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n+\n+        ret.setDevice(readBinaryLong(2, swapHalfWord));\n+        ret.setInode(readBinaryLong(2, swapHalfWord));\n+        ret.setMode(readBinaryLong(2, swapHalfWord));\n+        ret.setUID(readBinaryLong(2, swapHalfWord));\n+        ret.setGID(readBinaryLong(2, swapHalfWord));\n+        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n+        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n+        ret.setTime(readBinaryLong(4, swapHalfWord));\n+        long namesize = readBinaryLong(2, swapHalfWord);\n+        ret.setSize(readBinaryLong(4, swapHalfWord));\n+        ret.setName(readCString((int) namesize));\n+        pad(ret.getHeaderSize() + namesize, 2);\n+\n+        return ret;\n+    }\n+\n+    private String readCString(final int length) throws IOException {\n+        byte tmpBuffer[] = new byte[length];\n+        readFully(tmpBuffer, 0, tmpBuffer.length);\n+        return new String(tmpBuffer, 0, tmpBuffer.length - 1);\n+    }\n+\n+    /**\n+     * Skips specified number of bytes in the current CPIO entry.\n+     *\n+     * @param n the number of bytes to skip\n+     * @return the actual number of bytes skipped\n+     * @throws IOException              if an I/O error has occurred\n+     * @throws IllegalArgumentException if n < 0\n+     */\n+    public long skip(final long n) throws IOException {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"negative skip length\");\n+        }\n+        ensureOpen();\n+        int max = (int) Math.min(n, Integer.MAX_VALUE);\n+        int total = 0;\n+\n+        while (total < max) {\n+            int len = max - total;\n+            if (len > this.tmpbuf.length) {\n+                len = this.tmpbuf.length;\n+            }\n+            len = read(this.tmpbuf, 0, len);\n+            if (len == -1) {\n+                this.entryEOF = true;\n+                break;\n+            }\n+            total += len;\n+        }\n+        return total;\n+    }\n+\n+\tpublic ArchiveEntry getNextEntry() throws IOException {\n+\t\tCpioArchiveEntry entry = this.getNextCPIOEntry();\n+    \tif(entry == null) {\n+    \t\treturn null;\n+    \t}\n+\t\treturn (ArchiveEntry)entry;\n+\t}\n+\t\n+\tpublic static boolean matches( byte[] signature ) {\n+\t\t// 3037 3037 30\n+    \t\n+    \tif (signature[0] != 0x30) {\n+    \t\treturn false;\n+    \t}\n+    \tif (signature[1] != 0x37) {\n+    \t\treturn false;\n+    \t}\n+    \tif (signature[2] != 0x30) {\n+    \t\treturn false;\n+    \t}\n+    \tif (signature[3] != 0x37) {\n+    \t\treturn false;\n+    \t}\n+    \tif (signature[4] != 0x30) {\n+    \t\treturn false;\n+    \t}\n+    \t\n+    \treturn true;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.cpio;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+\n+/**\n+ * CPIOArchiveOutputStream is a stream for writting cpio streams. All formats of cpio\n+ * are supported (old ascii, old binary, new portable format and the new\n+ * portable format with crc).\n+ * <p/>\n+ * <p/>\n+ * An entry can be written by creating an instance of CPIOArchiveEntry and fill it with\n+ * the necessary values and put it into the cpio stream. Afterwards write the\n+ * contents of the file into the cpio stream. Either close the stream by calling\n+ * finish() or put a next entry into the cpio stream.\n+ * <p/>\n+ * <code><pre>\n+ * CPIOArchiveOutputStream cpioOut = new CPIOArchiveOutputStream(new BufferedOutputStream(\n+ *         new FileOutputStream(new File(&quot;test.cpio&quot;))));\n+ * CPIOArchiveEntry cpioEntry = new CPIOArchiveEntry();\n+ * cpioEntry.setName(&quot;testfile&quot;);\n+ * String testContents = &quot;12345&quot;;\n+ * cpioEntry.setFileSize(testContents.length());\n+ * cpioOut.putNextEntry(cpioEntry);\n+ * cpioOut.write(testContents.getBytes());\n+ * cpioOut.finish();\n+ * cpioOut.close();\n+ * </pre></code>\n+ * <p/>\n+ * Note: This implementation should be compatible to cpio 2.5\n+ *\n+ * based on code from the jRPM project (jrpm.sourceforge.net) \n+ */\n+public class CpioArchiveOutputStream extends ArchiveOutputStream implements CpioConstants {\n+\t\n+    private CpioArchiveEntry cpioEntry;\n+\n+    private boolean closed = false;\n+\n+    private boolean finished;\n+\n+    private short entryFormat = FORMAT_NEW;\n+\n+    private HashMap names = new HashMap();\n+\n+    private long crc = 0;\n+\n+    private long written;\n+    \n+    private OutputStream out = null;\n+\n+    /**\n+     * Check to make sure that this stream has not been closed\n+     *\n+     * @throws IOException if the stream is already closed\n+     */\n+    private void ensureOpen() throws IOException {\n+        if (this.closed) {\n+            throw new IOException(\"Stream closed\");\n+        }\n+    }\n+\n+    /**\n+     * Construct the cpio output stream with a specified format\n+     *\n+     * @param out    The cpio stream\n+     * @param format The format of the stream\n+     */\n+    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n+    \tthis.out = new FilterOutputStream(out);\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Construct the cpio output stream. The format for this CPIO stream is the\n+     * \"new\" format\n+     *\n+     * @param out The cpio stream\n+     */\n+    public CpioArchiveOutputStream(final OutputStream out) {\n+        this(out, FORMAT_NEW);\n+    }\n+\n+    /**\n+     * Set a default header format. This will be used if no format is defined in\n+     * the cpioEntry given to putNextEntry().\n+     *\n+     * @param format A CPIO format\n+     */\n+    public void setFormat(final short format) {\n+        switch (format) {\n+            case FORMAT_NEW:\n+            case FORMAT_NEW_CRC:\n+            case FORMAT_OLD_ASCII:\n+            case FORMAT_OLD_BINARY:\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown header type\");\n+\n+        }\n+        this.entryFormat = format;\n+    }\n+\n+    /**\n+     * Begins writing a new CPIO file entry and positions the stream to the\n+     * start of the entry data. Closes the current entry if still active. The\n+     * current time will be used if the entry has no set modification time and\n+     * the default header format will be used if no other format is specified in\n+     * the entry.\n+     *\n+     * @param e the CPIO cpioEntry to be written\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n+        ensureOpen();\n+        if (this.cpioEntry != null) {\n+            closeEntry(); // close previous entry\n+        }\n+        if (e.getTime() == -1) {\n+            e.setTime(System.currentTimeMillis());\n+        }\n+        if (e.getFormat() == -1) {\n+            e.setFormat(this.entryFormat);\n+        }\n+\n+        if (this.names.put(e.getName(), e) != null) {\n+            throw new IOException(\"duplicate entry: \" + e.getName());\n+        }\n+\n+        writeHeader(e);\n+        this.cpioEntry = e;\n+        this.written = 0;\n+    }\n+\n+    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n+        switch (e.getFormat()) {\n+            case FORMAT_NEW:\n+            \tout.write(MAGIC_NEW.getBytes());\n+                writeNewEntry(e);\n+                break;\n+            case FORMAT_NEW_CRC:\n+            \tout.write(MAGIC_NEW_CRC.getBytes());\n+                writeNewEntry(e);\n+                break;\n+            case FORMAT_OLD_ASCII:\n+            \tout.write(MAGIC_OLD_ASCII.getBytes());\n+                writeOldAsciiEntry(e);\n+                break;\n+            case FORMAT_OLD_BINARY:\n+                boolean swapHalfWord = true;\n+                writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n+                writeOldBinaryEntry(e, swapHalfWord);\n+                break;\n+        }\n+    }\n+\n+    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n+        writeAsciiLong(entry.getInode(), 8, 16);\n+        writeAsciiLong(entry.getMode(), 8, 16);\n+        writeAsciiLong(entry.getUID(), 8, 16);\n+        writeAsciiLong(entry.getGID(), 8, 16);\n+        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n+        writeAsciiLong(entry.getTime(), 8, 16);\n+        writeAsciiLong(entry.getSize(), 8, 16);\n+        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n+        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n+        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n+        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n+        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n+        writeAsciiLong(entry.getChksum(), 8, 16);\n+        writeCString(entry.getName());\n+        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n+    }\n+\n+    private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException {\n+        writeAsciiLong(entry.getDevice(), 6, 8);\n+        writeAsciiLong(entry.getInode(), 6, 8);\n+        writeAsciiLong(entry.getMode(), 6, 8);\n+        writeAsciiLong(entry.getUID(), 6, 8);\n+        writeAsciiLong(entry.getGID(), 6, 8);\n+        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n+        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n+        writeAsciiLong(entry.getTime(), 11, 8);\n+        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n+        writeAsciiLong(entry.getSize(), 11, 8);\n+        writeCString(entry.getName());\n+    }\n+\n+    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n+                                     final boolean swapHalfWord) throws IOException {\n+        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n+        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n+        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n+        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n+        writeCString(entry.getName());\n+        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n+    }\n+\n+    /**\n+     * Closes the current CPIO entry and positions the stream for writing the\n+     * next entry.\n+     *\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public void closeEntry() throws IOException {\n+        ensureOpen();\n+\n+        if (this.cpioEntry.getSize() != this.written) {\n+            throw new IOException(\"invalid entry size (expected \"\n+                    + this.cpioEntry.getSize() + \" but got \" + this.written\n+                    + \" bytes)\");\n+        }\n+        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n+            pad(this.cpioEntry.getSize(), 4);\n+        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n+            pad(this.cpioEntry.getSize(), 2);\n+        }\n+        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+            if (this.crc != this.cpioEntry.getChksum()) {\n+                throw new IOException(\"CRC Error\");\n+            }\n+        }\n+        if (this.cpioEntry != null) {\n+            this.cpioEntry = null;\n+        }\n+        this.crc = 0;\n+        this.written = 0;\n+    }\n+\n+    /**\n+     * Writes an array of bytes to the current CPIO entry data. This method will\n+     * block until all the bytes are written.\n+     *\n+     * @param b   the data to be written\n+     * @param off the start offset in the data\n+     * @param len the number of bytes that are written\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public synchronized void write(final byte[] b, final int off, final int len)\n+            throws IOException {\n+        ensureOpen();\n+        if (off < 0 || len < 0 || off > b.length - len) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return;\n+        }\n+\n+        if (this.cpioEntry == null) {\n+            throw new IOException(\"no current CPIO entry\");\n+        }\n+        if (this.written + len > this.cpioEntry.getSize()) {\n+            throw new IOException(\"attempt to write past end of STORED entry\");\n+        }\n+        out.write(b, off, len);\n+        this.written += len;\n+        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n+            for (int pos = 0; pos < len; pos++) {\n+                this.crc += b[pos] & 0xFF;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Finishes writing the contents of the CPIO output stream without closing\n+     * the underlying stream. Use this method when applying multiple filters in\n+     * succession to the same output stream.\n+     *\n+     * @throws IOException if an I/O exception has occurred or if a CPIO file error\n+     *                     has occurred\n+     */\n+    public void finish() throws IOException {\n+        ensureOpen();\n+        // TODO: synchronize and finish\n+        if (this.finished) {\n+            return;\n+        }\n+        if (this.cpioEntry != null) {\n+            closeEntry();\n+        }\n+        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n+        this.cpioEntry.setMode(0);\n+        this.cpioEntry.setName(\"TRAILER!!!\");\n+        this.cpioEntry.setNumberOfLinks(1);\n+        writeHeader(this.cpioEntry);\n+        closeEntry();\n+    }\n+\n+    /**\n+     * Closes the CPIO output stream as well as the stream being filtered.\n+     *\n+     * @throws IOException if an I/O error has occurred or if a CPIO file error has\n+     *                     occurred\n+     */\n+    public void close() throws IOException {\n+        if (!this.closed) {\n+            super.close();\n+            this.closed = true;\n+        }\n+    }\n+\n+    private void pad(final long count, final int border) throws IOException {\n+        long skip = count % border;\n+        if (skip > 0) {\n+            byte tmp[] = new byte[(int) (border - skip)];\n+            out.write(tmp);\n+        }\n+    }\n+\n+    private void writeBinaryLong(final long number, final int length,\n+                                 final boolean swapHalfWord) throws IOException {\n+        byte tmp[] = long2byteArray(number, length, swapHalfWord);\n+        out.write(tmp);\n+    }\n+\n+    private void writeAsciiLong(final long number, final int length,\n+                                final int radix) throws IOException {\n+        StringBuffer tmp = new StringBuffer();\n+        String tmpStr;\n+        if (radix == 16) {\n+            tmp.append(Long.toHexString(number));\n+        } else if (radix == 8) {\n+            tmp.append(Long.toOctalString(number));\n+        } else {\n+            tmp.append(Long.toString(number));\n+        }\n+\n+        if (tmp.length() <= length) {\n+            long insertLength = length - tmp.length();\n+            for (int pos = 0; pos < insertLength; pos++) {\n+                tmp.insert(0, \"0\");\n+            }\n+            tmpStr = tmp.toString();\n+        } else {\n+            tmpStr = tmp.substring(tmp.length() - length);\n+        }\n+        out.write(tmpStr.getBytes());\n+    }\n+\n+    private void writeCString(final String str) throws IOException {\n+    \tout.write(str.getBytes());\n+    \tout.write('\\0');\n+    }\n+\n+    /**\n+     * Converts a byte array to a long. Halfwords can be swaped with setting\n+     * swapHalfWord=true.\n+     *\n+     * @param number       An array of bytes containing a number\n+     * @param length       The length of the returned array\n+     * @param swapHalfWord Swap halfwords ([0][1][2][3]->[1][0][3][2])\n+     * @return The long value\n+     */\n+    private static byte[] long2byteArray(final long number, final int length,\n+                                         final boolean swapHalfWord) {\n+        byte[] ret = new byte[length];\n+        int pos = 0;\n+        long tmp_number = 0;\n+\n+        if (length % 2 != 0 || length < 2) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        tmp_number = number;\n+        for (pos = length - 1; pos >= 0; pos--) {\n+            ret[pos] = (byte) (tmp_number & 0xFF);\n+            tmp_number >>= 8;\n+        }\n+\n+        if (!swapHalfWord) {\n+            byte tmp = 0;\n+            for (pos = 0; pos < length; pos++) {\n+                tmp = ret[pos];\n+                ret[pos++] = ret[pos];\n+                ret[pos] = tmp;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry()\n+\t */\n+\tpublic void closeArchiveEntry() throws IOException {\n+\t\tthis.closeEntry();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry(org.apache.commons.compress.archivers.ArchiveEntry)\n+\t */\n+\tpublic void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+\t\tthis.putNextEntry((CpioArchiveEntry)entry);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see java.io.OutputStream#write(int)\n+\t */\n+\tpublic void write(int b) throws IOException {\n+\t\tout.write(b);\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioConstants.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.cpio;\n+\n+/**\n+ * All constants needed by CPIO.\n+ * \n+ * based on code from the jRPM project (jrpm.sourceforge.net) \n+ */\n+public interface CpioConstants {\n+    /** magic number of a cpio entry in the new format */\n+    final String MAGIC_NEW = \"070701\";\n+\n+    /** magic number of a cpio entry in the new format with crc */\n+    final String MAGIC_NEW_CRC = \"070702\";\n+\n+    /** magic number of a cpio entry in the old ascii format */\n+    final String MAGIC_OLD_ASCII = \"070707\";\n+\n+    /** magic number of a cpio entry in the old binary format */\n+    final int MAGIC_OLD_BINARY = 070707;\n+\n+    /** write/read a CPIOArchiveEntry in the new format */\n+    final short FORMAT_NEW = 1;\n+\n+    /** write/read a CPIOArchiveEntry in the new format with crc */\n+    final short FORMAT_NEW_CRC = 2;\n+\n+    /** write/read a CPIOArchiveEntry in the old ascii format */\n+    final short FORMAT_OLD_ASCII = 4;\n+\n+    /** write/read a CPIOArchiveEntry in the old binary format */\n+    final short FORMAT_OLD_BINARY = 8;\n+\n+    /** Mask for both new formats */\n+    final short FORMAT_NEW_MASK = 3;\n+\n+    /** Mask for both old formats */\n+    final short FORMAT_OLD_MASK = 12;\n+\n+    /** Mask for all file type bits. */\n+    final int S_IFMT = 0170000;\n+\n+    /** Defines a directory */\n+    final int C_ISDIR = 0040000;\n+\n+    /** Defines a symbolic link */\n+    final int C_ISLNK = 0120000;\n+\n+    /** Defines a regular file */\n+    final int C_ISREG = 0100000;\n+\n+    /** Defines a pipe */\n+    final int C_ISFIFO = 0010000;\n+\n+    /** Defines a character device */\n+    final int C_ISCHR = 0020000;\n+\n+    /** Defines a block device */\n+    final int C_ISBLK = 0060000;\n+\n+    /** Defines a socket */\n+    final int C_ISSOCK = 0140000;\n+\n+    /** HP/UX network special (C_ISCTG) */\n+    final int C_ISNWK = 0110000;\n+\n+    /** Permits the owner of a file to read the file */\n+    final int C_IRUSR = 000400;\n+\n+    /** Permits the owner of a file to write to the file */\n+    final int C_IWUSR = 000200;\n+\n+    /**\n+     * Permits the owner of a file to execute the file or to search the file's\n+     * directory\n+     */\n+    final int C_IXUSR = 000100;\n+\n+    /** Permits a file's group to read the file */\n+    final int C_IRGRP = 000040;\n+\n+    /** Permits a file's group to write to the file */\n+    final int C_IWGRP = 000020;\n+\n+    /**\n+     * Permits a file's group to execute the file or to search the file's\n+     * directory\n+     */\n+    final int C_IXGRP = 000010;\n+\n+    /** Permits others to read the file */\n+    final int C_IROTH = 000004;\n+\n+    /** Permits others to write to the file */\n+    final int C_IWOTH = 000002;\n+\n+    /** Permits others to execute the file or to search the file's directory */\n+    final int C_IXOTH = 000001;\n+\n+    /** TODO document */\n+    final int C_ISUID = 004000;\n+\n+    /** TODO document */\n+    final int C_ISGID = 002000;\n+\n+    /** TODO document */\n+    final int C_ISVTX = 001000;\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n \n         int v, t, i, j, gs, ge, totc, bt, bc, iter;\n         int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n-        int nGroups, nBytes;\n+        int nGroups; //, nBytes;\n \n         alphaSize = nInUse + 2;\n         for (t = 0; t < N_GROUPS; t++) {\n                 }\n             }\n \n-            nBytes = bytesOut;\n+            //nBytes = bytesOut;\n             for (i = 0; i < 16; i++) {\n                 if (inUse16[i]) {\n                     bsW(1, 1);\n         }\n \n         /* Now the selectors. */\n-        nBytes = bytesOut;\n+        //nBytes = bytesOut;\n         bsW (3, nGroups);\n         bsW (15, nSelectors);\n         for (i = 0; i < nSelectors; i++) {\n         }\n \n         /* Now the coding tables. */\n-        nBytes = bytesOut;\n+        //nBytes = bytesOut;\n \n         for (t = 0; t < nGroups; t++) {\n             int curr = len[t][0];\n         }\n \n         /* And finally, the block data proper */\n-        nBytes = bytesOut;\n+        //nBytes = bytesOut;\n         selCtr = 0;\n         gs = 0;\n         while (true) {\n--- a/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n \t\tfinal ArchiveInputStream ar = factory.createArchiveInputStream(\n \t\t\t\tnew BufferedInputStream(new FileInputStream(\n \t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.ar\").getFile())))); \n+\t\tassertNotNull(ar);\n \t\tassertTrue(ar instanceof ArArchiveInputStream);\n \n \t\tfinal ArchiveInputStream tar = factory.createArchiveInputStream(\n \t\t\t\tnew BufferedInputStream(new FileInputStream(\n \t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.tar\").getFile()))));\n+\t\tassertNotNull(tar);\n \t\tassertTrue(tar instanceof TarArchiveInputStream);\n \n \t\tfinal ArchiveInputStream zip = factory.createArchiveInputStream(\n \t\t\t\tnew BufferedInputStream(new FileInputStream(\n \t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.zip\").getFile()))));\n+\t\tassertNotNull(zip);\n \t\tassertTrue(zip instanceof ZipArchiveInputStream);\n \n \t\tfinal ArchiveInputStream jar = factory.createArchiveInputStream(\n \t\t\t\tnew BufferedInputStream(new FileInputStream(\n \t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.jar\").getFile()))));\n+\t\tassertNotNull(jar);\n \t\tassertTrue(jar instanceof JarArchiveInputStream);\n+\n+\t\tfinal ArchiveInputStream cpio = factory.createArchiveInputStream(\n+\t\t\t\tnew BufferedInputStream(new FileInputStream(\n+\t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.cpio\").getFile()))));\n+\t\tassertNotNull(cpio);\n+\t\tassertTrue(cpio instanceof CpioArchiveInputStream);\n \n //\t\tfinal ArchiveInputStream tgz = factory.createArchiveInputStream(\n //\t\t\t\tnew BufferedInputStream(new FileInputStream(\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.archivers.cpio.CpioArchiveEntry;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n+public final class CpioTestCase extends AbstractTestCase {\n+\n+\tpublic void testCpioArchiveCreation() throws Exception {\n+\t\tfinal File output = new File(dir, \"bla.cpio\");\n+\t\t\n+\t\tfinal File file1 = getFile(\"test1.xml\");\n+\t\tfinal File file2 = getFile(\"test2.xml\");\n+\t\t\n+\t\tfinal OutputStream out = new FileOutputStream(output);\n+        final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n+\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n+\t\tIOUtils.copy(new FileInputStream(file1), os);\n+\t\tos.closeArchiveEntry();\n+\t\t\n+\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n+\t\tIOUtils.copy(new FileInputStream(file2), os);\n+\t\tos.closeArchiveEntry();\n+\t\t\n+\t\tos.close();\n+\t}\n+\n+\tpublic void testCpioUnarchive() throws Exception {\n+\t\tfinal File output = new File(dir, \"bla.cpio\");\n+\t\t{\n+\t\t\tfinal File file1 = getFile(\"test1.xml\");\n+\t\t\tfinal File file2 = getFile(\"test2.xml\");\n+\t\t\t\n+\t\t\tfinal OutputStream out = new FileOutputStream(output);\n+\t        final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n+\t\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n+\t\t\tIOUtils.copy(new FileInputStream(file1), os);\n+\t\t\tos.closeArchiveEntry();\n+\t\t\t\n+\t\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n+\t\t\tIOUtils.copy(new FileInputStream(file2), os);\n+\t\t\tos.closeArchiveEntry();\n+\t\t\tos.close();\n+\t\t}\n+\t\t\n+\t\t// Unarchive Operation\n+\t\tfinal File input = output;\n+\t\tfinal InputStream is = new FileInputStream(input);\n+\t\tfinal ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n+\t\tfinal CpioArchiveEntry entry = (CpioArchiveEntry)in.getNextEntry();\n+\t\t\n+\t\tFile target = new File(dir, entry.getName());\n+        final OutputStream out = new FileOutputStream(target);\n+        \n+        IOUtils.copy(in, out);\n+    \n+        out.close();\n+        in.close();\n+\t}\n+\n+}", "timestamp": 1231758561, "metainfo": ""}