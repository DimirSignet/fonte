{"sha": "4d68ddaedca7219f4b12b3c239f9238d5e1c185b", "log": "extract general purpose bit logic  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Parser/encoder for the \"general purpose bit\" field in ZIP's local\n+ * file and cebtral directory headers.\n+ * @since Apache Commons Compress 1.1\n+ */\n+public class GeneralPurposeBit {\n+    /**\n+     * Indicates that a data descriptor stored after the file contents\n+     * will hold CRC and size information.\n+     */\n+    private static final int DATA_DESCRIPTOR_FLAG = 1 << 3;\n+\n+    /**\n+     * Indicates that filenames are written in utf-8.\n+     *\n+     * <p>The only reason this is public is that {@link\n+     * ZipArchiveOutputStream#EFS_FLAG} was public in Apache Commons\n+     * Compress 1.0 and we needed a substitute for it.</p>\n+     */\n+    public static final int UFT8_NAMES_FLAG = 1 << 11;\n+\n+    private boolean languageEncodingFlag = false;\n+    private boolean dataDescriptorFlag = false;\n+\n+    public GeneralPurposeBit() {\n+    }\n+\n+    /**\n+     * whether the current entry uses UTF8 for file name and comment.\n+     */\n+    public boolean usesUTF8ForNames() {\n+        return languageEncodingFlag;\n+    }\n+\n+    /**\n+     * whether the current entry will use UTF8 for file name and comment.\n+     */\n+    public void useUTF8ForNames(boolean b) {\n+        languageEncodingFlag = b;\n+    }\n+\n+    /**\n+     * whether the current entry uses the data descriptor to store CRC\n+     * and size information\n+     */\n+    public boolean usesDataDescriptor() {\n+        return dataDescriptorFlag;\n+    }\n+\n+    /**\n+     * whether the current entry will use the data descriptor to store\n+     * CRC and size information\n+     */\n+    public void useDataDescriptor(boolean b) {\n+        dataDescriptorFlag = b;\n+    }\n+\n+    /**\n+     * Encodes the set bits in a form suitable for ZIP archives.\n+     */\n+    public byte[] encode() {\n+        return \n+            ZipShort.getBytes((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n+                              |\n+                              (languageEncodingFlag ? UFT8_NAMES_FLAG : 0)\n+                              );\n+    }\n+\n+    /**\n+     * Parses the supported flags from the given archive data.\n+     * @param data local file header or a central directory entry.\n+     * @param offset offset at which the general purpose bit starts\n+     */\n+    public static GeneralPurposeBit parse(final byte[] data, final int offset) {\n+        final int generalPurposeFlag = ZipShort.getValue(data, offset);\n+        GeneralPurposeBit b = new GeneralPurposeBit();\n+        b.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\n+        b.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\n+        return b;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                             & ZipFile.NIBLET_MASK);\n \n-        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n-        final boolean hasUTF8Flag = \n-            (generalPurposeFlag & ZipArchiveOutputStream.UFT8_NAMES_FLAG) != 0;\n+        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\n+        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n-        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n+        hasDataDescriptor = gpFlag.usesDataDescriptor();\n \n         off += SHORT;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     /**\n      * General purpose flag, which indicates that filenames are\n      * written in utf-8.\n-     */\n-    public static final int UFT8_NAMES_FLAG = 1 << 11;\n-\n-    /**\n-     * General purpose flag, which indicates that filenames are\n-     * written in utf-8.\n-     * @deprecated use {@link #UFT8_NAMES_FLAG} instead\n-     */\n-    public static final int EFS_FLAG = UFT8_NAMES_FLAG;\n+     * @deprecated use {@link GeneralPurposeBit#UFT8_NAMES_FLAG} instead\n+     */\n+    public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n \n     /**\n      * Current entry.\n \n         // CheckStyle:MagicNumber OFF\n         int versionNeededToExtract = 10;\n-        int generalPurposeFlag = (useUTF8Flag || utfFallback) ? UFT8_NAMES_FLAG : 0;\n+        GeneralPurposeBit b = new GeneralPurposeBit();\n+        b.useUTF8ForNames(useUTF8Flag || utfFallback);\n         if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor\n             versionNeededToExtract =  20;\n-            // bit3 set to signal, we use a data descriptor\n-            generalPurposeFlag |= 8;\n+            b.useDataDescriptor(true);\n         }\n         // CheckStyle:MagicNumber ON\n \n         // version needed to extract\n         writeOut(ZipShort.getBytes(versionNeededToExtract));\n         // general purpose bit flag\n-        writeOut(ZipShort.getBytes(generalPurposeFlag));\n+        writeOut(b.encode());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n \n             off += SHORT; // skip version info\n \n-            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\n-            final boolean hasUTF8Flag = \n-                (generalPurposeFlag & ZipArchiveOutputStream.UFT8_NAMES_FLAG) != 0;\n+            final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n+            final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n             final ZipEncoding entryEncoding =\n                 hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBitTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.Arrays;\n+import junit.framework.TestCase;\n+\n+public class GeneralPurposeBitTest extends TestCase {\n+\n+    public void testDefaults() {\n+        assertFalse(new GeneralPurposeBit().usesDataDescriptor());\n+        assertFalse(new GeneralPurposeBit().usesUTF8ForNames());\n+        byte[] b = new byte[2];\n+        assertTrue(Arrays.equals(b, new GeneralPurposeBit().encode()));\n+    }\n+\n+    public void testParseEdgeCases() {\n+        assertFalse(GeneralPurposeBit.parse(new byte[2], 0)\n+                    .usesDataDescriptor());\n+        assertFalse(GeneralPurposeBit.parse(new byte[2], 0)\n+                    .usesUTF8ForNames());\n+        assertTrue(GeneralPurposeBit.parse(new byte[] {(byte) 255, (byte) 255},\n+                                           0)\n+                   .usesDataDescriptor());\n+        assertTrue(GeneralPurposeBit.parse(new byte[] {(byte) 255, (byte) 255},\n+                                           0)\n+                   .usesUTF8ForNames());\n+    }\n+\n+    public void testDataDescriptor() {\n+        byte[] flags = new byte[] {(byte) 8, (byte) 0};\n+        assertTrue(GeneralPurposeBit.parse(flags, 0).usesDataDescriptor());\n+        GeneralPurposeBit b = new GeneralPurposeBit();\n+        b.useDataDescriptor(true);\n+        assertTrue(Arrays.equals(flags, b.encode()));\n+    }\n+\n+    public void testLanguageEncodingFlag() {\n+        byte[] flags = new byte[] {(byte) 0, (byte) 8};\n+        assertTrue(GeneralPurposeBit.parse(flags, 0).usesUTF8ForNames());\n+        GeneralPurposeBit b = new GeneralPurposeBit();\n+        b.useUTF8ForNames(true);\n+        assertTrue(Arrays.equals(flags, b.encode()));\n+    }\n+}", "timestamp": 1266573397, "metainfo": ""}