{"sha": "0f5e88e5124841c8d198d215daee07d06d573ea1", "log": "base BitStream on BitInputStream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import org.apache.commons.compress.utils.BitInputStream;\n+import java.nio.ByteOrder;\n \n /**\n  * Iterates over the bits of an InputStream. For each byte the bits\n  *\n  * @since 1.7\n  */\n-class BitStream {\n-\n-    private final InputStream in;\n-\n-    /** The bits read from the underlying stream but not consumed by nextBits() */\n-    private long bitCache;\n-\n-    /** The number of bits available in the bit cache */\n-    private int bitCacheSize;\n-\n-    /** Bit masks for extracting the right most bits from a byte */\n-    private static final int[] MASKS = new int[]{ \n-            0x00, // 00000000\n-            0x01, // 00000001\n-            0x03, // 00000011\n-            0x07, // 00000111\n-            0x0F, // 00001111\n-            0x1F, // 00011111\n-            0x3F, // 00111111\n-            0x7F, // 01111111\n-            0xFF  // 11111111\n-    };\n+class BitStream extends BitInputStream {\n \n     BitStream(InputStream in) {\n-        this.in = in;\n-    }\n-\n-    private boolean fillCache() throws IOException {\n-        boolean filled = false;\n-        \n-        while (bitCacheSize <= 56) {\n-            long nextByte = in.read();\n-            if (nextByte == -1) {\n-                break;\n-            }\n-            \n-            filled = true;\n-            bitCache = bitCache | (nextByte << bitCacheSize);\n-            bitCacheSize += 8;\n-        }\n-\n-        return filled;\n+        super(in, ByteOrder.LITTLE_ENDIAN);\n     }\n \n     /**\n      * @return The next bit (0 or 1) or -1 if the end of the stream has been reached\n      */\n     int nextBit() throws IOException {\n-        if (bitCacheSize == 0 && !fillCache()) {\n-            return -1;\n-        }\n-\n-        int bit = (int) (bitCache & 1); // extract the right most bit\n-\n-        bitCache = (bitCache >>> 1); // shift the remaning bits to the right\n-        bitCacheSize--;\n-\n-        return bit;\n+        return readBits(1);\n     }\n \n     /**\n      * @return The value formed by the n bits, or -1 if the end of the stream has been reached\n      */\n     int nextBits(final int n) throws IOException {\n-        if (bitCacheSize < n && !fillCache()) {\n-            return -1;\n-        }\n-\n-        final int bits = (int) (bitCache & MASKS[n]); // extract the right most bits\n-\n-        bitCache = (bitCache >>> n); // shift the remaning bits to the right\n-        bitCacheSize = bitCacheSize - n;\n-\n-        return bits;\n+        return readBits(n);\n     }\n \n     int nextByte() throws IOException {\n-        return nextBits(8);\n+        return readBits(8);\n     }\n }", "timestamp": 1415942391, "metainfo": ""}