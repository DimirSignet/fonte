{"sha": "c7e51ede7a9894e57bb72877ab6b77a0c3ef0705", "log": "detect encrypted entries and say that you can't read/write them.  COMPRESS-89  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n+    private boolean encrypted;\n+    private boolean stronglyEncrypted;\n \n     /**\n      * Creates a new zip entry with the specified name.\n         // the empty string in the current implemention (there's no setter)\n         // so it is basically draining the performance of a hashmap lookup\n         return getName().hashCode();\n+    }\n+\n+    /**\n+     * Whether the entry is encrypted.\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public boolean isEncrypted() {\n+        return encrypted;\n+    }\n+\n+    /**\n+     * Whether the entry is encrypted using strong encryption.\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public boolean isStronglyEncrypted() {\n+        return stronglyEncrypted && encrypted;\n+    }\n+\n+    /**\n+     * Whether the entry is encrypted.\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public void setEncrypted(boolean b) {\n+        encrypted = b;\n+    }\n+\n+    /**\n+     * Whether the entry is encrypted using strong encryption.\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public void setStronglyEncrypted(boolean b) {\n+        stronglyEncrypted = b;\n+        if (b) {\n+            setEncrypted(true);\n+        }\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         final ZipEncoding entryEncoding =\n             hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n         hasDataDescriptor = gpFlag.usesDataDescriptor();\n+        current.setEncrypted(gpFlag.usesEncryption());\n+        current.setStronglyEncrypted(gpFlag.usesStrongEncryption());\n \n         off += SHORT;\n \n         return getNextZipEntry();\n     }\n \n+    /**\n+     * Whether this class is able to read the given entry.\n+     *\n+     * <p>May return false if it is set up to use encryption or a\n+     * compression method that hasn't been implemented yet.</p>\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public boolean canRead(ZipArchiveEntry ze) {\n+        return !ze.isEncrypted() &&\n+            (ze.getMethod() == ZipArchiveEntry.STORED\n+             || ze.getMethod() == ZipArchiveEntry.DEFLATED);\n+    }\n+\n     public int read(byte[] buffer, int start, int length) throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         // avoid int overflow, check null buffer\n         if (start <= buffer.length && length >= 0 && start >= 0\n             && buffer.length - start >= length) {\n-            if (!current.isSupportedCompressionMethod()) {\n+            if (current.isEncrypted()) {\n+                throw new IOException(\"Encryption is not supported, used in \"\n+                                      + \"entry \" + current.getName());\n+            }\n+            if (current.getMethod() != ZipArchiveEntry.STORED\n+                && current.getMethod() != ZipArchiveEntry.DEFLATED) {\n                 throw new IOException(\n                         \"Unsupported compression method \" + current.getMethod()\n                         + \" in ZIP archive entry \" + current.getName());\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     }\n \n     /**\n+     * Whether this stream is able to write the given entry.\n+     *\n+     * <p>May return false if it is set up to use encryption or a\n+     * compression method that hasn't been implemented yet.</p>\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public boolean canWrite(ZipArchiveEntry ze) {\n+        return !ze.isEncrypted() &&\n+            (ze.getMethod() == STORED || ze.getMethod() == DEFLATED);\n+    }\n+\n+    /**\n      * Writes bytes to ZIP entry.\n      * @param b the byte array to write\n      * @param offset the start position to write from\n      * @throws IOException on error\n      */\n     public void write(byte[] b, int offset, int length) throws IOException {\n-        if (!entry.isSupportedCompressionMethod()) {\n+        if (entry.isEncrypted()) {\n+            throw new IOException(\"Encryption is not supported, used in entry \"\n+                                  + entry.getName());\n+        }\n+        if (entry.getMethod() != STORED && entry.getMethod() != DEFLATED) {\n             throw new IOException(\n                     \"Unsupported compression method \" + entry.getMethod()\n                     + \" in ZIP archive entry \" + entry.getName());\n-        } else if (entry.getMethod() == DEFLATED) {\n+        }\n+        if (entry.getMethod() == DEFLATED) {\n             if (length > 0) {\n                 if (!def.finished()) {\n                     if (length <= DEFLATER_BLOCK_SIZE) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n     }\n \n     /**\n+     * Whether this class is able to read the given entry.\n+     *\n+     * <p>May return false if it is set up to use encryption or a\n+     * compression method that hasn't been implemented yet.</p>\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public boolean canRead(ZipArchiveEntry ze) {\n+        return !ze.isEncrypted() &&\n+            (ze.getMethod() == ZipArchiveEntry.STORED\n+             || ze.getMethod() == ZipArchiveEntry.DEFLATED);\n+    }\n+\n+    /**\n      * Returns an InputStream for reading the contents of the given entry.\n      * @param ze the entry to get the stream for.\n      * @return a stream to read the entry from.\n         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);\n         if (offsetEntry == null) {\n             return null;\n+        }\n+        if (ze.isEncrypted()) {\n+            throw new IOException(\"Encryption is not supported, used in \"\n+                                  + \"entry \" + ze.getName());\n+        }\n+        if (ze.getMethod() != ZipArchiveEntry.STORED\n+            && ze.getMethod() != ZipArchiveEntry.DEFLATED) {\n+            throw new IOException(\"Unsupported compression method \"\n+                                  + ze.getMethod() + \" in ZIP archive entry \"\n+                                  + ze.getName());\n         }\n         long start = offsetEntry.dataOffset;\n         BoundedInputStream bis =\n             final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n             final ZipEncoding entryEncoding =\n                 hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n+            ze.setEncrypted(gpFlag.usesEncryption());\n+            ze.setStronglyEncrypted(gpFlag.usesStrongEncryption());\n \n             off += SHORT;\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import junit.framework.TestCase;\n+\n+public class EncryptedArchiveTest extends TestCase {\n+\n+    public void testReadPasswordEncryptedEntryViaZipFile()\n+        throws IOException, URISyntaxException {\n+\tURL zip = getClass().getResource(\"/password-encrypted.zip\");\n+        File file = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+        try {\n+            zf = new ZipFile(file);\n+            ZipArchiveEntry zae = zf.getEntry(\"LICENSE.txt\");\n+            assertTrue(zae.isEncrypted());\n+            assertFalse(zae.isStronglyEncrypted());\n+            assertFalse(zf.canRead(zae));\n+            try {\n+                zf.getInputStream(zae);\n+                fail(\"expected an exception\");\n+            } catch (IOException ex) {\n+                assertTrue(ex.getMessage().indexOf(\"Encryption\") >= 0);\n+            }\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+        }\n+    }\n+\n+    public void testReadPasswordEncryptedEntryViaStream()\n+        throws IOException, URISyntaxException {\n+\tURL zip = getClass().getResource(\"/password-encrypted.zip\");\n+        File file = new File(new URI(zip.toString()));\n+        ZipArchiveInputStream zin = null;\n+        try {\n+            zin = new ZipArchiveInputStream(new FileInputStream(file));\n+            ZipArchiveEntry zae = zin.getNextZipEntry();\n+            assertEquals(\"LICENSE.txt\", zae.getName());\n+            assertTrue(zae.isEncrypted());\n+            assertFalse(zae.isStronglyEncrypted());\n+            assertFalse(zin.canRead(zae));\n+            try {\n+                byte[] buf = new byte[1024];\n+                zin.read(buf, 0, buf.length);\n+                fail(\"expected an exception\");\n+            } catch (IOException ex) {\n+                assertTrue(ex.getMessage().indexOf(\"Encryption\") >= 0);\n+            }\n+        } finally {\n+            if (zin != null) {\n+                zin.close();\n+            }\n+        }\n+    }\n+}", "timestamp": 1266576927, "metainfo": ""}