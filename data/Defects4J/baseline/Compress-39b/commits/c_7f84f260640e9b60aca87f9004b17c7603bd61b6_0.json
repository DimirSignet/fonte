{"sha": "7f84f260640e9b60aca87f9004b17c7603bd61b6", "log": "make clear AbstractLZWInputStream is only public for technical reasons  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n-import org.apache.commons.compress.compressors.z.AbstractLZWInputStream;\n+import org.apache.commons.compress.compressors.z._internal_.InternalLZWInputStream;\n \n /**\n  * Input stream that decompresses ZIP method 1 (unshrinking). A variation of the LZW algorithm, with some twists.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-class UnshrinkingInputStream extends AbstractLZWInputStream {\n+class UnshrinkingInputStream extends InternalLZWInputStream {\n     private static final int MAX_CODE_SIZE = 13;\n     private static final int MAX_TABLE_SIZE = 1 << MAX_CODE_SIZE;\n     private final boolean[] isUsed;\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import org.apache.commons.compress.compressors.z._internal_.InternalLZWInputStream;\n \n /**\n  * Input stream that decompresses .Z files.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-public class ZCompressorInputStream extends AbstractLZWInputStream {\n+public class ZCompressorInputStream extends InternalLZWInputStream {\n     private static final int MAGIC_1 = 0x1f;\n     private static final int MAGIC_2 = 0x9d;\n     private static final int BLOCK_MODE_MASK = 0x80;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     * <p><strong>This method is only protected for technical reasons\n+     * and is not part of Commons Compress' published API.  It may\n+     * change without warning.</strong></p>\n+     */\n     @Override\n     protected int readNextCode() throws IOException {\n         int code = super.readNextCode();\n         bitsCachedSize = 0;\n     }\n     \n+    /**\n+     * {@inheritDoc}\n+     * <p><strong>This method is only protected for technical reasons\n+     * and is not part of Commons Compress' published API.  It may\n+     * change without warning.</strong></p>\n+     */\n     @Override\n     protected int addEntry(int previousCode, byte character) throws IOException {\n         final int maxTableSize = 1 << codeSize;\n         return r;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     * <p><strong>This method is only protected for technical reasons\n+     * and is not part of Commons Compress' published API.  It may\n+     * change without warning.</strong></p>\n+     */\n     @Override\n     protected int decompressNextSymbol() throws IOException {\n         //\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/_internal_/InternalLZWInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.z._internal_;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+\n+/**\n+ * Base-class for traditional Unix \".Z\" compression and the\n+ * Unshrinking method of ZIP archive.\n+ *\n+ * <p><strong>This class is only public for technical reasons and is\n+ * not part of Commons Compress' published API.  It may change without\n+ * warning.</strong></p>\n+ * @NotThreadSafe\n+ * @since 1.7\n+ */\n+public abstract class InternalLZWInputStream extends CompressorInputStream {\n+    private final byte[] oneByte = new byte[1];\n+\n+    protected final InputStream in;\n+    protected int clearCode = -1;\n+    protected int codeSize = 9;\n+    protected int bitsCached = 0;\n+    protected int bitsCachedSize = 0;\n+    protected int previousCode = -1;\n+    protected int tableSize = 0;\n+    protected int[] prefixes;\n+    protected byte[] characters;\n+    private byte[] outputStack;\n+    private int outputStackLocation;\n+\n+    protected InternalLZWInputStream(InputStream inputStream) throws IOException {\n+        this.in = inputStream;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        int ret = read(oneByte);\n+        if (ret < 0) {\n+            return ret;\n+        }\n+        return 0xff & oneByte[0];\n+    }\n+    \n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int bytesRead = readFromStack(b, off, len);\n+        while (len - bytesRead > 0) {\n+            int result = decompressNextSymbol();\n+            if (result < 0) {\n+                if (bytesRead > 0) {\n+                    count(bytesRead);\n+                    return bytesRead;\n+                }\n+                return result;\n+            }\n+            bytesRead += readFromStack(b, off + bytesRead, len - bytesRead);\n+        }\n+        count(bytesRead);\n+        return bytesRead;\n+    }\n+\n+    /**\n+     * Read the next code and expand it.\n+     */\n+    protected abstract int decompressNextSymbol() throws IOException;\n+\n+    /**\n+     * Add a new entry to the dictionary.\n+     */\n+    protected abstract int addEntry(int previousCode, byte character)\n+        throws IOException;\n+\n+    /**\n+     * Sets the clear code based on the code size.\n+     */\n+    protected void setClearCode(int codeSize) {\n+        clearCode = (1 << (codeSize - 1));\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n+     */\n+    protected void initializeTables(int maxCodeSize) {\n+        final int maxTableSize = 1 << maxCodeSize;\n+        prefixes = new int[maxTableSize];\n+        characters = new byte[maxTableSize];\n+        outputStack = new byte[maxTableSize];\n+        outputStackLocation = maxTableSize;\n+        final int max = 1 << 8;\n+        for (int i = 0; i < max; i++) {\n+            prefixes[i] = -1;\n+            characters[i] = (byte) i;\n+        }\n+    }\n+\n+    /**\n+     * Reads the next code from the stream.\n+     */\n+    protected int readNextCode() throws IOException {\n+        while (bitsCachedSize < codeSize) {\n+            final int nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            bitsCached |= (nextByte << bitsCachedSize);\n+            bitsCachedSize += 8;\n+        }\n+        final int mask = (1 << codeSize) - 1;\n+        final int code = (bitsCached & mask);\n+        bitsCached >>>= codeSize;\n+        bitsCachedSize -= codeSize;\n+        return code;\n+    }\n+    \n+    /**\n+     * Adds a new entry if the maximum table size hasn't been exceeded\n+     * and returns the new index.\n+     */\n+    protected int addEntry(int previousCode, byte character, int maxTableSize) {\n+        if (tableSize < maxTableSize) {\n+            final int index = tableSize;\n+            prefixes[tableSize] = previousCode;\n+            characters[tableSize] = character;\n+            tableSize++;\n+            return index;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Add entry for repeat of previousCode we haven't added, yet.\n+     */\n+    protected int addRepeatOfPreviousCode() throws IOException {\n+        if (previousCode == -1) {\n+            // can't have a repeat for the very first code\n+            throw new IOException(\"The first code can't be a reference to its preceding code\");\n+        }\n+        byte firstCharacter = 0;\n+        for (int last = previousCode; last >= 0; last = prefixes[last]) {\n+            firstCharacter = characters[last];\n+        }\n+        return addEntry(previousCode, firstCharacter);\n+    }\n+\n+    /**\n+     * Expands the entry with index code to the output stack and may\n+     * create a new entry\n+     */\n+    protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry)\n+        throws IOException {\n+        for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n+            outputStack[--outputStackLocation] = characters[entry];\n+        }\n+        if (previousCode != -1 && !addedUnfinishedEntry) {\n+            addEntry(previousCode, outputStack[outputStackLocation]);\n+        }\n+        previousCode = code;\n+        return outputStackLocation;\n+    }\n+\n+    private int readFromStack(byte[] b, int off, int len) {\n+        int remainingInStack = outputStack.length - outputStackLocation;\n+        if (remainingInStack > 0) {\n+            int maxLength = Math.min(remainingInStack, len);\n+            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+            outputStackLocation += maxLength;\n+            return maxLength;\n+        }\n+        return 0;\n+    }\n+}", "timestamp": 1387562056, "metainfo": ""}