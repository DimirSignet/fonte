{"sha": "2dca66105a3ec80f99a48ed8c43e3988cc86e84e", "log": "use long to count bytes or we get trouble with archives > 2GB  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n     private static final int BYTE_MASK = 0xFF;\n     \n     /** holds the number of bytes read in this stream */\n-    private int bytesRead = 0;\n+    private long bytesRead = 0;\n \n     /**\n      * Returns the next Archive Entry in this Stream.\n      * \n      * @return the byte read, or -1 if end of input is reached\n      * @throws IOException\n-     *             if an I/O error has occurred or if a CPIO file error has\n-     *             occurred\n+     *             if an I/O error has occurred\n      */\n     public int read() throws IOException {\n         int num = read(SINGLE, 0, 1);\n      * @param read the number of bytes read\n      */\n     protected void count(int read) {\n-        if(read != -1) {\n+        count((long) read);\n+    }\n+\n+    /**\n+     * Increments the counter of already read bytes.\n+     * Doesn't increment if the EOF has been hit (read == -1)\n+     * \n+     * @param read the number of bytes read\n+     */\n+    protected void count(long read) {\n+        if (read != -1) {\n             bytesRead = bytesRead + read;\n         }\n     }\n     \n     /**\n+     * Decrements the counter of already read bytes.\n+     * \n+     * @param read the number of bytes pushed back.\n+     */\n+    protected void pushedBackBytes(long pushedBack) {\n+        bytesRead -= pushedBack;\n+    }\n+    \n+    /**\n+     * Returns the current number of bytes read from this stream.\n+     * @return the number of read bytes\n+     * @deprecated this method may yield wrong results for large\n+     * archives, use #getBytesRead instead\n+     */\n+    public int getCount() {\n+        return (int) bytesRead;\n+    }\n+\n+    /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n      */\n-    public int getCount() {\n+    public long getBytesRead() {\n         return bytesRead;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n     private final byte[] oneByte = new byte[1];\n     static final int BYTE_MASK = 0xFF;\n \n-    /** holds the number of bytes read in this stream */\n-    private int bytesRead = 0;\n+    /** holds the number of bytes written to this stream */\n+    private long bytesWritten = 0;\n     // Methods specific to ArchiveOutputStream\n     \n     /**\n     }\n \n     /**\n-     * Increments the counter of already read bytes.\n+     * Increments the counter of already written bytes.\n      * Doesn't increment if the EOF has been hit (read == -1)\n      * \n      * @param read the number of bytes read\n      */\n     protected void count(int read) {\n-        if(read != -1) {\n-            bytesRead = bytesRead + read;\n+        count((long) read);\n+    }\n+\n+    /**\n+     * Increments the counter of already written bytes.\n+     * Doesn't increment if the EOF has been hit (read == -1)\n+     * \n+     * @param written the number of bytes written\n+     */\n+    protected void count(long written) {\n+        if (written != -1) {\n+            bytesWritten = bytesWritten + written;\n         }\n     }\n     \n     /**\n-     * Returns the current number of bytes read from this stream.\n-     * @return the number of read bytes\n+     * Returns the current number of bytes written to this stream.\n+     * @return the number of written bytes\n+     * @deprecated this method may yield wrong results for large\n+     * archives, use #getBytesWritten instead\n      */\n     public int getCount() {\n-        return bytesRead;\n+        return (int) bytesWritten;\n+    }\n+\n+    /**\n+     * Returns the current number of bytes written to this stream.\n+     * @return the number of written bytes\n+     */\n+    public long getBytesWritten() {\n+        return bytesWritten;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n             final byte[] realized = new byte[expected.length];\n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read header. Occured at byte: \" + getCount());\n+                throw new IOException(\"failed to read header. Occured at byte: \" + getBytesRead());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n             final byte[] realized = new byte[expected.length];\n             final int read = read(realized);\n             if (read != expected.length) {\n-                throw new IOException(\"failed to read entry header. Occured at byte: \" + getCount());\n+                throw new IOException(\"failed to read entry header. Occured at byte: \" + getBytesRead());\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid entry header. not read the content? Occured at byte: \" + getCount());\n+                    throw new IOException(\"invalid entry header. not read the content? Occured at byte: \" + getBytesRead());\n                 }\n             }\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n             } else if (magicString.equals(MAGIC_OLD_ASCII)) {\n                 this.entry = readOldAsciiEntry();\n             } else {\n-                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getCount());\n+                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occured at byte: \" + getBytesRead());\n             }\n         }\n \n             this.entryEOF = true;\n             if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n                 if (this.crc != this.entry.getChksum()) {\n-                    throw new IOException(\"CRC Error. Occured at byte: \" + getCount());\n+                    throw new IOException(\"CRC Error. Occured at byte: \" + getBytesRead());\n                 }\n             }\n             return -1; // EOF for this entry\n         String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getCount());\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n         }\n         skip(ret.getHeaderPadCount());\n \n         final String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getCount());\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n         }\n \n         return ret;\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n-            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getCount());\n+            throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n         }\n         skip(ret.getHeaderPadCount());\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             if (rec == null) {\n                 // Unexpected EOF!\n                 throw new IOException(\"unexpected EOF with \" + numToRead\n-                                      + \" bytes unread. Occured at byte: \" + getCount());\n+                                      + \" bytes unread. Occured at byte: \" + getBytesRead());\n             }\n             count(rec.length);\n             int sz = numToRead;\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n import java.io.InputStream;\n \n public abstract class CompressorInputStream extends InputStream {\n-    private int bytesRead = 0;\n+    private long bytesRead = 0;\n     \n     /**\n      * Increments the counter of already read bytes.\n      * @param read the number of bytes read\n      */\n     protected void count(int read) {\n+        count((long) read);\n+    }\n+    \n+    /**\n+     * Increments the counter of already read bytes.\n+     * Doesn't increment if the EOF has been hit (read == -1)\n+     * \n+     * @param read the number of bytes read\n+     */\n+    protected void count(long read) {\n         if(read != -1) {\n             bytesRead = bytesRead + read;\n         }\n     }\n-    \n+\n+    /**\n+     * Returns the current number of bytes read from this stream.\n+     * @return the number of read bytes\n+     * @deprecated this method may yield wrong results for large\n+     * archives, use #getBytesRead instead\n+     */\n+    public int getCount() {\n+        return (int) bytesRead;\n+    }\n+\n     /**\n      * Returns the current number of bytes read from this stream.\n      * @return the number of read bytes\n      */\n-    public int getCount() {\n+    public long getBytesRead() {\n         return bytesRead;\n     }\n }", "timestamp": 1266509420, "metainfo": ""}