{"sha": "8954b8be675333bafc75f9c3ccbf1839bbff8c62", "log": "Refactor magic string.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n         if ((localFileHeader.arjFlags & LocalFileHeader.Flags.PATHSYM) != 0) {\n             return localFileHeader.name.replaceAll(\"/\",\n                     Matcher.quoteReplacement(File.separator));\n-        } else {\n-            return localFileHeader.name;\n         }\n+        return localFileHeader.name;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n         }\n         if (charsetName != null) {\n             return new String(buffer.toByteArray(), charsetName);\n-        } else {\n-            // intentionally using the default encoding as that's the contract for a null charsetName\n-            return new String(buffer.toByteArray());\n-        }\n+        }\n+        // intentionally using the default encoding as that's the contract for a null charsetName\n+        return new String(buffer.toByteArray());\n     }\n     \n     private void readFully(final DataInputStream dataIn, byte[] b)\n                         currentLocalFileHeader.originalSize, currentLocalFileHeader.originalCrc32);\n             }\n             return new ArjArchiveEntry(currentLocalFileHeader);\n-        } else {\n-            currentInputStream = null;\n-            return null;\n-        }\n+        }\n+        currentInputStream = null;\n+        return null;\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedRandomAccessFileInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedRandomAccessFileInputStream.java\n         if (bytesRemaining > 0) {\n             --bytesRemaining;\n             return file.read();\n-        } else {\n-            return -1;\n         }\n+        return -1;\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n     public Date getCreationDate() {\n         if (hasCreationDate) {\n             return ntfsTimeToJavaTime(creationDate);\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    \"The entry doesn't have this timestamp\");\n-        }\n+        }\n+        throw new UnsupportedOperationException(\n+                \"The entry doesn't have this timestamp\");\n     }\n     \n     /**\n     public Date getLastModifiedDate() {\n         if (hasLastModifiedDate) {\n             return ntfsTimeToJavaTime(lastModifiedDate);\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    \"The entry doesn't have this timestamp\");\n-        }\n+        }\n+        throw new UnsupportedOperationException(\n+                \"The entry doesn't have this timestamp\");\n     }\n     \n     /**\n     public Date getAccessDate() {\n         if (hasAccessDate) {\n             return ntfsTimeToJavaTime(accessDate);\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    \"The entry doesn't have this timestamp\");\n-        }\n+        }\n+        throw new UnsupportedOperationException(\n+                \"The entry doesn't have this timestamp\");\n     }\n     \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n         final int external = header.readUnsignedByte();\n         if (external != 0) {\n             throw new IOException(\"External unsupported\");\n-        } else {\n-            for (int i = 0; i < (int)numFolders; i++) {\n-                folders[i] = readFolder(header);\n-            }\n+        }\n+        for (int i = 0; i < (int)numFolders; i++) {\n+            folders[i] = readFolder(header);\n         }\n         \n         nid = header.readUnsignedByte();\n                     final int external = header.readUnsignedByte();\n                     if (external != 0) {\n                         throw new IOException(\"Not implemented\");\n-                    } else {\n-                        if (((size - 1) & 1) != 0) {\n-                            throw new IOException(\"File names length invalid\");\n+                    }\n+                    if (((size - 1) & 1) != 0) {\n+                        throw new IOException(\"File names length invalid\");\n+                    }\n+                    final byte[] names = new byte[(int)(size - 1)];\n+                    header.readFully(names);\n+                    int nextFile = 0;\n+                    int nextName = 0;\n+                    for (int i = 0; i < names.length; i += 2) {\n+                        if (names[i] == 0 && names[i+1] == 0) {\n+                            files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n+                            nextName = i + 2;\n                         }\n-                        final byte[] names = new byte[(int)(size - 1)];\n-                        header.readFully(names);\n-                        int nextFile = 0;\n-                        int nextName = 0;\n-                        for (int i = 0; i < names.length; i += 2) {\n-                            if (names[i] == 0 && names[i+1] == 0) {\n-                                files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\n-                                nextName = i + 2;\n-                            }\n-                        }\n-                        if (nextName != names.length || nextFile != files.length) {\n-                            throw new IOException(\"Error parsing file names\");\n-                        }\n+                    }\n+                    if (nextName != names.length || nextFile != files.length) {\n+                        throw new IOException(\"Error parsing file names\");\n                     }\n                     break;\n                 }\n                     final int external = header.readUnsignedByte();\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n-                    } else {\n-                        for (int i = 0; i < files.length; i++) {\n-                            files[i].setHasCreationDate(timesDefined.get(i));\n-                            if (files[i].getHasCreationDate()) {\n-                                files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n-                            }\n+                    }\n+                    for (int i = 0; i < files.length; i++) {\n+                        files[i].setHasCreationDate(timesDefined.get(i));\n+                        if (files[i].getHasCreationDate()) {\n+                            files[i].setCreationDate(Long.reverseBytes(header.readLong()));\n                         }\n                     }\n                     break;\n                     final int external = header.readUnsignedByte();\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n-                    } else {\n-                        for (int i = 0; i < files.length; i++) {\n-                            files[i].setHasAccessDate(timesDefined.get(i));\n-                            if (files[i].getHasAccessDate()) {\n-                                files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n-                            }\n+                    }\n+                    for (int i = 0; i < files.length; i++) {\n+                        files[i].setHasAccessDate(timesDefined.get(i));\n+                        if (files[i].getHasAccessDate()) {\n+                            files[i].setAccessDate(Long.reverseBytes(header.readLong()));\n                         }\n                     }\n                     break;\n                     final int external = header.readUnsignedByte();\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n-                    } else {\n-                        for (int i = 0; i < files.length; i++) {\n-                            files[i].setHasLastModifiedDate(timesDefined.get(i));\n-                            if (files[i].getHasLastModifiedDate()) {\n-                                files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n-                            }\n+                    }\n+                    for (int i = 0; i < files.length; i++) {\n+                        files[i].setHasLastModifiedDate(timesDefined.get(i));\n+                        if (files[i].getHasLastModifiedDate()) {\n+                            files[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n                         }\n                     }\n                     break;\n                     final int external = header.readUnsignedByte();\n                     if (external != 0) {\n                         throw new IOException(\"Unimplemented\");\n-                    } else {\n-                        for (int i = 0; i < files.length; i++) {\n-                            files[i].setHasWindowsAttributes(attributesDefined.get(i));\n-                            if (files[i].getHasWindowsAttributes()) {\n-                                files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n-                            }\n+                    }\n+                    for (int i = 0; i < files.length; i++) {\n+                        files[i].setHasWindowsAttributes(attributesDefined.get(i));\n+                        if (files[i].getHasWindowsAttributes()) {\n+                            files[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n                         }\n                     }\n                     break;\n         if (folder.hasCrc) {\n             return new CRC32VerifyingInputStream(inputStreamStack,\n                     folder.getUnpackSize(), folder.crc);\n-        } else {\n-            return inputStreamStack;\n-        }\n+        }\n+        return inputStreamStack;\n     }\n     \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n             int value = buffer[readIndex];\n             readIndex = (readIndex + 1) % size;\n             return value & 0xFF;\n-        } else {\n-            return -1;\n         }\n+        return -1;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n     public ByteBuffer encode(String name) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return ByteBuffer.wrap(name.getBytes());\n-        } else {\n-            return ByteBuffer.wrap(name.getBytes(this.charsetName));\n         }\n+        return ByteBuffer.wrap(name.getBytes(this.charsetName));\n     }\n \n     /**\n     public String decode(byte[] data) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return new String(data);\n-        } else {\n-            return new String(data,this.charsetName);\n         }\n+        return new String(data,this.charsetName);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n             return (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                     (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                     (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n-        } else {\n-            return false;\n-        }\n+        }\n+        return false;\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n                     (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                     (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                     (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n-        } else {\n-            return false;\n-        }\n+        }\n+        return false;\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n             long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n                 throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n-            } else {\n-                count(n);\n-                remaining -= n;\n-            }\n+            }\n+            count(n);\n+            remaining -= n;\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n                     in.close();\n                 }\n             }\n-        } else {\n-            return null;\n-        }\n+        }\n+        return null;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n     public static long adjustToLong(int i) {\n         if (i < 0) {\n             return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n-        } else {\n-            return i;\n-        }\n+        }\n+        return i;\n     }\n \n     /**\n     static long bigToLong(BigInteger big) {\n         if (big.bitLength() <= 63) { // bitLength() doesn't count the sign bit.\n             return big.longValue();\n-        } else {\n-            throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + big + \"]\");\n-        }\n+        }\n+        throw new NumberFormatException(\"The BigInteger cannot fit inside a 64 bit java long: [\" + big + \"]\");\n     }\n \n     /**\n     public static int signedByteToUnsignedInt(byte b) {\n         if (b >= 0) {\n             return b;\n-        } else {\n-            return 256 + b;\n-        }\n+        }\n+        return 256 + b;\n     }\n \n     /**\n         }\n         if (i < 128) {\n             return (byte) i;\n-        } else {\n-            return (byte) (i - 256);\n-        }\n+        }\n+        return (byte) (i - 256);\n     }\n \n     /**\n                 throw\n                     new UnsupportedZipFeatureException(UnsupportedZipFeatureException\n                                                        .Feature.METHOD, ze);\n-            } else {\n-                throw new UnsupportedZipFeatureException(m, ze);\n             }\n+            throw new UnsupportedZipFeatureException(m, ze);\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n                             it.remove();\n                             changes.add(pChange);\n                             return;\n-                        } else {\n-                            // do not add this change\n-                            return;\n                         }\n+                        // do not add this change\n+                        return;\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n             int r = read0();\n             count(r < 0 ? -1 : 1);\n             return r;\n-        } else {\n-            throw new IOException(\"stream closed\");\n-        }\n+        }\n+        throw new IOException(\"stream closed\");\n     }\n \n     /*\n             ) {\n             this.currentState = EOF;\n             throw new IOException(\"bad block header\");\n-        } else {\n-            this.storedBlockCRC = bsGetInt();\n-            this.blockRandomised = bsR(1) == 1;\n-\n-            /**\n-             * Allocate data here instead in constructor, so we do not allocate\n-             * it if the input file is empty.\n-             */\n-            if (this.data == null) {\n-                this.data = new Data(this.blockSize100k);\n-            }\n-\n-            // currBlockNo++;\n-            getAndMoveToFrontDecode();\n-\n-            this.crc.initialiseCRC();\n-            this.currentState = START_BLOCK_STATE;\n-        }\n+        }\n+        this.storedBlockCRC = bsGetInt();\n+        this.blockRandomised = bsR(1) == 1;\n+\n+        /**\n+         * Allocate data here instead in constructor, so we do not allocate\n+         * it if the input file is empty.\n+         */\n+        if (this.data == null) {\n+            this.data = new Data(this.blockSize100k);\n+        }\n+\n+        // currBlockNo++;\n+        getAndMoveToFrontDecode();\n+\n+        this.crc.initialiseCRC();\n+        this.currentState = START_BLOCK_STATE;\n     }\n \n     private void endBlock() throws IOException {\n                             bsBuffShadow = (bsBuffShadow << 8) | thech;\n                             bsLiveShadow += 8;\n                             continue;\n-                        } else {\n-                            throw new IOException(\"unexpected end of stream\");\n                         }\n+                        throw new IOException(\"unexpected end of stream\");\n                     }\n                     int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                         & ((1 << zn) - 1);\n                                 bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                 bsLiveShadow += 8;\n                                 continue;\n-                            } else {\n-                                throw new IOException(\n-                                                      \"unexpected end of stream\");\n                             }\n+                            throw new IOException(\n+                                                  \"unexpected end of stream\");\n                         }\n                         bsLiveShadow--;\n                         zvec = (zvec << 1)\n                         bsBuffShadow = (bsBuffShadow << 8) | thech;\n                         bsLiveShadow += 8;\n                         continue;\n-                    } else {\n-                        throw new IOException(\"unexpected end of stream\");\n                     }\n+                    throw new IOException(\"unexpected end of stream\");\n                 }\n                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                     & ((1 << zn) - 1);\n                             bsBuffShadow = (bsBuffShadow << 8) | thech;\n                             bsLiveShadow += 8;\n                             continue;\n-                        } else {\n-                            throw new IOException(\"unexpected end of stream\");\n                         }\n+                        throw new IOException(\"unexpected end of stream\");\n                     }\n                     bsLiveShadow--;\n                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                     bsBuffShadow = (bsBuffShadow << 8) | thech;\n                     bsLiveShadow += 8;\n                     continue;\n-                } else {\n-                    throw new IOException(\"unexpected end of stream\");\n-                }\n+                }\n+                throw new IOException(\"unexpected end of stream\");\n             }\n             bsLiveShadow--;\n             zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n             this.currentState = RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n             return su_ch2Shadow;\n-        } else {\n-            endBlock();\n-            initBlock();\n-            return setupBlock();\n-        }\n+        }\n+        endBlock();\n+        initBlock();\n+        return setupBlock();\n     }\n \n     private int setupNoRandPartA() throws IOException {\n             this.currentState = NO_RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n             return su_ch2Shadow;\n-        } else {\n-            this.currentState = NO_RAND_PART_A_STATE;\n-            endBlock();\n-            initBlock();\n-            return setupBlock();\n-        }\n+        }\n+        this.currentState = NO_RAND_PART_A_STATE;\n+        endBlock();\n+        initBlock();\n+        return setupBlock();\n     }\n \n     private int setupRandPartB() throws IOException {\n             this.crc.updateCRC(this.su_ch2);\n             this.su_j2++;\n             return this.su_ch2;\n-        } else {\n-            this.currentState = RAND_PART_A_STATE;\n-            this.su_i2++;\n-            this.su_count = 0;\n-            return setupRandPartA();\n-        }\n+        }\n+        this.currentState = RAND_PART_A_STATE;\n+        this.su_i2++;\n+        this.su_count = 0;\n+        return setupRandPartA();\n     }\n \n     private int setupNoRandPartB() throws IOException {\n             this.su_j2++;\n             this.currentState = NO_RAND_PART_C_STATE;\n             return su_ch2Shadow;\n-        } else {\n-            this.su_i2++;\n-            this.su_count = 0;\n-            return setupNoRandPartA();\n-        }\n+        }\n+        this.su_i2++;\n+        this.su_count = 0;\n+        return setupNoRandPartA();\n     }\n \n     private static final class Data {\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n                                                 }\n                                                 break HAMMER;\n                                             } // while x > 0\n-                                            else {\n-                                                if ((block[i1] & 0xff) > (block[i2] & 0xff)) {\n-                                                    continue HAMMER;\n-                                                } else {\n-                                                    break HAMMER;\n-                                                }\n+                                            if ((block[i1] & 0xff) > (block[i2] & 0xff)) {\n+                                                continue HAMMER;\n                                             }\n+                                            break HAMMER;\n                                         } else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {\n                                             continue HAMMER;\n                                         } else {\n--- a/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n         if (bytesRemaining > 0) {\n             --bytesRemaining;\n             return in.read();\n-        } else {\n-            return -1;\n         }\n+        return -1;\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n         // Can't really skip, we have to hash everything to verify the checksum\n         if (read() >= 0) {\n             return 1;\n-        } else {\n-            return 0;\n         }\n+        return 0;\n     }\n \n     @Override", "timestamp": 1460217591, "metainfo": ""}