{"sha": "a53ab172b2a9b7c1a57be9f8d6dc82977af02bff", "log": "Working version of deferred block decompression for skipped entries.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n import java.util.LinkedList;\n     private int currentEntryIndex = -1;\n     private int currentFolderIndex = -1;\n     private InputStream currentFolderInputStream = null;\n-    private InputStream currentEntryInputStream = null;\n     private byte[] password;\n-        \n+\n+    private ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n+\n     static final byte[] sevenZSignature = {\n         (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n     };\n     private void buildDecodingStream() throws IOException {\n         final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n         if (folderIndex < 0) {\n-            currentEntryInputStream = new BoundedInputStream(\n-                    new ByteArrayInputStream(new byte[0]), 0);\n+        \tdeferredBlockStreams.clear();\n+            // TODO: previously it'd return an empty stream?\n+        \t// new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\n             return;\n         }\n         final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n         if (currentFolderIndex == folderIndex) {\n+        \t// (COMPRESS-320).\n+        \t// The current entry is within the same (potentially opened) folder. The\n+        \t// previous stream has to be fully decoded before we can start reading\n+        \t// but don't do it eagerly -- if the user skips over the entire folder nothing\n+        \t// is effectively decompressed.\n+\n             // need to advance the folder input stream past the current file\n-            drainPreviousEntry();\n             file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n         } else {\n+        \t// We're opening a new folder. Discard any queued streams/ folder stream.\n             currentFolderIndex = folderIndex;\n+        \tdeferredBlockStreams.clear();\n             if (currentFolderInputStream != null) {\n                 currentFolderInputStream.close();\n                 currentFolderInputStream = null;\n                     archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n             currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n         }\n-        final InputStream fileStream = new BoundedInputStream(\n-                currentFolderInputStream, file.getSize());\n+\n+        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n         if (file.getHasCrc()) {\n-            currentEntryInputStream = new CRC32VerifyingInputStream(\n-                    fileStream, file.getSize(), file.getCrcValue());\n-        } else {\n-            currentEntryInputStream = fileStream;\n-        }\n-        \n-    }\n-    \n-    private void drainPreviousEntry() throws IOException {\n-        if (currentEntryInputStream != null) {\n-            // return value ignored as IOUtils.skip ensures the stream is drained completely\n-            IOUtils.skip(currentEntryInputStream, Long.MAX_VALUE);\n-            currentEntryInputStream.close();\n-            currentEntryInputStream = null;\n-        }\n-    }\n-    \n+            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n+        }\n+        \n+        deferredBlockStreams.add(fileStream);\n+    }\n+\n     private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n                 final int firstPackStreamIndex, SevenZArchiveEntry entry) throws IOException {\n         file.seek(folderOffset);\n      *             if an I/O error has occurred\n      */\n     public int read() throws IOException {\n-        if (currentEntryInputStream == null) {\n-            throw new IllegalStateException(\"No current 7z entry\");\n-        }\n-        return currentEntryInputStream.read();\n-    }\n-    \n-    /**\n+    \treturn getCurrentStream().read();\n+    }\n+    \n+    private InputStream getCurrentStream() throws IOException {\n+        if (deferredBlockStreams.isEmpty()) {\n+            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n+        }\n+        \n+        while (deferredBlockStreams.size() > 1) {\n+        \t// In solid compression mode we need to decompress all leading folder' \n+        \t// streams to get access to an entry. We defer this until really needed\n+        \t// so that entire blocks can be skipped without wasting time for decompression.\n+        \tInputStream stream = deferredBlockStreams.remove(0);\n+        \tIOUtils.skip(stream, Long.MAX_VALUE);\n+        \tstream.close();\n+        }\n+\n+\t\treturn deferredBlockStreams.get(0);\n+\t}\n+\n+\t/**\n      * Reads data into an array of bytes.\n      * \n      * @param b the array to write data to\n      *             if an I/O error has occurred\n      */\n     public int read(byte[] b) throws IOException {\n-        return read(b, 0, b.length);\n+    \treturn read(b, 0, b.length);\n     }\n     \n     /**\n      *             if an I/O error has occurred\n      */\n     public int read(byte[] b, int off, int len) throws IOException {\n-        if (currentEntryInputStream == null) {\n-            throw new IllegalStateException(\"No current 7z entry\");\n-        }\n-        return currentEntryInputStream.read(b, off, len);\n+        return getCurrentStream().read(b, off, len);\n     }\n     \n     private static long readUint64(final DataInput in) throws IOException {", "timestamp": 1456324939, "metainfo": ""}