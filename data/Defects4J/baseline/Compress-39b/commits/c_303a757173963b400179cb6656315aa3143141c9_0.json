{"sha": "303a757173963b400179cb6656315aa3143141c9", "log": "re-shuffle som code  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/AES256SHA256Decoder.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.GeneralSecurityException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+class AES256SHA256Decoder extends CoderBase {\n+    @Override\n+    InputStream decode(final InputStream in, final Coder coder, final byte[] passwordBytes) throws IOException {\n+        return new InputStream() {\n+            private boolean isInitialized = false;\n+            private CipherInputStream cipherInputStream = null;\n+                \n+            private CipherInputStream init() throws IOException {\n+                if (isInitialized) {\n+                    return cipherInputStream;\n+                }\n+                final int byte0 = 0xff & coder.properties[0];\n+                final int numCyclesPower = byte0 & 0x3f;\n+                final int byte1 = 0xff & coder.properties[1];\n+                final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n+                final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n+                if (2 + saltSize + ivSize > coder.properties.length) {\n+                    throw new IOException(\"Salt size + IV size too long\");\n+                }\n+                final byte[] salt = new byte[saltSize];\n+                System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n+                final byte[] iv = new byte[16];\n+                System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n+\n+                if (passwordBytes == null) {\n+                    throw new IOException(\"Cannot read encrypted files without a password\");\n+                }\n+                final byte[] aesKeyBytes;\n+                if (numCyclesPower == 0x3f) {\n+                    aesKeyBytes = new byte[32];\n+                    System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n+                    System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n+                                     Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n+                } else {\n+                    final MessageDigest digest;\n+                    try {\n+                        digest = MessageDigest.getInstance(\"SHA-256\");\n+                    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n+                        IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n+                        ioe.initCause(noSuchAlgorithmException);\n+                        throw ioe;\n+                        // TODO: simplify when Compress requires Java 1.6                \n+//                      throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n+//                              noSuchAlgorithmException);\n+                    }\n+                    final byte[] extra = new byte[8];\n+                    for (long j = 0; j < (1L << numCyclesPower); j++) {\n+                        digest.update(salt);\n+                        digest.update(passwordBytes);\n+                        digest.update(extra);\n+                        for (int k = 0; k < extra.length; k++) {\n+                            ++extra[k];\n+                            if (extra[k] != 0) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    aesKeyBytes = digest.digest();\n+                }\n+\n+                final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n+                try {\n+                    final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+                    cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n+                    cipherInputStream = new CipherInputStream(in, cipher);\n+                    isInitialized = true;\n+                    return cipherInputStream;\n+                } catch (GeneralSecurityException generalSecurityException) {\n+                    IOException ioe = new IOException(\"Decryption error \" +\n+                                                      \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n+                    ioe.initCause(generalSecurityException);\n+                    throw ioe;\n+                    // TODO: simplify when Compress requires Java 1.6                \n+//                  throw new IOException(\"Decryption error \" +\n+//                          \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n+//                          generalSecurityException);\n+                    }\n+            }\n+                \n+            @Override\n+            public int read() throws IOException {\n+                return init().read();\n+            }\n+                \n+            @Override\n+            public int read(byte[] b, int off, int len) throws IOException {\n+                return init().read(b, off, len);\n+            }\n+                \n+            @Override\n+            public void close() {\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/CoderBase.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.sevenz;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Base Codec class.\n+ */\n+abstract class CoderBase {\n+    private final Class<?>[] acceptableOptions;\n+    private static final byte[] NONE = new byte[0];\n+\n+    /**\n+     * @param acceptableOptions types that can be used as options for this codec.\n+     */\n+    protected CoderBase(Class<?>... acceptableOptions) {\n+        this.acceptableOptions = acceptableOptions;\n+    }\n+\n+    /**\n+     * @return whether this method can extract options from the given object.\n+     */\n+    boolean canAcceptOptions(Object opts) {\n+        for (Class<?> c : acceptableOptions) {\n+            if (c.isInstance(opts)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @return property-bytes to write in a Folder block\n+     */\n+    byte[] getOptionsAsProperties(Object options) {\n+        return NONE;\n+    }\n+\n+    /**\n+     * @return a stream that reads from in using the configured coder and password.\n+     */\n+    abstract InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException;\n+\n+    /**\n+     * @return a stream that writes to out using the given configuration.\n+     */\n+    OutputStream encode(final OutputStream out, final Object options) throws IOException {\n+        throw new UnsupportedOperationException(\"method doesn't support writing\");\n+    }\n+\n+    /**\n+     * If the option represents a number, return its integer\n+     * value, otherwise return the given default value.\n+     */\n+    protected static int numberOptionOrDefault(Object options, int defaultValue) {\n+        return options instanceof Number ? ((Number) options).intValue() : defaultValue;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.security.GeneralSecurityException;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.zip.Deflater;\n import java.util.zip.DeflaterOutputStream;\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.CipherInputStream;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.IvParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n \n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\n import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\n import org.tukaani.xz.LZMAInputStream;\n \n class Coders {\n+    private static final Map<SevenZMethod, CoderBase> CODER_MAP = new HashMap<SevenZMethod, CoderBase>() {{\n+            put(SevenZMethod.COPY, new CopyDecoder());\n+            put(SevenZMethod.LZMA, new LZMADecoder());\n+            put(SevenZMethod.LZMA2, new LZMA2Decoder());\n+            put(SevenZMethod.DEFLATE, new DeflateDecoder());\n+            put(SevenZMethod.BZIP2, new BZIP2Decoder());\n+            put(SevenZMethod.AES256SHA256, new AES256SHA256Decoder());\n+        }};\n+\n     static CoderBase findByMethod(SevenZMethod method) {\n-        for (final CoderId coderId : coderTable) {\n-            if (coderId.method.equals(method)) {\n-                return coderId.coder;\n-            }\n-        }\n-        return null;\n+        return CODER_MAP.get(method);\n     }\n \n     static InputStream addDecoder(final InputStream is,\n         return cb.encode(out, options);\n     }\n \n-    static CoderId[] coderTable = new CoderId[] {\n-        new CoderId(SevenZMethod.COPY, new CopyDecoder()),\n-        new CoderId(SevenZMethod.LZMA, new LZMADecoder()),\n-        new CoderId(SevenZMethod.LZMA2, new LZMA2Decoder()),\n-        new CoderId(SevenZMethod.DEFLATE, new DeflateDecoder()),\n-        new CoderId(SevenZMethod.BZIP2, new BZIP2Decoder()),\n-        new CoderId(SevenZMethod.AES256SHA256, new AES256SHA256Decoder())\n-    };\n-    \n-    static class CoderId {\n-        CoderId(SevenZMethod method, final CoderBase coder) {\n-            this.method = method;\n-            this.coder = coder;\n-        }\n-\n-        final SevenZMethod method;\n-        final CoderBase coder;\n-    }\n-    \n-    static abstract class CoderBase {\n-        private final Class<?>[] acceptableOptions;\n-        private static final byte[] NONE = new byte[0];\n-\n-        protected CoderBase(Class<?>... acceptableOptions) {\n-            this.acceptableOptions = acceptableOptions;\n-        }\n-\n-        /**\n-         * @return whether this method can extract options from the given object.\n-         */\n-        boolean canAcceptOptions(Object opts) {\n-            for (Class<?> c : acceptableOptions) {\n-                if (c.isInstance(opts)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        /**\n-         * @return property-bytes to write in a Folder block\n-         */\n-        byte[] getOptionsAsProperties(Object options) {\n-            return NONE;\n-        }\n-\n-        abstract InputStream decode(final InputStream in, final Coder coder,\n-                byte[] password) throws IOException;\n-        OutputStream encode(final OutputStream out, final Object options)\n-            throws IOException {\n-            throw new UnsupportedOperationException(\"method doesn't support writing\");\n-        }\n-\n-        /**\n-         * If the option represents a number, return its integer\n-         * value, otherwise return the given default value.\n-         */\n-        protected int numberOptionOrDefault(Object options, int defaultValue) {\n-            return options instanceof Number ? ((Number) options).intValue() : defaultValue;\n-        }\n-    }\n-    \n     static class CopyDecoder extends CoderBase {\n         @Override\n         InputStream decode(final InputStream in, final Coder coder,\n         }\n     }\n \n-    static class AES256SHA256Decoder extends CoderBase {\n-        @Override\n-        InputStream decode(final InputStream in, final Coder coder,\n-                final byte[] passwordBytes) throws IOException {\n-            return new InputStream() {\n-                private boolean isInitialized = false;\n-                private CipherInputStream cipherInputStream = null;\n-                \n-                private CipherInputStream init() throws IOException {\n-                    if (isInitialized) {\n-                        return cipherInputStream;\n-                    }\n-                    final int byte0 = 0xff & coder.properties[0];\n-                    final int numCyclesPower = byte0 & 0x3f;\n-                    final int byte1 = 0xff & coder.properties[1];\n-                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n-                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n-                    if (2 + saltSize + ivSize > coder.properties.length) {\n-                        throw new IOException(\"Salt size + IV size too long\");\n-                    }\n-                    final byte[] salt = new byte[saltSize];\n-                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n-                    final byte[] iv = new byte[16];\n-                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n-                    \n-                    if (passwordBytes == null) {\n-                        throw new IOException(\"Cannot read encrypted files without a password\");\n-                    }\n-                    final byte[] aesKeyBytes;\n-                    if (numCyclesPower == 0x3f) {\n-                        aesKeyBytes = new byte[32];\n-                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n-                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n-                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n-                    } else {\n-                        final MessageDigest digest;\n-                        try {\n-                            digest = MessageDigest.getInstance(\"SHA-256\");\n-                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n-                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n-                            ioe.initCause(noSuchAlgorithmException);\n-                            throw ioe;\n-        // TODO: simplify when Compress requires Java 1.6                \n-//                            throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n-//                                    noSuchAlgorithmException);\n-                        }\n-                        final byte[] extra = new byte[8];\n-                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n-                            digest.update(salt);\n-                            digest.update(passwordBytes);\n-                            digest.update(extra);\n-                            for (int k = 0; k < extra.length; k++) {\n-                                ++extra[k];\n-                                if (extra[k] != 0) {\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        aesKeyBytes = digest.digest();\n-                    }\n-                    \n-                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n-                    try {\n-                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n-                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n-                        cipherInputStream = new CipherInputStream(in, cipher);\n-                        isInitialized = true;\n-                        return cipherInputStream;\n-                    } catch (GeneralSecurityException generalSecurityException) {\n-                        IOException ioe = new IOException(\"Decryption error \" +\n-                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n-                        ioe.initCause(generalSecurityException);\n-                        throw ioe;\n-        // TODO: simplify when Compress requires Java 1.6                \n-//                        throw new IOException(\"Decryption error \" +\n-//                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n-//                                generalSecurityException);\n-                    }\n-                }\n-                \n-                @Override\n-                public int read() throws IOException {\n-                    return init().read();\n-                }\n-                \n-                @Override\n-                public int read(byte[] b, int off, int len) throws IOException {\n-                    return init().read(b, off, len);\n-                }\n-                \n-                @Override\n-                public void close() {\n-                }\n-            };\n-        }\n-    }\n-\n     /**\n      * ZLIB requires an extra dummy byte.\n      *\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n import org.tukaani.xz.LZMA2InputStream;\n import org.tukaani.xz.LZMA2Options;\n \n-class LZMA2Decoder extends Coders.CoderBase {\n+class LZMA2Decoder extends CoderBase {\n     LZMA2Decoder() {\n         super(LZMA2Options.class, Number.class);\n     }", "timestamp": 1393444821, "metainfo": ""}