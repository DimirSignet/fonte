{"sha": "7d99a02fc8bed02f6071a928f3828d2c76f8d1e4", "log": "Fixed last findbug issue, which was real  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.zip.Deflater;\n     private final List<ScatterZipOutputStream> streams = synchronizedList(new ArrayList<ScatterZipOutputStream>());\n     private final ExecutorService es;\n     private final ScatterGatherBackingStoreSupplier supplier;\n+    private final List<Future> futures = new ArrayList<Future>();\n \n     private final long startedAt = System.currentTimeMillis();\n     private long compressionDoneAt = 0;\n             throw new IllegalArgumentException(\"Method must be set on the supplied zipArchiveEntry\");\n         }\n         // Consider if we want to constrain the number of items that can enqueue here.\n-        es.submit(new Callable<ScatterZipOutputStream>() {\n-            public ScatterZipOutputStream call() throws Exception {\n+        Future<Object> future = es.submit(new Callable<Object>() {\n+            public Void call() throws Exception {\n                 ScatterZipOutputStream streamToUse = tlScatterStreams.get();\n                 InputStream payload = source.get();\n                 try {\n                 } finally {\n                     payload.close();\n                 }\n-                return streamToUse;\n+                return null;\n             }\n \n         });\n+        futures.add( future);\n     }\n \n \n      * @param targetStream The ZipArchiveOutputStream to receive the contents of the scatter streams\n      * @throws IOException          If writing fails\n      * @throws InterruptedException If we get interrupted\n+     * @throws ExecutionException   If something happens in the parallel execution\n      */\n-    public void writeTo(ZipArchiveOutputStream targetStream) throws IOException, InterruptedException {\n+    public void writeTo(ZipArchiveOutputStream targetStream)\n+            throws IOException, InterruptedException, ExecutionException {\n+\n+        // Make sure we catch any exceptions from parallel phase\n+        for (Future future : futures) {\n+            future.get();\n+        }\n+\n         es.shutdown();\n         es.awaitTermination(1000 * 60, TimeUnit.SECONDS);\n ", "timestamp": 1421082129, "metainfo": ""}