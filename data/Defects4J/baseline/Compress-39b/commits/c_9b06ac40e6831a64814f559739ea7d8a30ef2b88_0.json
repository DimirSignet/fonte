{"sha": "9b06ac40e6831a64814f559739ea7d8a30ef2b88", "log": "Javadoc review fixes  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n import static org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest.createZipArchiveEntryRequest;\n \n /**\n- * Creates a zip in parallel by using multiple threadlocal #ScatterZipOutputStream instances.\n+ * Creates a zip in parallel by using multiple threadlocal {@link ScatterZipOutputStream} instances.\n  * <p>\n  * Note that this class generally makes no guarantees about the order of things written to\n  * the output file. Things that need to come in a specific order (manifests, directories)\n  * must be handled by the client of this class, usually by writing these things to the\n- * #ZipArchiveOutputStream *before* calling #writeTo on this class.</p>\n+ * {@link ZipArchiveOutputStream} <em>before</em> calling {@link #writeTo writeTo} on this class.</p>\n  * <p>\n- * The client can supply an ExecutorService, but for reasons of memory model consistency,\n- * this will be shut down by this class prior to completion.\n+ * The client can supply an {@link java.util.concurrent.ExecutorService}, but for reasons of\n+ * memory model consistency, this will be shut down by this class prior to completion.\n  * </p>\n  * @since 1.10\n  */\n \n     /**\n      * Create a ParallelScatterZipCreator with default threads, which is set to the number of available\n-     * processors, as defined by java.lang.Runtime#availableProcessors()\n+     * processors, as defined by {@link java.lang.Runtime#availableProcessors}\n      */\n     public ParallelScatterZipCreator() {\n         this(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));\n     /**\n      * Submit a callable for compression.\n      *\n-     * @see #createCallable for details of if/when to use this.\n-     *\n-     * @param callable The callable to run, created by #createCallable, possibly wrapped by caller.\n+     * @see ParallelScatterZipCreator#createCallable for details of if/when to use this.\n+     *\n+     * @param callable The callable to run, created by {@link #createCallable createCallable}, possibly wrapped by caller.\n      */\n     public final void submit(Callable<Object> callable) {\n         futures.add(es.submit(callable));\n \n     /**\n      * Create a callable that will compress the given archive entry.\n-     *\n+     * <p/>\n      * <p>This method is expected to be called from a single client thread.</p>\n-     * <p>\n-     * Consider using #addArchiveEntry, which wraps this method and #submit. The most common use case\n-     * for using #createCallable and #submit from a client is if you want to wrap the callable in something\n-     * that can be prioritized by the supplied #ExecutorService, for instance to process large or slow files first.\n-     * Since the creation of the #ExecutorService is handled by the client, all of this is up to the client.\n+     * <p/>\n+     * Consider using {@link #addArchiveEntry addArchiveEntry}, which wraps this method and {@link #submit submit}.\n+     * The most common use case for using {@link #createCallable createCallable} and {@link #submit submit} from a\n+     * client is if you want to wrap the callable in something that can be prioritized by the supplied\n+     * {@link ExecutorService}, for instance to process large or slow files first.\n+     * Since the creation of the {@link ExecutorService} is handled by the client, all of this is up to the client.\n      *\n      * @param zipArchiveEntry The entry to add.\n-     * @param source    The source input stream supplier\n-     * @return   A callable that should subsequently passed to #submit, possibly in a wrapped/adapted from. The\n-     *          value of this callable is not used, but any exceptions happening inside the compression\n-     *          will be propagated through the callable.\n+     * @param source          The source input stream supplier\n+     * @return A callable that should subsequently passed to #submit, possibly in a wrapped/adapted from. The\n+     * value of this callable is not used, but any exceptions happening inside the compression\n+     * will be propagated through the callable.\n      */\n \n     public final Callable<Object> createCallable(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier source) {\n \n \n     /**\n-     * Write the contents this to the target #ZipArchiveOutputStream.\n+     * Write the contents this to the target {@link ZipArchiveOutputStream}.\n      * <p>\n      * It may be beneficial to write things like directories and manifest files to the targetStream\n      * before calling this method.\n      * </p>\n      *\n-     * @param targetStream The ZipArchiveOutputStream to receive the contents of the scatter streams\n+     * @param targetStream The {@link ZipArchiveOutputStream} to receive the contents of the scatter streams\n      * @throws IOException          If writing fails\n      * @throws InterruptedException If we get interrupted\n      * @throws ExecutionException   If something happens in the parallel execution\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n  * implementation only supports file-based backing.\n  * </p>\n  * Thread safety: This class supports multiple threads. But the \"writeTo\" method must be called\n- * by the thread that originally created the ZipArchiveEntry.\n+ * by the thread that originally created the {@link ZipArchiveEntry}.\n  *\n  * @since 1.10\n  */\n         }\n \n         /**\n-         * Update the original ZipArchiveEntry witg sizes/crc\n+         * Update the original {@link ZipArchiveEntry} with sizes/crc\n          * Do not use this methods from threads that did not create the instance itself !\n-         * @return the zipeArchiveEntry that is basis for this request\n+         * @return the zipArchiveEntry that is basis for this request\n          */\n \n         public ZipArchiveEntry transferToArchiveEntry(){\n     /**\n      * Write the contents of this scatter stream to a target archive.\n      *\n-     * @param target The archive to receive the contents of this #ScatterZipOutputStream\n+     * @param target The archive to receive the contents of this {@link ScatterZipOutputStream}.\n      * @throws IOException If writing fails\n      */\n     public void writeTo(ZipArchiveOutputStream target) throws IOException {\n     }\n \n     /**\n-     * Create a ScatterZipOutputStream with default compression level that is backed by a file\n+     * Create a {@link ScatterZipOutputStream} with default compression level that is backed by a file\n      *\n      * @param file The file to offload compressed data into.\n-     * @return A  ScatterZipOutputStream that is ready for use.\n+     * @return A ScatterZipOutputStream that is ready for use.\n      * @throws FileNotFoundException\n      */\n     public static ScatterZipOutputStream fileBased(File file) throws FileNotFoundException {\n     }\n \n     /**\n-     * Create a ScatterZipOutputStream that is backed by a file\n+     * Create a {@link ScatterZipOutputStream} that is backed by a file\n      *\n      * @param file             The file to offload compressed data into.\n      * @param compressionLevel The compression level to use, @see #Deflater\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n import java.util.zip.Deflater;\n \n /**\n- * Encapsulates a Deflater and crc calculator, handling multiple types of output streams.\n- * Currently #ZipEntry.DEFLATED and #ZipEntry.STORED are the only supported compression methods.\n+ * Encapsulates a {@link Deflater} and crc calculator, handling multiple types of output streams.\n+ * Currently {@link java.util.zip.ZipEntry#DEFLATED} and {@link java.util.zip.ZipEntry#STORED} are the only\n+ * supported compression methods.\n  *\n  * @since 1.10\n  */\n     /**\n      * Create a stream compressor with the given compression level.\n      *\n-     * @param os       The #OutputStream stream to receive output\n+     * @param os       The stream to receive output\n      * @param deflater The deflater to use\n      * @return A stream compressor\n      */\n     /**\n      * Create a stream compressor with the default compression level.\n      *\n-     * @param os The #OutputStream stream to receive output\n+     * @param os The stream to receive output\n      * @return A stream compressor\n      */\n     static StreamCompressor create(OutputStream os) {\n     /**\n      * Create a stream compressor with the given compression level.\n      *\n-     * @param os       The #DataOutput to receive output\n+     * @param os       The DataOutput to receive output\n      * @param deflater The deflater to use for the compressor\n      * @return A stream compressor\n      */\n     /**\n      * Create a stream compressor with the given compression level.\n      *\n-     * @param compressionLevel The #Deflater compression level\n-     * @param bs               The #ScatterGatherBackingStore to receive output\n+     * @param compressionLevel The {@link Deflater}  compression level\n+     * @param bs               The ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n     public static StreamCompressor create(int compressionLevel, ScatterGatherBackingStore bs) {\n     /**\n      * Create a stream compressor with the default compression level.\n      *\n-     * @param bs The #ScatterGatherBackingStore to receive output\n+     * @param bs The ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n     public static StreamCompressor create(ScatterGatherBackingStore bs) {\n--- a/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStore.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStore.java\n /**\n  * <p>Store intermediate payload in a scatter-gather scenario.\n  * Multiple threads write their payload to a backing store, which can\n- * subsequently be reversed to an #InputStream to be used as input in the\n+ * subsequently be reversed to an {@link InputStream} to be used as input in the\n  * gather phase.</p>\n  *\n  * <p>It is the responsibility of the allocator of an instance of this class\n--- a/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStoreSupplier.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/ScatterGatherBackingStoreSupplier.java\n import java.io.IOException;\n \n /**\n- * Supplies ScatterGatherBackingStore instances.\n+ * Supplies {@link ScatterGatherBackingStore} instances.\n  *\n  * @since 1.10\n  */", "timestamp": 1422175657, "metainfo": ""}