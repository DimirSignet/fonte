{"sha": "1418705648202405208e3f4d900dfcc81457cbac", "log": "Cut overall object instantiation in half by changing file header generation algorithm, for a 10-15 percent performance improvement when archive contains lots of small files.  Also extracted two private methods createLocalFileHeader and createCentralFileHeader in ZipArchiveOutputStream.  These may have some interesting additional usages in the near future.  This is basically a \"tactical refactoring\"; scatter/gather had a wonderful performance in the \"scatter\" algorithm, but spent an *equal* amount of time in the \"gather\" phase  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n      * Encodes the set bits in a form suitable for ZIP archives.\n      */\n     public byte[] encode() {\n-        return \n-            ZipShort.getBytes((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n-                              |\n-                              (languageEncodingFlag ? UFT8_NAMES_FLAG : 0)\n-                              |\n-                              (encryptionFlag ? ENCRYPTION_FLAG : 0)\n-                              |\n-                              (strongEncryptionFlag ? STRONG_ENCRYPTION_FLAG : 0)\n-                              );\n+        byte[] result = new byte[2];\n+        encode(result, 0);\n+        return result;\n+    }\n+\n+\n+    /**\n+     * Encodes the set bits in a form suitable for ZIP archives.\n+     *\n+     * @param buf the output buffer\n+     * @param  offset\n+     *         The offset within the output buffer of the first byte to be written.\n+     *         must be non-negative and no larger than <tt>buf.length-2</tt>\n+     */\n+    public void encode(byte[] buf, int offset) {\n+                ZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n+                        |\n+                        (languageEncodingFlag ? UFT8_NAMES_FLAG : 0)\n+                        |\n+                        (encryptionFlag ? ENCRYPTION_FLAG : 0)\n+                        |\n+                        (strongEncryptionFlag ? STRONG_ENCRYPTION_FLAG : 0)\n+                        , buf, offset);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import java.io.OutputStream;\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n-import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC_SHORT;\n import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MIN_VERSION;\n+import static org.apache.commons.compress.archivers.zip.ZipLong.putLong;\n+import static org.apache.commons.compress.archivers.zip.ZipShort.putShort;\n \n /**\n  * Reimplementation of {@link java.util.zip.ZipOutputStream\n public class ZipArchiveOutputStream extends ArchiveOutputStream {\n \n     static final int BUFFER_SIZE = 512;\n+    private static final int LFH_SIG_OFFSET = 0;\n+    private static final int LFH_VERSION_NEEDED_OFFSET = 4;\n+    private static final int LFH_GPB_OFFSET = 6;\n+    private static final int LFH_METHOD_OFFSET = 8;\n+    private static final int LFH_TIME_OFFSET = 10;\n+    private static final int LFH_CRC_OFFSET = 14;\n+    private static final int LFH_COMPRESSED_SIZE_OFFSET = 18;\n+    private static final int LFH_ORIGINAL_SIZE_OFFSET = 22;\n+    private static final int LFH_FILENAME_LENGTH_OFFSET = 26;\n+    private static final int LFH_EXTRA_LENGTH_OFFSET = 28;\n+    private static final int LFH_FILENAME_OFFSET = 30;\n+    private static final int CFH_SIG_OFFSET = 0;\n+    private static final int CFH_VERSION_MADE_BY_OFFSET = 4;\n+    private static final int CFH_VERSION_NEEDED_OFFSET = 6;\n+    private static final int CFH_GPB_OFFSET = 8;\n+    private static final int CFH_METHOD_OFFSET = 10;\n+    private static final int CFH_TIME_OFFSET = 12;\n+    private static final int CFH_CRC_OFFSET = 16;\n+    private static final int CFH_COMPRESSED_SIZE_OFFSET = 20;\n+    private static final int CFH_ORIGINAL_SIZE_OFFSET = 24;\n+    private static final int CFH_FILENAME_LENGTH_OFFSET = 28;\n+    private static final int CFH_EXTRA_LENGTH_OFFSET = 30;\n+    private static final int CFH_COMMENT_LENGTH_OFFSET = 32;\n+    private static final int CFH_DISK_NUMBER_OFFSET = 34;\n+    private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36;\n+    private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38;\n+    private static final int CFH_LFH_OFFSET = 42;\n+    private static final int CFH_FILENAME_OFFSET = 46;\n \n     /** indicates if this archive is finished. protected for use in Jar implementation */\n     protected boolean finished = false;\n             def.setLevel(level);\n             hasCompressionLevelChanged = false;\n         }\n-        writeLocalFileHeader(entry.entry);\n+        writeLocalFileHeader((ZipArchiveEntry)archiveEntry);\n     }\n \n     /**\n      * @throws IOException on error\n      */\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n-\n         boolean encodable = zipEncoding.canEncode(ze.getName());\n         ByteBuffer name = getName(ze);\n \n             addUnicodeExtraFields(ze, encodable, name);\n         }\n \n-        offsets.put(ze, Long.valueOf(written));\n-\n-        writeOut(LFH_SIG);\n-        written += WORD;\n+        final byte[] localHeader = createLocalFileHeader(ze, name, encodable);\n+        offsets.put(ze, written);\n+        entry.localDataStart = written + 14; // Right before crc\n+        writeOut( localHeader);\n+        written += localHeader.length;\n+        entry.dataStart = written;\n+    }\n+\n+\n+    private byte[] createLocalFileHeader(ZipArchiveEntry ze, ByteBuffer name, boolean encodable)  {\n+\n+        byte[] extra = ze.getLocalFileDataExtra();\n+        int len= LFH_FILENAME_OFFSET + name.limit() + extra.length;\n+        byte[] buf = new byte[len];\n+\n+        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n \n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n \n-        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n-                                                         !encodable\n-                                                         && fallbackToUTF8,\n-                                                         hasZip64Extra(ze));\n-        written += WORD;\n+        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n+\n+        GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod,\n+                !encodable\n+                        && fallbackToUTF8\n+        );\n+        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n \n         // compression method\n-        writeOut(ZipShort.getBytes(zipMethod));\n-        written += SHORT;\n-\n-        // last mod. time and date\n-        writeOut(ZipUtil.toDosTime(ze.getTime()));\n-        written += WORD;\n+        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+\n+        ZipUtil.toDosTime(ze.getTime(), buf, LFH_TIME_OFFSET);\n \n         // CRC\n         // compressed length\n         // uncompressed length\n-        entry.localDataStart = written;\n         if (zipMethod == DEFLATED || raf != null) {\n-            writeOut(LZERO);\n+            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n             if (hasZip64Extra(entry.entry)) {\n                 // point to ZIP64 extended information extra field for\n                 // sizes, may get rewritten once sizes are known if\n                 // stream is seekable\n-                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-                writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n+                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n             } else {\n-                writeOut(LZERO);\n-                writeOut(LZERO);\n+                System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n+                System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n             }\n         } else {\n-            writeOut(ZipLong.getBytes(ze.getCrc()));\n-            byte[] size = ZipLong.ZIP64_MAGIC.getBytes();\n+            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n             if (!hasZip64Extra(ze)) {\n-                size = ZipLong.getBytes(ze.getSize());\n+                putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+                putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+            } else {\n+                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n             }\n-            writeOut(size);\n-            writeOut(size);\n-        }\n-        // CheckStyle:MagicNumber OFF\n-        written += 12;\n-        // CheckStyle:MagicNumber ON\n-\n+        }\n         // file name length\n-        writeOut(ZipShort.getBytes(name.limit()));\n-        written += SHORT;\n+        putShort(name.limit(), buf, LFH_FILENAME_LENGTH_OFFSET);\n \n         // extra field length\n-        byte[] extra = ze.getLocalFileDataExtra();\n-        writeOut(ZipShort.getBytes(extra.length));\n-        written += SHORT;\n+        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n \n         // file name\n-        writeOut(name.array(), name.arrayOffset(),\n-                 name.limit() - name.position());\n-        written += name.limit();\n-\n-        // extra field\n-        writeOut(extra);\n-        written += extra.length;\n-\n-        entry.dataStart = written;\n-    }\n+        final int nameLen = name.limit() - name.position();\n+        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n+\n+        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n+        return buf;\n+    }\n+\n \n     /**\n      * Adds UnicodeExtra fields for name and file comment if mode is\n      * Zip64Mode#Never}.\n      */\n     protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n-        writeOut(CFH_SIG);\n-        written += WORD;\n \n         final long lfhOffset = offsets.get(ze).longValue();\n         final boolean needsZip64Extra = hasZip64Extra(ze)\n                                              .ARCHIVE_TOO_BIG_MESSAGE);\n         }\n \n+\n         handleZip64Extra(ze, lfhOffset, needsZip64Extra);\n \n-        // version made by\n-        // CheckStyle:MagicNumber OFF\n-        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | \n-                                   (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION\n-                                                  : ZIP64_MIN_VERSION)));\n-        written += SHORT;\n-\n-        final int zipMethod = ze.getMethod();\n-        final boolean encodable = zipEncoding.canEncode(ze.getName());\n-        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n-                                                         !encodable\n-                                                         && fallbackToUTF8,\n-                                                         needsZip64Extra);\n-        written += WORD;\n-\n-        // compression method\n-        writeOut(ZipShort.getBytes(zipMethod));\n-        written += SHORT;\n-\n-        // last mod. time and date\n-        writeOut(ZipUtil.toDosTime(ze.getTime()));\n-        written += WORD;\n-\n-        // CRC\n-        // compressed length\n-        // uncompressed length\n-        writeOut(ZipLong.getBytes(ze.getCrc()));\n-        if (ze.getCompressedSize() >= ZIP64_MAGIC\n-            || ze.getSize() >= ZIP64_MAGIC) {\n-            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n-        } else {\n-            writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n-            writeOut(ZipLong.getBytes(ze.getSize()));\n-        }\n-        // CheckStyle:MagicNumber OFF\n-        written += 12;\n-        // CheckStyle:MagicNumber ON\n-\n-        ByteBuffer name = getName(ze);\n-\n-        writeOut(ZipShort.getBytes(name.limit()));\n-        written += SHORT;\n-\n-        // extra field length\n+        byte[] centralFileHeader = createCentralFileHeader(ze, getName(ze), lfhOffset);\n+        writeOut(centralFileHeader);\n+        written += centralFileHeader.length;\n+    }\n+    /**\n+     * Writes the central file header entry.\n+     * @param ze the entry to write\n+     * @param name The encoded name\n+     * @param lfhOffset Local file header offset for this file\n+     * @throws IOException on error\n+     * @throws Zip64RequiredException if the archive's size exceeds 4\n+     * GByte and {@link Zip64Mode #setUseZip64} is {@link\n+     * Zip64Mode#Never}.\n+     */\n+    private byte[] createCentralFileHeader(ZipArchiveEntry ze, ByteBuffer name, long lfhOffset) throws IOException {\n         byte[] extra = ze.getCentralDirectoryExtra();\n-        writeOut(ZipShort.getBytes(extra.length));\n-        written += SHORT;\n \n         // file comment length\n         String comm = ze.getComment();\n         }\n \n         ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n-\n-        writeOut(ZipShort.getBytes(commentB.limit()));\n-        written += SHORT;\n+        int len= CFH_FILENAME_OFFSET + name.limit() + extra.length + commentB.limit();\n+        byte[] buf = new byte[len];\n+\n+        System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n+\n+        final boolean needsZip64Extra = hasZip64Extra(ze)\n+                || ze.getCompressedSize() >= ZIP64_MAGIC\n+                || ze.getSize() >= ZIP64_MAGIC\n+                || lfhOffset >= ZIP64_MAGIC;\n+\n+        if (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\n+            // must be the offset that is too big, otherwise an\n+            // exception would have been throw in putArchiveEntry or\n+            // closeArchiveEntry\n+            throw new Zip64RequiredException(Zip64RequiredException\n+                    .ARCHIVE_TOO_BIG_MESSAGE);\n+        }\n+\n+        // todo: Do in caller !  handleZip64Extra(ze, lfhOffset, needsZip64Extra);\n+\n+        // version made by\n+        // CheckStyle:MagicNumber OFF\n+        putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\n+                buf, CFH_VERSION_MADE_BY_OFFSET);\n+\n+        final int zipMethod = ze.getMethod();\n+        final boolean encodable = zipEncoding.canEncode(ze.getName());\n+        putShort(versionNeededToExtract(zipMethod, needsZip64Extra), buf, CFH_VERSION_NEEDED_OFFSET);\n+        getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8).encode(buf, CFH_GPB_OFFSET);\n+\n+        // compression method\n+        putShort(zipMethod, buf, CFH_METHOD_OFFSET);\n+\n+\n+        // last mod. time and date\n+        ZipUtil.toDosTime(ze.getTime(), buf, CFH_TIME_OFFSET);\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        putLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\n+        if (ze.getCompressedSize() >= ZIP64_MAGIC\n+                || ze.getSize() >= ZIP64_MAGIC) {\n+            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET);\n+            ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET);\n+        } else {\n+            putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\n+            putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\n+        }\n+\n+        putShort(name.limit(), buf, CFH_FILENAME_LENGTH_OFFSET);\n+\n+        // extra field length\n+        putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\n+\n+        putShort(commentB.limit(), buf, CFH_COMMENT_LENGTH_OFFSET);\n \n         // disk number start\n-        writeOut(ZERO);\n-        written += SHORT;\n+        System.arraycopy(ZERO,  0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\n \n         // internal file attributes\n-        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n-        written += SHORT;\n+        putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\n \n         // external file attributes\n-        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n-        written += WORD;\n+        putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\n \n         // relative offset of LFH\n-        writeOut(ZipLong.getBytes(Math.min(lfhOffset, ZIP64_MAGIC)));\n-        written += WORD;\n+        putLong(Math.min(lfhOffset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\n \n         // file name\n-        writeOut(name.array(), name.arrayOffset(),\n-                 name.limit() - name.position());\n-        written += name.limit();\n-\n-        // extra field\n-        writeOut(extra);\n-        written += extra.length;\n+        System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, name.limit() - name.position());\n+\n+        int extraStart = CFH_FILENAME_OFFSET + name.limit();\n+        System.arraycopy(extra, 0, buf, extraStart, extra.length);\n+\n+        int commentLength = commentB.limit() - commentB.position();\n+        int commentStart = extraStart + commentLength;\n \n         // file comment\n-        writeOut(commentB.array(), commentB.arrayOffset(),\n-                 commentB.limit() - commentB.position());\n-        written += commentB.limit();\n+        System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLength);\n+        return buf;\n     }\n \n     /**\n         }\n     }\n \n-    private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n-                                                                  zipMethod,\n-                                                                  final boolean\n-                                                                  utfFallback,\n-                                                                  final boolean\n-                                                                  zip64)\n-        throws IOException {\n-\n-        // CheckStyle:MagicNumber OFF\n-        int versionNeededToExtract = INITIAL_VERSION;\n+    private GeneralPurposeBit getGeneralPurposeBits(final int zipMethod, final boolean utfFallback) {\n         GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useUTF8ForNames(useUTF8Flag || utfFallback);\n-        if (zipMethod == DEFLATED && raf == null) {\n-            // requires version 2 as we are going to store length info\n-            // in the data descriptor\n-            versionNeededToExtract = DATA_DESCRIPTOR_MIN_VERSION;\n+        if (isDeflatedToOutputStream(zipMethod)) {\n             b.useDataDescriptor(true);\n         }\n+        return b;\n+    }\n+\n+    private int versionNeededToExtract(final int zipMethod, final boolean zip64) {\n         if (zip64) {\n-            versionNeededToExtract = ZIP64_MIN_VERSION;\n-        }\n-        // CheckStyle:MagicNumber ON\n-\n-        // version needed to extract\n-        writeOut(ZipShort.getBytes(versionNeededToExtract));\n-        // general purpose bit flag\n-        writeOut(b.encode());\n-    }\n+            return ZIP64_MIN_VERSION;\n+        }\n+        // requires version 2 as we are going to store length info\n+        // in the data descriptor\n+        return (isDeflatedToOutputStream(zipMethod)) ?\n+                DATA_DESCRIPTOR_MIN_VERSION :\n+                INITIAL_VERSION;\n+    }\n+\n+    private boolean isDeflatedToOutputStream(int zipMethod) {\n+        return zipMethod == DEFLATED && raf == null;\n+    }\n+\n \n     /**\n      * Creates a new zip entry taking some information from the given\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n      */\n     public static byte[] getBytes(long value) {\n         byte[] result = new byte[WORD];\n-        result[0] = (byte) ((value & BYTE_MASK));\n-        result[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n-        result[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\n-        result[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n+        putLong(value, result, 0);\n         return result;\n+    }\n+\n+    /**\n+     * put the value as four bytes in big endian byte order.\n+     * @param value the Java long to convert to bytes\n+     * @param buf the output buffer\n+     * @param  offset\n+     *         The offset within the output buffer of the first byte to be written.\n+     *         must be non-negative and no larger than <tt>buf.length-4</tt>\n+     */\n+\n+    public static void putLong(long value, byte[] buf, int offset) {\n+        buf[offset++] = (byte) ((value & BYTE_MASK));\n+        buf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        buf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\n+        buf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n+    }\n+\n+    public void putLong(byte[] buf, int offset) {\n+        putLong(value, buf, offset);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n      */\n     public static byte[] getBytes(int value) {\n         byte[] result = new byte[2];\n-        result[0] = (byte) (value & BYTE_MASK);\n-        result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n+        putShort(value, result, 0);\n         return result;\n+    }\n+\n+    /**\n+     * put the value as two bytes in big endian byte order.\n+     * @param value the Java int to convert to bytes\n+     * @param buf the output buffer\n+     * @param  offset\n+     *         The offset within the output buffer of the first byte to be written.\n+     *         must be non-negative and no larger than <tt>buf.length-2</tt>\n+     */\n+    public static void putShort(int value, byte[] buf, int offset) {\n+        buf[offset] = (byte) (value & BYTE_MASK);\n+        buf[offset+1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n      * @return the date as a byte array\n      */\n     public static byte[] toDosTime(long t) {\n+        byte[] result = new byte[4];\n+        toDosTime(t, result, 0);\n+        return result;\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     *\n+     * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n+     * @param t number of milliseconds since the epoch\n+     * @param buf the output buffer\n+     * @param offset\n+     *         The offset within the output buffer of the first byte to be written.\n+     *         must be non-negative and no larger than <tt>buf.length-4</tt>\n+     */\n+    public static void toDosTime(long t, byte[] buf, int offset) {\n         Calendar c = Calendar.getInstance();\n         c.setTimeInMillis(t);\n \n         int year = c.get(Calendar.YEAR);\n         if (year < 1980) {\n-            return copy(DOS_TIME_MIN); // stop callers from changing the array\n+            System.arraycopy(DOS_TIME_MIN, 0, buf, offset, DOS_TIME_MIN.length);// stop callers from changing the array\n+            return;\n         }\n         int month = c.get(Calendar.MONTH) + 1;\n         long value =  ((year - 1980) << 25)\n-            |         (month << 21)\n-            |         (c.get(Calendar.DAY_OF_MONTH) << 16)\n-            |         (c.get(Calendar.HOUR_OF_DAY) << 11)\n-            |         (c.get(Calendar.MINUTE) << 5)\n-            |         (c.get(Calendar.SECOND) >> 1);\n-        return ZipLong.getBytes(value);\n+                |         (month << 21)\n+                |         (c.get(Calendar.DAY_OF_MONTH) << 16)\n+                |         (c.get(Calendar.HOUR_OF_DAY) << 11)\n+                |         (c.get(Calendar.MINUTE) << 5)\n+                |         (c.get(Calendar.SECOND) >> 1);\n+        ZipLong.putLong(value, buf, offset);\n     }\n \n     /**\n         }\n         return null;\n     }\n+    static void copy(byte[] from, byte[] to, int offset) {\n+        if (from != null) {\n+            System.arraycopy(from, 0, to, offset, from.length);\n+        }\n+    }\n+\n \n     /**\n      * Whether this library is able to read or write the given entry.\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipLongTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipLongTest.java\n     }\n \n     /**\n+     * Test conversion to bytes.\n+     */\n+    public void testPut() {\n+        byte[] arr = new byte[5];\n+        ZipLong.putLong(0x12345678, arr, 1);\n+        assertEquals(\"first byte getBytes\", 0x78, arr[1]);\n+        assertEquals(\"second byte getBytes\", 0x56, arr[2]);\n+        assertEquals(\"third byte getBytes\", 0x34, arr[3]);\n+        assertEquals(\"fourth byte getBytes\", 0x12, arr[4]);\n+    }\n+\n+    /**\n      * Test conversion from bytes.\n      */\n     public void testFromBytes() {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipShortTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipShortTest.java\n         assertEquals(\"first byte getBytes\", 0x34, result[0]);\n         assertEquals(\"second byte getBytes\", 0x12, result[1]);\n     }\n+\n+\n+    /**\n+     * Test conversion to bytes.\n+     */\n+    public void testPut() {\n+        byte[] arr = new byte[3];\n+        ZipShort.putShort(0x1234, arr, 1);\n+        assertEquals(\"first byte getBytes\", 0x34, arr[1]);\n+        assertEquals(\"second byte getBytes\", 0x12, arr[2]);\n+    }\n+\n \n     /**\n      * Test conversion from bytes.\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n         assertEquals(b10,b2[0]); // first byte should still be the same\n     }\n \n+    public void testOutsideCalendar(){\n+        byte[] b1 = ZipUtil.toDosTime(160441200000L); // 1.1..1975\n+        assertEquals(0, b1[0]);\n+        assertEquals(33, b1[1]);\n+        assertEquals(0, b1[2]);\n+        assertEquals(0, b1[3]);\n+    }\n+\n+    public void testInsideCalendar(){\n+        byte[] b1 = ZipUtil.toDosTime(476096400000L); // 1.1.1985, 10:00 am\n+        assertEquals(0, b1[0]);\n+        assertEquals(80, b1[1]);\n+        assertEquals(65, b1[2]);\n+        assertEquals(10, b1[3]);\n+    }\n+\n     public void testReverse() {\n         byte[][] bTest = new byte[6][];\n         bTest[0] = new byte[]{};", "timestamp": 1419429644, "metainfo": ""}