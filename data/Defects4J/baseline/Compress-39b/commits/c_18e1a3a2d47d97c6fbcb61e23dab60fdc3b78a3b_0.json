{"sha": "18e1a3a2d47d97c6fbcb61e23dab60fdc3b78a3b", "log": "It seems WinZip uses 'version needed to extract' from the central directory entry to parse the local file header ignoring the 'version' stored in the LFH.  Make sure the two values agree, which they did not in 'Always' mode.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n      * any entry has initially been unknown and create an archive\n      * identical to {@link Zip64Mode#Never Never} otherwise.  {@link\n      * Zip64Mode#Always Always} will create an archive that is at\n-     * least 20 bytes per entry bigger than the one {@link\n+     * least 24 bytes per entry bigger than the one {@link\n      * Zip64Mode#Never Never} would create.</p>\n      *\n      * <p>Defaults to {@link Zip64Mode#AsNeeded AsNeeded} unless\n         written += WORD;\n \n         final long lfhOffset = offsets.get(ze).longValue();\n-        final boolean needsZip64Extra = ze.getCompressedSize() >= ZIP64_MAGIC\n+        final boolean needsZip64Extra = hasZip64Extra(ze)\n+            || ze.getCompressedSize() >= ZIP64_MAGIC\n             || ze.getSize() >= ZIP64_MAGIC\n             || lfhOffset >= ZIP64_MAGIC;\n \n \n     /**\n      * If the entry needs Zip64 extra information inside the central\n-     * director then configure its data, otherwise remove it if one is\n-     * present.\n+     * directory then configure its data.\n      */\n     private void handleZip64Extra(ZipArchiveEntry ze, long lfhOffset,\n                                   boolean needsZip64Extra) {\n             if (lfhOffset >= ZIP64_MAGIC) {\n                 z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset));\n             }\n-            ze.setExtra();\n-        } else if (hasZip64Extra(ze)) {\n-            // added to LFH but not really needed, probably because of\n-            // Zip64Mode.Always\n-            ze.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n             ze.setExtra();\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n                     // skip first two entries\n                     a.skipBytes(2 * 47 /* CD entry of file with\n                                           file name length 1 and no\n-                                          extra data */);\n+                                          extra data */\n+                                + 2 * (mode == Zip64Mode.Always ? 4 : 0)\n+                                /* empty ZIP64 extra fields if mode is Always */\n+                                );\n \n                     // grab third entry, verify offset is\n                     // 0xFFFFFFFF and it has a ZIP64 extended\n                     final long end = getLengthAndPositionAtCentralDirectory(a);\n \n                     // grab first CF entry, verify sizes are 1e6 and it\n-                    // has no ZIP64 extended information extra field\n-                    // at all\n+                    // has an empty ZIP64 extended information extra field\n                     byte[] header = new byte[12];\n                     a.readFully(header);\n                     assertArrayEquals(new byte[] {\n                             // version made by\n                             45, 0,\n                             // version needed to extract\n-                            10, 0,\n+                            45, 0,\n                             // GPB (EFS bit)\n                             0, 8,\n                             // method\n                             // file name length\n                             1, 0,\n                             // extra field length\n-                            0, 0,\n+                            4, 0,\n                             // comment length\n                             0, 0,\n                             // disk number\n                             // file name\n                             (byte) '0'\n                         }, rest);\n+\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            0, 0,\n+                        }, extra);\n \n                     // and now validate local file header: this one\n                     // has a ZIP64 extra field as the mode was\n                             (byte) '0'\n                         }, rest);\n \n-                    byte[] extra = new byte[20];\n+                    extra = new byte[20];\n                     a.readFully(extra);\n                     assertArrayEquals(new byte[] {\n                             // Header-ID\n \n                     long cfhPos = a.getFilePointer();\n                     // grab first entry, verify sizes are not\n-                    // 0xFFFFFFF and it has no ZIP64 extended\n+                    // 0xFFFFFFF and it has an empty ZIP64 extended\n                     // information extra field\n                     byte[] header = new byte[12];\n                     a.readFully(header);\n                             // version made by\n                             45, 0,\n                             // version needed to extract\n-                            20, 0,\n+                            45, 0,\n                             // GPB (EFS + Data Descriptor)\n                             8, 8,\n                             // method\n                             // file name length\n                             1, 0,\n                             // extra field length\n-                            0, 0,\n+                            4, 0,\n                             // comment length\n                             0, 0,\n                             // disk number\n                             // file name\n                             (byte) '0'\n                         }, rest);\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            0, 0,\n+                        }, extra);\n \n                     // validate data descriptor\n                     a.seek(cfhPos - 24);\n                             (byte) '0'\n                         }, rest);\n \n-                    byte[] extra = new byte[20];\n+                    extra = new byte[20];\n                     a.readFully(extra);\n                     assertArrayEquals(new byte[] {\n                             // Header-ID\n \n                     long cfhPos = a.getFilePointer();\n                     // grab first CD entry, verify sizes are not\n-                    // 0xFFFFFFFF and it has a no ZIP64 extended\n+                    // 0xFFFFFFFF and it has a an empty ZIP64 extended\n                     // information extra field\n                     byte[] header = new byte[12];\n                     a.readFully(header);\n                             // version made by\n                             45, 0,\n                             // version needed to extract\n-                            10, 0,\n+                            45, 0,\n                             // GPB (EFS + *no* Data Descriptor)\n                             0, 8,\n                             // method\n                             // file name length\n                             1, 0,\n                             // extra field length\n-                            0, 0,\n+                            4, 0,\n                             // comment length\n                             0, 0,\n                             // disk number\n                             // file name\n                             (byte) '0'\n                         }, rest);\n+                    byte[] extra = new byte[4];\n+                    a.readFully(extra);\n+                    assertArrayEquals(new byte[] {\n+                            // Header-ID\n+                            1, 0,\n+                            // size of extra\n+                            0, 0,\n+                        }, extra);\n \n                     // and now validate local file header\n                     a.seek(0);\n                             (byte) '0'\n                         }, rest);\n \n-                    byte[] extra = new byte[12];\n+                    extra = new byte[12];\n                     a.readFully(extra);\n                     assertArrayEquals(new byte[] {\n                             // Header-ID", "timestamp": 1313207305, "metainfo": ""}