{"sha": "11349c5f52e0355a11ced6234ae424da73c9503b", "log": "Extract generic octal formatting method to simplify code and eliminate array copies Change leading padding to zeroes as that is more compatible (and required for Posix)  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      * Parsing stops when a NUL is found, or a trailing space,\n      * or the buffer length is reached.\n      *\n+     * Behaviour with non-octal input is currently undefined.\n+     * \n      * @param buffer The buffer from which to parse.\n      * @param offset The offset into the buffer from which to parse.\n      * @param length The maximum number of bytes to parse.\n     }\n \n     /**\n+     * Fill buffer with octal number, with leading zeroes\n+     * \n+     * @param value number to convert to octal (assumed >=0)\n+     * @param buffer destination buffer\n+     * @param offset starting offset in buffer\n+     * @param length length of buffer to fill\n+     */\n+    public static void formatUnsignedOctalString(long value, byte[] buffer,\n+            int offset, int length) {\n+        length--;\n+        if (value == 0) {\n+            buffer[offset + length--] = (byte) '0';\n+        } else {\n+            for (long val = value; length >= 0 && val > 0; --length) {\n+                // CheckStyle:MagicNumber OFF\n+                buffer[offset + length] = (byte) ((byte) '0' + (byte) (val & 7));\n+                val = val >> 3;\n+                // CheckStyle:MagicNumber ON\n+            }\n+        }\n+\n+        for (; length >= 0; --length) { // leading zeros\n+            buffer[offset + length] = (byte) '0';\n+        }\n+    }\n+\n+    /**\n      * Write an octal integer into a buffer.\n      *\n      * Adds a trailing space and NUL to end of the buffer.\n+     * [Appears to be standard for V7 Unix BSD]\n      * Converts the long value (assumed positive) to the buffer.\n      * Adds leading spaces to the buffer.\n+     * [V7 Unix and Posix use leading zeroes]\n      * \n      * @param value The value to write\n      * @param buf The buffer to receive the output\n      * @return The updated offset, i.e offset+length\n      */\n     public static int getOctalBytes(long value, byte[] buf, int offset, int length) {\n-        int    idx = length - 1;\n-\n-        buf[offset + idx] = 0; // Trailing null\n-        --idx;\n-        buf[offset + idx] = (byte) ' '; // Trailing space TODO - why??\n-        --idx;\n-\n-        if (value == 0) {\n-            buf[offset + idx] = (byte) '0';\n-            --idx;\n-        } else {\n-            for (long val = value; idx >= 0 && val > 0; --idx) {\n-                // CheckStyle:MagicNumber OFF\n-                buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));\n-                val = val >> 3;\n-                // CheckStyle:MagicNumber ON\n-            }\n-        }\n-\n-        for (; idx >= 0; --idx) { // leading spaces\n-            buf[offset + idx] = (byte) ' ';\n-        }\n+\n+        int idx=length-2; // For space and trailing null\n+        formatUnsignedOctalString(value, buf, offset, idx);\n+\n+        buf[offset + idx++] = (byte) ' '; // Trailing space\n+        buf[offset + idx]   = 0; // Trailing null\n \n         return offset + length;\n     }\n \n     /**\n      * Write an octal long integer into a buffer.\n-     *\n+     * The buffer is terminated with a space.\n+     * \n      * @param value The value to write as octal\n      * @param buf The destinationbuffer.\n      * @param offset The starting offset into the buffer.\n      * @return The updated offset\n      */\n     public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) {\n-        byte[] temp = new byte[length + 1];\n-\n-        getOctalBytes(value, temp, 0, length + 1);\n-        System.arraycopy(temp, 0, buf, offset, length);\n+\n+        int idx=length-1; // For space\n+        \n+        formatUnsignedOctalString(value, buf, offset, idx);\n+        buf[offset + idx] = (byte) ' '; // Trailing space\n \n         return offset + length;\n     }\n     /**\n      * Writes an octal value into a buffer.\n      *\n-     * TODO document fully. How does it differ from getOctalBytes?\n+     * Checksum is followed by NUL and then space.\n      *\n      * @param value The value to convert\n      * @param buf The destination buffer\n      * @return The updated value of offset, i.e. offset+length\n      */\n     public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) {\n-        getOctalBytes(value, buf, offset, length);\n-\n-        buf[offset + length - 1] = (byte) ' ';\n-        buf[offset + length - 2] = 0;\n+\n+        int idx=length-2; // for NUL and space\n+        formatUnsignedOctalString(value, buf, offset, idx);\n+\n+        buf[offset + idx++]   = 0; // Trailing null\n+        buf[offset + idx]     = (byte) ' '; // Trailing space\n \n         return offset + length;\n     }", "timestamp": 1238543360, "metainfo": ""}