{"sha": "7181d54ff1170865f066a41f7e2568be34f3a749", "log": "consume remainder of ZIP when last LF-entry has been read  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n       extra field length              2 bytes\n     */\n \n+    private static final int CFH_LEN = 46;\n+    /*\n+        central file header signature   4 bytes  (0x02014b50)\n+        version made by                 2 bytes\n+        version needed to extract       2 bytes\n+        general purpose bit flag        2 bytes\n+        compression method              2 bytes\n+        last mod file time              2 bytes\n+        last mod file date              2 bytes\n+        crc-32                          4 bytes\n+        compressed size                 4 bytes\n+        uncompressed size               4 bytes\n+        file name length                2 bytes\n+        extra field length              2 bytes\n+        file comment length             2 bytes\n+        disk number start               2 bytes\n+        internal file attributes        2 bytes\n+        external file attributes        4 bytes\n+        relative offset of local header 4 bytes\n+    */\n+\n     private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n \n     // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n     private final byte[] LFH_BUF = new byte[LFH_LEN];\n     private final byte[] SKIP_BUF = new byte[1024];\n+    private final byte[] SHORT_BUF = new byte[SHORT];\n     private final byte[] WORD_BUF = new byte[WORD];\n     private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n+\n+    private int entriesRead = 0;\n \n     public ZipArchiveInputStream(InputStream inputStream) {\n         this(inputStream, ZipEncodingHelper.UTF8);\n         }\n             \n         ZipLong sig = new ZipLong(LFH_BUF);\n-        if (sig.equals(ZipLong.CFH_SIG)) {\n+        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n             hitCentralDirectory = true;\n-            return null;\n+            skipRemainderOfArchive();\n         }\n         if (!sig.equals(ZipLong.LFH_SIG)) {\n             return null;\n         }\n \n         processZip64Extra(size, cSize);\n+        entriesRead++;\n         return current.entry;\n     }\n \n         pushedBackBytes(length);\n     }\n \n+    // End of Central Directory Record\n+    //   end of central dir signature    4 bytes  (0x06054b50)\n+    //   number of this disk             2 bytes\n+    //   number of the disk with the\n+    //   start of the central directory  2 bytes\n+    //   total number of entries in the\n+    //   central directory on this disk  2 bytes\n+    //   total number of entries in\n+    //   the central directory           2 bytes\n+    //   size of the central directory   4 bytes\n+    //   offset of start of central\n+    //   directory with respect to\n+    //   the starting disk number        4 bytes\n+    //   .ZIP file comment length        2 bytes\n+    //   .ZIP file comment       (variable size)\n+    //\n+\n+    /**\n+     * Reads the stream until it find the \"End of central directory\n+     * record\" and consumes it as well.\n+     */\n+    private void skipRemainderOfArchive() throws IOException {\n+        // skip over central directory. One LFH has been read too much\n+        // already.  The calculation discounts file names and extra\n+        // data so it will be too short.\n+        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n+        findEocdRecord();\n+        realSkip(ZipFile.MIN_EOCD_SIZE\n+                 - WORD /* signature */ - SHORT /* comment len */);\n+        readFully(SHORT_BUF);\n+        // file comment\n+        realSkip(ZipShort.getValue(SHORT_BUF));\n+    }\n+\n+    /**\n+     * Reads forward until the signature of the &quot;End of central\n+     * directory&quot; recod is found.\n+     */\n+    private void findEocdRecord() throws IOException {\n+        int currentByte = -1;\n+        boolean skipReadCall = false;\n+        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n+            skipReadCall = false;\n+            if (!isFirstByteOfEocdSig(currentByte)) {\n+                continue;\n+            }\n+            currentByte = readOneByte();\n+            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n+                if (currentByte == -1) {\n+                    break;\n+                }\n+                skipReadCall = isFirstByteOfEocdSig(currentByte);\n+                continue;\n+            }\n+            currentByte = readOneByte();\n+            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n+                if (currentByte == -1) {\n+                    break;\n+                }\n+                skipReadCall = isFirstByteOfEocdSig(currentByte);\n+                continue;\n+            }\n+            currentByte = readOneByte();\n+            if (currentByte == -1\n+                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n+                break;\n+            }\n+            skipReadCall = isFirstByteOfEocdSig(currentByte);\n+        }\n+    }\n+\n+    /**\n+     * Skips bytes by reading from the underlying stream rather than\n+     * the (potentially inflating) archive stream - which {@link\n+     * #skip} would do.\n+     *\n+     * Also updates bytes-read counter.\n+     */\n+    private void realSkip(long value) throws IOException {\n+        if (value >= 0) {\n+            long skipped = 0;\n+            while (skipped < value) {\n+                long rem = value - skipped;\n+                int x = in.read(SKIP_BUF, 0,\n+                                (int) (SKIP_BUF.length > rem ? rem\n+                                       : SKIP_BUF.length));\n+                if (x == -1) {\n+                    return;\n+                }\n+                count(x);\n+                skipped += x;\n+            }\n+            return;\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+\n+    /**\n+     * Reads bytes by reading from the underlying stream rather than\n+     * the (potentially inflating) archive stream - which {@link\n+     * #read} would do.\n+     *\n+     * Also updates bytes-read counter.\n+     */\n+    private int readOneByte() throws IOException {\n+        int b = in.read();\n+        if (b != -1) {\n+            count(1);\n+        }\n+        return b;\n+    }\n+\n+    private boolean isFirstByteOfEocdSig(int b) {\n+        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n+    }\n+\n     /**\n      * Structure collecting information for the entry that is\n      * currently being read.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * supposed to be the last structure of the archive - without file\n      * comment.\n      */\n-    private static final int MIN_EOCD_SIZE =\n+    static final int MIN_EOCD_SIZE =\n         /* end of central dir signature    */ WORD\n         /* number of this disk             */ + SHORT\n         /* number of the disk with the     */\n      * finds the &quot;Zip64 end of central directory record&quot; using the\n      * parsed information, parses that and positions the stream at the\n      * first central directory record.\n+     *\n+     * Expects stream to be positioned right behind the &quot;Zip64\n+     * end of central directory locator&quot;'s signature.\n      */\n     private void positionAtCentralDirectory64()\n         throws IOException {\n     }\n \n     /**\n-     * Searches for the &quot;End of central dir record&quot;, parses\n-     * it and positions the stream at the first central directory\n-     * record.\n+     * Parses the &quot;End of central dir record&quot; and positions\n+     * the stream at the first central directory record.\n+     *\n+     * Expects stream to be positioned at the beginning of the\n+     * &quot;End of central dir record&quot;.\n      */\n     private void positionAtCentralDirectory32()\n         throws IOException {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n         new ZipLong(0X30304B50L);\n \n     /**\n+     * Archive extra data record signature.</p>\n+     * @since 1.5\n+     */\n+    public static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n+\n+    /**\n      * Create instance from a number.\n      * @param value the long to store as a ZipLong\n      */\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n             try {\n                 assertNull(zip.getNextZipEntry());\n             } catch (IOException e) {\n+                e.printStackTrace();\n                 fail(\"COMPRESS-93: Unable to skip an unsupported zip entry\");\n             }\n         } finally {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n import java.io.BufferedInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n+import java.io.InputStream;\n import java.net.URI;\n import java.net.URL;\n \n         }\n     }\n \n+    @Test\n+    public void shouldConsumeArchiveCompletely() throws Exception {\n+        InputStream is = ZipArchiveInputStreamTest.class\n+            .getResourceAsStream(\"/archive_with_trailer.zip\");\n+        ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n+        while (zip.getNextZipEntry() != null) {\n+            // just consume the archive\n+            ;\n+        }\n+        byte[] expected = new byte[] {\n+            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n+        };\n+        byte[] actual = new byte[expected.length];\n+        is.read(actual);\n+        assertArrayEquals(expected, actual);\n+    }\n }", "timestamp": 1358858724, "metainfo": ""}