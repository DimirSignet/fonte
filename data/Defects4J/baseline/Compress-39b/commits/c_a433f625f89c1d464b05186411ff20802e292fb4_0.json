{"sha": "a433f625f89c1d464b05186411ff20802e292fb4", "log": "Added headers to recognize PKWARE crypto headers.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Base class for all PKWare strong crypto extra headers.\n+ * \n+ * <b>Algorithm IDs</b> - integer identifier of the encryption algorithm from\n+ * the following range\n+ * \n+ * <ul>\n+ * <li>0x6601 - DES</li>\n+ * <li>0x6602 - RC2 (version needed to extract < 5.2)</li>\n+ * <li>0x6603 - 3DES 168</li>\n+ * <li>0x6609 - 3DES 112</li>\n+ * <li>0x660E - AES 128</li>\n+ * <li>0x660F - AES 192</li>\n+ * <li>0x6610 - AES 256</li>\n+ * <li>0x6702 - RC2 (version needed to extract >= 5.2)</li>\n+ * <li>0x6720 - Blowfish</li>\n+ * <li>0x6721 - Twofish</li>\n+ * <li>0x6801 - RC4</li>\n+ * <li>0xFFFF - Unknown algorithm</li>\n+ * </ul>\n+ * \n+ * <b>Hash Algorithms</b> - integer identifier of the hash algorithm from the\n+ * following range\n+ * \n+ * <ul>\n+ * <li>0x0000 - none</li>\n+ * <li>0x0001 - CRC32</li>\n+ * <li>0x8003 - MD5</li>\n+ * <li>0x8004 - SHA1</li>\n+ * <li>0x8007 - RIPEMD160</li>\n+ * <li>0x800C - SHA256</li>\n+ * <li>0x800D - SHA384</li>\n+ * <li>0x800E - SHA512</li>\n+ * </ul>\n+ *\n+ * TODO: define enums for crypto and hash algorithms.\n+ */\n+public abstract class PKWareExtraHeader implements ZipExtraField {\n+\n+    /**\n+     * Encryption algorithm.\n+     */\n+    public enum EncryptionAlgorithm {\n+        DES(0x6601),\n+        RC2pre52(0x6602),\n+        TripleDES168(0x6603),\n+        TripleDES192(0x6609),\n+        AES128(0x660E),\n+        AES192(0x660F),\n+        AES256(0x6610),\n+        RC2(0x6702),\n+        RC4(0x6801),\n+        UNKNOWN(0xFFFF);\n+\n+        private final int code;\n+\n+        private static final Map<Integer, EncryptionAlgorithm> codeToEnum;\n+\n+        static {\n+            Map<Integer, EncryptionAlgorithm> cte = new HashMap<Integer, EncryptionAlgorithm>();\n+            for (EncryptionAlgorithm method : values()) {\n+                cte.put(Integer.valueOf(method.getCode()), method);\n+            }\n+            codeToEnum = Collections.unmodifiableMap(cte);\n+        }\n+\n+        /**\n+         * private constructor for enum style class.\n+         */\n+        EncryptionAlgorithm(int code) {\n+            this.code = code;\n+        }\n+\n+        /**\n+         * the algorithm id.\n+         * \n+         * @return the PKWare AlgorithmId\n+         */\n+        public int getCode() {\n+            return code;\n+        }\n+\n+        /**\n+         * returns the EncryptionAlgorithm for the given code or null if the\n+         * method is not known.\n+         */\n+        public static EncryptionAlgorithm getAlgorithmByCode(int code) {\n+            return codeToEnum.get(Integer.valueOf(code));\n+        }\n+    }\n+\n+    /**\n+     * Hash Algorithm\n+     */\n+    public enum HashAlgorithm {\n+        NONE(0),\n+        CRC32(1),\n+        MD5(0x8003),\n+        SHA1(0x8004),\n+        RIPEND160(0x8007),\n+        SHA256(0x800C),\n+        SHA384(0x800D),\n+        SHA512(0x800E);\n+\n+        private final int code;\n+\n+        private static final Map<Integer, HashAlgorithm> codeToEnum;\n+\n+        static {\n+            Map<Integer, HashAlgorithm> cte = new HashMap<Integer, HashAlgorithm>();\n+            for (HashAlgorithm method : values()) {\n+                cte.put(Integer.valueOf(method.getCode()), method);\n+            }\n+            codeToEnum = Collections.unmodifiableMap(cte);\n+        }\n+\n+        /**\n+         * private constructor for enum style class.\n+         */\n+        HashAlgorithm(int code) {\n+            this.code = code;\n+        }\n+\n+        /**\n+         * the hash algorithm ID.\n+         * \n+         * @return the PKWare hashAlg\n+         */\n+        public int getCode() {\n+            return code;\n+        }\n+\n+        /**\n+         * returns the HashAlgorithm for the given code or null if the method is\n+         * not known.\n+         */\n+        public static HashAlgorithm getAlgorithmByCode(int code) {\n+            return codeToEnum.get(Integer.valueOf(code));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0014_X509Certificates.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * PKCS#7 Store for X.509 Certificates (0x0014):\n+ *\n+ * This field MUST contain information about each of the certificates files may\n+ * be signed with. When the Central Directory Encryption feature is enabled for\n+ * a ZIP file, this record will appear in the Archive Extra Data Record,\n+ * otherwise it will appear in the first central directory record and will be\n+ * ignored in any other record.\n+ *\n+ * Note: all fields stored in Intel low-byte/high-byte order.\n+ * \n+ * <pre>\n+ *         Value     Size     Description\n+ *         -----     ----     -----------\n+ * (Store) 0x0014    2 bytes  Tag for this \"extra\" block type\n+ *         TSize     2 bytes  Size of the store data\n+ *         TData     TSize    Data about the store\n+ * </pre>\n+ * \n+ * @NotThreadSafe\n+ */\n+public class X0014_X509Certificates extends PKWareExtraHeader implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0014);\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Get the header id.\n+     * \n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] localData;\n+\n+    /**\n+     * Set the extra field data in the local file data - without Header-ID or\n+     * length specifier.\n+     * \n+     * @param data\n+     *            the field data to use\n+     */\n+    public void setLocalFileDataData(byte[] data) {\n+        localData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the length of the local data.\n+     * \n+     * @return the length of the local data\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localData != null ? localData.length : 0);\n+    }\n+\n+    /**\n+     * Get the local data.\n+     * \n+     * @return the local data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localData);\n+    }\n+\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] centralData;\n+\n+    /**\n+     * Set the extra field data in central directory.\n+     * \n+     * @param data\n+     *            the data to use\n+     */\n+    public void setCentralDirectoryData(byte[] data) {\n+        centralData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the central data length. If there is no central data, get the local\n+     * file data length.\n+     * \n+     * @return the central data length\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        if (centralData != null) {\n+            return new ZipShort(centralData.length);\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the central data.\n+     * \n+     * @return the central data if present, else return the local file data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        if (centralData != null) {\n+            return ZipUtil.copy(centralData);\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setLocalFileDataData(tmp);\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+        if (localData == null) {\n+            setLocalFileDataData(tmp);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * X.509 Certificate ID and Signature for individual file (0x0015):\n+ *\n+ * This field contains the information about which certificate in the PKCS#7\n+ * store was used to sign a particular file. It also contains the signature\n+ * data. This field can appear multiple times, but can only appear once per\n+ * certificate.\n+ *\n+ * Note: all fields stored in Intel low-byte/high-byte order.\n+ *\n+ * <pre>\n+ *         Value     Size     Description\n+ *         -----     ----     -----------\n+ * (CID)   0x0015    2 bytes  Tag for this \"extra\" block type\n+ *         TSize     2 bytes  Size of data that follows\n+ *         RCount    4 bytes  Number of recipients. (inferred)\n+ *         HashAlg   2 bytes  Hash algorithm identifier. (inferred)\n+ *         TData     TSize    Signature Data\n+ * </pre>\n+ * \n+ * @NotThreadSafe\n+ */\n+public class X0015_CertificateIdForFile extends PKWareExtraHeader implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0015);\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Get the header id.\n+     * \n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] localData;\n+\n+    private int rcount;\n+    private HashAlgorithm hashAlg;\n+    \n+    /**\n+     * Get record count.\n+     * @return\n+     */\n+    public int getRecordCount() {\n+        return rcount;\n+    }\n+\n+    /**\n+     * Get hash algorithm.\n+     * @return\n+     */\n+    public HashAlgorithm getHashAlgorithm() {\n+        return hashAlg;\n+    }\n+\n+    /**\n+     * Set the extra field data in the local file data - without Header-ID or\n+     * length specifier.\n+     * \n+     * @param data\n+     *            the field data to use\n+     */\n+    public void setLocalFileDataData(byte[] data) {\n+        localData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the length of the local data.\n+     * \n+     * @return the length of the local data\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localData != null ? localData.length : 0);\n+    }\n+\n+    /**\n+     * Get the local data.\n+     * \n+     * @return the local data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localData);\n+    }\n+\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] centralData;\n+\n+    /**\n+     * Set the extra field data in central directory.\n+     * \n+     * @param data\n+     *            the data to use\n+     */\n+    public void setCentralDirectoryData(byte[] data) {\n+        centralData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the central data length. If there is no central data, get the local\n+     * file data length.\n+     * \n+     * @return the central data length\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        if (centralData != null) {\n+            return new ZipShort(centralData.length);\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the central data.\n+     * \n+     * @return the central data if present, else return the local file data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        if (centralData != null) {\n+            return ZipUtil.copy(centralData);\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setLocalFileDataData(tmp);\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+        if (localData == null) {\n+            setLocalFileDataData(tmp);\n+        }\n+\n+        this.rcount = ZipShort.getValue(data, offset);\n+        this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * X.509 Certificate ID and Signature for central directory (0x0016):\n+ *\n+ * This field contains the information about which certificate in the PKCS#7\n+ * store was used to sign the central directory structure. When the Central\n+ * Directory Encryption feature is enabled for a ZIP file, this record will\n+ * appear in the Archive Extra Data Record, otherwise it will appear in the\n+ * first central directory record.\n+ *\n+ * Note: all fields stored in Intel low-byte/high-byte order.\n+ *\n+ * <pre>\n+ *         Value     Size     Description\n+ *         -----     ----     -----------\n+ * (CDID)  0x0016    2 bytes  Tag for this \"extra\" block type\n+ *         TSize     2 bytes  Size of data that follows\n+ *         RCount    4 bytes  Number of recipients. (inferred)\n+ *         HashAlg   2 bytes  Hash algorithm identifier. (inferred)\n+ *         TData     TSize    Data\n+ * </pre>\n+ * \n+ * @NotThreadSafe\n+ */\n+public class X0016_CertificateIdForCentralDirectory extends PKWareExtraHeader implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0016);\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Get the header id.\n+     * \n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] localData;\n+\n+    private int rcount;\n+    private HashAlgorithm hashAlg;\n+\n+    /**\n+     * Get record count.\n+     * @return\n+     */\n+    public int getRecordCount() {\n+        return rcount;\n+    }\n+    \n+    /**\n+     * Get hash algorithm.\n+     * @return\n+     */\n+    public HashAlgorithm getHashAlgorithm() {\n+        return hashAlg;\n+    }\n+    \n+    /**\n+     * Set the extra field data in the local file data - without Header-ID or\n+     * length specifier.\n+     * \n+     * @param data\n+     *            the field data to use\n+     */\n+    public void setLocalFileDataData(byte[] data) {\n+        localData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the length of the local data.\n+     * \n+     * @return the length of the local data\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localData != null ? localData.length : 0);\n+    }\n+\n+    /**\n+     * Get the local data.\n+     * \n+     * @return the local data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localData);\n+    }\n+\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] centralData;\n+\n+    /**\n+     * Set the extra field data in central directory.\n+     * \n+     * @param data\n+     *            the data to use\n+     */\n+    public void setCentralDirectoryData(byte[] data) {\n+        centralData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the central data length. If there is no central data, get the local\n+     * file data length.\n+     * \n+     * @return the central data length\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        if (centralData != null) {\n+            return new ZipShort(centralData.length);\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the central data.\n+     * \n+     * @return the central data if present, else return the local file data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        if (centralData != null) {\n+            return ZipUtil.copy(centralData);\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * This should never be called for this header type.\n+     * \n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setLocalFileDataData(tmp);\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+\n+        this.rcount = ZipShort.getValue(data, offset);\n+        this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Strong Encryption Header (0x0017)\n+ *\n+ * Certificate-based encryption:\n+ *\n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * 0x0017    2 bytes  Tag for this \"extra\" block type\n+ * TSize     2 bytes  Size of data that follows\n+ * Format    2 bytes  Format definition for this record\n+ * AlgID     2 bytes  Encryption algorithm identifier\n+ * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n+ * Flags     2 bytes  Processing flags\n+ * RCount    4 bytes  Number of recipients. \n+ * HashAlg   2 bytes  Hash algorithm identifier\n+ * HSize     2 bytes  Hash size\n+ * SRList    (var)    Simple list of recipients hashed public keys\n+ * \n+ * Flags -   This defines the processing flags.\n+ * \n+ *           <ul>\n+ *           <li>0x0007 - reserved for future use\n+ *           <li>0x000F - reserved for future use\n+ *           <li>0x0100 - Indicates non-OAEP key wrapping was used.  If this\n+ *                        this field is set, the version needed to extract must\n+ *                        be at least 61.  This means OAEP key wrapping is not\n+ *                        used when generating a Master Session Key using\n+ *                        ErdData.\n+ *           <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the\n+ *                        same algorithm used for encrypting the file contents.\n+ *           <li>0x8000 - reserved for future use\n+ *           </ul>\n+ *        \n+ * RCount - This defines the number intended recipients whose\n+ *          public keys were used for encryption.  This identifies\n+ *          the number of elements in the SRList.\n+ *          \n+ *          see also: reserved1\n+ * \n+ * HashAlg - This defines the hash algorithm used to calculate\n+ *           the public key hash of each public key used\n+ *           for encryption. This field currently supports\n+ *           only the following value for SHA-1\n+ * \n+ *           0x8004 - SHA1\n+ * \n+ * HSize -   This defines the size of a hashed public key.\n+ * \n+ * SRList -  This is a variable length list of the hashed\n+ *           public keys for each intended recipient.  Each\n+ *           element in this list is HSize.  The total size of\n+ *           SRList is determined using RCount * HSize.\n+ * </pre>\n+ * \n+ * Password-based Extra Field 0x0017 in central header only.\n+ * \n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * 0x0017    2 bytes  Tag for this \"extra\" block type\n+ * TSize     2 bytes  Size of data that follows\n+ * Format    2 bytes  Format definition for this record\n+ * AlgID     2 bytes  Encryption algorithm identifier\n+ * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n+ * Flags     2 bytes  Processing flags\n+ * (more?)\n+ * </pre>\n+ *\n+ * <b>Format</b> - the data format identifier for this record. The only value\n+ * allowed at this time is the integer value 2.\n+ * \n+ * Password-based Extra Field 0x0017 preceding compressed file data.\n+ * \n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * 0x0017    2 bytes  Tag for this \"extra\" block type\n+ * IVSize    2 bytes  Size of initialization vector (IV)\n+ * IVData    IVSize   Initialization vector for this file\n+ * Size      4 bytes  Size of remaining decryption header data\n+ * Format    2 bytes  Format definition for this record\n+ * AlgID     2 bytes  Encryption algorithm identifier\n+ * Bitlen    2 bytes  Bit length of encryption key (32-448 bits)\n+ * Flags     2 bytes  Processing flags\n+ * ErdSize   2 bytes  Size of Encrypted Random Data\n+ * ErdData   ErdSize  Encrypted Random Data\n+ * Reserved1 4 bytes  Reserved certificate processing data\n+ * Reserved2 (var)    Reserved for certificate processing data\n+ * VSize     2 bytes  Size of password validation data\n+ * VData     VSize-4  Password validation data\n+ * VCRC32    4 bytes  Standard ZIP CRC32 of password validation data\n+ *     \n+ * IVData - The size of the IV should match the algorithm block size.\n+ *          The IVData can be completely random data.  If the size of\n+ *          the randomly generated data does not match the block size\n+ *          it should be complemented with zero's or truncated as\n+ *          necessary.  If IVSize is 0,then IV = CRC32 + Uncompressed\n+ *          File Size (as a 64 bit little-endian, unsigned integer value).\n+ * \n+ * Format -  the data format identifier for this record.  The only\n+ *           value allowed at this time is the integer value 2.\n+ * \n+ * ErdData - Encrypted random data is used to store random data that\n+ *           is used to generate a file session key for encrypting\n+ *           each file.  SHA1 is used to calculate hash data used to\n+ *           derive keys.  File session keys are derived from a master\n+ *           session key generated from the user-supplied password.\n+ *           If the Flags field in the decryption header contains\n+ *           the value 0x4000, then the ErdData field must be\n+ *           decrypted using 3DES. If the value 0x4000 is not set,\n+ *           then the ErdData field must be decrypted using AlgId.\n+ * \n+ * Reserved1 - Reserved for certificate processing, if value is\n+ *           zero, then Reserved2 data is absent.  See the explanation\n+ *           under the Certificate Processing Method for details on\n+ *           this data structure.\n+ * \n+ * Reserved2 - If present, the size of the Reserved2 data structure\n+ *           is located by skipping the first 4 bytes of this field\n+ *           and using the next 2 bytes as the remaining size.  See\n+ *           the explanation under the Certificate Processing Method\n+ *           for details on this data structure.\n+ * \n+ * VSize - This size value will always include the 4 bytes of the\n+ *         VCRC32 data and will be greater than 4 bytes.\n+ * \n+ * VData - Random data for password validation.  This data is VSize\n+ *         in length and VSize must be a multiple of the encryption\n+ *         block size.  VCRC32 is a checksum value of VData. \n+ *         VData and VCRC32 are stored encrypted and start the\n+ *         stream of encrypted data for a file.\n+ * </pre>\n+ * \n+ * \n+ * Reserved1 - Certificate Decryption Header Reserved1 Data:\n+ * \n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * RCount    4 bytes  Number of recipients.\n+ * </pre>\n+ * \n+ * RCount - This defines the number intended recipients whose public keys were\n+ * used for encryption. This defines the number of elements in the REList field\n+ * defined below.\n+ * \n+ * \n+ * Reserved2 - Certificate Decryption Header Reserved2 Data Structures:\n+ * \n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * HashAlg   2 bytes  Hash algorithm identifier\n+ * HSize     2 bytes  Hash size\n+ * REList    (var)    List of recipient data elements\n+ * \n+ * HashAlg - This defines the hash algorithm used to calculate\n+ *           the public key hash of each public key used\n+ *           for encryption. This field currently supports\n+ *           only the following value for SHA-1\n+ *    \n+ *               0x8004 - SHA1\n+ *                \n+ * HSize -   This defines the size of a hashed public key\n+ *           defined in REHData.\n+ * \n+ * REList -  This is a variable length of list of recipient data. \n+ *           Each element in this list consists of a Recipient\n+ *           Element data structure as follows:\n+ * </pre>\n+ * \n+ * Recipient Element (REList) Data Structure:\n+ *\n+ * <pre>\n+ * Value     Size     Description\n+ * -----     ----     -----------\n+ * RESize    2 bytes  Size of REHData + REKData\n+ * REHData   HSize    Hash of recipients public key\n+ * REKData   (var)    Simple key blob\n+ * \n+ * \n+ * RESize -  This defines the size of an individual REList\n+ *           element.  This value is the combined size of the\n+ *           REHData field + REKData field.  REHData is defined by\n+ *           HSize.  REKData is variable and can be calculated\n+ *           for each REList element using RESize and HSize.\n+ * \n+ * REHData - Hashed public key for this recipient.\n+ * \n+ * REKData - Simple Key Blob.  The format of this data structure\n+ *           is identical to that defined in the Microsoft\n+ *           CryptoAPI and generated using the CryptExportKey()\n+ *           function.  The version of the Simple Key Blob\n+ *           supported at this time is 0x02 as defined by\n+ *           Microsoft.\n+ *           \n+ *           For more details see https://msdn.microsoft.com/en-us/library/aa920051.aspx\n+ * </pre>\n+ * \n+ * <b>Flags</b> - Processing flags needed for decryption\n+ * \n+ * <ul>\n+ * <li>0x0001 - Password is required to decrypt</li>\n+ * <li>0x0002 - Certificates only</li>\n+ * <li>0x0003 - Password or certificate required to decrypt</li>\n+ * <li>0x0007 - reserved for future use\n+ * <li>0x000F - reserved for future use\n+ * <li>0x0100 - indicates non-OAEP key wrapping was used. If this field is set\n+ * the version needed to extract must be at least 61. This means OAEP key\n+ * wrapping is not used when generating a Master Session Key using ErdData.\n+ * <li>0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the same\n+ * algorithm used for encrypting the file contents.\n+ * <li>0x8000 - reserved for future use.\n+ * </ul>\n+ *\n+ * <b>See the section describing the Strong Encryption Specification for\n+ * details. Refer to the section in this document entitled\n+ * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n+ * information.</b>\n+ *\n+ * @NotThreadSafe\n+ */\n+public class X0017_StrongEncryptionHeader extends PKWareExtraHeader implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0017);\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Get the header id.\n+     * \n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] localData;\n+\n+    private int format;\n+    private EncryptionAlgorithm algId;\n+    private int bitlen;\n+    private int flags;\n+    private long rcount;\n+    private HashAlgorithm hashAlg;\n+    private int hashSize;\n+\n+    // encryption data\n+    private byte ivData[];\n+    private byte erdData[];\n+    \n+    // encryption key\n+    private byte recipientKeyHash[];\n+    private byte keyBlob[];\n+    \n+    // password verification data\n+    private byte vData[];\n+    private byte vCRC32[];\n+\n+    /**\n+     * Get record count.\n+     * @return\n+     */\n+    public long getRecordCount() {\n+        return rcount;\n+    }\n+    \n+    /**\n+     * Get hash algorithm.\n+     * @return\n+     */\n+    public HashAlgorithm getHashAlgorithm() {\n+        return hashAlg;\n+    }\n+    \n+    /**\n+     * Get encryption algorithm.\n+     * @return\n+     */\n+    public EncryptionAlgorithm getEncryptionAlgorithm() {\n+        return algId;\n+    }\n+    \n+    /**\n+     * Set the extra field data in the local file data - without Header-ID or\n+     * length specifier.\n+     * \n+     * @param data\n+     *            the field data to use\n+     */\n+    public void setLocalFileDataData(byte[] data) {\n+        localData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the length of the local data.\n+     * \n+     * @return the length of the local data\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localData != null ? localData.length : 0);\n+    }\n+\n+    /**\n+     * Get the local data.\n+     * \n+     * @return the local data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localData);\n+    }\n+\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] centralData;\n+\n+    /**\n+     * Set the extra field data in central directory.\n+     * \n+     * @param data\n+     *            the data to use\n+     */\n+    public void setCentralDirectoryData(byte[] data) {\n+        centralData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the central data length. If there is no central data, get the local\n+     * file data length.\n+     * \n+     * @return the central data length\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        if (centralData != null) {\n+            return new ZipShort(centralData.length);\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the central data.\n+     * \n+     * @return the central data if present, else return the local file data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        if (centralData != null) {\n+            return ZipUtil.copy(centralData);\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * Parse central directory format.\n+     * \n+     * @param data\n+     * @param offset\n+     * @param length\n+     */\n+    public void parseCentralDirectoryFormat(byte[] data, int offset, int length) {\n+        this.format = ZipShort.getValue(data, offset);\n+        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n+        this.bitlen = ZipShort.getValue(data, offset + 4);\n+        this.flags = ZipShort.getValue(data, offset + 6);\n+        this.rcount = ZipLong.getValue(data, offset + 8);\n+\n+        if (rcount > 0) {\n+            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n+            this.hashSize = ZipShort.getValue(data, offset + 14);\n+            // srlist... hashed public keys\n+            for (int i = 0; i < this.rcount; i++) {\n+                for (int j = 0; j < this.hashSize; j++) {\n+                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse file header format. (Password only?)\n+     * \n+     * @param data\n+     * @param offset\n+     * @param length\n+     */\n+    public void parseFileFormat(byte[] data, int offset, int length) {\n+        int ivSize = ZipShort.getValue(data, offset);\n+        this.ivData = new byte[ivSize];\n+        System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n+\n+        long size = ZipLong.getValue(data, offset + ivSize + 2);\n+        this.format = ZipShort.getValue(data, offset + ivSize + 6);\n+        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\n+        this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n+        this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n+\n+        int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n+        this.erdData = new byte[erdSize];\n+        System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n+        \n+        this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n+        System.out.println(\"rcount: \" + rcount);\n+        if (rcount == 0) {\n+            int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n+            this.vData = new byte[vSize - 4];\n+            this.vCRC32 = new byte[4];\n+            System.arraycopy(data, offset + ivSize + 22 + erdSize , this.vData, 0, vSize - 4);\n+            System.arraycopy(data, offset + ivSize + 22 + erdSize + vSize - 4, vCRC32, 0, 4);\n+        } else {\n+            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n+            this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n+            int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n+            this.recipientKeyHash = new byte[this.hashSize];\n+            this.keyBlob = new byte[resize - this.hashSize];\n+            System.arraycopy(data, offset + ivSize + 24 + erdSize, this.recipientKeyHash, 0, this.hashSize);\n+            System.arraycopy(data, offset + ivSize + 24 + erdSize + this.hashSize, this.keyBlob, 0, resize - this.hashSize);\n+\n+            int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n+            this.vData = new byte[vSize - 4];\n+            this.vCRC32 = new byte[4];\n+            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n+            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, vCRC32, 0, 4);\n+        }\n+        \n+        // validate values?\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        parseFileFormat(data, offset, length);\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+        parseCentralDirectoryFormat(data, offset, length);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0019_EncryptionRecipientCertificateList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * PKCS#7 Encryption Recipient Certificate List (0x0019)\n+ * \n+ * This field MAY contain information about each of the certificates used in\n+ * encryption processing and it can be used to identify who is allowed to\n+ * decrypt encrypted files. This field should only appear in the archive extra\n+ * data record. This field is not required and serves only to aid archive\n+ * modifications by preserving public encryption key data. Individual security\n+ * requirements may dictate that this data be omitted to deter information\n+ * exposure.\n+ *\n+ * Note: all fields stored in Intel low-byte/high-byte order.\n+ *\n+ * <pre>\n+ *          Value     Size     Description\n+ *          -----     ----     -----------\n+ * (CStore) 0x0019    2 bytes  Tag for this \"extra\" block type\n+ *          TSize     2 bytes  Size of the store data\n+ *          Version   2 bytes  Format version number - must 0x0001 at this time\n+ *          CStore    (var)    PKCS#7 data blob\n+ * </pre>\n+ *\n+ * <b>See the section describing the Strong Encryption Specification for\n+ * details. Refer to the section in this document entitled\n+ * \"Incorporating PKWARE Proprietary Technology into Your Product\" for more\n+ * information.</b>\n+ * \n+ * @NotThreadSafe\n+ */\n+public class X0019_EncryptionRecipientCertificateList extends PKWareExtraHeader implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0x0019);\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Get the header id.\n+     * \n+     * @return the header id\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Extra field data in local file data - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] localData;\n+\n+    /**\n+     * Set the extra field data in the local file data - without Header-ID or\n+     * length specifier.\n+     * \n+     * @param data\n+     *            the field data to use\n+     */\n+    public void setLocalFileDataData(byte[] data) {\n+        localData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the length of the local data.\n+     * \n+     * @return the length of the local data\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localData != null ? localData.length : 0);\n+    }\n+\n+    /**\n+     * Get the local data.\n+     * \n+     * @return the local data\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localData);\n+    }\n+\n+    /**\n+     * Extra field data in central directory - without Header-ID or length\n+     * specifier.\n+     */\n+    private byte[] centralData;\n+\n+    /**\n+     * Set the extra field data in central directory.\n+     * \n+     * @param data\n+     *            the data to use\n+     */\n+    public void setCentralDirectoryData(byte[] data) {\n+        centralData = ZipUtil.copy(data);\n+    }\n+\n+    /**\n+     * Get the central data length. If there is no central data, get the local\n+     * file data length.\n+     * \n+     * @return the central data length\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        if (centralData != null) {\n+            return new ZipShort(centralData.length);\n+        }\n+        return getLocalFileDataLength();\n+    }\n+\n+    /**\n+     * Get the central data.\n+     * \n+     * @return the central data if present, else return the local file data\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        if (centralData != null) {\n+            return ZipUtil.copy(centralData);\n+        }\n+        return getLocalFileDataData();\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n+     */\n+    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setLocalFileDataData(tmp);\n+    }\n+\n+    /**\n+     * @param data\n+     *            the array of bytes.\n+     * @param offset\n+     *            the source location in the data array.\n+     * @param length\n+     *            the number of bytes to use in the data array.\n+     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n+     */\n+    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+        byte[] tmp = new byte[length];\n+        System.arraycopy(data, offset, tmp, 0, length);\n+        setCentralDirectoryData(tmp);\n+        if (localData == null) {\n+            setLocalFileDataData(tmp);\n+        }\n+    }\n+}", "timestamp": 1450024389, "metainfo": ""}