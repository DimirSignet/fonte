{"sha": "eedeff97d84db068a0fc56c91c4f39a5db2130bb", "log": "detect sparse entries in tar and allow users to skip them.  Submitted by Patrick Dreyer.  COMPRESS-145  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This class represents a sparse entry in a Tar archive.\n+ *\n+ * <p>\n+ * The C structure for a sparse entry is:\n+ * <pre>\n+ * struct posix_header {\n+ * struct sparse sp[21]; // TarConstants.SPARSELEN_GNU_SPARSE     - offset 0\n+ * char isextended;      // TarConstants.ISEXTENDEDLEN_GNU_SPARSE - offset 504\n+ * };\n+ * </pre>\n+ * Whereas, \"struct sparse\" is:\n+ * <pre>\n+ * struct sparse {\n+ * char offset[12];   // offset 0\n+ * char numbytes[12]; // offset 12\n+ * };\n+ * </pre>\n+ */\n+\n+public class TarArchiveSparseEntry implements TarConstants {\n+    /** If an extension sparse header follows. */\n+    private boolean isExtended;\n+\n+    /**\n+     * Construct an entry from an archive's header bytes. File is set\n+     * to null.\n+     *\n+     * @param headerBuf The header bytes from a tar archive entry.\n+     * @throws IOException on unknown format\n+     */\n+    public TarArchiveSparseEntry(byte[] headerBuf) throws IOException {\n+        int offset = 0;\n+        offset += SPARSELEN_GNU_SPARSE;\n+        isExtended = TarUtils.parseBoolean(headerBuf, offset);\n+    }\n+\n+    public boolean isExtended() {\n+        return isExtended;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarConstants.java\n /**\n  * This interface contains all the definitions used in the package.\n  *\n+ * For tar formats (FORMAT_OLDGNU, FORMAT_POSIX, etc.) see GNU tar\n+ * <I>tar.h</I> type <I>enum archive_format</I>\n  */\n // CheckStyle:InterfaceIsTypeCheck OFF (bc)\n public interface TarConstants {\n \n     /**\n+     * GNU format as per before tar 1.12.\n+     */\n+    int    FORMAT_OLDGNU = 2;\n+\n+    /**\n+     * Pure Posix format.\n+     */\n+    int    FORMAT_POSIX = 3;\n+\n+    /**\n      * The length of the name field in a header buffer.\n      */\n     int    NAMELEN = 100;\n     int    PREFIXLEN = 155;\n \n     /**\n+     * The length of the access time field in an old GNU header buffer.\n+     * \n+     */\n+    int    ATIMELEN_GNU = 12;\n+\n+    /**\n+     * The length of the created time field in an old GNU header buffer.\n+     * \n+     */\n+    int    CTIMELEN_GNU = 12;\n+\n+    /**\n+     * The length of the multivolume start offset field in an old GNU header buffer. \n+     * \n+     */\n+    int    OFFSETLEN_GNU = 12;\n+\n+    /**\n+     * The length of the long names field in an old GNU header buffer. \n+     * \n+     */\n+    int    LONGNAMESLEN_GNU = 4;\n+\n+    /**\n+     * The length of the padding field in an old GNU header buffer. \n+     * \n+     */\n+    int    PAD2LEN_GNU = 1;\n+\n+    /**\n+     * The sum of the length of all sparse headers in an old GNU header buffer. \n+     * \n+     */\n+    int    SPARSELEN_GNU = 96;\n+\n+    /**\n+     * The length of the is extension field in an old GNU header buffer. \n+     * \n+     */\n+    int    ISEXTENDEDLEN_GNU = 1;\n+\n+    /**\n+     * The length of the real size field in an old GNU header buffer. \n+     * \n+     */\n+    int    REALSIZELEN_GNU = 12;\n+\n+    /**\n+     * The sum of the length of all sparse headers in a sparse header buffer. \n+     * \n+     */\n+    int    SPARSELEN_GNU_SPARSE = 504;\n+\n+    /**\n+     * The length of the is extension field in a sparse header buffer. \n+     * \n+     */\n+    int    ISEXTENDEDLEN_GNU_SPARSE = 1;\n+\n+    /**\n      * LF_ constants represent the \"link flag\" of an entry, or more commonly,\n      * the \"entry type\". This is the \"old way\" of indicating a normal file.\n      */\n      * Identifies the *next* file on the tape as having a long name.\n      */\n     byte LF_GNUTYPE_LONGNAME = (byte) 'L';\n+\n+    /**\n+     * Sparse file type.\n+     * @since Apache Commons Compress 1.1.1\n+     */\n+    byte LF_GNUTYPE_SPARSE = (byte) 'S';\n \n     // See \"http://www.opengroup.org/onlinepubs/009695399/utilities/pax.html#tag_04_100_13_02\"\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n         return result;\n     }\n \n+    /**\n+     * Parse a boolean byte from a buffer.\n+     * Leading spaces and NUL are ignored.\n+     * The buffer may contain trailing spaces or NULs.\n+     *\n+     * @param buffer The buffer from which to parse.\n+     * @param offset The offset into the buffer from which to parse.\n+     * @param length The maximum number of bytes to parse - must be at least 1 byte.\n+     * @return The boolean value of the bytes.\n+     * @throws IllegalArgumentException if an invalid byte is detected.\n+     */\n+    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n+        return (buffer[offset] == 1);\n+    }\n+\n     // Helper method to generate the exception message\n     private static String exceptionMessage(byte[] buffer, final int offset,\n             final int length, int current, final byte currentByte) {", "timestamp": 1311397037, "metainfo": ""}