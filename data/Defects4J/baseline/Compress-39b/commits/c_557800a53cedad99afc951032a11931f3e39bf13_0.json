{"sha": "557800a53cedad99afc951032a11931f3e39bf13", "log": "COMPRESS-277 make sure IOUtils#skip deals with streams that return 0 on skip even though more could be read  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n  */\n public final class IOUtils {\n \n+    private static final int COPY_BUF_SIZE = 8024;\n+    private static final int SKIP_BUF_SIZE = 4096;\n+\n     /** Private constructor to prevent instantiation of this utility class. */\n     private IOUtils(){\n     }\n      *             if an error occurs\n      */\n     public static long copy(final InputStream input, final OutputStream output) throws IOException {\n-        return copy(input, output, 8024);\n+        return copy(input, output, COPY_BUF_SIZE);\n     }\n \n     /**\n      * Skips the given number of bytes by repeatedly invoking skip on\n      * the given input stream if necessary.\n      *\n+     * <p>In a case where the stream's skip() method returns 0 before\n+     * the requested number of bytes has been skip this implementation\n+     * will fall back to using the read() method.</p>\n+     *\n      * <p>This method will only skip less than the requested number of\n      * bytes if the end of the input stream has been reached.</p>\n      *\n             }\n             numToSkip -= skipped;\n         }\n+            \n+        if (numToSkip > 0) {\n+            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n+            while (numToSkip > 0) {\n+                int read = readFully(input, skipBuf, 0,\n+                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n+                if (read < 1) {\n+                    break;\n+                }\n+                numToSkip -= read;\n+            }\n+        }\n         return available - numToSkip;\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class IOUtilsTest {\n+\n+    private interface StreamWrapper {\n+        InputStream wrap(InputStream toWrap);\n+    }\n+\n+    @Test\n+    public void skipUsingSkip() throws Exception {\n+        skip(new StreamWrapper() {\n+                public InputStream wrap(InputStream toWrap) {\n+                    return toWrap;\n+                }\n+            });\n+    }\n+\n+    @Test\n+    public void skipUsingRead() throws Exception {\n+        skip(new StreamWrapper() {\n+                public InputStream wrap(InputStream toWrap) {\n+                    return new FilterInputStream(toWrap) {\n+                        public long skip(long s) {\n+                            return 0;\n+                        }\n+                    };\n+                }\n+            });\n+    }\n+\n+    @Test\n+    public void skipUsingSkipAndRead() throws Exception {\n+        skip(new StreamWrapper() {\n+                public InputStream wrap(final InputStream toWrap) {\n+                    return new FilterInputStream(toWrap) {\n+                        boolean skipped;\n+                        public long skip(long s) throws IOException {\n+                            if (!skipped) {\n+                                toWrap.skip(5);\n+                                skipped = true;\n+                                return 5;\n+                            }\n+                            return 0;\n+                        }\n+                    };\n+                }\n+            });\n+    }\n+\n+    private void skip(StreamWrapper wrapper) throws Exception {\n+        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n+                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n+            });\n+        InputStream sut = wrapper.wrap(in);\n+        Assert.assertEquals(10, IOUtils.skip(sut, 10));\n+        Assert.assertEquals(11, sut.read());\n+    }\n+\n+}", "timestamp": 1397322357, "metainfo": ""}