{"sha": "1120914c8b6c0ba6e75328791d9fe639b946e2fa", "log": "COMPRESS-214 - better support for unix symlinks  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.utils.IOUtils;\n+\n import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.zip.ZipException;\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n \n /**\n  * Extension that adds better handling of extra fields and provides\n     public int getUnixMode() {\n         return platform != PLATFORM_UNIX ? 0 :\n             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);\n+    }\n+\n+    /**\n+     * Returns true if this entry represents a unix symlink,\n+     * in which case the entry's content contains the target path\n+     * for the symlink.\n+     *\n+     * @return true if the entry represents a unix symlink, false otherwise.\n+     */\n+    public boolean isUnixSymlink() {\n+        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n+    }\n+\n+    /**\n+     * <p>\n+     * Convenience method to return this entry's content as a String if isUnixSymlink()\n+     * returns true, otherwise returns null.\n+     * This method assumes the symlink's target path has been stored in the zip file using the\n+     * UTF-8 character encoding.\n+     * </p><p>\n+     * Unfortunately, there is no reliable way to automatically obtain the target path's\n+     * character encoding (within the zip file) should it differ from UTF-8.  Zip files\n+     * do not remember the character set used to encode zip contents.\n+     * Entry names do not have this problem (thanks to various flags and extra fields),\n+     * but symlink targets are not so lucky.  If you happen to know the character set that was used\n+     * to encode symlink paths in the zip file, feel free to use the overloaded version:\n+     * <code>getUnixSymlink(ZipFile zf, String pathCharset)</code>.\n+     * </p><p>\n+     * This method can only be used in conjunction with a ZipFile object (since we need\n+     * the entry's contents); users of ZipArchiveInputStream will need to create their\n+     * own logic.\n+     * </p>\n+     *\n+     * @param zf ZipFile object that contains this ZipArchiveEntry's contents.\n+     * @return entry's content as a String (UTF-8 character set assumed).\n+     * @throws IOException problem with content's input stream\n+     */\n+    public String getUnixSymlink(ZipFile zf) throws IOException {\n+        return getUnixSymlink(zf, \"UTF-8\");\n+    }\n+\n+    /**\n+     * <p>\n+     * Convenience method to return this entry's content as a String if isUnixSymlink()\n+     * returns true, otherwise returns null.\n+     * </p><p>\n+     * Unfortunately, there is no reliable way to automatically obtain the target path's\n+     * character encoding (within the zip file) should it differ from UTF-8.  Zip files\n+     * do not remember the character set used to encode zip contents.\n+     * Entry names do not have this problem (thanks to various flags and extra fields),\n+     * but symlink targets are not so lucky.\n+     * </p><p>\n+     * This method can only be used in conjunction with a ZipFile object (since we need\n+     * the entry's contents); users of ZipArchiveInputStream will need to create their\n+     * own logic.\n+     * </p>\n+     *\n+     * @param zf          ZipFile object that contains this ZipArchiveEntry's contents.\n+     * @param pathCharset the character set used to encode the symlink's target path.\n+     * @return entry's content as a String (using the provided character set).\n+     * @throws IOException problem with content's input stream\n+     */\n+    public String getUnixSymlink(ZipFile zf, String pathCharset) throws IOException {\n+        if (isUnixSymlink()) {\n+            InputStream in = null;\n+            try {\n+                in = zf.getInputStream(this);\n+                byte[] symlinkBytes = IOUtils.toByteArray(in);\n+                return new String(symlinkBytes, pathCharset);\n+            } finally {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            }\n+        } else {\n+            return null;\n+        }\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n  */\n package org.apache.commons.compress.utils;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n         }\n         return count;\n     }\n+\n+\n+    // toByteArray(InputStream) copied from:\n+    // commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941\n+    // January 8th, 2013\n+    //\n+    // Assuming our copy() works just as well as theirs!  :-)\n+\n+    /**\n+     * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.\n+     * <p>\n+     * This method buffers the input internally, so there is no need to use a\n+     * <code>BufferedInputStream</code>.\n+     *\n+     * @param input  the <code>InputStream</code> to read from\n+     * @return the requested byte array\n+     * @throws NullPointerException if the input is null\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static byte[] toByteArray(final InputStream input) throws IOException {\n+        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        copy(input, output);\n+        return output.toByteArray();\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import junit.framework.TestCase;\n+\n import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.TreeMap;\n import java.util.zip.ZipEntry;\n-\n-import junit.framework.TestCase;\n \n /**\n  * JUnit 3 testcases for org.apache.commons.compress.archivers.zip.ZipEntry.\n \n     public ZipArchiveEntryTest(String name) {\n         super(name);\n+    }\n+\n+    public void testUnixSymlinkSampleFile() throws Exception {\n+        final String entryPrefix = \"COMPRESS-214_unix_symlinks/\";\n+        final TreeMap<String, String> expectedVals = new TreeMap<String, String>();\n+\n+        // I threw in some Japanese characters to keep things interesting.\n+        expectedVals.put(entryPrefix + \"link1\", \"../COMPRESS-214_unix_symlinks/./a/b/c/../../../\\uF999\");\n+        expectedVals.put(entryPrefix + \"link2\", \"../COMPRESS-214_unix_symlinks/./a/b/c/../../../g\");\n+        expectedVals.put(entryPrefix + \"link3\", \"../COMPRESS-214_unix_symlinks/././a/b/c/../../../\\u76F4\\u6A39\");\n+        expectedVals.put(entryPrefix + \"link4\", \"\\u82B1\\u5B50/\\u745B\\u5B50\");\n+        expectedVals.put(entryPrefix + \"\\uF999\", \"./\\u82B1\\u5B50/\\u745B\\u5B50/\\u5897\\u8C37/\\uF999\");\n+        expectedVals.put(entryPrefix + \"g\", \"./a/b/c/d/e/f/g\");\n+        expectedVals.put(entryPrefix + \"\\u76F4\\u6A39\", \"./g\");\n+\n+        // Notice how a directory link might contain a trailing slash, or it might not.\n+        // Also note:  symlinks are always stored as files, even if they link to directories.\n+        expectedVals.put(entryPrefix + \"link5\", \"../COMPRESS-214_unix_symlinks/././a/b\");\n+        expectedVals.put(entryPrefix + \"link6\", \"../COMPRESS-214_unix_symlinks/././a/b/\");\n+\n+        // I looked into creating a test with hard links, but zip does not appear to\n+        // support hard links, so nevermind.\n+\n+        URL zip = getClass().getResource(\"/COMPRESS-214_unix_symlinks.zip\");\n+        File archive = new File(new URI(zip.toString()));\n+        ZipFile zf = null;\n+\n+        try {\n+            zf = new ZipFile(archive);\n+            Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+            while (en.hasMoreElements()) {\n+                ZipArchiveEntry zae = en.nextElement();\n+                if (zae.isUnixSymlink()) {\n+                    String name = zae.getName();\n+                    String link = zae.getUnixSymlink(zf);\n+                    String expected = expectedVals.get(name);\n+                    assertEquals(expected, link);\n+                } else {\n+                    String link = zae.getUnixSymlink(zf);\n+                    // Should be null if it's not a symlink!\n+                    assertNull(link);\n+                }\n+            }\n+        } finally {\n+            if (zf != null) {\n+                zf.close();\n+            }\n+        }\n     }\n \n     /**", "timestamp": 1358199768, "metainfo": ""}