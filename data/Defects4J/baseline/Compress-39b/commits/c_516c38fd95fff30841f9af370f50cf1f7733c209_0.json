{"sha": "516c38fd95fff30841f9af370f50cf1f7733c209", "log": "Changed ZipArchiveEntry to use more optimized data structure for an overall performance improvement of about 10% for the use case \"many small files\", for instance a jar file.  LinkedHashMap was not a very good structure for such small lists and performs badly in terms of locality  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.zip.ZipException;\n \n     private int internalAttributes = 0;\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n-    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n+    private ZipExtraField[] extraFields;\n     private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n     private byte[] rawName = null;\n     private GeneralPurposeBit gpb = new GeneralPurposeBit();\n+    private static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\n \n     /**\n      * Creates a new zip entry with the specified name.\n         this((java.util.zip.ZipEntry) entry);\n         setInternalAttributes(entry.getInternalAttributes());\n         setExternalAttributes(entry.getExternalAttributes());\n-        setExtraFields(entry.getExtraFields(true));\n+        setExtraFields(getAllExtraFieldsNoCopy());\n         setPlatform(entry.getPlatform());\n         GeneralPurposeBit other = entry.getGeneralPurposeBit();\n         setGeneralPurposeBit(other == null ? null :\n \n         e.setInternalAttributes(getInternalAttributes());\n         e.setExternalAttributes(getExternalAttributes());\n-        e.setExtraFields(getExtraFields(true));\n+        e.setExtraFields(getAllExtraFieldsNoCopy());\n         return e;\n     }\n \n      * @param fields an array of extra fields\n      */\n     public void setExtraFields(ZipExtraField[] fields) {\n-        extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n+        List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();\n         for (ZipExtraField field : fields) {\n             if (field instanceof UnparseableExtraFieldData) {\n                 unparseableExtra = (UnparseableExtraFieldData) field;\n             } else {\n-                extraFields.put(field.getHeaderId(), field);\n+                newFields.add( field);\n             }\n         }\n+        extraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\n         setExtra();\n     }\n \n      * @return an array of the extra fields\n      */\n     public ZipExtraField[] getExtraFields() {\n-        return getExtraFields(false);\n+        final ZipExtraField[] parseableExtraFields = getParseableExtraFields();\n+        return Arrays.copyOf(parseableExtraFields, parseableExtraFields.length);\n     }\n \n     /**\n      * @since 1.1\n      */\n     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n+        return includeUnparseable ?\n+                getAllExtraFields() :\n+                getParseableExtraFields();\n+    }\n+\n+    private ZipExtraField[] getParseableExtraFields() {\n         if (extraFields == null) {\n-            return !includeUnparseable || unparseableExtra == null\n-                ? new ZipExtraField[0]\n-                : new ZipExtraField[] { unparseableExtra };\n-        }\n-        List<ZipExtraField> result =\n-            new ArrayList<ZipExtraField>(extraFields.values());\n-        if (includeUnparseable && unparseableExtra != null) {\n-            result.add(unparseableExtra);\n-        }\n-        return result.toArray(new ZipExtraField[result.size()]);\n-    }\n-\n+            return noExtraFields;\n+        }\n+        return extraFields;\n+    }\n+\n+    /**\n+     * Get all extra fields, including unparseable ones.\n+     * @return An array of all extra fields. Not necessarily a copy of internal data structures, hence private method\n+     */\n+    private ZipExtraField[] getAllExtraFieldsNoCopy() {\n+        if (extraFields == null) {\n+            return getUnparseableOnly();\n+        }\n+        return unparseableExtra != null ? getMergedFields() : extraFields;\n+    }\n+\n+    private ZipExtraField[] copyOf(ZipExtraField[] src){\n+        return Arrays.copyOf(src, src.length);\n+    }\n+\n+    private ZipExtraField[] getMergedFields() {\n+        final ZipExtraField[] zipExtraFields = Arrays.copyOf(extraFields, extraFields.length + 1);\n+        zipExtraFields[zipExtraFields.length] = unparseableExtra;\n+        return zipExtraFields;\n+    }\n+\n+    private ZipExtraField[] getUnparseableOnly() {\n+        return unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n+    }\n+\n+    private ZipExtraField[] getAllExtraFields() {\n+        final ZipExtraField[] allExtraFieldsNoCopy = getAllExtraFieldsNoCopy();\n+        return (allExtraFieldsNoCopy == extraFields) ? copyOf( allExtraFieldsNoCopy) : allExtraFieldsNoCopy;\n+    }\n     /**\n      * Adds an extra field - replacing an already present extra field\n      * of the same type.\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n             if (extraFields == null) {\n-                extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n+                extraFields = new ZipExtraField[]{ ze};\n+            } else {\n+                if (getExtraField(ze.getHeaderId())!= null){\n+                    removeExtraField(ze.getHeaderId());\n+                }\n+                final ZipExtraField[] zipExtraFields = Arrays.copyOf(extraFields, extraFields.length + 1);\n+                zipExtraFields[zipExtraFields.length -1] = ze;\n+                extraFields = zipExtraFields;\n             }\n-            extraFields.put(ze.getHeaderId(), ze);\n         }\n         setExtra();\n     }\n         if (ze instanceof UnparseableExtraFieldData) {\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n-            LinkedHashMap<ZipShort, ZipExtraField> copy = extraFields;\n-            extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\n-            extraFields.put(ze.getHeaderId(), ze);\n-            if (copy != null) {\n-                copy.remove(ze.getHeaderId());\n-                extraFields.putAll(copy);\n+            if (getExtraField(ze.getHeaderId()) != null){\n+                removeExtraField(ze.getHeaderId());\n+            }\n+            ZipExtraField[] copy = extraFields;\n+            int newLen = extraFields != null ? extraFields.length + 1: 1;\n+            extraFields = new ZipExtraField[newLen];\n+            extraFields[0] = ze;\n+            if (copy != null){\n+                System.arraycopy(copy, 0, extraFields, 1, extraFields.length - 1);\n             }\n         }\n         setExtra();\n         if (extraFields == null) {\n             throw new java.util.NoSuchElementException();\n         }\n-        if (extraFields.remove(type) == null) {\n+\n+        List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();\n+        for (ZipExtraField extraField : extraFields) {\n+            if (!type.equals(extraField.getHeaderId())){\n+                newResult.add( extraField);\n+            }\n+        }\n+        if (extraFields.length == newResult.size()) {\n             throw new java.util.NoSuchElementException();\n         }\n+        extraFields = newResult.toArray(new ZipExtraField[newResult.size()]);\n         setExtra();\n     }\n \n      */\n     public ZipExtraField getExtraField(ZipShort type) {\n         if (extraFields != null) {\n-            return extraFields.get(type);\n+            for (ZipExtraField extraField : extraFields) {\n+                if (type.equals(extraField.getHeaderId())) {\n+                    return extraField;\n+                }\n+            }\n         }\n         return null;\n     }\n      * modify super's data directly.\n      */\n     protected void setExtra() {\n-        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n+        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n     }\n \n     /**\n      * @return the central directory extra data\n      */\n     public byte[] getCentralDirectoryExtra() {\n-        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));\n+        return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n     }\n \n     /**\n      */\n     protected void setName(String name) {\n         if (name != null && getPlatform() == PLATFORM_FAT\n-            && name.indexOf(\"/\") == -1) {\n+            && !name.contains(\"/\")) {\n             name = name.replace('\\\\', '/');\n         }\n         this.name = name;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n             putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n         }\n \n-        GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod,\n-                !encodable\n-                        && fallbackToUTF8\n-        );\n+        GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n         generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n \n         // compression method", "timestamp": 1420830795, "metainfo": ""}