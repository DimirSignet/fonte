{"sha": "478bef366f84544eb4ac89553eeb7d57680fc521", "log": "Add final modifier to method parameters.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/PasswordRequiredException.java\n+++ b/src/main/java/org/apache/commons/compress/PasswordRequiredException.java\n      * @param name name of the archive containing encrypted streams or\n      * the encrypted file.\n      */\n-    public PasswordRequiredException(String name) {\n+    public PasswordRequiredException(final String name) {\n         super(\"Cannot read encrypted content from \" + name + \" without a password.\");\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveException.java\n      * @param message\n      *            the detail message\n      */\n-    public ArchiveException(String message) {\n+    public ArchiveException(final String message) {\n         super(message);\n     }\n \n      * @param cause\n      *            the cause\n      */\n-    public ArchiveException(String message, Exception cause) {\n+    public ArchiveException(final String message, final Exception cause) {\n         super(message);\n         this.initCause(cause);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n      * \n      * @param read the number of bytes read\n      */\n-    protected void count(int read) {\n+    protected void count(final int read) {\n         count((long) read);\n     }\n \n      * @param read the number of bytes read\n      * @since 1.1\n      */\n-    protected void count(long read) {\n+    protected void count(final long read) {\n         if (read != -1) {\n             bytesRead = bytesRead + read;\n         }\n      * @param pushedBack the number of bytes pushed back.\n      * @since 1.1\n      */\n-    protected void pushedBackBytes(long pushedBack) {\n+    protected void pushedBackBytes(final long pushedBack) {\n         bytesRead -= pushedBack;\n     }\n \n      * \n      * @since 1.1\n      */\n-    public boolean canReadEntryData(ArchiveEntry archiveEntry) {\n+    public boolean canReadEntryData(final ArchiveEntry archiveEntry) {\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveOutputStream.java\n      * @throws IOException on error\n      */\n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         oneByte[0] = (byte) (b & BYTE_MASK);\n         write(oneByte, 0, 1);\n     }\n      * \n      * @param written the number of bytes written\n      */\n-    protected void count(int written) {\n+    protected void count(final int written) {\n         count((long) written);\n     }\n \n      * @param written the number of bytes written\n      * @since 1.1\n      */\n-    protected void count(long written) {\n+    protected void count(final long written) {\n         if (written != -1) {\n             bytesWritten = bytesWritten + written;\n         }\n      * @return This implementation always returns true.\n      * @since 1.1\n      */\n-    public boolean canWriteEntryData(ArchiveEntry archiveEntry) {\n+    public boolean canWriteEntryData(final ArchiveEntry archiveEntry) {\n         return true;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n      *\n      * @since 1.10\n      */\n-    public ArchiveStreamFactory(String encoding) {\n+    public ArchiveStreamFactory(final String encoding) {\n         super();\n         this.encoding = encoding;\n         // Also set the original field so can continue to use it.\n      * was used to specify the factory encoding.\n      */\n     @Deprecated\n-    public void setEntryEncoding(String entryEncoding) {\n+    public void setEntryEncoding(final String entryEncoding) {\n         // Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway\n         if (encoding != null) {\n             throw new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n public final class Lister {\n     private static final ArchiveStreamFactory factory = new ArchiveStreamFactory();\n \n-    public static void main(String[] args) throws Exception {\n+    public static void main(final String[] args) throws Exception {\n         if (args.length == 0) {\n             usage();\n             return;\n--- a/src/main/java/org/apache/commons/compress/archivers/StreamingNotSupportedException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/StreamingNotSupportedException.java\n      * \n      * @param format the format that has been requested/detected.\n      */\n-    public StreamingNotSupportedException(String format) {\n+    public StreamingNotSupportedException(final String format) {\n         super(\"The \" + format + \" doesn't support streaming.\");\n         this.format = format;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n      * @param name name of the entry\n      * @param length length of the entry in bytes\n      */\n-    public ArArchiveEntry(String name, long length) {\n+    public ArArchiveEntry(final String name, final long length) {\n         this(name, length, 0, 0, DEFAULT_MODE,\n              System.currentTimeMillis() / 1000);\n     }\n      * @param mode file mode\n      * @param lastModified last modified time in seconds since the epoch\n      */\n-    public ArArchiveEntry(String name, long length, int userId, int groupId,\n-                          int mode, long lastModified) {\n+    public ArArchiveEntry(final String name, final long length, final int userId, final int groupId,\n+                          final int mode, final long lastModified) {\n         this.name = name;\n         this.length = length;\n         this.userId = userId;\n      * @param inputFile the file to create an entry from\n      * @param entryName the name of the entry\n      */\n-    public ArArchiveEntry(File inputFile, String entryName) {\n+    public ArArchiveEntry(final File inputFile, final String entryName) {\n         // TODO sort out mode\n         this(entryName, inputFile.isFile() ? inputFile.length() : 0,\n              0, 0, DEFAULT_MODE, inputFile.lastModified() / 1000);\n     }\n \n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (this == obj) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n      * @return the extended file name; without trailing \"/\" if present.\n      * @throws IOException if name not found or buffer not set up\n      */\n-    private String getExtendedName(int offset) throws IOException{\n+    private String getExtendedName(final int offset) throws IOException{\n         if (namebuffer == null) {\n             throw new IOException(\"Cannot process GNU long filename as no // record was found\");\n         }\n         }\n         throw new IOException(\"Failed to read entry: \"+offset);\n     }\n-    private long asLong(byte[] input) {\n+    private long asLong(final byte[] input) {\n         return Long.parseLong(ArchiveUtils.toAsciiString(input).trim());\n     }\n \n-    private int asInt(byte[] input) {\n+    private int asInt(final byte[] input) {\n         return asInt(input, 10, false);\n     }\n \n-    private int asInt(byte[] input, boolean treatBlankAsZero) {\n+    private int asInt(final byte[] input, final boolean treatBlankAsZero) {\n         return asInt(input, 10, treatBlankAsZero);\n     }\n \n-    private int asInt(byte[] input, int base) {\n+    private int asInt(final byte[] input, final int base) {\n         return asInt(input, base, false);\n     }\n \n-    private int asInt(byte[] input, int base, boolean treatBlankAsZero) {\n+    private int asInt(final byte[] input, final int base, final boolean treatBlankAsZero) {\n         String string = ArchiveUtils.toAsciiString(input).trim();\n         if (string.length() == 0 && treatBlankAsZero) {\n             return 0;\n      * @see java.io.InputStream#read(byte[], int, int)\n      */\n     @Override\n-    public int read(byte[] b, final int off, final int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         int toRead = len;\n         if (currentEntry != null) {\n             final long entryEnd = entryOffset + currentEntry.getLength();\n      *            the number of bytes to check\n      * @return true, if this stream is an Ar archive stream, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         // 3c21 7261 6863 0a3e\n \n         if (length < 8) {\n      *\n      * @since 1.3\n      */\n-    private static boolean isBSDLongName(String name) {\n+    private static boolean isBSDLongName(final String name) {\n         return name != null && name.matches(BSD_LONGNAME_PATTERN);\n     }\n \n      *\n      * @since 1.3\n      */\n-    private String getBSDLongName(String bsdLongName) throws IOException {\n+    private String getBSDLongName(final String bsdLongName) throws IOException {\n         int nameLen =\n             Integer.parseInt(bsdLongName.substring(BSD_LONGNAME_PREFIX_LEN));\n         byte[] name = new byte[nameLen];\n      * characters. Note that the decimal offsets are number of\n      * characters, not line or string number within the \"//\" file.</p>\n      */\n-    private static boolean isGNUStringTable(String name) {\n+    private static boolean isGNUStringTable(final String name) {\n         return GNU_STRING_TABLE_NAME.equals(name);\n     }\n \n      *\n      * @see #isGNUStringTable\n      */\n-    private ArArchiveEntry readGNUStringTable(byte[] length) throws IOException {\n+    private ArArchiveEntry readGNUStringTable(final byte[] length) throws IOException {\n         int bufflen = asInt(length); // Assume length will fit in an int\n         namebuffer = new byte[bufflen];\n         int read = IOUtils.readFully(this, namebuffer, 0, bufflen);\n      *\n      * @see #isGNUStringTable\n      */\n-    private boolean isGNULongName(String name) {\n+    private boolean isGNULongName(final String name) {\n         return name != null && name.matches(GNU_LONGNAME_PATTERN);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n      * @param longFileMode the mode to use\n      * @since 1.3\n      */\n-    public void setLongFileMode(int longFileMode) {\n+    public void setLongFileMode(final int longFileMode) {\n         this.longFileMode = longFileMode;\n     }\n \n     }\n \n     @Override\n-    public void write(byte[] b, int off, int len) throws IOException {\n+    public void write(final byte[] b, final int off, final int len) throws IOException {\n         out.write(b, off, len);\n         count(len);\n         entryOffset += len;\n     }\n \n     @Override\n-    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n+    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName)\n             throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n         return new String(buffer.toByteArray());\n     }\n     \n-    private void readFully(final DataInputStream dataIn, byte[] b)\n+    private void readFully(final DataInputStream dataIn, final byte[] b)\n         throws IOException {\n         dataIn.readFully(b);\n         count(b.length);\n         return localFileHeader;\n     }\n     \n-    private void readExtraData(int firstHeaderSize, DataInputStream firstHeader,\n-                               LocalFileHeader localFileHeader) throws IOException {\n+    private void readExtraData(final int firstHeaderSize, final DataInputStream firstHeader,\n+                               final LocalFileHeader localFileHeader) throws IOException {\n         if (firstHeaderSize >= 33) {\n             localFileHeader.extendedFilePosition = read32(firstHeader);\n             if (firstHeaderSize >= 45) {\n     }\n \n     @Override\n-    public boolean canReadEntryData(ArchiveEntry ae) {\n+    public boolean canReadEntryData(final ArchiveEntry ae) {\n         return ae instanceof ArjArchiveEntry\n             && ((ArjArchiveEntry) ae).getMethod() == LocalFileHeader.Methods.STORED;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * @param entryName\n      *            The name of this entry.\n      */\n-    public CpioArchiveEntry(File inputFile, String entryName) {\n+    public CpioArchiveEntry(final File inputFile, final String entryName) {\n         this(FORMAT_NEW, inputFile, entryName);\n     }\n \n      * \n      * @since 1.1\n      */\n-    public CpioArchiveEntry(final short format, File inputFile,\n-                            String entryName) {\n+    public CpioArchiveEntry(final short format, final File inputFile,\n+                            final String entryName) {\n         this(format, entryName, inputFile.isFile() ? inputFile.length() : 0);\n         if (inputFile.isDirectory()){\n             setMode(C_ISDIR);\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (this == obj) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n      *            the platform's default.\n      * @since 1.6\n      */\n-    public CpioArchiveInputStream(final InputStream in, String encoding) {\n+    public CpioArchiveInputStream(final InputStream in, final String encoding) {\n         this(in, BLOCK_SIZE, encoding);\n     }\n \n      *            The block size of the archive.\n      * @since 1.5\n      */\n-    public CpioArchiveInputStream(final InputStream in, int blockSize) {\n+    public CpioArchiveInputStream(final InputStream in, final int blockSize) {\n         this(in, blockSize, CharsetNames.US_ASCII);\n     }\n \n      *            the platform's default.\n      * @since 1.6\n      */\n-    public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n+    public CpioArchiveInputStream(final InputStream in, final int blockSize, final String encoding) {\n         this.in = in;\n         this.blockSize = blockSize;\n         this.encoding = encoding;\n         return this.entry;\n     }\n \n-    private void skip(int bytes) throws IOException{\n+    private void skip(final int bytes) throws IOException{\n         // bytes cannot be more than 3 bytes\n         if (bytes > 0) {\n             readFully(FOUR_BYTES_BUF, 0, bytes);\n      * @param length length of data\n      * @return whether the buffer seems to contain CPIO data\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < 6) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      *            the platform's default.\n      * @since 1.6\n      */\n-    public CpioArchiveOutputStream(final OutputStream out, String encoding) {\n+    public CpioArchiveOutputStream(final OutputStream out, final String encoding) {\n         this(out, FORMAT_NEW, BLOCK_SIZE, encoding);\n     }\n \n      * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n      */\n     @Override\n-    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry entry) throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n         }\n     }\n \n-    private void pad(int count) throws IOException{\n+    private void pad(final int count) throws IOException{\n         if (count > 0){\n             byte buff[] = new byte[count];\n             out.write(buff);\n      * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n      */\n     @Override\n-    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n+    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName)\n             throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n     /**\n      * Extracts the file type bits from a mode.\n      */\n-    static long fileType(long mode) {\n+    static long fileType(final long mode) {\n         return mode & CpioConstants.S_IFMT;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/Dirent.java\n      * @param type\n      * @param name\n      */\n-    Dirent(int ino, int parentIno, int type, String name) {\n+    Dirent(final int ino, final int parentIno, final int type, final String name) {\n         this.ino = ino;\n         this.parentIno = parentIno;\n         this.type = type;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n \n         int code;\n \n-        private SEGMENT_TYPE(int code) {\n+        private SEGMENT_TYPE(final int code) {\n             this.code = code;\n         }\n \n-        public static SEGMENT_TYPE find(int code) {\n+        public static SEGMENT_TYPE find(final int code) {\n             for (SEGMENT_TYPE t : values()) {\n                 if (t.code == code) {\n                     return t;\n \n         int code;\n \n-        private COMPRESSION_TYPE(int code) {\n+        private COMPRESSION_TYPE(final int code) {\n             this.code = code;\n         }\n \n-        public static COMPRESSION_TYPE find(int code) {\n+        public static COMPRESSION_TYPE find(final int code) {\n             for (COMPRESSION_TYPE t : values()) {\n                 if (t.code == code) {\n                     return t;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n      * @param name pathname\n      * @param simpleName actual filename.\n      */\n-    public DumpArchiveEntry(String name, String simpleName) {\n+    public DumpArchiveEntry(final String name, final String simpleName) {\n         setName(name);\n         this.simpleName = simpleName;\n     }\n      * @param ino the ino\n      * @param type the type\n      */\n-    protected DumpArchiveEntry(String name, String simpleName, int ino,\n-                               TYPE type) {\n+    protected DumpArchiveEntry(final String name, final String simpleName, final int ino,\n+                               final TYPE type) {\n         setType(type);\n         setName(name);\n         this.simpleName = simpleName;\n      * Sets the path of the entry.\n      * @param simpleName the simple name\n      */\n-    protected void setSimpleName(String simpleName) {\n+    protected void setSimpleName(final String simpleName) {\n         this.simpleName = simpleName;\n     }\n \n      * Set the number of hard links.\n      * @param nlink the number of hard links\n      */\n-    public void setNlink(int nlink) {\n+    public void setNlink(final int nlink) {\n         this.nlink = nlink;\n     }\n \n      * Set the file creation time.\n      * @param ctime the creation time\n      */\n-    public void setCreationTime(Date ctime) {\n+    public void setCreationTime(final Date ctime) {\n         this.ctime = ctime.getTime();\n     }\n \n      * Set the generation of the file.\n      * @param generation the generation\n      */\n-    public void setGeneration(int generation) {\n+    public void setGeneration(final int generation) {\n         this.generation = generation;\n     }\n \n      * Set whether this file has been deleted.\n      * @param isDeleted whether the file has been deleted\n      */\n-    public void setDeleted(boolean isDeleted) {\n+    public void setDeleted(final boolean isDeleted) {\n         this.isDeleted = isDeleted;\n     }\n \n      * Set the offset within the archive.\n      * @param offset the offset\n      */\n-    public void setOffset(long offset) {\n+    public void setOffset(final long offset) {\n         this.offset = offset;\n     }\n \n      * Set the tape volume.\n      * @param volume the volume\n      */\n-    public void setVolume(int volume) {\n+    public void setVolume(final int volume) {\n         this.volume = volume;\n     }\n \n      * @param idx index of the record to check\n      * @return whether this is a sparse record\n      */\n-    public boolean isSparseRecord(int idx) {\n+    public boolean isSparseRecord(final int idx) {\n         return (header.getCdata(idx) & 0x01) == 0;\n     }\n \n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o == this) {\n             return true;\n         } else if (o == null || !o.getClass().equals(getClass())) {\n      *\n      * @param buffer buffer to read content from\n      */\n-    static DumpArchiveEntry parse(byte[] buffer) {\n+    static DumpArchiveEntry parse(final byte[] buffer) {\n         DumpArchiveEntry entry = new DumpArchiveEntry();\n         TapeSegmentHeader header = entry.header;\n \n     /**\n      * Update entry with information from next tape segment header.\n      */\n-    void update(byte[] buffer) {\n+    void update(final byte[] buffer) {\n         header.volume = DumpArchiveUtil.convert32(buffer, 16);\n         header.count = DumpArchiveUtil.convert32(buffer, 160);\n \n             return ino;\n         }\n \n-        void setIno(int ino) {\n+        void setIno(final int ino) {\n             this.ino = ino;\n         }\n \n             return holes;\n         }\n \n-        public int getCdata(int idx) {\n+        public int getCdata(final int idx) {\n             return cdata[idx];\n         }\n     }\n      * Set the type of the entry.\n      * @param type the type\n      */\n-    public void setType(TYPE type) {\n+    public void setType(final TYPE type) {\n         this.type = type;\n     }\n \n      * Set the access permissions on the entry.\n      * @param mode the access permissions\n      */\n-    public void setMode(int mode) {\n+    public void setMode(final int mode) {\n         this.mode = mode & 07777;\n         this.permissions = PERMISSION.find(mode);\n     }\n      * Set the size of the entry.\n      * @param size the size\n      */\n-    public void setSize(long size) {\n+    public void setSize(final long size) {\n         this.size = size;\n     }\n \n      * Set the time the file was last modified.\n      * @param mtime the last modified time\n      */\n-    public void setLastModifiedDate(Date mtime) {\n+    public void setLastModifiedDate(final Date mtime) {\n         this.mtime = mtime.getTime();\n     }\n \n      * Set the time the file was last accessed.\n      * @param atime the access time\n      */\n-    public void setAccessTime(Date atime) {\n+    public void setAccessTime(final Date atime) {\n         this.atime = atime.getTime();\n     }\n \n      * Set the user id.\n      * @param uid the user id\n      */\n-    public void setUserId(int uid) {\n+    public void setUserId(final int uid) {\n         this.uid = uid;\n     }\n \n      * Set the group id.\n      * @param gid the group id\n      */\n-    public void setGroupId(int gid) {\n+    public void setGroupId(final int gid) {\n         this.gid = gid;\n     }\n \n \n         private int code;\n \n-        private TYPE(int code) {\n+        private TYPE(final int code) {\n             this.code = code;\n         }\n \n-        public static TYPE find(int code) {\n+        public static TYPE find(final int code) {\n             TYPE type = UNKNOWN;\n \n             for (TYPE t : TYPE.values()) {\n \n         private int code;\n \n-        private PERMISSION(int code) {\n+        private PERMISSION(final int code) {\n             this.code = code;\n         }\n \n-        public static Set<PERMISSION> find(int code) {\n+        public static Set<PERMISSION> find(final int code) {\n             Set<PERMISSION> set = new HashSet<PERMISSION>();\n \n             for (PERMISSION p : PERMISSION.values()) {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveException.java\n     public DumpArchiveException() {\n     }\n \n-    public DumpArchiveException(String msg) {\n+    public DumpArchiveException(final String msg) {\n         super(msg);\n     }\n \n-    public DumpArchiveException(Throwable cause) {\n+    public DumpArchiveException(final Throwable cause) {\n         initCause(cause);\n     }\n \n-    public DumpArchiveException(String msg, Throwable cause) {\n+    public DumpArchiveException(final String msg, final Throwable cause) {\n         super(msg);\n         initCause(cause);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n      * @param is stream to read from\n      * @throws ArchiveException on error\n      */\n-    public DumpArchiveInputStream(InputStream is) throws ArchiveException {\n+    public DumpArchiveInputStream(final InputStream is) throws ArchiveException {\n         this(is, null);\n     }\n \n      * @since 1.6\n      * @throws ArchiveException on error\n      */\n-    public DumpArchiveInputStream(InputStream is, String encoding)\n+    public DumpArchiveInputStream(final InputStream is, final String encoding)\n         throws ArchiveException {\n         this.raw = new TapeInputStream(is);\n         this.hasHitEOF = false;\n         queue = new PriorityQueue<DumpArchiveEntry>(10,\n                 new Comparator<DumpArchiveEntry>() {\n                     @Override\n-                    public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n+                    public int compare(final DumpArchiveEntry p, final DumpArchiveEntry q) {\n                         if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                             return Integer.MAX_VALUE;\n                         }\n      * @param entry\n      * @return  full path for specified archive entry, or null if there's a gap.\n      */\n-    private String getPath(DumpArchiveEntry entry) {\n+    private String getPath(final DumpArchiveEntry entry) {\n         // build the stack of elements. It's possible that we're \n         // still missing an intermediate value and if so we\n         Stack<String> elements = new Stack<String>();\n      * @throws IOException on error\n      */\n     @Override\n-    public int read(byte[] buf, int off, int len) throws IOException {\n+    public int read(final byte[] buf, int off, int len) throws IOException {\n         int totalRead = 0;\n \n         if (hasHitEOF || isClosed || entryOffset >= entrySize) {\n      * @param length length of data\n      * @return whether the buffer seems to contain dump data\n      */\n-    public static boolean matches(byte[] buffer, int length) {\n+    public static boolean matches(final byte[] buffer, final int length) {\n         // do we have enough of the header?\n         if (length < 32) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n     private int firstrec;\n     private int ntrec;\n \n-    DumpArchiveSummary(byte[] buffer, ZipEncoding encoding) throws IOException {\n+    DumpArchiveSummary(final byte[] buffer, final ZipEncoding encoding) throws IOException {\n         dumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 4);\n         previousDumpDate = 1000L * DumpArchiveUtil.convert32(buffer, 8);\n         volume = DumpArchiveUtil.convert32(buffer, 12);\n      * Set dump date.\n      * @param dumpDate the dump date\n      */\n-    public void setDumpDate(Date dumpDate) {\n+    public void setDumpDate(final Date dumpDate) {\n         this.dumpDate = dumpDate.getTime();\n     }\n \n      * Set previous dump date.\n      * @param previousDumpDate the previous dump dat\n      */\n-    public void setPreviousDumpDate(Date previousDumpDate) {\n+    public void setPreviousDumpDate(final Date previousDumpDate) {\n         this.previousDumpDate = previousDumpDate.getTime();\n     }\n \n      * Set volume (tape) number.\n      * @param volume the volume number\n      */\n-    public void setVolume(int volume) {\n+    public void setVolume(final int volume) {\n         this.volume = volume;\n     }\n \n      * Set level.\n      * @param level the level\n      */\n-    public void setLevel(int level) {\n+    public void setLevel(final int level) {\n         this.level = level;\n     }\n \n      * Set dump label.\n      * @param label the label\n      */\n-    public void setLabel(String label) {\n+    public void setLabel(final String label) {\n         this.label = label;\n     }\n \n      * Set the last mountpoint.\n      * @param filesystem the last mountpoint\n      */\n-    public void setFilesystem(String filesystem) {\n+    public void setFilesystem(final String filesystem) {\n         this.filesys = filesystem;\n     }\n \n      * Set the device name.\n      * @param devname the device name\n      */\n-    public void setDevname(String devname) {\n+    public void setDevname(final String devname) {\n         this.devname = devname;\n     }\n \n      * Set the hostname.\n      * @param hostname the host name\n      */\n-    public void setHostname(String hostname) {\n+    public void setHostname(final String hostname) {\n         this.hostname = hostname;\n     }\n \n      * Set the miscellaneous flags.\n      * @param flags flags\n      */\n-    public void setFlags(int flags) {\n+    public void setFlags(final int flags) {\n         this.flags = flags;\n     }\n \n      * Set the inode of the first record.\n      * @param firstrec the first record\n      */\n-    public void setFirstRecord(int firstrec) {\n+    public void setFirstRecord(final int firstrec) {\n         this.firstrec = firstrec;\n     }\n \n      * Set the number of records per tape block.\n      * @param ntrec the number of records per tape block\n      */\n-    public void setNTRec(int ntrec) {\n+    public void setNTRec(final int ntrec) {\n         this.ntrec = ntrec;\n     }\n \n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (this == o) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n      * @param buffer buffer containing tape segment header\n      * @returns checksum\n      */\n-    public static int calculateChecksum(byte[] buffer) {\n+    public static int calculateChecksum(final byte[] buffer) {\n         int calc = 0;\n \n         for (int i = 0; i < 256; i++) {\n      *\n      * @param buffer\n      */\n-    public static final boolean verify(byte[] buffer) {\n+    public static final boolean verify(final byte[] buffer) {\n         // verify magic. for now only accept NFS_MAGIC.\n         int magic = convert32(buffer, 24);\n \n      *\n      * @param buffer\n      */\n-    public static final int getIno(byte[] buffer) {\n+    public static final int getIno(final byte[] buffer) {\n         return convert32(buffer, 20);\n     }\n \n      * @param offset\n      * @return the 8-byte entry as a long\n      */\n-    public static final long convert64(byte[] buffer, int offset) {\n+    public static final long convert64(final byte[] buffer, final int offset) {\n         long i = 0;\n         i += (((long) buffer[offset + 7]) << 56);\n         i += (((long) buffer[offset + 6] << 48) & 0x00FF000000000000L);\n      * @param offset\n      * @return the 4-byte entry as an int\n      */\n-    public static final int convert32(byte[] buffer, int offset) {\n+    public static final int convert32(final byte[] buffer, final int offset) {\n         int i = 0;\n         i = buffer[offset + 3] << 24;\n         i += (buffer[offset + 2] << 16) & 0x00FF0000;\n      * @param offset\n      * @return the 2-byte entry as an int\n      */\n-    public static final int convert16(byte[] buffer, int offset) {\n+    public static final int convert16(final byte[] buffer, final int offset) {\n         int i = 0;\n         i += (buffer[offset + 1] << 8) & 0x0000FF00;\n         i += buffer[offset] & 0x000000FF;\n     /**\n      * Decodes a byte array to a string.\n      */\n-    static String decode(ZipEncoding encoding, byte[] b, int offset, int len)\n+    static String decode(final ZipEncoding encoding, final byte[] b, final int offset, final int len)\n         throws IOException {\n         byte[] copy = new byte[len];\n         System.arraycopy(b, offset, copy, 0, len);\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/InvalidFormatException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/InvalidFormatException.java\n         super(\"there was an error decoding a tape segment\");\n     }\n \n-    public InvalidFormatException(long offset) {\n+    public InvalidFormatException(final long offset) {\n         super(\"there was an error decoding a tape segment header at offset \" +\n             offset + \".\");\n         this.offset = offset;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n     /**\n      * Constructor\n      */\n-    public TapeInputStream(InputStream in) {\n+    public TapeInputStream(final InputStream in) {\n         super(in);\n     }\n \n      * @throws IOException\n      *             there was an error reading additional blocks.\n      */\n-    public void resetBlockSize(int recsPerBlock, boolean isCompressed)\n+    public void resetBlockSize(final int recsPerBlock, final boolean isCompressed)\n         throws IOException {\n         this.isCompressed = isCompressed;\n \n      * record size\n      */\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, int off, final int len) throws IOException {\n         if ((len % recordSize) != 0) {\n             throw new IllegalArgumentException(\n                 \"all reads must be multiple of record size (\" + recordSize +\n      * record size\n      */\n     @Override\n-    public long skip(long len) throws IOException {\n+    public long skip(final long len) throws IOException {\n         if ((len % recordSize) != 0) {\n             throw new IllegalArgumentException(\n                 \"all reads must be multiple of record size (\" + recordSize +\n      *        This is an optimization for longer seeks.\n      * @return false if End-Of-File, else true\n      */\n-    private boolean readBlock(boolean decompress) throws IOException {\n+    private boolean readBlock(final boolean decompress) throws IOException {\n         boolean success = true;\n \n         if (in == null) {\n     /**\n      * Read buffer\n      */\n-    private boolean readFully(byte[] b, int off, int len)\n+    private boolean readFully(final byte[] b, final int off, final int len)\n         throws IOException {\n         int count = IOUtils.readFully(in, b, off, len);\n         if (count < len) {\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/UnsupportedCompressionAlgorithmException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/UnsupportedCompressionAlgorithmException.java\n         super(\"this file uses an unsupported compression algorithm.\");\n     }\n \n-    public UnsupportedCompressionAlgorithmException(String alg) {\n+    public UnsupportedCompressionAlgorithmException(final String alg) {\n         super(\"this file uses an unsupported compression algorithm: \" + alg +\n             \".\");\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n     private final Attributes manifestAttributes = null;\n     private final Certificate[] certificates = null;\n \n-    public JarArchiveEntry(ZipEntry entry) throws ZipException {\n+    public JarArchiveEntry(final ZipEntry entry) throws ZipException {\n         super(entry);\n     }\n \n-    public JarArchiveEntry(String name) {\n+    public JarArchiveEntry(final String name) {\n         super(name);\n     }\n \n-    public JarArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n+    public JarArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\n         super(entry);\n     }\n \n-    public JarArchiveEntry(JarEntry entry) throws ZipException {\n+    public JarArchiveEntry(final JarEntry entry) throws ZipException {\n         super(entry);\n \n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n      *            the number of bytes to check\n      * @return true, if this stream is a jar archive stream, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length ) {\n+    public static boolean matches(final byte[] signature, final int length ) {\n         return ZipArchiveInputStream.matches(signature, length);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n \n     // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n     @Override\n-    public void putArchiveEntry(ArchiveEntry ze) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry ze) throws IOException {\n         if (!jarMarkerAdded) {\n             ((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\n             jarMarkerAdded = true;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/AES256SHA256Decoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/AES256SHA256Decoder.java\n \n class AES256SHA256Decoder extends CoderBase {\n     @Override\n-    InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n+    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n             final Coder coder, final byte[] passwordBytes) throws IOException {\n         return new InputStream() {\n             private boolean isInitialized = false;\n             }\n                 \n             @Override\n-            public int read(byte[] b, int off, int len) throws IOException {\n+            public int read(final byte[] b, final int off, final int len) throws IOException {\n                 return init().read(b, off, len);\n             }\n                 \n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Archive.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Archive.java\n             + \" files and \" + streamMap;\n     }\n \n-    private static String lengthOf(long[] a) {\n+    private static String lengthOf(final long[] a) {\n         return a == null ? \"(null)\" : String.valueOf(a.length); \n     }\n \n-    private static String lengthOf(Object[] a) {\n+    private static String lengthOf(final Object[] a) {\n         return a == null ? \"(null)\" : String.valueOf(a.length); \n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedRandomAccessFileInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/BoundedRandomAccessFileInputStream.java\n     }\n \n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (bytesRemaining == 0) {\n             return -1;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/CLI.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/CLI.java\n     private static enum Mode {\n         LIST(\"Analysing\") {\n             @Override\n-            public void takeAction(SevenZFile archive, SevenZArchiveEntry entry) {\n+            public void takeAction(final SevenZFile archive, final SevenZArchiveEntry entry) {\n                 System.out.print(entry.getName());\n                 if (entry.isDirectory()) {\n                     System.out.print(\" dir\");\n                 }\n             }\n \n-            private String getContentMethods(SevenZArchiveEntry entry) {\n+            private String getContentMethods(final SevenZArchiveEntry entry) {\n                 StringBuilder sb = new StringBuilder();\n                 boolean first = true;\n                 for (SevenZMethodConfiguration m : entry.getContentMethods()) {\n         },\n         EXTRACT(\"Extracting\") {\n             @Override\n-            public void takeAction(SevenZFile archive, SevenZArchiveEntry entry) \n+            public void takeAction(final SevenZFile archive, final SevenZArchiveEntry entry) \n                 throws IOException {\n                 File outFile = new File(entry.getName());\n                 if (entry.isDirectory()) {\n         };\n \n         private final String message;\n-        private Mode(String message) {\n+        private Mode(final String message) {\n             this.message = message;\n         }\n         public String getMessage() {\n             throws IOException;\n     }        \n \n-    public static void main(String[] args) throws Exception {\n+    public static void main(final String[] args) throws Exception {\n         if (args.length == 0) {\n             usage();\n             return;\n         System.out.println(\"Parameters: archive-name [list|extract]\");\n     }\n \n-    private static Mode grabMode(String[] args) {\n+    private static Mode grabMode(final String[] args) {\n         if (args.length < 2) {\n             return Mode.LIST;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/CoderBase.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/CoderBase.java\n     /**\n      * @param acceptableOptions types that can be used as options for this codec.\n      */\n-    protected CoderBase(Class<?>... acceptableOptions) {\n+    protected CoderBase(final Class<?>... acceptableOptions) {\n         this.acceptableOptions = acceptableOptions;\n     }\n \n     /**\n      * @return whether this method can extract options from the given object.\n      */\n-    boolean canAcceptOptions(Object opts) {\n+    boolean canAcceptOptions(final Object opts) {\n         for (Class<?> c : acceptableOptions) {\n             if (c.isInstance(opts)) {\n                 return true;\n     /**\n      * @return property-bytes to write in a Folder block\n      */\n-    byte[] getOptionsAsProperties(Object options) {\n+    byte[] getOptionsAsProperties(final Object options) {\n         return NONE;\n     }\n \n     /**\n      * @return configuration options that have been used to create the given InputStream from the given Coder\n      */\n-    Object getOptionsFromCoder(Coder coder, InputStream in) {\n+    Object getOptionsFromCoder(final Coder coder, final InputStream in) {\n         return null;\n     }\n \n      * If the option represents a number, return its integer\n      * value, otherwise return the given default value.\n      */\n-    protected static int numberOptionOrDefault(Object options, int defaultValue) {\n+    protected static int numberOptionOrDefault(final Object options, final int defaultValue) {\n         return options instanceof Number ? ((Number) options).intValue() : defaultValue;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n             put(SevenZMethod.DELTA_FILTER, new DeltaDecoder());\n         }};\n \n-    static CoderBase findByMethod(SevenZMethod method) {\n+    static CoderBase findByMethod(final SevenZMethod method) {\n         return CODER_MAP.get(method);\n     }\n \n-    static InputStream addDecoder(final String archiveName, final InputStream is, long uncompressedLength,\n+    static InputStream addDecoder(final String archiveName, final InputStream is, final long uncompressedLength,\n             final Coder coder, final byte[] password) throws IOException {\n         CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));\n         if (cb == null) {\n     }\n     \n     static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\n-                                   Object options) throws IOException {\n+                                   final Object options) throws IOException {\n         CoderBase cb = findByMethod(method);\n         if (cb == null) {\n             throw new IOException(\"Unsupported compression method \" + method);\n \n     static class CopyDecoder extends CoderBase {\n         @Override\n-        InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n-                final Coder coder, byte[] password) throws IOException {\n+        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n+                final Coder coder, final byte[] password) throws IOException {\n             return in; \n         }\n         @Override\n \n     static class LZMADecoder extends CoderBase {\n         @Override\n-        InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n-                final Coder coder, byte[] password) throws IOException {\n+        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n+                final Coder coder, final byte[] password) throws IOException {\n             byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n     \n     static class BCJDecoder extends CoderBase {\n         private final FilterOptions opts;\n-        BCJDecoder(FilterOptions opts) {\n+        BCJDecoder(final FilterOptions opts) {\n             this.opts = opts;\n         }\n \n         @Override\n-        InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n-                final Coder coder, byte[] password) throws IOException {\n+        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n+                final Coder coder, final byte[] password) throws IOException {\n             try {\n                 return opts.getInputStream(in);\n             } catch (AssertionError e) {\n         }\n \n         @Override\n-        InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n+        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n                 final Coder coder, final byte[] password)\n             throws IOException {\n             final Inflater inflater = new Inflater(true);\n                 }\n \n                 @Override\n-                public int read(byte[] b, int off, int len) throws IOException {\n+                public int read(final byte[] b, final int off, final int len) throws IOException {\n                     return inflaterInputStream.read(b, off, len);\n                 }\n \n                 @Override\n-                public int read(byte[] b) throws IOException {\n+                public int read(final byte[] b) throws IOException {\n                     return inflaterInputStream.read(b);\n                 }\n \n             final DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater);\n             return new OutputStream() {\n                 @Override\n-                public void write(int b) throws IOException {\n+                public void write(final int b) throws IOException {\n                     deflaterOutputStream.write(b);\n                 }\n \n                 @Override\n-                public void write(byte[] b) throws IOException {\n+                public void write(final byte[] b) throws IOException {\n                     deflaterOutputStream.write(b);\n                 }\n \n                 @Override\n-                public void write(byte[] b, int off, int len) throws IOException {\n+                public void write(final byte[] b, final int off, final int len) throws IOException {\n                     deflaterOutputStream.write(b, off, len);\n                 }\n \n         }\n \n         @Override\n-        InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n+        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n                 final Coder coder, final byte[] password)\n                 throws IOException {\n             return new BZip2CompressorInputStream(in);\n     private static class DummyByteAddingInputStream extends FilterInputStream {\n         private boolean addDummyByte = true;\n \n-        private DummyByteAddingInputStream(InputStream in) {\n+        private DummyByteAddingInputStream(final InputStream in) {\n             super(in);\n         }\n \n         }\n \n         @Override\n-        public int read(byte[] b, int off, int len) throws IOException {\n+        public int read(final byte[] b, final int off, final int len) throws IOException {\n             int result = super.read(b, off, len);\n             if (result == -1 && addDummyByte) {\n                 addDummyByte = false;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/DeltaDecoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/DeltaDecoder.java\n     }\n \n     @Override\n-    InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n-            final Coder coder, byte[] password) throws IOException {\n+    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n+            final Coder coder, final byte[] password) throws IOException {\n         return new DeltaOptions(getOptionsFromCoder(coder)).getInputStream(in);\n     }\n \n     }\n \n     @Override\n-    byte[] getOptionsAsProperties(Object options) {\n+    byte[] getOptionsAsProperties(final Object options) {\n         return new byte[] {\n             (byte) (numberOptionOrDefault(options, 1) - 1)\n         };\n     }\n \n     @Override\n-    Object getOptionsFromCoder(Coder coder, InputStream in) {\n+    Object getOptionsFromCoder(final Coder coder, final InputStream in) {\n         return getOptionsFromCoder(coder);\n     }\n \n-    private int getOptionsFromCoder(Coder coder) {\n+    private int getOptionsFromCoder(final Coder coder) {\n         if (coder.properties == null || coder.properties.length == 0) {\n             return 1;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n         return 0;\n     }\n \n-    long getUnpackSizeForCoder(Coder coder) {\n+    long getUnpackSizeForCoder(final Coder coder) {\n         if (coders != null) {\n             for (int i = 0; i < coders.length; i++) {\n                 if (coders[i] == coder) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n     }\n \n     @Override\n-    InputStream decode(final String archiveName, final InputStream in, long uncompressedLength,\n-            final Coder coder, byte[] password) throws IOException {\n+    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n+            final Coder coder, final byte[] password) throws IOException {\n         try {\n             int dictionarySize = getDictionarySize(coder);\n             return new LZMA2InputStream(in, dictionarySize);\n     }\n \n     @Override\n-    byte[] getOptionsAsProperties(Object opts) {\n+    byte[] getOptionsAsProperties(final Object opts) {\n         int dictSize = getDictSize(opts);\n         int lead = Integer.numberOfLeadingZeros(dictSize);\n         int secondBit = (dictSize >>> (30 - lead)) - 2;\n     }\n \n     @Override\n-    Object getOptionsFromCoder(Coder coder, InputStream in) {\n+    Object getOptionsFromCoder(final Coder coder, final InputStream in) {\n         return getDictionarySize(coder);\n     }\n \n-    private int getDictSize(Object opts) {\n+    private int getDictSize(final Object opts) {\n         if (opts instanceof LZMA2Options) {\n             return ((LZMA2Options) opts).getDictSize();\n         }\n         return numberOptionOrDefault(opts);\n     }\n \n-    private int getDictionarySize(Coder coder) throws IllegalArgumentException {\n+    private int getDictionarySize(final Coder coder) throws IllegalArgumentException {\n         final int dictionarySizeBits = 0xff & coder.properties[0];\n         if ((dictionarySizeBits & (~0x3f)) != 0) {\n             throw new IllegalArgumentException(\"Unsupported LZMA2 property bits\");\n         return (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);\n     }\n \n-    private LZMA2Options getOptions(Object opts) throws IOException {\n+    private LZMA2Options getOptions(final Object opts) throws IOException {\n         if (opts instanceof LZMA2Options) {\n             return (LZMA2Options) opts;\n         }\n         return options;\n     }\n \n-    private int numberOptionOrDefault(Object opts) {\n+    private int numberOptionOrDefault(final Object opts) {\n         return numberOptionOrDefault(opts, LZMA2Options.DICT_SIZE_DEFAULT);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n      *\n      * @param name This entry's new name.\n      */\n-    public void setName(String name) {\n+    public void setName(final String name) {\n         this.name = name;\n     }\n \n      * Sets whether there is any content associated with this entry.\n      * @param hasStream whether there is any content associated with this entry.\n      */\n-    public void setHasStream(boolean hasStream) {\n+    public void setHasStream(final boolean hasStream) {\n         this.hasStream = hasStream;\n     }\n \n      *\n      * @param isDirectory True if this entry is a directory.\n      */\n-    public void setDirectory(boolean isDirectory) {\n+    public void setDirectory(final boolean isDirectory) {\n         this.isDirectory = isDirectory;\n     }\n     \n      * meaning it should delete the same file from a previous backup.\n      * @param isAntiItem true if it is an anti-item, false otherwise \n      */\n-    public void setAntiItem(boolean isAntiItem) {\n+    public void setAntiItem(final boolean isAntiItem) {\n         this.isAntiItem = isAntiItem;\n     }\n \n      * Sets whether this entry has got a creation date at all.\n      * @param hasCreationDate whether the entry has got a creation date\n      */\n-    public void setHasCreationDate(boolean hasCreationDate) {\n+    public void setHasCreationDate(final boolean hasCreationDate) {\n         this.hasCreationDate = hasCreationDate;\n     }\n     \n      * since 1 January 1601)\n      * @param ntfsCreationDate the creation date\n      */\n-    public void setCreationDate(long ntfsCreationDate) {\n+    public void setCreationDate(final long ntfsCreationDate) {\n         this.creationDate = ntfsCreationDate;\n     }\n     \n      * Sets the creation date,\n      * @param creationDate the creation date\n      */\n-    public void setCreationDate(Date creationDate) {\n+    public void setCreationDate(final Date creationDate) {\n         hasCreationDate = creationDate != null;\n         if (hasCreationDate) {\n             this.creationDate = javaTimeToNtfsTime(creationDate);\n      * @param hasLastModifiedDate whether this entry has got a last\n      * modified date at all\n      */\n-    public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\n+    public void setHasLastModifiedDate(final boolean hasLastModifiedDate) {\n         this.hasLastModifiedDate = hasLastModifiedDate;\n     }\n \n      * units since 1 January 1601)\n      * @param ntfsLastModifiedDate the last modified date\n      */\n-    public void setLastModifiedDate(long ntfsLastModifiedDate) {\n+    public void setLastModifiedDate(final long ntfsLastModifiedDate) {\n         this.lastModifiedDate = ntfsLastModifiedDate;\n     }\n     \n      * Sets the last modified date,\n      * @param lastModifiedDate the last modified date\n      */\n-    public void setLastModifiedDate(Date lastModifiedDate) {\n+    public void setLastModifiedDate(final Date lastModifiedDate) {\n         hasLastModifiedDate = lastModifiedDate != null;\n         if (hasLastModifiedDate) {\n             this.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n      * Sets whether this entry has got an access date at all.\n      * @param hasAcessDate whether this entry has got an access date at all.\n      */\n-    public void setHasAccessDate(boolean hasAcessDate) {\n+    public void setHasAccessDate(final boolean hasAcessDate) {\n         this.hasAccessDate = hasAcessDate;\n     }\n \n      * since 1 January 1601)\n      * @param ntfsAccessDate the access date\n      */\n-    public void setAccessDate(long ntfsAccessDate) {\n+    public void setAccessDate(final long ntfsAccessDate) {\n         this.accessDate = ntfsAccessDate;\n     }\n     \n      * Sets the access date,\n      * @param accessDate the access date\n      */\n-    public void setAccessDate(Date accessDate) {\n+    public void setAccessDate(final Date accessDate) {\n         hasAccessDate = accessDate != null;\n         if (hasAccessDate) {\n             this.accessDate = javaTimeToNtfsTime(accessDate);\n      * Sets whether this entry has windows attributes.\n      * @param hasWindowsAttributes whether this entry has windows attributes.\n      */\n-    public void setHasWindowsAttributes(boolean hasWindowsAttributes) {\n+    public void setHasWindowsAttributes(final boolean hasWindowsAttributes) {\n         this.hasWindowsAttributes = hasWindowsAttributes;\n     }\n \n      * Sets the windows attributes.\n      * @param windowsAttributes the windows attributes\n      */\n-    public void setWindowsAttributes(int windowsAttributes) {\n+    public void setWindowsAttributes(final int windowsAttributes) {\n         this.windowsAttributes = windowsAttributes;\n     }\n \n      * Sets whether this entry has got a crc.\n      * @param hasCrc whether this entry has got a crc.\n      */\n-    public void setHasCrc(boolean hasCrc) {\n+    public void setHasCrc(final boolean hasCrc) {\n         this.hasCrc = hasCrc;\n     }\n \n      * @param crc the CRC\n      */\n     @Deprecated\n-    public void setCrc(int crc) {\n+    public void setCrc(final int crc) {\n         this.crc = crc;\n     }\n \n      * @since Compress 1.7\n      * @param crc the CRC\n      */\n-    public void setCrcValue(long crc) {\n+    public void setCrcValue(final long crc) {\n         this.crc = crc;\n     }\n \n      * @param crc the CRC\n      */\n     @Deprecated\n-    void setCompressedCrc(int crc) {\n+    void setCompressedCrc(final int crc) {\n         this.compressedCrc = crc;\n     }\n \n      * @since Compress 1.7\n      * @param crc the CRC\n      */\n-    void setCompressedCrcValue(long crc) {\n+    void setCompressedCrcValue(final long crc) {\n         this.compressedCrc = crc;\n     }\n \n      *\n      * @param size This entry's new file size.\n      */\n-    public void setSize(long size) {\n+    public void setSize(final long size) {\n         this.size = size;\n     }\n \n      *\n      * @param size This entry's new compressed file size.\n      */\n-    void setCompressedSize(long size) {\n+    void setCompressedSize(final long size) {\n         this.compressedSize = size;\n     }\n \n      * @param methods the methods to use for the content\n      * @since 1.8\n      */\n-    public void setContentMethods(Iterable<? extends SevenZMethodConfiguration> methods) {\n+    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\n         if (methods != null) {\n             LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\n             for (SevenZMethodConfiguration m : methods) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n         return Arrays.asList(archive.files);\n     }\n     \n-    private Archive readHeaders(byte[] password) throws IOException {\n+    private Archive readHeaders(final byte[] password) throws IOException {\n         final byte[] signature = new byte[6];\n         file.readFully(signature);\n         if (!Arrays.equals(signature, sevenZSignature)) {\n     }\n     \n     private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\n-                                              byte[] password) throws IOException {\n+                                              final byte[] password) throws IOException {\n         readStreamsInfo(header, archive);\n         \n         // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n     }\n \n     private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n-                final int firstPackStreamIndex, SevenZArchiveEntry entry) throws IOException {\n+                final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n         file.seek(folderOffset);\n         InputStream inputStreamStack =\n             new BufferedInputStream(\n      * @throws IOException\n      *             if an I/O error has occurred\n      */\n-    public int read(byte[] b) throws IOException {\n+    public int read(final byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n     \n      * @throws IOException\n      *             if an I/O error has occurred\n      */\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         return getCurrentStream().read(b, off, len);\n     }\n     \n      * @return true, if this is the signature of a 7z archive.\n      * @since 1.8\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < sevenZSignature.length) {\n             return false;\n         }\n         return true;\n     }\n \n-    private static long skipBytesFully(DataInput input, long bytesToSkip) throws IOException {\n+    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n         if (bytesToSkip < 1) {\n             return 0;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethod.java\n \n     private final byte[] id;\n \n-    private SevenZMethod(byte[] id) {\n+    private SevenZMethod(final byte[] id) {\n         this.id = id;\n     }\n \n         return copy;\n     }\n \n-    static SevenZMethod byId(byte[] id) {\n+    static SevenZMethod byId(final byte[] id) {\n         for (SevenZMethod m : SevenZMethod.class.getEnumConstants()) {\n             if (Arrays.equals(m.id, id)) {\n                 return m;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethodConfiguration.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethodConfiguration.java\n      * Doesn't configure any additional options.\n      * @param method the method to use\n      */\n-    public SevenZMethodConfiguration(SevenZMethod method) {\n+    public SevenZMethodConfiguration(final SevenZMethod method) {\n         this(method, null);\n     }\n \n      * @param options the options to use\n      * @throws IllegalArgumentException if the method doesn't understand the options specified.\n      */\n-    public SevenZMethodConfiguration(SevenZMethod method, Object options) {\n+    public SevenZMethodConfiguration(final SevenZMethod method, final Object options) {\n         this.method = method;\n         this.options = options;\n         if (options != null && !Coders.findByMethod(method).canAcceptOptions(options)) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n      * to {@link #setContentMethods}.</p>\n      * @param method the default compression method\n      */\n-    public void setContentCompression(SevenZMethod method) {\n+    public void setContentCompression(final SevenZMethod method) {\n         setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(method)));\n     }\n \n      * @since 1.8\n      * @param methods the default (compression) methods\n      */\n-    public void setContentMethods(Iterable<? extends SevenZMethodConfiguration> methods) {\n+    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\n         this.contentMethods = reverse(methods);\n     }\n \n         };\n     }\n \n-    private Iterable<? extends SevenZMethodConfiguration> getContentMethods(SevenZArchiveEntry entry) {\n+    private Iterable<? extends SevenZMethodConfiguration> getContentMethods(final SevenZArchiveEntry entry) {\n         Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();\n         return ms == null ? contentMethods : ms;\n     }\n         header.write(NID.kEnd);\n     }\n     \n-    private void writeFolder(final DataOutput header, SevenZArchiveEntry entry) throws IOException {\n+    private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry) throws IOException {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int numCoders = 0;\n         for (SevenZMethodConfiguration m : getContentMethods(entry)) {\n         }\n     }\n \n-    private void writeSingleCodec(SevenZMethodConfiguration m, OutputStream bos) throws IOException {\n+    private void writeSingleCodec(final SevenZMethodConfiguration m, final OutputStream bos) throws IOException {\n         byte[] id = m.getMethod().getId();\n         byte[] properties = Coders.findByMethod(m.getMethod())\n             .getOptionsAsProperties(m.getOptions());\n         }\n     }\n \n-    private static <T> Iterable<T> reverse(Iterable<T> i) {\n+    private static <T> Iterable<T> reverse(final Iterable<T> i) {\n         LinkedList<T> l = new LinkedList<T>();\n         for (T t : i) {\n             l.addFirst(t);\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n      *\n      * @param name the entry name\n      */\n-    public TarArchiveEntry(String name) {\n+    public TarArchiveEntry(final String name) {\n         this(name, false);\n     }\n \n      *\n      * @since 1.1\n      */\n-    public TarArchiveEntry(String name, boolean preserveLeadingSlashes) {\n+    public TarArchiveEntry(String name, final boolean preserveLeadingSlashes) {\n         this();\n \n         this.preserveLeadingSlashes = preserveLeadingSlashes;\n      * @param name the entry name\n      * @param linkFlag the entry link flag.\n      */\n-    public TarArchiveEntry(String name, byte linkFlag) {\n+    public TarArchiveEntry(final String name, final byte linkFlag) {\n         this(name, linkFlag, false);\n     }\n \n      *\n      * @since 1.5\n      */\n-    public TarArchiveEntry(String name, byte linkFlag, boolean preserveLeadingSlashes) {\n+    public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes) {\n         this(name, preserveLeadingSlashes);\n         this.linkFlag = linkFlag;\n         if (linkFlag == LF_GNUTYPE_LONGNAME) {\n      *\n      * @param file The file that the entry represents.\n      */\n-    public TarArchiveEntry(File file) {\n+    public TarArchiveEntry(final File file) {\n         this(file, file.getPath());\n     }\n \n      * @param file The file that the entry represents.\n      * @param fileName the name to be used for the entry.\n      */\n-    public TarArchiveEntry(File file, String fileName) {\n+    public TarArchiveEntry(final File file, final String fileName) {\n         String normalizedName = normalizeFileName(fileName, false);\n         this.file = file;\n \n      * @param headerBuf The header bytes from a tar archive entry.\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n      */\n-    public TarArchiveEntry(byte[] headerBuf) {\n+    public TarArchiveEntry(final byte[] headerBuf) {\n         this();\n         parseTarHeader(headerBuf);\n     }\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n      * @throws IOException on error\n      */\n-    public TarArchiveEntry(byte[] headerBuf, ZipEncoding encoding)\n+    public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\n         throws IOException {\n         this();\n         parseTarHeader(headerBuf, encoding);\n      * @param it Entry to be checked for equality.\n      * @return True if the entries are equal.\n      */\n-    public boolean equals(TarArchiveEntry it) {\n+    public boolean equals(final TarArchiveEntry it) {\n         return getName().equals(it.getName());\n     }\n \n      * @return True if the entries are equal.\n      */\n     @Override\n-    public boolean equals(Object it) {\n+    public boolean equals(final Object it) {\n         if (it == null || getClass() != it.getClass()) {\n             return false;\n         }\n      * @param desc Entry to be checked as a descendent of this.\n      * @return True if entry is a descendant of this.\n      */\n-    public boolean isDescendent(TarArchiveEntry desc) {\n+    public boolean isDescendent(final TarArchiveEntry desc) {\n         return desc.getName().startsWith(getName());\n     }\n \n      *\n      * @param name This entry's new name.\n      */\n-    public void setName(String name) {\n+    public void setName(final String name) {\n         this.name = normalizeFileName(name, this.preserveLeadingSlashes);\n     }\n \n      *\n      * @param mode the mode for this entry\n      */\n-    public void setMode(int mode) {\n+    public void setMode(final int mode) {\n         this.mode = mode;\n     }\n \n      *\n      * @since 1.1\n      */\n-    public void setLinkName(String link) {\n+    public void setLinkName(final String link) {\n         this.linkName = link;\n     }\n \n      *\n      * @param userId This entry's new user id.\n      */\n-    public void setUserId(int userId) {\n+    public void setUserId(final int userId) {\n         setUserId((long) userId);\n     }\n \n      * @param userId This entry's new user id.\n      * @since 1.10\n      */\n-    public void setUserId(long userId) {\n+    public void setUserId(final long userId) {\n         this.userId = userId;\n     }\n \n      *\n      * @param groupId This entry's new group id.\n      */\n-    public void setGroupId(int groupId) {\n+    public void setGroupId(final int groupId) {\n         setGroupId((long) groupId);\n     }\n \n      * @since 1.10\n      * @param groupId This entry's new group id.\n      */\n-    public void setGroupId(long groupId) {\n+    public void setGroupId(final long groupId) {\n         this.groupId = groupId;\n     }\n \n      *\n      * @param userName This entry's new user name.\n      */\n-    public void setUserName(String userName) {\n+    public void setUserName(final String userName) {\n         this.userName = userName;\n     }\n \n      *\n      * @param groupName This entry's new group name.\n      */\n-    public void setGroupName(String groupName) {\n+    public void setGroupName(final String groupName) {\n         this.groupName = groupName;\n     }\n \n      * @param userId This entry's new user id.\n      * @param groupId This entry's new group id.\n      */\n-    public void setIds(int userId, int groupId) {\n+    public void setIds(final int userId, final int groupId) {\n         setUserId(userId);\n         setGroupId(groupId);\n     }\n      * @param userName This entry's new user name.\n      * @param groupName This entry's new group name.\n      */\n-    public void setNames(String userName, String groupName) {\n+    public void setNames(final String userName, final String groupName) {\n         setUserName(userName);\n         setGroupName(groupName);\n     }\n      *\n      * @param time This entry's new modification time.\n      */\n-    public void setModTime(long time) {\n+    public void setModTime(final long time) {\n         modTime = time / MILLIS_PER_SECOND;\n     }\n \n      *\n      * @param time This entry's new modification time.\n      */\n-    public void setModTime(Date time) {\n+    public void setModTime(final Date time) {\n         modTime = time.getTime() / MILLIS_PER_SECOND;\n     }\n \n      * @param size This entry's new file size.\n      * @throws IllegalArgumentException if the size is &lt; 0.\n      */\n-    public void setSize(long size) {\n+    public void setSize(final long size) {\n         if (size < 0){\n             throw new IllegalArgumentException(\"Size is out of range: \"+size);\n         }\n      * @throws IllegalArgumentException if the devNo is &lt; 0.\n      * @since 1.4\n      */\n-    public void setDevMajor(int devNo) {\n+    public void setDevMajor(final int devNo) {\n         if (devNo < 0){\n             throw new IllegalArgumentException(\"Major device number is out of \"\n                                                + \"range: \" + devNo);\n      * @throws IllegalArgumentException if the devNo is &lt; 0.\n      * @since 1.4\n      */\n-    public void setDevMinor(int devNo) {\n+    public void setDevMinor(final int devNo) {\n         if (devNo < 0){\n             throw new IllegalArgumentException(\"Minor device number is out of \"\n                                                + \"range: \" + devNo);\n      *\n      * @param outbuf The tar entry header buffer to fill in.\n      */\n-    public void writeEntryHeader(byte[] outbuf) {\n+    public void writeEntryHeader(final byte[] outbuf) {\n         try {\n             writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n         } catch (IOException ex) {\n      * @since 1.4\n      * @throws IOException on error\n      */\n-    public void writeEntryHeader(byte[] outbuf, ZipEncoding encoding,\n-                                 boolean starMode) throws IOException {\n+    public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding,\n+                                 final boolean starMode) throws IOException {\n         int offset = 0;\n \n         offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n         TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n     }\n \n-    private int writeEntryHeaderField(long value, byte[] outbuf, int offset,\n-                                      int length, boolean starMode) {\n+    private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset,\n+                                      final int length, final boolean starMode) {\n         if (!starMode && (value < 0\n                           || value >= 1l << 3 * (length - 1))) {\n             // value doesn't fit into field when written as octal\n      * @param header The tar entry header buffer to get information from.\n      * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n      */\n-    public void parseTarHeader(byte[] header) {\n+    public void parseTarHeader(final byte[] header) {\n         try {\n             parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n         } catch (IOException ex) {\n      * have an invalid format\n      * @throws IOException on error\n      */\n-    public void parseTarHeader(byte[] header, ZipEncoding encoding)\n+    public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\n         throws IOException {\n         parseTarHeader(header, encoding, false);\n     }\n \n-    private void parseTarHeader(byte[] header, ZipEncoding encoding,\n+    private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\n                                 final boolean oldStyle)\n         throws IOException {\n         int offset = 0;\n      * turns path separators into forward slahes.\n      */\n     private static String normalizeFileName(String fileName,\n-                                            boolean preserveLeadingSlashes) {\n+                                            final boolean preserveLeadingSlashes) {\n         String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n \n         if (osname != null) {\n      * @param header The tar entry header buffer to evaluate the format for.\n      * @return format type\n      */\n-    private int evaluateType(byte[] header) {\n+    private int evaluateType(final byte[] header) {\n         if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {\n             return FORMAT_OLDGNU;\n         }\n         return 0;\n     }\n \n-    void fillGNUSparse0xData(Map<String, String> headers) {\n+    void fillGNUSparse0xData(final Map<String, String> headers) {\n         paxGNUSparse = true;\n         realSize = Integer.parseInt(headers.get(\"GNU.sparse.size\"));\n         if (headers.containsKey(\"GNU.sparse.name\")) {\n         }\n     }\n \n-    void fillGNUSparse1xData(Map<String, String> headers) {\n+    void fillGNUSparse1xData(final Map<String, String> headers) {\n         paxGNUSparse = true;\n         realSize = Integer.parseInt(headers.get(\"GNU.sparse.realsize\"));\n         name = headers.get(\"GNU.sparse.name\");\n     }\n \n-    void fillStarSparseData(Map<String, String> headers) {\n+    void fillStarSparseData(final Map<String, String> headers) {\n         starSparse = true;\n         if (headers.containsKey(\"SCHILY.realsize\")) {\n             realSize = Long.parseLong(headers.get(\"SCHILY.realsize\"));\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n      * Constructor for TarInputStream.\n      * @param is the input stream to use\n      */\n-    public TarArchiveInputStream(InputStream is) {\n+    public TarArchiveInputStream(final InputStream is) {\n         this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveInputStream(InputStream is, String encoding) {\n+    public TarArchiveInputStream(final InputStream is, final String encoding) {\n         this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE,\n              encoding);\n     }\n      * @param is the input stream to use\n      * @param blockSize the block size to use\n      */\n-    public TarArchiveInputStream(InputStream is, int blockSize) {\n+    public TarArchiveInputStream(final InputStream is, final int blockSize) {\n         this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);\n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveInputStream(InputStream is, int blockSize,\n-                                 String encoding) {\n+    public TarArchiveInputStream(final InputStream is, final int blockSize,\n+                                 final String encoding) {\n         this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n     }\n \n      * @param blockSize the block size to use\n      * @param recordSize the record size to use\n      */\n-    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n+    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {\n         this(is, blockSize, recordSize, null);      \n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\n-                                 String encoding) {\n+    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize,\n+                                 final String encoding) {\n         this.is = is;\n         this.hasHitEOF = false;\n         this.encoding = encoding;\n      * @param markLimit The limit to mark.\n      */\n     @Override\n-    public void mark(int markLimit) {\n+    public void mark(final int markLimit) {\n     }\n \n     /**\n      * @param record The record data to check.\n      * @return true if the record data is an End of Archive\n      */\n-    protected boolean isEOFRecord(byte[] record) {\n+    protected boolean isEOFRecord(final byte[] record) {\n         return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n     }\n     \n     // NOTE, using a Map here makes it impossible to ever support GNU\n     // sparse files using the PAX Format 0.0, see\n     // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n-    Map<String, String> parsePaxHeaders(InputStream i)\n+    Map<String, String> parsePaxHeaders(final InputStream i)\n         throws IOException {\n         Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n         // Format is \"length keyword=value\\n\";\n         return headers;\n     }\n \n-    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n+    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers) {\n         /*\n          * The following headers are defined for Pax.\n          * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n      * @throws IOException on error\n      */\n     @Override\n-    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n+    public int read(final byte[] buf, final int offset, int numToRead) throws IOException {\n     \tint totalRead = 0;\n \n         if (hasHitEOF || isDirectory() || entryOffset >= entrySize) {\n      * <p>May return false if the current entry is a sparse file.</p>\n      */\n     @Override\n-    public boolean canReadEntryData(ArchiveEntry ae) {\n+    public boolean canReadEntryData(final ArchiveEntry ae) {\n         if (ae instanceof TarArchiveEntry) {\n             TarArchiveEntry te = (TarArchiveEntry) ae;\n             return !te.isSparse();\n         return currEntry;\n     }\n \n-    protected final void setCurrentEntry(TarArchiveEntry e) {\n+    protected final void setCurrentEntry(final TarArchiveEntry e) {\n         currEntry = e;\n     }\n \n         return hasHitEOF;\n     }\n \n-    protected final void setAtEOF(boolean b) {\n+    protected final void setAtEOF(final boolean b) {\n         hasHitEOF = b;\n     }\n \n      *            the number of bytes to check\n      * @return true, if this stream is a tar archive stream, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n      * Constructor for TarInputStream.\n      * @param os the output stream to use\n      */\n-    public TarArchiveOutputStream(OutputStream os) {\n+    public TarArchiveOutputStream(final OutputStream os) {\n         this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveOutputStream(OutputStream os, String encoding) {\n+    public TarArchiveOutputStream(final OutputStream os, final String encoding) {\n         this(os, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);\n     }\n \n      * @param os the output stream to use\n      * @param blockSize the block size to use\n      */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n+    public TarArchiveOutputStream(final OutputStream os, final int blockSize) {\n         this(os, blockSize, TarConstants.DEFAULT_RCDSIZE);\n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize,\n-                                  String encoding) {\n+    public TarArchiveOutputStream(final OutputStream os, final int blockSize,\n+                                  final String encoding) {\n         this(os, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);\n     }\n \n      * @param blockSize the block size to use\n      * @param recordSize the record size to use\n      */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n+    public TarArchiveOutputStream(final OutputStream os, final int blockSize, final int recordSize) {\n         this(os, blockSize, recordSize, null);\n     }\n \n      * @param encoding name of the encoding to use for file names\n      * @since 1.4\n      */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize,\n-                                  int recordSize, String encoding) {\n+    public TarArchiveOutputStream(final OutputStream os, final int blockSize,\n+                                  final int recordSize, final String encoding) {\n         out = new CountingOutputStream(os);\n         this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n      * Default is LONGFILE_ERROR.\n      * @param longFileMode the mode to use\n      */\n-    public void setLongFileMode(int longFileMode) {\n+    public void setLongFileMode(final int longFileMode) {\n         this.longFileMode = longFileMode;\n     }\n \n      * @param bigNumberMode the mode to use\n      * @since 1.4\n      */\n-    public void setBigNumberMode(int bigNumberMode) {\n+    public void setBigNumberMode(final int bigNumberMode) {\n         this.bigNumberMode = bigNumberMode;\n     }\n \n      * @since 1.4\n      * @param b whether to add a PAX extension header for non-ASCII file names.\n      */\n-    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n+    public void setAddPaxHeadersForNonAsciiNames(final boolean b) {\n         addPaxHeadersForNonAsciiNames = b;\n     }\n \n      * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n      */\n     @Override\n-    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n      * @throws IOException on error\n      */\n     @Override\n-    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n+    public void write(final byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n         if (!haveUnclosedEntry) {\n             throw new IllegalStateException(\"No current tar entry\");\n         }\n      * Writes a PAX extended header with the given map as contents.\n      * @since 1.4\n      */\n-    void writePaxHeaders(TarArchiveEntry entry,\n-                         String entryName,\n-                         Map<String, String> headers) throws IOException {\n+    void writePaxHeaders(final TarArchiveEntry entry,\n+                         final String entryName,\n+                         final Map<String, String> headers) throws IOException {\n         String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n         if (name.length() >= TarConstants.NAMELEN) {\n             name = name.substring(0, TarConstants.NAMELEN - 1);\n         closeArchiveEntry();\n     }\n \n-    private String stripTo7Bits(String name) {\n+    private String stripTo7Bits(final String name) {\n         final int length = name.length();\n         StringBuilder result = new StringBuilder(length);\n         for (int i = 0; i < length; i++) {\n      * @return true if the character could lead to problems when used\n      * inside a TarArchiveEntry name for a PAX header.\n      */\n-    private boolean shouldBeReplaced(char c) {\n+    private boolean shouldBeReplaced(final char c) {\n         return c == 0 // would be read as Trailing null\n             || c == '/' // when used as last character TAE will consider the PAX header a directory\n             || c == '\\\\'; // same as '/' as slashes get \"normalized\" on Windows\n     }\n \n     @Override\n-    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n+    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName)\n             throws IOException {\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n      * @param record The record data to write to the archive.\n      * @throws IOException on error\n      */\n-    private void writeRecord(byte[] record) throws IOException {\n+    private void writeRecord(final byte[] record) throws IOException {\n         if (record.length != recordSize) {\n             throw new IOException(\"record to write has length '\"\n                                   + record.length\n      * @param offset The offset of the record data within buf.\n      * @throws IOException on error\n      */\n-    private void writeRecord(byte[] buf, int offset) throws IOException {\n+    private void writeRecord(final byte[] buf, final int offset) throws IOException {\n  \n         if (offset + recordSize > buf.length) {\n             throw new IOException(\"record has length '\" + buf.length\n         }\n     }\n \n-    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\n-                                            TarArchiveEntry entry) {\n+    private void addPaxHeadersForBigNumbers(final Map<String, String> paxHeaders,\n+                                            final TarArchiveEntry entry) {\n         addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                  TarConstants.MAXSIZE);\n         addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(),\n         failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n     }\n \n-    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders,\n-                                          String header, long value,\n-                                          long maxValue) {\n+    private void addPaxHeaderForBigNumber(final Map<String, String> paxHeaders,\n+                                          final String header, final long value,\n+                                          final long maxValue) {\n         if (value < 0 || value > maxValue) {\n             paxHeaders.put(header, String.valueOf(value));\n         }\n     }\n \n-    private void failForBigNumbers(TarArchiveEntry entry) {\n+    private void failForBigNumbers(final TarArchiveEntry entry) {\n         failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\n         failForBigNumberWithPosixMessage(\"group id\", entry.getLongGroupId(), TarConstants.MAXID);\n         failForBigNumber(\"last modification time\",\n                          TarConstants.MAXID);\n     }\n \n-    private void failForBigNumber(String field, long value, long maxValue) {\n+    private void failForBigNumber(final String field, final long value, final long maxValue) {\n         failForBigNumber(field, value, maxValue, \"\");\n     }\n \n-    private void failForBigNumberWithPosixMessage(String field, long value, long maxValue) {\n+    private void failForBigNumberWithPosixMessage(final String field, final long value, final long maxValue) {\n         failForBigNumber(field, value, maxValue, \" Use STAR or POSIX extensions to overcome this limit\");\n     }\n \n-    private void failForBigNumber(String field, long value, long maxValue, String additionalMsg) {\n+    private void failForBigNumber(final String field, final long value, final long maxValue, final String additionalMsg) {\n         if (value < 0 || value > maxValue) {\n             throw new RuntimeException(field + \" '\" + value\n                     + \"' is too big ( > \"\n      * @param fieldName the name of the field\n      * @return whether a pax header has been written.\n      */\n-    private boolean handleLongName(TarArchiveEntry entry , String name,\n-                                   Map<String, String> paxHeaders,\n-                                   String paxHeaderName, byte linkType, String fieldName)\n+    private boolean handleLongName(final TarArchiveEntry entry , final String name,\n+                                   final Map<String, String> paxHeaders,\n+                                   final String paxHeaderName, final byte linkType, final String fieldName)\n         throws IOException {\n         final ByteBuffer encodedName = zipEncoding.encode(name);\n         final int len = encodedName.limit() - encodedName.position();\n         return false;\n     }\n \n-    private void transferModTime(TarArchiveEntry from, TarArchiveEntry to) {\n+    private void transferModTime(final TarArchiveEntry from, final TarArchiveEntry to) {\n         Date fromModTime = from.getModTime();\n         long fromModTimeSeconds = fromModTime.getTime() / 1000;\n         if (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java\n      * @param headerBuf The header bytes from a tar archive entry.\n      * @throws IOException on unknown format\n      */\n-    public TarArchiveSparseEntry(byte[] headerBuf) throws IOException {\n+    public TarArchiveSparseEntry(final byte[] headerBuf) throws IOException {\n         int offset = 0;\n         offset += SPARSELEN_GNU_SPARSE;\n         isExtended = TarUtils.parseBoolean(headerBuf, offset);\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n      */\n     static final ZipEncoding FALLBACK_ENCODING = new ZipEncoding() {\n             @Override\n-            public boolean canEncode(String name) { return true; }\n+            public boolean canEncode(final String name) { return true; }\n \n             @Override\n-            public ByteBuffer encode(String name) {\n+            public ByteBuffer encode(final String name) {\n                 final int length = name.length();\n                 byte[] buf = new byte[length];\n \n             }\n \n             @Override\n-            public String decode(byte[] buffer) {\n+            public String decode(final byte[] buffer) {\n                 final int length = buffer.length;\n                 StringBuilder result = new StringBuilder(length);\n \n     }\n \n     // Helper method to generate the exception message\n-    private static String exceptionMessage(byte[] buffer, final int offset,\n-            final int length, int current, final byte currentByte) {\n+    private static String exceptionMessage(final byte[] buffer, final int offset,\n+            final int length, final int current, final byte currentByte) {\n         // default charset is good enough for an exception message,\n         //\n         // the alternative was to modify parseOctal and\n      * @param length The maximum number of bytes to parse.\n      * @return The entry name.\n      */\n-    public static String parseName(byte[] buffer, final int offset, final int length) {\n+    public static String parseName(final byte[] buffer, final int offset, final int length) {\n         try {\n             return parseName(buffer, offset, length, DEFAULT_ENCODING);\n         } catch (IOException ex) {\n      * @return The entry name.\n      * @throws IOException on error\n      */\n-    public static String parseName(byte[] buffer, final int offset,\n+    public static String parseName(final byte[] buffer, final int offset,\n                                    final int length,\n                                    final ZipEncoding encoding)\n         throws IOException {\n      * @param length The maximum number of header bytes to copy.\n      * @return The updated offset, i.e. offset + length\n      */\n-    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n+    public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n         try {\n             return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n         } catch (IOException ex) {\n      * @return The updated offset, i.e. offset + length\n      * @throws IOException on error\n      */\n-    public static int formatNameBytes(String name, byte[] buf, final int offset,\n+    public static int formatNameBytes(final String name, final byte[] buf, final int offset,\n                                       final int length,\n                                       final ZipEncoding encoding)\n         throws IOException {\n      * @param length length of buffer to fill\n      * @throws IllegalArgumentException if the value will not fit in the buffer\n      */\n-    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n+    public static void formatUnsignedOctalString(final long value, final byte[] buffer,\n             final int offset, final int length) {\n         int remaining = length;\n         remaining--;\n      * @return The updated offset, i.e offset+length\n      * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n      */\n-    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n+    public static int formatOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n \n         int idx=length-2; // For space and trailing null\n         formatUnsignedOctalString(value, buf, offset, idx);\n      * @return The updated offset\n      * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n      */\n-    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n+    public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n \n         int idx=length-1; // For space\n \n      * @since 1.4\n      */\n     public static int formatLongOctalOrBinaryBytes(\n-        final long value, byte[] buf, final int offset, final int length) {\n+        final long value, final byte[] buf, final int offset, final int length) {\n \n         // Check whether we are dealing with UID/GID or SIZE field\n         final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n         return offset + length;\n     }\n \n-    private static void formatLongBinary(final long value, byte[] buf,\n+    private static void formatLongBinary(final long value, final byte[] buf,\n                                          final int offset, final int length,\n                                          final boolean negative) {\n         final int bits = (length - 1) * 8;\n         }\n     }\n \n-    private static void formatBigIntegerBinary(final long value, byte[] buf,\n+    private static void formatBigIntegerBinary(final long value, final byte[] buf,\n                                                final int offset,\n                                                final int length,\n                                                final boolean negative) {\n      * @return The updated value of offset, i.e. offset+length\n      * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n      */\n-    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n+    public static int formatCheckSumOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n \n         int idx=length-2; // for NUL and space\n         formatUnsignedOctalString(value, buf, offset, idx);\n      * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n      * @since 1.5\n      */\n-    public static boolean verifyCheckSum(byte[] header) {\n+    public static boolean verifyCheckSum(final byte[] header) {\n         long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n         long unsignedSum = 0;\n         long signedSum = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n      * @param len The length of the encoded filename or commentin\n      * <code>bytes</code>.\n      */\n-    protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) {\n+    protected AbstractUnicodeExtraField(final String text, final byte[] bytes, final int off, final int len) {\n         CRC32 crc32 = new CRC32();\n         crc32.update(bytes, off, len);\n         nameCRC32 = crc32.getValue();\n      * @param bytes The encoded of the filename or comment in the zip\n      * file.\n      */\n-    protected AbstractUnicodeExtraField(String text, byte[] bytes) {\n+    protected AbstractUnicodeExtraField(final String text, final byte[] bytes) {\n         this(text, bytes, 0, bytes.length);\n     }\n \n      * @param nameCRC32 The CRC32 checksum of the filename as encoded\n      *         in the central directory of the zip file to set.\n      */\n-    public void setNameCRC32(long nameCRC32) {\n+    public void setNameCRC32(final long nameCRC32) {\n         this.nameCRC32 = nameCRC32;\n         data = null;\n     }\n     /**\n      * @param unicodeName The UTF-8 encoded name to set.\n      */\n-    public void setUnicodeName(byte[] unicodeName) {\n+    public void setUnicodeName(final byte[] unicodeName) {\n         if (unicodeName != null) {\n             this.unicodeName = new byte[unicodeName.length];\n             System.arraycopy(unicodeName, 0, this.unicodeName, 0,\n     }\n \n     @Override\n-    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n+    public void parseFromLocalFileData(final byte[] buffer, final int offset, final int length)\n         throws ZipException {\n \n         if (length < 5) {\n      * same data in central directory and local file data.\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n-                                              int length)\n+    public void parseFromCentralDirectoryData(final byte[] buffer, final int offset,\n+                                              final int length)\n         throws ZipException {\n         parseFromLocalFileData(buffer, offset, length);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n      * Set the user id.\n      * @param uid the user id\n      */\n-    public void setUserId(int uid) {\n+    public void setUserId(final int uid) {\n         this.uid = uid;\n     }\n \n      * Set the group id.\n      * @param gid the group id\n      */\n-    public void setGroupId(int gid) {\n+    public void setGroupId(final int gid) {\n         this.gid = gid;\n     }\n \n      * @param name Name of the file this entry links to, empty String\n      *             if it is not a symbolic link.\n      */\n-    public void setLinkedFile(String name) {\n+    public void setLinkedFile(final String name) {\n         link = name;\n         mode = getMode(mode);\n     }\n      * File mode of this file.\n      * @param mode the file mode\n      */\n-    public void setMode(int mode) {\n+    public void setMode(final int mode) {\n         this.mode = getMode(mode);\n     }\n \n      * Indicate whether this entry is a directory.\n      * @param dirFlag if true, this entry is a directory\n      */\n-    public void setDirectory(boolean dirFlag) {\n+    public void setDirectory(final boolean dirFlag) {\n         this.dirFlag = dirFlag;\n         mode = getMode(mode);\n     }\n      * @throws ZipException on error\n      */\n     @Override\n-    public void parseFromLocalFileData(byte[] data, int offset, int length)\n+    public void parseFromLocalFileData(final byte[] data, final int offset, final int length)\n         throws ZipException {\n \n         long givenChecksum = ZipLong.getValue(data, offset);\n      * same data in central directory and local file data.\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n-                                              int length)\n+    public void parseFromCentralDirectoryData(final byte[] buffer, final int offset,\n+                                              final int length)\n         throws ZipException {\n         parseFromLocalFileData(buffer, offset, length);\n     }\n      * @param mode the mode\n      * @return the type with the mode\n      */\n-    protected int getMode(int mode) {\n+    protected int getMode(final int mode) {\n         int type = FILE_FLAG;\n         if (isLink()) {\n             type = LINK_FLAG;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/BinaryTree.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BinaryTree.java\n      */\n     private final int[] tree;\n \n-    public BinaryTree(int depth) {\n+    public BinaryTree(final int depth) {\n         tree = new int[(1 << (depth + 1)) - 1];\n         Arrays.fill(tree, UNDEFINED);\n     }\n      * @param depth  the number of nodes in the path\n      * @param value  the value of the leaf (must be positive)\n      */\n-    public void addLeaf(int node, int path, int depth, int value) {\n+    public void addLeaf(final int node, final int path, final int depth, final int value) {\n         if (depth == 0) {\n             // end of the path reached, add the value to the current node\n             if (tree[node] == UNDEFINED) {\n      * @param stream\n      * @return the value decoded, or -1 if the end of the stream is reached\n      */\n-    public int read(BitStream stream) throws IOException {\n+    public int read(final BitStream stream) throws IOException {\n         int currentIndex = 0;\n \n         while (true) {\n     /**\n      * Decodes the packed binary tree from the specified stream.\n      */\n-    static BinaryTree decode(InputStream in, final int totalNumberOfValues) throws IOException {\n+    static BinaryTree decode(final InputStream in, final int totalNumberOfValues) throws IOException {\n         // the first byte contains the size of the structure minus one\n         int size = in.read() + 1;\n         if (size == 0) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BitStream.java\n  */\n class BitStream extends BitInputStream {\n \n-    BitStream(InputStream in) {\n+    BitStream(final InputStream in) {\n         super(in, ByteOrder.LITTLE_ENDIAN);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n     /** Index of the next data written in the buffer */\n     private int writeIndex;\n \n-    CircularBuffer(int size) {\n+    CircularBuffer(final int size) {\n         this.size = size;\n         buffer = new byte[size];\n     }\n     /**\n      * Writes a byte to the buffer.\n      */\n-    public void put(int value) {\n+    public void put(final int value) {\n         buffer[writeIndex] = (byte) value;\n         writeIndex = (writeIndex + 1) % size;\n     }\n      * @param distance the distance from the current write position\n      * @param length   the number of bytes to copy\n      */\n-    public void copy(int distance, int length) {\n+    public void copy(final int distance, final int length) {\n         int pos1 = writeIndex - distance;\n         int pos2 = pos1 + length;\n         for (int i = pos1; i < pos2; i++) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n      * @param numberOfTrees  the number of trees (2 or 3)\n      * @param in             the compressed data stream\n      */\n-    public ExplodingInputStream(int dictionarySize, int numberOfTrees, InputStream in) {\n+    public ExplodingInputStream(final int dictionarySize, final int numberOfTrees, final InputStream in) {\n         if (dictionarySize != 4096 && dictionarySize != 8192) {\n             throw new IllegalArgumentException(\"The dictionary size must be 4096 or 8192\");\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n      * the {@link ZipExtraField ZipExtraField interface}.</p>\n      * @param c the class to register\n      */\n-    public static void register(Class<?> c) {\n+    public static void register(final Class<?> c) {\n         try {\n             ZipExtraField ze = (ZipExtraField) c.newInstance();\n             implementations.put(ze.getHeaderId(), c);\n      * @exception InstantiationException if unable to instantiate the class\n      * @exception IllegalAccessException if not allowed to instantiate the class\n      */\n-    public static ZipExtraField createExtraField(ZipShort headerId)\n+    public static ZipExtraField createExtraField(final ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n         Class<?> c = implementations.get(headerId);\n         if (c != null) {\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      */\n-    public static ZipExtraField[] parse(byte[] data) throws ZipException {\n+    public static ZipExtraField[] parse(final byte[] data) throws ZipException {\n         return parse(data, true, UnparseableExtraField.THROW);\n     }\n \n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      */\n-    public static ZipExtraField[] parse(byte[] data, boolean local)\n+    public static ZipExtraField[] parse(final byte[] data, final boolean local)\n         throws ZipException {\n         return parse(data, local, UnparseableExtraField.THROW);\n     }\n      *\n      * @since 1.1\n      */\n-    public static ZipExtraField[] parse(byte[] data, boolean local,\n-                                        UnparseableExtraField onUnparseableData)\n+    public static ZipExtraField[] parse(final byte[] data, final boolean local,\n+                                        final UnparseableExtraField onUnparseableData)\n         throws ZipException {\n         List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n         int start = 0;\n      * @param data an array of ExtraFiles\n      * @return an array of bytes\n      */\n-    public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\n+    public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\n         final boolean lastIsUnparseableHolder = data.length > 0\n             && data[data.length - 1] instanceof UnparseableExtraFieldData;\n         int regularExtraFieldCount =\n      * @param data an array of ExtraFields\n      * @return an array of bytes\n      */\n-    public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\n+    public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\n         final boolean lastIsUnparseableHolder = data.length > 0\n             && data[data.length - 1] instanceof UnparseableExtraFieldData;\n         int regularExtraFieldCount =\n \n         private final int key;\n \n-        private UnparseableExtraField(int k) {\n+        private UnparseableExtraField(final int k) {\n             key = k;\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n      * @param charsetName The name of the charset or {@code null} for\n      *                the platform's default character set.\n      */\n-    public FallbackZipEncoding(String charsetName) {\n+    public FallbackZipEncoding(final String charsetName) {\n         this.charsetName = charsetName;\n     }\n \n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n     @Override\n-    public boolean canEncode(String name) {\n+    public boolean canEncode(final String name) {\n         return true;\n     }\n \n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n     @Override\n-    public ByteBuffer encode(String name) throws IOException {\n+    public ByteBuffer encode(final String name) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return ByteBuffer.wrap(name.getBytes());\n         }\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n     @Override\n-    public String decode(byte[] data) throws IOException {\n+    public String decode(final byte[] data) throws IOException {\n         if (this.charsetName == null) { // i.e. use default charset, see no-args constructor\n             return new String(data);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n      * whether the current entry will use UTF8 for file name and comment.\n      * @param b whether the current entry will use UTF8 for file name and comment.\n      */\n-    public void useUTF8ForNames(boolean b) {\n+    public void useUTF8ForNames(final boolean b) {\n         languageEncodingFlag = b;\n     }\n \n      * @param b whether the current entry will use the data descriptor to store\n      * CRC and size information\n      */\n-    public void useDataDescriptor(boolean b) {\n+    public void useDataDescriptor(final boolean b) {\n         dataDescriptorFlag = b;\n     }\n \n      * whether the current entry will be encrypted.\n      * @param b whether the current entry will be encrypted\n      */\n-    public void useEncryption(boolean b) {\n+    public void useEncryption(final boolean b) {\n         encryptionFlag = b;\n     }\n \n      * whether the current entry will be encrypted  using strong encryption.\n      * @param b whether the current entry will be encrypted  using strong encryption\n      */\n-    public void useStrongEncryption(boolean b) {\n+    public void useStrongEncryption(final boolean b) {\n         strongEncryptionFlag = b;\n         if (b) {\n             useEncryption(true);\n      *         The offset within the output buffer of the first byte to be written.\n      *         must be non-negative and no larger than <tt>buf.length-2</tt>\n      */\n-    public void encode(byte[] buf, int offset) {\n+    public void encode(final byte[] buf, final int offset) {\n                 ZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n                         |\n                         (languageEncodingFlag ? UFT8_NAMES_FLAG : 0)\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (!(o instanceof GeneralPurposeBit)) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/JarMarker.java\n      * @throws ZipException on error\n      */\n     @Override\n-    public void parseFromLocalFileData(byte[] data, int offset, int length)\n+    public void parseFromLocalFileData(final byte[] data, final int offset, final int length)\n         throws ZipException {\n         if (length != 0) {\n             throw new ZipException(\"JarMarker doesn't expect any data\");\n      * same data in central directory and local file data.\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n-                                              int length)\n+    public void parseFromCentralDirectoryData(final byte[] buffer, final int offset,\n+                                              final int length)\n         throws ZipException {\n         parseFromLocalFileData(buffer, offset, length);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n      * \n      * @param charset The NIO charset to wrap.\n      */\n-    public NioZipEncoding(Charset charset) {\n+    public NioZipEncoding(final Charset charset) {\n         this.charset = charset;\n     }\n \n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n     @Override\n-    public boolean canEncode(String name) {\n+    public boolean canEncode(final String name) {\n         CharsetEncoder enc = this.charset.newEncoder();\n         enc.onMalformedInput(CodingErrorAction.REPORT);\n         enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n     @Override\n-    public ByteBuffer encode(String name) {\n+    public ByteBuffer encode(final String name) {\n         CharsetEncoder enc = this.charset.newEncoder();\n \n         enc.onMalformedInput(CodingErrorAction.REPORT);\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n     @Override\n-    public String decode(byte[] data) throws IOException {\n+    public String decode(final byte[] data) throws IOException {\n         return this.charset.newDecoder()\n             .onMalformedInput(CodingErrorAction.REPORT)\n             .onUnmappableCharacter(CodingErrorAction.REPORT)\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n      */\n     private byte[] centralData;\n \n-    protected PKWareExtraHeader(ZipShort headerId) {\n+    protected PKWareExtraHeader(final ZipShort headerId) {\n         this.headerId = headerId;\n     }\n     \n      * @param data\n      *            the field data to use\n      */\n-    public void setLocalFileDataData(byte[] data) {\n+    public void setLocalFileDataData(final byte[] data) {\n         localData = ZipUtil.copy(data);\n     }\n \n      * @param data\n      *            the data to use\n      */\n-    public void setCentralDirectoryData(byte[] data) {\n+    public void setCentralDirectoryData(final byte[] data) {\n         centralData = ZipUtil.copy(data);\n     }\n \n      * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n      */\n     @Override\n-    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setLocalFileDataData(tmp);\n      * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setCentralDirectoryData(tmp);\n         /**\n          * private constructor for enum style class.\n          */\n-        EncryptionAlgorithm(int code) {\n+        EncryptionAlgorithm(final int code) {\n             this.code = code;\n         }\n \n          * @return the EncryptionAlgorithm for the given code or null\n          * if the method is not known\n          */\n-        public static EncryptionAlgorithm getAlgorithmByCode(int code) {\n+        public static EncryptionAlgorithm getAlgorithmByCode(final int code) {\n             return codeToEnum.get(Integer.valueOf(code));\n         }\n     }\n         /**\n          * private constructor for enum style class.\n          */\n-        HashAlgorithm(int code) {\n+        HashAlgorithm(final int code) {\n             this.code = code;\n         }\n \n          * @return the HashAlgorithm for the given code or null\n          * if the method is not known\n          */\n-        public static HashAlgorithm getAlgorithmByCode(int code) {\n+        public static HashAlgorithm getAlgorithmByCode(final int code) {\n             return codeToEnum.get(Integer.valueOf(code));\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n         }\n     }\n \n-    private ScatterZipOutputStream createDeferred(ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier)\n+    private ScatterZipOutputStream createDeferred(final ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier)\n             throws IOException {\n         ScatterGatherBackingStore bs = scatterGatherBackingStoreSupplier.get();\n         StreamCompressor sc = StreamCompressor.create(Deflater.DEFAULT_COMPRESSION, bs);\n      * @param executorService The executorService to use for parallel scheduling. For technical reasons,\n      *                        this will be shut down by this class.\n      */\n-    public ParallelScatterZipCreator(ExecutorService executorService) {\n+    public ParallelScatterZipCreator(final ExecutorService executorService) {\n         this(executorService, new DefaultBackingStoreSupplier());\n     }\n \n      *                        by this class.\n      * @param backingStoreSupplier The supplier of backing store which shall be used\n      */\n-    public ParallelScatterZipCreator(ExecutorService executorService,\n-                                     ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n+    public ParallelScatterZipCreator(final ExecutorService executorService,\n+                                     final ScatterGatherBackingStoreSupplier backingStoreSupplier) {\n         this.backingStoreSupplier = backingStoreSupplier;\n         es = executorService;\n     }\n      *\n      * @param callable The callable to run, created by {@link #createCallable createCallable}, possibly wrapped by caller.\n      */\n-    public final void submit(Callable<Object> callable) {\n+    public final void submit(final Callable<Object> callable) {\n         futures.add(es.submit(callable));\n     }\n \n      * will be propagated through the callable.\n      */\n \n-    public final Callable<Object> createCallable(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier source) {\n+    public final Callable<Object> createCallable(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier source) {\n         final int method = zipArchiveEntry.getMethod();\n         if (method == ZipMethod.UNKNOWN_CODE) {\n             throw new IllegalArgumentException(\"Method must be set on zipArchiveEntry: \" + zipArchiveEntry);\n      * @throws InterruptedException If we get interrupted\n      * @throws ExecutionException   If something happens in the parallel execution\n      */\n-    public void writeTo(ZipArchiveOutputStream targetStream)\n+    public void writeTo(final ZipArchiveOutputStream targetStream)\n             throws IOException, InterruptedException, ExecutionException {\n \n         // Make sure we catch any exceptions from parallel phase\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterStatistics.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterStatistics.java\n     private final long compressionElapsed;\n     private final long mergingElapsed;\n \n-    ScatterStatistics(long compressionElapsed, long mergingElapsed) {\n+    ScatterStatistics(final long compressionElapsed, final long mergingElapsed) {\n         this.compressionElapsed = compressionElapsed;\n         this.mergingElapsed = mergingElapsed;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n         final long compressedSize;\n         final long size;\n \n-        public CompressedEntry(ZipArchiveEntryRequest zipArchiveEntryRequest, long crc, long compressedSize, long size) {\n+        public CompressedEntry(final ZipArchiveEntryRequest zipArchiveEntryRequest, final long crc, final long compressedSize, final long size) {\n             this.zipArchiveEntryRequest = zipArchiveEntryRequest;\n             this.crc = crc;\n             this.compressedSize = compressedSize;\n         }\n     }\n \n-    public ScatterZipOutputStream(ScatterGatherBackingStore backingStore,\n-                                  StreamCompressor streamCompressor) {\n+    public ScatterZipOutputStream(final ScatterGatherBackingStore backingStore,\n+                                  final StreamCompressor streamCompressor) {\n         this.backingStore = backingStore;\n         this.streamCompressor = streamCompressor;\n     }\n      * @param zipArchiveEntryRequest The entry to write.\n      * @throws IOException    If writing fails\n      */\n-    public void addArchiveEntry(ZipArchiveEntryRequest zipArchiveEntryRequest) throws IOException {\n+    public void addArchiveEntry(final ZipArchiveEntryRequest zipArchiveEntryRequest) throws IOException {\n         final InputStream payloadStream = zipArchiveEntryRequest.getPayloadStream();\n         try {\n             streamCompressor.deflate(payloadStream, zipArchiveEntryRequest.getMethod());\n      * @param target The archive to receive the contents of this {@link ScatterZipOutputStream}.\n      * @throws IOException If writing fails\n      */\n-    public void writeTo(ZipArchiveOutputStream target) throws IOException {\n+    public void writeTo(final ZipArchiveOutputStream target) throws IOException {\n         backingStore.closeForWriting();\n         InputStream data = backingStore.getInputStream();\n         for (CompressedEntry compressedEntry : items) {\n      * @return A ScatterZipOutputStream that is ready for use.\n      * @throws FileNotFoundException if the file cannot be found\n      */\n-    public static ScatterZipOutputStream fileBased(File file) throws FileNotFoundException {\n+    public static ScatterZipOutputStream fileBased(final File file) throws FileNotFoundException {\n         return fileBased(file, Deflater.DEFAULT_COMPRESSION);\n     }\n \n      * @return A  ScatterZipOutputStream that is ready for use.\n      * @throws FileNotFoundException if the file cannot be found\n      */\n-    public static ScatterZipOutputStream fileBased(File file, int compressionLevel) throws FileNotFoundException {\n+    public static ScatterZipOutputStream fileBased(final File file, final int compressionLevel) throws FileNotFoundException {\n         ScatterGatherBackingStore bs = new FileBasedScatterGatherBackingStore(file);\n         StreamCompressor sc = StreamCompressor.create(compressionLevel, bs);\n         return new ScatterZipOutputStream(bs, sc);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n         public final char unicode;\n         public final byte code;\n \n-        Simple8BitChar(byte code, char unicode) {\n+        Simple8BitChar(final byte code, final char unicode) {\n             this.code = code;\n             this.unicode = unicode;\n         }\n \n         @Override\n-        public int compareTo(Simple8BitChar a) {\n+        public int compareTo(final Simple8BitChar a) {\n             return this.unicode - a.unicode;\n         }\n \n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o instanceof Simple8BitChar) {\n                 Simple8BitChar other = (Simple8BitChar) o;\n                 return unicode == other.unicode && code == other.code;\n      * @param highChars The characters for byte values of 128 to 255\n      * stored as an array of 128 chars.\n      */\n-    public Simple8BitZipEncoding(char[] highChars) {\n+    public Simple8BitZipEncoding(final char[] highChars) {\n         this.highChars = highChars.clone();\n         List<Simple8BitChar> temp =\n             new ArrayList<Simple8BitChar>(this.highChars.length);\n      * @param b The byte to decode.\n      * @return The associated character value.\n      */\n-    public char decodeByte(byte b) {\n+    public char decodeByte(final byte b) {\n         // code 0-127\n         if (b >= 0) {\n             return (char) b;\n      * @param c The character to encode.\n      * @return Whether the given unicode character is covered by this encoding.\n      */\n-    public boolean canEncodeChar(char c) {\n+    public boolean canEncodeChar(final char c) {\n \n         if (c >= 0 && c < 128) {\n             return true;\n      *         If {@code false} is returned, nothing is pushed to the\n      *         byte buffer. \n      */\n-    public boolean pushEncodedChar(ByteBuffer bb, char c) {\n+    public boolean pushEncodedChar(final ByteBuffer bb, final char c) {\n \n         if (c >= 0 && c < 128) {\n             bb.put((byte) c);\n      *         A {@code null} value is returned, if this character is not\n      *         covered by this encoding.\n      */\n-    private Simple8BitChar encodeHighChar(char c) {\n+    private Simple8BitChar encodeHighChar(final char c) {\n         // for performance an simplicity, yet another reincarnation of\n         // binary search...\n         int i0 = 0;\n      * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n      */\n     @Override\n-    public boolean canEncode(String name) {\n+    public boolean canEncode(final String name) {\n \n         for (int i=0;i<name.length();++i) {\n \n      * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n      */\n     @Override\n-    public ByteBuffer encode(String name) {\n+    public ByteBuffer encode(final String name) {\n         ByteBuffer out = ByteBuffer.allocate(name.length()\n                                              + 6 + (name.length() + 1) / 2);\n \n      * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n      */\n     @Override\n-    public String decode(byte[] data) throws IOException {\n+    public String decode(final byte[] data) throws IOException {\n         char [] ret = new char[data.length];\n \n         for (int i=0;i<data.length;++i) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n     private final byte[] outputBuffer = new byte[bufferSize];\n     private final byte[] readerBuf = new byte[bufferSize];\n \n-    StreamCompressor(Deflater deflater) {\n+    StreamCompressor(final Deflater deflater) {\n         this.def = deflater;\n     }\n \n      * @param deflater The deflater to use\n      * @return A stream compressor\n      */\n-    static StreamCompressor create(OutputStream os, Deflater deflater) {\n+    static StreamCompressor create(final OutputStream os, final Deflater deflater) {\n         return new OutputStreamCompressor(deflater, os);\n     }\n \n      * @param os The stream to receive output\n      * @return A stream compressor\n      */\n-    static StreamCompressor create(OutputStream os) {\n+    static StreamCompressor create(final OutputStream os) {\n         return create(os, new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n     }\n \n      * @param deflater The deflater to use for the compressor\n      * @return A stream compressor\n      */\n-    static StreamCompressor create(DataOutput os, Deflater deflater) {\n+    static StreamCompressor create(final DataOutput os, final Deflater deflater) {\n         return new DataOutputCompressor(deflater, os);\n     }\n \n      * @param bs               The ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n-    public static StreamCompressor create(int compressionLevel, ScatterGatherBackingStore bs) {\n+    public static StreamCompressor create(final int compressionLevel, final ScatterGatherBackingStore bs) {\n         final Deflater deflater = new Deflater(compressionLevel, true);\n         return new ScatterGatherBackingStoreCompressor(deflater, bs);\n     }\n      * @param bs The ScatterGatherBackingStore to receive output\n      * @return A stream compressor\n      */\n-    public static StreamCompressor create(ScatterGatherBackingStore bs) {\n+    public static StreamCompressor create(final ScatterGatherBackingStore bs) {\n         return create(Deflater.DEFAULT_COMPRESSION, bs);\n     }\n \n      * @throws IOException When failures happen\n      */\n \n-    public void deflate(InputStream source, int method) throws IOException {\n+    public void deflate(final InputStream source, final int method) throws IOException {\n         reset();\n         int length;\n \n      * @return the number of bytes written to the stream this time\n      * @throws IOException on error\n      */\n-    long write(byte[] b, int offset, int length, int method) throws IOException {\n+    long write(final byte[] b, final int offset, final int length, final int method) throws IOException {\n         long current = writtenToOutputStreamForLastEntry;\n         crc.update(b, offset, length);\n         if (method == ZipEntry.DEFLATED) {\n         }\n     }\n \n-    private void writeDeflated(byte[] b, int offset, int length)\n+    private void writeDeflated(final byte[] b, final int offset, final int length)\n             throws IOException {\n         if (length > 0 && !def.finished()) {\n             if (length <= DEFLATER_BLOCK_SIZE) {\n         }\n     }\n \n-    public void writeCounted(byte[] data) throws IOException {\n+    public void writeCounted(final byte[] data) throws IOException {\n         writeCounted(data, 0, data.length);\n     }\n \n-    public void writeCounted(byte[] data, int offset, int length) throws IOException {\n+    public void writeCounted(final byte[] data, final int offset, final int length) throws IOException {\n         writeOut(data, offset, length);\n         writtenToOutputStreamForLastEntry += length;\n         totalWrittenToOutputStream += length;\n     private static final class ScatterGatherBackingStoreCompressor extends StreamCompressor {\n         private final ScatterGatherBackingStore bs;\n \n-        public ScatterGatherBackingStoreCompressor(Deflater deflater, ScatterGatherBackingStore bs) {\n+        public ScatterGatherBackingStoreCompressor(final Deflater deflater, final ScatterGatherBackingStore bs) {\n             super(deflater);\n             this.bs = bs;\n         }\n \n         @Override\n-        protected final void writeOut(byte[] data, int offset, int length)\n+        protected final void writeOut(final byte[] data, final int offset, final int length)\n                 throws IOException {\n             bs.writeOut(data, offset, length);\n         }\n     private static final class OutputStreamCompressor extends StreamCompressor {\n         private final OutputStream os;\n \n-        public OutputStreamCompressor(Deflater deflater, OutputStream os) {\n+        public OutputStreamCompressor(final Deflater deflater, final OutputStream os) {\n             super(deflater);\n             this.os = os;\n         }\n \n         @Override\n-        protected final void writeOut(byte[] data, int offset, int length)\n+        protected final void writeOut(final byte[] data, final int offset, final int length)\n                 throws IOException {\n             os.write(data, offset, length);\n         }\n     private static final class DataOutputCompressor extends StreamCompressor {\n         private final DataOutput raf;\n \n-        public DataOutputCompressor(Deflater deflater, DataOutput raf) {\n+        public DataOutputCompressor(final Deflater deflater, final DataOutput raf) {\n             super(deflater);\n             this.raf = raf;\n         }\n \n         @Override\n-        protected final void writeOut(byte[] data, int offset, int length)\n+        protected final void writeOut(final byte[] data, final int offset, final int length)\n                 throws IOException {\n             raf.write(data, offset, length);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n      * @param len The length of the encoded comment or comment in\n      * <code>bytes</code>.\n      */\n-    public UnicodeCommentExtraField(String text, byte[] bytes, int off,\n-                                    int len) {\n+    public UnicodeCommentExtraField(final String text, final byte[] bytes, final int off,\n+                                    final int len) {\n         super(text, bytes, off, len);\n     }\n \n      * @param comment The file comment\n      * @param bytes the bytes actually written to the archive\n      */\n-    public UnicodeCommentExtraField(String comment, byte[] bytes) {\n+    public UnicodeCommentExtraField(final String comment, final byte[] bytes) {\n         super(comment, bytes);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n      * @param len The length of the encoded filename or comment in\n      * <code>bytes</code>.\n      */\n-    public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\n+    public UnicodePathExtraField(final String text, final byte[] bytes, final int off, final int len) {\n         super(text, bytes, off, len);\n     }\n \n      * @param name The file name\n      * @param bytes the bytes actually written to the archive\n      */\n-    public UnicodePathExtraField(String name, byte[] bytes) {\n+    public UnicodePathExtraField(final String name, final byte[] bytes) {\n         super(name, bytes);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n      * @param length the length of data\n      */\n     @Override\n-    public void parseFromLocalFileData(byte[] buffer, int offset, int length) {\n+    public void parseFromLocalFileData(final byte[] buffer, final int offset, final int length) {\n         localFileData = new byte[length];\n         System.arraycopy(buffer, offset, localFileData, 0, length);\n     }\n      * @param length the length of data\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n-                                              int length) {\n+    public void parseFromCentralDirectoryData(final byte[] buffer, final int offset,\n+                                              final int length) {\n         centralDirectoryData = new byte[length];\n         System.arraycopy(buffer, offset, centralDirectoryData, 0, length);\n         if (localFileData == null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n      * Set the header id.\n      * @param headerId the header id to use\n      */\n-    public void setHeaderId(ZipShort headerId) {\n+    public void setHeaderId(final ZipShort headerId) {\n         this.headerId = headerId;\n     }\n \n      * without Header-ID or length specifier.\n      * @param data the field data to use\n      */\n-    public void setLocalFileDataData(byte[] data) {\n+    public void setLocalFileDataData(final byte[] data) {\n         localData = ZipUtil.copy(data);\n     }\n \n      * Set the extra field data in central directory.\n      * @param data the data to use\n      */\n-    public void setCentralDirectoryData(byte[] data) {\n+    public void setCentralDirectoryData(final byte[] data) {\n         centralData = ZipUtil.copy(data);\n     }\n \n      * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n      */\n     @Override\n-    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setLocalFileDataData(tmp);\n      * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n      */\n     @Override\n-    public void parseFromCentralDirectoryData(byte[] data, int offset,\n-                                              int length) {\n+    public void parseFromCentralDirectoryData(final byte[] data, final int offset,\n+                                              final int length) {\n         byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setCentralDirectoryData(tmp);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n     private static final int MAX_TABLE_SIZE = 1 << MAX_CODE_SIZE;\n     private final boolean[] isUsed;\n     \n-    public UnshrinkingInputStream(InputStream inputStream) throws IOException {\n+    public UnshrinkingInputStream(final InputStream inputStream) throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         setClearCode(DEFAULT_CODE_SIZE);\n         initializeTables(MAX_CODE_SIZE);\n     }\n \n     @Override\n-    protected int addEntry(int previousCode, byte character) throws IOException {\n+    protected int addEntry(final int previousCode, final byte character) throws IOException {\n         int tableSize = getTableSize();\n         while ((tableSize < MAX_TABLE_SIZE) && isUsed[tableSize]) {\n             tableSize++;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnsupportedZipFeatureException.java\n      * @param reason the feature that is not supported\n      * @param entry the entry using the feature\n      */\n-    public UnsupportedZipFeatureException(Feature reason,\n-                                          ZipArchiveEntry entry) {\n+    public UnsupportedZipFeatureException(final Feature reason,\n+                                          final ZipArchiveEntry entry) {\n         super(\"unsupported feature \" + reason +  \" used in entry \"\n               + entry.getName());\n         this.reason = reason;\n      * @param entry the entry using the feature\n      * @since 1.5\n      */\n-    public UnsupportedZipFeatureException(ZipMethod method,\n-                                          ZipArchiveEntry entry) {\n+    public UnsupportedZipFeatureException(final ZipMethod method,\n+                                          final ZipArchiveEntry entry) {\n         super(\"unsupported feature method '\" + method.name()\n               +  \"' used in entry \" + entry.getName());\n         this.reason = Feature.METHOD;\n      * @param reason the feature that is not supported\n      * @since 1.5\n      */\n-    public UnsupportedZipFeatureException(Feature reason) {\n+    public UnsupportedZipFeatureException(final Feature reason) {\n         super(\"unsupported feature \" + reason +  \" used in archive.\");\n         this.reason = reason;\n         this.entry = null;\n \n         private final String name;\n \n-        private Feature(String name) {\n+        private Feature(final String name) {\n             this.name = name;\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n      */\n     @Override\n     public void parseFromLocalFileData(\n-            byte[] data, int offset, int length\n+            final byte[] data, int offset, final int length\n     ) throws ZipException {\n         final int len = offset + length;\n \n      */\n     @Override\n     public void parseFromCentralDirectoryData(\n-            byte[] buffer, int offset, int length\n+            final byte[] buffer, final int offset, final int length\n     ) throws ZipException {\n         reset();\n         parseFromLocalFileData(buffer, offset, length);\n      *\n      * @param t ZipEightByteInteger of the modify time\n      */\n-    public void setModifyTime(ZipEightByteInteger t) {\n+    public void setModifyTime(final ZipEightByteInteger t) {\n         modifyTime = t == null ? ZipEightByteInteger.ZERO : t;\n     }\n \n      *\n      * @param t ZipEightByteInteger of the access time\n      */\n-    public void setAccessTime(ZipEightByteInteger t) {\n+    public void setAccessTime(final ZipEightByteInteger t) {\n         accessTime = t == null ? ZipEightByteInteger.ZERO : t;\n     }\n \n      *\n      * @param t ZipEightByteInteger of the create time\n      */\n-    public void setCreateTime(ZipEightByteInteger t) {\n+    public void setCreateTime(final ZipEightByteInteger t) {\n         createTime = t == null ? ZipEightByteInteger.ZERO : t;\n     }\n \n      *\n      * @param d modify time as java.util.Date\n      */\n-    public void setModifyJavaTime(Date d) { setModifyTime(dateToZip(d)); }\n+    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZip(d)); }\n \n     /**\n      * Sets the access time as a java.util.Date\n      *\n      * @param d access time as java.util.Date\n      */\n-    public void setAccessJavaTime(Date d) { setAccessTime(dateToZip(d)); }\n+    public void setAccessJavaTime(final Date d) { setAccessTime(dateToZip(d)); }\n \n     /**\n      * <p>\n      *\n      * @param d create time as java.util.Date\n      */\n-    public void setCreateJavaTime(Date d) { setCreateTime(dateToZip(d)); }\n+    public void setCreateJavaTime(final Date d) { setCreateTime(dateToZip(d)); }\n \n     /**\n      * Returns a String representation of this class useful for\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o instanceof X000A_NTFS) {\n             X000A_NTFS xf = (X000A_NTFS) o;\n \n         this.createTime = ZipEightByteInteger.ZERO;\n     }\n \n-    private void readTimeAttr(byte[] data, int offset, int length) {\n+    private void readTimeAttr(final byte[] data, int offset, final int length) {\n         if (length >= 2 + 3 * 8) {\n             ZipShort tagValueLength = new ZipShort(data, offset);\n             if (TIME_ATTR_SIZE.equals(tagValueLength)) {\n         return new ZipEightByteInteger((d.getTime() * 10000l) - EPOCH_OFFSET);\n     }\n \n-    private static Date zipToDate(ZipEightByteInteger z) {\n+    private static Date zipToDate(final ZipEightByteInteger z) {\n         if (z == null || ZipEightByteInteger.ZERO.equals(z)) { return null; }\n         long l = (z.getLongValue() + EPOCH_OFFSET) / 10000l;\n         return new Date(l);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0015_CertificateIdForFile.java\n     }\n \n     @Override\n-    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n         super.parseFromCentralDirectoryData(data, offset, length);\n         this.rcount = ZipShort.getValue(data, offset);\n         this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0016_CertificateIdForCentralDirectory.java\n     }\n \n     @Override\n-    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n         this.rcount = ZipShort.getValue(data, offset);\n         this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n      * @param offset offset into buffer to read data\n      * @param length the length of data\n      */\n-    public void parseCentralDirectoryFormat(byte[] data, int offset, int length) {\n+    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n         this.format = ZipShort.getValue(data, offset);\n         this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n         this.bitlen = ZipShort.getValue(data, offset + 4);\n      * @param offset offset into buffer to read data\n      * @param length the length of data\n      */\n-    public void parseFileFormat(byte[] data, int offset, int length) {\n+    public void parseFileFormat(final byte[] data, final int offset, final int length) {\n         int ivSize = ZipShort.getValue(data, offset);\n         this.ivData = new byte[ivSize];\n         System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n     }\n \n     @Override\n-    public void parseFromLocalFileData(byte[] data, int offset, int length) {\n+    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n         super.parseFromLocalFileData(data, offset, length);\n         parseFileFormat(data, offset, length);\n     }\n \n     @Override\n-    public void parseFromCentralDirectoryData(byte[] data, int offset, int length) {\n+    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n         super.parseFromCentralDirectoryData(data, offset, length);\n         parseCentralDirectoryFormat(data, offset, length);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n      */\n     @Override\n     public void parseFromLocalFileData(\n-            byte[] data, int offset, int length\n+            final byte[] data, int offset, final int length\n     ) throws ZipException {\n         reset();\n         final int len = offset + length;\n      */\n     @Override\n     public void parseFromCentralDirectoryData(\n-            byte[] buffer, int offset, int length\n+            final byte[] buffer, final int offset, final int length\n     ) throws ZipException {\n         reset();\n         parseFromLocalFileData(buffer, offset, length);\n      * @param flags flags byte indicating which of the\n      *              three datestamp fields are present.\n      */\n-    public void setFlags(byte flags) {\n+    public void setFlags(final byte flags) {\n         this.flags = flags;\n         this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n         this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n      *\n      * @param l ZipLong of the modify time (seconds per epoch)\n      */\n-    public void setModifyTime(ZipLong l) {\n+    public void setModifyTime(final ZipLong l) {\n         bit0_modifyTimePresent = l != null;\n         flags = (byte) (l != null ? (flags | MODIFY_TIME_BIT)\n                         : (flags & ~MODIFY_TIME_BIT));\n      *\n      * @param l ZipLong of the access time (seconds per epoch)\n      */\n-    public void setAccessTime(ZipLong l) {\n+    public void setAccessTime(final ZipLong l) {\n         bit1_accessTimePresent = l != null;\n         flags = (byte) (l != null ? (flags | ACCESS_TIME_BIT)\n                         : (flags & ~ACCESS_TIME_BIT));\n      *\n      * @param l ZipLong of the create time (seconds per epoch)\n      */\n-    public void setCreateTime(ZipLong l) {\n+    public void setCreateTime(final ZipLong l) {\n         bit2_createTimePresent = l != null;\n         flags = (byte) (l != null ? (flags | CREATE_TIME_BIT)\n                         : (flags & ~CREATE_TIME_BIT));\n      *\n      * @param d modify time as java.util.Date\n      */\n-    public void setModifyJavaTime(Date d) { setModifyTime(dateToZipLong(d)); }\n+    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }\n \n     /**\n      * <p>\n      *\n      * @param d access time as java.util.Date\n      */\n-    public void setAccessJavaTime(Date d) { setAccessTime(dateToZipLong(d)); }\n+    public void setAccessJavaTime(final Date d) { setAccessTime(dateToZipLong(d)); }\n \n     /**\n      * <p>\n      *\n      * @param d create time as java.util.Date\n      */\n-    public void setCreateJavaTime(Date d) { setCreateTime(dateToZipLong(d)); }\n+    public void setCreateJavaTime(final Date d) { setCreateTime(dateToZipLong(d)); }\n \n     /**\n      * Utility method converts java.util.Date (milliseconds since epoch)\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o instanceof X5455_ExtendedTimestamp) {\n             X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n      *\n      * @param l UID value to set on this extra field.\n      */\n-    public void setUID(long l) {\n+    public void setUID(final long l) {\n         this.uid = ZipUtil.longToBig(l);\n     }\n \n      *\n      * @param l GID value to set on this extra field.\n      */\n-    public void setGID(long l) {\n+    public void setGID(final long l) {\n         this.gid = ZipUtil.longToBig(l);\n     }\n \n      */\n     @Override\n     public void parseFromLocalFileData(\n-            byte[] data, int offset, int length\n+            final byte[] data, int offset, final int length\n     ) throws ZipException {\n         reset();\n         this.version = signedByteToUnsignedInt(data[offset++]);\n      */\n     @Override\n     public void parseFromCentralDirectoryData(\n-            byte[] buffer, int offset, int length\n+            final byte[] buffer, final int offset, final int length\n     ) throws ZipException {\n     }\n \n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o instanceof X7875_NewUnix) {\n             X7875_NewUnix xf = (X7875_NewUnix) o;\n             // We assume uid and gid can never be null.\n      * @param array byte[] array to trim & pad.\n      * @return trimmed & padded byte[] array.\n      */\n-    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n+    static byte[] trimLeadingZeroesForceMinLength(final byte[] array) {\n         if (array == null) {\n             return array;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n      *\n      * @throws IllegalArgumentException if size or compressedSize is null\n      */\n-    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n-                                              ZipEightByteInteger compressedSize) {\n+    public Zip64ExtendedInformationExtraField(final ZipEightByteInteger size,\n+                                              final ZipEightByteInteger compressedSize) {\n         this(size, compressedSize, null, null);\n     }\n \n      *\n      * @throws IllegalArgumentException if size or compressedSize is null\n      */\n-    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n-                                              ZipEightByteInteger compressedSize,\n-                                              ZipEightByteInteger relativeHeaderOffset,\n-                                              ZipLong diskStart) {\n+    public Zip64ExtendedInformationExtraField(final ZipEightByteInteger size,\n+                                              final ZipEightByteInteger compressedSize,\n+                                              final ZipEightByteInteger relativeHeaderOffset,\n+                                              final ZipLong diskStart) {\n         this.size = size;\n         this.compressedSize = compressedSize;\n         this.relativeHeaderOffset = relativeHeaderOffset;\n     }\n \n     @Override\n-    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n+    public void parseFromLocalFileData(final byte[] buffer, int offset, final int length)\n         throws ZipException {\n         if (length == 0) {\n             // no local file data at all, may happen if an archive\n     }\n \n     @Override\n-    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n-                                              int length)\n+    public void parseFromCentralDirectoryData(final byte[] buffer, int offset,\n+                                              final int length)\n         throws ZipException {\n         // store for processing in reparseCentralDirectoryData\n         rawCentralDirectoryData = new byte[length];\n      * @param hasDiskStart flag to read from central directory\n      * @throws ZipException on error\n      */\n-    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n-                                            boolean hasCompressedSize,\n-                                            boolean hasRelativeHeaderOffset,\n-                                            boolean hasDiskStart)\n+    public void reparseCentralDirectoryData(final boolean hasUncompressedSize,\n+                                            final boolean hasCompressedSize,\n+                                            final boolean hasRelativeHeaderOffset,\n+                                            final boolean hasDiskStart)\n         throws ZipException {\n         if (rawCentralDirectoryData != null) {\n             int expectedLength = (hasUncompressedSize ? DWORD : 0)\n      * The uncompressed size stored in this extra field.\n      * @param size The uncompressed size stored in this extra field.\n      */\n-    public void setSize(ZipEightByteInteger size) {\n+    public void setSize(final ZipEightByteInteger size) {\n         this.size = size;\n     }\n \n      * The uncompressed size stored in this extra field.\n      * @param compressedSize The uncompressed size stored in this extra field.\n      */\n-    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n+    public void setCompressedSize(final ZipEightByteInteger compressedSize) {\n         this.compressedSize = compressedSize;\n     }\n \n      * The relative header offset stored in this extra field.\n      * @param rho The relative header offset stored in this extra field.\n      */\n-    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n+    public void setRelativeHeaderOffset(final ZipEightByteInteger rho) {\n         relativeHeaderOffset = rho;\n     }\n \n      * The disk start number stored in this extra field.\n      * @param ds The disk start number stored in this extra field.\n      */\n-    public void setDiskStartNumber(ZipLong ds) {\n+    public void setDiskStartNumber(final ZipLong ds) {\n         diskStart = ds;\n     }\n \n-    private int addSizes(byte[] data) {\n+    private int addSizes(final byte[] data) {\n         int off = 0;\n         if (size != null) {\n             System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64RequiredException.java\n     /**\n      * Helper to format \"entry too big\" messages.\n      */\n-    static String getEntryTooBigMessage(ZipArchiveEntry ze) {\n+    static String getEntryTooBigMessage(final ZipArchiveEntry ze) {\n         return ze.getName() + \"'s size exceeds the limit of 4GByte.\";\n     }\n \n     static final String TOO_MANY_ENTRIES_MESSAGE =\n         \"archive contains more than 65535 entries.\";\n \n-    public Zip64RequiredException(String reason) {\n+    public Zip64RequiredException(final String reason) {\n         super(reason);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n      *\n      * @param name the name of the entry\n      */\n-    public ZipArchiveEntry(String name) {\n+    public ZipArchiveEntry(final String name) {\n         super(name);\n         setName(name);\n     }\n      * @param entry the entry to get fields from\n      * @throws ZipException on error\n      */\n-    public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n+    public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException {\n         super(entry);\n         setName(entry.getName());\n         byte[] extra = entry.getExtra();\n      * @param entry the entry to get fields from\n      * @throws ZipException on error\n      */\n-    public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n+    public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\n         this((java.util.zip.ZipEntry) entry);\n         setInternalAttributes(entry.getInternalAttributes());\n         setExternalAttributes(entry.getExternalAttributes());\n      * @param inputFile file to create the entry from\n      * @param entryName name of the entry\n      */\n-    public ZipArchiveEntry(File inputFile, String entryName) {\n+    public ZipArchiveEntry(final File inputFile, final String entryName) {\n         this(inputFile.isDirectory() && !entryName.endsWith(\"/\") ? \n              entryName + \"/\" : entryName);\n         if (inputFile.isFile()){\n      * @since 1.1\n      */\n     @Override\n-    public void setMethod(int method) {\n+    public void setMethod(final int method) {\n         if (method < 0) {\n             throw new IllegalArgumentException(\n                     \"ZIP compression method can not be negative: \" + method);\n      * Sets the internal file attributes.\n      * @param value an <code>int</code> value\n      */\n-    public void setInternalAttributes(int value) {\n+    public void setInternalAttributes(final int value) {\n         internalAttributes = value;\n     }\n \n      * Sets the external file attributes.\n      * @param value an <code>long</code> value\n      */\n-    public void setExternalAttributes(long value) {\n+    public void setExternalAttributes(final long value) {\n         externalAttributes = value;\n     }\n \n      * unzip command.\n      * @param mode an <code>int</code> value\n      */\n-    public void setUnixMode(int mode) {\n+    public void setUnixMode(final int mode) {\n         // CheckStyle:MagicNumberCheck OFF - no point\n         setExternalAttributes((mode << SHORT_SHIFT)\n                               // MS-DOS read-only attribute\n      * Set the platform (UNIX or FAT).\n      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX\n      */\n-    protected void setPlatform(int platform) {\n+    protected void setPlatform(final int platform) {\n         this.platform = platform;\n     }\n \n      * Replaces all currently attached extra fields with the new array.\n      * @param fields an array of extra fields\n      */\n-    public void setExtraFields(ZipExtraField[] fields) {\n+    public void setExtraFields(final ZipExtraField[] fields) {\n         List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();\n         for (ZipExtraField field : fields) {\n             if (field instanceof UnparseableExtraFieldData) {\n      *\n      * @since 1.1\n      */\n-    public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n+    public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {\n         return includeUnparseable ?\n                 getAllExtraFields() :\n                 getParseableExtraFields();\n         return unparseableExtra != null ? getMergedFields() : extraFields;\n     }\n \n-    private ZipExtraField[] copyOf(ZipExtraField[] src){\n+    private ZipExtraField[] copyOf(final ZipExtraField[] src){\n         return copyOf(src, src.length);\n     }\n \n-    private ZipExtraField[] copyOf(ZipExtraField[] src, int length) {\n+    private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length) {\n         ZipExtraField[] cpy = new ZipExtraField[length];\n         System.arraycopy(src, 0, cpy, 0, Math.min(src.length, length));\n         return cpy;\n      * added as last field.</p>\n      * @param ze an extra field\n      */\n-    public void addExtraField(ZipExtraField ze) {\n+    public void addExtraField(final ZipExtraField ze) {\n         if (ze instanceof UnparseableExtraFieldData) {\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n      * <p>The new extra field will be the first one.</p>\n      * @param ze an extra field\n      */\n-    public void addAsFirstExtraField(ZipExtraField ze) {\n+    public void addAsFirstExtraField(final ZipExtraField ze) {\n         if (ze instanceof UnparseableExtraFieldData) {\n             unparseableExtra = (UnparseableExtraFieldData) ze;\n         } else {\n      * Remove an extra field.\n      * @param type the type of extra field to remove\n      */\n-    public void removeExtraField(ZipShort type) {\n+    public void removeExtraField(final ZipShort type) {\n         if (extraFields == null) {\n             throw new java.util.NoSuchElementException();\n         }\n      * @param type the header id\n      * @return null if no such field exists.\n      */\n-    public ZipExtraField getExtraField(ZipShort type) {\n+    public ZipExtraField getExtraField(final ZipShort type) {\n         if (extraFields != null) {\n             for (ZipExtraField extraField : extraFields) {\n                 if (type.equals(extraField.getHeaderId())) {\n      * @throws RuntimeException on error\n      */\n     @Override\n-    public void setExtra(byte[] extra) throws RuntimeException {\n+    public void setExtra(final byte[] extra) throws RuntimeException {\n         try {\n             ZipExtraField[] local =\n                 ExtraFieldUtils.parse(extra, true,\n      * Sets the central directory part of extra fields.\n      * @param b an array of bytes to be parsed into extra fields\n      */\n-    public void setCentralDirectoryExtra(byte[] b) {\n+    public void setCentralDirectoryExtra(final byte[] b) {\n         try {\n             ZipExtraField[] central =\n                 ExtraFieldUtils.parse(b, false,\n      *            than 0\n      */\n     @Override\n-    public void setSize(long size) {\n+    public void setSize(final long size) {\n         if (size < 0) {\n             throw new IllegalArgumentException(\"invalid entry size\");\n         }\n      * archive\n      * @since 1.2\n      */\n-    protected void setName(String name, byte[] rawName) {\n+    protected void setName(final String name, final byte[] rawName) {\n         setName(name);\n         this.rawName = rawName;\n     }\n      * @param b the general purpose bit\n      * @since 1.1\n      */\n-    public void setGeneralPurposeBit(GeneralPurposeBit b) {\n+    public void setGeneralPurposeBit(final GeneralPurposeBit b) {\n         gpb = b;\n     }\n \n      * @param f the extra fields to merge\n      * @param local whether the new fields originate from local data\n      */\n-    private void mergeExtraFields(ZipExtraField[] f, boolean local)\n+    private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\n         throws ZipException {\n         if (extraFields == null) {\n             setExtraFields(f);\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (this == obj) {\n             return true;\n         }\n      * @param versionMadeBy \"version made by\" field\n      * @since 1.11\n      */\n-    public void setVersionMadeBy(int versionMadeBy) {\n+    public void setVersionMadeBy(final int versionMadeBy) {\n         this.versionMadeBy = versionMadeBy;\n     }\n \n      * @param versionRequired \"version required to expand\" field\n      * @since 1.11\n      */\n-    public void setVersionRequired(int versionRequired) {\n+    public void setVersionRequired(final int versionRequired) {\n         this.versionRequired = versionRequired;\n     }\n \n      * @param rawFlag content of the flags field\n      * @since 1.11\n      */\n-    public void setRawFlag(int rawFlag) {\n+    public void setRawFlag(final int rawFlag) {\n         this.rawFlag = rawFlag;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequest.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryRequest.java\n     private final int method;\n \n \n-    private ZipArchiveEntryRequest(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier payloadSupplier) {\n+    private ZipArchiveEntryRequest(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier payloadSupplier) {\n         // this constructor has \"safe\" access to all member variables on zipArchiveEntry\n         this.zipArchiveEntry = zipArchiveEntry;\n         this.payloadSupplier = payloadSupplier;\n      * @param payloadSupplier The payload that will be added to the zip entry.\n      * @return The newly created request\n      */\n-    public static ZipArchiveEntryRequest createZipArchiveEntryRequest(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier payloadSupplier) {\n+    public static ZipArchiveEntryRequest createZipArchiveEntryRequest(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier payloadSupplier) {\n         return new ZipArchiveEntryRequest(zipArchiveEntry, payloadSupplier);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n      * Create an instance using UTF-8 encoding\n      * @param inputStream the stream to wrap\n      */\n-    public ZipArchiveInputStream(InputStream inputStream) {\n+    public ZipArchiveInputStream(final InputStream inputStream) {\n         this(inputStream, ZipEncodingHelper.UTF8);\n     }\n \n      * for the platform's default encoding\n      * @since 1.5\n      */\n-    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n+    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n         this(inputStream, encoding, true);\n     }\n \n      * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n      * Extra Fields (if present) to set the file names.\n      */\n-    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n+    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n         this(inputStream, encoding, useUnicodeExtraFields, false);\n     }\n \n      * will try to read STORED entries that use a data descriptor\n      * @since 1.1\n      */\n-    public ZipArchiveInputStream(InputStream inputStream,\n-                                 String encoding,\n-                                 boolean useUnicodeExtraFields,\n-                                 boolean allowStoredEntriesWithDataDescriptor) {\n+    public ZipArchiveInputStream(final InputStream inputStream,\n+                                 final String encoding,\n+                                 final boolean useUnicodeExtraFields,\n+                                 final boolean allowStoredEntriesWithDataDescriptor) {\n         this.encoding = encoding;\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n      * deals with splitting/spanning markers that may prefix the first\n      * LFH.\n      */\n-    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n+    private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\n         readFully(lfh);\n         ZipLong sig = new ZipLong(lfh);\n         if (sig.equals(ZipLong.DD_SIG)) {\n      * information from it if sizes are 0xFFFFFFFF and the entry\n      * doesn't use a data descriptor.\n      */\n-    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n+    private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n         Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField) \n             current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n      * @since 1.1\n      */\n     @Override\n-    public boolean canReadEntryData(ArchiveEntry ae) {\n+    public boolean canReadEntryData(final ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n             return ZipUtil.canHandleEntryData(ze)\n     }\n \n     @Override\n-    public int read(byte[] buffer, int offset, int length) throws IOException {\n+    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n     /**\n      * Implementation of read for STORED entries.\n      */\n-    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n+    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n \n         if (current.hasDataDescriptor) {\n             if (lastStoredEntry == null) {\n     /**\n      * Implementation of read for DEFLATED entries.\n      */\n-    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n+    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n         int read = readFromInflater(buffer, offset, length);\n         if (read <= 0) {\n             if (inf.finished()) {\n      * Potentially reads more bytes to fill the inflater's buffer and\n      * reads from it.\n      */\n-    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n+    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n         int read = 0;\n         do {\n             if (inf.needsInput()) {\n      * @throws IllegalArgumentException - if value is negative.\n      */\n     @Override\n-    public long skip(long value) throws IOException {\n+    public long skip(final long value) throws IOException {\n         if (value >= 0) {\n             long skipped = 0;\n             while (skipped < value) {\n      * @param length    the number of bytes to check\n      * @return true, if this stream is a zip archive stream, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n             return false;\n         }\n             || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n     }\n \n-    private static boolean checksig(byte[] signature, byte[] expected) {\n+    private static boolean checksig(final byte[] signature, final byte[] expected) {\n         for (int i = 0; i < expected.length; i++) {\n             if (signature[i] != expected[i]) {\n                 return false;\n         return length;\n     }\n \n-    private void readFully(byte[] b) throws IOException {\n+    private void readFully(final byte[] b) throws IOException {\n         int count = IOUtils.readFully(in, b);\n         count(count);\n         if (count < b.length) {\n      * the entry doesn't require any data descriptor or the method is\n      * DEFLATED.\n      */\n-    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n+    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n         return !entry.getGeneralPurposeBit().usesDataDescriptor()\n \n                 || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n      * <p>If it contains such a signature, reads the data descriptor\n      * and positions the stream right after the data descriptor.</p>\n      */\n-    private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\n+    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n             throws IOException {\n \n         boolean done = false;\n      * <p>Data descriptor plus incomplete signature (3 bytes in the\n      * worst case) can be 20 bytes max.</p>\n      */\n-    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n+    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n         final int cacheable = offset + lastRead - expecteDDLen - 3;\n         if (cacheable > 0) {\n             bos.write(buf.array(), 0, cacheable);\n         return offset;\n     }\n \n-    private void pushback(byte[] buf, int offset, int length) throws IOException {\n+    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n         ((PushbackInputStream) in).unread(buf, offset, length);\n         pushedBackBytes(length);\n     }\n      *\n      * Also updates bytes-read counter.\n      */\n-    private void realSkip(long value) throws IOException {\n+    private void realSkip(final long value) throws IOException {\n         if (value >= 0) {\n             long skipped = 0;\n             while (skipped < value) {\n         return b;\n     }\n \n-    private boolean isFirstByteOfEocdSig(int b) {\n+    private boolean isFirstByteOfEocdSig(final int b) {\n         return b == ZipArchiveOutputStream.EOCD_SIG[0];\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n      * @param out the outputstream to zip\n      */\n-    public ZipArchiveOutputStream(OutputStream out) {\n+    public ZipArchiveOutputStream(final OutputStream out) {\n         this.out = out;\n         this.raf = null;\n         def = new Deflater(level, true);\n      * @param file the file to zip to\n      * @throws IOException on error\n      */\n-    public ZipArchiveOutputStream(File file) throws IOException {\n+    public ZipArchiveOutputStream(final File file) throws IOException {\n         OutputStream o = null;\n         RandomAccessFile _raf = null;\n         try {\n      * @param b whether to set the language encoding flag if the file\n      * name encoding is UTF-8\n      */\n-    public void setUseLanguageEncodingFlag(boolean b) {\n+    public void setUseLanguageEncodingFlag(final boolean b) {\n         useUTF8Flag = b && ZipEncodingHelper.isUTF8(encoding);\n     }\n \n      *\n      * @param b whether to create Unicode Extra Fields.\n      */\n-    public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\n+    public void setCreateUnicodeExtraFields(final UnicodeExtraFieldPolicy b) {\n         createUnicodeExtraFields = b;\n     }\n \n      * flag if the file name cannot be encoded using the specified\n      * encoding.\n      */\n-    public void setFallbackToUTF8(boolean b) {\n+    public void setFallbackToUTF8(final boolean b) {\n         fallbackToUTF8 = b;\n     }\n \n      * @since 1.3\n      * @param mode Whether Zip64 extensions will be used.\n      */\n-    public void setUseZip64(Zip64Mode mode) {\n+    public void setUseZip64(final Zip64Mode mode) {\n         zip64Mode = mode;\n     }\n \n      * @param phased              This entry is second phase of a 2-phase zip creation, size, compressed size and crc\n      *                            are known in ZipArchiveEntry\n      */\n-    private void closeCopiedEntry(boolean phased) throws IOException {\n+    private void closeCopiedEntry(final boolean phased) throws IOException {\n         preClose();\n         entry.bytesRead = entry.entry.getSize();\n         Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n         closeEntry(actuallyNeedsZip64, phased);\n     }\n \n-    private void closeEntry(boolean actuallyNeedsZip64, boolean phased) throws IOException {\n+    private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\n         if (!phased && raf != null) {\n             rewriteSizesAndCrc(actuallyNeedsZip64);\n         }\n      * @param rawStream The raw input stream of a different entry. May be compressed/encrypted.\n      * @throws IOException If copying fails\n      */\n-    public void addRawArchiveEntry(ZipArchiveEntry entry, InputStream rawStream)\n+    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\n             throws IOException {\n         ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n         if (hasZip64Extra(ae)) {\n      * Zip64Mode.Never case and returns whether the entry would\n      * require a Zip64 extra field.\n      */\n-    private boolean handleSizesAndCrc(long bytesWritten, long crc,\n-                                      Zip64Mode effectiveMode)\n+    private boolean handleSizesAndCrc(final long bytesWritten, final long crc,\n+                                      final Zip64Mode effectiveMode)\n         throws ZipException {\n         if (entry.entry.getMethod() == DEFLATED) {\n             /* It turns out def.getBytesRead() returns wrong values if\n      * Zip64Mode.Never case and returns whether the entry would\n      * require a Zip64 extra field.\n      */\n-    private boolean checkIfNeedsZip64(Zip64Mode effectiveMode)\n+    private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode)\n             throws ZipException {\n         final boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\n         if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\n         return actuallyNeedsZip64;\n     }\n \n-    private boolean isZip64Required(ZipArchiveEntry entry1, Zip64Mode requestedMode) {\n+    private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\n         return requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n     }\n \n-    private boolean isTooLageForZip32(ZipArchiveEntry zipArchiveEntry){\n+    private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry){\n         return zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n     }\n \n      * and potentiall the ZIP64 extra containing the correct CRC and\n      * compressed/uncompressed sizes.\n      */\n-    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n+    private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64)\n         throws IOException {\n         long save = raf.getFilePointer();\n \n      * is {@link Zip64Mode#Never}.\n      */\n     @Override\n-    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n+    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n         putArchiveEntry(archiveEntry, false);\n     }\n \n      * compressed size is known to exceed 4 GByte and {@link #setUseZip64}\n      * is {@link Zip64Mode#Never}.\n      */\n-    private void putArchiveEntry(ArchiveEntry archiveEntry, boolean phased) throws IOException {\n+    private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n      * Provides default values for compression method and last\n      * modification time.\n      */\n-    private void setDefaults(ZipArchiveEntry entry) {\n+    private void setDefaults(final ZipArchiveEntry entry) {\n         if (entry.getMethod() == -1) { // not specified\n             entry.setMethod(method);\n         }\n      * big to be written without Zip64 extra but the mode has been set\n      * to Never.\n      */\n-    private void validateSizeInformation(Zip64Mode effectiveMode)\n+    private void validateSizeInformation(final Zip64Mode effectiveMode)\n         throws ZipException {\n         // Size/CRC not required if RandomAccessFile is used\n         if (entry.entry.getMethod() == STORED && raf == null) {\n      * usage</li>\n      * </ul>\n      */\n-    private boolean shouldAddZip64Extra(ZipArchiveEntry entry, Zip64Mode mode) {\n+    private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\n         return mode == Zip64Mode.Always\n             || entry.getSize() >= ZIP64_MAGIC\n             || entry.getCompressedSize() >= ZIP64_MAGIC\n      * Set the file comment.\n      * @param comment the comment\n      */\n-    public void setComment(String comment) {\n+    public void setComment(final String comment) {\n         this.comment = comment;\n     }\n \n      * @throws IllegalArgumentException if an invalid compression\n      * level is specified.\n      */\n-    public void setLevel(int level) {\n+    public void setLevel(final int level) {\n         if (level < Deflater.DEFAULT_COMPRESSION\n             || level > Deflater.BEST_COMPRESSION) {\n             throw new IllegalArgumentException(\"Invalid compression level: \"\n      * <p>Default is DEFLATED.</p>\n      * @param method an <code>int</code> from java.util.zip.ZipEntry\n      */\n-    public void setMethod(int method) {\n+    public void setMethod(final int method) {\n         this.method = method;\n     }\n \n      * @since 1.1\n      */\n     @Override\n-    public boolean canWriteEntryData(ArchiveEntry ae) {\n+    public boolean canWriteEntryData(final ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n             return zae.getMethod() != ZipMethod.IMPLODING.getCode()\n      * @throws IOException on error\n      */\n     @Override\n-    public void write(byte[] b, int offset, int length) throws IOException {\n+    public void write(final byte[] b, final int offset, final int length) throws IOException {\n         if (entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n      * @param data the byte array to write\n      * @throws IOException on error\n      */\n-    private void writeCounted(byte[] data) throws IOException {\n+    private void writeCounted(final byte[] data) throws IOException {\n         streamCompressor.writeCounted(data);\n     }\n \n-    private void copyFromZipInputStream(InputStream src) throws IOException {\n+    private void copyFromZipInputStream(final InputStream src) throws IOException {\n         if (entry == null) {\n             throw new IllegalStateException(\"No current entry\");\n         }\n      * @param ze the entry to write\n      * @throws IOException on error\n      */\n-    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n+    protected void writeLocalFileHeader(final ZipArchiveEntry ze) throws IOException {\n         writeLocalFileHeader(ze, false);\n     }\n \n-    private void writeLocalFileHeader(ZipArchiveEntry ze, boolean phased) throws IOException {\n+    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n         boolean encodable = zipEncoding.canEncode(ze.getName());\n         ByteBuffer name = getName(ze);\n \n     }\n \n \n-    private byte[] createLocalFileHeader(ZipArchiveEntry ze, ByteBuffer name, boolean encodable,\n-                                         boolean phased)  {\n+    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n+                                         final boolean phased)  {\n         byte[] extra = ze.getLocalFileDataExtra();\n         final int nameLen = name.limit() - name.position();\n         int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n      * ALWAYS or the data cannot be encoded using the configured\n      * encoding.\n      */\n-    private void addUnicodeExtraFields(ZipArchiveEntry ze, boolean encodable,\n-                                       ByteBuffer name)\n+    private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encodable,\n+                                       final ByteBuffer name)\n         throws IOException {\n         if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n             || !encodable) {\n      * @param ze the entry to write\n      * @throws IOException on error\n      */\n-    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n+    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n         if (ze.getMethod() != DEFLATED || raf != null) {\n             return;\n         }\n      * GByte and {@link Zip64Mode #setUseZip64} is {@link\n      * Zip64Mode#Never}.\n      */\n-    protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n+    protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n         byte[] centralFileHeader = createCentralFileHeader(ze);\n         writeCounted(centralFileHeader);\n     }\n \n-    private byte[] createCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n+    private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n \n         final long lfhOffset = offsets.get(ze);\n         final boolean needsZip64Extra = hasZip64Extra(ze)\n      * @param lfhOffset Local file header offset for this file\n      * @throws IOException on error\n      */\n-    private byte[] createCentralFileHeader(ZipArchiveEntry ze, ByteBuffer name, long lfhOffset,\n-                                           boolean needsZip64Extra) throws IOException {\n+    private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final long lfhOffset,\n+                                           final boolean needsZip64Extra) throws IOException {\n         byte[] extra = ze.getCentralDirectoryExtra();\n \n         // file comment length\n      * If the entry needs Zip64 extra information inside the central\n      * directory then configure its data.\n      */\n-    private void handleZip64Extra(ZipArchiveEntry ze, long lfhOffset,\n-                                  boolean needsZip64Extra) {\n+    private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset,\n+                                  final boolean needsZip64Extra) {\n         if (needsZip64Extra) {\n             Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n             if (ze.getCompressedSize() >= ZIP64_MAGIC\n      * @param data the byte array to write\n      * @throws IOException on error\n      */\n-    protected final void writeOut(byte[] data) throws IOException {\n+    protected final void writeOut(final byte[] data) throws IOException {\n         streamCompressor.writeOut(data, 0, data.length);\n     }\n \n      * @param length the number of bytes to write\n      * @throws IOException on error\n      */\n-    protected final void writeOut(byte[] data, int offset, int length)\n+    protected final void writeOut(final byte[] data, final int offset, final int length)\n             throws IOException {\n         streamCompressor.writeOut(data, offset, length);\n     }\n                 INITIAL_VERSION;\n     }\n \n-    private boolean isDeflatedToOutputStream(int zipMethod) {\n+    private boolean isDeflatedToOutputStream(final int zipMethod) {\n         return zipMethod == DEFLATED && raf == null;\n     }\n \n      * <p>Must not be used if the stream has already been closed.</p>\n      */\n     @Override\n-    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n+    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName)\n         throws IOException {\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n      * @since 1.3\n      */\n     private Zip64ExtendedInformationExtraField\n-        getZip64Extra(ZipArchiveEntry ze) {\n+        getZip64Extra(final ZipArchiveEntry ze) {\n         if (entry != null) {\n             entry.causedUseOfZip64 = !hasUsedZip64;\n         }\n      *\n      * @since 1.3\n      */\n-    private boolean hasZip64Extra(ZipArchiveEntry ze) {\n+    private boolean hasZip64Extra(final ZipArchiveEntry ze) {\n         return ze.getExtraField(Zip64ExtendedInformationExtraField\n                                 .HEADER_ID)\n             != null;\n      *\n      * @since 1.3\n      */\n-    private Zip64Mode getEffectiveZip64Mode(ZipArchiveEntry ze) {\n+    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n         if (zip64Mode != Zip64Mode.AsNeeded\n             || raf != null\n             || ze.getMethod() != DEFLATED\n         return Zip64Mode.Never;\n     }\n \n-    private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {\n+    private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n         boolean encodable = zipEncoding.canEncode(ze.getName());\n         return !encodable && fallbackToUTF8\n             ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n     }\n \n-    private ByteBuffer getName(ZipArchiveEntry ze) throws IOException {\n+    private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n         return getEntryEncoding(ze).encode(ze.getName());\n     }\n \n             new UnicodeExtraFieldPolicy(\"not encodeable\");\n \n         private final String name;\n-        private UnicodeExtraFieldPolicy(String n) {\n+        private UnicodeExtraFieldPolicy(final String n) {\n             name = n;\n         }\n         @Override\n      * currently being written.\n      */\n     private static final class CurrentEntry {\n-        private CurrentEntry(ZipArchiveEntry entry) {\n+        private CurrentEntry(final ZipArchiveEntry entry) {\n             this.entry = entry;\n         }\n         /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n      * Create instance from a number.\n      * @param value the long to store as a ZipEightByteInteger\n      */\n-    public ZipEightByteInteger(long value) {\n+    public ZipEightByteInteger(final long value) {\n         this(BigInteger.valueOf(value));\n     }\n \n      * Create instance from a number.\n      * @param value the BigInteger to store as a ZipEightByteInteger\n      */\n-    public ZipEightByteInteger(BigInteger value) {\n+    public ZipEightByteInteger(final BigInteger value) {\n         this.value = value;\n     }\n \n      * Create instance from bytes.\n      * @param bytes the bytes to store as a ZipEightByteInteger\n      */\n-    public ZipEightByteInteger (byte[] bytes) {\n+    public ZipEightByteInteger (final byte[] bytes) {\n         this(bytes, 0);\n     }\n \n      * @param bytes the bytes to store as a ZipEightByteInteger\n      * @param offset the offset to start\n      */\n-    public ZipEightByteInteger (byte[] bytes, int offset) {\n+    public ZipEightByteInteger (final byte[] bytes, final int offset) {\n         value = ZipEightByteInteger.getValue(bytes, offset);\n     }\n \n      * @param value the value to convert\n      * @return value as eight bytes in big endian byte order\n      */\n-    public static byte[] getBytes(long value) {\n+    public static byte[] getBytes(final long value) {\n         return getBytes(BigInteger.valueOf(value));\n     }\n \n      * @param value the value to convert\n      * @return value as eight bytes in big endian byte order\n      */\n-    public static byte[] getBytes(BigInteger value) {\n+    public static byte[] getBytes(final BigInteger value) {\n         byte[] result = new byte[8];\n         long val = value.longValue();\n         result[0] = (byte) ((val & BYTE_MASK));\n      * @param offset the offset to start\n      * @return the corresponding Java long value\n      */\n-    public static long getLongValue(byte[] bytes, int offset) {\n+    public static long getLongValue(final byte[] bytes, final int offset) {\n         return getValue(bytes, offset).longValue();\n     }\n \n      * @param offset the offset to start\n      * @return the corresponding Java BigInteger value\n      */\n-    public static BigInteger getValue(byte[] bytes, int offset) {\n+    public static BigInteger getValue(final byte[] bytes, final int offset) {\n         long value = ((long) bytes[offset + BYTE_7] << BYTE_7_SHIFT) & BYTE_7_MASK;\n         value += ((long) bytes[offset + BYTE_6] << BYTE_6_SHIFT) & BYTE_6_MASK;\n         value += ((long) bytes[offset + BYTE_5] << BYTE_5_SHIFT) & BYTE_5_MASK;\n      * @param bytes the array of bytes\n      * @return the corresponding Java long value\n      */\n-    public static long getLongValue(byte[] bytes) {\n+    public static long getLongValue(final byte[] bytes) {\n         return getLongValue(bytes, 0);\n     }\n \n      * @param bytes the array of bytes\n      * @return the corresponding Java BigInteger value\n      */\n-    public static BigInteger getValue(byte[] bytes) {\n+    public static BigInteger getValue(final byte[] bytes) {\n         return getValue(bytes, 0);\n     }\n \n      * @return true if the objects are equal\n      */\n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o == null || !(o instanceof ZipEightByteInteger)) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n          * \n          * @see Simple8BitZipEncoding#Simple8BitZipEncoding(char[])\n          */\n-        SimpleEncodingHolder(char [] highChars) {\n+        SimpleEncodingHolder(final char [] highChars) {\n             this.highChars = highChars;\n         }\n \n      *         of <code>r</code>.\n      *\n      */\n-    static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\n+    static ByteBuffer growBuffer(final ByteBuffer b, final int newCapacity) {\n         b.limit(b.position());\n         b.rewind();\n \n      * @param bb The byte buffer to write to.\n      * @param c The character to write.\n      */\n-    static void appendSurrogate(ByteBuffer bb, char c) {\n+    static void appendSurrogate(final ByteBuffer bb, final char c) {\n \n         bb.put((byte) '%');\n         bb.put((byte) 'U');\n      *             the platform's default encoding.\n      * @return A zip encoding for the given encoding name.\n      */\n-    public static ZipEncoding getZipEncoding(String name) {\n+    public static ZipEncoding getZipEncoding(final String name) {\n  \n         // fallback encoding is good enough for UTF-8.\n         if (isUTF8(name)) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n-    public ZipFile(File f) throws IOException {\n+    public ZipFile(final File f) throws IOException {\n         this(f, ZipEncodingHelper.UTF8);\n     }\n \n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n-    public ZipFile(String name) throws IOException {\n+    public ZipFile(final String name) throws IOException {\n         this(new File(name), ZipEncodingHelper.UTF8);\n     }\n \n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n-    public ZipFile(String name, String encoding) throws IOException {\n+    public ZipFile(final String name, final String encoding) throws IOException {\n         this(new File(name), encoding, true);\n     }\n \n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n-    public ZipFile(File f, String encoding) throws IOException {\n+    public ZipFile(final File f, final String encoding) throws IOException {\n         this(f, encoding, true);\n     }\n \n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n-    public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\n+    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\n         throws IOException {\n         this.archiveName = f.getAbsolutePath();\n         this.encoding = encoding;\n      * on a null parameter\n      * @param zipfile file to close, can be null\n      */\n-    public static void closeQuietly(ZipFile zipfile) {\n+    public static void closeQuietly(final ZipFile zipfile) {\n         IOUtils.closeQuietly(zipfile);\n     }\n \n      * @return the ZipArchiveEntry corresponding to the given name - or\n      * {@code null} if not present.\n      */\n-    public ZipArchiveEntry getEntry(String name) {\n+    public ZipArchiveEntry getEntry(final String name) {\n         LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n         return entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n     }\n      * given name\n      * @since 1.6\n      */\n-    public Iterable<ZipArchiveEntry> getEntries(String name) {\n+    public Iterable<ZipArchiveEntry> getEntries(final String name) {\n         List<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n         return entriesOfThatName != null ? entriesOfThatName\n             : Collections.<ZipArchiveEntry>emptyList();\n      * given name\n      * @since 1.6\n      */\n-    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(String name) {\n+    public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(final String name) {\n         ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n         if (nameMap.containsKey(name)) {\n             entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n      * @param ze the entry\n      * @return whether this class is able to read the given entry.\n      */\n-    public boolean canReadEntryData(ZipArchiveEntry ze) {\n+    public boolean canReadEntryData(final ZipArchiveEntry ze) {\n         return ZipUtil.canHandleEntryData(ze);\n     }\n \n      * @return The raw input stream containing (possibly) compressed data.\n      * @since 1.11\n      */\n-    public InputStream getRawInputStream(ZipArchiveEntry ze) {\n+    public InputStream getRawInputStream(final ZipArchiveEntry ze) {\n         if (!(ze instanceof Entry)) {\n             return null;\n         }\n      * @param predicate A predicate that selects which entries to write\n      * @throws IOException on error\n      */\n-    public void copyRawEntries(ZipArchiveOutputStream target, ZipArchiveEntryPredicate predicate)\n+    public void copyRawEntries(final ZipArchiveOutputStream target, final ZipArchiveEntryPredicate predicate)\n             throws IOException {\n         Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();\n         while (src.hasMoreElements()) {\n      * @throws IOException if unable to create an input stream from the zipentry\n      * @throws ZipException if the zipentry uses an unsupported feature\n      */\n-    public InputStream getInputStream(ZipArchiveEntry ze)\n+    public InputStream getInputStream(final ZipArchiveEntry ze)\n         throws IOException, ZipException {\n         if (!(ze instanceof Entry)) {\n             return null;\n      * @throws IOException problem with content's input stream\n      * @since 1.5\n      */\n-    public String getUnixSymlink(ZipArchiveEntry entry) throws IOException {\n+    public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {\n         if (entry != null && entry.isUnixSymlink()) {\n             InputStream in = null;\n             try {\n      * added to this map.\n      */\n     private void\n-        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n+        readCentralDirectoryEntry(final Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n         throws IOException {\n         archive.readFully(CFH_BUF);\n         int off = 0;\n      * even if they are never used - and here a field with only one\n      * size would be invalid.</p>\n      */\n-    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n-                                                 OffsetEntry offset,\n-                                                 int diskStart)\n+    private void setSizesAndOffsetFromZip64Extra(final ZipArchiveEntry ze,\n+                                                 final OffsetEntry offset,\n+                                                 final int diskStart)\n         throws IOException {\n         Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField)\n      * for the given signature, positions the RandomaccessFile right\n      * at the signature if it has been found.\n      */\n-    private boolean tryToLocateSignature(long minDistanceFromEnd,\n-                                         long maxDistanceFromEnd,\n-                                         byte[] sig) throws IOException {\n+    private boolean tryToLocateSignature(final long minDistanceFromEnd,\n+                                         final long maxDistanceFromEnd,\n+                                         final byte[] sig) throws IOException {\n         boolean found = false;\n         long off = archive.length() - minDistanceFromEnd;\n         final long stopSearching =\n      * <p>Also records the offsets for the data to read from the\n      * entries.</p>\n      */\n-    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n+    private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\n                                             entriesWithoutUTF8Flag)\n         throws IOException {\n         for (ZipArchiveEntry zipArchiveEntry : entries) {\n         private long loc;\n         private boolean addDummyByte = false;\n \n-        BoundedInputStream(long start, long remaining) {\n+        BoundedInputStream(final long start, final long remaining) {\n             this.remaining = remaining;\n             loc = start;\n         }\n         }\n \n         @Override\n-        public int read(byte[] b, int off, int len) throws IOException {\n+        public int read(final byte[] b, final int off, int len) throws IOException {\n             if (remaining <= 0) {\n                 if (addDummyByte) {\n                     addDummyByte = false;\n     private static final class NameAndComment {\n         private final byte[] name;\n         private final byte[] comment;\n-        private NameAndComment(byte[] name, byte[] comment) {\n+        private NameAndComment(final byte[] name, final byte[] comment) {\n             this.name = name;\n             this.comment = comment;\n         }\n     private final Comparator<ZipArchiveEntry> OFFSET_COMPARATOR =\n         new Comparator<ZipArchiveEntry>() {\n         @Override\n-        public int compare(ZipArchiveEntry e1, ZipArchiveEntry e2) {\n+        public int compare(final ZipArchiveEntry e1, final ZipArchiveEntry e2) {\n             if (e1 == e2) {\n                 return 0;\n             }\n \n         private final OffsetEntry offsetEntry;\n \n-        Entry(OffsetEntry offset) {\n+        Entry(final OffsetEntry offset) {\n             this.offsetEntry = offset;\n         }\n \n         }\n \n         @Override\n-        public boolean equals(Object other) {\n+        public boolean equals(final Object other) {\n             if (super.equals(other)) {\n                 // super.equals would return false if other were not an Entry\n                 Entry otherEntry = (Entry) other;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n      * Create instance from a number.\n      * @param value the long to store as a ZipLong\n      */\n-    public ZipLong(long value) {\n+    public ZipLong(final long value) {\n         this.value = value;\n     }\n \n      * Create instance from bytes.\n      * @param bytes the bytes to store as a ZipLong\n      */\n-    public ZipLong (byte[] bytes) {\n+    public ZipLong (final byte[] bytes) {\n         this(bytes, 0);\n     }\n \n      * @param bytes the bytes to store as a ZipLong\n      * @param offset the offset to start\n      */\n-    public ZipLong (byte[] bytes, int offset) {\n+    public ZipLong (final byte[] bytes, final int offset) {\n         value = ZipLong.getValue(bytes, offset);\n     }\n \n      * @param value the value to convert\n      * @return value as four bytes in big endian byte order\n      */\n-    public static byte[] getBytes(long value) {\n+    public static byte[] getBytes(final long value) {\n         byte[] result = new byte[WORD];\n         putLong(value, result, 0);\n         return result;\n      *         must be non-negative and no larger than <tt>buf.length-4</tt>\n      */\n \n-    public static void putLong(long value, byte[] buf, int offset) {\n+    public static void putLong(final long value, final byte[] buf, int offset) {\n         buf[offset++] = (byte) ((value & BYTE_MASK));\n         buf[offset++] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n         buf[offset++] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\n         buf[offset] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\n     }\n \n-    public void putLong(byte[] buf, int offset) {\n+    public void putLong(final byte[] buf, final int offset) {\n         putLong(value, buf, offset);\n     }\n \n      * @param offset the offset to start\n      * @return the corresponding Java long value\n      */\n-    public static long getValue(byte[] bytes, int offset) {\n+    public static long getValue(final byte[] bytes, final int offset) {\n         long value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\n         value += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\n         value += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n      * @param bytes the array of bytes\n      * @return the corresponding Java long value\n      */\n-    public static long getValue(byte[] bytes) {\n+    public static long getValue(final byte[] bytes) {\n         return getValue(bytes, 0);\n     }\n \n      * @return true if the objects are equal\n      */\n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o == null || !(o instanceof ZipLong)) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n     /**\n      * private constructor for enum style class.\n      */\n-    ZipMethod(int code) {\n+    ZipMethod(final int code) {\n         this.code = code;\n     }\n \n      * @return the {@link ZipMethod} for the given code or null if the\n      * method is not known.\n      */\n-    public static ZipMethod getMethodByCode(int code) {\n+    public static ZipMethod getMethodByCode(final int code) {\n         return codeToEnum.get(code);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n      * Create instance from a number.\n      * @param value the int to store as a ZipShort\n      */\n-    public ZipShort (int value) {\n+    public ZipShort (final int value) {\n         this.value = value;\n     }\n \n      * Create instance from bytes.\n      * @param bytes the bytes to store as a ZipShort\n      */\n-    public ZipShort (byte[] bytes) {\n+    public ZipShort (final byte[] bytes) {\n         this(bytes, 0);\n     }\n \n      * @param bytes the bytes to store as a ZipShort\n      * @param offset the offset to start\n      */\n-    public ZipShort (byte[] bytes, int offset) {\n+    public ZipShort (final byte[] bytes, final int offset) {\n         value = ZipShort.getValue(bytes, offset);\n     }\n \n      * @param value the Java int to convert to bytes\n      * @return the converted int as a byte array in big endian byte order\n      */\n-    public static byte[] getBytes(int value) {\n+    public static byte[] getBytes(final int value) {\n         byte[] result = new byte[2];\n         putShort(value, result, 0);\n         return result;\n      *         The offset within the output buffer of the first byte to be written.\n      *         must be non-negative and no larger than <tt>buf.length-2</tt>\n      */\n-    public static void putShort(int value, byte[] buf, int offset) {\n+    public static void putShort(final int value, final byte[] buf, final int offset) {\n         buf[offset] = (byte) (value & BYTE_MASK);\n         buf[offset+1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n     }\n      * @param offset the offset to start\n      * @return the corresponding java int value\n      */\n-    public static int getValue(byte[] bytes, int offset) {\n+    public static int getValue(final byte[] bytes, final int offset) {\n         int value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n         value += (bytes[offset] & BYTE_MASK);\n         return value;\n      * @param bytes the array of bytes\n      * @return the corresponding java int value\n      */\n-    public static int getValue(byte[] bytes) {\n+    public static int getValue(final byte[] bytes) {\n         return getValue(bytes, 0);\n     }\n \n      * @return true if the objects are equal\n      */\n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(final Object o) {\n         if (o == null || !(o instanceof ZipShort)) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n      * @param time the <code>Date</code> to convert\n      * @return the date as a <code>ZipLong</code>\n      */\n-    public static ZipLong toDosTime(Date time) {\n+    public static ZipLong toDosTime(final Date time) {\n         return new ZipLong(toDosTime(time.getTime()));\n     }\n \n      * @param t number of milliseconds since the epoch\n      * @return the date as a byte array\n      */\n-    public static byte[] toDosTime(long t) {\n+    public static byte[] toDosTime(final long t) {\n         byte[] result = new byte[4];\n         toDosTime(t, result, 0);\n         return result;\n      *         The offset within the output buffer of the first byte to be written.\n      *         must be non-negative and no larger than <tt>buf.length-4</tt>\n      */\n-    public static void toDosTime(long t, byte[] buf, int offset) {\n+    public static void toDosTime(final long t, final byte[] buf, final int offset) {\n         toDosTime(Calendar.getInstance(), t, buf, offset);\n     }\n \n-    static void toDosTime(Calendar c, long t, byte[] buf, int offset) {\n+    static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\n         c.setTimeInMillis(t);\n \n         int year = c.get(Calendar.YEAR);\n      * @param i the value to treat as unsigned int.\n      * @return the unsigned int as a long.\n      */\n-    public static long adjustToLong(int i) {\n+    public static long adjustToLong(final int i) {\n         if (i < 0) {\n             return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n         }\n      * @param big BigInteger to convert.\n      * @return long representation of the BigInteger.\n      */\n-    static long bigToLong(BigInteger big) {\n+    static long bigToLong(final BigInteger big) {\n         if (big.bitLength() <= 63) { // bitLength() doesn't count the sign bit.\n             return big.longValue();\n         }\n      * @return int representation of the provided byte\n      * @since 1.5\n      */\n-    public static int signedByteToUnsignedInt(byte b) {\n+    public static int signedByteToUnsignedInt(final byte b) {\n         if (b >= 0) {\n             return b;\n         }\n      * @throws IllegalArgumentException if the provided integer is not inside the range [0,255].\n      * @since 1.5\n      */\n-    public static byte unsignedIntToSignedByte(int i) {\n+    public static byte unsignedIntToSignedByte(final int i) {\n         if (i > 255 || i < 0) {\n             throw new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n         }\n      * @param zipDosTime contains the stored DOS time.\n      * @return a Date instance corresponding to the given time.\n      */\n-    public static Date fromDosTime(ZipLong zipDosTime) {\n+    public static Date fromDosTime(final ZipLong zipDosTime) {\n         long dosTime = zipDosTime.getValue();\n         return new Date(dosToJavaTime(dosTime));\n     }\n      * @param dosTime time to convert\n      * @return converted time\n      */\n-    public static long dosToJavaTime(long dosTime) {\n+    public static long dosToJavaTime(final long dosTime) {\n         Calendar cal = Calendar.getInstance();\n         // CheckStyle:MagicNumberCheck OFF - no point\n         cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\n      * names/comments match those of the extra fields, transfer the\n      * known Unicode values from the extra field.\n      */\n-    static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\n-                                                 byte[] originalNameBytes,\n-                                                 byte[] commentBytes) {\n+    static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze,\n+                                                 final byte[] originalNameBytes,\n+                                                 final byte[] commentBytes) {\n         UnicodePathExtraField name = (UnicodePathExtraField)\n             ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n         String originalName = ze.getName();\n      * instead.</p>\n      */\n     private static \n-        String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\n-                                                 byte[] orig) {\n+        String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f,\n+                                                 final byte[] orig) {\n         if (f != null) {\n             CRC32 crc32 = new CRC32();\n             crc32.update(orig);\n      * Create a copy of the given array - or return null if the\n      * argument is null.\n      */\n-    static byte[] copy(byte[] from) {\n+    static byte[] copy(final byte[] from) {\n         if (from != null) {\n             byte[] to = new byte[from.length];\n             System.arraycopy(from, 0, to, 0, to.length);\n         }\n         return null;\n     }\n-    static void copy(byte[] from, byte[] to, int offset) {\n+    static void copy(final byte[] from, final byte[] to, final int offset) {\n         if (from != null) {\n             System.arraycopy(from, 0, to, offset, from.length);\n         }\n     /**\n      * Whether this library is able to read or write the given entry.\n      */\n-    static boolean canHandleEntryData(ZipArchiveEntry entry) {\n+    static boolean canHandleEntryData(final ZipArchiveEntry entry) {\n         return supportsEncryptionOf(entry) && supportsMethodOf(entry);\n     }\n \n      *\n      * @return true if the entry isn't encrypted at all\n      */\n-    private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\n+    private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\n         return !entry.getGeneralPurposeBit().usesEncryption();\n     }\n \n      *\n      * @return true if the compression method is STORED or DEFLATED\n      */\n-    private static boolean supportsMethodOf(ZipArchiveEntry entry) {\n+    private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\n         return entry.getMethod() == ZipEntry.STORED\n             || entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n             || entry.getMethod() == ZipMethod.IMPLODING.getCode()\n      * Checks whether the entry requires features not (yet) supported\n      * by the library and throws an exception if it does.\n      */\n-    static void checkRequestedFeatures(ZipArchiveEntry ze)\n+    static void checkRequestedFeatures(final ZipArchiveEntry ze)\n         throws UnsupportedZipFeatureException {\n         if (!supportsEncryptionOf(ze)) {\n             throw\n--- a/src/main/java/org/apache/commons/compress/changes/Change.java\n+++ b/src/main/java/org/apache/commons/compress/changes/Change.java\n      * from the stream as argument.\n      * @param pFilename the filename of the file to delete\n      */\n-    Change(final String pFilename, int type) {\n+    Change(final String pFilename, final int type) {\n         if(pFilename == null) {\n             throw new NullPointerException();\n         }\n      * @param pEntry the entry details\n      * @param pInput the InputStream for the entry data\n      */\n-    Change(final ArchiveEntry pEntry, final InputStream pInput, boolean replace) {\n+    Change(final ArchiveEntry pEntry, final InputStream pInput, final boolean replace) {\n         if(pEntry == null || pInput == null) {\n             throw new NullPointerException();\n         }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n      * @param pChange\n      *            the change which should result in an addition\n      */\n-    private void addAddition(Change pChange) {\n+    private void addAddition(final Change pChange) {\n         if (Change.TYPE_ADD != pChange.type() ||\n             pChange.getInput() == null) {\n             return;\n      * @param pChange\n      *            the change which should result in a deletion\n      */\n-    private void addDeletion(Change pChange) {\n+    private void addDeletion(final Change pChange) {\n         if ((Change.TYPE_DELETE != pChange.type() &&\n             Change.TYPE_DELETE_DIR != pChange.type()) ||\n             pChange.targetFile() == null) {\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n      *             if an read/write error occurs\n      * @return the results of this operation\n      */\n-    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n+    public ChangeSetResults perform(final ArchiveInputStream in, final ArchiveOutputStream out)\n             throws IOException {\n         return perform(new ArchiveInputStreamIterator(in), out);\n     }\n      * @return the results of this operation\n      * @since 1.5\n      */\n-    public ChangeSetResults perform(ZipFile in, ArchiveOutputStream out)\n+    public ChangeSetResults perform(final ZipFile in, final ArchiveOutputStream out)\n             throws IOException {\n         return perform(new ZipFileIterator(in), out);\n     }\n      *             if an read/write error occurs\n      * @return the results of this operation\n      */\n-    private ChangeSetResults perform(ArchiveEntryIterator entryIterator,\n-                                     ArchiveOutputStream out)\n+    private ChangeSetResults perform(final ArchiveEntryIterator entryIterator,\n+                                     final ArchiveOutputStream out)\n             throws IOException {\n         ChangeSetResults results = new ChangeSetResults();\n \n      *            the entry to check\n      * @return true, if this entry has an deletion change later, false otherwise\n      */\n-    private boolean isDeletedLater(Set<Change> workingSet, ArchiveEntry entry) {\n+    private boolean isDeletedLater(final Set<Change> workingSet, final ArchiveEntry entry) {\n         String source = entry.getName();\n \n         if (!workingSet.isEmpty()) {\n      * @throws IOException\n      *             if data cannot be read or written\n      */\n-    private void copyStream(InputStream in, ArchiveOutputStream out,\n-            ArchiveEntry entry) throws IOException {\n+    private void copyStream(final InputStream in, final ArchiveOutputStream out,\n+            final ArchiveEntry entry) throws IOException {\n         out.putArchiveEntry(entry);\n         IOUtils.copy(in, out);\n         out.closeArchiveEntry();\n         implements ArchiveEntryIterator {\n         private final ArchiveInputStream in;\n         private ArchiveEntry next;\n-        ArchiveInputStreamIterator(ArchiveInputStream in) {\n+        ArchiveInputStreamIterator(final ArchiveInputStream in) {\n             this.in = in;\n         }\n         @Override\n         private final ZipFile in;\n         private final Enumeration<ZipArchiveEntry> nestedEnum;\n         private ZipArchiveEntry current;\n-        ZipFileIterator(ZipFile in) {\n+        ZipFileIterator(final ZipFile in) {\n             this.in = in;\n             nestedEnum = in.getEntriesInPhysicalOrder();\n         }\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetResults.java\n      * Adds the filename of a recently deleted file to the result list.\n      * @param fileName the file which has been deleted\n      */\n-    void deleted(String fileName) {\n+    void deleted(final String fileName) {\n         deleted.add(fileName);\n     }\n \n      * copied from the source stream to the target stream.\n      * @param fileName the file name which has been added from the original stream\n      */\n-    void addedFromStream(String fileName) {\n+    void addedFromStream(final String fileName) {\n         addedFromStream.add(fileName);\n     }\n \n      * copied from the changeset to the target stream\n      * @param fileName the name of the file\n      */\n-    void addedFromChangeSet(String fileName) {\n+    void addedFromChangeSet(final String fileName) {\n         addedFromChangeSet.add(fileName);\n     }\n \n      * @param filename the filename to check\n      * @return true, if this filename already has been added\n      */\n-    boolean hasBeenAdded(String filename) {\n+    boolean hasBeenAdded(final String filename) {\n         if(addedFromChangeSet.contains(filename) || addedFromStream.contains(filename)) {\n             return true;\n         } \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorException.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorException.java\n      * @param message\n      *            the detail message\n      */\n-    public CompressorException(String message) {\n+    public CompressorException(final String message) {\n         super(message);\n     }\n \n      * @param cause\n      *            the cause\n      */\n-    public CompressorException(String message, Throwable cause) {\n+    public CompressorException(final String message, final Throwable cause) {\n         super(message, cause);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorInputStream.java\n      *\n      * @since 1.1\n      */\n-    protected void count(int read) {\n+    protected void count(final int read) {\n         count((long) read);\n     }\n \n      * \n      * @param read the number of bytes read\n      */\n-    protected void count(long read) {\n+    protected void count(final long read) {\n         if (read != -1) {\n             bytesRead = bytesRead + read;\n         }\n      * @param pushedBack the number of bytes pushed back.\n      * @since 1.7\n      */\n-    protected void pushedBackBytes(long pushedBack) {\n+    protected void pushedBackBytes(final long pushedBack) {\n         bytesRead -= pushedBack;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n      *           This setting applies to the gzip, bzip2 and xz formats only.\n      * @since 1.10\n      */\n-    public CompressorStreamFactory(boolean decompressUntilEOF) {\n+    public CompressorStreamFactory(final boolean decompressUntilEOF) {\n         this.decompressUntilEOF = Boolean.valueOf(decompressUntilEOF);\n         // Also copy to existing variable so can continue to use that as the current value\n         this.decompressConcatenated = decompressUntilEOF;\n      * was used to create the factory\n      */\n     @Deprecated\n-    public void setDecompressConcatenated(boolean decompressConcatenated) {\n+    public void setDecompressConcatenated(final boolean decompressConcatenated) {\n         if (this.decompressUntilEOF != null) {\n             throw new IllegalStateException(\"Cannot override the setting defined by the constructor\");\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n      *\n      * @param defaultExtension the format's default extension like \".gz\"\n      */\n-    public FileNameUtil(Map<String, String> uncompressSuffix,\n-                        String defaultExtension) {\n+    public FileNameUtil(final Map<String, String> uncompressSuffix,\n+                        final String defaultExtension) {\n         this.uncompressSuffix = Collections.unmodifiableMap(uncompressSuffix);\n         int lc = Integer.MIN_VALUE, sc = Integer.MAX_VALUE;\n         int lu = Integer.MIN_VALUE, su = Integer.MAX_VALUE;\n      * @return {@code true} if the filename has a common format suffix,\n      *         {@code false} otherwise\n      */\n-    public boolean isCompressedFilename(String filename) {\n+    public boolean isCompressedFilename(final String filename) {\n         final String lower = filename.toLowerCase(Locale.ENGLISH);\n         final int n = lower.length();\n         for (int i = shortestCompressedSuffix;\n      * @param filename name of a file\n      * @return name of the corresponding uncompressed file\n      */\n-    public String getUncompressedFilename(String filename) {\n+    public String getUncompressedFilename(final String filename) {\n         final String lower = filename.toLowerCase(Locale.ENGLISH);\n         final int n = lower.length();\n         for (int i = shortestCompressedSuffix;\n      * @param filename name of a file\n      * @return name of the corresponding compressed file\n      */\n-    public String getCompressedFilename(String filename) {\n+    public String getCompressedFilename(final String filename) {\n         final String lower = filename.toLowerCase(Locale.ENGLISH);\n         final int n = lower.length();\n         for (int i = shortestUncompressedSuffix;\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n         }\n     }\n \n-    private boolean init(boolean isFirstStream) throws IOException {\n+    private boolean init(final boolean isFirstStream) throws IOException {\n         if (null == in) {\n             throw new IOException(\"No InputStream\");\n         }\n         // 4560782 byte\n         // ===============\n \n-        Data(int blockSize100k) {\n+        Data(final int blockSize100k) {\n             this.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n         }\n \n          * I don't initialize it at construction time to avoid unneccessary\n          * memory allocation when compressing small files.\n          */\n-        int[] initTT(int length) {\n+        int[] initTT(final int length) {\n             int[] ttShadow = this.tt;\n \n             // tt.length should always be >= length, but theoretically\n      * \n      * @since 1.1\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n \n         if (length < 3) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n      *            The length of the data which will be compressed by\n      *            {@code BZip2CompressorOutputStream}.\n      */\n-    public static int chooseBlockSize(long inputLength) {\n+    public static int chooseBlockSize(final long inputLength) {\n         return (inputLength > 0) ? (int) Math\n             .min((inputLength / 132000) + 1, 9) : MAX_BLOCKSIZE;\n     }\n          */\n         int origPtr;\n \n-        Data(int blockSize100k) {\n+        Data(final int blockSize100k) {\n             final int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\n             this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\n             this.fmap = new int[n];\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n      * @return {@code true} if the filename has a common bzip2 suffix,\n      *         {@code false} otherwise\n      */\n-    public static boolean isCompressedFilename(String filename) {\n+    public static boolean isCompressedFilename(final String filename) {\n         return fileNameUtil.isCompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding uncompressed file\n      */\n-    public static String getUncompressedFilename(String filename) {\n+    public static String getUncompressedFilename(final String filename) {\n         return fileNameUtil.getUncompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding compressed file\n      */\n-    public static String getCompressedFilename(String filename) {\n+    public static String getCompressedFilename(final String filename) {\n         return fileNameUtil.getCompressedFilename(filename);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n      * @param lo lower boundary of the fmap-interval to be sorted \n      * @param hi upper boundary of the fmap-interval to be sorted \n      */\n-    private void fallbackSimpleSort(int[] fmap, \n-                                    int[] eclass, \n-                                    int lo, \n-                                    int hi) {\n+    private void fallbackSimpleSort(final int[] fmap, \n+                                    final int[] eclass, \n+                                    final int lo, \n+                                    final int hi) {\n         if (lo == hi) {\n             return;\n         }\n     /**\n      * swaps two values in fmap\n      */\n-    private void fswap(int[] fmap, int zz1, int zz2) {\n+    private void fswap(final int[] fmap, final int zz1, final int zz2) {\n         int zztmp = fmap[zz1];\n         fmap[zz1] = fmap[zz2];\n         fmap[zz2] = zztmp;\n     /**\n      * swaps two intervals starting at yyp1 and yyp2 of length yyn inside fmap.\n      */\n-    private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\n+    private void fvswap(final int[] fmap, int yyp1, int yyp2, int yyn) {\n         while (yyn > 0) {\n             fswap(fmap, yyp1, yyp2);\n             yyp1++; yyp2++; yyn--;\n         }\n     }\n \n-    private int fmin(int a, int b) {\n+    private int fmin(final int a, final int b) {\n         return a < b ? a : b;\n     }\n \n-    private void fpush(int sp, int lz, int hz) {\n+    private void fpush(final int sp, final int lz, final int hz) {\n         stack_ll[sp] = lz;\n         stack_hh[sp] = hz;\n     }\n \n-    private int[] fpop(int sp) {\n+    private int[] fpop(final int sp) {\n         return new int[] { stack_ll[sp], stack_hh[sp] };\n     }\n \n      * @param loSt lower boundary of the fmap-interval to be sorted \n      * @param hiSt upper boundary of the fmap-interval to be sorted \n      */\n-    private void fallbackQSort3(int[] fmap, \n-                                int[] eclass, \n-                                int loSt, \n-                                int hiSt) {\n+    private void fallbackQSort3(final int[] fmap, \n+                                final int[] eclass, \n+                                final int loSt, \n+                                final int hiSt) {\n         int lo, unLo, ltLo, hi, unHi, gtHi, n;\n \n         long r = 0;\n      * @param nblock size of the block\n      * @param off offset of first byte to sort in block\n      */\n-    final void fallbackSort(int[] fmap, byte[] block, int nblock) {\n+    final void fallbackSort(final int[] fmap, final byte[] block, final int nblock) {\n         final int[] ftab = new int[257];\n         int H, i, j, k, l, r, cc, cc1;\n         int nNotDone;\n    Sedgewick and Jon L. Bentley.\n --*/\n \n-    private static void vswap(int[] fmap, int p1, int p2, int n) {\n+    private static void vswap(final int[] fmap, int p1, int p2, int n) {\n         n += p1;\n         while (p1 < n) {\n             int t = fmap[p1];\n         }\n     }\n \n-    private static byte med3(byte a, byte b, byte c) {\n+    private static byte med3(final byte a, final byte b, final byte c) {\n         return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c\n                                                         : a);\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n             return globalCrc;\n         }\n \n-        void setGlobalCRC(int newCrc) {\n+        void setGlobalCRC(final int newCrc) {\n             globalCrc = newCrc;\n         }\n \n-        void updateCRC(int inCh) {\n+        void updateCRC(final int inCh) {\n             int temp = (globalCrc >> 24) ^ inCh;\n             if (temp < 0) {\n                 temp = 256 + temp;\n             globalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n         }\n \n-        void updateCRC(int inCh, int repeat) {\n+        void updateCRC(final int inCh, int repeat) {\n             int globalCrcShadow = this.globalCrc;\n             while (repeat-- > 0) {\n                 int temp = (globalCrcShadow >> 24) ^ inCh;\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/Rand.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/Rand.java\n      * @param i the index\n      * @return the random number\n      */\n-    static int rNums(int i){\n+    static int rNums(final int i){\n         return RNUMS[i];\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n      * @param       inputStream where to read the compressed data\n      *\n      */\n-    public DeflateCompressorInputStream(InputStream inputStream) {\n+    public DeflateCompressorInputStream(final InputStream inputStream) {\n         this(inputStream, new DeflateParameters());\n     }\n \n      * @param       inputStream where to read the compressed data\n      * @param       parameters parameters\n      */\n-    public DeflateCompressorInputStream(InputStream inputStream,\n-                                        DeflateParameters parameters) {\n+    public DeflateCompressorInputStream(final InputStream inputStream,\n+                                        final DeflateParameters parameters) {\n         inflater = new Inflater(!parameters.withZlibHeader());\n         in = new InflaterInputStream(inputStream, inflater);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public int read(byte[] buf, int off, int len) throws IOException {\n+    public int read(final byte[] buf, final int off, final int len) throws IOException {\n         int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n \n     /** {@inheritDoc} */\n     @Override\n-    public long skip(long n) throws IOException {\n+    public long skip(final long n) throws IOException {\n         return in.skip(n);\n     }\n \n      * \n      * @since 1.10\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         return length > 3 && signature[0] == MAGIC_1 && (\n                 signature[1] == (byte) MAGIC_2a ||\n                 signature[1] == (byte) MAGIC_2b ||\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStream.java\n      * @param outputStream the stream to wrap\n      * @throws IOException on error\n      */\n-    public DeflateCompressorOutputStream(OutputStream outputStream) throws IOException {\n+    public DeflateCompressorOutputStream(final OutputStream outputStream) throws IOException {\n         this(outputStream, new DeflateParameters());\n     }\n \n      * @param parameters the deflate parameters to apply\n      * @throws IOException on error\n      */\n-    public DeflateCompressorOutputStream(OutputStream outputStream,\n-                                         DeflateParameters parameters) throws IOException {\n+    public DeflateCompressorOutputStream(final OutputStream outputStream,\n+                                         final DeflateParameters parameters) throws IOException {\n         this.deflater = new Deflater(parameters.getCompressionLevel(), !parameters.withZlibHeader());\n         this.out = new DeflaterOutputStream(outputStream, deflater);\n     }\n \n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         out.write(b);\n     }\n \n     @Override\n-    public void write(byte[] buf, int off, int len) throws IOException {\n+    public void write(final byte[] buf, final int off, final int len) throws IOException {\n         out.write(buf, off, len);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateParameters.java\n      *\n      * @param zlibHeader true if zlib header shall be written\n      */\n-    public void setWithZlibHeader(boolean zlibHeader) {\n+    public void setWithZlibHeader(final boolean zlibHeader) {\n         this.zlibHeader = zlibHeader;\n     }\n \n      * @see Deflater#DEFAULT_COMPRESSION\n      * @see Deflater#BEST_COMPRESSION\n      */\n-    public void setCompressionLevel(int compressionLevel) {\n+    public void setCompressionLevel(final int compressionLevel) {\n         if (compressionLevel < -1 || compressionLevel > 9) {\n             throw new IllegalArgumentException(\"Invalid Deflate compression level: \" + compressionLevel);\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n      *\n      * @throws IOException if the stream could not be created\n      */\n-    public GzipCompressorInputStream(InputStream inputStream)\n+    public GzipCompressorInputStream(final InputStream inputStream)\n             throws IOException {\n         this(inputStream, false);\n     }\n      *\n      * @throws IOException if the stream could not be created\n      */\n-    public GzipCompressorInputStream(InputStream inputStream,\n-                                     boolean decompressConcatenated)\n+    public GzipCompressorInputStream(final InputStream inputStream,\n+                                     final boolean decompressConcatenated)\n             throws IOException {\n         // Mark support is strictly needed for concatenated files only,\n         // but it's simpler if it is always available.\n         return parameters;\n     }\n \n-    private boolean init(boolean isFirstMember) throws IOException {\n+    private boolean init(final boolean isFirstMember) throws IOException {\n         assert isFirstMember || decompressConcatenated;\n \n         // Check the magic bytes without a possibility of EOFException.\n         return true;\n     }\n \n-    private byte[] readToNull(DataInputStream inData) throws IOException {\n+    private byte[] readToNull(final DataInputStream inData) throws IOException {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int b = 0;\n         while ((b = inData.readUnsignedByte()) != 0x00) { // NOPMD\n         return bos.toByteArray();\n     }\n \n-    private long readLittleEndianInt(DataInputStream inData) throws IOException {\n+    private long readLittleEndianInt(final DataInputStream inData) throws IOException {\n         return inData.readUnsignedByte()\n             | (inData.readUnsignedByte() << 8)\n             | (inData.readUnsignedByte() << 16)\n      * @since 1.1\n      */\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, int off, int len) throws IOException {\n         if (endReached) {\n             return -1;\n         }\n      *\n      * @since 1.1\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n \n         if (length < 2) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n      * @param out the stream to compress to\n      * @throws IOException if writing fails\n      */\n-    public GzipCompressorOutputStream(OutputStream out) throws IOException {\n+    public GzipCompressorOutputStream(final OutputStream out) throws IOException {\n         this(out, new GzipParameters());\n     }\n \n      * \n      * @since 1.7\n      */\n-    public GzipCompressorOutputStream(OutputStream out, GzipParameters parameters) throws IOException {\n+    public GzipCompressorOutputStream(final OutputStream out, final GzipParameters parameters) throws IOException {\n         this.out = out;\n         this.deflater = new Deflater(parameters.getCompressionLevel(), true);\n         \n         writeHeader(parameters);\n     }\n \n-    private void writeHeader(GzipParameters parameters) throws IOException {\n+    private void writeHeader(final GzipParameters parameters) throws IOException {\n         String filename = parameters.getFilename();\n         String comment = parameters.getComment();\n         \n     }\n \n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         write(new byte[]{(byte) (b & 0xff)}, 0, 1);\n     }\n \n      * @since 1.1\n      */\n     @Override\n-    public void write(byte[] buffer) throws IOException {\n+    public void write(final byte[] buffer) throws IOException {\n         write(buffer, 0, buffer.length);\n     }\n \n      * @since 1.1\n      */\n     @Override\n-    public void write(byte[] buffer, int offset, int length) throws IOException {\n+    public void write(final byte[] buffer, final int offset, final int length) throws IOException {\n         if (deflater.finished()) {\n             throw new IOException(\"Cannot write more data, the end of the compressed data stream has been reached\");\n \n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipParameters.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipParameters.java\n      * @see Deflater#DEFAULT_COMPRESSION\n      * @see Deflater#BEST_COMPRESSION\n      */\n-    public void setCompressionLevel(int compressionLevel) {\n+    public void setCompressionLevel(final int compressionLevel) {\n         if (compressionLevel < -1 || compressionLevel > 9) {\n             throw new IllegalArgumentException(\"Invalid gzip compression level: \" + compressionLevel);\n         }\n      * \n      * @param modificationTime the modification time, in milliseconds\n      */\n-    public void setModificationTime(long modificationTime) {\n+    public void setModificationTime(final long modificationTime) {\n         this.modificationTime = modificationTime;\n     }\n \n      * \n      * @param filename the name of the file without the directory path\n      */\n-    public void setFilename(String filename) {\n+    public void setFilename(final String filename) {\n         this.filename = filename;\n     }\n \n         return comment;\n     }\n \n-    public void setComment(String comment) {\n+    public void setComment(final String comment) {\n         this.comment = comment;\n     }\n \n      * \n      * @param operatingSystem the code of the operating system\n      */\n-    public void setOperatingSystem(int operatingSystem) {\n+    public void setOperatingSystem(final int operatingSystem) {\n         this.operatingSystem = operatingSystem;\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n      * @return {@code true} if the filename has a common gzip suffix,\n      *         {@code false} otherwise\n      */\n-    public static boolean isCompressedFilename(String filename) {\n+    public static boolean isCompressedFilename(final String filename) {\n         return fileNameUtil.isCompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding uncompressed file\n      */\n-    public static String getUncompressedFilename(String filename) {\n+    public static String getUncompressedFilename(final String filename) {\n         return fileNameUtil.getUncompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding compressed file\n      */\n-    public static String getCompressedFilename(String filename) {\n+    public static String getCompressedFilename(final String filename) {\n         return fileNameUtil.getCompressedFilename(filename);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n      *                          by this implementation, or the underlying\n      *                          <code>inputStream</code> throws an exception\n      */\n-    public LZMACompressorInputStream(InputStream inputStream)\n+    public LZMACompressorInputStream(final InputStream inputStream)\n             throws IOException {\n         in = new LZMAInputStream(inputStream);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public int read(byte[] buf, int off, int len) throws IOException {\n+    public int read(final byte[] buf, final int off, final int len) throws IOException {\n         int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n \n     /** {@inheritDoc} */\n     @Override\n-    public long skip(long n) throws IOException {\n+    public long skip(final long n) throws IOException {\n         return in.skip(n);\n     }\n \n      * \n      * @since 1.10\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n \n         if (signature == null || length < 3) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n      * @param   length        the number of bytes to check\n      * @return  true if signature matches the .lzma magic bytes, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < HEADER_MAGIC.length) {\n             return false;\n         }\n      * @return {@code true} if the filename has a common lzma suffix,\n      *         {@code false} otherwise\n      */\n-    public static boolean isCompressedFilename(String filename) {\n+    public static boolean isCompressedFilename(final String filename) {\n         return fileNameUtil.isCompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding uncompressed file\n      */\n-    public static String getUncompressedFilename(String filename) {\n+    public static String getUncompressedFilename(final String filename) {\n         return fileNameUtil.getUncompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding compressed file\n      */\n-    public static String getCompressedFilename(String filename) {\n+    public static String getCompressedFilename(final String filename) {\n         return fileNameUtil.getCompressedFilename(filename);\n     }\n \n      * <p>This defaults to {@code false} in an OSGi environment and {@code true} otherwise.</p>\n      * @param doCache whether to cache the result\n      */\n-    public static void setCacheLZMAAvailablity(boolean doCache) {\n+    public static void setCacheLZMAAvailablity(final boolean doCache) {\n         if (!doCache) {\n             cachedLZMAAvailability = CachedAvailability.DONT_CACHE;\n         } else if (cachedLZMAAvailability == CachedAvailability.DONT_CACHE) {\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n     }\n     \n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         int bytesRead = readFromStack(b, off, len);\n         while (len - bytesRead > 0) {\n             int result = decompressNextSymbol();\n      * Sets the clear code based on the code size.\n      * @param codeSize code size\n      */\n-    protected void setClearCode(int codeSize) {\n+    protected void setClearCode(final int codeSize) {\n         clearCode = (1 << (codeSize - 1));\n     }\n \n      * Initializes the arrays based on the maximum code size.\n      * @param maxCodeSize maximum code size\n      */\n-    protected void initializeTables(int maxCodeSize) {\n+    protected void initializeTables(final int maxCodeSize) {\n         final int maxTableSize = 1 << maxCodeSize;\n         prefixes = new int[maxTableSize];\n         characters = new byte[maxTableSize];\n      * @param maxTableSize the maximum table size\n      * @return the new code\n      */\n-    protected int addEntry(int previousCode, byte character, int maxTableSize) {\n+    protected int addEntry(final int previousCode, final byte character, final int maxTableSize) {\n         if (tableSize < maxTableSize) {\n             prefixes[tableSize] = previousCode;\n             characters[tableSize] = character;\n      * @return the new location of the output stack\n      * @throws IOException on error\n      */\n-    protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry)\n+    protected int expandCodeToOutputStack(final int code, final boolean addedUnfinishedEntry)\n         throws IOException {\n         for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n             outputStack[--outputStackLocation] = characters[entry];\n         return outputStackLocation;\n     }\n \n-    private int readFromStack(byte[] b, int off, int len) {\n+    private int readFromStack(final byte[] b, final int off, final int len) {\n         int remainingInStack = outputStack.length - outputStackLocation;\n         if (remainingInStack > 0) {\n             int maxLength = Math.min(remainingInStack, len);\n         setCodeSize(DEFAULT_CODE_SIZE);\n     }\n \n-    protected void setCodeSize(int cs) {\n+    protected void setCodeSize(final int cs) {\n         this.codeSize = cs;\n     }\n \n         this.previousCode = -1;\n     }\n \n-    protected int getPrefix(int offset) {\n+    protected int getPrefix(final int offset) {\n         return prefixes[offset];\n     }\n \n-    protected void setPrefix(int offset, int value) {\n+    protected void setPrefix(final int offset, final int value) {\n         prefixes[offset] = value;\n     }\n \n         return tableSize;\n     }\n \n-    protected void setTableSize(int newSize) {\n+    protected void setTableSize(final int newSize) {\n         tableSize = newSize;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n     }\n \n     @Override\n-    public int read(byte[] b) throws IOException {\n+    public int read(final byte[] b) throws IOException {\n         return streamBridge.getInput().read(b);\n     }\n \n     @Override\n-    public int read(byte[] b, int off, int count) throws IOException {\n+    public int read(final byte[] b, final int off, final int count) throws IOException {\n         return streamBridge.getInput().read(b, off, count);\n     }\n \n     }\n \n     @Override\n-    public void mark(int limit) {\n+    public void mark(final int limit) {\n         try {\n             streamBridge.getInput().mark(limit);\n         } catch (IOException ex) {\n     }\n \n     @Override\n-    public long skip(long count) throws IOException {\n+    public long skip(final long count) throws IOException {\n         return streamBridge.getInput().skip(count);\n     }\n \n      * @return true, if this stream is a pack200 compressed stream,\n      * false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < SIG_LENGTH) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n     }\n \n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         streamBridge.write(b);\n     }\n \n     @Override\n-    public void write(byte[] b) throws IOException {\n+    public void write(final byte[] b) throws IOException {\n         streamBridge.write(b);\n     }\n \n     @Override\n-    public void write(byte[] b, int from, int length) throws IOException {\n+    public void write(final byte[] b, final int from, final int length) throws IOException {\n         streamBridge.write(b, from, length);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n      * @param jar the JAR archive to normalize\n      * @throws IOException if reading or writing fails\n      */\n-    public static void normalize(File jar)\n+    public static void normalize(final File jar)\n         throws IOException {\n         normalize(jar, jar, null);\n     }\n      * method will implicitly set the segment limit to -1.\n      * @throws IOException if reading or writing fails\n      */\n-    public static void normalize(File jar, Map<String, String> props)\n+    public static void normalize(final File jar, final Map<String, String> props)\n         throws IOException {\n         normalize(jar, jar, props);\n     }\n      * @param to the normalized archive\n      * @throws IOException if reading or writing fails\n      */\n-    public static void normalize(File from, File to)\n+    public static void normalize(final File from, final File to)\n         throws IOException {\n         normalize(from, to, null);\n     }\n      * method will implicitly set the segment limit to -1.\n      * @throws IOException if reading or writing fails\n      */\n-    public static void normalize(File from, File to, Map<String, String> props)\n+    public static void normalize(final File from, final File to, Map<String, String> props)\n         throws IOException {\n         if (props == null) {\n             props = new HashMap<String, String>();\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/StreamBridge.java\n     private InputStream input;\n     private final Object INPUT_LOCK = new Object();\n \n-    protected StreamBridge(OutputStream out) {\n+    protected StreamBridge(final OutputStream out) {\n         super(out);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n      * @param in  the InputStream from which to read the compressed data\n      * @throws IOException if reading fails\n      */\n-    public FramedSnappyCompressorInputStream(InputStream in) throws IOException {\n+    public FramedSnappyCompressorInputStream(final InputStream in) throws IOException {\n         this.in = new PushbackInputStream(in, 1);\n         readStreamIdentifier();\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         int read = readOnce(b, off, len);\n         if (read == -1) {\n             readNextBlock();\n      * read from the current chunk (which may be -1 if the end of the\n      * chunk is reached).\n      */\n-    private int readOnce(byte[] b, int off, int len) throws IOException {\n+    private int readOnce(final byte[] b, final int off, final int len) throws IOException {\n         int read = -1;\n         if (inUncompressedChunk) {\n             int amount = Math.min(uncompressedBytesRemaining, len);\n      * @param length    the number of bytes to check\n      * @return          true if this is a .sz stream, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n \n         if (length < SZ_SIGNATURE.length) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n   }\n \n   @Override\n-public void update(byte[] b, int off, int len) {\n+public void update(final byte[] b, int off, int len) {\n     int localCrc = crc;\n \n     while(len > 7) {\n   }\n \n   @Override\n-final public void update(int b) {\n+final public void update(final int b) {\n     crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\n   }\n     \n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n      * {@inheritDoc}\n      */\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (endReached) {\n             return -1;\n         }\n      *\n      * @param len the number of uncompressed bytes to read\n      */\n-    private void fill(int len) throws IOException {\n+    private void fill(final int len) throws IOException {\n         if (uncompressedBytesRemaining == 0) {\n             endReached = true;\n         }\n      * or 63 for 1-4 bytes, respectively. The literal itself follows\n      * after the length.\n      */\n-    private int readLiteralLength(int b) throws IOException {\n+    private int readLiteralLength(final int b) throws IOException {\n         int length;\n         switch (b >> 2) {\n         case 60:\n      *             buffer\n      * @return True if the decompressed data should be flushed\n      */\n-    private boolean expandCopy(final long off, int length) throws IOException {\n+    private boolean expandCopy(final long off, final int length) throws IOException {\n         if (off > blockSize) {\n             throw new IOException(\"Offset is larger than block size\");\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n      * @param   length        the number of bytes to check\n      * @return  true if signature matches the .xz magic bytes, false otherwise\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < XZ.HEADER_MAGIC.length) {\n             return false;\n         }\n      *                          by this implementation, or the underlying\n      *                          <code>inputStream</code> throws an exception\n      */\n-    public XZCompressorInputStream(InputStream inputStream)\n+    public XZCompressorInputStream(final InputStream inputStream)\n             throws IOException {\n         this(inputStream, false);\n     }\n      *                          by this implementation, or the underlying\n      *                          <code>inputStream</code> throws an exception\n      */\n-    public XZCompressorInputStream(InputStream inputStream,\n-                                   boolean decompressConcatenated)\n+    public XZCompressorInputStream(final InputStream inputStream,\n+                                   final boolean decompressConcatenated)\n             throws IOException {\n         if (decompressConcatenated) {\n             in = new XZInputStream(inputStream);\n     }\n \n     @Override\n-    public int read(byte[] buf, int off, int len) throws IOException {\n+    public int read(final byte[] buf, final int off, final int len) throws IOException {\n         int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n     }\n \n     @Override\n-    public long skip(long n) throws IOException {\n+    public long skip(final long n) throws IOException {\n         return in.skip(n);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.java\n      * @param outputStream the stream to wrap\n      * @throws IOException on error\n      */\n-    public XZCompressorOutputStream(OutputStream outputStream)\n+    public XZCompressorOutputStream(final OutputStream outputStream)\n             throws IOException {\n         out = new XZOutputStream(outputStream, new LZMA2Options());\n     }\n      * @param preset the preset\n      * @throws IOException on error\n      */\n-    public XZCompressorOutputStream(OutputStream outputStream, int preset)\n+    public XZCompressorOutputStream(final OutputStream outputStream, final int preset)\n             throws IOException {\n         out = new XZOutputStream(outputStream, new LZMA2Options(preset));\n     }\n \n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         out.write(b);\n     }\n \n     @Override\n-    public void write(byte[] buf, int off, int len) throws IOException {\n+    public void write(final byte[] buf, final int off, final int len) throws IOException {\n         out.write(buf, off, len);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n      * @return  true if signature matches the .xz magic bytes, false otherwise\n      * @since 1.9\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         if (length < HEADER_MAGIC.length) {\n             return false;\n         }\n      * @return {@code true} if the filename has a common xz suffix,\n      *         {@code false} otherwise\n      */\n-    public static boolean isCompressedFilename(String filename) {\n+    public static boolean isCompressedFilename(final String filename) {\n         return fileNameUtil.isCompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding uncompressed file\n      */\n-    public static String getUncompressedFilename(String filename) {\n+    public static String getUncompressedFilename(final String filename) {\n         return fileNameUtil.getUncompressedFilename(filename);\n     }\n \n      * @param filename name of a file\n      * @return name of the corresponding compressed file\n      */\n-    public static String getCompressedFilename(String filename) {\n+    public static String getCompressedFilename(final String filename) {\n         return fileNameUtil.getCompressedFilename(filename);\n     }\n \n      * @param doCache whether to cache the result\n      * @since 1.9\n      */\n-    public static void setCacheXZAvailablity(boolean doCache) {\n+    public static void setCacheXZAvailablity(final boolean doCache) {\n         if (!doCache) {\n             cachedXZAvailability = CachedAvailability.DONT_CACHE;\n         } else if (cachedXZAvailability == CachedAvailability.DONT_CACHE) {\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n     private final int maxCodeSize;\n     private long totalCodesRead = 0;\n     \n-    public ZCompressorInputStream(InputStream inputStream) throws IOException {\n+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         int firstByte = (int) in.readBits(8);\n         int secondByte = (int) in.readBits(8);\n      * change or disappear without warning.</strong></p>\n      */\n     @Override\n-    protected int addEntry(int previousCode, byte character) throws IOException {\n+    protected int addEntry(final int previousCode, final byte character) throws IOException {\n         final int maxTableSize = 1 << getCodeSize();\n         int r = addEntry(previousCode, character, maxTableSize);\n         if (getTableSize() == maxTableSize && getCodeSize() < maxCodeSize) {\n      * \n      * @since 1.9\n      */\n-    public static boolean matches(byte[] signature, int length) {\n+    public static boolean matches(final byte[] signature, final int length) {\n         return length > 3 && signature[0] == MAGIC_1 && signature[1] == (byte) MAGIC_2;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n+++ b/src/main/java/org/apache/commons/compress/parallel/FileBasedScatterGatherBackingStore.java\n     private final FileOutputStream os;\n     private boolean closed;\n \n-    public FileBasedScatterGatherBackingStore(File target) throws FileNotFoundException {\n+    public FileBasedScatterGatherBackingStore(final File target) throws FileNotFoundException {\n         this.target = target;\n         os = new FileOutputStream(target);\n     }\n     }\n \n     @Override\n-    public void writeOut(byte[] data, int offset, int length) throws IOException {\n+    public void writeOut(final byte[] data, final int offset, final int length) throws IOException {\n         os.write(data, offset, length);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n      * @param entry the entry\n      * @return the representation of the entry\n      */\n-    public static String toString(ArchiveEntry entry){\n+    public static String toString(final ArchiveEntry entry){\n         StringBuilder sb = new StringBuilder();\n         sb.append(entry.isDirectory()? 'd' : '-');// c.f. \"ls -l\" output\n         String size = Long.toString(entry.getSize());\n      * @return {@code true} if buffer is the same as the expected string\n      */\n     public static boolean matchAsciiBuffer(\n-            String expected, byte[] buffer, int offset, int length){\n+            final String expected, final byte[] buffer, final int offset, final int length){\n         byte[] buffer1;\n         try {\n             buffer1 = expected.getBytes(CharsetNames.US_ASCII);\n      * @param buffer the buffer\n      * @return {@code true} if buffer is the same as the expected string\n      */\n-    public static boolean matchAsciiBuffer(String expected, byte[] buffer){\n+    public static boolean matchAsciiBuffer(final String expected, final byte[] buffer){\n         return matchAsciiBuffer(expected, buffer, 0, buffer.length);\n     }\n \n      * @param inputString string to convert\n      * @return the bytes\n      */\n-    public static byte[] toAsciiBytes(String inputString){\n+    public static byte[] toAsciiBytes(final String inputString){\n         try {\n             return inputString.getBytes(CharsetNames.US_ASCII);\n         } catch (UnsupportedEncodingException e) {\n      * @param length length of array\n      * @return the bytes, interpreted as an Ascii string\n      */\n-    public static String toAsciiString(final byte[] inputBytes, int offset, int length){\n+    public static String toAsciiString(final byte[] inputBytes, final int offset, final int length){\n         try {\n             return new String(inputBytes, offset, length, CharsetNames.US_ASCII);\n         } catch (UnsupportedEncodingException e) {\n     public static boolean isEqual(\n             final byte[] buffer1, final int offset1, final int length1,\n             final byte[] buffer2, final int offset2, final int length2,\n-            boolean ignoreTrailingNulls){\n+            final boolean ignoreTrailingNulls){\n         int minLen=length1 < length2 ? length1 : length2;\n         for (int i=0; i < minLen; i++){\n             if (buffer1[offset1+i] != buffer2[offset2+i]){\n      * @param ignoreTrailingNulls whether to ignore tariling nulls\n      * @return {@code true} if buffer1 and buffer2 have same contents\n      */\n-    public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, boolean ignoreTrailingNulls){\n+    public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, final boolean ignoreTrailingNulls){\n         return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, ignoreTrailingNulls);\n     }\n \n      *            The number of characters to check (not the size of the array)\n      * @return true if the first N bytes are zero\n      */\n-    public static boolean isArrayZero(byte[] a, int size) {\n+    public static boolean isArrayZero(final byte[] a, final int size) {\n         for (int i = 0; i < size; i++) {\n             if (a[i] != 0) {\n                 return false;\n--- a/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n     }\n \n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         if (bytesRemaining == 0) {\n             return -1;\n         }\n--- a/src/main/java/org/apache/commons/compress/utils/Charsets.java\n+++ b/src/main/java/org/apache/commons/compress/utils/Charsets.java\n      *            A charset or null.\n      * @return the given Charset or the default Charset if the given Charset is null\n      */\n-    public static Charset toCharset(Charset charset) {\n+    public static Charset toCharset(final Charset charset) {\n         return charset == null ? Charset.defaultCharset() : charset;\n     }\n \n      * @throws java.nio.charset.IllegalCharsetNameException\n      *             If the given charset name is illegal\n      */\n-    public static Charset toCharset(String charset) {\n+    public static Charset toCharset(final String charset) {\n         return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n      * value\n      */\n     @Override\n-    public int read(byte[] b) throws IOException {\n+    public int read(final byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n \n      * value\n      */\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         int ret = in.read(b, off, len);\n         if (ret >= 0) {\n             checksum.update(b, off, ret);\n     }\n \n     @Override\n-    public long skip(long n) throws IOException {\n+    public long skip(final long n) throws IOException {\n         // Can't really skip, we have to hash everything to verify the checksum\n         if (read() >= 0) {\n             return 1;\n--- a/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n         return r;\n     }\n     @Override\n-    public int read(byte[] b) throws IOException {\n+    public int read(final byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n     @Override\n-    public int read(byte[] b, int off, int len) throws IOException {\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n         int r = in.read(b, off, len);\n         if (r >= 0) {\n             count(r);\n      * \n      * @param read the number of bytes read\n      */\n-    protected final void count(long read) {\n+    protected final void count(final long read) {\n         if (read != -1) {\n             bytesRead += read;\n         }\n--- a/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingOutputStream.java\n     }\n \n     @Override\n-    public void write(int b) throws IOException {\n+    public void write(final int b) throws IOException {\n         out.write(b);\n         count(1);\n     }\n     @Override\n-    public void write(byte[] b) throws IOException {\n+    public void write(final byte[] b) throws IOException {\n         write(b, 0, b.length);\n     }\n     @Override\n-    public void write(byte[] b, int off, int len) throws IOException {\n+    public void write(final byte[] b, final int off, final int len) throws IOException {\n         out.write(b, off, len);\n         count(len);\n     }\n      * \n      * @param written the number of bytes written\n      */\n-    protected void count(long written) {\n+    protected void count(final long written) {\n         if (written != -1) {\n             bytesWritten += written;\n         }\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n      * @throws IOException\n      *             if an error occurs\n      */\n-    public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\n+    public static long copy(final InputStream input, final OutputStream output, final int buffersize) throws IOException {\n         final byte[] buffer = new byte[buffersize];\n         int n = 0;\n         long count=0;\n      * @return the number of bytes actually skipped\n      * @throws IOException on error\n      */\n-    public static long skip(InputStream input, long numToSkip) throws IOException {\n+    public static long skip(final InputStream input, long numToSkip) throws IOException {\n         long available = numToSkip;\n         while (numToSkip > 0) {\n             long skipped = input.skip(numToSkip);\n      * @return the number of bytes actually read\n      * @throws IOException on error\n      */\n-    public static int readFully(InputStream input, byte[] b) throws IOException {\n+    public static int readFully(final InputStream input, final byte[] b) throws IOException {\n         return readFully(input, b, 0, b.length);\n     }\n \n      * @throws IOException\n      *             if an I/O error has occurred\n      */\n-    public static int readFully(InputStream input, byte[] b, int offset, int len)\n+    public static int readFully(final InputStream input, final byte[] b, final int offset, final int len)\n         throws IOException {\n         if (len < 0 || offset < 0 || len + offset > b.length) {\n             throw new IndexOutOfBoundsException();\n      * @param c Closeable to close, can be null\n      * @since 1.7\n      */\n-    public static void closeQuietly(Closeable c) {\n+    public static void closeQuietly(final Closeable c) {\n         if (c != null) {\n             try {\n                 c.close();\n--- a/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n         archive = null;\n     }\n \n-    public static File mkdir(String name) throws IOException {\n+    public static File mkdir(final String name) throws IOException {\n         File f = File.createTempFile(name, \"\");\n         f.delete();\n         f.mkdir();\n         return f;\n     }\n \n-    public static File getFile(String path) throws IOException {\n+    public static File getFile(final String path) throws IOException {\n         URL url = AbstractTestCase.class.getClassLoader().getResource(path);\n         if (url == null) {\n             throw new FileNotFoundException(\"couldn't find \" + path);\n         }\n     }\n \n-    public static void rmdir(File f) {\n+    public static void rmdir(final File f) {\n         String[] s = f.list();\n         if (s != null) {\n             for (String element : s) {\n      * @return whether deletion was successful\n      * @since Stolen from FileUtils in Ant 1.8.0\n      */\n-    public static boolean tryHardToDelete(File f) {\n+    public static boolean tryHardToDelete(final File f) {\n         if (f != null && f.exists() && !f.delete()) {\n             if (ON_WINDOWS) {\n                 System.gc();\n      * @throws Exception\n      *             in case something goes wrong\n      */\n-    protected File createArchive(String archivename) throws Exception {\n+    protected File createArchive(final String archivename) throws Exception {\n         ArchiveOutputStream out = null;\n         OutputStream stream = null;\n         try {\n      * @throws IOException\n      * @throws FileNotFoundException\n      */\n-    private void addArchiveEntry(ArchiveOutputStream out, String filename, final File infile)\n+    private void addArchiveEntry(final ArchiveOutputStream out, final String filename, final File infile)\n             throws IOException, FileNotFoundException {\n         ArchiveEntry entry = out.createArchiveEntry(infile, filename);\n         out.putArchiveEntry(entry);\n      * @return the archive File\n      * @throws Exception\n      */\n-    protected File createEmptyArchive(String archivename) throws Exception {\n+    protected File createEmptyArchive(final String archivename) throws Exception {\n         ArchiveOutputStream out = null;\n         OutputStream stream = null;\n         archiveList = new ArrayList<String>();\n      * @return the archive File\n      * @throws Exception\n      */\n-    protected File createSingleEntryArchive(String archivename) throws Exception {\n+    protected File createSingleEntryArchive(final String archivename) throws Exception {\n         ArchiveOutputStream out = null;\n         OutputStream stream = null;\n         archiveList = new ArrayList<String>();\n      *            a list with expected string filenames\n      * @throws Exception\n      */\n-    protected void checkArchiveContent(File archive, List<String> expected)\n+    protected void checkArchiveContent(final File archive, final List<String> expected)\n             throws Exception {\n         final InputStream is = new FileInputStream(archive);\n         try {\n      * @param expected list of expected entries or {@code null} if no check of names desired\n      * @throws Exception\n      */\n-    protected void checkArchiveContent(ArchiveInputStream in, List<String> expected)\n+    protected void checkArchiveContent(final ArchiveInputStream in, final List<String> expected)\n             throws Exception {\n         checkArchiveContent(in, expected, true);\n     }\n      * @return returns the created result file if cleanUp = false, or null otherwise\n      * @throws Exception\n      */\n-    protected File checkArchiveContent(ArchiveInputStream in, List<String> expected, boolean cleanUp)\n+    protected File checkArchiveContent(final ArchiveInputStream in, final List<String> expected, final boolean cleanUp)\n             throws Exception {\n         File result = mkdir(\"dir-result\");\n         result.deleteOnExit();\n      * @param entry\n      * @return returns the entry name\n      */\n-    protected String getExpectedString(ArchiveEntry entry) {\n+    protected String getExpectedString(final ArchiveEntry entry) {\n         return entry.getName();\n     }\n \n         return tmpDir;\n     }\n \n-    protected void closeQuietly(Closeable closeable){\n+    protected void closeQuietly(final Closeable closeable){\n         if (closeable != null) {\n             try {\n                 closeable.close();\n--- a/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n \n     private final File file;\n \n-    public ArchiveReadTest(String file){\n+    public ArchiveReadTest(final String file){\n         this.file = new File(ARCDIR, file);\n     }\n \n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n-            public boolean accept(File dir, String name) {\n+            public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n             }\n         })) \n \n     // files.txt contains size and filename\n     @Override\n-    protected String getExpectedString(ArchiveEntry entry) {\n+    protected String getExpectedString(final ArchiveEntry entry) {\n         return entry.getSize() + \" \" + entry.getName();\n     }\n \n--- a/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n         asciiToByteAndBackFail(\"\\u8025\");\n     }\n \n-    private void asciiToByteAndBackOK(String inputString) {\n+    private void asciiToByteAndBackOK(final String inputString) {\n         assertEquals(inputString, ArchiveUtils.toAsciiString(ArchiveUtils.toAsciiBytes(inputString)));\n     }\n \n-    private void asciiToByteAndBackFail(String inputString) {\n+    private void asciiToByteAndBackFail(final String inputString) {\n         assertFalse(inputString.equals(ArchiveUtils.toAsciiString(ArchiveUtils.toAsciiBytes(inputString))));\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n \n     }\n \n-    private ArchiveInputStream getStreamFor(String resource)\n+    private ArchiveInputStream getStreamFor(final String resource)\n             throws ArchiveException, IOException {\n         return factory.createArchiveInputStream(\n                    new BufferedInputStream(new FileInputStream(\n         checkEmptyArchive(\"zip\");\n     }\n \n-    private void checkEmptyArchive(String type) throws Exception{\n+    private void checkEmptyArchive(final String type) throws Exception{\n         File ar = createEmptyArchive(type); // will be deleted by tearDown()\n         ar.deleteOnExit(); // Just in case file cannot be deleted\n         ArchiveInputStream ais = null;\n--- a/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n+++ b/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n         compareReads(\"zip\");\n     }\n \n-    private void compareWrites(String archiverName, ArchiveEntry entry) throws Exception {\n+    private void compareWrites(final String archiverName, final ArchiveEntry entry) throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n         OutputStream out2 = new ByteArrayOutputStream();\n         OutputStream out3 = new ByteArrayOutputStream();\n         assertEquals(\"out1!=out3\",out1.toString(),out3.toString());\n     }\n \n-    private void compareReads(String archiverName) throws Exception {\n+    private void compareReads(final String archiverName) throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n         OutputStream out2 = new ByteArrayOutputStream();\n         OutputStream out3 = new ByteArrayOutputStream();\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n         doCallSequence(\"Zip\");\n     }\n \n-    private void doCallSequence(String archiveType) throws Exception {\n+    private void doCallSequence(final String archiveType) throws Exception {\n         OutputStream out1 = new ByteArrayOutputStream();\n         File dummy = getFile(\"test1.xml\"); // need a real file\n \n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n         final String fieldName;\n         final String type;\n         final boolean hasOutputStream;\n-        TestData(String testFile, String type, boolean hasOut, String expectedEncoding, ArchiveStreamFactory fac, String fieldName) {\n+        TestData(final String testFile, final String type, final boolean hasOut, final String expectedEncoding, final ArchiveStreamFactory fac, final String fieldName) {\n             this.testFile = testFile;\n             this.expectedEncoding = expectedEncoding;\n             this.fac = fac;\n     }\n \n     @SuppressWarnings(\"deprecation\") // test of deprecated method\n-    static ArchiveStreamFactory getFactory(String entryEncoding) {\n+    static ArchiveStreamFactory getFactory(final String entryEncoding) {\n         ArchiveStreamFactory fac = new ArchiveStreamFactory();\n         fac.setEntryEncoding(entryEncoding);\n         return fac;\n     }\n \n     // equals allowing null\n-    private static boolean eq(String exp, String act) {\n+    private static boolean eq(final String exp, final String act) {\n         if (exp == null) {\n             return act == null;\n         }\n         return exp.equals(act);\n     }\n \n-    private static String getField(Object instance, String name) {\n+    private static String getField(final Object instance, final String name) {\n         Class<?> cls = instance.getClass();\n         Field fld;\n         try {\n         }\n     }\n \n-    private ArchiveInputStream getInputStreamFor(String resource, ArchiveStreamFactory factory)\n+    private ArchiveInputStream getInputStreamFor(final String resource, final ArchiveStreamFactory factory)\n             throws IOException, ArchiveException {\n         return factory.createArchiveInputStream(\n                    new BufferedInputStream(new FileInputStream(\n                        getFile(resource))));\n     }\n \n-    private ArchiveInputStream getInputStreamFor(String type, String resource, ArchiveStreamFactory factory)\n+    private ArchiveInputStream getInputStreamFor(final String type, final String resource, final ArchiveStreamFactory factory)\n             throws IOException, ArchiveException {\n         return factory.createArchiveInputStream(\n                    type,\n                        getFile(resource))));\n     }\n \n-    private ArchiveOutputStream getOutputStreamFor(String type, ArchiveStreamFactory factory)\n+    private ArchiveOutputStream getOutputStreamFor(final String type, final ArchiveStreamFactory factory)\n             throws IOException, ArchiveException {\n         return factory.createArchiveOutputStream(type, new ByteArrayOutputStream());\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n \n     private final File file;\n \n-    public LongPathTest(String file){\n+    public LongPathTest(final String file){\n         this.file = new File(ARCDIR, file);\n     }\n \n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n-            public boolean accept(File dir, String name) {\n+            public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n             }\n         })) \n     }\n \n     @Override\n-    protected String getExpectedString(ArchiveEntry entry) {\n+    protected String getExpectedString(final ArchiveEntry entry) {\n         if (entry instanceof TarArchiveEntry) {\n             TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n             if (tarEntry.isSymbolicLink()) {\n--- a/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n \n     private final File file;\n \n-    public LongSymLinkTest(String file){\n+    public LongSymLinkTest(final String file){\n         this.file = new File(ARCDIR, file);\n     }\n \n         Collection<Object[]> params = new ArrayList<Object[]>();\n         for (String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n-            public boolean accept(File dir, String name) {\n+            public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n             }\n         })) \n \n \n     @Override\n-    protected String getExpectedString(ArchiveEntry entry) {\n+    protected String getExpectedString(final ArchiveEntry entry) {\n         if (entry instanceof TarArchiveEntry) {\n             TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n             if (tarEntry.isSymbolicLink()) {\n--- a/src/test/java/org/apache/commons/compress/archivers/SevenZTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/SevenZTestCase.java\n         testSevenZArchiveCreation(SevenZMethod.DEFLATE);\n     }\n     \n-    private void testSevenZArchiveCreation(SevenZMethod method) throws Exception {\n+    private void testSevenZArchiveCreation(final SevenZMethod method) throws Exception {\n         final File output = new File(dir, \"bla.7z\");\n         final File file1 = getFile(\"test1.xml\");\n         final File file2 = getFile(\"test2.xml\");\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n     String second_payload = \"AAAAAAAAAAAA\";\n     ZipArchiveEntryPredicate allFilesPredicate = new ZipArchiveEntryPredicate() {\n         @Override\n-        public boolean test(ZipArchiveEntry zipArchiveEntry) {\n+        public boolean test(final ZipArchiveEntry zipArchiveEntry) {\n             return true;\n         }\n     };\n         zf1.close();\n     }\n \n-    private File createReferenceFile(File directory, Zip64Mode zipMode, String prefix) throws IOException {\n+    private File createReferenceFile(final File directory, final Zip64Mode zipMode, final String prefix) throws IOException {\n         File reference = File.createTempFile(prefix, \".zip\", directory);\n         ZipArchiveOutputStream zos = new ZipArchiveOutputStream(reference);\n         zos.setUseZip64(zipMode);\n         return reference;\n     }\n \n-    private ZipArchiveOutputStream createFirstEntry(ZipArchiveOutputStream zos) throws IOException {\n+    private ZipArchiveOutputStream createFirstEntry(final ZipArchiveOutputStream zos) throws IOException {\n         createArchiveEntry(first_payload, zos, \"file1.txt\");\n         return zos;\n     }\n \n-    private ZipArchiveOutputStream createSecondEntry(ZipArchiveOutputStream zos) throws IOException {\n+    private ZipArchiveOutputStream createSecondEntry(final ZipArchiveOutputStream zos) throws IOException {\n         createArchiveEntry(second_payload, zos, \"file2.txt\");\n         return zos;\n     }\n \n \n-    private void assertSameFileContents(File expectedFile, File actualFile) throws IOException {\n+    private void assertSameFileContents(final File expectedFile, final File actualFile) throws IOException {\n         int size = (int) Math.max(expectedFile.length(), actualFile.length());\n         ZipFile expected = new ZipFile(expectedFile);\n         ZipFile actual = new ZipFile(actualFile);\n     }\n \n \n-    private void createArchiveEntry(String payload, ZipArchiveOutputStream zos, String name)\n+    private void createArchiveEntry(final String payload, final ZipArchiveOutputStream zos, final String name)\n             throws IOException {\n         ZipArchiveEntry in = new ZipArchiveEntry(name);\n         zos.putArchiveEntry(in);\n--- a/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n         checkLongNameEntry(\"longfile_bsd.ar\");\n     }\n \n-    private void checkLongNameEntry(String archive) throws Exception {\n+    private void checkLongNameEntry(final String archive) throws Exception {\n         FileInputStream fis = new FileInputStream(getFile(archive));\n         ArArchiveInputStream s = null;\n         try {\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n         }\n     }\n \n-    private byte[] readFully(SevenZFile archive) throws IOException {\n+    private byte[] readFully(final SevenZFile archive) throws IOException {\n         byte [] buf = new byte [1024];\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         for (int len = 0; (len = archive.read(buf)) > 0;) {\n         }\n     }\n \n-    private void test7zUnarchive(File f, SevenZMethod m) throws Exception {\n+    private void test7zUnarchive(final File f, final SevenZMethod m) throws Exception {\n         test7zUnarchive(f, m, null);\n     }\n \n         }\n     }\n     \n-    private void test7zUnarchive(File f, SevenZMethod m, byte[] password) throws Exception {\n+    private void test7zUnarchive(final File f, final SevenZMethod m, final byte[] password) throws Exception {\n         SevenZFile sevenZFile = new SevenZFile(f, password);\n         try {\n             SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n         }\n     }\n \n-    private void testCompress252(int numberOfFiles, int numberOfNonEmptyFiles)\n+    private void testCompress252(final int numberOfFiles, final int numberOfNonEmptyFiles)\n         throws Exception {\n         int nonEmptyModulus = numberOfNonEmptyFiles != 0\n             ? numberOfFiles / numberOfNonEmptyFiles\n         verifyCompress252(output, numberOfFiles, numberOfNonEmptyFiles);\n     }\n \n-    private void verifyCompress252(File output, int numberOfFiles, int numberOfNonEmptyFiles)\n+    private void verifyCompress252(final File output, final int numberOfFiles, final int numberOfNonEmptyFiles)\n         throws Exception {\n         SevenZFile archive = new SevenZFile(output);\n         int filesFound = 0;\n         assertEquals(numberOfNonEmptyFiles, nonEmptyFilesFound);\n     }\n \n-    private void addDir(SevenZOutputFile archive) throws Exception {\n+    private void addDir(final SevenZOutputFile archive) throws Exception {\n         SevenZArchiveEntry entry = archive.createArchiveEntry(dir, \"foo/\");\n         archive.putArchiveEntry(entry);\n         archive.closeArchiveEntry();\n     }\n \n-    private void verifyDir(SevenZFile archive) throws Exception {\n+    private void verifyDir(final SevenZFile archive) throws Exception {\n         SevenZArchiveEntry entry = archive.getNextEntry();\n         assertNotNull(entry);\n         assertEquals(\"foo/\", entry.getName());\n         assertTrue(entry.isDirectory());\n     }\n \n-    private void addFile(SevenZOutputFile archive, int index, boolean nonEmpty)\n+    private void addFile(final SevenZOutputFile archive, final int index, final boolean nonEmpty)\n         throws Exception {\n         addFile(archive, index, nonEmpty, null);\n     }\n \n-    private void addFile(SevenZOutputFile archive, int index, boolean nonEmpty, Iterable<SevenZMethodConfiguration> methods)\n+    private void addFile(final SevenZOutputFile archive, final int index, final boolean nonEmpty, final Iterable<SevenZMethodConfiguration> methods)\n         throws Exception {\n         SevenZArchiveEntry entry = new SevenZArchiveEntry();\n         entry.setName(\"foo/\" + index + \".txt\");\n         archive.closeArchiveEntry();\n     }\n \n-    private Boolean verifyFile(SevenZFile archive, int index) throws Exception {\n+    private Boolean verifyFile(final SevenZFile archive, final int index) throws Exception {\n         return verifyFile(archive, index, null);\n     }\n \n-    private Boolean verifyFile(SevenZFile archive, int index,\n-                               Iterable<SevenZMethodConfiguration> methods) throws Exception {\n+    private Boolean verifyFile(final SevenZFile archive, final int index,\n+                               final Iterable<SevenZMethodConfiguration> methods) throws Exception {\n         SevenZArchiveEntry entry = archive.getNextEntry();\n         if (entry == null) {\n             return null;\n         return Boolean.TRUE;\n     }\n \n-    private void testRoundTrip(SevenZMethod method) throws Exception {\n+    private void testRoundTrip(final SevenZMethod method) throws Exception {\n         output = new File(dir, method + \"-roundtrip.7z\");\n         ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n         methods.add(new SevenZMethodConfiguration(method));\n         createAndReadBack(output, methods);\n     }\n \n-    private void testFilterRoundTrip(SevenZMethodConfiguration method) throws Exception {\n+    private void testFilterRoundTrip(final SevenZMethodConfiguration method) throws Exception {\n         output = new File(dir, method.getMethod() + \"-roundtrip.7z\");\n         ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n         methods.add(method);\n         createAndReadBack(output, methods);\n     }\n \n-    private void createAndReadBack(File output, Iterable<SevenZMethodConfiguration> methods) throws Exception {\n+    private void createAndReadBack(final File output, final Iterable<SevenZMethodConfiguration> methods) throws Exception {\n         SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         outArchive.setContentMethods(methods);\n         try {\n         }\n     }\n \n-    private static void assertContentMethodsEquals(Iterable<? extends SevenZMethodConfiguration> expected,\n-                                                   Iterable<? extends SevenZMethodConfiguration> actual) {\n+    private static void assertContentMethodsEquals(final Iterable<? extends SevenZMethodConfiguration> expected,\n+                                                   final Iterable<? extends SevenZMethodConfiguration> actual) {\n         assertNotNull(actual);\n         Iterator<? extends SevenZMethodConfiguration> expectedIter = expected.iterator();\n         Iterator<? extends SevenZMethodConfiguration> actualIter = actual.iterator();\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n         }\n     }\n \n-    private void readFileBiggerThan8GByte(String name) throws Exception {\n+    private void readFileBiggerThan8GByte(final String name) throws Exception {\n         InputStream in = null;\n         GzipCompressorInputStream gzin = null;\n         TarArchiveInputStream tin = null;\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n         }\n     }\n \n-    private void assertPaxGNUEntry(TarArchiveInputStream tin, String suffix) throws Throwable {\n+    private void assertPaxGNUEntry(final TarArchiveInputStream tin, final String suffix) throws Throwable {\n         TarArchiveEntry ae = tin.getNextTarEntry();\n         assertEquals(\"sparsefile-\" + suffix, ae.getName());\n         assertTrue(ae.isGNUSparse());\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n         assertEquals(\"/foo\", t.getName());\n     }\n \n-    private void assertGnuMagic(TarArchiveEntry t) {\n+    private void assertGnuMagic(final TarArchiveEntry t) {\n         assertEquals(MAGIC_GNU + VERSION_GNU_SPACE, readMagic(t));\n     }\n \n-    private void assertPosixMagic(TarArchiveEntry t) {\n+    private void assertPosixMagic(final TarArchiveEntry t) {\n         assertEquals(MAGIC_POSIX + VERSION_POSIX, readMagic(t));\n     }\n \n-    private String readMagic(TarArchiveEntry t) {\n+    private String readMagic(final TarArchiveEntry t) {\n         byte[] buf = new byte[512];\n         t.writeEntryHeader(buf);\n         return new String(buf, MAGIC_OFFSET, MAGICLEN + VERSIONLEN);\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n         datePriorToEpoch(\"preepoch-posix.tar\");\n     }\n \n-    private void datePriorToEpoch(String archive) throws Exception {\n+    private void datePriorToEpoch(final String archive) throws Exception {\n         TarArchiveInputStream in = null;\n         try {\n             in = new TarArchiveInputStream(new FileInputStream(getFile(archive)));\n         }\n     }\n \n-    private TarArchiveInputStream getTestStream(String name) {\n+    private TarArchiveInputStream getTestStream(final String name) {\n         return new TarArchiveInputStream(\n                 TarArchiveInputStreamTest.class.getResourceAsStream(name));\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n               + \"0123\\n\", new String(data, 512, 101, CharsetNames.UTF_8));\n     }\n \n-    private byte[] writePaxHeader(Map<String, String> m) throws Exception {\n+    private byte[] writePaxHeader(final Map<String, String> m) throws Exception {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.writePaxHeaders(new TarArchiveEntry(\"x\"), \"foo\", m);\n         testRoundtripWith67CharFileName(TarArchiveOutputStream.LONGFILE_POSIX);\n     }\n \n-    private void testRoundtripWith67CharFileName(int mode) throws Exception {\n+    private void testRoundtripWith67CharFileName(final int mode) throws Exception {\n         String n = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n             + \"AAAAAAA\";\n         assertEquals(67, n.length());\n         testWriteLongDirectoryName(TarArchiveOutputStream.LONGFILE_POSIX);\n     }\n \n-    private void testWriteLongDirectoryName(int mode) throws Exception {\n+    private void testWriteLongDirectoryName(final int mode) throws Exception {\n         String n = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/\";\n     /**\n      * @see \"https://issues.apache.org/jira/browse/COMPRESS-237\"\n      */\n-    private void testWriteLongLinkName(int mode) throws Exception {\n+    private void testWriteLongLinkName(final int mode) throws Exception {\n         String linkname = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/test\";\n         tarIn.close();\n     }\n \n-    private static byte[] createTarArchiveContainingOneDirectory(String fname, Date modificationDate) throws IOException {\n+    private static byte[] createTarArchiveContainingOneDirectory(final String fname, final Date modificationDate) throws IOException {\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         TarArchiveOutputStream tarOut = new TarArchiveOutputStream(baos, 1024);\n         tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarLister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarLister.java\n  */\n public final class TarLister {\n \n-    public static void main(String[] args) throws Exception {\n+    public static void main(final String[] args) throws Exception {\n         if (args.length == 0) {\n             usage();\n             return;\n         System.out.println(\"Parameters: archive-name [encoding]\");\n     }\n \n-    private static void log(TarArchiveEntry ae) {\n+    private static void log(final TarArchiveEntry ae) {\n         StringBuilder sb = new StringBuilder(Integer.toOctalString(ae.getMode()))\n             .append(\" \");\n         String name = ae.getUserName();\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n         checkRoundTripOctalOrBinary(Long.MIN_VALUE + 1, 12);\n     }\n \n-    private void testRoundTripOctalOrBinary(int length) {\n+    private void testRoundTripOctalOrBinary(final int length) {\n         checkRoundTripOctalOrBinary(0, length);\n         checkRoundTripOctalOrBinary(1, length);\n         checkRoundTripOctalOrBinary(TarConstants.MAXSIZE, length); // will need binary format\n         assertEquals(s, TarUtils.parseName(buff, 0, len, enc));\n     }\n \n-    private void checkName(String string) {\n+    private void checkName(final String string) {\n         byte buff[] = new byte[100];\n         int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n         assertEquals(string, TarUtils.parseName(buff, 0, len));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ExplodeSupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ExplodeSupportTest.java\n \n public class ExplodeSupportTest {\n \n-    private void testArchiveWithImplodeCompression(String filename, String entryName) throws IOException {\n+    private void testArchiveWithImplodeCompression(final String filename, final String entryName) throws IOException {\n         ZipFile zip = new ZipFile(new File(filename));\n         ZipArchiveEntry entry = zip.getEntries().nextElement();\n         assertEquals(\"entry name\", entryName, entry.getName());\n         testArchiveWithImplodeCompression(\"target/test-classes/moby-imploded.zip\", \"README\");\n     }\n \n-    private void testZipStreamWithImplodeCompression(String filename, String entryName) throws IOException {\n+    private void testZipStreamWithImplodeCompression(final String filename, final String entryName) throws IOException {\n         ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(new File(filename)));\n         ZipArchiveEntry entry = zin.getNextZipEntry();\n         assertEquals(\"entry name\", entryName, entry.getName());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n         String dir;\n     }\n \n-    public static void main(String[] args) throws IOException {\n+    public static void main(final String[] args) throws IOException {\n         CommandLine cl = parse(args);\n         File f = new File(cl.archive);\n         if (!f.isFile()) {\n         }\n     }\n \n-    private static void list(ZipArchiveEntry entry) {\n+    private static void list(final ZipArchiveEntry entry) {\n         System.out.println(entry.getName());\n     }\n \n-    private static void extract(String dir, ZipArchiveEntry entry,\n-                                InputStream is) throws IOException {\n+    private static void extract(final String dir, final ZipArchiveEntry entry,\n+                                final InputStream is) throws IOException {\n         File f = new File(dir, entry.getName());\n         if (!f.getParentFile().exists()) {\n             f.getParentFile().mkdirs();\n         }\n     }\n \n-    private static CommandLine parse(String[] args) {\n+    private static CommandLine parse(final String[] args) {\n         CommandLine cl = new CommandLine();\n         boolean error = false;\n         for (int i = 0; i < args.length; i++) {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n         assertNotNull(zipCreator.getStatisticsMessage());\n     }\n \n-    private void removeEntriesFoundInZipFile(File result, Map<String, byte[]> entries) throws IOException {\n+    private void removeEntriesFoundInZipFile(final File result, final Map<String, byte[]> entries) throws IOException {\n         ZipFile zf = new ZipFile(result);\n         Enumeration<ZipArchiveEntry> entriesInPhysicalOrder = zf.getEntriesInPhysicalOrder();\n         while (entriesInPhysicalOrder.hasMoreElements()){\n         zf.close();\n     }\n \n-    private Map<String, byte[]> writeEntries(ParallelScatterZipCreator zipCreator) {\n+    private Map<String, byte[]> writeEntries(final ParallelScatterZipCreator zipCreator) {\n         Map<String, byte[]> entries = new HashMap<String, byte[]>();\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n         return entries;\n     }\n \n-    private Map<String, byte[]> writeEntriesAsCallable(ParallelScatterZipCreator zipCreator) {\n+    private Map<String, byte[]> writeEntriesAsCallable(final ParallelScatterZipCreator zipCreator) {\n         Map<String, byte[]> entries = new HashMap<String, byte[]>();\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n         return entries;\n     }\n \n-    private ZipArchiveEntry createZipArchiveEntry(Map<String, byte[]> entries, int i, byte[] payloadBytes) {\n+    private ZipArchiveEntry createZipArchiveEntry(final Map<String, byte[]> entries, final int i, final byte[] payloadBytes) {\n         ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n         entries.put( za.getName(), payloadBytes);\n         za.setMethod(ZipEntry.DEFLATED);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSample.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSample.java\n     public ScatterSample() throws IOException {\n     }\n \n-    public void addEntry(ZipArchiveEntry zipArchiveEntry, InputStreamSupplier streamSupplier) throws IOException {\n+    public void addEntry(final ZipArchiveEntry zipArchiveEntry, final InputStreamSupplier streamSupplier) throws IOException {\n         if (zipArchiveEntry.isDirectory() && !zipArchiveEntry.isUnixSymlink()) {\n             dirs.addArchiveEntry(ZipArchiveEntryRequest.createZipArchiveEntryRequest(zipArchiveEntry, streamSupplier));\n         } else {\n         }\n     }\n \n-    public void writeTo(ZipArchiveOutputStream zipArchiveOutputStream)\n+    public void writeTo(final ZipArchiveOutputStream zipArchiveOutputStream)\n             throws IOException, ExecutionException, InterruptedException {\n         dirs.writeTo(zipArchiveOutputStream);\n         dirs.close();\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n         checkFile(result);\n     }\n \n-    private void createFile(File result) throws IOException, ExecutionException, InterruptedException {\n+    private void createFile(final File result) throws IOException, ExecutionException, InterruptedException {\n         ScatterSample scatterSample = new ScatterSample();\n         ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"test1.xml\");\n         archiveEntry.setMethod(ZipEntry.DEFLATED);\n         zipArchiveOutputStream.close();\n     }\n \n-    private void checkFile(File result) throws IOException {\n+    private void checkFile(final File result) throws IOException {\n         ZipFile zf = new ZipFile(result);\n         ZipArchiveEntry archiveEntry1 = zf.getEntries().nextElement();\n         assertEquals( \"test1.xml\", archiveEntry1.getName());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n         }\n     }\n \n-    private void assertCanRead(ZipFile zf, String fileName) throws IOException {\n+    private void assertCanRead(final ZipFile zf, final String fileName) throws IOException {\n         ZipArchiveEntry entry = zf.getEntry(fileName);\n         assertNotNull(\"Entry doesn't exist\", entry);\n         InputStream is = zf.getInputStream(entry);\n         }\n     }\n \n-    private static void testFileRoundtrip(String encoding, boolean withEFS,\n-                                          boolean withExplicitUnicodeExtra)\n+    private static void testFileRoundtrip(final String encoding, final boolean withEFS,\n+                                          final boolean withExplicitUnicodeExtra)\n         throws IOException {\n \n         File file = File.createTempFile(encoding + \"-test\", \".zip\");\n         }\n     }\n \n-    private static void createTestFile(File file, String encoding,\n-                                       boolean withEFS,\n-                                       boolean withExplicitUnicodeExtra)\n+    private static void createTestFile(final File file, final String encoding,\n+                                       final boolean withEFS,\n+                                       final boolean withExplicitUnicodeExtra)\n         throws UnsupportedEncodingException, IOException {\n \n         ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         }\n     }\n \n-    private static void testFile(File file, String encoding)\n+    private static void testFile(final File file, final String encoding)\n         throws IOException {\n         ZipFile zf = null;\n         try {\n         }\n     }\n \n-    private static UnicodePathExtraField findUniCodePath(ZipArchiveEntry ze) {\n+    private static UnicodePathExtraField findUniCodePath(final ZipArchiveEntry ze) {\n         return (UnicodePathExtraField)\n             ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n     }\n \n-    private static void assertUnicodeName(ZipArchiveEntry ze,\n-                                          String expectedName,\n-                                          String encoding)\n+    private static void assertUnicodeName(final ZipArchiveEntry ze,\n+                                          final String expectedName,\n+                                          final String encoding)\n         throws IOException {\n         if (!expectedName.equals(ze.getName())) {\n             UnicodePathExtraField ucpf = findUniCodePath(ze);\n \n     }\n \n-    private static void assertRawNameOfAcsiiTxt(ZipArchiveEntry ze) {\n+    private static void assertRawNameOfAcsiiTxt(final ZipArchiveEntry ze) {\n         byte[] b = ze.getRawName();\n         assertNotNull(b);\n         final int len = ASCII_TXT.length();\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestampTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestampTest.java\n         }\n     }\n \n-    private static boolean isFlagSet(byte data, byte flag) { return (data & flag) == flag; }\n+    private static boolean isFlagSet(final byte data, final byte flag) { return (data & flag) == flag; }\n \n     /**\n      * InfoZIP seems to adjust the time stored inside the LFH and CD\n      * The archive read in {@link #testSampleFile} has been created\n      * with GMT-8 so we need to adjust for the difference.\n      */\n-    private static Date adjustFromGMTToExpectedOffset(Date from) {\n+    private static Date adjustFromGMTToExpectedOffset(final Date from) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(from);\n         cal.add(Calendar.MILLISECOND, cal.get(Calendar.ZONE_OFFSET));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n         assertTrue(Arrays.equals(SEQUENCE6, trimTest(SEQUENCE6_LEADING_ZERO)));\n     }\n \n-    private static byte[] trimTest(byte[] b) { return X7875_NewUnix.trimLeadingZeroesForceMinLength(b); }\n+    private static byte[] trimTest(final byte[] b) { return X7875_NewUnix.trimLeadingZeroesForceMinLength(b); }\n \n     @Test\n     public void testParseReparse() throws ZipException {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n         assertNull(f.getDiskStartNumber());\n     }\n \n-    private static void checkSizes(byte[] b) {\n+    private static void checkSizes(final byte[] b) {\n         assertEquals(0x78, b[0]);\n         assertEquals(0x56, b[1]);\n         assertEquals(0x34, b[2]);\n         assertEquals(0x00, b[15]);\n     }\n \n-    private static void checkOffset(byte[] b, int off) {\n+    private static void checkOffset(final byte[] b, final int off) {\n         assertEquals(0x78, b[0 + off]);\n         assertEquals(0x56, b[1 + off]);\n         assertEquals(0x34, b[2 + off]);\n         assertEquals((byte) 0xAB, b[7 + off]);\n     }\n \n-    private static void checkDisk(byte[] b, int off) {\n+    private static void checkDisk(final byte[] b, final int off) {\n         assertEquals(0x12, b[0 + off]);\n         assertEquals(0x00, b[1 + off]);\n         assertEquals(0x00, b[2 + off]);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n         }\n     }\n \n-    private static File write5GBZerosFile(String testName) throws Throwable {\n+    private static File write5GBZerosFile(final String testName) throws Throwable {\n         File f = getTempFile(testName);\n         ZipArchiveOutputStream zos = new ZipArchiveOutputStream(f);\n         try {\n     private static ZipOutputTest write100KFiles(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n     private static final ZipOutputTest write100KFilesModeNever =\n         new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n         withTemporaryArchive(\"readSelfGenerated100KFilesUsingZipFile()\",\n                              new ZipOutputTest() {\n                                  @Override\n-                                public void test(File f,\n-                                                  ZipArchiveOutputStream zos)\n+                                public void test(final File f,\n+                                                  final ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      write100KFilesToStream(zos);\n                                      read100KFilesUsingZipFileImpl(f);\n         write3EntriesCreatingBigArchive(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n     private static final ZipOutputTest write3EntriesCreatingBigArchiveModeNever =\n         new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n         withTemporaryArchive(\"read3EntriesCreatingBigArchiveFileUsingZipFile\",\n                              new ZipOutputTest() {\n                                  @Override\n-                                public void test(File f,\n-                                                  ZipArchiveOutputStream zos)\n+                                public void test(final File f,\n+                                                  final ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      write3EntriesCreatingBigArchiveToStream(zos);\n                                      ZipFile zf = null;\n                                                      final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         writeBigStoredEntryModeNever(final boolean knownSize) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n                                       final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f,\n-                             ZipArchiveOutputStream zos)\n+            public void test(final File f,\n+                             final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         writeBigDeflatedEntryUnknownSizeToStream(final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 try {\n                     if (mode != Zip64Mode.AsNeeded) {\n                                     final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         withTemporaryArchive(\"writeBigDeflatedEntryKnownSizeToStreamModeNever\",\n                              new ZipOutputTest() {\n                                  @Override\n-                                public void test(File f,\n-                                                  ZipArchiveOutputStream zos)\n+                                public void test(final File f,\n+                                                  final ZipArchiveOutputStream zos)\n                                      throws IOException {\n                                      zos.setUseZip64(Zip64Mode.Never);\n                                      try {\n         writeBigDeflatedEntryToFileModeNever(final boolean knownSize) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n                                                        final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         writeSmallStoredEntryModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n                 byte[] buf = new byte[ONE_MILLION];\n                                         final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         writeSmallDeflatedEntryToStreamModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n                 byte[] buf = new byte[ONE_MILLION];\n                                       final Zip64Mode mode) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n         writeSmallDeflatedEntryToFileModeAlways(final boolean knownSize) {\n         return new ZipOutputTest() {\n             @Override\n-            public void test(File f, ZipArchiveOutputStream zos)\n+            public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n                 byte[] buf = new byte[ONE_MILLION];\n         void test(File f, ZipArchiveOutputStream zos) throws IOException;\n     }\n \n-    private static void withTemporaryArchive(String testName,\n-                                             ZipOutputTest test,\n-                                             boolean useRandomAccessFile)\n+    private static void withTemporaryArchive(final String testName,\n+                                             final ZipOutputTest test,\n+                                             final boolean useRandomAccessFile)\n         throws Throwable {\n         File f = getTempFile(testName);\n         BufferedOutputStream os = null;\n         return getFile(\"100k_Files_PKZip.zip\");\n     }\n \n-    private static File getTempFile(String testName) throws Throwable {\n+    private static File getTempFile(final String testName) throws Throwable {\n         File f = File.createTempFile(\"commons-compress-\" + testName, \".zip\");\n         f.deleteOnExit();\n         return f;\n     }\n \n-    private static void read5GBOfZerosImpl(File f, String expectedName)\n+    private static void read5GBOfZerosImpl(final File f, final String expectedName)\n         throws IOException {\n         FileInputStream fin = new FileInputStream(f);\n         ZipArchiveInputStream zin = null;\n         }\n     }\n \n-    private static void read5GBOfZerosUsingZipFileImpl(File f,\n-                                                       String expectedName)\n+    private static void read5GBOfZerosUsingZipFileImpl(final File f,\n+                                                       final String expectedName)\n         throws IOException {\n         ZipFile zf = null;\n         try {\n         }\n     }\n \n-    private static void read100KFilesImpl(File f) throws IOException {\n+    private static void read100KFilesImpl(final File f) throws IOException {\n         FileInputStream fin = new FileInputStream(f);\n         ZipArchiveInputStream zin = null;\n         try {\n         }\n     }\n \n-    private static void read100KFilesUsingZipFileImpl(File f)\n+    private static void read100KFilesUsingZipFileImpl(final File f)\n         throws IOException {\n         ZipFile zf = null;\n         try {\n         }\n     }\n \n-    private static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a)\n+    private static long getLengthAndPositionAtCentralDirectory(final RandomAccessFile a)\n         throws IOException {\n         final long end = a.length();\n         a.seek(end - 22 - 20);\n         return end;\n     }\n \n-    private static long getLengthAndPositionAtCentralDirectory32(RandomAccessFile a, final long end)\n+    private static long getLengthAndPositionAtCentralDirectory32(final RandomAccessFile a, final long end)\n         throws IOException {\n         a.seek(end - 22 + 16);\n         byte[] cdOffset = new byte[4];\n         return end;\n     }\n \n-    private static void write100KFilesToStream(ZipArchiveOutputStream zos)\n+    private static void write100KFilesToStream(final ZipArchiveOutputStream zos)\n         throws IOException {\n         for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n             ZipArchiveEntry zae = new ZipArchiveEntry(String.valueOf(i));\n     }\n \n     private static void\n-        write3EntriesCreatingBigArchiveToStream(ZipArchiveOutputStream zos)\n+        write3EntriesCreatingBigArchiveToStream(final ZipArchiveOutputStream zos)\n         throws IOException {\n         byte[] buf = new byte[ONE_MILLION];\n         ZipArchiveEntry zae = null;\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipEncodingTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipEncodingTest.java\n         doSimpleEncodingTest(\"Cp1252\",b);\n     }\n \n-    private static void assertEquals(byte[] expected, ByteBuffer actual) {\n+    private static void assertEquals(final byte[] expected, final ByteBuffer actual) {\n \n         Assert.assertEquals(expected.length, actual.limit());\n \n \n     }\n \n-    private void doSimpleEncodingTest(String name, byte[] testBytes)\n+    private void doSimpleEncodingTest(final String name, byte[] testBytes)\n         throws IOException {\n \n         ZipEncoding enc = ZipEncodingHelper.getZipEncoding(name);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n         zf = new ZipFile(archive);\n     }\n \n-    private static void assertEntryName(ArrayList<ZipArchiveEntry> entries,\n-                                        int index,\n-                                        String expectedName) {\n+    private static void assertEntryName(final ArrayList<ZipArchiveEntry> entries,\n+                                        final int index,\n+                                        final String expectedName) {\n         ZipArchiveEntry ze = entries.get(index);\n         assertEquals(\"src/main/java/org/apache/commons/compress/archivers/zip/\"\n                      + expectedName + \".java\",\n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n public final class ChangeSetTestCase extends AbstractTestCase {\n \n     // Delete a directory tree\n-    private void archiveListDeleteDir(String prefix){\n+    private void archiveListDeleteDir(final String prefix){\n         Iterator<String> it = archiveList.iterator();\n         while(it.hasNext()){\n             String entry = it.next();\n     }\n \n     // Delete a single file\n-    private void archiveListDelete(String prefix){\n+    private void archiveListDelete(final String prefix){\n         Iterator<String> it = archiveList.iterator();\n         while(it.hasNext()){\n             String entry = it.next();\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n         final char[] entryNames; // expected entries ...\n         final CompressorStreamFactory factory; // ... when using this factory\n         final boolean concat; // expected value for decompressConcatenated\n-        TestData(String name, char[] names, CompressorStreamFactory factory, boolean concat) {\n+        TestData(final String name, final char[] names, final CompressorStreamFactory factory, final boolean concat) {\n             this.fileName = name;\n             this.entryNames = names;\n             this.factory = factory;\n         }\n     }\n \n-    private CompressorInputStream getStreamFor(String resource)\n+    private CompressorInputStream getStreamFor(final String resource)\n             throws CompressorException, IOException {\n         return factory.createCompressorInputStream(\n                    new BufferedInputStream(new FileInputStream(\n                        getFile(resource))));\n     }\n \n-    private CompressorInputStream getStreamFor(String resource, CompressorStreamFactory factory)\n+    private CompressorInputStream getStreamFor(final String resource, final CompressorStreamFactory factory)\n             throws CompressorException, IOException {\n         return factory.createCompressorInputStream(\n                    new BufferedInputStream(new FileInputStream(\n--- a/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n     public void testDefaultExtraction() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws IOException {\n+            public CompressorInputStream wrap(final InputStream is) throws IOException {\n                 return new FramedSnappyCompressorInputStream(is);\n             }\n         });\n     public void testDefaultExtractionViaFactory() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws Exception {\n+            public CompressorInputStream wrap(final InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(CompressorStreamFactory.SNAPPY_FRAMED,\n                                                  is);\n     public void testDefaultExtractionViaFactoryAutodetection() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws Exception {\n+            public CompressorInputStream wrap(final InputStream is) throws Exception {\n                 return new CompressorStreamFactory().createCompressorInputStream(is);\n             }\n         });\n     }\n \n-    private void testUnarchive(StreamWrapper<CompressorInputStream> wrapper) throws Exception {\n+    private void testUnarchive(final StreamWrapper<CompressorInputStream> wrapper) throws Exception {\n         final File input = getFile(\"bla.tar.sz\");\n         final File output = new File(dir, \"bla.tar\");\n         final FileInputStream is = new FileInputStream(input);\n--- a/src/test/java/org/apache/commons/compress/compressors/GZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/GZipTestCase.java\n         }\n     }\n \n-    private void testExtraFlags(int compressionLevel, int flag) throws Exception {\n+    private void testExtraFlags(final int compressionLevel, final int flag) throws Exception {\n         FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n         byte[] content;\n         try {\n--- a/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/LZMATestCase.java\n         }\n     }\n \n-    private void copy(InputStream in, File output) throws IOException {\n+    private void copy(final InputStream in, final File output) throws IOException {\n         FileOutputStream out = null;\n         try {\n             out = new FileOutputStream(output);\n--- a/src/test/java/org/apache/commons/compress/compressors/Pack200TestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/Pack200TestCase.java\n         jarUnarchiveAll(true, Pack200Strategy.TEMP_FILE);\n     }\n \n-    private void jarUnarchiveAll(boolean useFile, Pack200Strategy mode)\n+    private void jarUnarchiveAll(final boolean useFile, final Pack200Strategy mode)\n         throws Exception {\n         final File input = getFile(\"bla.pack\");\n         final InputStream is = useFile\n         jarArchiveCreation(Pack200Strategy.TEMP_FILE);\n     }\n \n-    private void jarArchiveCreation(Pack200Strategy mode) throws Exception {\n+    private void jarArchiveCreation(final Pack200Strategy mode) throws Exception {\n         final File output = new File(dir, \"bla.pack\");\n \n         final File file1 = getFile(\"test1.xml\");\n--- a/src/test/java/org/apache/commons/compress/compressors/ZTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/ZTestCase.java\n     public void testZUnarchive() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws IOException {\n+            public CompressorInputStream wrap(final InputStream is) throws IOException {\n                 return new ZCompressorInputStream(is);\n             }\n         });\n     public void testZUnarchiveViaFactory() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws Exception {\n+            public CompressorInputStream wrap(final InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(CompressorStreamFactory.Z, is);\n             }\n     public void testZUnarchiveViaAutoDetection() throws Exception {\n         testUnarchive(new StreamWrapper<CompressorInputStream>() {\n             @Override\n-            public CompressorInputStream wrap(InputStream is) throws Exception {\n+            public CompressorInputStream wrap(final InputStream is) throws Exception {\n                 return new CompressorStreamFactory()\n                     .createCompressorInputStream(new BufferedInputStream(is));\n             }\n                                                   4));\n     }\n \n-    private void testUnarchive(StreamWrapper<CompressorInputStream> wrapper) throws Exception {\n+    private void testUnarchive(final StreamWrapper<CompressorInputStream> wrapper) throws Exception {\n         final File input = getFile(\"bla.tar.Z\");\n         final File output = new File(dir, \"bla.tar\");\n         final InputStream is = new FileInputStream(input);\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n         return setUpFixture(FIXTURE);\n     }\n \n-    private void assertFixtureSorted(BZip2CompressorOutputStream.Data data) {\n+    private void assertFixtureSorted(final BZip2CompressorOutputStream.Data data) {\n         assertFixtureSorted(data, FIXTURE, FIXTURE_BWT);\n     }\n \n         return setUpFixture(FIXTURE2);\n     }\n \n-    private void assertFixture2Sorted(BZip2CompressorOutputStream.Data data) {\n+    private void assertFixture2Sorted(final BZip2CompressorOutputStream.Data data) {\n         assertFixtureSorted(data, FIXTURE2, FIXTURE2_BWT);\n     }\n \n-    private DS setUpFixture(byte[] fixture) {\n+    private DS setUpFixture(final byte[] fixture) {\n         BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n         System.arraycopy(fixture, 0, data.block, 1, fixture.length);\n         return new DS(data, new BlockSort(data));\n     }\n \n-    private void assertFixtureSorted(BZip2CompressorOutputStream.Data data,\n-                                     byte[] fixture, byte[] fixtureBwt) {\n+    private void assertFixtureSorted(final BZip2CompressorOutputStream.Data data,\n+                                     final byte[] fixture, final byte[] fixtureBwt) {\n         assertEquals(fixture[fixture.length - 1], data.block[0]);\n         for (int i = 0; i < fixture.length; i++) {\n             assertEquals(fixtureBwt[i], data.block[data.fmap[i]]);\n     private static class DS {\n         private final BZip2CompressorOutputStream.Data data;\n         private final BlockSort s;\n-        DS(BZip2CompressorOutputStream.Data data, BlockSort s) {\n+        DS(final BZip2CompressorOutputStream.Data data, final BlockSort s) {\n             this.data = data;\n             this.s = s;\n         }\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java\n         }\n     }\n \n-    private static ReadableByteChannel makeBZ2C(InputStream source) throws IOException {\n+    private static ReadableByteChannel makeBZ2C(final InputStream source) throws IOException {\n         BufferedInputStream bin = new BufferedInputStream(source);\n         BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);\n \n \n     // Helper method since Arrays#copyOfRange is Java 1.6+\n     // Does not check parameters, so may fail if they are incompatible\n-    private static byte[] copyOfRange(byte[] original, int from, int to) {\n+    private static byte[] copyOfRange(final byte[] original, final int from, final int to) {\n         int length = to - from;\n         byte buff[] = new byte[length];\n         System.arraycopy(original, from, buff, 0, length);\n--- a/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n         testChecksumUnmasking(0xffffc757l);\n     }\n \n-    private void testChecksumUnmasking(long x) {\n+    private void testChecksumUnmasking(final long x) {\n         assertEquals(Long.toHexString(x),\n                      Long.toHexString(FramedSnappyCompressorInputStream\n                                       .unmask(mask(x))));\n     }\n \n-    private long mask(long x) {\n+    private long mask(final long x) {\n         return (((x >>> 15) | (x << 17))\n                 + FramedSnappyCompressorInputStream.MASK_OFFSET)\n              & 0xffffFFFFL;\n--- a/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n     public void skipUsingSkip() throws Exception {\n         skip(new StreamWrapper() {\n                 @Override\n-                public InputStream wrap(InputStream toWrap) {\n+                public InputStream wrap(final InputStream toWrap) {\n                     return toWrap;\n                 }\n             });\n     public void skipUsingRead() throws Exception {\n         skip(new StreamWrapper() {\n                 @Override\n-                public InputStream wrap(InputStream toWrap) {\n+                public InputStream wrap(final InputStream toWrap) {\n                     return new FilterInputStream(toWrap) {\n                         @Override\n-                        public long skip(long s) {\n+                        public long skip(final long s) {\n                             return 0;\n                         }\n                     };\n                     return new FilterInputStream(toWrap) {\n                         boolean skipped;\n                         @Override\n-                        public long skip(long s) throws IOException {\n+                        public long skip(final long s) throws IOException {\n                             if (!skipped) {\n                                 toWrap.skip(5);\n                                 skipped = true;\n             });\n     }\n \n-    private void skip(StreamWrapper wrapper) throws Exception {\n+    private void skip(final StreamWrapper wrapper) throws Exception {\n         ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n             });", "timestamp": 1460221598, "metainfo": ""}