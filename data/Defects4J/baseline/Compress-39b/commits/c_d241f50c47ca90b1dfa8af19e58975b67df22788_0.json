{"sha": "d241f50c47ca90b1dfa8af19e58975b67df22788", "log": "Optimize the LZW implementation, support reading bit patterns that are either big or little endian, and make LZWInputStream public.    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.ByteOrder;\n \n-import org.apache.commons.compress.compressors.z._internal_.InternalLZWInputStream;\n+import org.apache.commons.compress.compressors.lzw.LZWInputStream;\n \n /**\n  * Input stream that decompresses ZIP method 1 (unshrinking). A variation of the LZW algorithm, with some twists.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-class UnshrinkingInputStream extends InternalLZWInputStream {\n+class UnshrinkingInputStream extends LZWInputStream {\n     private static final int MAX_CODE_SIZE = 13;\n     private static final int MAX_TABLE_SIZE = 1 << MAX_CODE_SIZE;\n     private final boolean[] isUsed;\n     \n     public UnshrinkingInputStream(InputStream inputStream) throws IOException {\n-        super(inputStream);\n+        super(inputStream, ByteOrder.LITTLE_ENDIAN);\n         setClearCode(codeSize);\n         initializeTables(MAX_CODE_SIZE);\n         isUsed = new boolean[prefixes.length];\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.compressors.lzw;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteOrder;\n+\n+import org.apache.commons.compress.compressors.CompressorInputStream;\n+import org.apache.commons.compress.utils.BitInputStream;\n+\n+/**\n+ * <p>Generic LZW implementation. It is used internally for\n+ * the Z decompressor and the Unshrinking Zip file compression method,\n+ * but may be useful for third-party projects in implementing their own LZW variations.</p>\n+ *\n+ * @NotThreadSafe\n+ * @since 1.10\n+ */\n+public abstract class LZWInputStream extends CompressorInputStream {\n+    private final byte[] oneByte = new byte[1];\n+\n+    protected final BitInputStream in;\n+    protected int clearCode = -1;\n+    protected int codeSize = 9;\n+    protected byte previousCodeFirstChar;\n+    protected int previousCode = -1;\n+    protected int tableSize = 0;\n+    protected int[] prefixes;\n+    protected byte[] characters;\n+    private byte[] outputStack;\n+    private int outputStackLocation;\n+\n+    protected LZWInputStream(final InputStream inputStream, final ByteOrder byteOrder) {\n+        this.in = new BitInputStream(inputStream, byteOrder);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        in.close();\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        int ret = read(oneByte);\n+        if (ret < 0) {\n+            return ret;\n+        }\n+        return 0xff & oneByte[0];\n+    }\n+    \n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        int bytesRead = readFromStack(b, off, len);\n+        while (len - bytesRead > 0) {\n+            int result = decompressNextSymbol();\n+            if (result < 0) {\n+                if (bytesRead > 0) {\n+                    count(bytesRead);\n+                    return bytesRead;\n+                }\n+                return result;\n+            }\n+            bytesRead += readFromStack(b, off + bytesRead, len - bytesRead);\n+        }\n+        count(bytesRead);\n+        return bytesRead;\n+    }\n+\n+    /**\n+     * Read the next code and expand it.\n+     */\n+    protected abstract int decompressNextSymbol() throws IOException;\n+\n+    /**\n+     * Add a new entry to the dictionary.\n+     */\n+    protected abstract int addEntry(int previousCode, byte character)\n+        throws IOException;\n+\n+    /**\n+     * Sets the clear code based on the code size.\n+     */\n+    protected void setClearCode(int codeSize) {\n+        clearCode = (1 << (codeSize - 1));\n+    }\n+\n+    /**\n+     * Initializes the arrays based on the maximum code size.\n+     */\n+    protected void initializeTables(int maxCodeSize) {\n+        final int maxTableSize = 1 << maxCodeSize;\n+        prefixes = new int[maxTableSize];\n+        characters = new byte[maxTableSize];\n+        outputStack = new byte[maxTableSize];\n+        outputStackLocation = maxTableSize;\n+        final int max = 1 << 8;\n+        for (int i = 0; i < max; i++) {\n+            prefixes[i] = -1;\n+            characters[i] = (byte) i;\n+        }\n+    }\n+\n+    /**\n+     * Reads the next code from the stream.\n+     */\n+    protected int readNextCode() throws IOException {\n+        return in.readBits(codeSize);\n+    }\n+    \n+    /**\n+     * Adds a new entry if the maximum table size hasn't been exceeded\n+     * and returns the new index.\n+     */\n+    protected int addEntry(int previousCode, byte character, int maxTableSize) {\n+        if (tableSize < maxTableSize) {\n+            prefixes[tableSize] = previousCode;\n+            characters[tableSize] = character;\n+            return tableSize++;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Add entry for repeat of previousCode we haven't added, yet.\n+     */\n+    protected int addRepeatOfPreviousCode() throws IOException {\n+        if (previousCode == -1) {\n+            // can't have a repeat for the very first code\n+            throw new IOException(\"The first code can't be a reference to its preceding code\");\n+        }\n+        return addEntry(previousCode, previousCodeFirstChar);\n+    }\n+\n+    /**\n+     * Expands the entry with index code to the output stack and may\n+     * create a new entry\n+     */\n+    protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry)\n+        throws IOException {\n+        for (int entry = code; entry >= 0; entry = prefixes[entry]) {\n+            outputStack[--outputStackLocation] = characters[entry];\n+        }\n+        if (previousCode != -1 && !addedUnfinishedEntry) {\n+            addEntry(previousCode, outputStack[outputStackLocation]);\n+        }\n+        previousCode = code;\n+        previousCodeFirstChar = outputStack[outputStackLocation];\n+        return outputStackLocation;\n+    }\n+\n+    private int readFromStack(byte[] b, int off, int len) {\n+        int remainingInStack = outputStack.length - outputStackLocation;\n+        if (remainingInStack > 0) {\n+            int maxLength = Math.min(remainingInStack, len);\n+            System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n+            outputStackLocation += maxLength;\n+            return maxLength;\n+        }\n+        return 0;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n \n import java.io.IOException;\n import java.io.InputStream;\n-import org.apache.commons.compress.compressors.z._internal_.InternalLZWInputStream;\n+import java.nio.ByteOrder;\n+\n+import org.apache.commons.compress.compressors.lzw.LZWInputStream;\n \n /**\n  * Input stream that decompresses .Z files.\n  * @NotThreadSafe\n  * @since 1.7\n  */\n-public class ZCompressorInputStream extends InternalLZWInputStream {\n+public class ZCompressorInputStream extends LZWInputStream {\n     private static final int MAGIC_1 = 0x1f;\n     private static final int MAGIC_2 = 0x9d;\n     private static final int BLOCK_MODE_MASK = 0x80;\n     private long totalCodesRead = 0;\n     \n     public ZCompressorInputStream(InputStream inputStream) throws IOException {\n-        super(inputStream);\n-        int firstByte = in.read();\n-        int secondByte = in.read();\n-        int thirdByte = in.read();\n+        super(inputStream, ByteOrder.LITTLE_ENDIAN);\n+        int firstByte = in.readBits(8);\n+        int secondByte = in.readBits(8);\n+        int thirdByte = in.readBits(8);\n         if (firstByte != MAGIC_1 || secondByte != MAGIC_2 || thirdByte < 0) {\n             throw new IOException(\"Input is not in .Z format\");\n         }\n         for (long i = 0; i < codeReadsToThrowAway; i++) {\n             readNextCode();\n         }\n-        bitsCached = 0;\n-        bitsCachedSize = 0;\n+        in.clearBitCache();\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteOrder;\n+\n+/**\n+ * Reads bits from an InputStream.\n+ * @since 1.10\n+ * @NotThreadSafe\n+ */\n+public class BitInputStream implements Closeable {\n+    private final InputStream in;\n+    private final ByteOrder byteOrder;\n+    private int bitsCached = 0;\n+    private int bitsCachedSize = 0;\n+\n+    /**\n+     * Constructor taking an InputStream and its bit arrangement. \n+     * @param in the InputStream\n+     * @param byteOrder the bit arrangement across byte boundaries,\n+     *      either BIG_ENDIAN (aaaaabbb bb000000) or LITTLE_ENDIAN (bbbaaaaa 000000bb)\n+     */\n+    public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\n+        this.in = in;\n+        this.byteOrder = byteOrder;\n+    }\n+    \n+    public void close() throws IOException {\n+        in.close();\n+    }\n+    \n+    public void clearBitCache() {\n+        bitsCached = 0;\n+        bitsCachedSize = 0;\n+    }\n+    \n+    public int readBits(final int count) throws IOException {\n+        while (bitsCachedSize < count) {\n+            final int nextByte = in.read();\n+            if (nextByte < 0) {\n+                return nextByte;\n+            }\n+            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+                bitsCached |= (nextByte << bitsCachedSize);\n+            } else {\n+                bitsCached <<= 8;\n+                bitsCached |= nextByte;\n+            }\n+            bitsCachedSize += 8;\n+        }\n+        \n+        final int mask = (1 << count) - 1;\n+        final int bitsOut;\n+        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n+            bitsOut = (bitsCached & mask);\n+            bitsCached >>>= count;\n+        } else {\n+            bitsOut = (bitsCached >> (bitsCachedSize - count)) & mask;\n+        }\n+        bitsCachedSize -= count;\n+        return bitsOut;\n+    }\n+}", "timestamp": 1414468860, "metainfo": ""}