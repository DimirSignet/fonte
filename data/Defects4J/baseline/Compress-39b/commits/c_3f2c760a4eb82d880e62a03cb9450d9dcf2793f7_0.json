{"sha": "3f2c760a4eb82d880e62a03cb9450d9dcf2793f7", "log": "Add final modifier to local variables.", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveInputStream.java\n      */\n     @Override\n     public int read() throws IOException {\n-        int num = read(SINGLE, 0, 1);\n+        final int num = read(SINGLE, 0, 1);\n         return num == -1 ? -1 : SINGLE[0] & BYTE_MASK;\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n             return new ArArchiveOutputStream(out);\n         }\n         if (ZIP.equalsIgnoreCase(archiverName)) {\n-            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n+            final ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n             if (entryEncoding != null) {\n                 zip.setEncoding(entryEncoding);\n             }\n                     if (tais.getNextTarEntry().isCheckSumOK()) {\n                         return createArchiveInputStream(TAR, in);\n                     }\n-                } catch (Exception e) { // NOPMD\n+                } catch (final Exception e) { // NOPMD\n                     // can generate IllegalArgumentException as well\n                     // as IOException\n                     // autodetection, simply not a TAR\n                     IOUtils.closeQuietly(tais);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/Lister.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/Lister.java\n             return;\n         }\n         System.out.println(\"Analysing \"+args[0]);\n-        File f = new File(args[0]);\n+        final File f = new File(args[0]);\n         if (!f.isFile()) {\n             System.err.println(f + \" doesn't exist or is a directory\");\n         }\n-        InputStream fis = new BufferedInputStream(new FileInputStream(f));\n+        final InputStream fis = new BufferedInputStream(new FileInputStream(f));\n         ArchiveInputStream ais;\n         if (args.length > 1) {\n             ais = factory.createArchiveInputStream(args[1], fis);\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n         if (obj == null || getClass() != obj.getClass()) {\n             return false;\n         }\n-        ArArchiveEntry other = (ArArchiveEntry) obj;\n+        final ArArchiveEntry other = (ArArchiveEntry) obj;\n         if (name == null) {\n             if (other.name != null) {\n                 return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n         IOUtils.readFully(this, NAME_BUF);\n         IOUtils.readFully(this, LAST_MODIFIED_BUF);\n         IOUtils.readFully(this, ID_BUF);\n-        int userId = asInt(ID_BUF, true);\n+        final int userId = asInt(ID_BUF, true);\n         IOUtils.readFully(this, ID_BUF);\n         IOUtils.readFully(this, FILE_MODE_BUF);\n         IOUtils.readFully(this, LENGTH_BUF);\n         if (temp.endsWith(\"/\")) { // GNU terminator\n             temp = temp.substring(0, temp.length() - 1);\n         } else if (isGNULongName(temp)) {\n-            int off = Integer.parseInt(temp.substring(1));// get the offset\n+            final int off = Integer.parseInt(temp.substring(1));// get the offset\n             temp = getExtendedName(off); // convert to the long name\n         } else if (isBSDLongName(temp)) {\n             temp = getBSDLongName(temp);\n             // entry length contained the length of the file name in\n             // addition to the real length of the entry.\n             // assume file name was ASCII, there is no \"standard\" otherwise\n-            int nameLen = temp.length();\n+            final int nameLen = temp.length();\n             len -= nameLen;\n             entryOffset += nameLen;\n         }\n     }\n \n     private int asInt(final byte[] input, final int base, final boolean treatBlankAsZero) {\n-        String string = ArchiveUtils.toAsciiString(input).trim();\n+        final String string = ArchiveUtils.toAsciiString(input).trim();\n         if (string.length() == 0 && treatBlankAsZero) {\n             return 0;\n         }\n      * @since 1.3\n      */\n     private String getBSDLongName(final String bsdLongName) throws IOException {\n-        int nameLen =\n+        final int nameLen =\n             Integer.parseInt(bsdLongName.substring(BSD_LONGNAME_PREFIX_LEN));\n-        byte[] name = new byte[nameLen];\n-        int read = IOUtils.readFully(this, name);\n+        final byte[] name = new byte[nameLen];\n+        final int read = IOUtils.readFully(this, name);\n         if (read != nameLen) {\n             throw new EOFException();\n         }\n      * @see #isGNUStringTable\n      */\n     private ArArchiveEntry readGNUStringTable(final byte[] length) throws IOException {\n-        int bufflen = asInt(length); // Assume length will fit in an int\n+        final int bufflen = asInt(length); // Assume length will fit in an int\n         namebuffer = new byte[bufflen];\n-        int read = IOUtils.readFully(this, namebuffer, 0, bufflen);\n+        final int read = IOUtils.readFully(this, namebuffer, 0, bufflen);\n         if (read != bufflen){\n             throw new IOException(\"Failed to read complete // record: expected=\"\n                                   + bufflen + \" read=\" + read);\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n     }\n \n     private long writeArchiveHeader() throws IOException {\n-        byte [] header = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n+        final byte [] header = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n         out.write(header);\n         return header.length;\n     }\n             throw new IOException(\"Stream has already been finished\");\n         }\n \n-        ArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\n+        final ArArchiveEntry pArEntry = (ArArchiveEntry)pEntry;\n         if (prevEntry == null) {\n             writeArchiveHeader();\n         } else {\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n      */\n     @Override\n     public Date getLastModifiedDate() {\n-        long ts = isHostOsUnix() ? localFileHeader.dateTimeModified * 1000l\n+        final long ts = isHostOsUnix() ? localFileHeader.dateTimeModified * 1000l\n             : ZipUtil.dosToJavaTime(0xFFFFFFFFL & localFileHeader.dateTimeModified);\n         return new Date(ts);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n             if ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\n                 throw new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n             }\n-        } catch (IOException ioException) {\n+        } catch (final IOException ioException) {\n             throw new ArchiveException(ioException.getMessage(), ioException);\n         }\n     }\n     }\n \n     private int read8(final DataInputStream dataIn) throws IOException {\n-        int value = dataIn.readUnsignedByte();\n+        final int value = dataIn.readUnsignedByte();\n         count(1);\n         return value;\n     }\n         localFileHeader.name = readString(basicHeader);\n         localFileHeader.comment = readString(basicHeader);\n \n-        ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n+        final ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n         int extendedHeaderSize;\n         while ((extendedHeaderSize = read16(in)) > 0) {\n             final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n--- a/src/main/java/org/apache/commons/compress/archivers/arj/LocalFileHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/LocalFileHeader.java\n \n     @Override\n     public String toString() {\n-        StringBuilder builder = new StringBuilder();\n+        final StringBuilder builder = new StringBuilder();\n         builder.append(\"LocalFileHeader [archiverVersionNumber=\");\n         builder.append(archiverVersionNumber);\n         builder.append(\", minVersionToExtract=\");\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n         if (name != null) {\n             size += name.length();\n         }\n-        int remain = size % this.alignmentBoundary;\n+        final int remain = size % this.alignmentBoundary;\n         if (remain > 0){\n             return this.alignmentBoundary - remain;\n         }\n      */\n     public int getDataPadCount(){\n         if (this.alignmentBoundary == 0) { return 0; }\n-        long size = this.filesize;\n-        int remain = (int) (size % this.alignmentBoundary);\n+        final long size = this.filesize;\n+        final int remain = (int) (size % this.alignmentBoundary);\n         if (remain > 0){\n             return this.alignmentBoundary - remain;\n         }\n         if (obj == null || getClass() != obj.getClass()) {\n             return false;\n         }\n-        CpioArchiveEntry other = (CpioArchiveEntry) obj;\n+        final CpioArchiveEntry other = (CpioArchiveEntry) obj;\n         if (name == null) {\n             if (other.name != null) {\n                 return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n                              TWO_BYTES_BUF.length);\n             readFully(SIX_BYTES_BUF, TWO_BYTES_BUF.length,\n                       FOUR_BYTES_BUF.length);\n-            String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n+            final String magicString = ArchiveUtils.toAsciiString(SIX_BYTES_BUF);\n             if (magicString.equals(MAGIC_NEW)) {\n                 this.entry = readNewEntry(false);\n             } else if (magicString.equals(MAGIC_NEW_CRC)) {\n             }\n             return -1; // EOF for this entry\n         }\n-        int tmplength = (int) Math.min(len, this.entry.getSize()\n+        final int tmplength = (int) Math.min(len, this.entry.getSize()\n                 - this.entryBytesRead);\n         if (tmplength < 0) {\n             return -1;\n         }\n \n-        int tmpread = readFully(b, off, tmplength);\n+        final int tmpread = readFully(b, off, tmplength);\n         if (this.entry.getFormat() == FORMAT_NEW_CRC) {\n             for (int pos = 0; pos < tmpread; pos++) {\n                 this.crc += b[pos] & 0xFF;\n \n     private final int readFully(final byte[] b, final int off, final int len)\n             throws IOException {\n-        int count = IOUtils.readFully(in, b, off, len);\n+        final int count = IOUtils.readFully(in, b, off, len);\n         count(count);\n         if (count < len) {\n             throw new EOFException();\n \n     private long readBinaryLong(final int length, final boolean swapHalfWord)\n             throws IOException {\n-        byte tmp[] = new byte[length];\n+        final byte tmp[] = new byte[length];\n         readFully(tmp, 0, tmp.length);\n         return CpioUtil.byteArray2long(tmp, swapHalfWord);\n     }\n \n     private long readAsciiLong(final int length, final int radix)\n             throws IOException {\n-        byte tmpBuffer[] = new byte[length];\n+        final byte tmpBuffer[] = new byte[length];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n         return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n     }\n         }\n \n         ret.setInode(readAsciiLong(8, 16));\n-        long mode = readAsciiLong(8, 16);\n+        final long mode = readAsciiLong(8, 16);\n         if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0\n             ret.setMode(mode);\n         }\n         ret.setDeviceMin(readAsciiLong(8, 16));\n         ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n         ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n-        long namesize = readAsciiLong(8, 16);\n+        final long namesize = readAsciiLong(8, 16);\n         ret.setChksum(readAsciiLong(8, 16));\n-        String name = readCString((int) namesize);\n+        final String name = readCString((int) namesize);\n         ret.setName(name);\n         if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n     }\n \n     private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n-        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n+        final CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n \n         ret.setDevice(readAsciiLong(6, 8));\n         ret.setInode(readAsciiLong(6, 8));\n         ret.setNumberOfLinks(readAsciiLong(6, 8));\n         ret.setRemoteDevice(readAsciiLong(6, 8));\n         ret.setTime(readAsciiLong(11, 8));\n-        long namesize = readAsciiLong(6, 8);\n+        final long namesize = readAsciiLong(6, 8);\n         ret.setSize(readAsciiLong(11, 8));\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n \n     private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n             throws IOException {\n-        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n+        final CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n \n         ret.setDevice(readBinaryLong(2, swapHalfWord));\n         ret.setInode(readBinaryLong(2, swapHalfWord));\n         ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n         ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n         ret.setTime(readBinaryLong(4, swapHalfWord));\n-        long namesize = readBinaryLong(2, swapHalfWord);\n+        final long namesize = readBinaryLong(2, swapHalfWord);\n         ret.setSize(readBinaryLong(4, swapHalfWord));\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n \n     private String readCString(final int length) throws IOException {\n         // don't include trailing NUL in file name to decode\n-        byte tmpBuffer[] = new byte[length - 1];\n+        final byte tmpBuffer[] = new byte[length - 1];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n         this.in.read();\n         return zipEncoding.decode(tmpBuffer);\n             throw new IllegalArgumentException(\"negative skip length\");\n         }\n         ensureOpen();\n-        int max = (int) Math.min(n, Integer.MAX_VALUE);\n+        final int max = (int) Math.min(n, Integer.MAX_VALUE);\n         int total = 0;\n \n         while (total < max) {\n      * Skips the padding zeros written after the TRAILER!!! entry.\n      */\n     private void skipRemainderOfLastBlock() throws IOException {\n-        long readFromLastBlock = getBytesRead() % blockSize;\n+        final long readFromLastBlock = getBytesRead() % blockSize;\n         long remainingBytes = readFromLastBlock == 0 ? 0\n             : blockSize - readFromLastBlock;\n         while (remainingBytes > 0) {\n-            long skipped = skip(blockSize - readFromLastBlock);\n+            final long skipped = skip(blockSize - readFromLastBlock);\n             if (skipped <= 0) {\n                 break;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n             throw new IOException(\"Stream has already been finished\");\n         }\n \n-        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n+        final CpioArchiveEntry e = (CpioArchiveEntry) entry;\n         ensureOpen();\n         if (this.entry != null) {\n             closeArchiveEntry(); // close previous entry\n             writeOldAsciiEntry(e);\n             break;\n         case FORMAT_OLD_BINARY:\n-            boolean swapHalfWord = true;\n+            final boolean swapHalfWord = true;\n             writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n             writeOldBinaryEntry(e, swapHalfWord);\n             break;\n         writeHeader(this.entry);\n         closeArchiveEntry();\n \n-        int lengthOfLastBlock = (int) (getBytesWritten() % blockSize);\n+        final int lengthOfLastBlock = (int) (getBytesWritten() % blockSize);\n         if (lengthOfLastBlock != 0) {\n             pad(blockSize - lengthOfLastBlock);\n         }\n \n     private void pad(final int count) throws IOException{\n         if (count > 0){\n-            byte buff[] = new byte[count];\n+            final byte buff[] = new byte[count];\n             out.write(buff);\n             count(count);\n         }\n \n     private void writeBinaryLong(final long number, final int length,\n             final boolean swapHalfWord) throws IOException {\n-        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n+        final byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n         out.write(tmp);\n         count(tmp.length);\n     }\n \n     private void writeAsciiLong(final long number, final int length,\n             final int radix) throws IOException {\n-        StringBuilder tmp = new StringBuilder();\n+        final StringBuilder tmp = new StringBuilder();\n         String tmpStr;\n         if (radix == 16) {\n             tmp.append(Long.toHexString(number));\n         }\n \n         if (tmp.length() <= length) {\n-            long insertLength = length - tmp.length();\n+            final long insertLength = length - tmp.length();\n             for (int pos = 0; pos < insertLength; pos++) {\n                 tmp.insert(0, \"0\");\n             }\n         } else {\n             tmpStr = tmp.substring(tmp.length() - length);\n         }\n-        byte[] b = ArchiveUtils.toAsciiBytes(tmpStr);\n+        final byte[] b = ArchiveUtils.toAsciiBytes(tmpStr);\n         out.write(b);\n         count(b.length);\n     }\n      * @throws IOException if the string couldn't be written\n      */\n     private void writeCString(final String str) throws IOException {\n-        ByteBuffer buf = zipEncoding.encode(str);\n+        final ByteBuffer buf = zipEncoding.encode(str);\n         final int len = buf.limit() - buf.position();\n         out.write(buf.array(), buf.arrayOffset(), len);\n         out.write('\\0');\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioUtil.java\n \n         long ret = 0;\n         int pos = 0;\n-        byte tmp_number[] = new byte[number.length];\n+        final byte tmp_number[] = new byte[number.length];\n         System.arraycopy(number, 0, tmp_number, 0, number.length);\n \n         if (!swapHalfWord) {\n      */\n     static byte[] long2byteArray(final long number, final int length,\n             final boolean swapHalfWord) {\n-        byte[] ret = new byte[length];\n+        final byte[] ret = new byte[length];\n         int pos = 0;\n         long tmp_number = 0;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveConstants.java\n         }\n \n         public static SEGMENT_TYPE find(final int code) {\n-            for (SEGMENT_TYPE t : values()) {\n+            for (final SEGMENT_TYPE t : values()) {\n                 if (t.code == code) {\n                     return t;\n                 }\n         }\n \n         public static COMPRESSION_TYPE find(final int code) {\n-            for (COMPRESSION_TYPE t : values()) {\n+            for (final COMPRESSION_TYPE t : values()) {\n                 if (t.code == code) {\n                     return t;\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntry.java\n             return false;\n         }\n \n-        DumpArchiveEntry rhs = (DumpArchiveEntry) o;\n+        final DumpArchiveEntry rhs = (DumpArchiveEntry) o;\n \n         if ((header == null) || (rhs.header == null)) {\n             return false;\n      * @param buffer buffer to read content from\n      */\n     static DumpArchiveEntry parse(final byte[] buffer) {\n-        DumpArchiveEntry entry = new DumpArchiveEntry();\n-        TapeSegmentHeader header = entry.header;\n+        final DumpArchiveEntry entry = new DumpArchiveEntry();\n+        final TapeSegmentHeader header = entry.header;\n \n         header.type = DumpArchiveConstants.SEGMENT_TYPE.find(DumpArchiveUtil.convert32(\n                     buffer, 0));\n \n         //header.magic = DumpArchiveUtil.convert32(buffer, 24);\n         //header.checksum = DumpArchiveUtil.convert32(buffer, 28);\n-        int m = DumpArchiveUtil.convert16(buffer, 32);\n+        final int m = DumpArchiveUtil.convert16(buffer, 32);\n \n         // determine the type of the file.\n         entry.setType(TYPE.find((m >> 12) & 0x0F));\n         public static TYPE find(final int code) {\n             TYPE type = UNKNOWN;\n \n-            for (TYPE t : TYPE.values()) {\n+            for (final TYPE t : TYPE.values()) {\n                 if (code == t.code) {\n                     type = t;\n                 }\n         }\n \n         public static Set<PERMISSION> find(final int code) {\n-            Set<PERMISSION> set = new HashSet<PERMISSION>();\n-\n-            for (PERMISSION p : PERMISSION.values()) {\n+            final Set<PERMISSION> set = new HashSet<PERMISSION>();\n+\n+            for (final PERMISSION p : PERMISSION.values()) {\n                 if ((code & p.code) == p.code) {\n                     set.add(p);\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n \n         try {\n             // read header, verify it's a dump archive.\n-            byte[] headerBytes = raw.readRecord();\n+            final byte[] headerBytes = raw.readRecord();\n \n             if (!DumpArchiveUtil.verify(headerBytes)) {\n                 throw new UnrecognizedFormatException();\n             // skip past CLRI and BITS segments since we don't handle them yet.\n             readCLRI();\n             readBITS();\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             throw new ArchiveException(ex.getMessage(), ex);\n         }\n \n         // put in a dummy record for the root node.\n-        Dirent root = new Dirent(2, 2, 4, \".\");\n+        final Dirent root = new Dirent(2, 2, 4, \".\");\n         names.put(2, root);\n \n         // use priority based on queue to ensure parent directories are\n      * Read CLRI (deleted inode) segment.\n      */\n     private void readCLRI() throws IOException {\n-        byte[] buffer = raw.readRecord();\n+        final byte[] buffer = raw.readRecord();\n \n         if (!DumpArchiveUtil.verify(buffer)) {\n             throw new InvalidFormatException();\n      * Read BITS segment.\n      */\n     private void readBITS() throws IOException {\n-        byte[] buffer = raw.readRecord();\n+        final byte[] buffer = raw.readRecord();\n \n         if (!DumpArchiveUtil.verify(buffer)) {\n             throw new InvalidFormatException();\n                 pending.put(entry.getIno(), entry);\n             }\n \n-            int datalen = DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\n+            final int datalen = DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\n \n             if (blockBuffer.length < datalen) {\n                 blockBuffer = new byte[datalen];\n \n             for (int i = 0; i < datalen - 8 && i < size - 8;\n                     i += reclen) {\n-                int ino = DumpArchiveUtil.convert32(blockBuffer, i);\n+                final int ino = DumpArchiveUtil.convert32(blockBuffer, i);\n                 reclen = DumpArchiveUtil.convert16(blockBuffer, i + 4);\n \n-                byte type = blockBuffer[i + 6];\n-\n-                String name = DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n+                final byte type = blockBuffer[i + 6];\n+\n+                final String name = DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\n \n                 if (\".\".equals(name) || \"..\".equals(name)) {\n                     // do nothing...\n                     continue;\n                 }\n \n-                Dirent d = new Dirent(ino, entry.getIno(), type, name);\n+                final Dirent d = new Dirent(ino, entry.getIno(), type, name);\n \n                 /*\n                 if ((type == 4) && names.containsKey(ino)) {\n                 names.put(ino, d);\n \n                 // check whether this allows us to fill anything in the pending list.\n-                for (Map.Entry<Integer, DumpArchiveEntry> e : pending.entrySet()) {\n-                    String path = getPath(e.getValue());\n+                for (final Map.Entry<Integer, DumpArchiveEntry> e : pending.entrySet()) {\n+                    final String path = getPath(e.getValue());\n \n                     if (path != null) {\n                         e.getValue().setName(path);\n \n                 // remove anything that we found. (We can't do it earlier\n                 // because of concurrent modification exceptions.)\n-                for (DumpArchiveEntry e : queue) {\n+                for (final DumpArchiveEntry e : queue) {\n                     pending.remove(e.getIno());\n                 }\n             }\n \n-            byte[] peekBytes = raw.peek();\n+            final byte[] peekBytes = raw.peek();\n \n             if (!DumpArchiveUtil.verify(peekBytes)) {\n                 throw new InvalidFormatException();\n     private String getPath(final DumpArchiveEntry entry) {\n         // build the stack of elements. It's possible that we're \n         // still missing an intermediate value and if so we\n-        Stack<String> elements = new Stack<String>();\n+        final Stack<String> elements = new Stack<String>();\n         Dirent dirent = null;\n \n         for (int i = entry.getIno();; i = dirent.getParentIno()) {\n         }\n \n         // generate full path from stack of elements.\n-        StringBuilder sb = new StringBuilder(elements.pop());\n+        final StringBuilder sb = new StringBuilder(elements.pop());\n \n         while (!elements.isEmpty()) {\n             sb.append('/');\n         }\n \n         while (len > 0) {\n-            int sz = len > readBuf.length - recordOffset\n+            final int sz = len > readBuf.length - recordOffset\n                 ? readBuf.length - recordOffset : len;\n \n             // copy any data we have\n             // load next block if necessary.\n             if (len > 0) {\n                 if (readIdx >= 512) {\n-                    byte[] headerBytes = raw.readRecord();\n+                    final byte[] headerBytes = raw.readRecord();\n \n                     if (!DumpArchiveUtil.verify(headerBytes)) {\n                         throw new InvalidFormatException();\n                 }\n \n                 if (!active.isSparseRecord(readIdx++)) {\n-                    int r = raw.read(readBuf, 0, readBuf.length);\n+                    final int r = raw.read(readBuf, 0, readBuf.length);\n                     if (r != readBuf.length) {\n                         throw new EOFException();\n                     }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveSummary.java\n             return false;\n         }\n \n-        DumpArchiveSummary rhs = (DumpArchiveSummary) o;\n+        final DumpArchiveSummary rhs = (DumpArchiveSummary) o;\n \n         if (dumpDate != rhs.dumpDate) {\n             return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtil.java\n      */\n     public static final boolean verify(final byte[] buffer) {\n         // verify magic. for now only accept NFS_MAGIC.\n-        int magic = convert32(buffer, 24);\n+        final int magic = convert32(buffer, 24);\n \n         if (magic != DumpArchiveConstants.NFS_MAGIC) {\n             return false;\n         }\n \n         //verify checksum...\n-        int checksum = convert32(buffer, 28);\n+        final int checksum = convert32(buffer, 28);\n \n         if (checksum != calculateChecksum(buffer)) {\n             return false;\n      */\n     static String decode(final ZipEncoding encoding, final byte[] b, final int offset, final int len)\n         throws IOException {\n-        byte[] copy = new byte[len];\n+        final byte[] copy = new byte[len];\n         System.arraycopy(b, offset, copy, 0, len);\n         return encoding.decode(copy);\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/TapeInputStream.java\n         blockSize = recordSize * recsPerBlock;\n \n         // save first block in case we need it again\n-        byte[] oldBuffer = blockBuffer;\n+        final byte[] oldBuffer = blockBuffer;\n \n         // read rest of new block\n         blockBuffer = new byte[blockSize];\n         }\n \n         // copy data, increment counters.\n-        byte[] b = new byte[recordSize];\n+        final byte[] b = new byte[recordSize];\n         System.arraycopy(blockBuffer, readOffset, b, 0, b.length);\n \n         return b;\n      * @throws IOException on error\n      */\n     public byte[] readRecord() throws IOException {\n-        byte[] result = new byte[recordSize];\n+        final byte[] result = new byte[recordSize];\n \n         // the read implementation will loop internally as long as\n         // input is available\n             }\n             bytesRead += 4;\n \n-            int h = DumpArchiveUtil.convert32(blockBuffer, 0);\n-            boolean compressed = (h & 0x01) == 0x01;\n+            final int h = DumpArchiveUtil.convert32(blockBuffer, 0);\n+            final boolean compressed = (h & 0x01) == 0x01;\n \n             if (!compressed) {\n                 // file is compressed but this block is not.\n                 bytesRead += blockSize;\n             } else {\n                 // this block is compressed.\n-                int flags = (h >> 1) & 0x07;\n+                final int flags = (h >> 1) & 0x07;\n                 int length = (h >> 4) & 0x0FFFFFFF;\n-                byte[] compBuffer = new byte[length];\n+                final byte[] compBuffer = new byte[length];\n                 success = readFully(compBuffer, 0, length);\n                 bytesRead += length;\n \n                         0x03)) {\n                     case ZLIB:\n \n-                        Inflater inflator = new Inflater();\n+                        final Inflater inflator = new Inflater();\n                         try {\n                             inflator.setInput(compBuffer, 0, compBuffer.length);\n                             length = inflator.inflate(blockBuffer);\n                             if (length != blockSize) {\n                                 throw new ShortFileException();\n                             }\n-                        } catch (DataFormatException e) {\n+                        } catch (final DataFormatException e) {\n                             throw new DumpArchiveException(\"bad data\", e);\n                         } finally {\n                             inflator.end();\n      */\n     private boolean readFully(final byte[] b, final int off, final int len)\n         throws IOException {\n-        int count = IOUtils.readFully(in, b, off, len);\n+        final int count = IOUtils.readFully(in, b, off, len);\n         if (count < len) {\n             throw new ShortFileException();\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveEntry.java\n     @Deprecated\n     public Certificate[] getCertificates() {\n         if (certificates != null) { // never true currently\n-            Certificate[] certs = new Certificate[certificates.length];\n+            final Certificate[] certs = new Certificate[certificates.length];\n             System.arraycopy(certificates, 0, certs, 0, certs.length);\n             return certs;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n     }\n \n     public JarArchiveEntry getNextJarEntry() throws IOException {\n-        ZipArchiveEntry entry = getNextZipEntry();\n+        final ZipArchiveEntry entry = getNextZipEntry();\n         return entry == null ? null : new JarArchiveEntry(entry);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/AES256SHA256Decoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/AES256SHA256Decoder.java\n                     final MessageDigest digest;\n                     try {\n                         digest = MessageDigest.getInstance(\"SHA-256\");\n-                    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n+                    } catch (final NoSuchAlgorithmException noSuchAlgorithmException) {\n                         throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n                             noSuchAlgorithmException);\n                     }\n                     cipherInputStream = new CipherInputStream(in, cipher);\n                     isInitialized = true;\n                     return cipherInputStream;\n-                } catch (GeneralSecurityException generalSecurityException) {\n+                } catch (final GeneralSecurityException generalSecurityException) {\n                     throw new IOException(\"Decryption error \" +\n                         \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n                         generalSecurityException);\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/CLI.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/CLI.java\n             }\n \n             private String getContentMethods(final SevenZArchiveEntry entry) {\n-                StringBuilder sb = new StringBuilder();\n+                final StringBuilder sb = new StringBuilder();\n                 boolean first = true;\n-                for (SevenZMethodConfiguration m : entry.getContentMethods()) {\n+                for (final SevenZMethodConfiguration m : entry.getContentMethods()) {\n                     if (!first) {\n                         sb.append(\", \");\n                     }\n             @Override\n             public void takeAction(final SevenZFile archive, final SevenZArchiveEntry entry) \n                 throws IOException {\n-                File outFile = new File(entry.getName());\n+                final File outFile = new File(entry.getName());\n                 if (entry.isDirectory()) {\n                     if (!outFile.isDirectory() && !outFile.mkdirs()) {\n                         throw new IOException(\"Cannot create directory \" + outFile);\n                 }\n \n                 System.out.println(\"extracting to \" + outFile);\n-                File parent = outFile.getParentFile();\n+                final File parent = outFile.getParentFile();\n                 if (parent != null && !parent.exists() && !parent.mkdirs()) {\n                     throw new IOException(\"Cannot create \" + parent);\n                 }\n-                FileOutputStream fos = new FileOutputStream(outFile);\n+                final FileOutputStream fos = new FileOutputStream(outFile);\n                 try {\n                     final long total = entry.getSize();\n                     long off = 0;\n                     while (off < total) {\n-                        int toRead = (int) Math.min(total - off, BUF.length);\n-                        int bytesRead = archive.read(BUF, 0, toRead);\n+                        final int toRead = (int) Math.min(total - off, BUF.length);\n+                        final int bytesRead = archive.read(BUF, 0, toRead);\n                         if (bytesRead < 1) {\n                             throw new IOException(\"reached end of entry \"\n                                                   + entry.getName()\n             usage();\n             return;\n         }\n-        Mode mode = grabMode(args);\n+        final Mode mode = grabMode(args);\n         System.out.println(mode.getMessage() + \" \" + args[0]);\n-        File f = new File(args[0]);\n+        final File f = new File(args[0]);\n         if (!f.isFile()) {\n             System.err.println(f + \" doesn't exist or is a directory\");\n         }\n-        SevenZFile archive = new SevenZFile(f);\n+        final SevenZFile archive = new SevenZFile(f);\n         try {\n             SevenZArchiveEntry ae;\n             while((ae=archive.getNextEntry()) != null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/CoderBase.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/CoderBase.java\n      * @return whether this method can extract options from the given object.\n      */\n     boolean canAcceptOptions(final Object opts) {\n-        for (Class<?> c : acceptableOptions) {\n+        for (final Class<?> c : acceptableOptions) {\n             if (c.isInstance(opts)) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n \n     static InputStream addDecoder(final String archiveName, final InputStream is, final long uncompressedLength,\n             final Coder coder, final byte[] password) throws IOException {\n-        CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));\n+        final CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));\n         if (cb == null) {\n             throw new IOException(\"Unsupported compression method \" +\n                                   Arrays.toString(coder.decompressionMethodId)\n     \n     static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\n                                    final Object options) throws IOException {\n-        CoderBase cb = findByMethod(method);\n+        final CoderBase cb = findByMethod(method);\n         if (cb == null) {\n             throw new IOException(\"Unsupported compression method \" + method);\n         }\n         @Override\n         InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n                 final Coder coder, final byte[] password) throws IOException {\n-            byte propsByte = coder.properties[0];\n+            final byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n                 dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n                 final Coder coder, final byte[] password) throws IOException {\n             try {\n                 return opts.getInputStream(in);\n-            } catch (AssertionError e) {\n+            } catch (final AssertionError e) {\n                 throw new IOException(\"BCJ filter used in \" + archiveName\n                                       + \" needs XZ for Java > 1.4 - see \"\n                                       + \"http://commons.apache.org/proper/commons-compress/limitations.html#7Z\",\n         }\n         @Override\n         OutputStream encode(final OutputStream out, final Object options) {\n-            int level = numberOptionOrDefault(options, 9);\n+            final int level = numberOptionOrDefault(options, 9);\n             final Deflater deflater = new Deflater(level, true);\n             final DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater);\n             return new OutputStream() {\n         @Override\n         OutputStream encode(final OutputStream out, final Object options)\n                 throws IOException {\n-            int blockSize = numberOptionOrDefault(options, BZip2CompressorOutputStream.MAX_BLOCKSIZE);\n+            final int blockSize = numberOptionOrDefault(options, BZip2CompressorOutputStream.MAX_BLOCKSIZE);\n             return new BZip2CompressorOutputStream(out, blockSize);\n         }\n     }\n \n         @Override\n         public int read(final byte[] b, final int off, final int len) throws IOException {\n-            int result = super.read(b, off, len);\n+            final int result = super.read(b, off, len);\n             if (result == -1 && addDummyByte) {\n                 addDummyByte = false;\n                 b[off] = 0;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/DeltaDecoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/DeltaDecoder.java\n \n     @Override\n     OutputStream encode(final OutputStream out, final Object options) throws IOException {\n-        int distance = numberOptionOrDefault(options, 1);\n+        final int distance = numberOptionOrDefault(options, 1);\n         try {\n             return new DeltaOptions(distance).getOutputStream(new FinishableWrapperOutputStream(out));\n-        } catch (UnsupportedOptionsException ex) {\n+        } catch (final UnsupportedOptionsException ex) {\n             throw new IOException(ex.getMessage());\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Folder.java\n      * from the output of the first and so on.</p>\n      */\n     Iterable<Coder> getOrderedCoders() {\n-        LinkedList<Coder> l = new LinkedList<Coder>();\n+        final LinkedList<Coder> l = new LinkedList<Coder>();\n         int current = (int) packedStreams[0]; // more that 2^31 coders?\n         while (current != -1) {\n             l.addLast(coders[current]);\n-            int pair = findBindPairForOutStream(current);\n+            final int pair = findBindPairForOutStream(current);\n             current = pair != -1 ? (int) bindPairs[pair].inIndex : -1;\n         }\n         return l;\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/LZMA2Decoder.java\n     InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n             final Coder coder, final byte[] password) throws IOException {\n         try {\n-            int dictionarySize = getDictionarySize(coder);\n+            final int dictionarySize = getDictionarySize(coder);\n             return new LZMA2InputStream(in, dictionarySize);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             throw new IOException(ex.getMessage());\n         }\n     }\n     @Override\n     OutputStream encode(final OutputStream out, final Object opts)\n         throws IOException {\n-        LZMA2Options options = getOptions(opts);\n-        FinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\n+        final LZMA2Options options = getOptions(opts);\n+        final FinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);\n         return options.getOutputStream(wrapped);\n     }\n \n     @Override\n     byte[] getOptionsAsProperties(final Object opts) {\n-        int dictSize = getDictSize(opts);\n-        int lead = Integer.numberOfLeadingZeros(dictSize);\n-        int secondBit = (dictSize >>> (30 - lead)) - 2;\n+        final int dictSize = getDictSize(opts);\n+        final int lead = Integer.numberOfLeadingZeros(dictSize);\n+        final int secondBit = (dictSize >>> (30 - lead)) - 2;\n         return new byte[] {\n             (byte) ((19 - lead) * 2 + secondBit)\n         };\n         if (opts instanceof LZMA2Options) {\n             return (LZMA2Options) opts;\n         }\n-        LZMA2Options options = new LZMA2Options();\n+        final LZMA2Options options = new LZMA2Options();\n         options.setDictSize(numberOptionOrDefault(opts));\n         return options;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry.java\n      */\n     public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {\n         if (methods != null) {\n-            LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\n-            for (SevenZMethodConfiguration m : methods) {\n+            final LinkedList<SevenZMethodConfiguration> l = new LinkedList<SevenZMethodConfiguration>();\n+            for (final SevenZMethodConfiguration m : methods) {\n                 l.addLast(m);\n             }\n             contentMethods = Collections.unmodifiableList(l);\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n         long totalOutStreams = 0;\n         for (int i = 0; i < coders.length; i++) {\n             coders[i] = new Coder();\n-            int bits = header.readUnsignedByte();\n+            final int bits = header.readUnsignedByte();\n             final int idSize = bits & 0xf;\n             final boolean isSimple = (bits & 0x10) == 0;\n             final boolean hasAttributes = (bits & 0x20) != 0;\n             if (propertyType == 0) {\n                 break;\n             }\n-            long size = readUint64(header);\n+            final long size = readUint64(header);\n             switch (propertyType) {\n                 case NID.kEmptyStream: {\n                     isEmptyStream = readBits(header, files.length);\n             new BufferedInputStream(\n               new BoundedRandomAccessFileInputStream(file,\n                   archive.packSizes[firstPackStreamIndex]));\n-        LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n+        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n         for (final Coder coder : folder.getOrderedCoders()) {\n             if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n                 throw new IOException(\"Multi input/output stream coders are not yet supported\");\n             }\n-            SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n+            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n             inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                     folder.getUnpackSizeForCoder(coder), coder, password);\n             methods.addFirst(new SevenZMethodConfiguration(method,\n             // In solid compression mode we need to decompress all leading folder'\n             // streams to get access to an entry. We defer this until really needed\n             // so that entire blocks can be skipped without wasting time for decompression.\n-            InputStream stream = deferredBlockStreams.remove(0);\n+            final InputStream stream = deferredBlockStreams.remove(0);\n             IOUtils.skip(stream, Long.MAX_VALUE);\n             stream.close();\n         }\n     \n     private static long readUint64(final DataInput in) throws IOException {\n         // long rather than int as it might get shifted beyond the range of an int\n-        long firstByte = in.readUnsignedByte();\n+        final long firstByte = in.readUnsignedByte();\n         int mask = 0x80;\n         long value = 0;\n         for (int i = 0; i < 8; i++) {\n             if ((firstByte & mask) == 0) {\n                 return value | ((firstByte & (mask - 1)) << (8 * i));\n             }\n-            long nextByte = in.readUnsignedByte();\n+            final long nextByte = in.readUnsignedByte();\n             value |= nextByte << (8 * i);\n             mask >>>= 1;\n         }\n         }\n         long skipped = 0;\n         while (bytesToSkip > Integer.MAX_VALUE) {\n-            long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n+            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n             if (skippedNow == 0) {\n                 return skipped;\n             }\n             bytesToSkip -= skippedNow;\n         }\n         while (bytesToSkip > 0) {\n-            int skippedNow = input.skipBytes((int) bytesToSkip);\n+            final int skippedNow = input.skipBytes((int) bytesToSkip);\n             if (skippedNow == 0) {\n                 return skipped;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZMethod.java\n     }\n \n     byte[] getId() {\n-        byte[] copy = new byte[id.length];\n+        final byte[] copy = new byte[id.length];\n         System.arraycopy(id, 0, copy, 0, id.length);\n         return copy;\n     }\n \n     static SevenZMethod byId(final byte[] id) {\n-        for (SevenZMethod m : SevenZMethod.class.getEnumConstants()) {\n+        for (final SevenZMethod m : SevenZMethod.class.getEnumConstants()) {\n             if (Arrays.equals(m.id, id)) {\n                 return m;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n             entry.setCompressedCrcValue(compressedCrc32.getValue());\n             entry.setHasCrc(true);\n             if (additionalCountingStreams != null) {\n-                long[] sizes = new long[additionalCountingStreams.length];\n+                final long[] sizes = new long[additionalCountingStreams.length];\n                 for (int i = 0; i < additionalCountingStreams.length; i++) {\n                     sizes[i] = additionalCountingStreams[i].getBytesWritten();\n                 }\n         }\n \n         OutputStream out = new OutputStreamWrapper();\n-        ArrayList<CountingOutputStream> moreStreams = new ArrayList<CountingOutputStream>();\n+        final ArrayList<CountingOutputStream> moreStreams = new ArrayList<CountingOutputStream>();\n         boolean first = true;\n-        for (SevenZMethodConfiguration m : getContentMethods(files.get(files.size() - 1))) {\n+        for (final SevenZMethodConfiguration m : getContentMethods(files.get(files.size() - 1))) {\n             if (!first) {\n-                CountingOutputStream cos = new CountingOutputStream(out);\n+                final CountingOutputStream cos = new CountingOutputStream(out);\n                 moreStreams.add(cos);\n                 out = cos;\n             }\n     }\n \n     private Iterable<? extends SevenZMethodConfiguration> getContentMethods(final SevenZArchiveEntry entry) {\n-        Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();\n+        final Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();\n         return ms == null ? contentMethods : ms;\n     }\n \n         header.write(NID.kFolder);\n         writeUint64(header, numNonEmptyStreams);\n         header.write(0);\n-        for (SevenZArchiveEntry entry : files) {\n+        for (final SevenZArchiveEntry entry : files) {\n             if (entry.hasStream()) {\n                 writeFolder(header, entry);\n             }\n         header.write(NID.kCodersUnpackSize);\n         for (final SevenZArchiveEntry entry : files) {\n             if (entry.hasStream()) {\n-                long[] moreSizes = additionalSizes.get(entry);\n+                final long[] moreSizes = additionalSizes.get(entry);\n                 if (moreSizes != null) {\n-                    for (long s : moreSizes) {\n+                    for (final long s : moreSizes) {\n                         writeUint64(header, s);\n                     }\n                 }\n     }\n     \n     private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry) throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int numCoders = 0;\n-        for (SevenZMethodConfiguration m : getContentMethods(entry)) {\n+        for (final SevenZMethodConfiguration m : getContentMethods(entry)) {\n             numCoders++;\n             writeSingleCodec(m, bos);\n         }\n     }\n \n     private void writeSingleCodec(final SevenZMethodConfiguration m, final OutputStream bos) throws IOException {\n-        byte[] id = m.getMethod().getId();\n-        byte[] properties = Coders.findByMethod(m.getMethod())\n+        final byte[] id = m.getMethod().getId();\n+        final byte[] properties = Coders.findByMethod(m.getMethod())\n             .getOptionsAsProperties(m.getOptions());\n \n         int codecFlags = id.length;\n         boolean hasEmptyFiles = false;\n         int emptyStreamCounter = 0;\n         final BitSet emptyFiles = new BitSet(0);\n-        for (SevenZArchiveEntry file1 : files) {\n+        for (final SevenZArchiveEntry file1 : files) {\n             if (!file1.hasStream()) {\n-                boolean isDir = file1.isDirectory();\n+                final boolean isDir = file1.isDirectory();\n                 emptyFiles.set(emptyStreamCounter++, !isDir);\n                 hasEmptyFiles |= !isDir;\n             }\n         boolean hasAntiItems = false;\n         final BitSet antiItems = new BitSet(0);\n         int antiItemCounter = 0;\n-        for (SevenZArchiveEntry file1 : files) {\n+        for (final SevenZArchiveEntry file1 : files) {\n             if (!file1.hasStream()) {\n-                boolean isAnti = file1.isAntiItem();\n+                final boolean isAnti = file1.isAntiItem();\n                 antiItems.set(antiItemCounter++, isAnti);\n                 hasAntiItems |= isAnti;\n             }\n     }\n \n     private static <T> Iterable<T> reverse(final Iterable<T> i) {\n-        LinkedList<T> l = new LinkedList<T>();\n-        for (T t : i) {\n+        final LinkedList<T> l = new LinkedList<T>();\n+        for (final T t : i) {\n             l.addFirst(t);\n         }\n         return l;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n         this.preserveLeadingSlashes = preserveLeadingSlashes;\n \n         name = normalizeFileName(name, preserveLeadingSlashes);\n-        boolean isDir = name.endsWith(\"/\");\n+        final boolean isDir = name.endsWith(\"/\");\n \n         this.name = name;\n         this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n      * @param fileName the name to be used for the entry.\n      */\n     public TarArchiveEntry(final File file, final String fileName) {\n-        String normalizedName = normalizeFileName(fileName, false);\n+        final String normalizedName = normalizeFileName(fileName, false);\n         this.file = file;\n \n         if (file.isDirectory()) {\n             this.mode = DEFAULT_DIR_MODE;\n             this.linkFlag = LF_DIR;\n \n-            int nameLength = normalizedName.length();\n+            final int nameLength = normalizedName.length();\n             if (nameLength == 0 || normalizedName.charAt(nameLength - 1) != '/') {\n                 this.name = normalizedName + \"/\";\n             } else {\n             return EMPTY_TAR_ARCHIVE_ENTRIES;\n         }\n \n-        String[] list = file.list();\n+        final String[] list = file.list();\n         if (list == null) {\n             return EMPTY_TAR_ARCHIVE_ENTRIES;\n         }\n-        TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n+        final TarArchiveEntry[] result = new TarArchiveEntry[list.length];\n \n         for (int i = 0; i < result.length; ++i) {\n             result[i] = new TarArchiveEntry(new File(file, list[i]));\n     public void writeEntryHeader(final byte[] outbuf) {\n         try {\n             writeEntryHeader(outbuf, TarUtils.DEFAULT_ENCODING, false);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             try {\n                 writeEntryHeader(outbuf, TarUtils.FALLBACK_ENCODING, false);\n-            } catch (IOException ex2) {\n+            } catch (final IOException ex2) {\n                 // impossible\n                 throw new RuntimeException(ex2);\n             }\n         offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n                                        starMode);\n \n-        int csOffset = offset;\n+        final int csOffset = offset;\n \n         for (int c = 0; c < CHKSUMLEN; ++c) {\n             outbuf[offset++] = (byte) ' ';\n             outbuf[offset++] = 0;\n         }\n \n-        long chk = TarUtils.computeCheckSum(outbuf);\n+        final long chk = TarUtils.computeCheckSum(outbuf);\n \n         TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n     }\n     public void parseTarHeader(final byte[] header) {\n         try {\n             parseTarHeader(header, TarUtils.DEFAULT_ENCODING);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             try {\n                 parseTarHeader(header, TarUtils.DEFAULT_ENCODING, true);\n-            } catch (IOException ex2) {\n+            } catch (final IOException ex2) {\n                 // not really possible\n                 throw new RuntimeException(ex2);\n             }\n         devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n         offset += DEVLEN;\n \n-        int type = evaluateType(header);\n+        final int type = evaluateType(header);\n         switch (type) {\n         case FORMAT_OLDGNU: {\n             offset += ATIMELEN_GNU;\n             break;\n         }\n         case FORMAT_XSTAR: {\n-            String xstarPrefix = oldStyle\n+            final String xstarPrefix = oldStyle\n                 ? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR)\n                 : TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding);\n             if (xstarPrefix.length() > 0) {\n         }\n         case FORMAT_POSIX:\n         default: {\n-            String prefix = oldStyle\n+            final String prefix = oldStyle\n                 ? TarUtils.parseName(header, offset, PREFIXLEN)\n                 : TarUtils.parseName(header, offset, PREFIXLEN, encoding);\n             // SunOS tar -E does not add / to directory names, so fix\n      */\n     private static String normalizeFileName(String fileName,\n                                             final boolean preserveLeadingSlashes) {\n-        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n+        final String osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n \n         if (osname != null) {\n \n \n             if (osname.startsWith(\"windows\")) {\n                 if (fileName.length() > 2) {\n-                    char ch1 = fileName.charAt(0);\n-                    char ch2 = fileName.charAt(1);\n+                    final char ch1 = fileName.charAt(0);\n+                    final char ch2 = fileName.charAt(1);\n \n                     if (ch2 == ':'\n                         && (ch1 >= 'a' && ch1 <= 'z'\n                     }\n                 }\n             } else if (osname.contains(\"netware\")) {\n-                int colon = fileName.indexOf(':');\n+                final int colon = fileName.indexOf(':');\n                 if (colon != -1) {\n                     fileName = fileName.substring(colon + 1);\n                 }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n             skipRecordPadding();\n         }\n \n-        byte[] headerBuf = getRecord();\n+        final byte[] headerBuf = getRecord();\n \n         if (headerBuf == null) {\n             /* hit EOF */\n \n         try {\n             currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             throw new IOException(\"Error detected parsing the header\", e);\n         }\n \n         entrySize = currEntry.getSize();\n \n         if (currEntry.isGNULongLinkEntry()) {\n-            byte[] longLinkData = getLongNameData();\n+            final byte[] longLinkData = getLongNameData();\n             if (longLinkData == null) {\n                 // Bugzilla: 40334\n                 // Malformed tar file - long link entry name not followed by\n         }\n \n         if (currEntry.isGNULongNameEntry()) {\n-            byte[] longNameData = getLongNameData();\n+            final byte[] longNameData = getLongNameData();\n             if (longNameData == null) {\n                 // Bugzilla: 40334\n                 // Malformed tar file - long entry name not followed by\n      */\n     private void skipRecordPadding() throws IOException {\n         if (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {\n-            long numRecords = (this.entrySize / this.recordSize) + 1;\n-            long padding = (numRecords * this.recordSize) - this.entrySize;\n-            long skipped = IOUtils.skip(is, padding);\n+            final long numRecords = (this.entrySize / this.recordSize) + 1;\n+            final long padding = (numRecords * this.recordSize) - this.entrySize;\n+            final long skipped = IOUtils.skip(is, padding);\n             count(skipped);\n         }\n     }\n      */\n     protected byte[] getLongNameData() throws IOException {\n         // read in the name\n-        ByteArrayOutputStream longName = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream longName = new ByteArrayOutputStream();\n         int length = 0;\n         while ((length = read(SMALL_BUF)) >= 0) {\n             longName.write(SMALL_BUF, 0, length);\n             --length;\n         }\n         if (length != longNameData.length) {\n-            byte[] l = new byte[length];\n+            final byte[] l = new byte[length];\n             System.arraycopy(longNameData, 0, l, 0, length);\n             longNameData = l;\n         }\n      */\n     protected byte[] readRecord() throws IOException {\n \n-        byte[] record = new byte[recordSize];\n-\n-        int readNow = IOUtils.readFully(is, record);\n+        final byte[] record = new byte[recordSize];\n+\n+        final int readNow = IOUtils.readFully(is, record);\n         count(readNow);\n         if (readNow != recordSize) {\n             return null;\n     }\n \n     private void paxHeaders() throws IOException{\n-        Map<String, String> headers = parsePaxHeaders(this);\n+        final Map<String, String> headers = parsePaxHeaders(this);\n         getNextEntry(); // Get the actual file entry\n         applyPaxHeadersToCurrentEntry(headers);\n     }\n     // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n     Map<String, String> parsePaxHeaders(final InputStream i)\n         throws IOException {\n-        Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n+        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n         // Format is \"length keyword=value\\n\";\n         while(true){ // get length\n             int ch;\n                 read++;\n                 if (ch == ' '){ // End of length string\n                     // Get keyword\n-                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n+                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                     while((ch = i.read()) != -1) {\n                         read++;\n                         if (ch == '='){ // end of keyword\n-                            String keyword = coll.toString(CharsetNames.UTF_8);\n+                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                             // Get rest of entry\n                             final int restLen = len - read;\n                             if (restLen == 1) { // only NL\n                                 headers.remove(keyword);\n                             } else {\n-                                byte[] rest = new byte[restLen];\n-                                int got = IOUtils.readFully(i, rest);\n+                                final byte[] rest = new byte[restLen];\n+                                final int got = IOUtils.readFully(i, rest);\n                                 if (got != restLen) {\n                                     throw new IOException(\"Failed to read \"\n                                                           + \"Paxheader. Expected \"\n                                                           + got);\n                                 }\n                                 // Drop trailing NL\n-                                String value = new String(rest, 0,\n+                                final String value = new String(rest, 0,\n                                                           restLen - 1, CharsetNames.UTF_8);\n                                 headers.put(keyword, value);\n                             }\n          * star files use additional members of which we use\n          * SCHILY.filetype in order to detect star sparse files.\n          */\n-        for (Entry<String, String> ent : headers.entrySet()){\n-            String key = ent.getKey();\n-            String val = ent.getValue();\n+        for (final Entry<String, String> ent : headers.entrySet()){\n+            final String key = ent.getKey();\n+            final String val = ent.getValue();\n             if (\"path\".equals(key)){\n                 currEntry.setName(val);\n             } else if (\"linkpath\".equals(key)){\n         if (currEntry.isExtended()) {\n             TarArchiveSparseEntry entry;\n             do {\n-                byte[] headerBuf = getRecord();\n+                final byte[] headerBuf = getRecord();\n                 if (headerBuf == null) {\n                     currEntry = null;\n                     break;\n      */\n     private void tryToConsumeSecondEOFRecord() throws IOException {\n         boolean shouldReset = true;\n-        boolean marked = is.markSupported();\n+        final boolean marked = is.markSupported();\n         if (marked) {\n             is.mark(recordSize);\n         }\n     @Override\n     public boolean canReadEntryData(final ArchiveEntry ae) {\n         if (ae instanceof TarArchiveEntry) {\n-            TarArchiveEntry te = (TarArchiveEntry) ae;\n+            final TarArchiveEntry te = (TarArchiveEntry) ae;\n             return !te.isSparse();\n         }\n         return false;\n      * the tool creating this archive has padded the last block.\n      */\n     private void consumeRemainderOfLastBlock() throws IOException {\n-        long bytesReadOfLastBlock = getBytesRead() % blockSize;\n+        final long bytesReadOfLastBlock = getBytesRead() % blockSize;\n         if (bytesReadOfLastBlock > 0) {\n-            long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n+            final long skipped = IOUtils.skip(is, blockSize - bytesReadOfLastBlock);\n             count(skipped);\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n         if (finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n-        Map<String, String> paxHeaders = new HashMap<String, String>();\n+        final TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n+        final Map<String, String> paxHeaders = new HashMap<String, String>();\n         final String entryName = entry.getName();\n-        boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n+        final boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \"path\",\n                                                        TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\n \n         final String linkName = entry.getLinkName();\n-        boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n+        final boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0\n             && handleLongName(entry, linkName, paxHeaders, \"linkpath\",\n                               TarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\n \n \n         if (assemLen > 0) {\n             if (assemLen + numToWrite >= recordBuf.length) {\n-                int aLen = recordBuf.length - assemLen;\n+                final int aLen = recordBuf.length - assemLen;\n \n                 System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                  assemLen);\n \n             writeRecord(wBuf, wOffset);\n \n-            int num = recordBuf.length;\n+            final int num = recordBuf.length;\n \n             currBytes += num;\n             numToWrite -= num;\n         if (name.length() >= TarConstants.NAMELEN) {\n             name = name.substring(0, TarConstants.NAMELEN - 1);\n         }\n-        TarArchiveEntry pex = new TarArchiveEntry(name,\n+        final TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                   TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n         transferModTime(entry, pex);\n \n-        StringWriter w = new StringWriter();\n-        for (Map.Entry<String, String> h : headers.entrySet()) {\n-            String key = h.getKey();\n-            String value = h.getValue();\n+        final StringWriter w = new StringWriter();\n+        for (final Map.Entry<String, String> h : headers.entrySet()) {\n+            final String key = h.getKey();\n+            final String value = h.getValue();\n             int len = key.length() + value.length()\n                 + 3 /* blank, equals and newline */\n                 + 2 /* guess 9 < actual length < 100 */;\n             }\n             w.write(line);\n         }\n-        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n+        final byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n         pex.setSize(data.length);\n         putArchiveEntry(pex);\n         write(data);\n \n     private String stripTo7Bits(final String name) {\n         final int length = name.length();\n-        StringBuilder result = new StringBuilder(length);\n+        final StringBuilder result = new StringBuilder(length);\n         for (int i = 0; i < length; i++) {\n-            char stripped = (char) (name.charAt(i) & 0x7F);\n+            final char stripped = (char) (name.charAt(i) & 0x7F);\n             if (shouldBeReplaced(stripped)) {\n                 result.append(\"_\");\n             } else {\n     }\n \n     private void padAsNeeded() throws IOException {\n-        int start = recordsWritten % recordsPerBlock;\n+        final int start = recordsWritten % recordsPerBlock;\n         if (start != 0) {\n             for (int i = start; i < recordsPerBlock; i++) {\n                 writeEOFRecord();\n             } else if (longFileMode == LONGFILE_GNU) {\n                 // create a TarEntry for the LongLink, the contents\n                 // of which are the link's name\n-                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n+                final TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\n \n                 longLinkEntry.setSize(len + 1); // +1 for NUL\n                 transferModTime(entry, longLinkEntry);\n \n     private void transferModTime(final TarArchiveEntry from, final TarArchiveEntry to) {\n         Date fromModTime = from.getModTime();\n-        long fromModTimeSeconds = fromModTime.getTime() / 1000;\n+        final long fromModTimeSeconds = fromModTime.getTime() / 1000;\n         if (fromModTimeSeconds < 0 || fromModTimeSeconds > TarConstants.MAXSIZE) {\n             fromModTime = new Date(0);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n             @Override\n             public ByteBuffer encode(final String name) {\n                 final int length = name.length();\n-                byte[] buf = new byte[length];\n+                final byte[] buf = new byte[length];\n \n                 // copy until end of input or output is reached.\n                 for (int i = 0; i < length; ++i) {\n             @Override\n             public String decode(final byte[] buffer) {\n                 final int length = buffer.length;\n-                StringBuilder result = new StringBuilder(length);\n-\n-                for (byte b : buffer) {\n+                final StringBuilder result = new StringBuilder(length);\n+\n+                for (final byte b : buffer) {\n                     if (b == 0) { // Trailing null\n                         break;\n                     }\n                                               final int offset,\n                                               final int length,\n                                               final boolean negative) {\n-        byte[] remainder = new byte[length - 1];\n+        final byte[] remainder = new byte[length - 1];\n         System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\n         BigInteger val = new BigInteger(remainder);\n         if (negative) {\n     public static String parseName(final byte[] buffer, final int offset, final int length) {\n         try {\n             return parseName(buffer, offset, length, DEFAULT_ENCODING);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             try {\n                 return parseName(buffer, offset, length, FALLBACK_ENCODING);\n-            } catch (IOException ex2) {\n+            } catch (final IOException ex2) {\n                 // impossible\n                 throw new RuntimeException(ex2);\n             }\n             }\n         }\n         if (len > 0) {\n-            byte[] b = new byte[len];\n+            final byte[] b = new byte[len];\n             System.arraycopy(buffer, offset, b, 0, len);\n             return encoding.decode(b);\n         }\n     public static int formatNameBytes(final String name, final byte[] buf, final int offset, final int length) {\n         try {\n             return formatNameBytes(name, buf, offset, length, DEFAULT_ENCODING);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             try {\n                 return formatNameBytes(name, buf, offset, length,\n                                        FALLBACK_ENCODING);\n-            } catch (IOException ex2) {\n+            } catch (final IOException ex2) {\n                 // impossible\n                 throw new RuntimeException(ex2);\n             }\n      */\n     public static int formatLongOctalBytes(final long value, final byte[] buf, final int offset, final int length) {\n \n-        int idx=length-1; // For space\n+        final int idx=length-1; // For space\n \n         formatUnsignedOctalString(value, buf, offset, idx);\n         buf[offset + idx] = (byte) ' '; // Trailing space\n                                                final int offset,\n                                                final int length,\n                                                final boolean negative) {\n-        BigInteger val = BigInteger.valueOf(value);\n+        final BigInteger val = BigInteger.valueOf(value);\n         final byte[] b = val.toByteArray();\n         final int len = b.length;\n         final int off = offset + length - len;\n     public static long computeCheckSum(final byte[] buf) {\n         long sum = 0;\n \n-        for (byte element : buf) {\n+        for (final byte element : buf) {\n             sum += BYTE_MASK & element;\n         }\n \n      * @since 1.5\n      */\n     public static boolean verifyCheckSum(final byte[] header) {\n-        long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n+        final long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n         long unsignedSum = 0;\n         long signedSum = 0;\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n      * <code>bytes</code>.\n      */\n     protected AbstractUnicodeExtraField(final String text, final byte[] bytes, final int off, final int len) {\n-        CRC32 crc32 = new CRC32();\n+        final CRC32 crc32 = new CRC32();\n         crc32.update(bytes, off, len);\n         nameCRC32 = crc32.getValue();\n \n         try {\n             unicodeName = text.getBytes(CharsetNames.UTF_8);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new RuntimeException(\"FATAL: UTF-8 encoding not supported.\", e);\n         }\n     }\n             throw new ZipException(\"UniCode path extra data must have at least 5 bytes.\");\n         }\n \n-        int version = buffer[offset];\n+        final int version = buffer[offset];\n \n         if (version != 0x01) {\n             throw new ZipException(\"Unsupported version [\" + version\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n     @Override\n     public byte[] getLocalFileDataData() {\n         // CRC will be added later\n-        byte[] data = new byte[getLocalFileDataLength().getValue() - WORD];\n+        final byte[] data = new byte[getLocalFileDataLength().getValue() - WORD];\n         System.arraycopy(ZipShort.getBytes(getMode()), 0, data, 0, 2);\n \n-        byte[] linkArray = getLinkedFile().getBytes(); // Uses default charset - see class Javadoc\n+        final byte[] linkArray = getLinkedFile().getBytes(); // Uses default charset - see class Javadoc\n         // CheckStyle:MagicNumber OFF\n         System.arraycopy(ZipLong.getBytes(linkArray.length),\n                          0, data, 2, WORD);\n \n         crc.reset();\n         crc.update(data);\n-        long checksum = crc.getValue();\n-\n-        byte[] result = new byte[data.length + WORD];\n+        final long checksum = crc.getValue();\n+\n+        final byte[] result = new byte[data.length + WORD];\n         System.arraycopy(ZipLong.getBytes(checksum), 0, result, 0, WORD);\n         System.arraycopy(data, 0, result, WORD, data.length);\n         return result;\n     public void parseFromLocalFileData(final byte[] data, final int offset, final int length)\n         throws ZipException {\n \n-        long givenChecksum = ZipLong.getValue(data, offset);\n-        byte[] tmp = new byte[length - WORD];\n+        final long givenChecksum = ZipLong.getValue(data, offset);\n+        final byte[] tmp = new byte[length - WORD];\n         System.arraycopy(data, offset + WORD, tmp, 0, length - WORD);\n         crc.reset();\n         crc.update(tmp);\n-        long realChecksum = crc.getValue();\n+        final long realChecksum = crc.getValue();\n         if (givenChecksum != realChecksum) {\n             throw new ZipException(\"bad CRC checksum \"\n                                    + Long.toHexString(givenChecksum)\n                                    + Long.toHexString(realChecksum));\n         }\n \n-        int newMode = ZipShort.getValue(tmp, 0);\n+        final int newMode = ZipShort.getValue(tmp, 0);\n         // CheckStyle:MagicNumber OFF\n-        byte[] linkArray = new byte[(int) ZipLong.getValue(tmp, 2)];\n+        final byte[] linkArray = new byte[(int) ZipLong.getValue(tmp, 2)];\n         uid = ZipShort.getValue(tmp, 6);\n         gid = ZipShort.getValue(tmp, 8);\n \n     @Override\n     public Object clone() {\n         try {\n-            AsiExtraField cloned = (AsiExtraField) super.clone();\n+            final AsiExtraField cloned = (AsiExtraField) super.clone();\n             cloned.crc = new CRC32();\n             return cloned;\n-        } catch (CloneNotSupportedException cnfe) {\n+        } catch (final CloneNotSupportedException cnfe) {\n             // impossible\n             throw new RuntimeException(cnfe);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/BinaryTree.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/BinaryTree.java\n             tree[node] = NODE;\n             \n             // move down the path recursively\n-            int nextChild = 2 * node + 1 + (path & 1);\n+            final int nextChild = 2 * node + 1 + (path & 1);\n             addLeaf(nextChild, path >>> 1, depth - 1, value);\n         }\n     }\n         int currentIndex = 0;\n \n         while (true) {\n-            int bit = stream.nextBit();\n+            final int bit = stream.nextBit();\n             if (bit == -1) {\n                 return -1;\n             }\n \n-            int childIndex = 2 * currentIndex + 1 + bit;\n-            int value = tree[childIndex];\n+            final int childIndex = 2 * currentIndex + 1 + bit;\n+            final int value = tree[childIndex];\n             if (value == NODE) {\n                 // consume the next bit\n                 currentIndex = childIndex;\n      */\n     static BinaryTree decode(final InputStream in, final int totalNumberOfValues) throws IOException {\n         // the first byte contains the size of the structure minus one\n-        int size = in.read() + 1;\n+        final int size = in.read() + 1;\n         if (size == 0) {\n             throw new IOException(\"Cannot read the size of the encoded tree, unexpected end of stream\");\n         }\n \n-        byte[] encodedTree = new byte[size];\n+        final byte[] encodedTree = new byte[size];\n         new DataInputStream(in).readFully(encodedTree);\n \n         /** The maximum bit length for a value (16 or lower) */\n         int maxLength = 0;\n         \n-        int[] originalBitLengths = new int[totalNumberOfValues];\n+        final int[] originalBitLengths = new int[totalNumberOfValues];\n         int pos = 0;\n-        for (byte b : encodedTree) {\n+        for (final byte b : encodedTree) {\n             // each byte encodes the number of values (upper 4 bits) for a bit length (lower 4 bits)\n-            int numberOfValues = ((b & 0xF0) >> 4) + 1;\n-            int bitLength = (b & 0x0F) + 1;\n+            final int numberOfValues = ((b & 0xF0) >> 4) + 1;\n+            final int bitLength = (b & 0x0F) + 1;\n \n             for (int j = 0; j < numberOfValues; j++) {\n                 originalBitLengths[pos++] = bitLength;\n         }\n \n         // sort the array of bit lengths and memorize the permutation used to restore the order of the codes\n-        int[] permutation = new int[originalBitLengths.length];\n+        final int[] permutation = new int[originalBitLengths.length];\n         for (int k = 0; k < permutation.length; k++) {\n             permutation[k] = k;\n         }\n         \n         int c = 0;\n-        int[] sortedBitLengths = new int[originalBitLengths.length];\n+        final int[] sortedBitLengths = new int[originalBitLengths.length];\n         for (int k = 0; k < originalBitLengths.length; k++) {\n             // iterate over the values\n             for (int l = 0; l < originalBitLengths.length; l++) {\n         int codeIncrement = 0;\n         int lastBitLength = 0;\n \n-        int[] codes = new int[totalNumberOfValues];\n+        final int[] codes = new int[totalNumberOfValues];\n \n         for (int i = totalNumberOfValues - 1; i >= 0; i--) {\n             code = code + codeIncrement;\n         }\n         \n         // build the tree\n-        BinaryTree tree = new BinaryTree(maxLength);\n+        final BinaryTree tree = new BinaryTree(maxLength);\n         \n         for (int k = 0; k < codes.length; k++) {\n-            int bitLength = originalBitLengths[k];\n+            final int bitLength = originalBitLengths[k];\n             if (bitLength > 0) {\n                 tree.addLeaf(0, Integer.reverse(codes[k] << 16), bitLength, k);\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/CircularBuffer.java\n      */\n     public int get() {\n         if (available()) {\n-            int value = buffer[readIndex];\n+            final int value = buffer[readIndex];\n             readIndex = (readIndex + 1) % size;\n             return value & 0xFF;\n         }\n      * @param length   the number of bytes to copy\n      */\n     public void copy(final int distance, final int length) {\n-        int pos1 = writeIndex - distance;\n-        int pos2 = pos1 + length;\n+        final int pos1 = writeIndex - distance;\n+        final int pos2 = pos1 + length;\n         for (int i = pos1; i < pos2; i++) {\n             buffer[writeIndex] = buffer[(i + size) % size];\n             writeIndex = (writeIndex + 1) % size;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExplodingInputStream.java\n     private void fillBuffer() throws IOException {\n         init();\n         \n-        int bit = bits.nextBit();\n+        final int bit = bits.nextBit();\n         if (bit == 1) {\n             // literal value\n             int literal;\n \n         } else if (bit == 0) {\n             // back reference\n-            int distanceLowSize = dictionarySize == 4096 ? 6 : 7;\n-            int distanceLow = (int) bits.nextBits(distanceLowSize);\n-            int distanceHigh = distanceTree.read(bits);\n+            final int distanceLowSize = dictionarySize == 4096 ? 6 : 7;\n+            final int distanceLow = (int) bits.nextBits(distanceLowSize);\n+            final int distanceHigh = distanceTree.read(bits);\n             if (distanceHigh == -1 && distanceLow <= 0) {\n                 // end of stream reached, nothing left to decode\n                 return;\n             }\n-            int distance = distanceHigh << distanceLowSize | distanceLow;\n+            final int distance = distanceHigh << distanceLowSize | distanceLow;\n             \n             int length = lengthTree.read(bits);\n             if (length == 63) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n      */\n     public static void register(final Class<?> c) {\n         try {\n-            ZipExtraField ze = (ZipExtraField) c.newInstance();\n+            final ZipExtraField ze = (ZipExtraField) c.newInstance();\n             implementations.put(ze.getHeaderId(), c);\n-        } catch (ClassCastException cc) {\n+        } catch (final ClassCastException cc) {\n             throw new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n-        } catch (InstantiationException ie) {\n+        } catch (final InstantiationException ie) {\n             throw new RuntimeException(c + \" is not a concrete class\");\n-        } catch (IllegalAccessException ie) {\n+        } catch (final IllegalAccessException ie) {\n             throw new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n         }\n     }\n      */\n     public static ZipExtraField createExtraField(final ZipShort headerId)\n         throws InstantiationException, IllegalAccessException {\n-        Class<?> c = implementations.get(headerId);\n+        final Class<?> c = implementations.get(headerId);\n         if (c != null) {\n             return (ZipExtraField) c.newInstance();\n         }\n-        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n         u.setHeaderId(headerId);\n         return u;\n     }\n     public static ZipExtraField[] parse(final byte[] data, final boolean local,\n                                         final UnparseableExtraField onUnparseableData)\n         throws ZipException {\n-        List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n+        final List<ZipExtraField> v = new ArrayList<ZipExtraField>();\n         int start = 0;\n         LOOP:\n         while (start <= data.length - WORD) {\n-            ZipShort headerId = new ZipShort(data, start);\n-            int length = new ZipShort(data, start + 2).getValue();\n+            final ZipShort headerId = new ZipShort(data, start);\n+            final int length = new ZipShort(data, start + 2).getValue();\n             if (start + WORD + length > data.length) {\n                 switch(onUnparseableData.getKey()) {\n                 case UnparseableExtraField.THROW_KEY:\n                                            + (data.length - start - WORD)\n                                            + \" bytes.\");\n                 case UnparseableExtraField.READ_KEY:\n-                    UnparseableExtraFieldData field =\n+                    final UnparseableExtraFieldData field =\n                         new UnparseableExtraFieldData();\n                     if (local) {\n                         field.parseFromLocalFileData(data, start,\n                 }\n             }\n             try {\n-                ZipExtraField ze = createExtraField(headerId);\n+                final ZipExtraField ze = createExtraField(headerId);\n                 if (local) {\n                     ze.parseFromLocalFileData(data, start + WORD, length);\n                 } else {\n                                                      length);\n                 }\n                 v.add(ze);\n-            } catch (InstantiationException ie) {\n+            } catch (final InstantiationException ie) {\n                 throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n-            } catch (IllegalAccessException iae) {\n+            } catch (final IllegalAccessException iae) {\n                 throw (ZipException) new ZipException(iae.getMessage()).initCause(iae);\n             }\n             start += length + WORD;\n         }\n \n-        ZipExtraField[] result = new ZipExtraField[v.size()];\n+        final ZipExtraField[] result = new ZipExtraField[v.size()];\n         return v.toArray(result);\n     }\n \n     public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\n         final boolean lastIsUnparseableHolder = data.length > 0\n             && data[data.length - 1] instanceof UnparseableExtraFieldData;\n-        int regularExtraFieldCount =\n+        final int regularExtraFieldCount =\n             lastIsUnparseableHolder ? data.length - 1 : data.length;\n \n         int sum = WORD * regularExtraFieldCount;\n-        for (ZipExtraField element : data) {\n+        for (final ZipExtraField element : data) {\n             sum += element.getLocalFileDataLength().getValue();\n         }\n \n-        byte[] result = new byte[sum];\n+        final byte[] result = new byte[sum];\n         int start = 0;\n         for (int i = 0; i < regularExtraFieldCount; i++) {\n             System.arraycopy(data[i].getHeaderId().getBytes(),\n             System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                              0, result, start + 2, 2);\n             start += WORD;\n-            byte[] local = data[i].getLocalFileDataData();\n+            final byte[] local = data[i].getLocalFileDataData();\n             if (local != null) {\n                 System.arraycopy(local, 0, result, start, local.length);\n                 start += local.length;\n             }\n         }\n         if (lastIsUnparseableHolder) {\n-            byte[] local = data[data.length - 1].getLocalFileDataData();\n+            final byte[] local = data[data.length - 1].getLocalFileDataData();\n             if (local != null) {\n                 System.arraycopy(local, 0, result, start, local.length);\n             }\n     public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\n         final boolean lastIsUnparseableHolder = data.length > 0\n             && data[data.length - 1] instanceof UnparseableExtraFieldData;\n-        int regularExtraFieldCount =\n+        final int regularExtraFieldCount =\n             lastIsUnparseableHolder ? data.length - 1 : data.length;\n \n         int sum = WORD * regularExtraFieldCount;\n-        for (ZipExtraField element : data) {\n+        for (final ZipExtraField element : data) {\n             sum += element.getCentralDirectoryLength().getValue();\n         }\n-        byte[] result = new byte[sum];\n+        final byte[] result = new byte[sum];\n         int start = 0;\n         for (int i = 0; i < regularExtraFieldCount; i++) {\n             System.arraycopy(data[i].getHeaderId().getBytes(),\n             System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                              0, result, start + 2, 2);\n             start += WORD;\n-            byte[] local = data[i].getCentralDirectoryData();\n+            final byte[] local = data[i].getCentralDirectoryData();\n             if (local != null) {\n                 System.arraycopy(local, 0, result, start, local.length);\n                 start += local.length;\n             }\n         }\n         if (lastIsUnparseableHolder) {\n-            byte[] local = data[data.length - 1].getCentralDirectoryData();\n+            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n             if (local != null) {\n                 System.arraycopy(local, 0, result, start, local.length);\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBit.java\n      * @return the encoded general purpose bits\n      */\n     public byte[] encode() {\n-        byte[] result = new byte[2];\n+        final byte[] result = new byte[2];\n         encode(result, 0);\n         return result;\n     }\n      */\n     public static GeneralPurposeBit parse(final byte[] data, final int offset) {\n         final int generalPurposeFlag = ZipShort.getValue(data, offset);\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\n         b.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\n         b.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\n         if (!(o instanceof GeneralPurposeBit)) {\n             return false;\n         }\n-        GeneralPurposeBit g = (GeneralPurposeBit) o;\n+        final GeneralPurposeBit g = (GeneralPurposeBit) o;\n         return g.encryptionFlag == encryptionFlag\n             && g.strongEncryptionFlag == strongEncryptionFlag\n             && g.languageEncodingFlag == languageEncodingFlag\n     public Object clone() {\n         try {\n             return super.clone();\n-        } catch (CloneNotSupportedException ex) {\n+        } catch (final CloneNotSupportedException ex) {\n             // impossible\n             throw new RuntimeException(\"GeneralPurposeBit is not Cloneable?\", ex);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n      */\n     @Override\n     public boolean canEncode(final String name) {\n-        CharsetEncoder enc = this.charset.newEncoder();\n+        final CharsetEncoder enc = this.charset.newEncoder();\n         enc.onMalformedInput(CodingErrorAction.REPORT);\n         enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n \n      */\n     @Override\n     public ByteBuffer encode(final String name) {\n-        CharsetEncoder enc = this.charset.newEncoder();\n+        final CharsetEncoder enc = this.charset.newEncoder();\n \n         enc.onMalformedInput(CodingErrorAction.REPORT);\n         enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n \n-        CharBuffer cb = CharBuffer.wrap(name);\n+        final CharBuffer cb = CharBuffer.wrap(name);\n         ByteBuffer out = ByteBuffer.allocate(name.length()\n                                              + (name.length() + 1) / 2);\n \n         while (cb.remaining() > 0) {\n-            CoderResult res = enc.encode(cb, out,true);\n+            final CoderResult res = enc.encode(cb, out,true);\n \n             if (res.isUnmappable() || res.isMalformed()) {\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/PKWareExtraHeader.java\n      */\n     @Override\n     public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n-        byte[] tmp = new byte[length];\n+        final byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setLocalFileDataData(tmp);\n     }\n      */\n     @Override\n     public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n-        byte[] tmp = new byte[length];\n+        final byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setCentralDirectoryData(tmp);\n         if (localData == null) {\n         private static final Map<Integer, EncryptionAlgorithm> codeToEnum;\n \n         static {\n-            Map<Integer, EncryptionAlgorithm> cte = new HashMap<Integer, EncryptionAlgorithm>();\n-            for (EncryptionAlgorithm method : values()) {\n+            final Map<Integer, EncryptionAlgorithm> cte = new HashMap<Integer, EncryptionAlgorithm>();\n+            for (final EncryptionAlgorithm method : values()) {\n                 cte.put(Integer.valueOf(method.getCode()), method);\n             }\n             codeToEnum = Collections.unmodifiableMap(cte);\n         private static final Map<Integer, HashAlgorithm> codeToEnum;\n \n         static {\n-            Map<Integer, HashAlgorithm> cte = new HashMap<Integer, HashAlgorithm>();\n-            for (HashAlgorithm method : values()) {\n+            final Map<Integer, HashAlgorithm> cte = new HashMap<Integer, HashAlgorithm>();\n+            for (final HashAlgorithm method : values()) {\n                 cte.put(Integer.valueOf(method.getCode()), method);\n             }\n             codeToEnum = Collections.unmodifiableMap(cte);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java\n \n         @Override\n         public ScatterGatherBackingStore get() throws IOException {\n-            File tempFile = File.createTempFile(\"parallelscatter\", \"n\" + storeNum.incrementAndGet());\n+            final File tempFile = File.createTempFile(\"parallelscatter\", \"n\" + storeNum.incrementAndGet());\n             return new FileBasedScatterGatherBackingStore(tempFile);\n         }\n     }\n \n     private ScatterZipOutputStream createDeferred(final ScatterGatherBackingStoreSupplier scatterGatherBackingStoreSupplier)\n             throws IOException {\n-        ScatterGatherBackingStore bs = scatterGatherBackingStoreSupplier.get();\n-        StreamCompressor sc = StreamCompressor.create(Deflater.DEFAULT_COMPRESSION, bs);\n+        final ScatterGatherBackingStore bs = scatterGatherBackingStoreSupplier.get();\n+        final StreamCompressor sc = StreamCompressor.create(Deflater.DEFAULT_COMPRESSION, bs);\n         return new ScatterZipOutputStream(bs, sc);\n     }\n \n         @Override\n         protected ScatterZipOutputStream initialValue() {\n             try {\n-                ScatterZipOutputStream scatterStream = createDeferred(backingStoreSupplier);\n+                final ScatterZipOutputStream scatterStream = createDeferred(backingStoreSupplier);\n                 streams.add(scatterStream);\n                 return scatterStream;\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n                 throw new RuntimeException(e);\n             }\n         }\n             throws IOException, InterruptedException, ExecutionException {\n \n         // Make sure we catch any exceptions from parallel phase\n-        for (Future<?> future : futures) {\n+        for (final Future<?> future : futures) {\n             future.get();\n         }\n \n         // It is important that all threads terminate before we go on, ensure happens-before relationship\n         compressionDoneAt = System.currentTimeMillis();\n \n-        for (ScatterZipOutputStream scatterStream : streams) {\n+        for (final ScatterZipOutputStream scatterStream : streams) {\n             scatterStream.writeTo(targetStream);\n             scatterStream.close();\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java\n          */\n \n         public ZipArchiveEntry transferToArchiveEntry(){\n-            ZipArchiveEntry entry = zipArchiveEntryRequest.getZipArchiveEntry();\n+            final ZipArchiveEntry entry = zipArchiveEntryRequest.getZipArchiveEntry();\n             entry.setCompressedSize(compressedSize);\n             entry.setSize(size);\n             entry.setCrc(crc);\n      */\n     public void writeTo(final ZipArchiveOutputStream target) throws IOException {\n         backingStore.closeForWriting();\n-        InputStream data = backingStore.getInputStream();\n-        for (CompressedEntry compressedEntry : items) {\n+        final InputStream data = backingStore.getInputStream();\n+        for (final CompressedEntry compressedEntry : items) {\n             final BoundedInputStream rawStream = new BoundedInputStream(data, compressedEntry.compressedSize);\n             target.addRawArchiveEntry(compressedEntry.transferToArchiveEntry(), rawStream);\n             rawStream.close();\n      * @throws FileNotFoundException if the file cannot be found\n      */\n     public static ScatterZipOutputStream fileBased(final File file, final int compressionLevel) throws FileNotFoundException {\n-        ScatterGatherBackingStore bs = new FileBasedScatterGatherBackingStore(file);\n-        StreamCompressor sc = StreamCompressor.create(compressionLevel, bs);\n+        final ScatterGatherBackingStore bs = new FileBasedScatterGatherBackingStore(file);\n+        final StreamCompressor sc = StreamCompressor.create(compressionLevel, bs);\n         return new ScatterZipOutputStream(bs, sc);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n         @Override\n         public boolean equals(final Object o) {\n             if (o instanceof Simple8BitChar) {\n-                Simple8BitChar other = (Simple8BitChar) o;\n+                final Simple8BitChar other = (Simple8BitChar) o;\n                 return unicode == other.unicode && code == other.code;\n             }\n             return false;\n      */\n     public Simple8BitZipEncoding(final char[] highChars) {\n         this.highChars = highChars.clone();\n-        List<Simple8BitChar> temp =\n+        final List<Simple8BitChar> temp =\n             new ArrayList<Simple8BitChar>(this.highChars.length);\n \n         byte code = 127;\n \n-        for (char highChar : this.highChars) {\n+        for (final char highChar : this.highChars) {\n             temp.add(new Simple8BitChar(++code, highChar));\n         }\n \n             return true;\n         }\n \n-        Simple8BitChar r = this.encodeHighChar(c);\n+        final Simple8BitChar r = this.encodeHighChar(c);\n         return r != null;\n     }\n \n             return true;\n         }\n \n-        Simple8BitChar r = this.encodeHighChar(c);\n+        final Simple8BitChar r = this.encodeHighChar(c);\n         if (r == null) {\n             return false;\n         }\n \n         while (i1 > i0) {\n \n-            int i = i0 + (i1 - i0) / 2;\n-\n-            Simple8BitChar m = this.reverseMapping.get(i);\n+            final int i = i0 + (i1 - i0) / 2;\n+\n+            final Simple8BitChar m = this.reverseMapping.get(i);\n \n             if (m.unicode == c) {\n                 return m;\n             return null;\n         }\n \n-        Simple8BitChar r = this.reverseMapping.get(i0);\n+        final Simple8BitChar r = this.reverseMapping.get(i0);\n \n         if (r.unicode != c) {\n             return null;\n \n         for (int i=0;i<name.length();++i) {\n \n-            char c = name.charAt(i);\n+            final char c = name.charAt(i);\n \n             if (!this.canEncodeChar(c)) {\n                 return false;\n \n         for (int i=0;i<name.length();++i) {\n \n-            char c = name.charAt(i);\n+            final char c = name.charAt(i);\n \n             if (out.remaining() < 6) {\n                 out = ZipEncodingHelper.growBuffer(out,out.position() + 6);\n      */\n     @Override\n     public String decode(final byte[] data) throws IOException {\n-        char [] ret = new char[data.length];\n+        final char [] ret = new char[data.length];\n \n         for (int i=0;i<data.length;++i) {\n             ret[i] = this.decodeByte(data[i]);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/StreamCompressor.java\n      * @throws IOException on error\n      */\n     long write(final byte[] b, final int offset, final int length, final int method) throws IOException {\n-        long current = writtenToOutputStreamForLastEntry;\n+        final long current = writtenToOutputStreamForLastEntry;\n         crc.update(b, offset, length);\n         if (method == ZipEntry.DEFLATED) {\n             writeDeflated(b, offset, length);\n     }\n \n     void deflate() throws IOException {\n-        int len = def.deflate(outputBuffer, 0, outputBuffer.length);\n+        final int len = def.deflate(outputBuffer, 0, outputBuffer.length);\n         if (len > 0) {\n             writeCounted(outputBuffer, 0, len);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n      */\n     @Override\n     public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n-        byte[] tmp = new byte[length];\n+        final byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setLocalFileDataData(tmp);\n     }\n     @Override\n     public void parseFromCentralDirectoryData(final byte[] data, final int offset,\n                                               final int length) {\n-        byte[] tmp = new byte[length];\n+        final byte[] tmp = new byte[length];\n         System.arraycopy(data, offset, tmp, 0, length);\n         setCentralDirectoryData(tmp);\n         if (localData == null) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnshrinkingInputStream.java\n             tableSize++;\n         }\n         setTableSize(tableSize);\n-        int idx = addEntry(previousCode, character, MAX_TABLE_SIZE);\n+        final int idx = addEntry(previousCode, character, MAX_TABLE_SIZE);\n         if (idx >= 0) {\n             isUsed[idx] = true;\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X000A_NTFS.java\n      */\n     @Override\n     public byte[] getLocalFileDataData() {\n-        byte[] data = new byte[getLocalFileDataLength().getValue()];\n+        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n         int pos = 4;\n         System.arraycopy(TIME_ATTR_TAG.getBytes(), 0, data, pos, 2);\n         pos += 2;\n         offset += 4;\n \n         while (offset + 4 <= len) {\n-            ZipShort tag = new ZipShort(data, offset);\n+            final ZipShort tag = new ZipShort(data, offset);\n             offset += 2;\n             if (tag.equals(TIME_ATTR_TAG)) {\n                 readTimeAttr(data, offset, len - offset);\n                 break;\n             }\n-            ZipShort size = new ZipShort(data, offset);\n+            final ZipShort size = new ZipShort(data, offset);\n             offset += 2 + size.getValue();\n         }\n     }\n      */\n     @Override\n     public String toString() {\n-        StringBuilder buf = new StringBuilder();\n+        final StringBuilder buf = new StringBuilder();\n         buf.append(\"0x000A Zip Extra Field:\")\n             .append(\" Modify:[\").append(getModifyJavaTime()).append(\"] \")\n             .append(\" Access:[\").append(getAccessJavaTime()).append(\"] \")\n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof X000A_NTFS) {\n-            X000A_NTFS xf = (X000A_NTFS) o;\n+            final X000A_NTFS xf = (X000A_NTFS) o;\n \n             return (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                     (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n \n     private void readTimeAttr(final byte[] data, int offset, final int length) {\n         if (length >= 2 + 3 * 8) {\n-            ZipShort tagValueLength = new ZipShort(data, offset);\n+            final ZipShort tagValueLength = new ZipShort(data, offset);\n             if (TIME_ATTR_SIZE.equals(tagValueLength)) {\n                 offset += 2;\n                 modifyTime = new ZipEightByteInteger(data, offset);\n \n     private static Date zipToDate(final ZipEightByteInteger z) {\n         if (z == null || ZipEightByteInteger.ZERO.equals(z)) { return null; }\n-        long l = (z.getLongValue() + EPOCH_OFFSET) / 10000l;\n+        final long l = (z.getLongValue() + EPOCH_OFFSET) / 10000l;\n         return new Date(l);\n     }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java\n      * @param length the length of data\n      */\n     public void parseFileFormat(final byte[] data, final int offset, final int length) {\n-        int ivSize = ZipShort.getValue(data, offset);\n+        final int ivSize = ZipShort.getValue(data, offset);\n         this.ivData = new byte[ivSize];\n         System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n \n         this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n         this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n \n-        int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n+        final int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n         this.erdData = new byte[erdSize];\n         System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n \n         this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n         System.out.println(\"rcount: \" + rcount);\n         if (rcount == 0) {\n-            int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n+            final int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n             this.vData = new byte[vSize - 4];\n             this.vCRC32 = new byte[4];\n             System.arraycopy(data, offset + ivSize + 22 + erdSize , this.vData, 0, vSize - 4);\n         } else {\n             this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n             this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n-            int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n+            final int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n             this.recipientKeyHash = new byte[this.hashSize];\n             this.keyBlob = new byte[resize - this.hashSize];\n             System.arraycopy(data, offset + ivSize + 24 + erdSize, this.recipientKeyHash, 0, this.hashSize);\n             System.arraycopy(data, offset + ivSize + 24 + erdSize + this.hashSize, this.keyBlob, 0, resize - this.hashSize);\n \n-            int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n+            final int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n             this.vData = new byte[vSize - 4];\n             this.vCRC32 = new byte[4];\n             System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n      */\n     @Override\n     public byte[] getLocalFileDataData() {\n-        byte[] data = new byte[getLocalFileDataLength().getValue()];\n+        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n         int pos = 0;\n         data[pos++] = 0;\n         if (bit0_modifyTimePresent) {\n      */\n     @Override\n     public byte[] getCentralDirectoryData() {\n-        byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n-        byte[] localData = getLocalFileDataData();\n+        final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n+        final byte[] localData = getLocalFileDataData();\n \n         // Truncate out create & access time (last 8 bytes) from\n         // the copy of the local data we obtained:\n      */\n     @Override\n     public String toString() {\n-        StringBuilder buf = new StringBuilder();\n+        final StringBuilder buf = new StringBuilder();\n         buf.append(\"0x5455 Zip Extra Field: Flags=\");\n         buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\n         if (bit0_modifyTimePresent && modifyTime != null) {\n-            Date m = getModifyJavaTime();\n+            final Date m = getModifyJavaTime();\n             buf.append(\" Modify:[\").append(m).append(\"] \");\n         }\n         if (bit1_accessTimePresent && accessTime != null) {\n-            Date a = getAccessJavaTime();\n+            final Date a = getAccessJavaTime();\n             buf.append(\" Access:[\").append(a).append(\"] \");\n         }\n         if (bit2_createTimePresent && createTime != null) {\n-            Date c = getCreateJavaTime();\n+            final Date c = getCreateJavaTime();\n             buf.append(\" Create:[\").append(c).append(\"] \");\n         }\n         return buf.toString();\n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof X5455_ExtendedTimestamp) {\n-            X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n+            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n \n             // The ZipLong==ZipLong clauses handle the cases where both are null.\n             // and only last 3 bits of flags matter.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n      */\n     @Override\n     public ZipShort getLocalFileDataLength() {\n-        int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n-        int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n+        final int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n+        final int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n \n         // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n         return new ZipShort(3 + uidSize + gidSize);\n         // optimization is the root of all...\n         //\n         // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n-        byte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n+        final byte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n \n         // reverse() switches byte array from big-endian to little-endian.\n         reverse(uidBytes);\n     ) throws ZipException {\n         reset();\n         this.version = signedByteToUnsignedInt(data[offset++]);\n-        int uidSize = signedByteToUnsignedInt(data[offset++]);\n-        byte[] uidBytes = new byte[uidSize];\n+        final int uidSize = signedByteToUnsignedInt(data[offset++]);\n+        final byte[] uidBytes = new byte[uidSize];\n         System.arraycopy(data, offset, uidBytes, 0, uidSize);\n         offset += uidSize;\n         this.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n \n-        int gidSize = signedByteToUnsignedInt(data[offset++]);\n-        byte[] gidBytes = new byte[gidSize];\n+        final int gidSize = signedByteToUnsignedInt(data[offset++]);\n+        final byte[] gidBytes = new byte[gidSize];\n         System.arraycopy(data, offset, gidBytes, 0, gidSize);\n         this.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n     }\n     @Override\n     public boolean equals(final Object o) {\n         if (o instanceof X7875_NewUnix) {\n-            X7875_NewUnix xf = (X7875_NewUnix) o;\n+            final X7875_NewUnix xf = (X7875_NewUnix) o;\n             // We assume uid and gid can never be null.\n             return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);\n         }\n         }\n \n         int pos = 0;\n-        for (byte b : array) {\n+        for (final byte b : array) {\n             if (b == 0) {\n                 pos++;\n             } else {\n         */\n         final int MIN_LENGTH = 1;\n \n-        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n-        int startPos = trimmedArray.length - (array.length - pos);\n+        final byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n+        final int startPos = trimmedArray.length - (array.length - pos);\n         System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n         return trimmedArray;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n             if (size == null || compressedSize == null) {\n                 throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n             }\n-            byte[] data = new byte[2 * DWORD];\n+            final byte[] data = new byte[2 * DWORD];\n             addSizes(data);\n             return data;\n         }\n \n     @Override\n     public byte[] getCentralDirectoryData() {\n-        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n+        final byte[] data = new byte[getCentralDirectoryLength().getValue()];\n         int off = addSizes(data);\n         if (relativeHeaderOffset != null) {\n             System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n                                             final boolean hasDiskStart)\n         throws ZipException {\n         if (rawCentralDirectoryData != null) {\n-            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n+            final int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                 + (hasCompressedSize ? DWORD : 0)\n                 + (hasRelativeHeaderOffset ? DWORD : 0)\n                 + (hasDiskStart ? WORD : 0);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n     public ZipArchiveEntry(final java.util.zip.ZipEntry entry) throws ZipException {\n         super(entry);\n         setName(entry.getName());\n-        byte[] extra = entry.getExtra();\n+        final byte[] extra = entry.getExtra();\n         if (extra != null) {\n             setExtraFields(ExtraFieldUtils.parse(extra, true,\n                                                  ExtraFieldUtils\n         setExternalAttributes(entry.getExternalAttributes());\n         setExtraFields(getAllExtraFieldsNoCopy());\n         setPlatform(entry.getPlatform());\n-        GeneralPurposeBit other = entry.getGeneralPurposeBit();\n+        final GeneralPurposeBit other = entry.getGeneralPurposeBit();\n         setGeneralPurposeBit(other == null ? null :\n                              (GeneralPurposeBit) other.clone());\n     }\n      */\n     @Override\n     public Object clone() {\n-        ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n+        final ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n \n         e.setInternalAttributes(getInternalAttributes());\n         e.setExternalAttributes(getExternalAttributes());\n      * @param fields an array of extra fields\n      */\n     public void setExtraFields(final ZipExtraField[] fields) {\n-        List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();\n-        for (ZipExtraField field : fields) {\n+        final List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();\n+        for (final ZipExtraField field : fields) {\n             if (field instanceof UnparseableExtraFieldData) {\n                 unparseableExtra = (UnparseableExtraFieldData) field;\n             } else {\n     }\n \n     private ZipExtraField[] copyOf(final ZipExtraField[] src, final int length) {\n-        ZipExtraField[] cpy = new ZipExtraField[length];\n+        final ZipExtraField[] cpy = new ZipExtraField[length];\n         System.arraycopy(src, 0, cpy, 0, Math.min(src.length, length));\n         return cpy;\n     }\n             if (getExtraField(ze.getHeaderId()) != null){\n                 removeExtraField(ze.getHeaderId());\n             }\n-            ZipExtraField[] copy = extraFields;\n-            int newLen = extraFields != null ? extraFields.length + 1: 1;\n+            final ZipExtraField[] copy = extraFields;\n+            final int newLen = extraFields != null ? extraFields.length + 1: 1;\n             extraFields = new ZipExtraField[newLen];\n             extraFields[0] = ze;\n             if (copy != null){\n             throw new java.util.NoSuchElementException();\n         }\n \n-        List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();\n-        for (ZipExtraField extraField : extraFields) {\n+        final List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();\n+        for (final ZipExtraField extraField : extraFields) {\n             if (!type.equals(extraField.getHeaderId())){\n                 newResult.add( extraField);\n             }\n      */\n     public ZipExtraField getExtraField(final ZipShort type) {\n         if (extraFields != null) {\n-            for (ZipExtraField extraField : extraFields) {\n+            for (final ZipExtraField extraField : extraFields) {\n                 if (type.equals(extraField.getHeaderId())) {\n                     return extraField;\n                 }\n     @Override\n     public void setExtra(final byte[] extra) throws RuntimeException {\n         try {\n-            ZipExtraField[] local =\n+            final ZipExtraField[] local =\n                 ExtraFieldUtils.parse(extra, true,\n                                       ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(local, true);\n-        } catch (ZipException e) {\n+        } catch (final ZipException e) {\n             // actually this is not possible as of Commons Compress 1.1\n             throw new RuntimeException(\"Error parsing extra fields for entry: \"\n                                        + getName() + \" - \" + e.getMessage(), e);\n      */\n     public void setCentralDirectoryExtra(final byte[] b) {\n         try {\n-            ZipExtraField[] central =\n+            final ZipExtraField[] central =\n                 ExtraFieldUtils.parse(b, false,\n                                       ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(central, false);\n-        } catch (ZipException e) {\n+        } catch (final ZipException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n     }\n      * @return the extra data for local file\n      */\n     public byte[] getLocalFileDataExtra() {\n-        byte[] extra = getExtra();\n+        final byte[] extra = getExtra();\n         return extra != null ? extra : EMPTY;\n     }\n \n      */\n     public byte[] getRawName() {\n         if (rawName != null) {\n-            byte[] b = new byte[rawName.length];\n+            final byte[] b = new byte[rawName.length];\n             System.arraycopy(rawName, 0, b, 0, rawName.length);\n             return b;\n         }\n         if (extraFields == null) {\n             setExtraFields(f);\n         } else {\n-            for (ZipExtraField element : f) {\n+            for (final ZipExtraField element : f) {\n                 ZipExtraField existing;\n                 if (element instanceof UnparseableExtraFieldData) {\n                     existing = unparseableExtra;\n                     addExtraField(element);\n                 } else {\n                     if (local) {\n-                        byte[] b = element.getLocalFileDataData();\n+                        final byte[] b = element.getLocalFileDataData();\n                         existing.parseFromLocalFileData(b, 0, b.length);\n                     } else {\n-                        byte[] b = element.getCentralDirectoryData();\n+                        final byte[] b = element.getCentralDirectoryData();\n                         existing.parseFromCentralDirectoryData(b, 0, b.length);\n                     }\n                 }\n         if (obj == null || getClass() != obj.getClass()) {\n             return false;\n         }\n-        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n-        String myName = getName();\n-        String otherName = other.getName();\n+        final ZipArchiveEntry other = (ZipArchiveEntry) obj;\n+        final String myName = getName();\n+        final String otherName = other.getName();\n         if (myName == null) {\n             if (otherName != null) {\n                 return false;\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n             } else {\n                 readFully(LFH_BUF);\n             }\n-        } catch (EOFException e) {\n+        } catch (final EOFException e) {\n             return null;\n         }\n \n-        ZipLong sig = new ZipLong(LFH_BUF);\n+        final ZipLong sig = new ZipLong(LFH_BUF);\n         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n             hitCentralDirectory = true;\n             skipRemainderOfArchive();\n         int off = WORD;\n         current = new CurrentEntry();\n \n-        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n+        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n         off += SHORT;\n         current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n \n         current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n         off += SHORT;\n \n-        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n+        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n         current.entry.setTime(time);\n         off += WORD;\n \n             off += 3 * WORD;\n         }\n \n-        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n+        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n \n         off += SHORT;\n \n-        int extraLen = ZipShort.getValue(LFH_BUF, off);\n+        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n         off += SHORT;\n \n-        byte[] fileName = new byte[fileNameLen];\n+        final byte[] fileName = new byte[fileNameLen];\n         readFully(fileName);\n         current.entry.setName(entryEncoding.decode(fileName), fileName);\n \n-        byte[] extraData = new byte[extraLen];\n+        final byte[] extraData = new byte[extraLen];\n         readFully(extraData);\n         current.entry.setExtra(extraData);\n \n      */\n     private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\n         readFully(lfh);\n-        ZipLong sig = new ZipLong(lfh);\n+        final ZipLong sig = new ZipLong(lfh);\n         if (sig.equals(ZipLong.DD_SIG)) {\n             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n         }\n         if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n             // The archive is not really split as only one segment was\n             // needed in the end.  Just skip over the marker.\n-            byte[] missedLfhBytes = new byte[4];\n+            final byte[] missedLfhBytes = new byte[4];\n             readFully(missedLfhBytes);\n             System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n             System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n      * doesn't use a data descriptor.\n      */\n     private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n-        Zip64ExtendedInformationExtraField z64 =\n+        final Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField) \n             current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         current.usesZip64 = z64 != null;\n     @Override\n     public boolean canReadEntryData(final ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n-            ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n+            final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n             return ZipUtil.canHandleEntryData(ze)\n                 && supportsDataDescriptorFor(ze);\n \n             return lastStoredEntry.read(buffer, offset, length);\n         }\n \n-        long csize = current.entry.getSize();\n+        final long csize = current.entry.getSize();\n         if (current.bytesRead >= csize) {\n             return -1;\n         }\n \n         if (buf.position() >= buf.limit()) {\n             buf.position(0);\n-            int l = in.read(buf.array());\n+            final int l = in.read(buf.array());\n             if (l == -1) {\n                 return -1;\n             }\n      * Implementation of read for DEFLATED entries.\n      */\n     private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n-        int read = readFromInflater(buffer, offset, length);\n+        final int read = readFromInflater(buffer, offset, length);\n         if (read <= 0) {\n             if (inf.finished()) {\n                 return -1;\n         int read = 0;\n         do {\n             if (inf.needsInput()) {\n-                int l = fill();\n+                final int l = fill();\n                 if (l > 0) {\n                     current.bytesReadFromStream += buf.limit();\n                 } else if (l == -1) {\n             }\n             try {\n                 read = inf.inflate(buffer, offset, length);\n-            } catch (DataFormatException e) {\n+            } catch (final DataFormatException e) {\n                 throw (IOException) new ZipException(e.getMessage()).initCause(e);\n             }\n         } while (read == 0 && inf.needsInput());\n         if (value >= 0) {\n             long skipped = 0;\n             while (skipped < value) {\n-                long rem = value - skipped;\n-                int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n+                final long rem = value - skipped;\n+                final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                 if (x == -1) {\n                     return skipped;\n                 }\n         } else {\n             skip(Long.MAX_VALUE);\n \n-            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n+            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                        ? getBytesInflated() : current.bytesRead;\n \n             // this is at most a single read() operation and can't\n             // exceed the range of int\n-            int diff = (int) (current.bytesReadFromStream - inB);\n+            final int diff = (int) (current.bytesReadFromStream - inB);\n \n             // Pushback any required bytes\n             if (diff > 0) {\n     private void drainCurrentEntryData() throws IOException {\n         long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n         while (remaining > 0) {\n-            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n+            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n                 throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n             }\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        int length = in.read(buf.array());\n+        final int length = in.read(buf.array());\n         if (length > 0) {\n             buf.limit(length);\n             count(buf.limit());\n     }\n \n     private void readFully(final byte[] b) throws IOException {\n-        int count = IOUtils.readFully(in, b);\n+        final int count = IOUtils.readFully(in, b);\n         count(count);\n         if (count < b.length) {\n             throw new EOFException();\n         // If so, push back eight bytes and assume sizes are four\n         // bytes, otherwise sizes are eight bytes each.\n         readFully(TWO_DWORD_BUF);\n-        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n+        final ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n         if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n             pushback(TWO_DWORD_BUF, DWORD, DWORD);\n             current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n      * next local file or central directory header.</p>\n      */\n     private void readStoredEntry() throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int off = 0;\n         boolean done = false;\n \n         // length of DD without signature\n-        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n+        final int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n \n         while (!done) {\n-            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n+            final int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                 // read the whole archive without ever finding a\n                 // central directory\n             }\n         }\n \n-        byte[] b = bos.toByteArray();\n+        final byte[] b = bos.toByteArray();\n         lastStoredEntry = new ByteArrayInputStream(b);\n     }\n \n         if (value >= 0) {\n             long skipped = 0;\n             while (skipped < value) {\n-                long rem = value - skipped;\n-                int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n+                final long rem = value - skipped;\n+                final int x = in.read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length));\n                 if (x == -1) {\n                     return;\n                 }\n      * Also updates bytes-read counter.\n      */\n     private int readOneByte() throws IOException {\n-        int b = in.read();\n+        final int b = in.read();\n         if (b != -1) {\n             count(1);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n         try {\n             _raf = new RandomAccessFile(file, \"rw\");\n             _raf.setLength(0);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             IOUtils.closeQuietly(_raf);\n             _raf = null;\n             o = new FileOutputStream(file);\n     }\n \n     private void writeCentralDirectoryInChunks() throws IOException {\n-        int NUM_PER_WRITE = 1000;\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\n+        final int NUM_PER_WRITE = 1000;\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\n         int count = 0;\n-        for (ZipArchiveEntry ze : entries) {\n+        for (final ZipArchiveEntry ze : entries) {\n             byteArrayOutputStream.write(createCentralFileHeader(ze));\n             if (++count > NUM_PER_WRITE){\n                 writeCounted(byteArrayOutputStream.toByteArray());\n \n         flushDeflater();\n \n-        long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n-        long realCrc = streamCompressor.getCrc32();\n+        final long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\n+        final long realCrc = streamCompressor.getCrc32();\n         entry.bytesRead = streamCompressor.getBytesRead();\n         final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n         final boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\n     private void closeCopiedEntry(final boolean phased) throws IOException {\n         preClose();\n         entry.bytesRead = entry.entry.getSize();\n-        Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n-        boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n+        final Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\n+        final boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\n         closeEntry(actuallyNeedsZip64, phased);\n     }\n \n      */\n     public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\n             throws IOException {\n-        ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n+        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n         if (hasZip64Extra(ae)) {\n             // Will be re-added as required. this may make the file generated with this method\n             // somewhat smaller than standard mode,\n             // since standard mode is unable to remove the zip 64 header.\n             ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         }\n-        boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n+        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n                 && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n                 && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;\n         putArchiveEntry(ae, is2PhaseSource);\n      */\n     private void rewriteSizesAndCrc(final boolean actuallyNeedsZip64)\n         throws IOException {\n-        long save = raf.getFilePointer();\n+        final long save = raf.getFilePointer();\n \n         raf.seek(entry.localDataStart);\n         writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n         }\n \n         if (hasZip64Extra(entry.entry)) {\n-            ByteBuffer name = getName(entry.entry);\n-            int nameLen = name.limit() - name.position();\n+            final ByteBuffer name = getName(entry.entry);\n+            final int nameLen = name.limit() - name.position();\n             // seek to ZIP64 extra, skip header and size information\n             raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                      + nameLen + 2 * SHORT);\n \n         if (shouldAddZip64Extra(entry.entry, effectiveMode)) {\n \n-            Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n+            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(entry.entry);\n \n             // just a placeholder, real data will be in data\n             // descriptor or inserted later via RandomAccessFile\n     @Override\n     public boolean canWriteEntryData(final ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n-            ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n+            final ZipArchiveEntry zae = (ZipArchiveEntry) ae;\n             return zae.getMethod() != ZipMethod.IMPLODING.getCode()\n                 && zae.getMethod() != ZipMethod.UNSHRINKING.getCode()\n                 && ZipUtil.canHandleEntryData(zae);\n             throw new IllegalStateException(\"No current entry\");\n         }\n         ZipUtil.checkRequestedFeatures(entry.entry);\n-        long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\n+        final long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\n         count(writtenThisTime);\n     }\n \n     }\n \n     private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n-        boolean encodable = zipEncoding.canEncode(ze.getName());\n-        ByteBuffer name = getName(ze);\n+        final boolean encodable = zipEncoding.canEncode(ze.getName());\n+        final ByteBuffer name = getName(ze);\n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n             addUnicodeExtraFields(ze, encodable, name);\n         }\n \n         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased);\n-        long localHeaderStart = streamCompressor.getTotalBytesWritten();\n+        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n         offsets.put(ze, localHeaderStart);\n         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n         writeCounted(localHeader);\n \n     private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                          final boolean phased)  {\n-        byte[] extra = ze.getLocalFileDataExtra();\n+        final byte[] extra = ze.getLocalFileDataExtra();\n         final int nameLen = name.limit() - name.position();\n-        int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n-        byte[] buf = new byte[len];\n+        final int len= LFH_FILENAME_OFFSET + nameLen + extra.length;\n+        final byte[] buf = new byte[len];\n \n         System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n \n             putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n         }\n \n-        GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n+        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8);\n         generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n \n         // compression method\n                                                        - name.position()));\n         }\n \n-        String comm = ze.getComment();\n+        final String comm = ze.getComment();\n         if (comm != null && !\"\".equals(comm)) {\n \n-            boolean commentEncodable = zipEncoding.canEncode(comm);\n+            final boolean commentEncodable = zipEncoding.canEncode(comm);\n \n             if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                 || !commentEncodable) {\n-                ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n+                final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n                 ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                               commentB.array(),\n                                                               commentB.arrayOffset(),\n      * Zip64Mode#Never}.\n      */\n     protected void writeCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\n-        byte[] centralFileHeader = createCentralFileHeader(ze);\n+        final byte[] centralFileHeader = createCentralFileHeader(ze);\n         writeCounted(centralFileHeader);\n     }\n \n      */\n     private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final long lfhOffset,\n                                            final boolean needsZip64Extra) throws IOException {\n-        byte[] extra = ze.getCentralDirectoryExtra();\n+        final byte[] extra = ze.getCentralDirectoryExtra();\n \n         // file comment length\n         String comm = ze.getComment();\n             comm = \"\";\n         }\n \n-        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n+        final ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\n         final int nameLen = name.limit() - name.position();\n         final int commentLen = commentB.limit() - commentB.position();\n-        int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n-        byte[] buf = new byte[len];\n+        final int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\n+        final byte[] buf = new byte[len];\n \n         System.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\n \n         // file name\n         System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\n \n-        int extraStart = CFH_FILENAME_OFFSET + nameLen;\n+        final int extraStart = CFH_FILENAME_OFFSET + nameLen;\n         System.arraycopy(extra, 0, buf, extraStart, extra.length);\n \n-        int commentStart = extraStart + extra.length;\n+        final int commentStart = extraStart + extra.length;\n \n         // file comment\n         System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\n     private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset,\n                                   final boolean needsZip64Extra) {\n         if (needsZip64Extra) {\n-            Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n+            final Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);\n             if (ze.getCompressedSize() >= ZIP64_MAGIC\n                 || ze.getSize() >= ZIP64_MAGIC\n                 || zip64Mode == Zip64Mode.Always) {\n         writeCounted(ZERO);\n \n         // number of entries\n-        int numberOfEntries = entries.size();\n+        final int numberOfEntries = entries.size();\n         if (numberOfEntries > ZIP64_MAGIC_SHORT\n             && zip64Mode == Zip64Mode.Never) {\n             throw new Zip64RequiredException(Zip64RequiredException\n                                              .ARCHIVE_TOO_BIG_MESSAGE);\n         }\n \n-        byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n+        final byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\n                                                 ZIP64_MAGIC_SHORT));\n         writeCounted(num);\n         writeCounted(num);\n         writeCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\n \n         // ZIP file comment\n-        ByteBuffer data = this.zipEncoding.encode(comment);\n-        int dataLen = data.limit() - data.position();\n+        final ByteBuffer data = this.zipEncoding.encode(comment);\n+        final int dataLen = data.limit() - data.position();\n         writeCounted(ZipShort.getBytes(dataLen));\n         streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n     }\n             return;\n         }\n \n-        long offset = streamCompressor.getTotalBytesWritten();\n+        final long offset = streamCompressor.getTotalBytesWritten();\n \n         writeOut(ZIP64_EOCD_SIG);\n         // size, we don't have any variable length as we don't support\n         writeOut(LZERO);\n \n         // number of entries\n-        byte[] num = ZipEightByteInteger.getBytes(entries.size());\n+        final byte[] num = ZipEightByteInteger.getBytes(entries.size());\n         writeOut(num);\n         writeOut(num);\n \n \n \n     private GeneralPurposeBit getGeneralPurposeBits(final int zipMethod, final boolean utfFallback) {\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useUTF8ForNames(useUTF8Flag || utfFallback);\n         if (isDeflatedToOutputStream(zipMethod)) {\n             b.useDataDescriptor(true);\n     }\n \n     private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n-        boolean encodable = zipEncoding.canEncode(ze.getName());\n+        final boolean encodable = zipEncoding.canEncode(ze.getName());\n         return !encodable && fallbackToUTF8\n             ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEightByteInteger.java\n      * @return value as eight bytes in big endian byte order\n      */\n     public static byte[] getBytes(final BigInteger value) {\n-        byte[] result = new byte[8];\n-        long val = value.longValue();\n+        final byte[] result = new byte[8];\n+        final long val = value.longValue();\n         result[0] = (byte) ((val & BYTE_MASK));\n         result[BYTE_1] = (byte) ((val & BYTE_1_MASK) >> BYTE_1_SHIFT);\n         result[BYTE_2] = (byte) ((val & BYTE_2_MASK) >> BYTE_2_SHIFT);\n         value += ((long) bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\n         value += ((long) bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\n         value += ((long) bytes[offset] & BYTE_MASK);\n-        BigInteger val = BigInteger.valueOf(value);\n+        final BigInteger val = BigInteger.valueOf(value);\n         return (bytes[offset + BYTE_7] & LEFTMOST_BIT) == LEFTMOST_BIT\n             ? val.setBit(LEFTMOST_BIT_SHIFT) : val;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n     private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n \n     static {\n-        Map<String, SimpleEncodingHolder> se =\n+        final Map<String, SimpleEncodingHolder> se =\n             new HashMap<String, SimpleEncodingHolder>();\n \n-        char[] cp437_high_chars =\n+        final char[] cp437_high_chars =\n             new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n                          0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n                          0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n                          0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n                          0x25a0, 0x00a0 };\n \n-        SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n+        final SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n \n         se.put(\"CP437\", cp437);\n         se.put(\"Cp437\", cp437);\n         se.put(\"IBM437\", cp437);\n         se.put(\"ibm437\", cp437);\n \n-        char[] cp850_high_chars =\n+        final char[] cp850_high_chars =\n             new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n                          0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n                          0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n                          0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n                          0x25a0, 0x00a0 };\n \n-        SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n+        final SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n \n         se.put(\"CP850\", cp850);\n         se.put(\"Cp850\", cp850);\n         b.limit(b.position());\n         b.rewind();\n \n-        int c2 = b.capacity() * 2;\n-        ByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n+        final int c2 = b.capacity() * 2;\n+        final ByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n \n         on.put(b);\n         return on;\n             return new FallbackZipEncoding();\n         }\n \n-        SimpleEncodingHolder h = simpleEncodings.get(name);\n+        final SimpleEncodingHolder h = simpleEncodings.get(name);\n \n         if (h!=null) {\n             return h.getEncoding();\n \n         try {\n \n-            Charset cs = Charset.forName(name);\n+            final Charset cs = Charset.forName(name);\n             return new NioZipEncoding(cs);\n \n-        } catch (UnsupportedCharsetException e) {\n+        } catch (final UnsupportedCharsetException e) {\n             return new FallbackZipEncoding(name);\n         }\n     }\n         if (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\n             return true;\n         }\n-        for (String alias : Charsets.UTF_8.aliases()) {\n+        for (final String alias : Charsets.UTF_8.aliases()) {\n             if (alias.equalsIgnoreCase(charsetName)) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n         archive = new RandomAccessFile(f, \"r\");\n         boolean success = false;\n         try {\n-            Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n+            final Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                 populateFromCentralDirectory();\n             resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n             success = true;\n      * @since 1.1\n      */\n     public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n-        ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n+        final ZipArchiveEntry[] allEntries = entries.toArray(new ZipArchiveEntry[entries.size()]);\n         Arrays.sort(allEntries, OFFSET_COMPARATOR);\n         return Collections.enumeration(Arrays.asList(allEntries));\n     }\n      * {@code null} if not present.\n      */\n     public ZipArchiveEntry getEntry(final String name) {\n-        LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        final LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n         return entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n     }\n \n      * @since 1.6\n      */\n     public Iterable<ZipArchiveEntry> getEntries(final String name) {\n-        List<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n+        final List<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n         return entriesOfThatName != null ? entriesOfThatName\n             : Collections.<ZipArchiveEntry>emptyList();\n     }\n         if (!(ze instanceof Entry)) {\n             return null;\n         }\n-        OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n-        long start = offsetEntry.dataOffset;\n+        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n+        final long start = offsetEntry.dataOffset;\n         return new BoundedInputStream(start, ze.getCompressedSize());\n     }\n \n      */\n     public void copyRawEntries(final ZipArchiveOutputStream target, final ZipArchiveEntryPredicate predicate)\n             throws IOException {\n-        Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();\n+        final Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();\n         while (src.hasMoreElements()) {\n-            ZipArchiveEntry entry = src.nextElement();\n+            final ZipArchiveEntry entry = src.nextElement();\n             if (predicate.test( entry)) {\n                 target.addRawArchiveEntry(entry, getRawInputStream(entry));\n             }\n             return null;\n         }\n         // cast valididty is checked just above\n-        OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n+        final OffsetEntry offsetEntry = ((Entry) ze).getOffsetEntry();\n         ZipUtil.checkRequestedFeatures(ze);\n-        long start = offsetEntry.dataOffset;\n-        BoundedInputStream bis =\n+        final long start = offsetEntry.dataOffset;\n+        final BoundedInputStream bis =\n             new BoundedInputStream(start, ze.getCompressedSize());\n         switch (ZipMethod.getMethodByCode(ze.getMethod())) {\n             case STORED:\n             InputStream in = null;\n             try {\n                 in = getInputStream(entry);\n-                byte[] symlinkBytes = IOUtils.toByteArray(in);\n+                final byte[] symlinkBytes = IOUtils.toByteArray(in);\n                 return zipEncoding.decode(symlinkBytes);\n             } finally {\n                 if (in != null) {\n      */\n     private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n         throws IOException {\n-        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n+        final HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n             new HashMap<ZipArchiveEntry, NameAndComment>();\n \n         positionAtCentralDirectory();\n         throws IOException {\n         archive.readFully(CFH_BUF);\n         int off = 0;\n-        OffsetEntry offset = new OffsetEntry();\n-        Entry ze = new Entry(offset);\n-\n-        int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n+        final OffsetEntry offset = new OffsetEntry();\n+        final Entry ze = new Entry(offset);\n+\n+        final int versionMadeBy = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n         ze.setVersionMadeBy(versionMadeBy);\n         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n         ze.setMethod(ZipShort.getValue(CFH_BUF, off));\n         off += SHORT;\n \n-        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n+        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(CFH_BUF, off));\n         ze.setTime(time);\n         off += WORD;\n \n         ze.setSize(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n-        int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n+        final int fileNameLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int extraLen = ZipShort.getValue(CFH_BUF, off);\n+        final int extraLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int commentLen = ZipShort.getValue(CFH_BUF, off);\n+        final int commentLen = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n-        int diskStart = ZipShort.getValue(CFH_BUF, off);\n+        final int diskStart = ZipShort.getValue(CFH_BUF, off);\n         off += SHORT;\n \n         ze.setInternalAttributes(ZipShort.getValue(CFH_BUF, off));\n         ze.setExternalAttributes(ZipLong.getValue(CFH_BUF, off));\n         off += WORD;\n \n-        byte[] fileName = new byte[fileNameLen];\n+        final byte[] fileName = new byte[fileNameLen];\n         archive.readFully(fileName);\n         ze.setName(entryEncoding.decode(fileName), fileName);\n \n         // data offset will be filled later\n         entries.add(ze);\n \n-        byte[] cdExtraData = new byte[extraLen];\n+        final byte[] cdExtraData = new byte[extraLen];\n         archive.readFully(cdExtraData);\n         ze.setCentralDirectoryExtra(cdExtraData);\n \n         setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n \n-        byte[] comment = new byte[commentLen];\n+        final byte[] comment = new byte[commentLen];\n         archive.readFully(comment);\n         ze.setComment(entryEncoding.decode(comment));\n \n                                                  final OffsetEntry offset,\n                                                  final int diskStart)\n         throws IOException {\n-        Zip64ExtendedInformationExtraField z64 =\n+        final Zip64ExtendedInformationExtraField z64 =\n             (Zip64ExtendedInformationExtraField)\n             ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n         if (z64 != null) {\n-            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n-            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n-            boolean hasRelativeHeaderOffset =\n+            final boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n+            final boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n+            final boolean hasRelativeHeaderOffset =\n                 offset.headerOffset == ZIP64_MAGIC;\n             z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                             hasCompressedSize,\n         throws IOException {\n         positionAtEndOfCentralDirectoryRecord();\n         boolean found = false;\n-        boolean searchedForZip64EOCD =\n+        final boolean searchedForZip64EOCD =\n             archive.getFilePointer() > ZIP64_EOCDL_LENGTH;\n         if (searchedForZip64EOCD) {\n             archive.seek(archive.getFilePointer() - ZIP64_EOCDL_LENGTH);\n      */\n     private void positionAtEndOfCentralDirectoryRecord()\n         throws IOException {\n-        boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n+        final boolean found = tryToLocateSignature(MIN_EOCD_SIZE, MAX_EOCD_SIZE,\n                                              ZipArchiveOutputStream.EOCD_SIG);\n         if (!found) {\n             throw new ZipException(\"archive is not a ZIP archive\");\n     private void skipBytes(final int count) throws IOException {\n         int totalSkipped = 0;\n         while (totalSkipped < count) {\n-            int skippedNow = archive.skipBytes(count - totalSkipped);\n+            final int skippedNow = archive.skipBytes(count - totalSkipped);\n             if (skippedNow <= 0) {\n                 throw new EOFException();\n             }\n     private void resolveLocalFileHeaderData(final Map<ZipArchiveEntry, NameAndComment>\n                                             entriesWithoutUTF8Flag)\n         throws IOException {\n-        for (ZipArchiveEntry zipArchiveEntry : entries) {\n+        for (final ZipArchiveEntry zipArchiveEntry : entries) {\n             // entries is filled in populateFromCentralDirectory and\n             // never modified\n-            Entry ze = (Entry) zipArchiveEntry;\n-            OffsetEntry offsetEntry = ze.getOffsetEntry();\n-            long offset = offsetEntry.headerOffset;\n+            final Entry ze = (Entry) zipArchiveEntry;\n+            final OffsetEntry offsetEntry = ze.getOffsetEntry();\n+            final long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n             archive.readFully(SHORT_BUF);\n-            int fileNameLen = ZipShort.getValue(SHORT_BUF);\n+            final int fileNameLen = ZipShort.getValue(SHORT_BUF);\n             archive.readFully(SHORT_BUF);\n-            int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n+            final int extraFieldLen = ZipShort.getValue(SHORT_BUF);\n             int lenToSkip = fileNameLen;\n             while (lenToSkip > 0) {\n-                int skipped = archive.skipBytes(lenToSkip);\n+                final int skipped = archive.skipBytes(lenToSkip);\n                 if (skipped <= 0) {\n                     throw new IOException(\"failed to skip file name in\"\n                                           + \" local file header\");\n                 }\n                 lenToSkip -= skipped;\n             }\n-            byte[] localExtraData = new byte[extraFieldLen];\n+            final byte[] localExtraData = new byte[extraFieldLen];\n             archive.readFully(localExtraData);\n             ze.setExtra(localExtraData);\n             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n \n             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n-                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n+                final NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                          nc.comment);\n             }\n \n-            String name = ze.getName();\n+            final String name = ze.getName();\n             LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\n             if (entriesOfThatName == null) {\n                 entriesOfThatName = new LinkedList<ZipArchiveEntry>();\n                 return 0;\n             }\n \n-            Entry ent1 = e1 instanceof Entry ? (Entry) e1 : null;\n-            Entry ent2 = e2 instanceof Entry ? (Entry) e2 : null;\n+            final Entry ent1 = e1 instanceof Entry ? (Entry) e1 : null;\n+            final Entry ent2 = e2 instanceof Entry ? (Entry) e2 : null;\n             if (ent1 == null) {\n                 return 1;\n             }\n             if (ent2 == null) {\n                 return -1;\n             }\n-            long val = (ent1.getOffsetEntry().headerOffset\n+            final long val = (ent1.getOffsetEntry().headerOffset\n                         - ent2.getOffsetEntry().headerOffset);\n             return val == 0 ? 0 : val < 0 ? -1 : +1;\n         }\n         public boolean equals(final Object other) {\n             if (super.equals(other)) {\n                 // super.equals would return false if other were not an Entry\n-                Entry otherEntry = (Entry) other;\n+                final Entry otherEntry = (Entry) other;\n                 return offsetEntry.headerOffset\n                         == otherEntry.offsetEntry.headerOffset\n                     && offsetEntry.dataOffset\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n      * @return value as four bytes in big endian byte order\n      */\n     public static byte[] getBytes(final long value) {\n-        byte[] result = new byte[WORD];\n+        final byte[] result = new byte[WORD];\n         putLong(value, result, 0);\n         return result;\n     }\n     public Object clone() {\n         try {\n             return super.clone();\n-        } catch (CloneNotSupportedException cnfe) {\n+        } catch (final CloneNotSupportedException cnfe) {\n             // impossible\n             throw new RuntimeException(cnfe);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipMethod.java\n     private static final Map<Integer, ZipMethod> codeToEnum;\n \n     static {\n-        Map<Integer, ZipMethod> cte = new HashMap<Integer, ZipMethod>();\n-        for (ZipMethod method : values()) {\n+        final Map<Integer, ZipMethod> cte = new HashMap<Integer, ZipMethod>();\n+        for (final ZipMethod method : values()) {\n             cte.put(method.getCode(), method);\n         }\n         codeToEnum = Collections.unmodifiableMap(cte);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n      * @return the value as a a two byte array in big endian byte order\n      */\n     public byte[] getBytes() {\n-        byte[] result = new byte[2];\n+        final byte[] result = new byte[2];\n         result[0] = (byte) (value & BYTE_MASK);\n         result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\n         return result;\n      * @return the converted int as a byte array in big endian byte order\n      */\n     public static byte[] getBytes(final int value) {\n-        byte[] result = new byte[2];\n+        final byte[] result = new byte[2];\n         putShort(value, result, 0);\n         return result;\n     }\n     public Object clone() {\n         try {\n             return super.clone();\n-        } catch (CloneNotSupportedException cnfe) {\n+        } catch (final CloneNotSupportedException cnfe) {\n             // impossible\n             throw new RuntimeException(cnfe);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n      * @return the date as a byte array\n      */\n     public static byte[] toDosTime(final long t) {\n-        byte[] result = new byte[4];\n+        final byte[] result = new byte[4];\n         toDosTime(t, result, 0);\n         return result;\n     }\n     static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\n         c.setTimeInMillis(t);\n \n-        int year = c.get(Calendar.YEAR);\n+        final int year = c.get(Calendar.YEAR);\n         if (year < 1980) {\n             System.arraycopy(DOS_TIME_MIN, 0, buf, offset, DOS_TIME_MIN.length);// stop callers from changing the array\n             return;\n         }\n-        int month = c.get(Calendar.MONTH) + 1;\n-        long value =  ((year - 1980) << 25)\n+        final int month = c.get(Calendar.MONTH) + 1;\n+        final long value =  ((year - 1980) << 25)\n                 |         (month << 21)\n                 |         (c.get(Calendar.DAY_OF_MONTH) << 16)\n                 |         (c.get(Calendar.HOUR_OF_DAY) << 11)\n     public static byte[] reverse(final byte[] array) {\n         final int z = array.length - 1; // position of last element\n         for (int i = 0; i < array.length / 2; i++) {\n-            byte x = array[i];\n+            final byte x = array[i];\n             array[i] = array[z - i];\n             array[z - i] = x;\n         }\n      * @return a Date instance corresponding to the given time.\n      */\n     public static Date fromDosTime(final ZipLong zipDosTime) {\n-        long dosTime = zipDosTime.getValue();\n+        final long dosTime = zipDosTime.getValue();\n         return new Date(dosToJavaTime(dosTime));\n     }\n \n      * @return converted time\n      */\n     public static long dosToJavaTime(final long dosTime) {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         // CheckStyle:MagicNumberCheck OFF - no point\n         cal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\n         cal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\n     static void setNameAndCommentFromExtraFields(final ZipArchiveEntry ze,\n                                                  final byte[] originalNameBytes,\n                                                  final byte[] commentBytes) {\n-        UnicodePathExtraField name = (UnicodePathExtraField)\n+        final UnicodePathExtraField name = (UnicodePathExtraField)\n             ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n-        String originalName = ze.getName();\n-        String newName = getUnicodeStringIfOriginalMatches(name,\n+        final String originalName = ze.getName();\n+        final String newName = getUnicodeStringIfOriginalMatches(name,\n                                                            originalNameBytes);\n         if (newName != null && !originalName.equals(newName)) {\n             ze.setName(newName);\n         }\n \n         if (commentBytes != null && commentBytes.length > 0) {\n-            UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\n+            final UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\n                 ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n-            String newComment =\n+            final String newComment =\n                 getUnicodeStringIfOriginalMatches(cmt, commentBytes);\n             if (newComment != null) {\n                 ze.setComment(newComment);\n         String getUnicodeStringIfOriginalMatches(final AbstractUnicodeExtraField f,\n                                                  final byte[] orig) {\n         if (f != null) {\n-            CRC32 crc32 = new CRC32();\n+            final CRC32 crc32 = new CRC32();\n             crc32.update(orig);\n-            long origCRC32 = crc32.getValue();\n+            final long origCRC32 = crc32.getValue();\n \n             if (origCRC32 == f.getNameCRC32()) {\n                 try {\n                     return ZipEncodingHelper\n                         .UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n-                } catch (IOException ex) {\n+                } catch (final IOException ex) {\n                     // UTF-8 unsupported?  should be impossible the\n                     // Unicode*ExtraField must contain some bad bytes\n \n      */\n     static byte[] copy(final byte[] from) {\n         if (from != null) {\n-            byte[] to = new byte[from.length];\n+            final byte[] to = new byte[from.length];\n             System.arraycopy(from, 0, to, 0, to.length);\n             return to;\n         }\n                                                    .Feature.ENCRYPTION, ze);\n         }\n         if (!supportsMethodOf(ze)) {\n-            ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\n+            final ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\n             if (m == null) {\n                 throw\n                     new UnsupportedZipFeatureException(UnsupportedZipFeatureException\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n         }\n \n         if (!changes.isEmpty()) {\n-            for (Iterator<Change> it = changes.iterator(); it.hasNext();) {\n-                Change change = it.next();\n+            for (final Iterator<Change> it = changes.iterator(); it.hasNext();) {\n+                final Change change = it.next();\n                 if (change.type() == Change.TYPE_ADD\n                         && change.getEntry() != null) {\n-                    ArchiveEntry entry = change.getEntry();\n+                    final ArchiveEntry entry = change.getEntry();\n \n                     if(entry.equals(pChange.getEntry())) {\n                         if(pChange.isReplaceMode()) {\n             pChange.targetFile() == null) {\n             return;\n         }\n-        String source = pChange.targetFile();\n+        final String source = pChange.targetFile();\n \n         if (source != null && !changes.isEmpty()) {\n-            for (Iterator<Change> it = changes.iterator(); it.hasNext();) {\n-                Change change = it.next();\n+            for (final Iterator<Change> it = changes.iterator(); it.hasNext();) {\n+                final Change change = it.next();\n                 if (change.type() == Change.TYPE_ADD\n                         && change.getEntry() != null) {\n-                    String target = change.getEntry().getName();\n+                    final String target = change.getEntry().getName();\n \n                     if (target == null) {\n                         continue;\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n     private ChangeSetResults perform(final ArchiveEntryIterator entryIterator,\n                                      final ArchiveOutputStream out)\n             throws IOException {\n-        ChangeSetResults results = new ChangeSetResults();\n-\n-        Set<Change> workingSet = new LinkedHashSet<Change>(changes);\n-\n-        for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n-            Change change = it.next();\n+        final ChangeSetResults results = new ChangeSetResults();\n+\n+        final Set<Change> workingSet = new LinkedHashSet<Change>(changes);\n+\n+        for (final Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n+            final Change change = it.next();\n \n             if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                 copyStream(change.getInput(), out, change.getEntry());\n         }\n \n         while (entryIterator.hasNext()) {\n-            ArchiveEntry entry = entryIterator.next();\n+            final ArchiveEntry entry = entryIterator.next();\n             boolean copy = true;\n \n-            for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n-                Change change = it.next();\n+            for (final Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n+                final Change change = it.next();\n \n                 final int type = change.type();\n                 final String name = entry.getName();\n         }\n \n         // Adds files which hasn't been added from the original and do not have replace mode on\n-        for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n-            Change change = it.next();\n+        for (final Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n+            final Change change = it.next();\n \n             if (change.type() == Change.TYPE_ADD && \n                 !change.isReplaceMode() && \n      * @return true, if this entry has an deletion change later, false otherwise\n      */\n     private boolean isDeletedLater(final Set<Change> workingSet, final ArchiveEntry entry) {\n-        String source = entry.getName();\n+        final String source = entry.getName();\n \n         if (!workingSet.isEmpty()) {\n-            for (Change change : workingSet) {\n+            for (final Change change : workingSet) {\n                 final int type = change.type();\n-                String target = change.targetFile();\n+                final String target = change.targetFile();\n                 if (type == Change.TYPE_DELETE && source.equals(target)) {\n                     return true;\n                 }\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n         final byte[] signature = new byte[12];\n         in.mark(signature.length);\n         try {\n-            int signatureLength = IOUtils.readFully(in, signature);\n+            final int signatureLength = IOUtils.readFully(in, signature);\n             in.reset();\n \n             if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n                 return new LZMACompressorInputStream(in);\n             }\n \n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n         }\n \n                 return new DeflateCompressorInputStream(in);\n             }\n \n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             throw new CompressorException(\n                     \"Could not create CompressorInputStream.\", e);\n         }\n                 return new DeflateCompressorOutputStream(out);\n             }\n \n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             throw new CompressorException(\n                     \"Could not create CompressorOutputStream\", e);\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/FileNameUtil.java\n         this.uncompressSuffix = Collections.unmodifiableMap(uncompressSuffix);\n         int lc = Integer.MIN_VALUE, sc = Integer.MAX_VALUE;\n         int lu = Integer.MIN_VALUE, su = Integer.MAX_VALUE;\n-        for (Map.Entry<String, String> ent : uncompressSuffix.entrySet()) {\n-            int cl = ent.getKey().length();\n+        for (final Map.Entry<String, String> ent : uncompressSuffix.entrySet()) {\n+            final int cl = ent.getKey().length();\n             if (cl > lc) {\n                 lc = cl;\n             }\n                 sc = cl;\n             }\n \n-            String u = ent.getValue();\n-            int ul = u.length();\n+            final String u = ent.getValue();\n+            final int ul = u.length();\n             if (ul > 0) {\n                 if (!compressSuffix.containsKey(u)) {\n                     compressSuffix.put(u, ent.getKey());\n         final int n = lower.length();\n         for (int i = shortestCompressedSuffix;\n              i <= longestCompressedSuffix && i < n; i++) {\n-            String suffix = uncompressSuffix.get(lower.substring(n - i));\n+            final String suffix = uncompressSuffix.get(lower.substring(n - i));\n             if (suffix != null) {\n                 return filename.substring(0, n - i) + suffix;\n             }\n         final int n = lower.length();\n         for (int i = shortestUncompressedSuffix;\n              i <= longestUncompressedSuffix && i < n; i++) {\n-            String suffix = compressSuffix.get(lower.substring(n - i));\n+            final String suffix = compressSuffix.get(lower.substring(n - i));\n             if (suffix != null) {\n                 return filename.substring(0, n - i) + suffix;\n             }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n     @Override\n     public int read() throws IOException {\n         if (this.in != null) {\n-            int r = read0();\n+            final int r = read0();\n             count(r < 0 ? -1 : 1);\n             return r;\n         }\n             count(1);\n         }\n \n-        int c = (destOffs == offs) ? -1 : (destOffs - offs);\n+        final int c = (destOffs == offs) ? -1 : (destOffs - offs);\n         return c;\n     }\n \n             throw new IOException(\"No InputStream\");\n         }\n \n-        int magic0 = this.in.read();\n+        final int magic0 = this.in.read();\n         if (magic0 == -1 && !isFirstStream) {\n             return false;\n         }\n-        int magic1 = this.in.read();\n-        int magic2 = this.in.read();\n+        final int magic1 = this.in.read();\n+        final int magic2 = this.in.read();\n \n         if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\n             throw new IOException(isFirstStream\n                     : \"Garbage after a valid BZip2 stream\");\n         }\n \n-        int blockSize = this.in.read();\n+        final int blockSize = this.in.read();\n         if ((blockSize < '1') || (blockSize > '9')) {\n             throw new IOException(\"BZip2 block size is invalid\");\n         }\n \n     @Override\n     public void close() throws IOException {\n-        InputStream inShadow = this.in;\n+        final InputStream inShadow = this.in;\n         if (inShadow != null) {\n             try {\n                 if (inShadow != System.in) {\n         if (bsLiveShadow < n) {\n             final InputStream inShadow = this.in;\n             do {\n-                int thech = inShadow.read();\n+                final int thech = inShadow.read();\n \n                 if (thech < 0) {\n                     throw new IOException(\"unexpected end of stream\");\n     private int setupNoRandPartA() throws IOException {\n         if (this.su_i2 <= this.last) {\n             this.su_chPrev = this.su_ch2;\n-            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n+            final int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n             this.su_ch2 = su_ch2Shadow;\n             this.su_tPos = this.data.tt[this.su_tPos];\n             this.su_i2++;\n \n     private int setupNoRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n-            int su_ch2Shadow = this.su_ch2;\n+            final int su_ch2Shadow = this.su_ch2;\n             this.crc.updateCRC(su_ch2Shadow);\n             this.su_j2++;\n             this.currentState = NO_RAND_PART_C_STATE;\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream.java\n                 heap[nHeap] = i;\n \n                 int zz = nHeap;\n-                int tmp = heap[zz];\n+                final int tmp = heap[zz];\n                 while (weight[tmp] < weight[heap[zz >> 1]]) {\n                     heap[zz] = heap[zz >> 1];\n                     zz >>= 1;\n             }\n \n             while (nHeap > 1) {\n-                int n1 = heap[1];\n+                final int n1 = heap[1];\n                 heap[1] = heap[nHeap];\n                 nHeap--;\n \n \n                 heap[zz] = tmp;\n \n-                int n2 = heap[1];\n+                final int n2 = heap[1];\n                 heap[1] = heap[nHeap];\n                 nHeap--;\n \n     @Override\n     public void close() throws IOException {\n         if (out != null) {\n-            OutputStream outShadow = this.out;\n+            final OutputStream outShadow = this.out;\n             finish();\n             outShadow.close();\n         }\n \n     @Override\n     public void flush() throws IOException {\n-        OutputStream outShadow = this.out;\n+        final OutputStream outShadow = this.out;\n         if (outShadow != null) {\n             outShadow.flush();\n         }\n         this.last = -1;\n         // ch = 0;\n \n-        boolean[] inUse = this.data.inUse;\n+        final boolean[] inUse = this.data.inUse;\n         for (int i = 256; --i >= 0;) {\n             inUse[i] = false;\n         }\n             throw new IOException(\"stream closed\");\n         }\n \n-        for (int hi = offs + len; offs < hi;) {\n+        for (final int hi = offs + len; offs < hi;) {\n             write0(buf[offs++]);\n         }\n     }\n \n     private void bsFinishedWithStream() throws IOException {\n         while (this.bsLive > 0) {\n-            int ch = this.bsBuff >> 24;\n+            final int ch = this.bsBuff >> 24;\n             this.out.write(ch); // write 8-bit\n             this.bsBuff <<= 8;\n             this.bsLive -= 8;\n         final int alphaSize = this.nInUse + 2;\n \n         for (int t = N_GROUPS; --t >= 0;) {\n-            byte[] len_t = len[t];\n+            final byte[] len_t = len[t];\n             for (int v = alphaSize; --v >= 0;) {\n                 len_t[v] = GREATER_ICOST;\n             }\n         for (int iter = 0; iter < N_ITERS; iter++) {\n             for (int t = nGroups; --t >= 0;) {\n                 fave[t] = 0;\n-                int[] rfreqt = rfreq[t];\n+                final int[] rfreqt = rfreq[t];\n                 for (int i = alphaSize; --i >= 0;) {\n                     rfreqt[i] = 0;\n                 }\n         // assert (nGroups < 8) : nGroups;\n \n         final Data dataShadow = this.data;\n-        byte[] pos = dataShadow.sendMTFValues2_pos;\n+        final byte[] pos = dataShadow.sendMTFValues2_pos;\n \n         for (int i = nGroups; --i >= 0;) {\n             pos[i] = (byte) i;\n \n             while (ll_i != tmp) {\n                 j++;\n-                byte tmp2 = tmp;\n+                final byte tmp2 = tmp;\n                 tmp = pos[j];\n                 pos[j] = tmp2;\n             }\n     }\n \n     private void sendMTFValues3(final int nGroups, final int alphaSize) {\n-        int[][] code = this.data.sendMTFValues_code;\n-        byte[][] len = this.data.sendMTFValues_len;\n+        final int[][] code = this.data.sendMTFValues_code;\n+        final byte[][] len = this.data.sendMTFValues_len;\n \n         for (int t = 0; t < nGroups; t++) {\n             int minLen = 32;\n         int bsBuffShadow = this.bsBuff;\n \n         for (int t = 0; t < nGroups; t++) {\n-            byte[] len_t = len[t];\n+            final byte[] len_t = len[t];\n             int curr = len_t[0] & 0xff;\n \n             // inlined: bsW(5, curr);\n             bsLiveShadow += 5;\n \n             for (int i = 0; i < alphaSize; i++) {\n-                int lti = len_t[i] & 0xff;\n+                final int lti = len_t[i] & 0xff;\n                 while (curr < lti) {\n                     // inlined: bsW(2, 2);\n                     while (bsLiveShadow >= 8) {\n \n             while (ll_i != tmp) {\n                 j++;\n-                byte tmp2 = tmp;\n+                final byte tmp2 = tmp;\n                 tmp = yy[j];\n                 yy[j] = tmp2;\n             }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2Utils.java\n     private static final FileNameUtil fileNameUtil;\n \n     static {\n-        Map<String, String> uncompressSuffix =\n+        final Map<String, String> uncompressSuffix =\n             new LinkedHashMap<String, String>();\n         // backwards compatibilty: BZip2Utils never created the short\n         // tbz form, so .tar.bz2 has to be added explicitly\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BlockSort.java\n         int j;\n         if (hi - lo > 3) {\n             for (int i = hi - 4; i >= lo; i--) {\n-                int tmp = fmap[i];\n-                int ec_tmp = eclass[tmp];\n+                final int tmp = fmap[i];\n+                final int ec_tmp = eclass[tmp];\n                 for (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];\n                      j += 4) {\n                     fmap[j - 4] = fmap[j];\n         }\n \n         for (int i = hi - 1; i >= lo; i--) {\n-            int tmp = fmap[i];\n-            int ec_tmp = eclass[tmp];\n+            final int tmp = fmap[i];\n+            final int ec_tmp = eclass[tmp];\n             for (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {\n                 fmap[j - 1] = fmap[j];\n             }\n      * swaps two values in fmap\n      */\n     private void fswap(final int[] fmap, final int zz1, final int zz2) {\n-        int zztmp = fmap[zz1];\n+        final int zztmp = fmap[zz1];\n         fmap[zz1] = fmap[zz2];\n         fmap[zz2] = zztmp;\n     }\n         fpush(sp++, loSt, hiSt);\n \n         while (sp > 0) {\n-            int[] s = fpop(--sp);\n+            final int[] s = fpop(--sp);\n             lo = s[0]; hi = s[1];\n \n             if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\n                book, chapter 35.\n             */\n             r = ((r * 7621) + 1) % 32768;\n-            long r3 = r % 3, med;\n+            final long r3 = r % 3;\n+            long med;\n             if (r3 == 0) {\n                 med = eclass[fmap[lo]]; \n             } else if (r3 == 1) {\n         }\n \n         nBhtab = 64 + nblock;\n-        BitSet bhtab = new BitSet(nBhtab);\n+        final BitSet bhtab = new BitSet(nBhtab);\n         for (i = 0; i < 256; i++) {\n             bhtab.set(ftab[i]);\n         }\n     private static void vswap(final int[] fmap, int p1, int p2, int n) {\n         n += p1;\n         while (p1 < n) {\n-            int t = fmap[p1];\n+            final int t = fmap[p1];\n             fmap[p1++] = fmap[p2];\n             fmap[p2++] = t;\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/CRC.java\n         void updateCRC(final int inCh, int repeat) {\n             int globalCrcShadow = this.globalCrc;\n             while (repeat-- > 0) {\n-                int temp = (globalCrcShadow >> 24) ^ inCh;\n+                final int temp = (globalCrcShadow >> 24) ^ inCh;\n                 globalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n                                                           ? temp\n                                                           : (temp + 256)];\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n     /** {@inheritDoc} */\n     @Override\n     public int read() throws IOException {\n-        int ret = in.read();\n+        final int ret = in.read();\n         count(ret == -1 ? 0 : 1);\n         return ret;\n     }\n     /** {@inheritDoc} */\n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n-        int ret = in.read(buf, off, len);\n+        final int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorInputStream.java\n         assert isFirstMember || decompressConcatenated;\n \n         // Check the magic bytes without a possibility of EOFException.\n-        int magic0 = in.read();\n-        int magic1 = in.read();\n+        final int magic0 = in.read();\n+        final int magic1 = in.read();\n \n         // If end of input was reached after decompressing at least\n         // one .gz member, we have reached the end of the file successfully.\n         }\n \n         // Parsing the rest of the header may throw EOFException.\n-        DataInputStream inData = new DataInputStream(in);\n-        int method = inData.readUnsignedByte();\n+        final DataInputStream inData = new DataInputStream(in);\n+        final int method = inData.readUnsignedByte();\n         if (method != Deflater.DEFLATED) {\n             throw new IOException(\"Unsupported compression method \"\n                                   + method + \" in the .gz header\");\n         }\n \n-        int flg = inData.readUnsignedByte();\n+        final int flg = inData.readUnsignedByte();\n         if ((flg & FRESERVED) != 0) {\n             throw new IOException(\n                     \"Reserved flags are set in the .gz header\");\n     }\n \n     private byte[] readToNull(final DataInputStream inData) throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         int b = 0;\n         while ((b = inData.readUnsignedByte()) != 0x00) { // NOPMD\n             bos.write(b);\n             int ret;\n             try {\n                 ret = inf.inflate(b, off, len);\n-            } catch (DataFormatException e) {\n+            } catch (final DataFormatException e) {\n                 throw new IOException(\"Gzip-compressed data is corrupt\");\n             }\n \n                 // in.mark earler, it should always skip enough.\n                 in.reset();\n \n-                int skipAmount = bufUsed - inf.getRemaining();\n+                final int skipAmount = bufUsed - inf.getRemaining();\n                 if (in.skip(skipAmount) != skipAmount) {\n                     throw new IOException();\n                 }\n \n                 bufUsed = 0;\n \n-                DataInputStream inData = new DataInputStream(in);\n+                final DataInputStream inData = new DataInputStream(in);\n \n                 // CRC32\n-                long crcStored = readLittleEndianInt(inData);\n+                final long crcStored = readLittleEndianInt(inData);\n \n                 if (crcStored != crc.getValue()) {\n                     throw new IOException(\"Gzip-compressed data is corrupt \"\n                 }\n \n                 // Uncompressed size modulo 2^32 (ISIZE in the spec)\n-                long isize = readLittleEndianInt(inData);\n+                final long isize = readLittleEndianInt(inData);\n \n                 if (isize != (inf.getBytesWritten() & 0xffffffffl)) {\n                     throw new IOException(\"Gzip-compressed data is corrupt\"\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipCompressorOutputStream.java\n     }\n \n     private void writeHeader(final GzipParameters parameters) throws IOException {\n-        String filename = parameters.getFilename();\n-        String comment = parameters.getComment();\n-        \n-        ByteBuffer buffer = ByteBuffer.allocate(10);\n+        final String filename = parameters.getFilename();\n+        final String comment = parameters.getComment();\n+        \n+        final ByteBuffer buffer = ByteBuffer.allocate(10);\n         buffer.order(ByteOrder.LITTLE_ENDIAN);\n         buffer.putShort((short) GZIPInputStream.GZIP_MAGIC);\n         buffer.put((byte) Deflater.DEFLATED); // compression method (8: deflate)\n         buffer.putInt((int) (parameters.getModificationTime() / 1000));\n         \n         // extra flags\n-        int compressionLevel = parameters.getCompressionLevel();\n+        final int compressionLevel = parameters.getCompressionLevel();\n         if (compressionLevel == Deflater.BEST_COMPRESSION) {\n             buffer.put((byte) 2);\n         } else if (compressionLevel == Deflater.BEST_SPEED) {\n     }\n \n     private void writeTrailer() throws IOException {\n-        ByteBuffer buffer = ByteBuffer.allocate(8);\n+        final ByteBuffer buffer = ByteBuffer.allocate(8);\n         buffer.order(ByteOrder.LITTLE_ENDIAN);\n         buffer.putInt((int) crc.getValue());\n         buffer.putInt(deflater.getTotalIn());\n     }\n \n     private void deflate() throws IOException {\n-        int length = deflater.deflate(deflateBuffer, 0, deflateBuffer.length);\n+        final int length = deflater.deflate(deflateBuffer, 0, deflateBuffer.length);\n         if (length > 0) {\n             out.write(deflateBuffer, 0, length);\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/gzip/GzipUtils.java\n         // using LinkedHashMap so .tgz is preferred over .taz as\n         // compressed extension of .tar as FileNameUtil will use the\n         // first one found\n-        Map<String, String> uncompressSuffix =\n+        final Map<String, String> uncompressSuffix =\n             new LinkedHashMap<String, String>();\n         uncompressSuffix.put(\".tgz\", \".tar\");\n         uncompressSuffix.put(\".taz\", \".tar\");\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMACompressorInputStream.java\n     /** {@inheritDoc} */\n     @Override\n     public int read() throws IOException {\n-        int ret = in.read();\n+        final int ret = in.read();\n         count(ret == -1 ? 0 : 1);\n         return ret;\n     }\n     /** {@inheritDoc} */\n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n-        int ret = in.read(buf, off, len);\n+        final int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzma/LZMAUtils.java\n     private static volatile CachedAvailability cachedLZMAAvailability;\n \n     static {\n-        Map<String, String> uncompressSuffix = new HashMap<String, String>();\n+        final Map<String, String> uncompressSuffix = new HashMap<String, String>();\n         uncompressSuffix.put(\".lzma\", \"\");\n         uncompressSuffix.put(\"-lzma\", \"\");\n         fileNameUtil = new FileNameUtil(uncompressSuffix, \".lzma\");\n         cachedLZMAAvailability = CachedAvailability.DONT_CACHE;\n         try {\n             Class.forName(\"org.osgi.framework.BundleEvent\");\n-        } catch (Exception ex) {\n+        } catch (final Exception ex) {\n             setCacheLZMAAvailablity(true);\n         }\n     }\n         try {\n             LZMACompressorInputStream.matches(null, 0);\n             return true;\n-        } catch (NoClassDefFoundError error) {\n+        } catch (final NoClassDefFoundError error) {\n             return false;\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/lzw/LZWInputStream.java\n     \n     @Override\n     public int read() throws IOException {\n-        int ret = read(oneByte);\n+        final int ret = read(oneByte);\n         if (ret < 0) {\n             return ret;\n         }\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n         int bytesRead = readFromStack(b, off, len);\n         while (len - bytesRead > 0) {\n-            int result = decompressNextSymbol();\n+            final int result = decompressNextSymbol();\n             if (result < 0) {\n                 if (bytesRead > 0) {\n                     count(bytesRead);\n     }\n \n     private int readFromStack(final byte[] b, final int off, final int len) {\n-        int remainingInStack = outputStack.length - outputStackLocation;\n+        final int remainingInStack = outputStack.length - outputStackLocation;\n         if (remainingInStack > 0) {\n-            int maxLength = Math.min(remainingInStack, len);\n+            final int maxLength = Math.min(remainingInStack, len);\n             System.arraycopy(outputStack, outputStackLocation, b, off, maxLength);\n             outputStackLocation += maxLength;\n             return maxLength;\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorInputStream.java\n         throws IOException {\n         originalInput = in;\n         streamBridge = mode.newStreamBridge();\n-        JarOutputStream jarOut = new JarOutputStream(streamBridge);\n-        Pack200.Unpacker u = Pack200.newUnpacker();\n+        final JarOutputStream jarOut = new JarOutputStream(streamBridge);\n+        final Pack200.Unpacker u = Pack200.newUnpacker();\n         if (props != null) {\n             u.properties().putAll(props);\n         }\n     public boolean markSupported() {\n         try {\n             return streamBridge.getInput().markSupported();\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             return false;\n         }\n     }\n     public void mark(final int limit) {\n         try {\n             streamBridge.getInput().mark(limit);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             throw new RuntimeException(ex);\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200CompressorOutputStream.java\n     public void finish() throws IOException {\n         if (!finished) {\n             finished = true;\n-            Pack200.Packer p = Pack200.newPacker();\n+            final Pack200.Packer p = Pack200.newPacker();\n             if (properties != null) {\n                 p.properties().putAll(properties);\n             }\n--- a/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/pack200/Pack200Utils.java\n             props = new HashMap<String, String>();\n         }\n         props.put(Pack200.Packer.SEGMENT_LIMIT, \"-1\");\n-        File f = File.createTempFile(\"commons-compress\", \"pack200normalize\");\n+        final File f = File.createTempFile(\"commons-compress\", \"pack200normalize\");\n         f.deleteOnExit();\n         try {\n             OutputStream os = new FileOutputStream(f);\n             JarFile j = null;\n             try {\n-                Pack200.Packer p = Pack200.newPacker();\n+                final Pack200.Packer p = Pack200.newPacker();\n                 p.properties().putAll(props);\n                 p.pack(j = new JarFile(from), os);\n                 j = null;\n                 os.close();\n                 os = null;\n \n-                Pack200.Unpacker u = Pack200.newUnpacker();\n+                final Pack200.Unpacker u = Pack200.newUnpacker();\n                 os = new JarOutputStream(new FileOutputStream(to));\n                 u.unpack(f, (JarOutputStream) os);\n             } finally {\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStream.java\n     private int readOnce(final byte[] b, final int off, final int len) throws IOException {\n         int read = -1;\n         if (inUncompressedChunk) {\n-            int amount = Math.min(uncompressedBytesRemaining, len);\n+            final int amount = Math.min(uncompressedBytesRemaining, len);\n             if (amount == 0) {\n                 return -1;\n             }\n                 count(read);\n             }\n         } else if (currentCompressedChunk != null) {\n-            long before = currentCompressedChunk.getBytesRead();\n+            final long before = currentCompressedChunk.getBytesRead();\n             read = currentCompressedChunk.read(b, off, len);\n             if (read == -1) {\n                 currentCompressedChunk.close();\n     private void readNextBlock() throws IOException {\n         verifyLastChecksumAndReset();\n         inUncompressedChunk = false;\n-        int type = readOneByte();\n+        final int type = readOneByte();\n         if (type == -1) {\n             endReached = true;\n         } else if (type == STREAM_IDENTIFIER_TYPE) {\n             uncompressedBytesRemaining = readSize() - 4 /* CRC */;\n             expectedChecksum = unmask(readCrc());\n         } else if (type == COMPRESSED_CHUNK_TYPE) {\n-            long size = readSize() - 4 /* CRC */;\n+            final long size = readSize() - 4 /* CRC */;\n             expectedChecksum = unmask(readCrc());\n             currentCompressedChunk =\n                 new SnappyCompressorInputStream(new BoundedInputStream(in, size));\n     }\n \n     private long readCrc() throws IOException {\n-        byte[] b = new byte[4];\n-        int read = IOUtils.readFully(in, b);\n+        final byte[] b = new byte[4];\n+        final int read = IOUtils.readFully(in, b);\n         count(read);\n         if (read != 4) {\n             throw new IOException(\"premature end of stream\");\n     }\n \n     private void skipBlock() throws IOException {\n-        int size = readSize();\n-        long read = IOUtils.skip(in, size);\n+        final int size = readSize();\n+        final long read = IOUtils.skip(in, size);\n         count(read);\n         if (read != size) {\n             throw new IOException(\"premature end of stream\");\n     }\n \n     private void readStreamIdentifier() throws IOException {\n-        byte[] b = new byte[10];\n-        int read = IOUtils.readFully(in, b);\n+        final byte[] b = new byte[10];\n+        final int read = IOUtils.readFully(in, b);\n         count(read);\n         if (10 != read || !matches(b, 10)) {\n             throw new IOException(\"Not a framed Snappy stream\");\n     }\n \n     private int readOneByte() throws IOException {\n-        int b = in.read();\n+        final int b = in.read();\n         if (b != -1) {\n             count(1);\n             return b & 0xFF;\n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/PureJavaCrc32C.java\n \n   @Override\n public long getValue() {\n-    long ret = crc;\n+    final long ret = crc;\n     return (~ret) & 0xffffffffL;\n   }\n \n--- a/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/SnappyCompressorInputStream.java\n             fill(len - avail);\n         }\n \n-        int readable = Math.min(len, available());\n+        final int readable = Math.min(len, available());\n         if (readable == 0 && len > 0) {\n             return -1;\n         }\n      * @return True if the decompressed data should be flushed\n      */\n     private boolean expandLiteral(final int length) throws IOException {\n-        int bytesRead = IOUtils.readFully(in, decompressBuf, writeIndex, length);\n+        final int bytesRead = IOUtils.readFully(in, decompressBuf, writeIndex, length);\n         count(bytesRead);\n         if (length != bytesRead) {\n             throw new IOException(\"Premature end of stream\");\n         if (off > blockSize) {\n             throw new IOException(\"Offset is larger than block size\");\n         }\n-        int offset = (int) off;\n+        final int offset = (int) off;\n \n         if (offset == 1) {\n-            byte lastChar = decompressBuf[writeIndex - 1];\n+            final byte lastChar = decompressBuf[writeIndex - 1];\n             for (int i = 0; i < length; i++) {\n                 decompressBuf[writeIndex++] = lastChar;\n             }\n             writeIndex += length;\n         } else {\n             int fullRotations = length / offset;\n-            int pad = length - (offset * fullRotations);\n+            final int pad = length - (offset * fullRotations);\n \n             while (fullRotations-- != 0) {\n                 System.arraycopy(decompressBuf, writeIndex - offset,\n      *             EOF is reached or error reading the stream\n      */\n     private int readOneByte() throws IOException {\n-        int b = in.read();\n+        final int b = in.read();\n         if (b == -1) {\n             throw new IOException(\"Premature end of stream\");\n         }\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStream.java\n \n     @Override\n     public int read() throws IOException {\n-        int ret = in.read();\n+        final int ret = in.read();\n         count(ret == -1 ? -1 : 1);\n         return ret;\n     }\n \n     @Override\n     public int read(final byte[] buf, final int off, final int len) throws IOException {\n-        int ret = in.read(buf, off, len);\n+        final int ret = in.read(buf, off, len);\n         count(ret);\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/xz/XZUtils.java\n     private static volatile CachedAvailability cachedXZAvailability;\n \n     static {\n-        Map<String, String> uncompressSuffix = new HashMap<String, String>();\n+        final Map<String, String> uncompressSuffix = new HashMap<String, String>();\n         uncompressSuffix.put(\".txz\", \".tar\");\n         uncompressSuffix.put(\".xz\", \"\");\n         uncompressSuffix.put(\"-xz\", \"\");\n         cachedXZAvailability = CachedAvailability.DONT_CACHE;\n         try {\n             Class.forName(\"org.osgi.framework.BundleEvent\");\n-        } catch (Exception ex) {\n+        } catch (final Exception ex) {\n             setCacheXZAvailablity(true);\n         }\n     }\n         try {\n             XZCompressorInputStream.matches(null, 0);\n             return true;\n-        } catch (NoClassDefFoundError error) {\n+        } catch (final NoClassDefFoundError error) {\n             return false;\n         }\n     }\n--- a/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/z/ZCompressorInputStream.java\n     \n     public ZCompressorInputStream(final InputStream inputStream) throws IOException {\n         super(inputStream, ByteOrder.LITTLE_ENDIAN);\n-        int firstByte = (int) in.readBits(8);\n-        int secondByte = (int) in.readBits(8);\n-        int thirdByte = (int) in.readBits(8);\n+        final int firstByte = (int) in.readBits(8);\n+        final int secondByte = (int) in.readBits(8);\n+        final int thirdByte = (int) in.readBits(8);\n         if (firstByte != MAGIC_1 || secondByte != MAGIC_2 || thirdByte < 0) {\n             throw new IOException(\"Input is not in .Z format\");\n         }\n      */\n     @Override\n     protected int readNextCode() throws IOException {\n-        int code = super.readNextCode();\n+        final int code = super.readNextCode();\n         if (code >= 0) {\n             ++totalCodesRead;\n         }\n     @Override\n     protected int addEntry(final int previousCode, final byte character) throws IOException {\n         final int maxTableSize = 1 << getCodeSize();\n-        int r = addEntry(previousCode, character, maxTableSize);\n+        final int r = addEntry(previousCode, character, maxTableSize);\n         if (getTableSize() == maxTableSize && getCodeSize() < maxCodeSize) {\n             reAlignReading();\n             incrementCodeSize();\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n      * @return the representation of the entry\n      */\n     public static String toString(final ArchiveEntry entry){\n-        StringBuilder sb = new StringBuilder();\n+        final StringBuilder sb = new StringBuilder();\n         sb.append(entry.isDirectory()? 'd' : '-');// c.f. \"ls -l\" output\n-        String size = Long.toString(entry.getSize());\n+        final String size = Long.toString(entry.getSize());\n         sb.append(' ');\n         // Pad output to 7 places, leading spaces\n         for(int i=7; i > size.length(); i--){\n         byte[] buffer1;\n         try {\n             buffer1 = expected.getBytes(CharsetNames.US_ASCII);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new RuntimeException(e); // Should not happen\n         }\n         return isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n     public static byte[] toAsciiBytes(final String inputString){\n         try {\n             return inputString.getBytes(CharsetNames.US_ASCII);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // Should never happen\n         }\n     }\n     public static String toAsciiString(final byte[] inputBytes){\n         try {\n             return new String(inputBytes, CharsetNames.US_ASCII);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new RuntimeException(e); // Should never happen\n         }\n     }\n     public static String toAsciiString(final byte[] inputBytes, final int offset, final int length){\n         try {\n             return new String(inputBytes, offset, length, CharsetNames.US_ASCII);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new RuntimeException(e); // Should never happen\n         }\n     }\n             final byte[] buffer1, final int offset1, final int length1,\n             final byte[] buffer2, final int offset2, final int length2,\n             final boolean ignoreTrailingNulls){\n-        int minLen=length1 < length2 ? length1 : length2;\n+        final int minLen=length1 < length2 ? length1 : length2;\n         for (int i=0; i < minLen; i++){\n             if (buffer1[offset1+i] != buffer2[offset2+i]){\n                 return false;\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumVerifyingInputStream.java\n         if (bytesRemaining <= 0) {\n             return -1;\n         }\n-        int ret = in.read();\n+        final int ret = in.read();\n         if (ret >= 0) {\n             checksum.update(ret);\n             --bytesRemaining;\n      */\n     @Override\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n-        int ret = in.read(b, off, len);\n+        final int ret = in.read(b, off, len);\n         if (ret >= 0) {\n             checksum.update(b, off, ret);\n             bytesRemaining -= ret;\n--- a/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/CountingInputStream.java\n \n     @Override\n     public int read() throws IOException {\n-        int r = in.read();\n+        final int r = in.read();\n         if (r >= 0) {\n             count(1);\n         }\n     }\n     @Override\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n-        int r = in.read(b, off, len);\n+        final int r = in.read(b, off, len);\n         if (r >= 0) {\n             count(r);\n         }\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n      * @throws IOException on error\n      */\n     public static long skip(final InputStream input, long numToSkip) throws IOException {\n-        long available = numToSkip;\n+        final long available = numToSkip;\n         while (numToSkip > 0) {\n-            long skipped = input.skip(numToSkip);\n+            final long skipped = input.skip(numToSkip);\n             if (skipped == 0) {\n                 break;\n             }\n         }\n             \n         while (numToSkip > 0) {\n-            int read = readFully(input, SKIP_BUF, 0,\n+            final int read = readFully(input, SKIP_BUF, 0,\n                                  (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n             if (read < 1) {\n                 break;\n         if (c != null) {\n             try {\n                 c.close();\n-            } catch (IOException ignored) { // NOPMD\n+            } catch (final IOException ignored) { // NOPMD\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n     }\n \n     public static File mkdir(final String name) throws IOException {\n-        File f = File.createTempFile(name, \"\");\n+        final File f = File.createTempFile(name, \"\");\n         f.delete();\n         f.mkdir();\n         return f;\n     }\n \n     public static File getFile(final String path) throws IOException {\n-        URL url = AbstractTestCase.class.getClassLoader().getResource(path);\n+        final URL url = AbstractTestCase.class.getClassLoader().getResource(path);\n         if (url == null) {\n             throw new FileNotFoundException(\"couldn't find \" + path);\n         }\n         URI uri = null;\n         try {\n             uri = url.toURI();\n-        } catch (java.net.URISyntaxException ex) {\n+        } catch (final java.net.URISyntaxException ex) {\n             throw new IOException(ex);\n         }\n         return new File(uri);\n     }\n \n     public static void rmdir(final File f) {\n-        String[] s = f.list();\n+        final String[] s = f.list();\n         if (s != null) {\n-            for (String element : s) {\n+            for (final String element : s) {\n                 final File file = new File(f, element);\n                 if (file.isDirectory()){\n                     rmdir(file);\n                 }\n-                boolean ok = tryHardToDelete(file);\n+                final boolean ok = tryHardToDelete(file);\n                 if (!ok && file.exists()){\n                     System.out.println(\"Failed to delete \"+element+\" in \"+f.getPath());\n                 }\n             }\n             try {\n                 Thread.sleep(10);\n-            } catch (InterruptedException ex) {\n+            } catch (final InterruptedException ex) {\n                 // Ignore Exception\n             }\n             return f.delete();\n      */\n     private void addArchiveEntry(final ArchiveOutputStream out, final String filename, final File infile)\n             throws IOException, FileNotFoundException {\n-        ArchiveEntry entry = out.createArchiveEntry(infile, filename);\n+        final ArchiveEntry entry = out.createArchiveEntry(infile, filename);\n         out.putArchiveEntry(entry);\n         IOUtils.copy(new FileInputStream(infile), out);\n         out.closeArchiveEntry();\n      */\n     protected File checkArchiveContent(final ArchiveInputStream in, final List<String> expected, final boolean cleanUp)\n             throws Exception {\n-        File result = mkdir(\"dir-result\");\n+        final File result = mkdir(\"dir-result\");\n         result.deleteOnExit();\n \n         try {\n             ArchiveEntry entry = null;\n             while ((entry = in.getNextEntry()) != null) {\n-                File outfile = new File(result.getCanonicalPath() + \"/result/\"\n+                final File outfile = new File(result.getCanonicalPath() + \"/result/\"\n                         + entry.getName());\n                 long copied=0;\n                 if (entry.isDirectory()){\n                     outfile.mkdirs();\n                 } else {\n                     outfile.getParentFile().mkdirs();\n-                    OutputStream out = new FileOutputStream(outfile);\n+                    final OutputStream out = new FileOutputStream(outfile);\n                     try {\n                         copied=IOUtils.copy(in, out);\n                     } finally {\n      * element of the two element array).\n      */\n     protected File[] createTempDirAndFile() throws IOException {\n-        File tmpDir = createTempDir();\n-        File tmpFile = File.createTempFile(\"testfile\", \"\", tmpDir);\n+        final File tmpDir = createTempDir();\n+        final File tmpFile = File.createTempFile(\"testfile\", \"\", tmpDir);\n         tmpFile.deleteOnExit();\n-        FileOutputStream fos = new FileOutputStream(tmpFile);\n+        final FileOutputStream fos = new FileOutputStream(tmpFile);\n         try {\n             fos.write(new byte[] {'f', 'o', 'o'});\n             return new File[] {tmpDir, tmpFile};\n     }\n \n     protected File createTempDir() throws IOException {\n-        File tmpDir = mkdir(\"testdir\");\n+        final File tmpDir = mkdir(\"testdir\");\n         tmpDir.deleteOnExit();\n         return tmpDir;\n     }\n         if (closeable != null) {\n             try {\n                 closeable.close();\n-            } catch (IOException ignored) {\n+            } catch (final IOException ignored) {\n                 // ignored\n             }\n         }\n--- a/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveReadTest.java\n     @BeforeClass\n     public static void setUpFileList() throws Exception {\n         assertTrue(ARCDIR.exists());\n-        File listing= new File(ARCDIR,\"files.txt\");\n+        final File listing= new File(ARCDIR,\"files.txt\");\n         assertTrue(\"files.txt is readable\",listing.canRead());\n-        BufferedReader br = new BufferedReader(new FileReader(listing));\n+        final BufferedReader br = new BufferedReader(new FileReader(listing));\n         String line;\n         while ((line=br.readLine())!=null){\n             if (!line.startsWith(\"#\")){\n     @Parameters(name = \"file={0}\")\n     public static Collection<Object[]> data() {\n         assertTrue(ARCDIR.exists());\n-        Collection<Object[]> params = new ArrayList<Object[]>();\n-        for (String f : ARCDIR.list(new FilenameFilter() {\n+        final Collection<Object[]> params = new ArrayList<Object[]>();\n+        for (final String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n             public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n     @Test\n     public void testArchive() throws Exception{\n         @SuppressWarnings(\"unchecked\") // fileList is correct type already\n+        final\n         ArrayList<String> expected= (ArrayList<String>) FILELIST.clone();\n         try {\n            checkArchiveContent(file, expected);\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             fail(\"Problem checking \"+file);\n-        } catch (AssertionError e) { // show error in context\n+        } catch (final AssertionError e) { // show error in context\n             fail(\"Problem checking \" + file + \" \" +e);\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/ArchiveUtilsTest.java\n \n     @Test\n     public void testCompareBA(){\n-        byte[] buffer1 = {1,2,3};\n-        byte[] buffer2 = {1,2,3,0};\n-        byte[] buffer3 = {1,2,3};\n+        final byte[] buffer1 = {1,2,3};\n+        final byte[] buffer2 = {1,2,3,0};\n+        final byte[] buffer3 = {1,2,3};\n         assertTrue(ArchiveUtils.isEqual(buffer1, buffer2, true));\n         assertFalse(ArchiveUtils.isEqual(buffer1, buffer2, false));\n         assertFalse(ArchiveUtils.isEqual(buffer1, buffer2));\n \n     @Test\n     public void testCompareAscii(){\n-        byte[] buffer1 = {'a','b','c'};\n-        byte[] buffer2 = {'d','e','f',0};\n+        final byte[] buffer1 = {'a','b','c'};\n+        final byte[] buffer2 = {'d','e','f',0};\n         assertTrue(ArchiveUtils.matchAsciiBuffer(\"abc\", buffer1));\n         assertFalse(ArchiveUtils.matchAsciiBuffer(\"abc\\0\", buffer1));\n         assertTrue(ArchiveUtils.matchAsciiBuffer(\"def\\0\", buffer2));\n--- a/src/test/java/org/apache/commons/compress/ChainingTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/ChainingTestCase.java\n \n     @Test\n     public void testTarGzip() throws Exception {\n-        File file = getFile(\"bla.tgz\");\n+        final File file = getFile(\"bla.tgz\");\n         final TarArchiveInputStream is = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(file)));\n         final TarArchiveEntry entry = (TarArchiveEntry)is.getNextEntry();\n         assertNotNull(entry);\n \n     @Test\n     public void testTarBzip2() throws Exception {\n-        File file = getFile(\"bla.tar.bz2\");\n+        final File file = getFile(\"bla.tar.bz2\");\n         final TarArchiveInputStream is = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(file)));\n         final TarArchiveEntry entry = (TarArchiveEntry)is.getNextEntry();\n         assertNotNull(entry);\n--- a/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n         try {\n             getStreamFor(\"test.txt\");\n             fail(\"Expected ArchiveException\");\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             // expected\n         }\n     }\n     }\n \n     private void checkEmptyArchive(final String type) throws Exception{\n-        File ar = createEmptyArchive(type); // will be deleted by tearDown()\n+        final File ar = createEmptyArchive(type); // will be deleted by tearDown()\n         ar.deleteOnExit(); // Just in case file cannot be deleted\n         ArchiveInputStream ais = null;\n         BufferedInputStream in = null;\n         try {\n             in = new BufferedInputStream(new FileInputStream(ar));\n             ais = factory.createArchiveInputStream(in);\n-        } catch (ArchiveException ae) {\n+        } catch (final ArchiveException ae) {\n             fail(\"Should have recognised empty archive for \"+type);\n         } finally {\n             if (ais != null) {\n--- a/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n+++ b/src/test/java/org/apache/commons/compress/IOMethodsTest.java\n \n     @Test\n     public void testWriteAr() throws Exception {\n-        ArchiveEntry entry = new ArArchiveEntry(\"dummy\", bytesToTest);\n+        final ArchiveEntry entry = new ArArchiveEntry(\"dummy\", bytesToTest);\n         compareWrites(\"ar\", entry);\n     }\n \n     @Test\n     public void testWriteCpio() throws Exception {\n-        ArchiveEntry entry = new CpioArchiveEntry(\"dummy\", bytesToTest);\n+        final ArchiveEntry entry = new CpioArchiveEntry(\"dummy\", bytesToTest);\n         compareWrites(\"cpio\", entry);\n     }\n \n     @Test\n     public void testWriteJar() throws Exception {\n-        ArchiveEntry entry = new JarArchiveEntry(\"dummy\");\n+        final ArchiveEntry entry = new JarArchiveEntry(\"dummy\");\n         compareWrites(\"jar\", entry);\n     }\n \n     @Test\n     public void testWriteTar() throws Exception {\n-        TarArchiveEntry entry = new TarArchiveEntry(\"dummy\");\n+        final TarArchiveEntry entry = new TarArchiveEntry(\"dummy\");\n         entry.setSize(bytesToTest);\n         compareWrites(\"tar\", entry);\n     }\n \n     @Test\n     public void testWriteZip() throws Exception {\n-        ArchiveEntry entry = new ZipArchiveEntry(\"dummy\");\n+        final ArchiveEntry entry = new ZipArchiveEntry(\"dummy\");\n         compareWrites(\"zip\", entry);\n     }\n \n     }\n \n     private void compareWrites(final String archiverName, final ArchiveEntry entry) throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        OutputStream out2 = new ByteArrayOutputStream();\n-        OutputStream out3 = new ByteArrayOutputStream();\n-        ArchiveOutputStream aos1 = factory.createArchiveOutputStream(archiverName, out1);\n+        final OutputStream out1 = new ByteArrayOutputStream();\n+        final OutputStream out2 = new ByteArrayOutputStream();\n+        final OutputStream out3 = new ByteArrayOutputStream();\n+        final ArchiveOutputStream aos1 = factory.createArchiveOutputStream(archiverName, out1);\n         aos1.putArchiveEntry(entry);\n-        ArchiveOutputStream aos2 = factory.createArchiveOutputStream(archiverName, out2);\n+        final ArchiveOutputStream aos2 = factory.createArchiveOutputStream(archiverName, out2);\n         aos2.putArchiveEntry(entry);\n-        ArchiveOutputStream aos3 = factory.createArchiveOutputStream(archiverName, out3);\n+        final ArchiveOutputStream aos3 = factory.createArchiveOutputStream(archiverName, out3);\n         aos3.putArchiveEntry(entry);\n-        for (byte element : byteTest) {\n+        for (final byte element : byteTest) {\n             aos1.write(element);\n         }\n         aos1.closeArchiveEntry();\n     }\n \n     private void compareReads(final String archiverName) throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        OutputStream out2 = new ByteArrayOutputStream();\n-        OutputStream out3 = new ByteArrayOutputStream();\n-        File file = createSingleEntryArchive(archiverName);\n+        final OutputStream out1 = new ByteArrayOutputStream();\n+        final OutputStream out2 = new ByteArrayOutputStream();\n+        final OutputStream out3 = new ByteArrayOutputStream();\n+        final File file = createSingleEntryArchive(archiverName);\n         file.deleteOnExit();\n \n-        InputStream is1 = new FileInputStream(file);\n-        ArchiveInputStream ais1 = factory.createArchiveInputStream(archiverName, is1);\n+        final InputStream is1 = new FileInputStream(file);\n+        final ArchiveInputStream ais1 = factory.createArchiveInputStream(archiverName, is1);\n         final ArchiveEntry nextEntry = ais1.getNextEntry();\n         assertNotNull(nextEntry);\n \n-        byte [] buff = new byte[10]; // small so multiple reads are needed;\n-        long size = nextEntry.getSize();\n+        final byte [] buff = new byte[10]; // small so multiple reads are needed;\n+        final long size = nextEntry.getSize();\n         if (size != ArchiveEntry.SIZE_UNKNOWN) {\n             assertTrue(\"Size should be > 0, found: \"+size, size > 0);\n         }\n \n-        InputStream is2 = new FileInputStream(file);\n-        ArchiveInputStream ais2 = factory.createArchiveInputStream(archiverName, is2);\n+        final InputStream is2 = new FileInputStream(file);\n+        final ArchiveInputStream ais2 = factory.createArchiveInputStream(archiverName, is2);\n         final ArchiveEntry nextEntry2 = ais2.getNextEntry();\n         assertNotNull(nextEntry2);\n         assertEquals(\"Expected same entry size\", size, nextEntry2.getSize());\n \n-        InputStream is3 = new FileInputStream(file);\n-        ArchiveInputStream ais3 = factory.createArchiveInputStream(archiverName, is3);\n+        final InputStream is3 = new FileInputStream(file);\n+        final ArchiveInputStream ais3 = factory.createArchiveInputStream(archiverName, is3);\n         final ArchiveEntry nextEntry3 = ais3.getNextEntry();\n         assertNotNull(nextEntry3);\n         assertEquals(\"Expected same entry size\", size, nextEntry3.getSize());\n--- a/src/test/java/org/apache/commons/compress/archivers/ArTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArTestCase.java\n         final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n         final ArArchiveEntry entry = (ArArchiveEntry)in.getNextEntry();\n \n-        File target = new File(dir, entry.getName());\n+        final File target = new File(dir, entry.getName());\n         final OutputStream out = new FileOutputStream(target);\n \n         IOUtils.copy(in, out);\n     @Ignore\n     @Test\n     public void XtestDirectoryEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ArArchiveOutputStream aos = null;\n         ArArchiveInputStream ais = null;\n             archive = File.createTempFile(\"test.\", \".ar\", tmp[0]);\n             archive.deleteOnExit();\n             aos = new ArArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            ArArchiveEntry in = new ArArchiveEntry(tmp[0], \"foo\");\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final ArArchiveEntry in = new ArArchiveEntry(tmp[0], \"foo\");\n             aos.putArchiveEntry(in);\n             aos.closeArchiveEntry();\n             aos.close();\n             aos = null;\n             ais = new ArArchiveInputStream(new FileInputStream(archive));\n-            ArArchiveEntry out = ais.getNextArEntry();\n+            final ArArchiveEntry out = ais.getNextArEntry();\n             ais.close();\n             ais = null;\n             assertNotNull(out);\n     @Ignore\n     @Test\n     public void XtestExplicitDirectoryEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ArArchiveOutputStream aos = null;\n         ArArchiveInputStream ais = null;\n             archive = File.createTempFile(\"test.\", \".ar\", tmp[0]);\n             archive.deleteOnExit();\n             aos = new ArArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            ArArchiveEntry in = new ArArchiveEntry(\"foo\", 0, 0, 0, 0,\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final ArArchiveEntry in = new ArArchiveEntry(\"foo\", 0, 0, 0, 0,\n                                                    tmp[1].lastModified() / 1000);\n             aos.putArchiveEntry(in);\n             aos.closeArchiveEntry();\n             aos.close();\n             aos = null;\n             ais = new ArArchiveInputStream(new FileInputStream(archive));\n-            ArArchiveEntry out = ais.getNextArEntry();\n+            final ArArchiveEntry out = ais.getNextArEntry();\n             ais.close();\n             ais = null;\n             assertNotNull(out);\n \n     @Test\n     public void testFileEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ArArchiveOutputStream aos = null;\n         ArArchiveInputStream ais = null;\n             archive = File.createTempFile(\"test.\", \".ar\", tmp[0]);\n             archive.deleteOnExit();\n             aos = new ArArchiveOutputStream(new FileOutputStream(archive));\n-            ArArchiveEntry in = new ArArchiveEntry(tmp[1], \"foo\");\n+            final ArArchiveEntry in = new ArArchiveEntry(tmp[1], \"foo\");\n             aos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 aos.write(b);\n             aos.close();\n             aos = null;\n             ais = new ArArchiveInputStream(new FileInputStream(archive));\n-            ArArchiveEntry out = ais.getNextArEntry();\n+            final ArArchiveEntry out = ais.getNextArEntry();\n             ais.close();\n             ais = null;\n             assertNotNull(out);\n \n     @Test\n     public void testExplicitFileEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ArArchiveOutputStream aos = null;\n         ArArchiveInputStream ais = null;\n             archive = File.createTempFile(\"test.\", \".ar\", tmp[0]);\n             archive.deleteOnExit();\n             aos = new ArArchiveOutputStream(new FileOutputStream(archive));\n-            ArArchiveEntry in = new ArArchiveEntry(\"foo\", tmp[1].length(),\n+            final ArArchiveEntry in = new ArArchiveEntry(\"foo\", tmp[1].length(),\n                                                    0, 0, 0,\n                                                    tmp[1].lastModified() / 1000);\n             aos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 aos.write(b);\n             aos.close();\n             aos = null;\n             ais = new ArArchiveInputStream(new FileInputStream(archive));\n-            ArArchiveEntry out = ais.getNextArEntry();\n+            final ArArchiveEntry out = ais.getNextArEntry();\n             ais.close();\n             ais = null;\n             assertNotNull(out);\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveOutputStreamTest.java\n \n     @Test\n     public void testFinish() throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n+        final OutputStream out1 = new ByteArrayOutputStream();\n \n         ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n         aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n         try {\n             aos1.finish();\n             fail(\"After putArchive should follow closeArchive\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n \n         try {\n             aos1.finish();\n             fail(\"After putArchive should follow closeArchive\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n \n         try {\n             aos1.finish();\n             fail(\"After putArchive should follow closeArchive\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n \n         try {\n             aos1.finish();\n             fail(\"After putArchive should follow closeArchive\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n \n         try {\n             aos1.finish();\n             fail(\"After putArchive should follow closeArchive\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n     }\n \n     @Test\n     public void testOptionalFinish() throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n+        final OutputStream out1 = new ByteArrayOutputStream();\n \n         ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n         aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n         try {\n             aos1.finish();\n             fail(\"finish() cannot follow close()\");\n-        } catch (IOException io) {\n+        } catch (final IOException io) {\n             // Exception expected\n         }\n     }\n     }\n \n     private void doCallSequence(final String archiveType) throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        File dummy = getFile(\"test1.xml\"); // need a real file\n+        final OutputStream out1 = new ByteArrayOutputStream();\n+        final File dummy = getFile(\"test1.xml\"); // need a real file\n \n         ArchiveOutputStream aos1;\n         aos1 = factory.createArchiveOutputStream(archiveType, out1);\n         try {\n             aos1.closeArchiveEntry();\n             fail(\"Should have raised IOException - closeArchiveEntry() called before putArchiveEntry()\");\n-        } catch (IOException expected) {\n+        } catch (final IOException expected) {\n         }\n \n         aos1.putArchiveEntry(aos1.createArchiveEntry(dummy, \"dummy\"));\n         try {\n             aos1.finish();\n             fail(\"Should have raised IOException - finish() called before closeArchiveEntry()\");\n-        } catch (IOException expected) {\n+        } catch (final IOException expected) {\n         }\n         try {\n             aos1.close();\n             fail(\"Should have raised IOException - close() called before closeArchiveEntry()\");\n-        } catch (IOException expected) {\n+        } catch (final IOException expected) {\n         }\n         aos1.closeArchiveEntry();\n         try {\n             aos1.closeArchiveEntry();\n             fail(\"Should have raised IOException - closeArchiveEntry() called with no open entry\");\n-        } catch (IOException expected) {\n+        } catch (final IOException expected) {\n         }\n         aos1.finish();\n         aos1.close();\n         try {\n             aos1.finish();\n             fail(\"Should have raised IOException - finish() called after close()\");\n-        } catch (IOException expected) {\n+        } catch (final IOException expected) {\n         }\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n             new ArchiveStreamFactory()\n                 .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n             fail(\"created an input stream for a non-archive\");\n-        } catch (ArchiveException ae) {\n+        } catch (final ArchiveException ae) {\n             assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n         }\n     }\n      */\n     @Test\n     public void aiffFilesAreNoTARs() throws Exception {\n-    \tFileInputStream fis = new FileInputStream(\"src/test/resources/testAIFF.aif\");\n+    \tfinal FileInputStream fis = new FileInputStream(\"src/test/resources/testAIFF.aif\");\n     \ttry {\n-            InputStream is = new BufferedInputStream(fis);\n+            final InputStream is = new BufferedInputStream(fis);\n             try {\n                 new ArchiveStreamFactory().createArchiveInputStream(is);\n                 fail(\"created an input stream for a non-archive\");\n-            } catch (ArchiveException ae) {\n+            } catch (final ArchiveException ae) {\n                 assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n             } finally {\n                 is.close();\n \n     @Test\n     public void testCOMPRESS209() throws Exception {\n-    \tFileInputStream fis = new FileInputStream(\"src/test/resources/testCompress209.doc\");\n+    \tfinal FileInputStream fis = new FileInputStream(\"src/test/resources/testCompress209.doc\");\n     \ttry {\n-            InputStream bis = new BufferedInputStream(fis);\n+            final InputStream bis = new BufferedInputStream(fis);\n             try {\n                 new ArchiveStreamFactory().createArchiveInputStream(bis);\n                 fail(\"created an input stream for a non-archive\");\n-            } catch (ArchiveException ae) {\n+            } catch (final ArchiveException ae) {\n                 assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n             } finally {\n                 bis.close();\n      */\n     @Test\n     public void detectsAndThrowsFor7z() throws Exception {\n-    \tFileInputStream fis = new FileInputStream(\"src/test/resources/bla.7z\");\n+    \tfinal FileInputStream fis = new FileInputStream(\"src/test/resources/bla.7z\");\n     \ttry {\n-            InputStream bis = new BufferedInputStream(fis);\n+            final InputStream bis = new BufferedInputStream(fis);\n             try {\n                 new ArchiveStreamFactory().createArchiveInputStream(bis);\n                 fail(\"Expected a StreamingNotSupportedException\");\n-            } catch (StreamingNotSupportedException ex) {\n+            } catch (final StreamingNotSupportedException ex) {\n                 assertEquals(ArchiveStreamFactory.SEVEN_Z, ex.getFormat());\n             } finally {\n                 bis.close();\n      */\n     @Test\n     public void skipsPK00Prefix() throws Exception {\n-    \tFileInputStream fis = new FileInputStream(\"src/test/resources/COMPRESS-208.zip\");\n+    \tfinal FileInputStream fis = new FileInputStream(\"src/test/resources/COMPRESS-208.zip\");\n     \ttry {\n-            InputStream bis = new BufferedInputStream(fis);\n+            final InputStream bis = new BufferedInputStream(fis);\n             try {\n-                ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(bis);\n+                final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(bis);\n                 try {\n                     assertTrue(ais instanceof ZipArchiveInputStream);\n                 } finally {\n         try {\n             fac.setEntryEncoding(\"US_ASCII\");\n             fail(\"Expected IllegalStateException\");\n-        } catch (IllegalStateException ise) {\n+        } catch (final IllegalStateException ise) {\n             // expected\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\") // test of deprecated method\n     static ArchiveStreamFactory getFactory(final String entryEncoding) {\n-        ArchiveStreamFactory fac = new ArchiveStreamFactory();\n+        final ArchiveStreamFactory fac = new ArchiveStreamFactory();\n         fac.setEntryEncoding(entryEncoding);\n         return fac;\n     }\n         dflt = UNKNOWN;\n         try {\n             dflt = getField(new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\"))), \"charsetName\");\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             e.printStackTrace();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             e.printStackTrace();\n         }\n         ARJ_DEFAULT = dflt;\n         dflt = UNKNOWN;\n         try {\n             dflt = getField(new DumpArchiveInputStream(new FileInputStream(getFile(\"bla.dump\"))), \"encoding\");\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             e.printStackTrace();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             e.printStackTrace();\n         }\n         DUMP_DEFAULT = dflt;\n     public void testEncodingInputStreamAutodetect() throws Exception {\n         int failed = 0;\n         for(int i = 1; i <= TESTS.length; i++) {\n-            TestData test = TESTS[i-1];\n-            ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n+            final TestData test = TESTS[i-1];\n+            final ArchiveInputStream ais = getInputStreamFor(test.testFile, test.fac);\n             final String field = getField(ais,test.fieldName);\n             if (!eq(test.expectedEncoding,field)) {\n                 System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n     public void testEncodingInputStream() throws Exception {\n         int failed = 0;\n         for(int i = 1; i <= TESTS.length; i++) {\n-            TestData test = TESTS[i-1];\n-            ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n+            final TestData test = TESTS[i-1];\n+            final ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n             final String field = getField(ais,test.fieldName);\n             if (!eq(test.expectedEncoding,field)) {\n                 System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n     public void testEncodingOutputStream() throws Exception {\n         int failed = 0;\n         for(int i = 1; i <= TESTS.length; i++) {\n-            TestData test = TESTS[i-1];\n+            final TestData test = TESTS[i-1];\n             if (test.hasOutputStream) {\n-                ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n+                final ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac);\n                 final String field = getField(ais, test.fieldName);\n                 if (!eq(test.expectedEncoding, field)) {\n                     System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n     }\n \n     private static String getField(final Object instance, final String name) {\n-        Class<?> cls = instance.getClass();\n+        final Class<?> cls = instance.getClass();\n         Field fld;\n         try {\n             fld = cls.getDeclaredField(name);\n-        } catch (NoSuchFieldException nsfe) {\n+        } catch (final NoSuchFieldException nsfe) {\n                 try {\n                     fld = cls.getSuperclass().getDeclaredField(name);\n-                } catch (NoSuchFieldException e) {\n+                } catch (final NoSuchFieldException e) {\n                     System.out.println(\"Cannot find \" + name + \" in class \" + instance.getClass().getSimpleName());\n                     return UNKNOWN;\n                 }                \n         }\n-        boolean isAccessible = fld.isAccessible();\n+        final boolean isAccessible = fld.isAccessible();\n         try {\n             if (!isAccessible) {\n                 fld.setAccessible(true);\n             }\n             System.out.println(\"Wrong type: \" + object.getClass().getCanonicalName() + \" for \" + name + \" in class \" + instance.getClass().getSimpleName());\n             return UNKNOWN;\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             e.printStackTrace();\n             return UNKNOWN;\n         } finally {\n--- a/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n         final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n \n \n-        Map<String, File> result = new HashMap<String, File>();\n+        final Map<String, File> result = new HashMap<String, File>();\n         ArchiveEntry entry = null;\n         while ((entry = in.getNextEntry()) != null) {\n-            File cpioget = new File(dir, entry.getName());\n+            final File cpioget = new File(dir, entry.getName());\n             final OutputStream out = new FileOutputStream(cpioget);\n             IOUtils.copy(in, out);\n             out.close();\n \n     @Test\n     public void testDirectoryEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n-        File archive = null;\n-        CpioArchiveOutputStream tos = null;\n-        CpioArchiveInputStream tis = null;\n-        try {\n-            archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n-            archive.deleteOnExit();\n-            tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            CpioArchiveEntry in = new CpioArchiveEntry(tmp[0], \"foo\");\n-            tos.putArchiveEntry(in);\n-            tos.closeArchiveEntry();\n-            tos.close();\n-            tos = null;\n-            tis = new CpioArchiveInputStream(new FileInputStream(archive));\n-            CpioArchiveEntry out = tis.getNextCPIOEntry();\n+        final File[] tmp = createTempDirAndFile();\n+        File archive = null;\n+        CpioArchiveOutputStream tos = null;\n+        CpioArchiveInputStream tis = null;\n+        try {\n+            archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n+            archive.deleteOnExit();\n+            tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final CpioArchiveEntry in = new CpioArchiveEntry(tmp[0], \"foo\");\n+            tos.putArchiveEntry(in);\n+            tos.closeArchiveEntry();\n+            tos.close();\n+            tos = null;\n+            tis = new CpioArchiveInputStream(new FileInputStream(archive));\n+            final CpioArchiveEntry out = tis.getNextCPIOEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testExplicitDirectoryEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n-        File archive = null;\n-        CpioArchiveOutputStream tos = null;\n-        CpioArchiveInputStream tis = null;\n-        try {\n-            archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n-            archive.deleteOnExit();\n-            tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            CpioArchiveEntry in = new CpioArchiveEntry(\"foo/\");\n+        final File[] tmp = createTempDirAndFile();\n+        File archive = null;\n+        CpioArchiveOutputStream tos = null;\n+        CpioArchiveInputStream tis = null;\n+        try {\n+            archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n+            archive.deleteOnExit();\n+            tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final CpioArchiveEntry in = new CpioArchiveEntry(\"foo/\");\n             in.setTime(beforeArchiveWrite / 1000);\n             in.setMode(CpioConstants.C_ISDIR);\n             tos.putArchiveEntry(in);\n             tos.close();\n             tos = null;\n             tis = new CpioArchiveInputStream(new FileInputStream(archive));\n-            CpioArchiveEntry out = tis.getNextCPIOEntry();\n+            final CpioArchiveEntry out = tis.getNextCPIOEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testFileEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         CpioArchiveOutputStream tos = null;\n         CpioArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n-            CpioArchiveEntry in = new CpioArchiveEntry(tmp[1], \"foo\");\n-            tos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final CpioArchiveEntry in = new CpioArchiveEntry(tmp[1], \"foo\");\n+            tos.putArchiveEntry(in);\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 tos.write(b);\n             tos.close();\n             tos = null;\n             tis = new CpioArchiveInputStream(new FileInputStream(archive));\n-            CpioArchiveEntry out = tis.getNextCPIOEntry();\n+            final CpioArchiveEntry out = tis.getNextCPIOEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testExplicitFileEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         CpioArchiveOutputStream tos = null;\n         CpioArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".cpio\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new CpioArchiveOutputStream(new FileOutputStream(archive));\n-            CpioArchiveEntry in = new CpioArchiveEntry(\"foo\");\n+            final CpioArchiveEntry in = new CpioArchiveEntry(\"foo\");\n             in.setTime(tmp[1].lastModified() / 1000);\n             in.setSize(tmp[1].length());\n             in.setMode(CpioConstants.C_ISREG);\n             tos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 tos.write(b);\n             tos.close();\n             tos = null;\n             tis = new CpioArchiveInputStream(new FileInputStream(archive));\n-            CpioArchiveEntry out = tis.getNextCPIOEntry();\n+            final CpioArchiveEntry out = tis.getNextCPIOEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n--- a/src/test/java/org/apache/commons/compress/archivers/DumpTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/DumpTestCase.java\n \n             ArchiveEntry entry = in.getNextEntry();\n             while (entry != null) {\n-                File archiveEntry = new File(dir, entry.getName());\n+                final File archiveEntry = new File(dir, entry.getName());\n                 archiveEntry.getParentFile().mkdirs();\n                 if (entry.isDirectory()) {\n                     archiveEntry.mkdir();\n     }\n \n     private void checkDumpArchive(final File f) throws Exception {\n-        ArrayList<String> expected = new ArrayList<String>();\n+        final ArrayList<String> expected = new ArrayList<String>();\n         expected.add(\"\");\n         expected.add(\"lost+found/\");\n         expected.add(\"test1.xml\");\n--- a/src/test/java/org/apache/commons/compress/archivers/ExceptionMessageTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ExceptionMessageTest.java\n         try{\n             new ArchiveStreamFactory().createArchiveInputStream(null, System.in);\n             fail(\"Should raise an IllegalArgumentException.\");\n-        }catch (IllegalArgumentException e) {\n+        }catch (final IllegalArgumentException e) {\n             assertEquals(ARCHIVER_NULL_MESSAGE, e.getMessage());\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             fail(\"ArchiveException not expected\");\n         }\n     }\n         try{\n             new ArchiveStreamFactory().createArchiveInputStream(\"zip\", null);\n             fail(\"Should raise an IllegalArgumentException.\");\n-        }catch (IllegalArgumentException e) {\n+        }catch (final IllegalArgumentException e) {\n             assertEquals(INPUTSTREAM_NULL_MESSAGE, e.getMessage());\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             fail(\"ArchiveException not expected\");\n         }\n     }\n         try{\n             new ArchiveStreamFactory().createArchiveOutputStream(null, System.out);\n             fail(\"Should raise an IllegalArgumentException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(ARCHIVER_NULL_MESSAGE, e.getMessage());\n-        } catch (ArchiveException e){\n+        } catch (final ArchiveException e){\n             fail(\"ArchiveException not expected\");\n         }\n     }\n         try{\n             new ArchiveStreamFactory().createArchiveOutputStream(\"zip\", null);\n             fail(\"Should raise an IllegalArgumentException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(OUTPUTSTREAM_NULL_MESSAGE, e.getMessage());\n-        } catch (ArchiveException e) {\n+        } catch (final ArchiveException e) {\n             fail(\"ArchiveException not expected\");\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n \n         ArchiveEntry entry = in.getNextEntry();\n         while (entry != null) {\n-            File archiveEntry = new File(dir, entry.getName());\n+            final File archiveEntry = new File(dir, entry.getName());\n             archiveEntry.getParentFile().mkdirs();\n             if(entry.isDirectory()){\n                 archiveEntry.mkdir();\n                 entry = in.getNextEntry();\n                 continue;\n             }\n-            OutputStream out = new FileOutputStream(archiveEntry);\n+            final OutputStream out = new FileOutputStream(archiveEntry);\n             IOUtils.copy(in, out);\n             out.close();\n             entry = in.getNextEntry();\n--- a/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongPathTest.java\n     @BeforeClass\n     public static void setUpFileList() throws Exception {\n         assertTrue(ARCDIR.exists());\n-        File listing= new File(ARCDIR,\"files.txt\");\n+        final File listing= new File(ARCDIR,\"files.txt\");\n         assertTrue(\"files.txt is readable\",listing.canRead());\n-        BufferedReader br = new BufferedReader(new FileReader(listing));\n+        final BufferedReader br = new BufferedReader(new FileReader(listing));\n         String line;\n         while ((line=br.readLine())!=null){\n             if (!line.startsWith(\"#\")){\n \n     @Parameters(name = \"file={0}\")\n     public static Collection<Object[]> data() {\n-        Collection<Object[]> params = new ArrayList<Object[]>();\n-        for (String f : ARCDIR.list(new FilenameFilter() {\n+        final Collection<Object[]> params = new ArrayList<Object[]>();\n+        for (final String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n             public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n     @Override\n     protected String getExpectedString(final ArchiveEntry entry) {\n         if (entry instanceof TarArchiveEntry) {\n-            TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n+            final TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n             if (tarEntry.isSymbolicLink()) {\n                 return tarEntry.getName() + \" -> \" + tarEntry.getLinkName();\n             }\n     @Test\n     public void testArchive() throws Exception {\n         @SuppressWarnings(\"unchecked\") // fileList is of correct type\n+        final\n         ArrayList<String> expected = (ArrayList<String>) FILELIST.clone();\n-        String name = file.getName();\n+        final String name = file.getName();\n         if (\"minotaur.jar\".equals(name) || \"minotaur-0.jar\".equals(name)){\n             expected.add(\"META-INF/\");\n             expected.add(\"META-INF/MANIFEST.MF\");\n         }\n-        ArchiveInputStream ais = factory.createArchiveInputStream(new BufferedInputStream(new FileInputStream(file)));\n+        final ArchiveInputStream ais = factory.createArchiveInputStream(new BufferedInputStream(new FileInputStream(file)));\n         // check if expected type recognised\n         if (name.endsWith(\".tar\")){\n             assertTrue(ais instanceof TarArchiveInputStream);\n             assertTrue(ais instanceof CpioArchiveInputStream);\n             // Hack: cpio does not add trailing \"/\" to directory names\n             for(int i=0; i < expected.size(); i++){\n-                String ent = expected.get(i);\n+                final String ent = expected.get(i);\n                 if (ent.endsWith(\"/\")){\n                     expected.set(i, ent.substring(0, ent.length()-1));\n                 }\n             assertTrue(ais instanceof ArArchiveInputStream);\n             // CPIO does not store directories or directory names\n             expected.clear();\n-            for (String ent : FILELIST) {\n+            for (final String ent : FILELIST) {\n                 if (!ent.endsWith(\"/\")) {// not a directory\n                     final int lastSlash = ent.lastIndexOf('/');\n                     if (lastSlash >= 0) { // extract path name\n         }\n         try {\n             checkArchiveContent(ais, expected);\n-        } catch (AssertionFailedError e) {\n+        } catch (final AssertionFailedError e) {\n             fail(\"Error processing \"+file.getName()+\" \"+e);\n         } finally {\n             ais.close();\n--- a/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/LongSymLinkTest.java\n     @BeforeClass\n     public static void setUpFileList() throws Exception {\n         assertTrue(ARCDIR.exists());\n-        File listing= new File(ARCDIR,\"files.txt\");\n+        final File listing= new File(ARCDIR,\"files.txt\");\n         assertTrue(\"files.txt is readable\",listing.canRead());\n-        BufferedReader br = new BufferedReader(new FileReader(listing));\n+        final BufferedReader br = new BufferedReader(new FileReader(listing));\n         String line;\n         while ((line=br.readLine())!=null){\n             if (!line.startsWith(\"#\")){\n \n     @Parameters(name = \"file={0}\")\n     public static Collection<Object[]> data() {\n-        Collection<Object[]> params = new ArrayList<Object[]>();\n-        for (String f : ARCDIR.list(new FilenameFilter() {\n+        final Collection<Object[]> params = new ArrayList<Object[]>();\n+        for (final String f : ARCDIR.list(new FilenameFilter() {\n             @Override\n             public boolean accept(final File dir, final String name) {\n                 return !name.endsWith(\".txt\");\n     @Override\n     protected String getExpectedString(final ArchiveEntry entry) {\n         if (entry instanceof TarArchiveEntry) {\n-            TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n+            final TarArchiveEntry tarEntry = (TarArchiveEntry) entry;\n             if (tarEntry.isSymbolicLink()) {\n                 return tarEntry.getName() + \" -> \" + tarEntry.getLinkName();\n             }\n     @Test\n     public void testArchive() throws Exception {\n         @SuppressWarnings(\"unchecked\") // fileList is of correct type\n+        final\n         ArrayList<String> expected = (ArrayList<String>) FILELIST.clone();\n-        String name = file.getName();\n+        final String name = file.getName();\n         if (\"minotaur.jar\".equals(name) || \"minotaur-0.jar\".equals(name)){\n             expected.add(\"META-INF/\");\n             expected.add(\"META-INF/MANIFEST.MF\");\n         }\n-        ArchiveInputStream ais = factory.createArchiveInputStream(new BufferedInputStream(new FileInputStream(file)));\n+        final ArchiveInputStream ais = factory.createArchiveInputStream(new BufferedInputStream(new FileInputStream(file)));\n         // check if expected type recognised\n         if (name.endsWith(\".tar\")){\n             assertTrue(ais instanceof TarArchiveInputStream);\n             assertTrue(ais instanceof CpioArchiveInputStream);\n             // Hack: cpio does not add trailing \"/\" to directory names\n             for(int i=0; i < expected.size(); i++){\n-                String ent = expected.get(i);\n+                final String ent = expected.get(i);\n                 if (ent.endsWith(\"/\")){\n                     expected.set(i, ent.substring(0, ent.length()-1));\n                 }\n             assertTrue(ais instanceof ArArchiveInputStream);\n             // CPIO does not store directories or directory names\n             expected.clear();\n-            for (String ent : FILELIST) {\n+            for (final String ent : FILELIST) {\n                 if (!ent.endsWith(\"/\")) {// not a directory\n                     final int lastSlash = ent.lastIndexOf('/');\n                     if (lastSlash >= 0) { // extract path name\n         }\n         try {\n             checkArchiveContent(ais, expected);\n-        } catch (AssertionFailedError e) {\n+        } catch (final AssertionFailedError e) {\n             fail(\"Error processing \"+file.getName()+\" \"+e);\n         } finally {\n             ais.close();\n--- a/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n \n     @Test\n     public void testTarArchiveLongNameCreation() throws Exception {\n-        String name = \"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\";\n-        byte[] bytes = name.getBytes(CharsetNames.UTF_8);\n+        final String name = \"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\";\n+        final byte[] bytes = name.getBytes(CharsetNames.UTF_8);\n         assertEquals(bytes.length, 99);\n \n         final File output = new File(dir, \"bla.tar\");\n         entry.setGroupName(\"excalibur\");\n         entry.setMode(0100000);\n         os.putArchiveEntry(entry);\n-        FileInputStream in = new FileInputStream(file1);\n+        final FileInputStream in = new FileInputStream(file1);\n         IOUtils.copy(in, os);\n         os.closeArchiveEntry();\n         os.close();\n \n         ArchiveOutputStream os2 = null;\n         try {\n-            String toLongName = \"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\";\n+            final String toLongName = \"testdata/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.xml\";\n             final File output2 = new File(dir, \"bla.tar\");\n             final OutputStream out2 = new FileOutputStream(output2);\n             os2 = new ArchiveStreamFactory().createArchiveOutputStream(\"tar\", out2);\n             os2.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file1), os2);\n             os2.closeArchiveEntry();\n-        } catch(IOException e) {\n+        } catch(final IOException e) {\n             assertTrue(true);\n         } finally {\n             if (os2 != null){\n \n     @Test\n     public void testDirectoryEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         TarArchiveOutputStream tos = null;\n         TarArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".tar\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new TarArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            TarArchiveEntry in = new TarArchiveEntry(tmp[0], \"foo\");\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final TarArchiveEntry in = new TarArchiveEntry(tmp[0], \"foo\");\n             tos.putArchiveEntry(in);\n             tos.closeArchiveEntry();\n             tos.close();\n             tos = null;\n             tis = new TarArchiveInputStream(new FileInputStream(archive));\n-            TarArchiveEntry out = tis.getNextTarEntry();\n+            final TarArchiveEntry out = tis.getNextTarEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testExplicitDirectoryEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         TarArchiveOutputStream tos = null;\n         TarArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".tar\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new TarArchiveOutputStream(new FileOutputStream(archive));\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            TarArchiveEntry in = new TarArchiveEntry(\"foo/\");\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final TarArchiveEntry in = new TarArchiveEntry(\"foo/\");\n             in.setModTime(beforeArchiveWrite);\n             tos.putArchiveEntry(in);\n             tos.closeArchiveEntry();\n             tos.close();\n             tos = null;\n             tis = new TarArchiveInputStream(new FileInputStream(archive));\n-            TarArchiveEntry out = tis.getNextTarEntry();\n+            final TarArchiveEntry out = tis.getNextTarEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testFileEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         TarArchiveOutputStream tos = null;\n         TarArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".tar\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new TarArchiveOutputStream(new FileOutputStream(archive));\n-            TarArchiveEntry in = new TarArchiveEntry(tmp[1], \"foo\");\n+            final TarArchiveEntry in = new TarArchiveEntry(tmp[1], \"foo\");\n             tos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 tos.write(b);\n             tos.close();\n             tos = null;\n             tis = new TarArchiveInputStream(new FileInputStream(archive));\n-            TarArchiveEntry out = tis.getNextTarEntry();\n+            final TarArchiveEntry out = tis.getNextTarEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n \n     @Test\n     public void testExplicitFileEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         TarArchiveOutputStream tos = null;\n         TarArchiveInputStream tis = null;\n             archive = File.createTempFile(\"test.\", \".tar\", tmp[0]);\n             archive.deleteOnExit();\n             tos = new TarArchiveOutputStream(new FileOutputStream(archive));\n-            TarArchiveEntry in = new TarArchiveEntry(\"foo\");\n+            final TarArchiveEntry in = new TarArchiveEntry(\"foo\");\n             in.setModTime(tmp[1].lastModified());\n             in.setSize(tmp[1].length());\n             tos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 tos.write(b);\n             tos.close();\n             tos = null;\n             tis = new TarArchiveInputStream(new FileInputStream(archive));\n-            TarArchiveEntry out = tis.getNextTarEntry();\n+            final TarArchiveEntry out = tis.getNextTarEntry();\n             tis.close();\n             tis = null;\n             assertNotNull(out);\n         try {\n             in.getNextEntry();\n             fail(\"Expected IOException\");\n-        } catch (IOException e) {\n-            Throwable t = e.getCause();\n+        } catch (final IOException e) {\n+            final Throwable t = e.getCause();\n             assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n         }\n         in.close();\n--- a/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ZipTestCase.java\n         out.close();\n \n         // Unarchive the same\n-        List<File> results = new ArrayList<File>();\n+        final List<File> results = new ArrayList<File>();\n \n         final InputStream is = new FileInputStream(output);\n         ArchiveInputStream in = null;\n \n             ZipArchiveEntry entry = null;\n             while((entry = (ZipArchiveEntry)in.getNextEntry()) != null) {\n-                File outfile = new File(resultDir.getCanonicalPath() + \"/result/\" + entry.getName());\n+                final File outfile = new File(resultDir.getCanonicalPath() + \"/result/\" + entry.getName());\n                 outfile.getParentFile().mkdirs();\n-                OutputStream o = new FileOutputStream(outfile);\n+                final OutputStream o = new FileOutputStream(outfile);\n                 try {\n                     IOUtils.copy(in, o);\n                 } finally {\n     @Test\n     public void testSkipsPK00Prefix() throws Exception {\n         final File input = getFile(\"COMPRESS-208.zip\");\n-        InputStream is = new FileInputStream(input);\n-        ArrayList<String> al = new ArrayList<String>();\n+        final InputStream is = new FileInputStream(input);\n+        final ArrayList<String> al = new ArrayList<String>();\n         al.add(\"test1.xml\");\n         al.add(\"test2.xml\");\n         try {\n         bla.close();\n         */\n         \n-        ZipFile moby = new ZipFile(getFile(\"moby.zip\"));\n-        ZipArchiveEntry entry = moby.getEntry(\"README\");\n+        final ZipFile moby = new ZipFile(getFile(\"moby.zip\"));\n+        final ZipArchiveEntry entry = moby.getEntry(\"README\");\n         assertEquals(\"method\", ZipMethod.TOKENIZATION.getCode(), entry.getMethod());\n         assertFalse(moby.canReadEntryData(entry));\n         moby.close();\n     @Test\n     public void testSkipEntryWithUnsupportedCompressionMethod()\n             throws IOException {\n-        ZipArchiveInputStream zip =\n+        final ZipArchiveInputStream zip =\n             new ZipArchiveInputStream(new FileInputStream(getFile(\"moby.zip\")));\n         try {\n-            ZipArchiveEntry entry = zip.getNextZipEntry();\n+            final ZipArchiveEntry entry = zip.getNextZipEntry();\n             assertEquals(\"method\", ZipMethod.TOKENIZATION.getCode(), entry.getMethod());\n             assertEquals(\"README\", entry.getName());\n             assertFalse(zip.canReadEntryData(entry));\n             try {\n                 assertNull(zip.getNextZipEntry());\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n                 e.printStackTrace();\n                 fail(\"COMPRESS-93: Unable to skip an unsupported zip entry\");\n             }\n     public void testListAllFilesWithNestedArchive() throws Exception {\n         final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n \n-        List<String> results = new ArrayList<String>();\n+        final List<String> results = new ArrayList<String>();\n \n         final InputStream is = new FileInputStream(input);\n         ArchiveInputStream in = null;\n             while((entry = (ZipArchiveEntry)in.getNextEntry()) != null) {\n                 results.add(entry.getName());\n \n-                ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n+                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n                 ZipArchiveEntry nestedEntry = null;\n                 while((nestedEntry = (ZipArchiveEntry)nestedIn.getNextEntry()) != null) {\n                     results.add(nestedEntry.getName());\n \n     @Test\n     public void testDirectoryEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ZipArchiveOutputStream zos = null;\n         ZipFile zf = null;\n             archive = File.createTempFile(\"test.\", \".zip\", tmp[0]);\n             archive.deleteOnExit();\n             zos = new ZipArchiveOutputStream(archive);\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            ZipArchiveEntry in = new ZipArchiveEntry(tmp[0], \"foo\");\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final ZipArchiveEntry in = new ZipArchiveEntry(tmp[0], \"foo\");\n             zos.putArchiveEntry(in);\n             zos.closeArchiveEntry();\n             zos.close();\n             zos = null;\n             zf = new ZipFile(archive);\n-            ZipArchiveEntry out = zf.getEntry(\"foo/\");\n+            final ZipArchiveEntry out = zf.getEntry(\"foo/\");\n             assertNotNull(out);\n             assertEquals(\"foo/\", out.getName());\n             assertEquals(0, out.getSize());\n \n     @Test\n     public void testExplicitDirectoryEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ZipArchiveOutputStream zos = null;\n         ZipFile zf = null;\n             archive = File.createTempFile(\"test.\", \".zip\", tmp[0]);\n             archive.deleteOnExit();\n             zos = new ZipArchiveOutputStream(archive);\n-            long beforeArchiveWrite = tmp[0].lastModified();\n-            ZipArchiveEntry in = new ZipArchiveEntry(\"foo/\");\n+            final long beforeArchiveWrite = tmp[0].lastModified();\n+            final ZipArchiveEntry in = new ZipArchiveEntry(\"foo/\");\n             in.setTime(beforeArchiveWrite);\n             zos.putArchiveEntry(in);\n             zos.closeArchiveEntry();\n             zos.close();\n             zos = null;\n             zf = new ZipFile(archive);\n-            ZipArchiveEntry out = zf.getEntry(\"foo/\");\n+            final ZipArchiveEntry out = zf.getEntry(\"foo/\");\n             assertNotNull(out);\n             assertEquals(\"foo/\", out.getName());\n             assertEquals(0, out.getSize());\n     public void testCopyRawEntriesFromFile()\n             throws IOException {\n \n-        File[] tmp = createTempDirAndFile();\n-        File reference = createReferenceFile(tmp[0], Zip64Mode.Never, \"expected.\");\n-\n-        File a1 = File.createTempFile(\"src1.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n+        final File[] tmp = createTempDirAndFile();\n+        final File reference = createReferenceFile(tmp[0], Zip64Mode.Never, \"expected.\");\n+\n+        final File a1 = File.createTempFile(\"src1.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n         zos.setUseZip64(Zip64Mode.Never);\n         createFirstEntry(zos).close();\n \n-        File a2 = File.createTempFile(\"src2.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(a2);\n+        final File a2 = File.createTempFile(\"src2.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(a2);\n         zos1.setUseZip64(Zip64Mode.Never);\n         createSecondEntry(zos1).close();\n \n-        ZipFile zf1 = new ZipFile(a1);\n-        ZipFile zf2 = new ZipFile(a2);\n-        File fileResult = File.createTempFile(\"file-actual.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult);\n+        final ZipFile zf1 = new ZipFile(a1);\n+        final ZipFile zf2 = new ZipFile(a2);\n+        final File fileResult = File.createTempFile(\"file-actual.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult);\n         zf1.copyRawEntries(zos2, allFilesPredicate);\n         zf2.copyRawEntries(zos2, allFilesPredicate);\n         zos2.close();\n     public void testCopyRawZip64EntryFromFile()\n             throws IOException {\n \n-        File[] tmp = createTempDirAndFile();\n-        File reference = File.createTempFile(\"z64reference.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(reference);\n+        final File[] tmp = createTempDirAndFile();\n+        final File reference = File.createTempFile(\"z64reference.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos1 = new ZipArchiveOutputStream(reference);\n         zos1.setUseZip64(Zip64Mode.Always);\n         createFirstEntry(zos1);\n         zos1.close();\n \n-        File a1 = File.createTempFile(\"zip64src.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n+        final File a1 = File.createTempFile(\"zip64src.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n         zos.setUseZip64(Zip64Mode.Always);\n         createFirstEntry(zos).close();\n \n-        ZipFile zf1 = new ZipFile(a1);\n-        File fileResult = File.createTempFile(\"file-actual.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult);\n+        final ZipFile zf1 = new ZipFile(a1);\n+        final File fileResult = File.createTempFile(\"file-actual.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos2 = new ZipArchiveOutputStream(fileResult);\n         zos2.setUseZip64(Zip64Mode.Always);\n         zf1.copyRawEntries(zos2, allFilesPredicate);\n         zos2.close();\n     @Test\n     public void testUnixModeInAddRaw() throws IOException {\n \n-        File[] tmp = createTempDirAndFile();\n-\n-        File a1 = File.createTempFile(\"unixModeBits.\", \".zip\", tmp[0]);\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n-\n-        ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\n+        final File[] tmp = createTempDirAndFile();\n+\n+        final File a1 = File.createTempFile(\"unixModeBits.\", \".zip\", tmp[0]);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1);\n+\n+        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\n         archiveEntry.setUnixMode(0664);\n         archiveEntry.setMethod(ZipEntry.DEFLATED);\n         zos.addRawArchiveEntry(archiveEntry, new ByteArrayInputStream(\"fud\".getBytes()));\n         zos.close();\n \n-        ZipFile zf1 = new ZipFile(a1);\n-        ZipArchiveEntry fred = zf1.getEntry(\"fred\");\n+        final ZipFile zf1 = new ZipFile(a1);\n+        final ZipArchiveEntry fred = zf1.getEntry(\"fred\");\n         assertEquals(0664, fred.getUnixMode());\n         zf1.close();\n     }\n \n     private File createReferenceFile(final File directory, final Zip64Mode zipMode, final String prefix) throws IOException {\n-        File reference = File.createTempFile(prefix, \".zip\", directory);\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(reference);\n+        final File reference = File.createTempFile(prefix, \".zip\", directory);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(reference);\n         zos.setUseZip64(zipMode);\n         createFirstEntry(zos);\n         createSecondEntry(zos);\n \n \n     private void assertSameFileContents(final File expectedFile, final File actualFile) throws IOException {\n-        int size = (int) Math.max(expectedFile.length(), actualFile.length());\n-        ZipFile expected = new ZipFile(expectedFile);\n-        ZipFile actual = new ZipFile(actualFile);\n-        byte[] expectedBuf = new byte[size];\n-        byte[] actualBuf = new byte[size];\n-\n-        Enumeration<ZipArchiveEntry> actualInOrder = actual.getEntriesInPhysicalOrder();\n-        Enumeration<ZipArchiveEntry> expectedInOrder = expected.getEntriesInPhysicalOrder();\n+        final int size = (int) Math.max(expectedFile.length(), actualFile.length());\n+        final ZipFile expected = new ZipFile(expectedFile);\n+        final ZipFile actual = new ZipFile(actualFile);\n+        final byte[] expectedBuf = new byte[size];\n+        final byte[] actualBuf = new byte[size];\n+\n+        final Enumeration<ZipArchiveEntry> actualInOrder = actual.getEntriesInPhysicalOrder();\n+        final Enumeration<ZipArchiveEntry> expectedInOrder = expected.getEntriesInPhysicalOrder();\n \n         while (actualInOrder.hasMoreElements()){\n-            ZipArchiveEntry actualElement = actualInOrder.nextElement();\n-            ZipArchiveEntry expectedElement = expectedInOrder.nextElement();\n+            final ZipArchiveEntry actualElement = actualInOrder.nextElement();\n+            final ZipArchiveEntry expectedElement = expectedInOrder.nextElement();\n             assertEquals( expectedElement.getName(), actualElement.getName());\n             // Don't compare timestamps since they may vary;\n             // there's no support for stubbed out clock (TimeSource) in ZipArchiveOutputStream\n             assertEquals( expectedElement.getExternalAttributes(), actualElement.getExternalAttributes());\n             assertEquals( expectedElement.getInternalAttributes(), actualElement.getInternalAttributes());\n \n-            InputStream actualIs = actual.getInputStream(actualElement);\n-            InputStream expectedIs = expected.getInputStream(expectedElement);\n+            final InputStream actualIs = actual.getInputStream(actualElement);\n+            final InputStream expectedIs = expected.getInputStream(expectedElement);\n             IOUtils.readFully(expectedIs, expectedBuf);\n             IOUtils.readFully(actualIs, actualBuf);\n             expectedIs.close();\n \n     private void createArchiveEntry(final String payload, final ZipArchiveOutputStream zos, final String name)\n             throws IOException {\n-        ZipArchiveEntry in = new ZipArchiveEntry(name);\n+        final ZipArchiveEntry in = new ZipArchiveEntry(name);\n         zos.putArchiveEntry(in);\n \n         zos.write(payload.getBytes());\n \n     @Test\n     public void testFileEntryFromFile() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ZipArchiveOutputStream zos = null;\n         ZipFile zf = null;\n             archive = File.createTempFile(\"test.\", \".zip\", tmp[0]);\n             archive.deleteOnExit();\n             zos = new ZipArchiveOutputStream(archive);\n-            ZipArchiveEntry in = new ZipArchiveEntry(tmp[1], \"foo\");\n+            final ZipArchiveEntry in = new ZipArchiveEntry(tmp[1], \"foo\");\n             zos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 zos.write(b);\n             zos.close();\n             zos = null;\n             zf = new ZipFile(archive);\n-            ZipArchiveEntry out = zf.getEntry(\"foo\");\n+            final ZipArchiveEntry out = zf.getEntry(\"foo\");\n             assertNotNull(out);\n             assertEquals(\"foo\", out.getName());\n             assertEquals(tmp[1].length(), out.getSize());\n \n     @Test\n     public void testExplicitFileEntry() throws Exception {\n-        File[] tmp = createTempDirAndFile();\n+        final File[] tmp = createTempDirAndFile();\n         File archive = null;\n         ZipArchiveOutputStream zos = null;\n         ZipFile zf = null;\n             archive = File.createTempFile(\"test.\", \".zip\", tmp[0]);\n             archive.deleteOnExit();\n             zos = new ZipArchiveOutputStream(archive);\n-            ZipArchiveEntry in = new ZipArchiveEntry(\"foo\");\n+            final ZipArchiveEntry in = new ZipArchiveEntry(\"foo\");\n             in.setTime(tmp[1].lastModified());\n             in.setSize(tmp[1].length());\n             zos.putArchiveEntry(in);\n-            byte[] b = new byte[(int) tmp[1].length()];\n+            final byte[] b = new byte[(int) tmp[1].length()];\n             fis = new FileInputStream(tmp[1]);\n             while (fis.read(b) > 0) {\n                 zos.write(b);\n             zos.close();\n             zos = null;\n             zf = new ZipFile(archive);\n-            ZipArchiveEntry out = zf.getEntry(\"foo\");\n+            final ZipArchiveEntry out = zf.getEntry(\"foo\");\n             assertNotNull(out);\n             assertEquals(\"foo\", out.getName());\n             assertEquals(tmp[1].length(), out.getSize());\n--- a/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n     }\n \n     private void checkLongNameEntry(final String archive) throws Exception {\n-        FileInputStream fis = new FileInputStream(getFile(archive));\n+        final FileInputStream fis = new FileInputStream(getFile(archive));\n         ArArchiveInputStream s = null;\n         try {\n             s = new ArArchiveInputStream(new BufferedInputStream(fis));\n             ArchiveEntry e = s.getNextEntry();\n             assertEquals(\"this_is_a_long_file_name.txt\", e.getName());\n             assertEquals(14, e.getSize());\n-            byte[] hello = new byte[14];\n+            final byte[] hello = new byte[14];\n             s.read(hello);\n             assertEquals(\"Hello, world!\\n\", ArchiveUtils.toAsciiString(hello));\n             e = s.getNextEntry();\n             assertEquals(\"this_is_a_long_file_name_as_well.txt\", e.getName());\n             assertEquals(4, e.getSize());\n-            byte[] bye = new byte[4];\n+            final byte[] bye = new byte[4];\n             s.read(bye);\n             assertEquals(\"Bye\\n\", ArchiveUtils.toAsciiString(bye));\n             assertNull(s.getNextEntry());\n--- a/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStreamTest.java\n         ArArchiveOutputStream os = null;\n         try {\n             os = new ArArchiveOutputStream(new ByteArrayOutputStream());\n-            ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\",\n+            final ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\",\n                                                    0);\n             os.putArchiveEntry(ae);\n             fail(\"Expected an exception\");\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             assertTrue(ex.getMessage().startsWith(\"filename too long\"));\n         } finally {\n             closeQuietly(os);\n     public void testLongFileNamesWorkUsingBSDDialect() throws Exception {\n         FileOutputStream fos = null;\n         ArArchiveOutputStream os = null;\n-        File[] df = createTempDirAndFile();\n+        final File[] df = createTempDirAndFile();\n         try {\n             fos = new FileOutputStream(df[1]);\n             os = new ArArchiveOutputStream(fos);\n             os.setLongFileMode(ArArchiveOutputStream.LONGFILE_BSD);\n-            ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\",\n+            final ArArchiveEntry ae = new ArArchiveEntry(\"this_is_a_long_name.txt\",\n                                                    14);\n             os.putArchiveEntry(ae);\n             os.write(new byte[] {\n             os = null;\n             fos = null;\n \n-            List<String> expected = new ArrayList<String>();\n+            final List<String> expected = new ArrayList<String>();\n             expected.add(\"this_is_a_long_name.txt\");\n             checkArchiveContent(df[1], expected);\n         } finally {\n--- a/src/test/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStreamTest.java\n \n     @Test\n     public void testArjUnarchive() throws Exception {\n-        StringBuilder expected = new StringBuilder();\n+        final StringBuilder expected = new StringBuilder();\n         expected.append(\"test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>\\n\");\n \n \n-        ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\")));\n+        final ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\")));\n         ArjArchiveEntry entry;\n \n-        StringBuilder result = new StringBuilder();\n+        final StringBuilder result = new StringBuilder();\n         while ((entry = in.getNextEntry()) != null) {\n             result.append(entry.getName());\n             int tmp;\n \n     @Test\n     public void testReadingOfAttributesDosVersion() throws Exception {\n-        ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\")));\n-        ArjArchiveEntry entry = in.getNextEntry();\n+        final ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.arj\")));\n+        final ArjArchiveEntry entry = in.getNextEntry();\n         assertEquals(\"test1.xml\", entry.getName());\n         assertEquals(30, entry.getSize());\n         assertEquals(0, entry.getUnixMode());\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2008, 9, 6, 23, 50, 52);\n         cal.set(Calendar.MILLISECOND, 0);\n         assertEquals(cal.getTime(), entry.getLastModifiedDate());\n \n     @Test\n     public void testReadingOfAttributesUnixVersion() throws Exception {\n-        ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.unix.arj\")));\n-        ArjArchiveEntry entry = in.getNextEntry();\n+        final ArjArchiveInputStream in = new ArjArchiveInputStream(new FileInputStream(getFile(\"bla.unix.arj\")));\n+        final ArjArchiveEntry entry = in.getNextEntry();\n         assertEquals(\"test1.xml\", entry.getName());\n         assertEquals(30, entry.getSize());\n         assertEquals(0664, entry.getUnixMode() & 07777 /* UnixStat.PERM_MASK */);\n-        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+0000\"));\n+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+0000\"));\n         cal.set(2008, 9, 6, 21, 50, 52);\n         cal.set(Calendar.MILLISECOND, 0);\n         assertEquals(cal.getTime(), entry.getLastModifiedDate());\n--- a/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStreamTest.java\n \n     @Test\n     public void testCpioUnarchive() throws Exception {\n-        StringBuilder expected = new StringBuilder();\n+        final StringBuilder expected = new StringBuilder();\n         expected.append(\"./test1.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>./test2.xml<?xml version=\\\"1.0\\\"?>\\n\");\n         expected.append(\"<empty/>\\n\");\n \n \n-        CpioArchiveInputStream in = new CpioArchiveInputStream(new FileInputStream(getFile(\"bla.cpio\")));\n+        final CpioArchiveInputStream in = new CpioArchiveInputStream(new FileInputStream(getFile(\"bla.cpio\")));\n         CpioArchiveEntry entry;\n \n-        StringBuilder result = new StringBuilder();\n+        final StringBuilder result = new StringBuilder();\n         while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n             result.append(entry.getName());\n             int tmp;\n \n     @Test\n     public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n-        CpioArchiveInputStream in =\n+        final CpioArchiveInputStream in =\n             new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n         CpioArchiveEntry entry= null;\n \n--- a/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStreamTest.java\n \n         try {\n             in = new CpioArchiveInputStream(new FileInputStream(output));\n-            CpioArchiveEntry e = ((CpioArchiveInputStream) in)\n+            final CpioArchiveEntry e = ((CpioArchiveInputStream) in)\n                 .getNextCPIOEntry();\n             assertEquals(\"test1.xml\", e.getName());\n             assertNull(((CpioArchiveInputStream) in).getNextEntry());\n--- a/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntryTest.java\n public class DumpArchiveEntryTest {\n     @Test\n     public void publicNameAddsTrailingSlashForDirectories() {\n-        DumpArchiveEntry ent = new DumpArchiveEntry(\"foo\", \"bar\", -1,\n+        final DumpArchiveEntry ent = new DumpArchiveEntry(\"foo\", \"bar\", -1,\n                                                     DumpArchiveEntry.TYPE\n                                                     .DIRECTORY);\n         assertEquals(\"bar\", ent.getSimpleName());\n \n     @Test\n     public void publicNameRemovesLeadingDotSlash() {\n-        DumpArchiveEntry ent = new DumpArchiveEntry(\"./foo\", \"bar\");\n+        final DumpArchiveEntry ent = new DumpArchiveEntry(\"./foo\", \"bar\");\n         assertEquals(\"bar\", ent.getSimpleName());\n         assertEquals(\"./foo\", ent.getOriginalName());\n         assertEquals(\"foo\", ent.getName());\n--- a/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStreamTest.java\n \n     @Test\n     public void testNotADumpArchive() throws Exception {\n-        FileInputStream is = new FileInputStream(getFile(\"bla.zip\"));\n+        final FileInputStream is = new FileInputStream(getFile(\"bla.zip\"));\n         try {\n             new DumpArchiveInputStream(is);\n             fail(\"expected an exception\");\n-        } catch (ArchiveException ex) {\n+        } catch (final ArchiveException ex) {\n             // expected\n             assertTrue(ex.getCause() instanceof ShortFileException);\n         } finally {\n \n     @Test\n     public void testNotADumpArchiveButBigEnough() throws Exception {\n-        FileInputStream is = new FileInputStream(getFile(\"zip64support.tar.bz2\"));\n+        final FileInputStream is = new FileInputStream(getFile(\"zip64support.tar.bz2\"));\n         try {\n             new DumpArchiveInputStream(is);\n             fail(\"expected an exception\");\n-        } catch (ArchiveException ex) {\n+        } catch (final ArchiveException ex) {\n             // expected\n             assertTrue(ex.getCause() instanceof UnrecognizedFormatException);\n         } finally {\n \n     @Test\n     public void testConsumesArchiveCompletely() throws Exception {\n-        InputStream is = DumpArchiveInputStreamTest.class\n+        final InputStream is = DumpArchiveInputStreamTest.class\n             .getResourceAsStream(\"/archive_with_trailer.dump\");\n-        DumpArchiveInputStream dump = new DumpArchiveInputStream(is);\n+        final DumpArchiveInputStream dump = new DumpArchiveInputStream(is);\n         while (dump.getNextDumpEntry() != null) {\n             // just consume the archive\n         }\n-        byte[] expected = new byte[] {\n+        final byte[] expected = new byte[] {\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n         };\n-        byte[] actual = new byte[expected.length];\n+        final byte[] actual = new byte[expected.length];\n         is.read(actual);\n         assertArrayEquals(expected, actual);\n         dump.close();\n--- a/src/test/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java\n \n     @Test\n     public void testJarMarker() throws IOException {\n-        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n+        final File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n         testArchive.deleteOnExit();\n         JarArchiveOutputStream out = null;\n         ZipFile zf = null;\n             if (out != null) {\n                 try {\n                     out.close();\n-                } catch (IOException e) { /* swallow */ }\n+                } catch (final IOException e) { /* swallow */ }\n             }\n             ZipFile.closeQuietly(zf);\n             AbstractTestCase.tryHardToDelete(testArchive);\n--- a/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveInputStream.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveInputStream.java\n         content = new String[pFiles.length];\n \n         for (int i = 0; i < pFiles.length; i++) {\n-            String[] nameAndContent = pFiles[i];\n+            final String[] nameAndContent = pFiles[i];\n             filenames[i] = nameAndContent[0];\n             content[i] = nameAndContent[1];\n         }\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZFileTest.java\n     @Test\n     public void testRandomlySkippingEntries() throws Exception {\n         // Read sequential reference.\n-        Map<String, byte[]> entriesByName = new HashMap<String, byte[]>();\n+        final Map<String, byte[]> entriesByName = new HashMap<String, byte[]>();\n         SevenZFile archive = new SevenZFile(getFile(\"COMPRESS-320/Copy.7z\"));\n         SevenZArchiveEntry entry;\n         while ((entry = archive.getNextEntry()) != null) {\n         }\n         archive.close();\n \n-        String[] variants = {\n+        final String[] variants = {\n             \"BZip2-solid.7z\",\n             \"BZip2.7z\",\n             \"Copy-solid.7z\",\n         };\n \n         // TODO: use randomizedtesting for predictable, but different, randomness.\n-        Random rnd = new Random(0xdeadbeef);\n-        for (String fileName : variants) {\n+        final Random rnd = new Random(0xdeadbeef);\n+        for (final String fileName : variants) {\n             archive = new SevenZFile(getFile(\"COMPRESS-320/\" + fileName));\n \n             while ((entry = archive.getNextEntry()) != null) {\n \n                 if (entry.hasStream()) {\n                     assertTrue(entriesByName.containsKey(entry.getName()));\n-                    byte [] content = readFully(archive);\n+                    final byte [] content = readFully(archive);\n                     assertTrue(\"Content mismatch on: \" + fileName + \"!\" + entry.getName(),\n                                Arrays.equals(content, entriesByName.get(entry.getName())));\n                 }\n     }\n \n     private byte[] readFully(final SevenZFile archive) throws IOException {\n-        byte [] buf = new byte [1024];\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final byte [] buf = new byte [1024];\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         for (int len = 0; (len = archive.read(buf)) > 0;) {\n             baos.write(buf, 0, len);\n         }\n \n     @Test\n     public void testAllEmptyFilesArchive() throws Exception {\n-        SevenZFile archive = new SevenZFile(getFile(\"7z-empty-mhc-off.7z\"));\n+        final SevenZFile archive = new SevenZFile(getFile(\"7z-empty-mhc-off.7z\"));\n         try {\n             assertNotNull(archive.getNextEntry());\n         } finally {\n         try {\n             new SevenZFile(getFile(\"bla.encrypted.7z\"));\n             fail(\"shouldn't decrypt without a password\");\n-        } catch (PasswordRequiredException ex) {\n-            String msg = ex.getMessage();\n+        } catch (final PasswordRequiredException ex) {\n+            final String msg = ex.getMessage();\n             assertTrue(\"Should start with whining about being unable to decrypt\",\n                        msg.startsWith(\"Cannot read encrypted content from \"));\n             assertTrue(\"Should finish the sentence properly\",\n      */\n     @Test\n     public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n-        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n+        final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\"));\n         try {\n             int count = 0;\n             while (sevenZFile.getNextEntry() != null) {\n \n     @Test\n     public void testReadingBackLZMA2DictSize() throws Exception {\n-        File output = new File(dir, \"lzma2-dictsize.7z\");\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final File output = new File(dir, \"lzma2-dictsize.7z\");\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         try {\n             outArchive.setContentMethods(Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.LZMA2, 1 << 20)));\n-            SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+            final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n             entry.setName(\"foo.txt\");\n             outArchive.putArchiveEntry(entry);\n             outArchive.write(new byte[] { 'A' });\n             outArchive.close();\n         }\n \n-        SevenZFile archive = new SevenZFile(output);\n-        try {\n-            SevenZArchiveEntry entry = archive.getNextEntry();\n-            SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\n+        final SevenZFile archive = new SevenZFile(output);\n+        try {\n+            final SevenZArchiveEntry entry = archive.getNextEntry();\n+            final SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\n             assertEquals(SevenZMethod.LZMA2, m.getMethod());\n             assertEquals(1 << 20, m.getOptions());\n         } finally {\n \n     @Test\n     public void testReadingBackDeltaDistance() throws Exception {\n-        File output = new File(dir, \"delta-distance.7z\");\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final File output = new File(dir, \"delta-distance.7z\");\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         try {\n             outArchive.setContentMethods(Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.DELTA_FILTER, 32),\n                                                        new SevenZMethodConfiguration(SevenZMethod.LZMA2)));\n-            SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+            final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n             entry.setName(\"foo.txt\");\n             outArchive.putArchiveEntry(entry);\n             outArchive.write(new byte[] { 'A' });\n             outArchive.close();\n         }\n \n-        SevenZFile archive = new SevenZFile(output);\n-        try {\n-            SevenZArchiveEntry entry = archive.getNextEntry();\n-            SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\n+        final SevenZFile archive = new SevenZFile(output);\n+        try {\n+            final SevenZArchiveEntry entry = archive.getNextEntry();\n+            final SevenZMethodConfiguration m = entry.getContentMethods().iterator().next();\n             assertEquals(SevenZMethod.DELTA_FILTER, m.getMethod());\n             assertEquals(32, m.getOptions());\n         } finally {\n \n     @Test\n     public void getEntriesOfUnarchiveTest() throws IOException {\n-        SevenZFile sevenZFile = new SevenZFile(getFile(\"bla.7z\"));\n-        try {\n-            Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\n-            Iterator<SevenZArchiveEntry> iter = entries.iterator();\n+        final SevenZFile sevenZFile = new SevenZFile(getFile(\"bla.7z\"));\n+        try {\n+            final Iterable<SevenZArchiveEntry> entries = sevenZFile.getEntries();\n+            final Iterator<SevenZArchiveEntry> iter = entries.iterator();\n             SevenZArchiveEntry entry = iter.next();\n             assertEquals(\"test1.xml\", entry.getName());\n             entry = iter.next();\n     }\n     \n     private void test7zUnarchive(final File f, final SevenZMethod m, final byte[] password) throws Exception {\n-        SevenZFile sevenZFile = new SevenZFile(f, password);\n+        final SevenZFile sevenZFile = new SevenZFile(f, password);\n         try {\n             SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n             assertEquals(\"test1.xml\", entry.getName());\n             entry = sevenZFile.getNextEntry();\n             assertEquals(\"test2.xml\", entry.getName());\n             assertEquals(m, entry.getContentMethods().iterator().next().getMethod());\n-            byte[] contents = new byte[(int)entry.getSize()];\n+            final byte[] contents = new byte[(int)entry.getSize()];\n             int off = 0;\n             while ((off < contents.length)) {\n-                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n+                final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                 assert(bytesRead >= 0);\n                 off += bytesRead;\n             }\n     }\n \n     private void checkHelloWorld(final String filename) throws Exception {\n-        SevenZFile sevenZFile = new SevenZFile(getFile(filename));\n-        try {\n-            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n+        final SevenZFile sevenZFile = new SevenZFile(getFile(filename));\n+        try {\n+            final SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n             assertEquals(\"Hello world.txt\", entry.getName());\n-            byte[] contents = new byte[(int)entry.getSize()];\n+            final byte[] contents = new byte[(int)entry.getSize()];\n             int off = 0;\n             while ((off < contents.length)) {\n-                int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n+                final int bytesRead = sevenZFile.read(contents, off, contents.length - off);\n                 assert(bytesRead >= 0);\n                 off += bytesRead;\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFileTest.java\n     public void testDirectoriesAndEmptyFiles() throws Exception {\n         output = new File(dir, \"empties.7z\");\n \n-        Date accessDate = new Date();\n-        Calendar cal = Calendar.getInstance();\n+        final Date accessDate = new Date();\n+        final Calendar cal = Calendar.getInstance();\n         cal.add(Calendar.HOUR, -1);\n-        Date creationDate = cal.getTime();\n-\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final Date creationDate = cal.getTime();\n+\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         try {\n             SevenZArchiveEntry entry = outArchive.createArchiveEntry(dir, \"foo/\");\n             outArchive.putArchiveEntry(entry);\n             assert(entry != null);\n             assertEquals(\"dada\", entry.getName());\n             assertEquals(2, entry.getSize());\n-            byte[] content = new byte[2];\n+            final byte[] content = new byte[2];\n             assertEquals(2, archive.read(content));\n             assertEquals(5, content[0]);\n             assertEquals(42, content[1]);\n     @Test\n     public void testDirectoriesOnly() throws Exception {\n         output = new File(dir, \"dirs.7z\");\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n-        try {\n-            SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        try {\n+            final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n             entry.setName(\"foo/\");\n             entry.setDirectory(true);\n             outArchive.putArchiveEntry(entry);\n \n         final SevenZFile archive = new SevenZFile(output);\n         try {\n-            SevenZArchiveEntry entry = archive.getNextEntry();\n+            final SevenZArchiveEntry entry = archive.getNextEntry();\n             assert(entry != null);\n             assertEquals(\"foo/\", entry.getName());\n             assertTrue(entry.isDirectory());\n     @Test\n     public void testCantFinishTwice() throws Exception {\n         output = new File(dir, \"finish.7z\");\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         try {\n             outArchive.finish();\n             outArchive.finish();\n             fail(\"shouldn't be able to call finish twice\");\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             assertEquals(\"This archive has already been finished\", ex.getMessage());\n         } finally {\n             outArchive.close();\n     @Test\n     public void testStackOfContentCompressions() throws Exception {\n         output = new File(dir, \"multiple-methods.7z\");\n-        ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n+        final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.COPY));\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.DEFLATE));\n     @Test\n     public void testLzma2WithOptionsConfiguration() throws Exception {\n         output = new File(dir, \"lzma2-options2.7z\");\n-        LZMA2Options opts = new LZMA2Options(1);\n+        final LZMA2Options opts = new LZMA2Options(1);\n         createAndReadBack(output, Collections\n                           .singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2, opts)));\n     }\n     @Test\n     public void testArchiveWithMixedMethods() throws Exception {\n         output = new File(dir, \"mixed-methods.7z\");\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         try {\n             addFile(outArchive, 0, true);\n             addFile(outArchive, 1, true, Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.BZIP2)));\n             outArchive.close();\n         }\n \n-        SevenZFile archive = new SevenZFile(output);\n+        final SevenZFile archive = new SevenZFile(output);\n         try {\n             assertEquals(Boolean.TRUE,\n                          verifyFile(archive, 0, Arrays.asList(new SevenZMethodConfiguration(SevenZMethod.LZMA2))));\n \n     private void testCompress252(final int numberOfFiles, final int numberOfNonEmptyFiles)\n         throws Exception {\n-        int nonEmptyModulus = numberOfNonEmptyFiles != 0\n+        final int nonEmptyModulus = numberOfNonEmptyFiles != 0\n             ? numberOfFiles / numberOfNonEmptyFiles\n             : numberOfFiles + 1;\n         int nonEmptyFilesAdded = 0;\n         output = new File(dir, \"COMPRESS252-\" + numberOfFiles + \"-\" + numberOfNonEmptyFiles + \".7z\");\n-        SevenZOutputFile archive = new SevenZOutputFile(output);\n+        final SevenZOutputFile archive = new SevenZOutputFile(output);\n         try {\n             addDir(archive);\n             for (int i = 0; i < numberOfFiles; i++) {\n \n     private void verifyCompress252(final File output, final int numberOfFiles, final int numberOfNonEmptyFiles)\n         throws Exception {\n-        SevenZFile archive = new SevenZFile(output);\n+        final SevenZFile archive = new SevenZFile(output);\n         int filesFound = 0;\n         int nonEmptyFilesFound = 0;\n         try {\n     }\n \n     private void addDir(final SevenZOutputFile archive) throws Exception {\n-        SevenZArchiveEntry entry = archive.createArchiveEntry(dir, \"foo/\");\n+        final SevenZArchiveEntry entry = archive.createArchiveEntry(dir, \"foo/\");\n         archive.putArchiveEntry(entry);\n         archive.closeArchiveEntry();\n     }\n \n     private void verifyDir(final SevenZFile archive) throws Exception {\n-        SevenZArchiveEntry entry = archive.getNextEntry();\n+        final SevenZArchiveEntry entry = archive.getNextEntry();\n         assertNotNull(entry);\n         assertEquals(\"foo/\", entry.getName());\n         assertTrue(entry.isDirectory());\n \n     private void addFile(final SevenZOutputFile archive, final int index, final boolean nonEmpty, final Iterable<SevenZMethodConfiguration> methods)\n         throws Exception {\n-        SevenZArchiveEntry entry = new SevenZArchiveEntry();\n+        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n         entry.setName(\"foo/\" + index + \".txt\");\n         entry.setContentMethods(methods);\n         archive.putArchiveEntry(entry);\n \n     private Boolean verifyFile(final SevenZFile archive, final int index,\n                                final Iterable<SevenZMethodConfiguration> methods) throws Exception {\n-        SevenZArchiveEntry entry = archive.getNextEntry();\n+        final SevenZArchiveEntry entry = archive.getNextEntry();\n         if (entry == null) {\n             return null;\n         }\n \n     private void testRoundTrip(final SevenZMethod method) throws Exception {\n         output = new File(dir, method + \"-roundtrip.7z\");\n-        ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n+        final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n         methods.add(new SevenZMethodConfiguration(method));\n         createAndReadBack(output, methods);\n     }\n \n     private void testFilterRoundTrip(final SevenZMethodConfiguration method) throws Exception {\n         output = new File(dir, method.getMethod() + \"-roundtrip.7z\");\n-        ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n+        final ArrayList<SevenZMethodConfiguration> methods = new ArrayList<SevenZMethodConfiguration>();\n         methods.add(method);\n         methods.add(new SevenZMethodConfiguration(SevenZMethod.LZMA2));\n         createAndReadBack(output, methods);\n     }\n \n     private void createAndReadBack(final File output, final Iterable<SevenZMethodConfiguration> methods) throws Exception {\n-        SevenZOutputFile outArchive = new SevenZOutputFile(output);\n+        final SevenZOutputFile outArchive = new SevenZOutputFile(output);\n         outArchive.setContentMethods(methods);\n         try {\n             addFile(outArchive, 0, true);\n             outArchive.close();\n         }\n \n-        SevenZFile archive = new SevenZFile(output);\n+        final SevenZFile archive = new SevenZFile(output);\n         try {\n             assertEquals(Boolean.TRUE, verifyFile(archive, 0, methods));\n         } finally {\n     private static void assertContentMethodsEquals(final Iterable<? extends SevenZMethodConfiguration> expected,\n                                                    final Iterable<? extends SevenZMethodConfiguration> actual) {\n         assertNotNull(actual);\n-        Iterator<? extends SevenZMethodConfiguration> expectedIter = expected.iterator();\n-        Iterator<? extends SevenZMethodConfiguration> actualIter = actual.iterator();\n+        final Iterator<? extends SevenZMethodConfiguration> expectedIter = expected.iterator();\n+        final Iterator<? extends SevenZMethodConfiguration> actualIter = actual.iterator();\n         while (expectedIter.hasNext()) {\n             assertTrue(actualIter.hasNext());\n-            SevenZMethodConfiguration expConfig = expectedIter.next();\n-            SevenZMethodConfiguration actConfig = actualIter.next();\n+            final SevenZMethodConfiguration expConfig = expectedIter.next();\n+            final SevenZMethodConfiguration actConfig = actualIter.next();\n             assertEquals(expConfig.getMethod(), actConfig.getMethod());\n         }\n         assertFalse(actualIter.hasNext());\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n                                          );\n             gzin = new GzipCompressorInputStream(in);\n             tin = new TarArchiveInputStream(gzin);\n-            TarArchiveEntry e = tin.getNextTarEntry();\n+            final TarArchiveEntry e = tin.getNextTarEntry();\n             assertNotNull(e);\n             assertNull(tin.getNextTarEntry());\n         } finally {\n                                          .getResourceAsStream(name));\n             gzin = new GzipCompressorInputStream(in);\n             tin = new TarArchiveInputStream(gzin);\n-            TarArchiveEntry e = tin.getNextTarEntry();\n+            final TarArchiveEntry e = tin.getNextTarEntry();\n             assertNotNull(e);\n             assertEquals(8200l * 1024 * 1024, e.getSize());\n \n             long read = 0;\n-            Random r = new Random(System.currentTimeMillis());\n+            final Random r = new Random(System.currentTimeMillis());\n             int readNow;\n-            byte[] buf = new byte[1024 * 1024];\n+            final byte[] buf = new byte[1024 * 1024];\n             while ((readNow = tin.read(buf, 0, buf.length)) > 0) {\n                 // testing all bytes for a value of 0 is going to take\n                 // too long, just pick a few ones randomly\n                 for (int i = 0; i < 100; i++) {\n-                    int idx = r.nextInt(readNow);\n+                    final int idx = r.nextInt(readNow);\n                     assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n                 }\n                 read += readNow;\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n \n     @Test\n     public void testOldGNU() throws Throwable {\n-        File file = getFile(\"oldgnu_sparse.tar\");\n+        final File file = getFile(\"oldgnu_sparse.tar\");\n         TarArchiveInputStream tin = null;\n         try {\n             tin = new TarArchiveInputStream(new FileInputStream(file));\n-            TarArchiveEntry ae = tin.getNextTarEntry();\n+            final TarArchiveEntry ae = tin.getNextTarEntry();\n             assertEquals(\"sparsefile\", ae.getName());\n             assertTrue(ae.isOldGNUSparse());\n             assertTrue(ae.isGNUSparse());\n \n     @Test\n     public void testPaxGNU() throws Throwable {\n-        File file = getFile(\"pax_gnu_sparse.tar\");\n+        final File file = getFile(\"pax_gnu_sparse.tar\");\n         TarArchiveInputStream tin = null;\n         try {\n             tin = new TarArchiveInputStream(new FileInputStream(file));\n     }\n \n     private void assertPaxGNUEntry(final TarArchiveInputStream tin, final String suffix) throws Throwable {\n-        TarArchiveEntry ae = tin.getNextTarEntry();\n+        final TarArchiveEntry ae = tin.getNextTarEntry();\n         assertEquals(\"sparsefile-\" + suffix, ae.getName());\n         assertTrue(ae.isGNUSparse());\n         assertTrue(ae.isPaxGNUSparse());\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n      */\n     @Test\n     public void testFileSystemRoot() {\n-        TarArchiveEntry t = new TarArchiveEntry(new File(ROOT));\n+        final TarArchiveEntry t = new TarArchiveEntry(new File(ROOT));\n         assertEquals(\"/\", t.getName());\n     }\n \n     @Test\n     public void testTarFileWithFSRoot() throws IOException {\n-        File f = File.createTempFile(\"taetest\", \".tar\");\n+        final File f = File.createTempFile(\"taetest\", \".tar\");\n         f.deleteOnExit();\n         TarArchiveOutputStream tout = null;\n         TarArchiveInputStream tin = null;\n \n     @Test\n     public void testMaxFileSize(){\n-        TarArchiveEntry t = new TarArchiveEntry(\"\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"\");\n         t.setSize(0);\n         t.setSize(1);\n         try {\n             t.setSize(-1);\n             fail(\"Should have generated IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n         t.setSize(077777777777L);\n         t.setSize(0100000000000L);\n \n     @Test\n     public void testLinkFlagConstructor() {\n-        TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME);\n+        final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME);\n         assertGnuMagic(t);\n         assertEquals(\"foo\", t.getName());\n     }\n \n     @Test\n     public void testLinkFlagConstructorWithFileFlag() {\n-        TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_NORMAL);\n+        final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_NORMAL);\n         assertPosixMagic(t);\n         assertEquals(\"foo\", t.getName());\n     }\n \n     @Test\n     public void testLinkFlagConstructorWithPreserve() {\n-        TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME,\n+        final TarArchiveEntry t = new TarArchiveEntry(\"/foo\", LF_GNUTYPE_LONGNAME,\n                                                 true);\n         assertGnuMagic(t);\n         assertEquals(\"/foo\", t.getName());\n     }\n \n     private String readMagic(final TarArchiveEntry t) {\n-        byte[] buf = new byte[512];\n+        final byte[] buf = new byte[512];\n         t.writeEntryHeader(buf);\n         return new String(buf, MAGIC_OFFSET, MAGICLEN + VERSIONLEN);\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n     public void readSimplePaxHeader() throws Exception {\n         final InputStream is = new ByteArrayInputStream(new byte[1]);\n         final TarArchiveInputStream tais = new TarArchiveInputStream(is);\n-        Map<String, String> headers = tais\n+        final Map<String, String> headers = tais\n             .parsePaxHeaders(new ByteArrayInputStream(\"30 atime=1321711775.972059463\\n\"\n                                                       .getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n     public void secondEntryWinsWhenPaxHeaderContainsDuplicateKey() throws Exception {\n         final InputStream is = new ByteArrayInputStream(new byte[1]);\n         final TarArchiveInputStream tais = new TarArchiveInputStream(is);\n-        Map<String, String> headers = tais\n+        final Map<String, String> headers = tais\n             .parsePaxHeaders(new ByteArrayInputStream(\"11 foo=bar\\n11 foo=baz\\n\"\n                                                       .getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n     public void paxHeaderEntryWithEmptyValueRemovesKey() throws Exception {\n         final InputStream is = new ByteArrayInputStream(new byte[1]);\n         final TarArchiveInputStream tais = new TarArchiveInputStream(is);\n-        Map<String, String> headers = tais\n+        final Map<String, String> headers = tais\n             .parsePaxHeaders(new ByteArrayInputStream(\"11 foo=bar\\n7 foo=\\n\"\n                                                       .getBytes(CharsetNames.UTF_8)));\n         assertEquals(0, headers.size());\n     public void readPaxHeaderWithEmbeddedNewline() throws Exception {\n         final InputStream is = new ByteArrayInputStream(new byte[1]);\n         final TarArchiveInputStream tais = new TarArchiveInputStream(is);\n-        Map<String, String> headers = tais\n+        final Map<String, String> headers = tais\n             .parsePaxHeaders(new ByteArrayInputStream(\"28 comment=line1\\nline2\\nand3\\n\"\n                                                       .getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n \n     @Test\n     public void readNonAsciiPaxHeader() throws Exception {\n-        String ae = \"\\u00e4\";\n-        String line = \"11 path=\"+ ae + \"\\n\";\n+        final String ae = \"\\u00e4\";\n+        final String line = \"11 path=\"+ ae + \"\\n\";\n         assertEquals(11, line.getBytes(CharsetNames.UTF_8).length);\n         final InputStream is = new ByteArrayInputStream(new byte[1]);\n         final TarArchiveInputStream tais = new TarArchiveInputStream(is);\n-        Map<String, String> headers = tais\n+        final Map<String, String> headers = tais\n             .parsePaxHeaders(new ByteArrayInputStream(line.getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n         assertEquals(ae, headers.get(\"path\"));\n         TarArchiveInputStream in = null;\n         try {\n             in = new TarArchiveInputStream(new FileInputStream(getFile(archive)));\n-            TarArchiveEntry tae = in.getNextTarEntry();\n+            final TarArchiveEntry tae = in.getNextTarEntry();\n             assertEquals(\"foo\", tae.getName());\n-            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+            final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n             cal.set(1969, 11, 31, 23, 59, 59);\n             cal.set(Calendar.MILLISECOND, 0);\n             assertEquals(cal.getTime(), tae.getLastModifiedDate());\n \n     @Test\n     public void testCompress197() throws Exception {\n-        TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n+        final TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n         try {\n             TarArchiveEntry entry = tar.getNextTarEntry();\n             while (entry != null) {\n                 entry = tar.getNextTarEntry();\n             }\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             fail(\"COMPRESS-197: \" + e.getMessage());\n         } finally {\n             tar.close();\n     @Test\n     public void shouldUseSpecifiedEncodingWhenReadingGNULongNames()\n         throws Exception {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        String encoding = CharsetNames.UTF_16;\n-        String name = \"1234567890123456789012345678901234567890123456789\"\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final String encoding = CharsetNames.UTF_16;\n+        final String name = \"1234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890\\u00e4\";\n-        TarArchiveOutputStream tos =\n+        final TarArchiveOutputStream tos =\n             new TarArchiveOutputStream(bos, encoding);\n         tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n         TarArchiveEntry t = new TarArchiveEntry(name);\n         tos.write(30);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n-        TarArchiveInputStream tis =\n+        final byte[] data = bos.toByteArray();\n+        final ByteArrayInputStream bis = new ByteArrayInputStream(data);\n+        final TarArchiveInputStream tis =\n             new TarArchiveInputStream(bis, encoding);\n         t = tis.getNextTarEntry();\n         assertEquals(name, t.getName());\n \n     @Test\n     public void shouldConsumeArchiveCompletely() throws Exception {\n-        InputStream is = TarArchiveInputStreamTest.class\n+        final InputStream is = TarArchiveInputStreamTest.class\n             .getResourceAsStream(\"/archive_with_trailer.tar\");\n-        TarArchiveInputStream tar = new TarArchiveInputStream(is);\n+        final TarArchiveInputStream tar = new TarArchiveInputStream(is);\n         while (tar.getNextTarEntry() != null) {\n             // just consume the archive\n         }\n-        byte[] expected = new byte[] {\n+        final byte[] expected = new byte[] {\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n         };\n-        byte[] actual = new byte[expected.length];\n+        final byte[] actual = new byte[expected.length];\n         is.read(actual);\n         assertArrayEquals(expected, actual);\n         tar.close();\n \n     @Test\n     public void readsArchiveCompletely_COMPRESS245() throws Exception {\n-        InputStream is = TarArchiveInputStreamTest.class\n+        final InputStream is = TarArchiveInputStreamTest.class\n             .getResourceAsStream(\"/COMPRESS-245.tar.gz\");\n         try {\n-            InputStream gin = new GZIPInputStream(is);\n-            TarArchiveInputStream tar = new TarArchiveInputStream(gin);\n+            final InputStream gin = new GZIPInputStream(is);\n+            final TarArchiveInputStream tar = new TarArchiveInputStream(gin);\n             int count = 0;\n             TarArchiveEntry entry = tar.getNextTarEntry();\n             while (entry != null) {\n             }\n             assertEquals(31, count);\n             tar.close();\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             fail(\"COMPRESS-245: \" + e.getMessage());\n         } finally {\n             is.close();\n \n     @Test(expected = IOException.class)\n     public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n-        File dir = mkdir(\"COMPRESS-279\");\n-        TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n+        final File dir = mkdir(\"COMPRESS-279\");\n+        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n         FileOutputStream out = null;\n         try {\n             TarArchiveEntry entry = is.getNextTarEntry();\n \n     @Test\n     public void shouldReadBigGid() throws Exception {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n         TarArchiveEntry t = new TarArchiveEntry(\"name\");\n         t.setGroupId(4294967294l);\n         tos.write(30);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n-        TarArchiveInputStream tis =\n+        final byte[] data = bos.toByteArray();\n+        final ByteArrayInputStream bis = new ByteArrayInputStream(data);\n+        final TarArchiveInputStream tis =\n             new TarArchiveInputStream(bis);\n         t = tis.getNextTarEntry();\n         assertEquals(4294967294l, t.getLongGroupId());\n      */\n     @Test\n     public void shouldReadGNULongNameEntryWithWrongName() throws Exception {\n-        TarArchiveInputStream is = getTestStream(\"/COMPRESS-324.tar\");\n-        try {\n-            TarArchiveEntry entry = is.getNextTarEntry();\n+        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-324.tar\");\n+        try {\n+            final TarArchiveEntry entry = is.getNextTarEntry();\n             assertEquals(\"1234567890123456789012345678901234567890123456789012345678901234567890\"\n                          + \"1234567890123456789012345678901234567890123456789012345678901234567890\"\n                          + \"1234567890123456789012345678901234567890123456789012345678901234567890\"\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n \n     @Test\n     public void testCount() throws Exception {\n-        File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n+        final File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n         f.deleteOnExit();\n-        FileOutputStream fos = new FileOutputStream(f);\n-\n-        ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n+        final FileOutputStream fos = new FileOutputStream(f);\n+\n+        final ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n             .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n \n-        File file1 = getFile(\"test1.xml\");\n-        TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName());\n+        final File file1 = getFile(\"test1.xml\");\n+        final TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName());\n         tarOut.putArchiveEntry(sEntry);\n \n-        FileInputStream in = new FileInputStream(file1);\n-        byte[] buf = new byte[8192];\n+        final FileInputStream in = new FileInputStream(file1);\n+        final byte[] buf = new byte[8192];\n \n         int read = 0;\n         while ((read = in.read(buf)) > 0) {\n \n     @Test\n     public void testMaxFileSizeError() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(077777777777L);\n         TarArchiveOutputStream tos =\n             new TarArchiveOutputStream(new ByteArrayOutputStream());\n         try {\n             tos.putArchiveEntry(t);\n             fail(\"Should have generated RuntimeException\");\n-        } catch (RuntimeException expected) {\n+        } catch (final RuntimeException expected) {\n         }\n     }\n \n     @Test\n     public void testBigNumberStarMode() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(0100000000000L);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\n         tos.putArchiveEntry(t);\n         // make sure header is written to byte array\n         tos.write(new byte[10 * 1024]);\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(0x80,\n                      data[TarConstants.NAMELEN\n                         + TarConstants.MODELEN\n                         + TarConstants.UIDLEN\n                         + TarConstants.GIDLEN] & 0x80);\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(0100000000000L, e.getSize());\n         tin.close();\n         // generates IOE because of unclosed entries.\n \n     @Test\n     public void testBigNumberPosixMode() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(0100000000000L);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n         tos.putArchiveEntry(t);\n         // make sure header is written to byte array\n         tos.write(new byte[10 * 1024]);\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(\"00000000000 \",\n                      new String(data,\n                                 1024 + TarConstants.NAMELEN\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN, 12,\n                                 CharsetNames.UTF_8));\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(0100000000000L, e.getSize());\n         tin.close();\n         // generates IOE because of unclosed entries.\n \n     @Test\n     public void testWriteSimplePaxHeaders() throws Exception {\n-        Map<String, String> m = new HashMap<String, String>();\n+        final Map<String, String> m = new HashMap<String, String>();\n         m.put(\"a\", \"b\");\n-        byte[] data = writePaxHeader(m);\n+        final byte[] data = writePaxHeader(m);\n         assertEquals(\"00000000006 \",\n                      new String(data, TarConstants.NAMELEN\n                                 + TarConstants.MODELEN\n \n     @Test\n     public void testPaxHeadersWithLength99() throws Exception {\n-        Map<String, String> m = new HashMap<String, String>();\n+        final Map<String, String> m = new HashMap<String, String>();\n         m.put(\"a\",\n               \"0123456789012345678901234567890123456789\"\n               + \"01234567890123456789012345678901234567890123456789\"\n               + \"012\");\n-        byte[] data = writePaxHeader(m);\n+        final byte[] data = writePaxHeader(m);\n         assertEquals(\"00000000143 \",\n                      new String(data, TarConstants.NAMELEN\n                                 + TarConstants.MODELEN\n \n     @Test\n     public void testPaxHeadersWithLength101() throws Exception {\n-        Map<String, String> m = new HashMap<String, String>();\n+        final Map<String, String> m = new HashMap<String, String>();\n         m.put(\"a\",\n               \"0123456789012345678901234567890123456789\"\n               + \"01234567890123456789012345678901234567890123456789\"\n               + \"0123\");\n-        byte[] data = writePaxHeader(m);\n+        final byte[] data = writePaxHeader(m);\n         assertEquals(\"00000000145 \",\n                      new String(data, TarConstants.NAMELEN\n                                 + TarConstants.MODELEN\n     }\n \n     private byte[] writePaxHeader(final Map<String, String> m) throws Exception {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.writePaxHeaders(new TarArchiveEntry(\"x\"), \"foo\", m);\n \n         // add a dummy entry so data gets written\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(10 * 1024);\n         tos.putArchiveEntry(t);\n         tos.write(new byte[10 * 1024]);\n \n     @Test\n     public void testWriteLongFileNamePosixMode() throws Exception {\n-        String n = \"01234567890123456789012345678901234567890123456789\"\n+        final String n = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\";\n-        TarArchiveEntry t =\n+        final TarArchiveEntry t =\n             new TarArchiveEntry(n);\n         t.setSize(10 * 1024);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n         tos.putArchiveEntry(t);\n         tos.write(new byte[10 * 1024]);\n         tos.closeArchiveEntry();\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(\"160 path=\" + n + \"\\n\",\n                      new String(data, 512, 160, CharsetNames.UTF_8));\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         tin.close();\n         tos.close();\n \n     @Test\n     public void testOldEntryStarMode() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(Integer.MAX_VALUE);\n         t.setModTime(-1000);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\n         tos.putArchiveEntry(t);\n         // make sure header is written to byte array\n         tos.write(new byte[10 * 1024]);\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals((byte) 0xff,\n                      data[TarConstants.NAMELEN\n                           + TarConstants.MODELEN\n                           + TarConstants.UIDLEN\n                           + TarConstants.GIDLEN\n                           + TarConstants.SIZELEN]);\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n-        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(1969, 11, 31, 23, 59, 59);\n         cal.set(Calendar.MILLISECOND, 0);\n         assertEquals(cal.getTime(), e.getLastModifiedDate());\n \n     @Test\n     public void testOldEntryPosixMode() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(Integer.MAX_VALUE);\n         t.setModTime(-1000);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n         tos.putArchiveEntry(t);\n         // make sure header is written to byte array\n         tos.write(new byte[10 * 1024]);\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(\"00000000000 \",\n                      new String(data,\n                                 1024 + TarConstants.NAMELEN\n                                 + TarConstants.GIDLEN\n                                 + TarConstants.SIZELEN, 12,\n                                 CharsetNames.UTF_8));\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n-        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(1969, 11, 31, 23, 59, 59);\n         cal.set(Calendar.MILLISECOND, 0);\n         assertEquals(cal.getTime(), e.getLastModifiedDate());\n \n     @Test\n     public void testOldEntryError() throws Exception {\n-        TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n+        final TarArchiveEntry t = new TarArchiveEntry(\"foo\");\n         t.setSize(Integer.MAX_VALUE);\n         t.setModTime(-1000);\n-        TarArchiveOutputStream tos =\n+        final TarArchiveOutputStream tos =\n             new TarArchiveOutputStream(new ByteArrayOutputStream());\n         try {\n             tos.putArchiveEntry(t);\n             fail(\"Should have generated RuntimeException\");\n-        } catch (RuntimeException expected) {\n+        } catch (final RuntimeException expected) {\n         }\n         tos.close();\n     }\n \n     @Test\n     public void testWriteNonAsciiPathNamePaxHeader() throws Exception {\n-        String n = \"\\u00e4\";\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n+        final String n = \"\\u00e4\";\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n         t.setSize(10 * 1024);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setAddPaxHeadersForNonAsciiNames(true);\n         tos.putArchiveEntry(t);\n         tos.write(new byte[10 * 1024]);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(\"11 path=\" + n + \"\\n\",\n                      new String(data, 512, 11, CharsetNames.UTF_8));\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         tin.close();\n     }\n \n     @Test\n     public void testWriteNonAsciiLinkPathNamePaxHeader() throws Exception {\n-        String n = \"\\u00e4\";\n-        TarArchiveEntry t = new TarArchiveEntry(\"a\", TarConstants.LF_LINK);\n+        final String n = \"\\u00e4\";\n+        final TarArchiveEntry t = new TarArchiveEntry(\"a\", TarConstants.LF_LINK);\n         t.setSize(10 * 1024);\n         t.setLinkName(n);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setAddPaxHeadersForNonAsciiNames(true);\n         tos.putArchiveEntry(t);\n         tos.write(new byte[10 * 1024]);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n+        final byte[] data = bos.toByteArray();\n         assertEquals(\"15 linkpath=\" + n + \"\\n\",\n                      new String(data, 512, 15, CharsetNames.UTF_8));\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getLinkName());\n         tin.close();\n     }\n     }\n \n     private void testRoundtripWith67CharFileName(final int mode) throws Exception {\n-        String n = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+        final String n = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n             + \"AAAAAAA\";\n         assertEquals(67, n.length());\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n         t.setSize(10 * 1024);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(mode);\n         tos.putArchiveEntry(t);\n         tos.write(new byte[10 * 1024]);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         tin.close();\n     }\n \n     @Test\n     public void testWriteLongDirectoryNameErrorMode() throws Exception {\n-        String n = \"01234567890123456789012345678901234567890123456789\"\n+        final String n = \"01234567890123456789012345678901234567890123456789\"\n                 + \"01234567890123456789012345678901234567890123456789\"\n                 + \"01234567890123456789012345678901234567890123456789/\";\n \n         try {\n-            TarArchiveEntry t = new TarArchiveEntry(n);\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+            final TarArchiveEntry t = new TarArchiveEntry(n);\n+            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n             tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_ERROR);\n             tos.putArchiveEntry(t);\n             tos.closeArchiveEntry();\n             tos.close();\n \n             fail(\"Truncated name didn't throw an exception\");\n-        } catch (RuntimeException e) {\n+        } catch (final RuntimeException e) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testWriteLongDirectoryNameTruncateMode() throws Exception {\n-        String n = \"01234567890123456789012345678901234567890123456789\"\n+        final String n = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/\";\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_TRUNCATE);\n         tos.putArchiveEntry(t);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(\"Entry name\", n.substring(0, TarConstants.NAMELEN) + \"/\", e.getName());\n         assertTrue(\"The entry is not a directory\", e.isDirectory());\n         tin.close();\n     }\n \n     private void testWriteLongDirectoryName(final int mode) throws Exception {\n-        String n = \"01234567890123456789012345678901234567890123456789\"\n+        final String n = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/\";\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(mode);\n         tos.putArchiveEntry(t);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         assertTrue(e.isDirectory());\n         tin.close();\n      */\n     @Test\n     public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n-        String n = \"f\\u00f6\\u00f6/\";\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final String n = \"f\\u00f6\\u00f6/\";\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setAddPaxHeadersForNonAsciiNames(true);\n         tos.putArchiveEntry(t);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         assertTrue(e.isDirectory());\n         tin.close();\n      */\n     @Test\n     public void testWriteNonAsciiNameWithUnfortunateNamePosixMode() throws Exception {\n-        String n = \"f\\u00f6\\u00f6\\u00dc\";\n-        TarArchiveEntry t = new TarArchiveEntry(n);\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n+        final String n = \"f\\u00f6\\u00f6\\u00dc\";\n+        final TarArchiveEntry t = new TarArchiveEntry(n);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n         tos.setAddPaxHeadersForNonAsciiNames(true);\n         tos.putArchiveEntry(t);\n         tos.closeArchiveEntry();\n         tos.close();\n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin =\n-            new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin =\n+            new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(n, e.getName());\n         assertFalse(e.isDirectory());\n         tin.close();\n      */\n     @Test\n     public void testWriteLongLinkNameErrorMode() throws Exception {\n-        String linkname = \"01234567890123456789012345678901234567890123456789\"\n+        final String linkname = \"01234567890123456789012345678901234567890123456789\"\n                 + \"01234567890123456789012345678901234567890123456789\"\n                 + \"01234567890123456789012345678901234567890123456789/test\";\n-        TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n+        final TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n \n         try {\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n             tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_ERROR);\n             tos.putArchiveEntry(entry);\n             tos.closeArchiveEntry();\n             tos.close();\n \n             fail(\"Truncated link name didn't throw an exception\");\n-        } catch (RuntimeException e) {\n+        } catch (final RuntimeException e) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testWriteLongLinkNameTruncateMode() throws Exception {\n-        String linkname = \"01234567890123456789012345678901234567890123456789\"\n+        final String linkname = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/\";\n-        TarArchiveEntry entry = new TarArchiveEntry(\"test\" , TarConstants.LF_SYMLINK);\n+        final TarArchiveEntry entry = new TarArchiveEntry(\"test\" , TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n \n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_TRUNCATE);\n         tos.putArchiveEntry(entry);\n         tos.closeArchiveEntry();\n         tos.close();\n \n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(\"Link name\", linkname.substring(0, TarConstants.NAMELEN), e.getLinkName());\n         tin.close();\n     }\n      * @see \"https://issues.apache.org/jira/browse/COMPRESS-237\"\n      */\n     private void testWriteLongLinkName(final int mode) throws Exception {\n-        String linkname = \"01234567890123456789012345678901234567890123456789\"\n+        final String linkname = \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789\"\n             + \"01234567890123456789012345678901234567890123456789/test\";\n-        TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n+        final TarArchiveEntry entry = new TarArchiveEntry(\"test\", TarConstants.LF_SYMLINK);\n         entry.setLinkName(linkname);\n \n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos, \"ASCII\");\n         tos.setLongFileMode(mode);\n         tos.putArchiveEntry(entry);\n         tos.closeArchiveEntry();\n         tos.close();\n \n-        byte[] data = bos.toByteArray();\n-        TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n-        TarArchiveEntry e = tin.getNextTarEntry();\n+        final byte[] data = bos.toByteArray();\n+        final TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data));\n+        final TarArchiveEntry e = tin.getNextTarEntry();\n         assertEquals(\"Entry name\", \"test\", e.getName());\n         assertEquals(\"Link name\", linkname, e.getLinkName());\n         assertTrue(\"The entry is not a symbolic link\", e.isSymbolicLink());\n \n     @Test\n     public void testPadsOutputToFullBlockLength() throws Exception {\n-        File f = File.createTempFile(\"commons-compress-padding\", \".tar\");\n+        final File f = File.createTempFile(\"commons-compress-padding\", \".tar\");\n         f.deleteOnExit();\n-        FileOutputStream fos = new FileOutputStream(f);\n-        TarArchiveOutputStream tos = new TarArchiveOutputStream(fos);\n-        File file1 = getFile(\"test1.xml\");\n-        TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName());\n+        final FileOutputStream fos = new FileOutputStream(f);\n+        final TarArchiveOutputStream tos = new TarArchiveOutputStream(fos);\n+        final File file1 = getFile(\"test1.xml\");\n+        final TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName());\n         tos.putArchiveEntry(sEntry);\n-        FileInputStream in = new FileInputStream(file1);\n+        final FileInputStream in = new FileInputStream(file1);\n         IOUtils.copy(in, tos);\n         in.close();\n         tos.closeArchiveEntry();\n     @Test\n     public void testLongNameMd5Hash() throws Exception {\n         final String longFileName = \"a/considerably/longer/file/name/which/forces/use/of/the/long/link/header/which/appears/to/always/use/the/current/time/as/modification/date\";\n-        String fname = longFileName;\n+        final String fname = longFileName;\n         final Date modificationDate = new Date();\n \n-        byte[] archive1 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n-        byte[] digest1 = MessageDigest.getInstance(\"MD5\").digest(archive1);\n+        final byte[] archive1 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n+        final byte[] digest1 = MessageDigest.getInstance(\"MD5\").digest(archive1);\n \n         // let a second elapse otherwise the modification dates will be equal\n         Thread.sleep(1000L);\n \n         // now recreate exactly the same tar file\n-        byte[] archive2 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n+        final byte[] archive2 = createTarArchiveContainingOneDirectory(fname, modificationDate);\n         // and I would expect the MD5 hash to be the same, but for long names it isn't\n-        byte[] digest2 = MessageDigest.getInstance(\"MD5\").digest(archive2);\n+        final byte[] digest2 = MessageDigest.getInstance(\"MD5\").digest(archive2);\n \n         Assert.assertArrayEquals(digest1, digest2);\n \n         // do I still have the correct modification date?\n         // let a second elapse so we don't get the current time\n         Thread.sleep(1000);\n-        TarArchiveInputStream tarIn = new TarArchiveInputStream(new ByteArrayInputStream(archive2));\n-        ArchiveEntry nextEntry = tarIn.getNextEntry();\n+        final TarArchiveInputStream tarIn = new TarArchiveInputStream(new ByteArrayInputStream(archive2));\n+        final ArchiveEntry nextEntry = tarIn.getNextEntry();\n         assertEquals(longFileName, nextEntry.getName());\n         // tar archive stores modification time to second granularity only (floored)\n         assertEquals(modificationDate.getTime() / 1000, nextEntry.getLastModifiedDate().getTime() / 1000);\n     }\n \n     private static byte[] createTarArchiveContainingOneDirectory(final String fname, final Date modificationDate) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        TarArchiveOutputStream tarOut = new TarArchiveOutputStream(baos, 1024);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final TarArchiveOutputStream tarOut = new TarArchiveOutputStream(baos, 1024);\n         tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-        TarArchiveEntry tarEntry = new TarArchiveEntry(\"d\");\n+        final TarArchiveEntry tarEntry = new TarArchiveEntry(\"d\");\n         tarEntry.setModTime(modificationDate);\n         tarEntry.setMode(TarArchiveEntry.DEFAULT_DIR_MODE);\n         tarEntry.setModTime(modificationDate.getTime());\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarLister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarLister.java\n             return;\n         }\n         System.out.println(\"Analysing \" + args[0]);\n-        File f = new File(args[0]);\n+        final File f = new File(args[0]);\n         if (!f.isFile()) {\n             System.err.println(f + \" doesn't exist or is a directory\");\n         }\n-        InputStream fis = new BufferedInputStream(new FileInputStream(f));\n+        final InputStream fis = new BufferedInputStream(new FileInputStream(f));\n         TarArchiveInputStream ais;\n         if (args.length > 1) {\n             ais = new TarArchiveInputStream(fis, args[1]);\n     }\n \n     private static void log(final TarArchiveEntry ae) {\n-        StringBuilder sb = new StringBuilder(Integer.toOctalString(ae.getMode()))\n+        final StringBuilder sb = new StringBuilder(Integer.toOctalString(ae.getMode()))\n             .append(\" \");\n         String name = ae.getUserName();\n         if (name != null && name.length() > 0) {\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n     @Test\n     public void testName(){\n         byte [] buff = new byte[20];\n-        String sb1 = \"abcdefghijklmnopqrstuvwxyz\";\n+        final String sb1 = \"abcdefghijklmnopqrstuvwxyz\";\n         int off = TarUtils.formatNameBytes(sb1, buff, 1, buff.length-1);\n         assertEquals(off, 20);\n         String sb2 = TarUtils.parseName(buff, 1, 10);\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n         buffer=new byte[]{0}; // 1-byte array\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n         buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n         buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - embedded space\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n         buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - embedded NUL\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n     }\n \n     private void checkRoundTripOctal(final long value, final int bufsize) {\n-        byte [] buffer = new byte[bufsize];\n+        final byte [] buffer = new byte[bufsize];\n         long parseValue;\n         TarUtils.formatLongOctalBytes(value, buffer, 0, buffer.length);\n         parseValue = TarUtils.parseOctal(buffer,0, buffer.length);\n     }\n \n     private void checkRoundTripOctalOrBinary(final long value, final int bufsize) {\n-        byte [] buffer = new byte[bufsize];\n+        final byte [] buffer = new byte[bufsize];\n         long parseValue;\n         TarUtils.formatLongOctalOrBinaryBytes(value, buffer, 0, buffer.length);\n         parseValue = TarUtils.parseOctalOrBinary(buffer,0, buffer.length);\n     // Check correct trailing bytes are generated\n     @Test\n     public void testTrailers() {\n-        byte [] buffer = new byte[12];\n+        final byte [] buffer = new byte[12];\n         TarUtils.formatLongOctalBytes(123, buffer, 0, buffer.length);\n         assertEquals(' ', buffer[buffer.length-1]);\n         assertEquals('3', buffer[buffer.length-2]); // end of number\n \n     @Test\n     public void testNegative() throws Exception {\n-        byte [] buffer = new byte[22];\n+        final byte [] buffer = new byte[22];\n         TarUtils.formatUnsignedOctalString(-1, buffer, 0, buffer.length);\n         assertEquals(\"1777777777777777777777\", new String(buffer, CharsetNames.UTF_8));\n     }\n \n     @Test\n     public void testOverflow() throws Exception {\n-        byte [] buffer = new byte[8-1]; // a lot of the numbers have 8-byte buffers (nul term)\n+        final byte [] buffer = new byte[8-1]; // a lot of the numbers have 8-byte buffers (nul term)\n         TarUtils.formatUnsignedOctalString(07777777L, buffer, 0, buffer.length);\n         assertEquals(\"7777777\", new String(buffer, CharsetNames.UTF_8));\n         try {\n             TarUtils.formatUnsignedOctalString(017777777L, buffer, 0, buffer.length);\n             fail(\"Should have cause IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n     }\n \n     @Test\n     public void testRoundEncoding() throws Exception {\n         // COMPRESS-114\n-        ZipEncoding enc = ZipEncodingHelper.getZipEncoding(CharsetNames.ISO_8859_1);\n-        String s = \"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W220\\u00b1ZB\\u00b1LALALA\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1CAN\\u00b1\\u00b1DC\\u00b1\\u00b1\\u00b104\\u00b1060302\\u00b1MOE.model\";\n-        byte buff[] = new byte[100];\n-        int len = TarUtils.formatNameBytes(s, buff, 0, buff.length, enc);\n+        final ZipEncoding enc = ZipEncodingHelper.getZipEncoding(CharsetNames.ISO_8859_1);\n+        final String s = \"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W220\\u00b1ZB\\u00b1LALALA\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1CAN\\u00b1\\u00b1DC\\u00b1\\u00b1\\u00b104\\u00b1060302\\u00b1MOE.model\";\n+        final byte buff[] = new byte[100];\n+        final int len = TarUtils.formatNameBytes(s, buff, 0, buff.length, enc);\n         assertEquals(s, TarUtils.parseName(buff, 0, len, enc));\n     }\n \n     private void checkName(final String string) {\n-        byte buff[] = new byte[100];\n-        int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n+        final byte buff[] = new byte[100];\n+        final int len = TarUtils.formatNameBytes(string, buff, 0, buff.length);\n         assertEquals(string, TarUtils.parseName(buff, 0, len));\n     }\n \n     @Test\n     public void testReadNegativeBinary8Byte() {\n-        byte[] b = new byte[] {\n+        final byte[] b = new byte[] {\n             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n             (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n         };\n \n     @Test\n     public void testReadNegativeBinary12Byte() {\n-        byte[] b = new byte[] {\n+        final byte[] b = new byte[] {\n             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n             (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n \n     @Test\n     public void testWriteNegativeBinary8Byte() {\n-        byte[] b = new byte[] {\n+        final byte[] b = new byte[] {\n             (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n             (byte) 0xff, (byte) 0xff, (byte) 0xf1, (byte) 0xef,\n         };\n     // https://issues.apache.org/jira/browse/COMPRESS-191\n     @Test\n     public void testVerifyHeaderCheckSum() {\n-        byte[] valid = { // from bla.tar\n+        final byte[] valid = { // from bla.tar\n                 116, 101, 115, 116, 49, 46, 120, 109, 108, 0, 0, 0, 0, 0, 0,\n                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                 0, 0, 0, 0 };\n         assertTrue(TarUtils.verifyCheckSum(valid));\n \n-        byte[] compress117 = { // from COMPRESS-117\n+        final byte[] compress117 = { // from COMPRESS-117\n             (byte) 0x37, (byte) 0x7a, (byte) 0x43, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x00,\n             0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         };\n         assertTrue(TarUtils.verifyCheckSum(compress117));\n \n-        byte[] invalid = { // from the testAIFF.aif file in Tika\n+        final byte[] invalid = { // from the testAIFF.aif file in Tika\n                 70, 79, 82, 77, 0, 0, 15, 46, 65, 73, 70, 70, 67, 79, 77, 77,\n                 0, 0, 0, 18, 0, 2, 0, 0, 3, -64, 0, 16, 64, 14, -84, 68, 0, 0,\n                 0, 0, 0, 0, 83, 83, 78, 68, 0, 0, 15, 8, 0, 0, 0, 0, 0, 0, 0,\n \n     @Test\n     public void testParseOctalCompress330() throws Exception{\n-        long expected = 0100000;\n-        byte [] buffer = new byte[] {\n+        final long expected = 0100000;\n+        final byte [] buffer = new byte[] {\n             32, 32, 32, 32, 32, 49, 48, 48, 48, 48, 48, 32\n         };\n         assertEquals(expected, TarUtils.parseOctalOrBinary(buffer, 0, buffer.length));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/AsiExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/AsiExtraFieldTest.java\n      */    \n     @Test\n     public void testModes() {\n-        AsiExtraField a = new AsiExtraField();\n+        final AsiExtraField a = new AsiExtraField();\n         a.setMode(0123);\n         assertEquals(\"plain file\", 0100123, a.getMode());\n         a.setDirectory(true);\n      */\n     @Test\n     public void testContent() {\n-        AsiExtraField a = new AsiExtraField();\n+        final AsiExtraField a = new AsiExtraField();\n         a.setMode(0123);\n         a.setUserId(5);\n         a.setGroupId(6);\n         try {\n             a.parseFromLocalFileData(data, 0, data.length);\n             fail(\"should raise bad CRC exception\");\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertEquals(\"bad CRC checksum 0 instead of ebf018e\",\n                          e.getMessage());\n         }\n \n     @Test\n     public void testClone() {\n-        AsiExtraField s1 = new AsiExtraField();\n+        final AsiExtraField s1 = new AsiExtraField();\n         s1.setUserId(42);\n         s1.setGroupId(12);\n         s1.setLinkedFile(\"foo\");\n         s1.setMode(0644);\n         s1.setDirectory(true);\n-        AsiExtraField s2 = (AsiExtraField) s1.clone();\n+        final AsiExtraField s2 = (AsiExtraField) s1.clone();\n         assertNotSame(s1, s2);\n         assertEquals(s1.getUserId(), s2.getUserId());\n         assertEquals(s1.getGroupId(), s2.getGroupId());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/BinaryTreeTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/BinaryTreeTest.java\n \n     @Test\n     public void testDecode() throws IOException {\n-        InputStream in = new ByteArrayInputStream(new byte[] { 0x02, 0x42, 0x01, 0x13 });\n+        final InputStream in = new ByteArrayInputStream(new byte[] { 0x02, 0x42, 0x01, 0x13 });\n         \n-        BinaryTree tree = BinaryTree.decode(in, 8);\n+        final BinaryTree tree = BinaryTree.decode(in, 8);\n         \n         assertNotNull(tree);\n         \n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0x8D, (byte) 0xC5, (byte) 0x11, 0x00 }));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0x8D, (byte) 0xC5, (byte) 0x11, 0x00 }));\n         assertEquals(0, tree.read(stream));\n         assertEquals(1, tree.read(stream));\n         assertEquals(2, tree.read(stream));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/BitStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/BitStreamTest.java\n \n     @Test\n     public void testEmptyStream() throws Exception {\n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n         assertEquals(\"next bit\", -1, stream.nextBit());\n         assertEquals(\"next bit\", -1, stream.nextBit());\n         assertEquals(\"next bit\", -1, stream.nextBit());\n \n     @Test\n     public void testStream() throws Exception {\n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x03 }));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x03 }));\n \n         assertEquals(\"bit 0\", 0, stream.nextBit());\n         assertEquals(\"bit 1\", 1, stream.nextBit());\n \n     @Test\n     public void testNextByteFromEmptyStream() throws Exception {\n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[0]));\n         assertEquals(\"next byte\", -1, stream.nextByte());\n         assertEquals(\"next byte\", -1, stream.nextByte());\n         stream.close();\n \n     @Test\n     public void testReadAlignedBytes() throws Exception {\n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n         assertEquals(\"next byte\", 0xEA, stream.nextByte());\n         assertEquals(\"next byte\", 0x35, stream.nextByte());\n         assertEquals(\"next byte\", -1, stream.nextByte());\n \n     @Test\n     public void testNextByte() throws Exception {\n-        BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n+        final BitStream stream = new BitStream(new ByteArrayInputStream(new byte[] { (byte) 0xEA, 0x35 }));\n         assertEquals(\"bit 0\", 0, stream.nextBit());\n         assertEquals(\"bit 1\", 1, stream.nextBit());\n         assertEquals(\"bit 2\", 0, stream.nextBit());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/CircularBufferTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/CircularBufferTest.java\n \n     @Test\n     public void testPutAndGet() throws Exception {\n-        int size = 16;\n-        CircularBuffer buffer = new CircularBuffer(size);\n+        final int size = 16;\n+        final CircularBuffer buffer = new CircularBuffer(size);\n         for (int i = 0; i < size / 2; i++) {\n             buffer.put(i);\n         }\n \n     @Test\n     public void testCopy() throws Exception {\n-        CircularBuffer buffer = new CircularBuffer(16);\n+        final CircularBuffer buffer = new CircularBuffer(16);\n         \n         buffer.put(1);\n         buffer.put(2);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n     @Test\n     public void testReadPasswordEncryptedEntryViaZipFile()\n         throws IOException {\n-        File file = getFile(\"password-encrypted.zip\");\n+        final File file = getFile(\"password-encrypted.zip\");\n         ZipFile zf = null;\n         try {\n             zf = new ZipFile(file);\n-            ZipArchiveEntry zae = zf.getEntry(\"LICENSE.txt\");\n+            final ZipArchiveEntry zae = zf.getEntry(\"LICENSE.txt\");\n             assertTrue(zae.getGeneralPurposeBit().usesEncryption());\n             assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\n             assertFalse(zf.canReadEntryData(zae));\n             try {\n                 zf.getInputStream(zae);\n                 fail(\"expected an exception\");\n-            } catch (UnsupportedZipFeatureException ex) {\n+            } catch (final UnsupportedZipFeatureException ex) {\n                 assertSame(UnsupportedZipFeatureException.Feature.ENCRYPTION,\n                            ex.getFeature());\n             }\n     @Test\n     public void testReadPasswordEncryptedEntryViaStream()\n         throws IOException {\n-        File file = getFile(\"password-encrypted.zip\");\n+        final File file = getFile(\"password-encrypted.zip\");\n         ZipArchiveInputStream zin = null;\n         try {\n             zin = new ZipArchiveInputStream(new FileInputStream(file));\n-            ZipArchiveEntry zae = zin.getNextZipEntry();\n+            final ZipArchiveEntry zae = zin.getNextZipEntry();\n             assertEquals(\"LICENSE.txt\", zae.getName());\n             assertTrue(zae.getGeneralPurposeBit().usesEncryption());\n             assertFalse(zae.getGeneralPurposeBit().usesStrongEncryption());\n             assertFalse(zin.canReadEntryData(zae));\n             try {\n-                byte[] buf = new byte[1024];\n+                final byte[] buf = new byte[1024];\n                 zin.read(buf, 0, buf.length);\n                 fail(\"expected an exception\");\n-            } catch (UnsupportedZipFeatureException ex) {\n+            } catch (final UnsupportedZipFeatureException ex) {\n                 assertSame(UnsupportedZipFeatureException.Feature.ENCRYPTION,\n                            ex.getFeature());\n             }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ExplodeSupportTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ExplodeSupportTest.java\n public class ExplodeSupportTest {\n \n     private void testArchiveWithImplodeCompression(final String filename, final String entryName) throws IOException {\n-        ZipFile zip = new ZipFile(new File(filename));\n-        ZipArchiveEntry entry = zip.getEntries().nextElement();\n+        final ZipFile zip = new ZipFile(new File(filename));\n+        final ZipArchiveEntry entry = zip.getEntries().nextElement();\n         assertEquals(\"entry name\", entryName, entry.getName());\n         assertTrue(\"entry can't be read\", zip.canReadEntryData(entry));\n         assertEquals(\"method\", ZipMethod.IMPLODING.getCode(), entry.getMethod());\n \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n         IOUtils.copy(zip.getInputStream(entry), out);\n \n         out.flush();\n     }\n \n     private void testZipStreamWithImplodeCompression(final String filename, final String entryName) throws IOException {\n-        ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(new File(filename)));\n-        ZipArchiveEntry entry = zin.getNextZipEntry();\n+        final ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(new File(filename)));\n+        final ZipArchiveEntry entry = zin.getNextZipEntry();\n         assertEquals(\"entry name\", entryName, entry.getName());\n         assertTrue(\"entry can't be read\", zin.canReadEntryData(entry));\n         assertEquals(\"method\", ZipMethod.IMPLODING.getCode(), entry.getMethod());\n \n-        InputStream bio = new BoundedInputStream(zin, entry.getSize());\n+        final InputStream bio = new BoundedInputStream(zin, entry.getSize());\n         \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32());\n         IOUtils.copy(bio, out);\n \n         out.flush();\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtilsTest.java\n         dummy.setCentralDirectoryData(new byte[] {0});\n \n         aLocal = a.getLocalFileDataData();\n-        byte[] dummyLocal = dummy.getLocalFileDataData();\n+        final byte[] dummyLocal = dummy.getLocalFileDataData();\n         data = new byte[4 + aLocal.length + 4 + dummyLocal.length];\n         System.arraycopy(a.getHeaderId().getBytes(), 0, data, 0, 2);\n         System.arraycopy(a.getLocalFileDataLength().getBytes(), 0, data, 2, 2);\n      */\n     @Test\n     public void testParse() throws Exception {\n-        ZipExtraField[] ze = ExtraFieldUtils.parse(data);\n+        final ZipExtraField[] ze = ExtraFieldUtils.parse(data);\n         assertEquals(\"number of fields\", 2, ze.length);\n         assertTrue(\"type field 1\", ze[0] instanceof AsiExtraField);\n         assertEquals(\"mode field 1\", 040755,\n         assertEquals(\"data length field 2\", 1,\n                      ze[1].getLocalFileDataLength().getValue());\n \n-        byte[] data2 = new byte[data.length-1];\n+        final byte[] data2 = new byte[data.length-1];\n         System.arraycopy(data, 0, data2, 0, data2.length);\n         try {\n             ExtraFieldUtils.parse(data2);\n             fail(\"data should be invalid\");\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertEquals(\"message\",\n                          \"bad extra field starting at \"+(4 + aLocal.length)\n                          + \".  Block length of 1 bytes exceeds remaining data of 0 bytes.\",\n         assertEquals(\"data length field 2\", 1,\n                      ze[1].getLocalFileDataLength().getValue());\n \n-        byte[] data2 = new byte[data.length-1];\n+        final byte[] data2 = new byte[data.length-1];\n         System.arraycopy(data, 0, data2, 0, data2.length);\n         ze = ExtraFieldUtils.parse(data2, true,\n                                    ExtraFieldUtils.UnparseableExtraField.READ);\n         assertEquals(\"data length field 2\", 1,\n                      ze[1].getLocalFileDataLength().getValue());\n \n-        byte[] data2 = new byte[data.length-1];\n+        final byte[] data2 = new byte[data.length-1];\n         System.arraycopy(data, 0, data2, 0, data2.length);\n         ze = ExtraFieldUtils.parse(data2, true,\n                                    ExtraFieldUtils.UnparseableExtraField.SKIP);\n      */\n     @Test\n     public void testMerge() {\n-        byte[] local =\n+        final byte[] local =\n             ExtraFieldUtils.mergeLocalFileDataData(new ZipExtraField[] {a, dummy});\n         assertEquals(\"local length\", data.length, local.length);\n         for (int i=0; i<local.length; i++) {\n             assertEquals(\"local byte \"+i, data[i], local[i]);\n         }\n \n-        byte[] dummyCentral = dummy.getCentralDirectoryData();\n-        byte[] data2 = new byte[4 + aLocal.length + 4 + dummyCentral.length];\n+        final byte[] dummyCentral = dummy.getCentralDirectoryData();\n+        final byte[] data2 = new byte[4 + aLocal.length + 4 + dummyCentral.length];\n         System.arraycopy(data, 0, data2, 0, 4 + aLocal.length + 2);\n         System.arraycopy(dummy.getCentralDirectoryLength().getBytes(), 0,\n                          data2, 4+aLocal.length+2, 2);\n                          4+aLocal.length+4, dummyCentral.length);\n \n \n-        byte[] central =\n+        final byte[] central =\n             ExtraFieldUtils.mergeCentralDirectoryData(new ZipExtraField[] {a, dummy});\n         assertEquals(\"central length\", data2.length, central.length);\n         for (int i=0; i<central.length; i++) {\n \n     @Test\n     public void testMergeWithUnparseableData() throws Exception {\n-        ZipExtraField d = new UnparseableExtraFieldData();\n-        byte[] b = UNRECOGNIZED_HEADER.getBytes();\n+        final ZipExtraField d = new UnparseableExtraFieldData();\n+        final byte[] b = UNRECOGNIZED_HEADER.getBytes();\n         d.parseFromLocalFileData(new byte[] {b[0], b[1], 1, 0}, 0, 4);\n-        byte[] local =\n+        final byte[] local =\n             ExtraFieldUtils.mergeLocalFileDataData(new ZipExtraField[] {a, d});\n         assertEquals(\"local length\", data.length - 1, local.length);\n         for (int i = 0; i < local.length; i++) {\n             assertEquals(\"local byte \" + i, data[i], local[i]);\n         }\n \n-        byte[] dCentral = d.getCentralDirectoryData();\n-        byte[] data2 = new byte[4 + aLocal.length + dCentral.length];\n+        final byte[] dCentral = d.getCentralDirectoryData();\n+        final byte[] data2 = new byte[4 + aLocal.length + dCentral.length];\n         System.arraycopy(data, 0, data2, 0, 4 + aLocal.length + 2);\n         System.arraycopy(dCentral, 0, data2,\n                          4 + aLocal.length, dCentral.length);\n \n \n-        byte[] central =\n+        final byte[] central =\n             ExtraFieldUtils.mergeCentralDirectoryData(new ZipExtraField[] {a, d});\n         assertEquals(\"central length\", data2.length, central.length);\n         for (int i = 0; i < central.length; i++) {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBitTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBitTest.java\n         assertFalse(new GeneralPurposeBit().usesUTF8ForNames());\n         assertFalse(new GeneralPurposeBit().usesEncryption());\n         assertFalse(new GeneralPurposeBit().usesStrongEncryption());\n-        byte[] b = new byte[2];\n+        final byte[] b = new byte[2];\n         assertTrue(Arrays.equals(b, new GeneralPurposeBit().encode()));\n     }\n \n \n     @Test\n     public void testDataDescriptor() {\n-        byte[] flags = new byte[] {(byte) 8, (byte) 0};\n+        final byte[] flags = new byte[] {(byte) 8, (byte) 0};\n         assertTrue(GeneralPurposeBit.parse(flags, 0).usesDataDescriptor());\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useDataDescriptor(true);\n         assertTrue(Arrays.equals(flags, b.encode()));\n     }\n \n     @Test\n     public void testLanguageEncodingFlag() {\n-        byte[] flags = new byte[] {(byte) 0, (byte) 8};\n+        final byte[] flags = new byte[] {(byte) 0, (byte) 8};\n         assertTrue(GeneralPurposeBit.parse(flags, 0).usesUTF8ForNames());\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useUTF8ForNames(true);\n         assertTrue(Arrays.equals(flags, b.encode()));\n     }\n \n     @Test\n     public void testEncryption() {\n-        byte[] flags = new byte[] {(byte) 1, (byte) 0};\n+        final byte[] flags = new byte[] {(byte) 1, (byte) 0};\n         assertTrue(GeneralPurposeBit.parse(flags, 0).usesEncryption());\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useEncryption(true);\n         assertTrue(Arrays.equals(flags, b.encode()));\n     }\n     public void testStrongEncryption() {\n         byte[] flags = new byte[] {(byte) 65, (byte) 0};\n         assertTrue(GeneralPurposeBit.parse(flags, 0).usesStrongEncryption());\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useStrongEncryption(true);\n         assertTrue(b.usesEncryption());\n         assertTrue(Arrays.equals(flags, b.encode()));\n \n     @Test\n     public void testClone() {\n-        GeneralPurposeBit b = new GeneralPurposeBit();\n+        final GeneralPurposeBit b = new GeneralPurposeBit();\n         b.useStrongEncryption(true);\n         b.useUTF8ForNames(true);\n         assertEquals(b, b.clone());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n     }\n \n     public static void main(final String[] args) throws IOException {\n-        CommandLine cl = parse(args);\n-        File f = new File(cl.archive);\n+        final CommandLine cl = parse(args);\n+        final File f = new File(cl.archive);\n         if (!f.isFile()) {\n             System.err.println(f + \" doesn't exists or is a directory\");\n             usage();\n         }\n         if (cl.useStream) {\n-            BufferedInputStream fs =\n+            final BufferedInputStream fs =\n                 new BufferedInputStream(new FileInputStream(f));\n             try {\n-                ZipArchiveInputStream zs =\n+                final ZipArchiveInputStream zs =\n                     new ZipArchiveInputStream(fs, cl.encoding, true,\n                                               cl.allowStoredEntriesWithDataDescriptor);\n                 for (ArchiveEntry entry = zs.getNextEntry();\n                      entry != null;\n                      entry = zs.getNextEntry()) {\n-                    ZipArchiveEntry ze = (ZipArchiveEntry) entry;\n+                    final ZipArchiveEntry ze = (ZipArchiveEntry) entry;\n                     list(ze);\n                     if (cl.dir != null) {\n                         extract(cl.dir, ze, zs);\n                 fs.close();\n             }\n         } else {\n-            ZipFile zf = new ZipFile(f, cl.encoding);\n+            final ZipFile zf = new ZipFile(f, cl.encoding);\n             try {\n-                for (Enumeration<ZipArchiveEntry> entries = zf.getEntries();\n+                for (final Enumeration<ZipArchiveEntry> entries = zf.getEntries();\n                      entries.hasMoreElements(); ) {\n-                    ZipArchiveEntry ze = entries.nextElement();\n+                    final ZipArchiveEntry ze = entries.nextElement();\n                     list(ze);\n                     if (cl.dir != null) {\n-                        InputStream is = zf.getInputStream(ze);\n+                        final InputStream is = zf.getInputStream(ze);\n                         try {\n                             extract(cl.dir, ze, is);\n                         } finally {\n \n     private static void extract(final String dir, final ZipArchiveEntry entry,\n                                 final InputStream is) throws IOException {\n-        File f = new File(dir, entry.getName());\n+        final File f = new File(dir, entry.getName());\n         if (!f.getParentFile().exists()) {\n             f.getParentFile().mkdirs();\n         }\n     }\n \n     private static CommandLine parse(final String[] args) {\n-        CommandLine cl = new CommandLine();\n+        final CommandLine cl = new CommandLine();\n         boolean error = false;\n         for (int i = 0; i < args.length; i++) {\n             if (args[i].equals(\"-enc\")) {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java\n     @Test\n     public void testRead7ZipMultiVolumeArchiveForStream() throws IOException {\n \n-        FileInputStream archive =\n+        final FileInputStream archive =\n             new FileInputStream(getFile(\"apache-maven-2.2.1.zip.001\"));\n         ZipArchiveInputStream zi = null;\n         try {\n \n             // these are the entries that are supposed to be processed\n             // correctly without any problems\n-            for (String element : ENTRIES) {\n+            for (final String element : ENTRIES) {\n                 assertEquals(element, zi.getNextEntry().getName());\n             }\n \n             // this is the last entry that is truncated\n-            ArchiveEntry lastEntry = zi.getNextEntry();\n+            final ArchiveEntry lastEntry = zi.getNextEntry();\n             assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n-            byte [] buffer = new byte [4096];\n+            final byte [] buffer = new byte [4096];\n \n             // before the fix, we'd get 0 bytes on this read and all\n             // subsequent reads thus a client application might enter\n             try {\n                 while (zi.read(buffer) > 0) { }\n                 fail(\"shouldn't be able to read from truncated entry\");\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n                 assertEquals(\"Truncated ZIP file\", e.getMessage());\n             }\n \n                 zi.getNextEntry();\n                 fail(\"shouldn't be able to read another entry from truncated\"\n                      + \" file\");\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n                 // this is to be expected\n             }\n         } finally {\n \n     @Test(expected=IOException.class)\n     public void testRead7ZipMultiVolumeArchiveForFile() throws IOException {\n-        File file = getFile(\"apache-maven-2.2.1.zip.001\");\n+        final File file = getFile(\"apache-maven-2.2.1.zip.001\");\n         new ZipFile(file);\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreatorTest.java\n     public void concurrent()\n             throws Exception {\n         result = File.createTempFile(\"parallelScatterGather1\", \"\");\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n         zos.setEncoding(\"UTF-8\");\n-        ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator();\n+        final ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator();\n \n-        Map<String, byte[]> entries = writeEntries(zipCreator);\n+        final Map<String, byte[]> entries = writeEntries(zipCreator);\n         zipCreator.writeTo(zos);\n         zos.close();\n         removeEntriesFoundInZipFile(result, entries);\n     public void callableApi()\n             throws Exception {\n         result = File.createTempFile(\"parallelScatterGather2\", \"\");\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(result);\n         zos.setEncoding(\"UTF-8\");\n-        ExecutorService es = Executors.newFixedThreadPool(1);\n+        final ExecutorService es = Executors.newFixedThreadPool(1);\n \n-        ScatterGatherBackingStoreSupplier supp = new ScatterGatherBackingStoreSupplier() {\n+        final ScatterGatherBackingStoreSupplier supp = new ScatterGatherBackingStoreSupplier() {\n             @Override\n             public ScatterGatherBackingStore get() throws IOException {\n                 return new FileBasedScatterGatherBackingStore(tmp = File.createTempFile(\"parallelscatter\", \"n1\"));\n             }\n         };\n \n-        ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator(es, supp);\n-        Map<String, byte[]> entries = writeEntriesAsCallable(zipCreator);\n+        final ParallelScatterZipCreator zipCreator = new ParallelScatterZipCreator(es, supp);\n+        final Map<String, byte[]> entries = writeEntriesAsCallable(zipCreator);\n         zipCreator.writeTo(zos);\n         zos.close();\n \n     }\n \n     private void removeEntriesFoundInZipFile(final File result, final Map<String, byte[]> entries) throws IOException {\n-        ZipFile zf = new ZipFile(result);\n-        Enumeration<ZipArchiveEntry> entriesInPhysicalOrder = zf.getEntriesInPhysicalOrder();\n+        final ZipFile zf = new ZipFile(result);\n+        final Enumeration<ZipArchiveEntry> entriesInPhysicalOrder = zf.getEntriesInPhysicalOrder();\n         while (entriesInPhysicalOrder.hasMoreElements()){\n-            ZipArchiveEntry zipArchiveEntry = entriesInPhysicalOrder.nextElement();\n-            InputStream inputStream = zf.getInputStream(zipArchiveEntry);\n-            byte[] actual = IOUtils.toByteArray(inputStream);\n-            byte[] expected = entries.remove(zipArchiveEntry.getName());\n+            final ZipArchiveEntry zipArchiveEntry = entriesInPhysicalOrder.nextElement();\n+            final InputStream inputStream = zf.getInputStream(zipArchiveEntry);\n+            final byte[] actual = IOUtils.toByteArray(inputStream);\n+            final byte[] expected = entries.remove(zipArchiveEntry.getName());\n             assertArrayEquals( \"For \" + zipArchiveEntry.getName(),  expected, actual);\n         }\n         zf.close();\n     }\n \n     private Map<String, byte[]> writeEntries(final ParallelScatterZipCreator zipCreator) {\n-        Map<String, byte[]> entries = new HashMap<String, byte[]>();\n+        final Map<String, byte[]> entries = new HashMap<String, byte[]>();\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n-            ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n+            final ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n             zipCreator.addArchiveEntry(za, new InputStreamSupplier() {\n                 @Override\n                 public InputStream get() {\n     }\n \n     private Map<String, byte[]> writeEntriesAsCallable(final ParallelScatterZipCreator zipCreator) {\n-        Map<String, byte[]> entries = new HashMap<String, byte[]>();\n+        final Map<String, byte[]> entries = new HashMap<String, byte[]>();\n         for (int i = 0; i < NUMITEMS; i++){\n             final byte[] payloadBytes = (\"content\" + i).getBytes();\n-            ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n+            final ZipArchiveEntry za = createZipArchiveEntry(entries, i, payloadBytes);\n             final Callable<Object> callable = zipCreator.createCallable(za, new InputStreamSupplier() {\n                 @Override\n                 public InputStream get() {\n     }\n \n     private ZipArchiveEntry createZipArchiveEntry(final Map<String, byte[]> entries, final int i, final byte[] payloadBytes) {\n-        ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n+        final ZipArchiveEntry za = new ZipArchiveEntry( \"file\" + i);\n         entries.put( za.getName(), payloadBytes);\n         za.setMethod(ZipEntry.DEFLATED);\n         za.setSize(payloadBytes.length);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterSampleTest.java\n \n     @Test\n     public void testSample() throws Exception {\n-        File result = File.createTempFile(\"testSample\", \"fe\");\n+        final File result = File.createTempFile(\"testSample\", \"fe\");\n \n         createFile(result);\n         checkFile(result);\n     }\n \n     private void createFile(final File result) throws IOException, ExecutionException, InterruptedException {\n-        ScatterSample scatterSample = new ScatterSample();\n-        ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"test1.xml\");\n+        final ScatterSample scatterSample = new ScatterSample();\n+        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"test1.xml\");\n         archiveEntry.setMethod(ZipEntry.DEFLATED);\n-        InputStreamSupplier supp = new InputStreamSupplier() {\n+        final InputStreamSupplier supp = new InputStreamSupplier() {\n             @Override\n             public InputStream get() {\n                 return new ByteArrayInputStream(\"Hello\".getBytes());\n         };\n \n         scatterSample.addEntry(archiveEntry, supp);\n-        ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(result);\n+        final ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(result);\n         scatterSample.writeTo(zipArchiveOutputStream);\n         zipArchiveOutputStream.close();\n     }\n \n     private void checkFile(final File result) throws IOException {\n-        ZipFile zf = new ZipFile(result);\n-        ZipArchiveEntry archiveEntry1 = zf.getEntries().nextElement();\n+        final ZipFile zf = new ZipFile(result);\n+        final ZipArchiveEntry archiveEntry1 = zf.getEntries().nextElement();\n         assertEquals( \"test1.xml\", archiveEntry1.getName());\n-        InputStream inputStream = zf.getInputStream(archiveEntry1);\n-        byte[] b = new byte[6];\n-        int i = IOUtils.readFully(inputStream, b);\n+        final InputStream inputStream = zf.getInputStream(archiveEntry1);\n+        final byte[] b = new byte[6];\n+        final int i = IOUtils.readFully(inputStream, b);\n         assertEquals(5, i);\n         assertEquals('H', b[0]);\n         assertEquals('o', b[4]);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStreamTest.java\n     @Test\n     public void putArchiveEntry() throws Exception {\n         scatterFile = File.createTempFile(\"scattertest\", \".notzip\");\n-        ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.fileBased(scatterFile);\n+        final ScatterZipOutputStream scatterZipOutputStream = ScatterZipOutputStream.fileBased(scatterFile);\n         final byte[] B_PAYLOAD = \"RBBBBBBS\".getBytes();\n         final byte[] A_PAYLOAD = \"XAAY\".getBytes();\n \n-        ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\n+        final ZipArchiveEntry zab = new ZipArchiveEntry(\"b.txt\");\n         zab.setMethod(ZipEntry.DEFLATED);\n         final ByteArrayInputStream payload = new ByteArrayInputStream(B_PAYLOAD);\n         scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zab, createPayloadSupplier(payload)));\n \n-        ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\n+        final ZipArchiveEntry zae = new ZipArchiveEntry(\"a.txt\");\n         zae.setMethod(ZipEntry.DEFLATED);\n-        ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\n+        final ByteArrayInputStream payload1 = new ByteArrayInputStream(A_PAYLOAD);\n         scatterZipOutputStream.addArchiveEntry(createZipArchiveEntryRequest(zae, createPayloadSupplier(payload1)));\n \n         target = File.createTempFile(\"scattertest\", \".zip\");\n-        ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target);\n+        final ZipArchiveOutputStream outputStream = new ZipArchiveOutputStream(target);\n         scatterZipOutputStream.writeTo( outputStream);\n         outputStream.close();\n         scatterZipOutputStream.close();\n \n-        ZipFile zf = new ZipFile(target);\n+        final ZipFile zf = new ZipFile(target);\n         final ZipArchiveEntry b_entry = zf.getEntries(\"b.txt\").iterator().next();\n         assertEquals(8, b_entry.getSize());\n         assertArrayEquals(B_PAYLOAD, IOUtils.toByteArray(zf.getInputStream(b_entry)));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/StreamCompressorTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/StreamCompressorTest.java\n \n     @Test\n     public void storedEntries() throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        StreamCompressor sc = StreamCompressor.create( baos);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final StreamCompressor sc = StreamCompressor.create( baos);\n         sc.deflate(new ByteArrayInputStream(\"A\".getBytes()), ZipEntry.STORED);\n         sc.deflate(new ByteArrayInputStream(\"BAD\".getBytes()), ZipEntry.STORED);\n         assertEquals(3, sc.getBytesRead());\n \n     @Test\n     public void deflatedEntries() throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        StreamCompressor sc = StreamCompressor.create( baos);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final StreamCompressor sc = StreamCompressor.create( baos);\n         sc.deflate(new ByteArrayInputStream(\"AAAAAABBBBBB\".getBytes()), ZipEntry.DEFLATED);\n         assertEquals(12, sc.getBytesRead());\n         assertEquals(8, sc.getBytesWrittenForLastEntry());\n         assertEquals(3299542, sc.getCrc32());\n \n         final byte[] actuals = baos.toByteArray();\n-        byte[] expected = new byte[]{115,116,4,1,39,48,0,0};\n+        final byte[] expected = new byte[]{115,116,4,1,39,48,0,0};\n         // Note that this test really asserts stuff about the java Deflater, which might be a little bit brittle\n         assertArrayEquals(expected, actuals);\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n      */\n     @Test\n     public void testRead7ZipArchive() throws IOException {\n-        File archive = getFile(\"utf8-7zip-test.zip\");\n+        final File archive = getFile(\"utf8-7zip-test.zip\");\n         ZipFile zf = null;\n         try {\n             zf = new ZipFile(archive, CP437, false);\n \n     @Test\n     public void testRead7ZipArchiveForStream() throws IOException {\n-        FileInputStream archive =\n+        final FileInputStream archive =\n             new FileInputStream(getFile(\"utf8-7zip-test.zip\"));\n         ZipArchiveInputStream zi = null;\n         try {\n      */\n     @Test\n     public void testReadWinZipArchive() throws IOException {\n-        File archive = getFile(\"utf8-winzip-test.zip\");\n+        final File archive = getFile(\"utf8-winzip-test.zip\");\n         ZipFile zf = null;\n         try {\n             zf = new ZipFile(archive, null, true);\n     }\n \n     private void assertCanRead(final ZipFile zf, final String fileName) throws IOException {\n-        ZipArchiveEntry entry = zf.getEntry(fileName);\n+        final ZipArchiveEntry entry = zf.getEntry(fileName);\n         assertNotNull(\"Entry doesn't exist\", entry);\n-        InputStream is = zf.getInputStream(entry);\n+        final InputStream is = zf.getInputStream(entry);\n         assertNotNull(\"InputStream is null\", is);\n         try {\n             is.read();\n \n     @Test\n     public void testReadWinZipArchiveForStream() throws IOException {\n-        FileInputStream archive =\n+        final FileInputStream archive =\n             new FileInputStream(getFile(\"utf8-winzip-test.zip\"));\n         ZipArchiveInputStream zi = null;\n         try {\n \n     @Test\n     public void testZipFileReadsUnicodeFields() throws IOException {\n-        File file = File.createTempFile(\"unicode-test\", \".zip\");\n+        final File file = File.createTempFile(\"unicode-test\", \".zip\");\n         file.deleteOnExit();\n         ZipArchiveInputStream zi = null;\n         try {\n             createTestFile(file, CharsetNames.US_ASCII, false, true);\n-            FileInputStream archive = new FileInputStream(file);\n+            final FileInputStream archive = new FileInputStream(file);\n             zi = new ZipArchiveInputStream(archive, CharsetNames.US_ASCII, true);\n             assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\n             assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\n     @Test\n     public void testZipArchiveInputStreamReadsUnicodeFields()\n         throws IOException {\n-        File file = File.createTempFile(\"unicode-test\", \".zip\");\n+        final File file = File.createTempFile(\"unicode-test\", \".zip\");\n         file.deleteOnExit();\n         ZipFile zf = null;\n         try {\n     @Test\n     public void testRawNameReadFromZipFile()\n         throws IOException {\n-        File archive = getFile(\"utf8-7zip-test.zip\");\n+        final File archive = getFile(\"utf8-7zip-test.zip\");\n         ZipFile zf = null;\n         try {\n             zf = new ZipFile(archive, CP437, false);\n     @Test\n     public void testRawNameReadFromStream()\n         throws IOException {\n-        FileInputStream archive =\n+        final FileInputStream archive =\n             new FileInputStream(getFile(\"utf8-7zip-test.zip\"));\n         ZipArchiveInputStream zi = null;\n         try {\n                                           final boolean withExplicitUnicodeExtra)\n         throws IOException {\n \n-        File file = File.createTempFile(encoding + \"-test\", \".zip\");\n+        final File file = File.createTempFile(encoding + \"-test\", \".zip\");\n         file.deleteOnExit();\n         try {\n             createTestFile(file, encoding, withEFS, withExplicitUnicodeExtra);\n                                        final boolean withExplicitUnicodeExtra)\n         throws UnsupportedEncodingException, IOException {\n \n-        ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        final ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         ZipArchiveOutputStream zos = null;\n         try {\n             if (withExplicitUnicodeExtra\n                 && !zipEncoding.canEncode(ze.getName())) {\n \n-                ByteBuffer en = zipEncoding.encode(ze.getName());\n+                final ByteBuffer en = zipEncoding.encode(ze.getName());\n \n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                            en.array(),\n             if (withExplicitUnicodeExtra\n                 && !zipEncoding.canEncode(ze.getName())) {\n \n-                ByteBuffer en = zipEncoding.encode(ze.getName());\n+                final ByteBuffer en = zipEncoding.encode(ze.getName());\n \n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                            en.array(),\n             if (withExplicitUnicodeExtra\n                 && !zipEncoding.canEncode(ze.getName())) {\n \n-                ByteBuffer en = zipEncoding.encode(ze.getName());\n+                final ByteBuffer en = zipEncoding.encode(ze.getName());\n \n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n                                                            en.array(),\n             if (zos != null) {\n                 try {\n                     zos.close();\n-                } catch (IOException e) { /* swallow */ }\n+                } catch (final IOException e) { /* swallow */ }\n             }\n         }\n     }\n         try {\n             zf = new ZipFile(file, encoding, false);\n \n-            Enumeration<ZipArchiveEntry> e = zf.getEntries();\n+            final Enumeration<ZipArchiveEntry> e = zf.getEntries();\n             while (e.hasMoreElements()) {\n-                ZipArchiveEntry ze = e.nextElement();\n+                final ZipArchiveEntry ze = e.nextElement();\n \n                 if (ze.getName().endsWith(\"sser.txt\")) {\n                     assertUnicodeName(ze, OIL_BARREL_TXT, encoding);\n                                           final String encoding)\n         throws IOException {\n         if (!expectedName.equals(ze.getName())) {\n-            UnicodePathExtraField ucpf = findUniCodePath(ze);\n+            final UnicodePathExtraField ucpf = findUniCodePath(ze);\n             assertNotNull(ucpf);\n \n-            ZipEncoding enc = ZipEncodingHelper.getZipEncoding(encoding);\n-            ByteBuffer ne = enc.encode(ze.getName());\n-\n-            CRC32 crc = new CRC32();\n+            final ZipEncoding enc = ZipEncodingHelper.getZipEncoding(encoding);\n+            final ByteBuffer ne = enc.encode(ze.getName());\n+\n+            final CRC32 crc = new CRC32();\n             crc.update(ne.array(), ne.arrayOffset(),\n                        ne.limit() - ne.position());\n \n \n     @Test\n     public void testUtf8Interoperability() throws IOException {\n-        File file1 = getFile(\"utf8-7zip-test.zip\");\n-        File file2 = getFile(\"utf8-winzip-test.zip\");\n+        final File file1 = getFile(\"utf8-7zip-test.zip\");\n+        final File file2 = getFile(\"utf8-winzip-test.zip\");\n \n         testFile(file1,CP437);\n         testFile(file2,CP437);\n     }\n \n     private static void assertRawNameOfAcsiiTxt(final ZipArchiveEntry ze) {\n-        byte[] b = ze.getRawName();\n+        final byte[] b = ze.getRawName();\n         assertNotNull(b);\n         final int len = ASCII_TXT.length();\n         assertEquals(len, b.length);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X000A_NTFSTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X000A_NTFSTest.java\n \n     @Test\n     public void simpleRountrip() throws Exception {\n-        X000A_NTFS xf = new X000A_NTFS();\n+        final X000A_NTFS xf = new X000A_NTFS();\n         xf.setModifyJavaTime(new Date(0));\n         // one second past midnight\n         xf.setAccessJavaTime(new Date(-11644473601000l));\n         xf.setCreateJavaTime(null);\n-        byte[] b = xf.getLocalFileDataData();\n+        final byte[] b = xf.getLocalFileDataData();\n \n-        X000A_NTFS xf2 = new X000A_NTFS();\n+        final X000A_NTFS xf2 = new X000A_NTFS();\n         xf2.parseFromLocalFileData(b, 0, b.length);\n         assertEquals(new Date(0), xf2.getModifyJavaTime());\n         assertEquals(new Date(-11644473601000l), xf2.getAccessJavaTime());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestampTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestampTest.java\n         http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/90df6756406f\n          */\n \n-        File archive = getFile(\"COMPRESS-210_unix_time_zip_test.zip\");\n+        final File archive = getFile(\"COMPRESS-210_unix_time_zip_test.zip\");\n         ZipFile zf = null;\n \n         try {\n             zf = new ZipFile(archive);\n-            Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+            final Enumeration<ZipArchiveEntry> en = zf.getEntries();\n \n             // We expect EVERY entry of this zip file\n             // to contain extra field 0x5455.\n             while (en.hasMoreElements()) {\n \n-                ZipArchiveEntry zae = en.nextElement();\n-                String name = zae.getName();\n-                X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) zae.getExtraField(X5455);\n-                Date rawZ = zae.getLastModifiedDate();\n-                Date m = xf.getModifyJavaTime();\n-                boolean zipTimeUsesExtendedTimestamp = rawZ.equals(m);\n-                Date z = zipTimeUsesExtendedTimestamp ? rawZ : adjustFromGMTToExpectedOffset(rawZ);\n-                Date a = xf.getAccessJavaTime();\n-\n-                String zipTime = DATE_FORMAT.format(z);\n-                String modTime = DATE_FORMAT.format(m);\n-                String accTime = DATE_FORMAT.format(a);\n+                final ZipArchiveEntry zae = en.nextElement();\n+                final String name = zae.getName();\n+                final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) zae.getExtraField(X5455);\n+                final Date rawZ = zae.getLastModifiedDate();\n+                final Date m = xf.getModifyJavaTime();\n+                final boolean zipTimeUsesExtendedTimestamp = rawZ.equals(m);\n+                final Date z = zipTimeUsesExtendedTimestamp ? rawZ : adjustFromGMTToExpectedOffset(rawZ);\n+                final Date a = xf.getAccessJavaTime();\n+\n+                final String zipTime = DATE_FORMAT.format(z);\n+                final String modTime = DATE_FORMAT.format(m);\n+                final String accTime = DATE_FORMAT.format(a);\n \n                 if (!zae.isDirectory()) {\n-                    int x = name.lastIndexOf('/');\n-                    String yearString = name.substring(x + 1);\n+                    final int x = name.lastIndexOf('/');\n+                    final String yearString = name.substring(x + 1);\n                     int year;\n                     try {\n                         year = Integer.parseInt(yearString);\n-                    } catch (NumberFormatException nfe) {\n+                    } catch (final NumberFormatException nfe) {\n                         year = -1;\n                     }\n                     if (year >= 0) {\n     public void testGettersSetters() {\n         // X5455 is concerned with time, so let's\n         // get a timestamp to play with (Jan 1st, 2000).\n-        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n         cal.set(Calendar.YEAR, 2000);\n         cal.set(Calendar.MONTH, Calendar.JANUARY);\n         cal.set(Calendar.DATE, 1);\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n-        Date timeMillis = cal.getTime();\n-        ZipLong time = new ZipLong(timeMillis.getTime() / 1000);\n+        final Date timeMillis = cal.getTime();\n+        final ZipLong time = new ZipLong(timeMillis.getTime() / 1000);\n \n         // set too big\n         try {\n             // Java time is 1000 x larger (milliseconds).\n             xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n             fail(\"Time too big for 32 bits!\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // All is good.\n         }\n \n     @Test\n     public void testWriteReadRoundtrip() throws IOException {\n         tmpDir = mkdir(\"X5455\");\n-        File output = new File(tmpDir, \"write_rewrite.zip\");\n+        final File output = new File(tmpDir, \"write_rewrite.zip\");\n         final OutputStream out = new FileOutputStream(output);\n-        Date d = new Date(97, 8, 24, 15, 10, 2);\n+        final Date d = new Date(97, 8, 24, 15, 10, 2);\n         ZipArchiveOutputStream os = null;\n         try {\n             os = new ZipArchiveOutputStream(out);\n-            ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\n+            final ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\n             xf.setModifyJavaTime(d);\n             xf.setFlags((byte) 1);\n             ze.addExtraField(xf);\n         }\n         out.close();\n         \n-        ZipFile zf = new ZipFile(output);\n-        ZipArchiveEntry ze = zf.getEntry(\"foo\");\n-        X5455_ExtendedTimestamp ext =\n+        final ZipFile zf = new ZipFile(output);\n+        final ZipArchiveEntry ze = zf.getEntry(\"foo\");\n+        final X5455_ExtendedTimestamp ext =\n             (X5455_ExtendedTimestamp) ze.getExtraField(X5455);\n         assertNotNull(ext);\n         assertTrue(ext.isBit0_modifyTimePresent());\n      * with GMT-8 so we need to adjust for the difference.\n      */\n     private static Date adjustFromGMTToExpectedOffset(final Date from) {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(from);\n         cal.add(Calendar.MILLISECOND, cal.get(Calendar.ZONE_OFFSET));\n         if (cal.getTimeZone().inDaylightTime(from)) {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/X7875_NewUnixTest.java\n \n     @Test\n     public void testSampleFile() throws Exception {\n-        File archive = getFile(\"COMPRESS-211_uid_gid_zip_test.zip\");\n+        final File archive = getFile(\"COMPRESS-211_uid_gid_zip_test.zip\");\n         ZipFile zf = null;\n \n         try {\n             zf = new ZipFile(archive);\n-            Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+            final Enumeration<ZipArchiveEntry> en = zf.getEntries();\n \n             // We expect EVERY entry of this zip file (dir & file) to\n             // contain extra field 0x7875.\n             while (en.hasMoreElements()) {\n \n-                ZipArchiveEntry zae = en.nextElement();\n-                String name = zae.getName();\n-                X7875_NewUnix xf = (X7875_NewUnix) zae.getExtraField(X7875);\n+                final ZipArchiveEntry zae = en.nextElement();\n+                final String name = zae.getName();\n+                final X7875_NewUnix xf = (X7875_NewUnix) zae.getExtraField(X7875);\n \n                 // The directory entry in the test zip file is uid/gid 1000.\n                 long expected = 1000;\n     public void testMisc() throws Exception {\n         assertFalse(xf.equals(new Object()));\n         assertTrue(xf.toString().startsWith(\"0x7875 Zip Extra Field\"));\n-        Object o = xf.clone();\n+        final Object o = xf.clone();\n         assertEquals(o.hashCode(), xf.hashCode());\n         assertTrue(xf.equals(o));\n         xf.setUID(12345);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n \n     @Test\n     public void testWriteCDOnlySizes() {\n-        Zip64ExtendedInformationExtraField f =\n+        final Zip64ExtendedInformationExtraField f =\n             new Zip64ExtendedInformationExtraField(SIZE, CSIZE);\n         assertEquals(new ZipShort(16), f.getCentralDirectoryLength());\n-        byte[] b = f.getCentralDirectoryData();\n+        final byte[] b = f.getCentralDirectoryData();\n         assertEquals(16, b.length);\n         checkSizes(b);\n     }\n \n     @Test\n     public void testWriteCDSizeAndOffset() {\n-        Zip64ExtendedInformationExtraField f =\n+        final Zip64ExtendedInformationExtraField f =\n             new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, null);\n         assertEquals(new ZipShort(24), f.getCentralDirectoryLength());\n-        byte[] b = f.getCentralDirectoryData();\n+        final byte[] b = f.getCentralDirectoryData();\n         assertEquals(24, b.length);\n         checkSizes(b);\n         checkOffset(b, 16);\n \n     @Test\n     public void testWriteCDSizeOffsetAndDisk() {\n-        Zip64ExtendedInformationExtraField f =\n+        final Zip64ExtendedInformationExtraField f =\n             new Zip64ExtendedInformationExtraField(SIZE, CSIZE, OFF, DISK);\n         assertEquals(new ZipShort(28), f.getCentralDirectoryLength());\n-        byte[] b = f.getCentralDirectoryData();\n+        final byte[] b = f.getCentralDirectoryData();\n         assertEquals(28, b.length);\n         checkSizes(b);\n         checkOffset(b, 16);\n \n     @Test\n     public void testWriteCDSizeAndDisk() {\n-        Zip64ExtendedInformationExtraField f =\n+        final Zip64ExtendedInformationExtraField f =\n             new Zip64ExtendedInformationExtraField(SIZE, CSIZE, null, DISK);\n         assertEquals(new ZipShort(20), f.getCentralDirectoryLength());\n-        byte[] b = f.getCentralDirectoryData();\n+        final byte[] b = f.getCentralDirectoryData();\n         assertEquals(20, b.length);\n         checkSizes(b);\n         checkDisk(b, 16);\n \n     @Test\n     public void testReadLFHSizesOnly() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[16];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[16];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         f.parseFromLocalFileData(b, 0, b.length);\n \n     @Test\n     public void testReadLFHSizesAndOffset() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[24];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[24];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n \n     @Test\n     public void testReadLFHSizesOffsetAndDisk() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[28];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[28];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n \n     @Test\n     public void testReadLFHSizesAndDisk() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[20];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[20];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         System.arraycopy(DISK.getBytes(), 0, b, 16, 4);\n \n     @Test\n     public void testReadCDSizesOffsetAndDisk() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[28];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[28];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n \n     @Test\n     public void testReadCDSizesAndOffset() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[24];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[24];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8);\n         System.arraycopy(OFF.getBytes(), 0, b, 16, 8);\n \n     @Test\n     public void testReadCDSomethingAndDisk() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[12];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[12];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         System.arraycopy(DISK.getBytes(), 0, b, 8, 4);\n         f.parseFromCentralDirectoryData(b, 0, b.length);\n \n     @Test\n     public void testReparseCDSingleEightByteData() throws ZipException {\n-        Zip64ExtendedInformationExtraField f =\n-            new Zip64ExtendedInformationExtraField();\n-        byte[] b = new byte[8];\n+        final Zip64ExtendedInformationExtraField f =\n+            new Zip64ExtendedInformationExtraField();\n+        final byte[] b = new byte[8];\n         System.arraycopy(SIZE.getBytes(), 0, b, 0, 8);\n         f.parseFromCentralDirectoryData(b, 0, b.length);\n         f.reparseCentralDirectoryData(true, false, false, false);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n     }\n \n     private static File write5GBZerosFile(final String testName) throws Throwable {\n-        File f = getTempFile(testName);\n-        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(f);\n+        final File f = getTempFile(testName);\n+        final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(f);\n         try {\n             zos.setUseZip64(Zip64Mode.Always);\n-            byte[] buf = new byte[ONE_MILLION];\n-            ZipArchiveEntry zae = new ZipArchiveEntry(\"5GB_of_Zeros\");\n+            final byte[] buf = new byte[ONE_MILLION];\n+            final ZipArchiveEntry zae = new ZipArchiveEntry(\"5GB_of_Zeros\");\n             zae.setSize(FIVE_BILLION);\n             zae.setMethod(ZipEntry.DEFLATED);\n             zae.setCrc(0x8a408f16L);\n             }\n             zos.closeArchiveEntry();\n             zos.close();\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             System.err.println(\"Failed to write archive because of: \"\n                                + ex.getMessage()\n                                + \" - likely not enough disk space.\");\n                     zos.setUseZip64(mode);\n                 }\n                 write100KFilesToStream(zos);\n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     final long end = a.length();\n \n                     // value 0xFFFF as \"number of entries\".\n                     a.seek(end\n                            - 22 /* length of EOCD without file comment */);\n-                    byte[] eocd = new byte[12];\n+                    final byte[] eocd = new byte[12];\n                     a.readFully(eocd);\n                     assertArrayEquals(new byte[] {\n                             // sig\n                     // locator\" is right in front of the EOCD and\n                     // the location of the \"Zip64 end of central\n                     // directory record\" seems correct\n-                    long expectedZ64EocdOffset = end - 22 /* eocd.length */\n+                    final long expectedZ64EocdOffset = end - 22 /* eocd.length */\n                         - 20 /* z64 eocd locator.length */\n                         - 56 /* z64 eocd without extensible data sector */;\n-                    byte[] loc =\n+                    final byte[] loc =\n                         ZipEightByteInteger.getBytes(expectedZ64EocdOffset);\n                     a.seek(end - 22 - 20);\n-                    byte[] z64EocdLoc = new byte[20];\n+                    final byte[] z64EocdLoc = new byte[20];\n                     a.readFully(z64EocdLoc);\n                     assertArrayEquals(new byte[] {\n                             // sig\n                     // known values are fine and read the location\n                     // of the central directory from it\n                     a.seek(expectedZ64EocdOffset);\n-                    byte[] z64EocdStart = new byte[40];\n+                    final byte[] z64EocdStart = new byte[40];\n                     a.readFully(z64EocdStart);\n                     assertArrayEquals(new byte[] {\n                             // sig\n                             0, 0, 0, 0,\n                         }, z64EocdStart);\n                     a.seek(expectedZ64EocdOffset + 48 /* skip size */);\n-                    byte[] cdOffset = new byte[8];\n+                    final byte[] cdOffset = new byte[8];\n                     a.readFully(cdOffset);\n-                    long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n+                    final long cdLoc = ZipEightByteInteger.getLongValue(cdOffset);\n \n                     // finally verify there really is a central\n                     // directory entry where the Zip64 EOCD claims\n                     a.seek(cdLoc);\n-                    byte[] sig = new byte[4];\n+                    final byte[] sig = new byte[4];\n                     a.readFully(sig);\n                     assertArrayEquals(new byte[] {\n                             (byte) 0x50, (byte) 0x4b, 1, 2,\n                 try {\n                     write100KFilesToStream(zos);\n                     fail(\"expected a Zip64RequiredException\");\n-                } catch (Zip64RequiredException ex) {\n+                } catch (final Zip64RequiredException ex) {\n                     assertEquals(Zip64RequiredException.TOO_MANY_ENTRIES_MESSAGE,\n                                  ex.getMessage());\n                 }\n                 }\n                 write3EntriesCreatingBigArchiveToStream(zos);\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n                     // skip first two entries\n                     // grab third entry, verify offset is\n                     // 0xFFFFFFFF and it has a ZIP64 extended\n                     // information extra field\n-                    byte[] header = new byte[12];\n+                    final byte[] header = new byte[12];\n                     a.readFully(header);\n                     assertArrayEquals(new byte[] {\n                             // sig\n                         }, header);\n                     // ignore timestamp, CRC, compressed size\n                     a.skipBytes(12);\n-                    byte[] rest = new byte[23];\n+                    final byte[] rest = new byte[23];\n                     a.readFully(rest);\n                     assertArrayEquals(new byte[] {\n                             // Original Size\n                             // file name\n                             (byte) '2'\n                         }, rest);\n-                    byte[] extra = new byte[4];\n+                    final byte[] extra = new byte[4];\n                     a.readFully(extra);\n                     assertArrayEquals(new byte[] {\n                             // Header-ID\n                         }, extra);\n \n                     // read offset of LFH\n-                    byte[] offset = new byte[8];\n+                    final byte[] offset = new byte[8];\n                     a.readFully(offset);\n                     // verify there is a LFH where the CD claims it\n                     a.seek(ZipEightByteInteger.getLongValue(offset));\n-                    byte[] sig = new byte[4];\n+                    final byte[] sig = new byte[4];\n                     a.readFully(sig);\n                     assertArrayEquals(new byte[] {\n                             (byte) 0x50, (byte) 0x4b, 3, 4,\n                 try {\n                     write3EntriesCreatingBigArchiveToStream(zos);\n                     fail(\"expected a Zip64RequiredException\");\n-                } catch (Zip64RequiredException ex) {\n+                } catch (final Zip64RequiredException ex) {\n                     assertEquals(Zip64RequiredException.ARCHIVE_TOO_BIG_MESSAGE,\n                                  ex.getMessage());\n                 }\n                                      try {\n                                          zf = new ZipFile(f);\n                                          int idx = 0;\n-                                         for (Enumeration<ZipArchiveEntry> e =\n+                                         for (final Enumeration<ZipArchiveEntry> e =\n                                                   zf.getEntriesInPhysicalOrder();\n                                               e.hasMoreElements(); ) {\n-                                             ZipArchiveEntry zae = e.nextElement();\n+                                             final ZipArchiveEntry zae = e.nextElement();\n                                              assertEquals(String.valueOf(idx),\n                                                           zae.getName());\n                                              if (idx++ < 2) {\n                                              } else {\n                                                  assertEquals(1,\n                                                               zae.getSize());\n-                                                 InputStream i =\n+                                                 final InputStream i =\n                                                      zf.getInputStream(zae);\n                                                  try {\n                                                      assertNotNull(i);\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(FIVE_BILLION);\n                     zae.setCrc(0x5c316f50L);\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                             // file name\n                             (byte) '0'\n                         }, rest);\n-                    byte[] extra = new byte[20];\n+                    final byte[] extra = new byte[20];\n                     a.readFully(extra);\n                     // 5e9 == 0x12A05F200\n                     assertArrayEquals(new byte[] {\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n-                    byte[] buf = new byte[ONE_MILLION];\n-                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    final byte[] buf = new byte[ONE_MILLION];\n+                    final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                     if (knownSize) {\n                         zae.setSize(FIVE_BILLION);\n                         zae.setCrc(0x5c316f50L);\n                     }\n                     zos.closeArchiveEntry();\n                     fail(\"expected a Zip64RequiredException\");\n-                } catch (Zip64RequiredException ex) {\n+                } catch (final Zip64RequiredException ex) {\n                     assertTrue(ex.getMessage().startsWith(\"0's size\"));\n                 }\n             }\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(FIVE_BILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a =\n+                final RandomAccessFile a =\n                     new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n-                    long cfhPos = a.getFilePointer();\n+                    final long cfhPos = a.getFilePointer();\n                     // grab first entry, verify\n                     // sizes are 0xFFFFFFFF and\n                     // it has a ZIP64 extended\n                             // file name\n                             (byte) '0'\n                         }, rest);\n-                    byte[] extra = new byte[20];\n+                    final byte[] extra = new byte[20];\n                     a.readFully(extra);\n                     // 5e9 == 0x12A05F200\n                     assertArrayEquals(new byte[] {\n                     if (mode != Zip64Mode.AsNeeded) {\n                         zos.setUseZip64(mode);\n                     }\n-                    byte[] buf = new byte[ONE_MILLION];\n-                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    final byte[] buf = new byte[ONE_MILLION];\n+                    final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                     zae.setMethod(ZipEntry.DEFLATED);\n                     zos.putArchiveEntry(zae);\n                     for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) {\n                     }\n                     zos.closeArchiveEntry();\n                     fail(\"expected a Zip64RequiredException\");\n-                } catch (Zip64RequiredException ex) {\n+                } catch (final Zip64RequiredException ex) {\n                     assertTrue(ex.getMessage().startsWith(\"0's size\"));\n                 }\n             }\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(FIVE_BILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                                      throws IOException {\n                                      zos.setUseZip64(Zip64Mode.Never);\n                                      try {\n-                                         ZipArchiveEntry zae =\n+                                         final ZipArchiveEntry zae =\n                                              new ZipArchiveEntry(\"0\");\n                                          zae.setSize(FIVE_BILLION);\n                                          zae.setMethod(ZipEntry.DEFLATED);\n                                          zos.putArchiveEntry(zae);\n                                          fail(\"expected a\"\n                                               + \" Zip64RequiredException\");\n-                                     } catch (Zip64RequiredException ex) {\n+                                     } catch (final Zip64RequiredException ex) {\n                                          assertTrue(ex.getMessage()\n                                                     .startsWith(\"0's size\"));\n                                      }\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Never);\n                 try {\n-                    byte[] buf = new byte[ONE_MILLION];\n-                    ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                    final byte[] buf = new byte[ONE_MILLION];\n+                    final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                     if (knownSize) {\n                         zae.setSize(FIVE_BILLION);\n                     }\n                     }\n                     zos.closeArchiveEntry();\n                     fail(\"expected a Zip64RequiredException\");\n-                } catch (Zip64RequiredException ex) {\n+                } catch (final Zip64RequiredException ex) {\n                     assertTrue(ex.getMessage().startsWith(\"0's size\"));\n                 }\n             }\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                     zae.setCrc(0x1279CB9EL);\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                     // has a ZIP64 extra field if and only if size was\n                     // unknown and mode was not Never or the mode was\n                     // Always (regardless of size)\n-                    boolean hasExtra = mode == Zip64Mode.Always\n+                    final boolean hasExtra = mode == Zip64Mode.Always\n                         || (mode == Zip64Mode.AsNeeded && !knownSize);\n                     a.seek(0);\n                     header = new byte[10];\n                             (byte) '0'\n                         }, rest);\n                     if (hasExtra) {\n-                        byte[] extra = new byte[20];\n+                        final byte[] extra = new byte[20];\n                         a.readFully(extra);\n                         assertArrayEquals(new byte[] {\n                                 // Header-ID\n             public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                     zae.setCrc(0x1279CB9EL);\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n-                    long cfhPos = a.getFilePointer();\n+                    final long cfhPos = a.getFilePointer();\n                     // grab first entry, verify sizes are not\n                     // 0xFFFFFFF and it has no ZIP64 extended\n                     // information extra field\n                         }, header);\n                     // ignore timestamp\n                     a.skipBytes(4);\n-                    byte[] crc = new byte[4];\n+                    final byte[] crc = new byte[4];\n                     a.readFully(crc);\n                     assertArrayEquals(new byte[] {\n                             (byte) 0x9E, (byte) 0xCB,\n             public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n-                    long cfhPos = a.getFilePointer();\n+                    final long cfhPos = a.getFilePointer();\n                     // grab first entry, verify sizes are not\n                     // 0xFFFFFFF and it has an empty ZIP64 extended\n                     // information extra field\n                         }, header);\n                     // ignore timestamp\n                     a.skipBytes(4);\n-                    byte[] crc = new byte[4];\n+                    final byte[] crc = new byte[4];\n                     a.readFully(crc);\n                     assertArrayEquals(new byte[] {\n                             (byte) 0x9E, (byte) 0xCB,\n                 if (mode != Zip64Mode.AsNeeded) {\n                     zos.setUseZip64(mode);\n                 }\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                     rest = new byte[9];\n                     a.readFully(rest);\n \n-                    boolean hasExtra = \n+                    final boolean hasExtra = \n                         mode == Zip64Mode.AsNeeded && !knownSize;\n \n                     assertArrayEquals(new byte[] {\n                             (byte) '0'\n                         }, rest);\n                     if (hasExtra) {\n-                        byte[] extra = new byte[12];\n+                        final byte[] extra = new byte[12];\n                         a.readFully(extra);\n                         assertArrayEquals(new byte[] {\n                                 // Header-ID\n             public void test(final File f, final ZipArchiveOutputStream zos)\n                 throws IOException {\n                 zos.setUseZip64(Zip64Mode.Always);\n-                byte[] buf = new byte[ONE_MILLION];\n-                ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n+                final byte[] buf = new byte[ONE_MILLION];\n+                final ZipArchiveEntry zae = new ZipArchiveEntry(\"0\");\n                 if (knownSize) {\n                     zae.setSize(ONE_MILLION);\n                 }\n                 zos.closeArchiveEntry();\n                 zos.close();\n \n-                RandomAccessFile a = new RandomAccessFile(f, \"r\");\n+                final RandomAccessFile a = new RandomAccessFile(f, \"r\");\n                 try {\n                     getLengthAndPositionAtCentralDirectory(a);\n \n                                              final ZipOutputTest test,\n                                              final boolean useRandomAccessFile)\n         throws Throwable {\n-        File f = getTempFile(testName);\n+        final File f = getTempFile(testName);\n         BufferedOutputStream os = null;\n-        ZipArchiveOutputStream zos = useRandomAccessFile\n+        final ZipArchiveOutputStream zos = useRandomAccessFile\n             ? new ZipArchiveOutputStream(f)\n             : new ZipArchiveOutputStream(os = new BufferedOutputStream(new FileOutputStream(f)));\n         try {\n             test.test(f, zos);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             System.err.println(\"Failed to write archive because of: \"\n                                + ex.getMessage()\n                                + \" - likely not enough disk space.\");\n     }\n \n     private static File getTempFile(final String testName) throws Throwable {\n-        File f = File.createTempFile(\"commons-compress-\" + testName, \".zip\");\n+        final File f = File.createTempFile(\"commons-compress-\" + testName, \".zip\");\n         f.deleteOnExit();\n         return f;\n     }\n \n     private static void read5GBOfZerosImpl(final File f, final String expectedName)\n         throws IOException {\n-        FileInputStream fin = new FileInputStream(f);\n+        final FileInputStream fin = new FileInputStream(f);\n         ZipArchiveInputStream zin = null;\n         try {\n             zin = new ZipArchiveInputStream(fin);\n                 zae = zin.getNextZipEntry();\n             }\n             assertEquals(expectedName, zae.getName());\n-            byte[] buf = new byte[1024 * 1024];\n+            final byte[] buf = new byte[1024 * 1024];\n             long read = 0;\n-            Random r = new Random(System.currentTimeMillis());\n+            final Random r = new Random(System.currentTimeMillis());\n             int readNow;\n             while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n                 // testing all bytes for a value of 0 is going to take\n                 // too long, just pick a few ones randomly\n                 for (int i = 0; i < 1024; i++) {\n-                    int idx = r.nextInt(readNow);\n+                    final int idx = r.nextInt(readNow);\n                     assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n                 }\n                 read += readNow;\n         ZipFile zf = null;\n         try {\n             zf = new ZipFile(f);\n-            Enumeration<ZipArchiveEntry> e = zf.getEntries();\n+            final Enumeration<ZipArchiveEntry> e = zf.getEntries();\n             assertTrue(e.hasMoreElements());\n             ZipArchiveEntry zae = e.nextElement();\n             while (zae.isDirectory()) {\n             }\n             assertEquals(expectedName, zae.getName());\n             assertEquals(FIVE_BILLION, zae.getSize());\n-            byte[] buf = new byte[1024 * 1024];\n+            final byte[] buf = new byte[1024 * 1024];\n             long read = 0;\n-            Random r = new Random(System.currentTimeMillis());\n+            final Random r = new Random(System.currentTimeMillis());\n             int readNow;\n-            InputStream zin = zf.getInputStream(zae);\n+            final InputStream zin = zf.getInputStream(zae);\n             try {\n                 while ((readNow = zin.read(buf, 0, buf.length)) > 0) {\n                     // testing all bytes for a value of 0 is going to take\n                     // too long, just pick a few ones randomly\n                     for (int i = 0; i < 1024; i++) {\n-                        int idx = r.nextInt(readNow);\n+                        final int idx = r.nextInt(readNow);\n                         assertEquals(\"testing byte \" + (read + idx), 0, buf[idx]);\n                     }\n                     read += readNow;\n     }\n \n     private static void read100KFilesImpl(final File f) throws IOException {\n-        FileInputStream fin = new FileInputStream(f);\n+        final FileInputStream fin = new FileInputStream(f);\n         ZipArchiveInputStream zin = null;\n         try {\n             zin = new ZipArchiveInputStream(fin);\n         try {\n             zf = new ZipFile(f);\n             int files = 0;\n-            for (Enumeration<ZipArchiveEntry> e = zf.getEntries(); e.hasMoreElements(); ) {\n-                ZipArchiveEntry zae = e.nextElement();\n+            for (final Enumeration<ZipArchiveEntry> e = zf.getEntries(); e.hasMoreElements(); ) {\n+                final ZipArchiveEntry zae = e.nextElement();\n                 if (!zae.isDirectory()) {\n                     files++;\n                     assertEquals(0, zae.getSize());\n         throws IOException {\n         final long end = a.length();\n         a.seek(end - 22 - 20);\n-        byte[] sig = new byte[4];\n+        final byte[] sig = new byte[4];\n         a.readFully(sig);\n         if (sig[0] != (byte) 0x50 || sig[1] != (byte) 0x4b\n             || sig[2] != 6 || sig[3] != 7) {\n             return getLengthAndPositionAtCentralDirectory32(a, end);\n         }\n \n-        long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n+        final long cdOffsetLoc = end - 22 - 20 - 56 + 48;\n         // seek to central directory locator\n         a.seek(cdOffsetLoc);\n-        byte[] cdOffset = new byte[8];\n+        final byte[] cdOffset = new byte[8];\n         a.readFully(cdOffset);\n         a.seek(ZipEightByteInteger.getLongValue(cdOffset));\n         return end;\n     private static long getLengthAndPositionAtCentralDirectory32(final RandomAccessFile a, final long end)\n         throws IOException {\n         a.seek(end - 22 + 16);\n-        byte[] cdOffset = new byte[4];\n+        final byte[] cdOffset = new byte[4];\n         a.readFully(cdOffset);\n         a.seek(ZipLong.getValue(cdOffset));\n         return end;\n     private static void write100KFilesToStream(final ZipArchiveOutputStream zos)\n         throws IOException {\n         for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {\n-            ZipArchiveEntry zae = new ZipArchiveEntry(String.valueOf(i));\n+            final ZipArchiveEntry zae = new ZipArchiveEntry(String.valueOf(i));\n             zae.setSize(0);\n             zos.putArchiveEntry(zae);\n             zos.closeArchiveEntry();\n     private static void\n         write3EntriesCreatingBigArchiveToStream(final ZipArchiveOutputStream zos)\n         throws IOException {\n-        byte[] buf = new byte[ONE_MILLION];\n+        final byte[] buf = new byte[ONE_MILLION];\n         ZipArchiveEntry zae = null;\n         for (int i = 0; i < 2; i++) {\n             zae = new ZipArchiveEntry(String.valueOf(i));\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntryTest.java\n      */\n     @Test\n     public void testExtraFields() {\n-        AsiExtraField a = new AsiExtraField();\n+        final AsiExtraField a = new AsiExtraField();\n         a.setDirectory(true);\n         a.setMode(0755);\n-        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n         u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n         u.setLocalFileDataData(new byte[0]);\n \n-        ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n+        final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n         ze.setExtraFields(new ZipExtraField[] {a, u});\n-        byte[] data1 = ze.getExtra();\n+        final byte[] data1 = ze.getExtra();\n         ZipExtraField[] result = ze.getExtraFields();\n         assertEquals(\"first pass\", 2, result.length);\n         assertSame(a, result[0]);\n         assertSame(u, result[1]);\n \n-        UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n         u2.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n         u2.setLocalFileDataData(new byte[] {1});\n \n         ze.addExtraField(u2);\n-        byte[] data2 = ze.getExtra();\n+        final byte[] data2 = ze.getExtra();\n         result = ze.getExtraFields();\n         assertEquals(\"second pass\", 2, result.length);\n         assertSame(a, result[0]);\n         assertSame(u2, result[1]);\n         assertEquals(\"length second pass\", data1.length+1, data2.length);\n \n-        UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n         u3.setHeaderId(new ZipShort(2));\n         u3.setLocalFileDataData(new byte[] {1});\n         ze.addExtraField(u3);\n         assertEquals(\"third pass\", 3, result.length);\n \n         ze.removeExtraField(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n-        byte[] data3 = ze.getExtra();\n+        final byte[] data3 = ze.getExtra();\n         result = ze.getExtraFields();\n         assertEquals(\"fourth pass\", 2, result.length);\n         assertSame(a, result[0]);\n         try {\n             ze.removeExtraField(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n             fail(\"should be no such element\");\n-        } catch (java.util.NoSuchElementException nse) {\n+        } catch (final java.util.NoSuchElementException nse) {\n         }\n     }\n \n      */\n     @Test\n     public void testExtraFieldMerging() {\n-        AsiExtraField a = new AsiExtraField();\n+        final AsiExtraField a = new AsiExtraField();\n         a.setDirectory(true);\n         a.setMode(0755);\n-        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n         u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n         u.setLocalFileDataData(new byte[0]);\n \n-        ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n+        final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n         ze.setExtraFields(new ZipExtraField[] {a, u});\n \n         // merge\n         // Header-ID 1 + length 1 + one byte of data\n-        byte[] b = ExtraFieldUtilsTest.UNRECOGNIZED_HEADER.getBytes();\n+        final byte[] b = ExtraFieldUtilsTest.UNRECOGNIZED_HEADER.getBytes();\n         ze.setCentralDirectoryExtra(new byte[] {b[0], b[1], 1, 0, 127});\n \n         ZipExtraField[] result = ze.getExtraFields();\n      */\n     @Test\n     public void testAddAsFirstExtraField() {\n-        AsiExtraField a = new AsiExtraField();\n+        final AsiExtraField a = new AsiExtraField();\n         a.setDirectory(true);\n         a.setMode(0755);\n-        UnrecognizedExtraField u = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u = new UnrecognizedExtraField();\n         u.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n         u.setLocalFileDataData(new byte[0]);\n \n-        ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n+        final ZipArchiveEntry ze = new ZipArchiveEntry(\"test/\");\n         ze.setExtraFields(new ZipExtraField[] {a, u});\n-        byte[] data1 = ze.getExtra();\n-\n-        UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n+        final byte[] data1 = ze.getExtra();\n+\n+        final UnrecognizedExtraField u2 = new UnrecognizedExtraField();\n         u2.setHeaderId(ExtraFieldUtilsTest.UNRECOGNIZED_HEADER);\n         u2.setLocalFileDataData(new byte[] {1});\n \n         ze.addAsFirstExtraField(u2);\n-        byte[] data2 = ze.getExtra();\n+        final byte[] data2 = ze.getExtra();\n         ZipExtraField[] result = ze.getExtraFields();\n         assertEquals(\"second pass\", 2, result.length);\n         assertSame(u2, result[0]);\n         assertSame(a, result[1]);\n         assertEquals(\"length second pass\", data1.length + 1, data2.length);\n \n-        UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n+        final UnrecognizedExtraField u3 = new UnrecognizedExtraField();\n         u3.setHeaderId(new ZipShort(2));\n         u3.setLocalFileDataData(new byte[] {1});\n         ze.addAsFirstExtraField(u3);\n      */\n     @Test\n     public void testCompressionMethod() throws Exception {\n-        ZipArchiveOutputStream zos =\n+        final ZipArchiveOutputStream zos =\n             new ZipArchiveOutputStream(new ByteArrayOutputStream());\n-        ZipArchiveEntry entry = new ZipArchiveEntry(\"foo\");\n+        final ZipArchiveEntry entry = new ZipArchiveEntry(\"foo\");\n         assertEquals(-1, entry.getMethod());\n         assertFalse(zos.canWriteEntryData(entry));\n \n      */\n     @Test\n     public void testNotEquals() {\n-        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n-        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n+        final ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n+        final ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n         assertFalse(entry1.equals(entry2));\n     }\n \n      */\n     @Test\n     public void testNullCommentEqualsEmptyComment() {\n-        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n-        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n-        ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n+        final ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n+        final ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n+        final ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n         entry1.setComment(null);\n         entry2.setComment(\"\");\n         entry3.setComment(\"bar\");\n \n     @Test\n     public void testCopyConstructor() throws Exception {\n-        ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\n+        final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\"fred\");\n         archiveEntry.setUnixMode(0664);\n         archiveEntry.setMethod(ZipEntry.DEFLATED);\n         archiveEntry.getGeneralPurposeBit().useStrongEncryption(true);\n-        ZipArchiveEntry copy = new ZipArchiveEntry(archiveEntry);\n+        final ZipArchiveEntry copy = new ZipArchiveEntry(archiveEntry);\n         assertEquals(archiveEntry, copy);\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n         ZipArchiveInputStream in = null;\n         try {\n             zf = new ZipFile(getFile(\"COMPRESS-189.zip\"));\n-            ZipArchiveEntry zae = zf.getEntry(\"USD0558682-20080101.ZIP\");\n+            final ZipArchiveEntry zae = zf.getEntry(\"USD0558682-20080101.ZIP\");\n             in = new ZipArchiveInputStream(new BufferedInputStream(zf.getInputStream(zae)));\n             ZipArchiveEntry innerEntry;\n             while ((innerEntry = in.getNextZipEntry()) != null) {\n \n     @Test\n     public void shouldConsumeArchiveCompletely() throws Exception {\n-        InputStream is = ZipArchiveInputStreamTest.class\n+        final InputStream is = ZipArchiveInputStreamTest.class\n             .getResourceAsStream(\"/archive_with_trailer.zip\");\n-        ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n+        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n         while (zip.getNextZipEntry() != null) {\n             // just consume the archive\n         }\n-        byte[] expected = new byte[] {\n+        final byte[] expected = new byte[] {\n             'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n         };\n-        byte[] actual = new byte[expected.length];\n+        final byte[] actual = new byte[expected.length];\n         is.read(actual);\n         assertArrayEquals(expected, actual);\n         zip.close();\n \n     @Test\n     public void testUnshrinkEntry() throws Exception {\n-        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"SHRUNK.ZIP\")));\n+        final ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"SHRUNK.ZIP\")));\n         \n         ZipArchiveEntry entry = in.getNextZipEntry();\n         assertEquals(\"method\", ZipMethod.UNSHRINKING.getCode(), entry.getMethod());\n      */\n     @Test\n     public void testReadingOfFirstStoredEntry() throws Exception {\n-        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n+        final ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n         \n         try {\n-            ZipArchiveEntry ze = in.getNextZipEntry();\n+            final ZipArchiveEntry ze = in.getNextZipEntry();\n             assertEquals(5, ze.getSize());\n             assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n                               IOUtils.toByteArray(in));\n \n     @Test\n     public void testUnzipBZip2CompressedEntry() throws Exception {\n-        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"bzip2-zip.zip\")));\n+        final ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"bzip2-zip.zip\")));\n         \n         try {\n-            ZipArchiveEntry ze = in.getNextZipEntry();\n+            final ZipArchiveEntry ze = in.getNextZipEntry();\n             assertEquals(42, ze.getSize());\n-            byte[] expected = new byte[42];\n+            final byte[] expected = new byte[42];\n             Arrays.fill(expected , (byte)'a');\n             assertArrayEquals(expected, IOUtils.toByteArray(in));\n         } finally {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipEightByteIntegerTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipEightByteIntegerTest.java\n      */\n     @Test\n     public void testLongToBytes() {\n-        ZipEightByteInteger zl = new ZipEightByteInteger(0xAB12345678l);\n-        byte[] result = zl.getBytes();\n+        final ZipEightByteInteger zl = new ZipEightByteInteger(0xAB12345678l);\n+        final byte[] result = zl.getBytes();\n         assertEquals(\"length getBytes\", 8, result.length);\n         assertEquals(\"first byte getBytes\", 0x78, result[0]);\n         assertEquals(\"second byte getBytes\", 0x56, result[1]);\n      */\n     @Test\n     public void testLongFromBytes() {\n-        byte[] val = new byte[] {0x78, 0x56, 0x34, 0x12, (byte) 0xAB, 0x00, 0x00, 0x00};\n-        ZipEightByteInteger zl = new ZipEightByteInteger(val);\n+        final byte[] val = new byte[] {0x78, 0x56, 0x34, 0x12, (byte) 0xAB, 0x00, 0x00, 0x00};\n+        final ZipEightByteInteger zl = new ZipEightByteInteger(val);\n         assertEquals(\"longValue from bytes\", 0xAB12345678l, zl.getLongValue());\n     }\n \n      */\n     @Test\n     public void testBIToBytes() {\n-        ZipEightByteInteger zl =\n+        final ZipEightByteInteger zl =\n             new ZipEightByteInteger(BigInteger.valueOf(Long.MAX_VALUE)\n                                     .shiftLeft(1));\n-        byte[] result = zl.getBytes();\n+        final byte[] result = zl.getBytes();\n         assertEquals(\"length getBytes\", 8, result.length);\n         assertEquals(\"first byte getBytes\", (byte) 0xFE, result[0]);\n         assertEquals(\"second byte getBytes\", (byte) 0xFF, result[1]);\n      */\n     @Test\n     public void testBIFromBytes() {\n-        byte[] val = new byte[] {(byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};\n-        ZipEightByteInteger zl = new ZipEightByteInteger(val);\n+        final byte[] val = new byte[] {(byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};\n+        final ZipEightByteInteger zl = new ZipEightByteInteger(val);\n         assertEquals(\"value from bytes\",\n                      BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1),\n                      zl.getValue());\n      */\n     @Test\n     public void testEquals() {\n-        ZipEightByteInteger zl = new ZipEightByteInteger(0x12345678);\n-        ZipEightByteInteger zl2 = new ZipEightByteInteger(0x12345678);\n-        ZipEightByteInteger zl3 = new ZipEightByteInteger(0x87654321);\n+        final ZipEightByteInteger zl = new ZipEightByteInteger(0x12345678);\n+        final ZipEightByteInteger zl2 = new ZipEightByteInteger(0x12345678);\n+        final ZipEightByteInteger zl3 = new ZipEightByteInteger(0x87654321);\n \n         assertTrue(\"reflexive\", zl.equals(zl));\n \n      */\n     @Test\n     public void testSign() {\n-        ZipEightByteInteger zl = new ZipEightByteInteger(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});\n+        final ZipEightByteInteger zl = new ZipEightByteInteger(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});\n         assertEquals(BigInteger.valueOf(Long.MAX_VALUE).shiftLeft(1).setBit(0),\n                      zl.getValue());\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipEncodingTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipEncodingTest.java\n         // the defined ones\n         // retrieved by\n         //    awk '/^0x/ && NF>2 {print $1;}' CP1252.TXT\n-        byte[] b =\n+        final byte[] b =\n             new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n                          0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n                          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n \n         Assert.assertEquals(expected.length, actual.limit());\n \n-        for (byte anExpected : expected) {\n-            byte a = actual.get();\n+        for (final byte anExpected : expected) {\n+            final byte a = actual.get();\n             Assert.assertEquals(anExpected, a);\n         }\n \n     private void doSimpleEncodingTest(final String name, byte[] testBytes)\n         throws IOException {\n \n-        ZipEncoding enc = ZipEncodingHelper.getZipEncoding(name);\n+        final ZipEncoding enc = ZipEncodingHelper.getZipEncoding(name);\n \n         if (testBytes == null) {\n \n             }\n         }\n \n-        String decoded = enc.decode(testBytes);\n+        final String decoded = enc.decode(testBytes);\n \n         assertTrue(enc.canEncode(decoded));\n \n-        ByteBuffer encoded = enc.encode(decoded);\n+        final ByteBuffer encoded = enc.encode(decoded);\n \n         assertEquals(testBytes, encoded);\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n     @Test\n     public void testCDOrder() throws Exception {\n         readOrderTest();\n-        ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntries());\n+        final ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntries());\n         assertEntryName(l, 0, \"AbstractUnicodeExtraField\");\n         assertEntryName(l, 1, \"AsiExtraField\");\n         assertEntryName(l, 2, \"ExtraFieldUtils\");\n     @Test\n     public void testPhysicalOrder() throws Exception {\n         readOrderTest();\n-        ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntriesInPhysicalOrder());\n+        final ArrayList<ZipArchiveEntry> l = Collections.list(zf.getEntriesInPhysicalOrder());\n         assertEntryName(l, 0, \"AbstractUnicodeExtraField\");\n         assertEntryName(l, 1, \"AsiExtraField\");\n         assertEntryName(l, 2, \"ExtraFieldUtils\");\n         zf.close();\n         try {\n             zf.close();\n-        } catch (Exception ex) {\n+        } catch (final Exception ex) {\n             fail(\"Caught exception of second close\");\n         }\n     }\n \n     @Test\n     public void testReadingOfStoredEntry() throws Exception {\n-        File f = File.createTempFile(\"commons-compress-zipfiletest\", \".zip\");\n+        final File f = File.createTempFile(\"commons-compress-zipfiletest\", \".zip\");\n         f.deleteOnExit();\n         OutputStream o = null;\n         InputStream i = null;\n         try {\n             o = new FileOutputStream(f);\n-            ZipArchiveOutputStream zo = new ZipArchiveOutputStream(o);\n+            final ZipArchiveOutputStream zo = new ZipArchiveOutputStream(o);\n             ZipArchiveEntry ze = new ZipArchiveEntry(\"foo\");\n             ze.setMethod(ZipEntry.STORED);\n             ze.setSize(4);\n             ze = zf.getEntry(\"foo\");\n             assertNotNull(ze);\n             i = zf.getInputStream(ze);\n-            byte[] b = new byte[4];\n+            final byte[] b = new byte[4];\n             assertEquals(4, i.read(b));\n             assertEquals(-1, i.read());\n         } finally {\n      */\n     @Test\n     public void testWinzipBackSlashWorkaround() throws Exception {\n-        File archive = getFile(\"test-winzip.zip\");\n+        final File archive = getFile(\"test-winzip.zip\");\n         zf = new ZipFile(archive);\n         assertNull(zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\"));\n         assertNotNull(zf.getEntry(\"\\u00e4/\\u00fc.txt\"));\n      */\n     @Test\n     public void testSkipsPK00Prefix() throws Exception {\n-        File archive = getFile(\"COMPRESS-208.zip\");\n+        final File archive = getFile(\"COMPRESS-208.zip\");\n         zf = new ZipFile(archive);\n         assertNotNull(zf.getEntry(\"test1.xml\"));\n         assertNotNull(zf.getEntry(\"test2.xml\"));\n         // I looked into creating a test with hard links, but zip does not appear to\n         // support hard links, so nevermind.\n \n-        File archive = getFile(\"COMPRESS-214_unix_symlinks.zip\");\n-\n-        zf = new ZipFile(archive);\n-        Enumeration<ZipArchiveEntry> en = zf.getEntries();\n+        final File archive = getFile(\"COMPRESS-214_unix_symlinks.zip\");\n+\n+        zf = new ZipFile(archive);\n+        final Enumeration<ZipArchiveEntry> en = zf.getEntries();\n         while (en.hasMoreElements()) {\n-            ZipArchiveEntry zae = en.nextElement();\n-            String link = zf.getUnixSymlink(zae);\n+            final ZipArchiveEntry zae = en.nextElement();\n+            final String link = zf.getUnixSymlink(zae);\n             if (zae.isUnixSymlink()) {\n-                String name = zae.getName();\n-                String expected = expectedVals.get(name);\n+                final String name = zae.getName();\n+                final String expected = expectedVals.get(name);\n                 assertEquals(expected, link);\n             } else {\n                 // Should be null if it's not a symlink!\n      */\n     @Test\n     public void testDuplicateEntry() throws Exception {\n-        File archive = getFile(\"COMPRESS-227.zip\");\n-        zf = new ZipFile(archive);\n-\n-        ZipArchiveEntry ze = zf.getEntry(\"test1.txt\");\n+        final File archive = getFile(\"COMPRESS-227.zip\");\n+        zf = new ZipFile(archive);\n+\n+        final ZipArchiveEntry ze = zf.getEntry(\"test1.txt\");\n         assertNotNull(ze);\n         assertNotNull(zf.getInputStream(ze));\n \n         int numberOfEntries = 0;\n-        for (ZipArchiveEntry entry : zf.getEntries(\"test1.txt\")) {\n+        for (final ZipArchiveEntry entry : zf.getEntries(\"test1.txt\")) {\n             numberOfEntries++;\n             assertNotNull(zf.getInputStream(entry));\n         }\n      */\n     @Test\n     public void testExcessDataInZip64ExtraField() throws Exception {\n-        File archive = getFile(\"COMPRESS-228.zip\");\n+        final File archive = getFile(\"COMPRESS-228.zip\");\n         zf = new ZipFile(archive);\n         // actually, if we get here, the test already has passed\n \n-        ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n+        final ZipArchiveEntry ze = zf.getEntry(\"src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\");\n         assertEquals(26101, ze.getSize());\n     }\n \n      */\n     @Test\n     public void testReadingOfFirstStoredEntry() throws Exception {\n-        File archive = getFile(\"COMPRESS-264.zip\");\n-        zf = new ZipFile(archive);\n-        ZipArchiveEntry ze = zf.getEntry(\"test.txt\");\n+        final File archive = getFile(\"COMPRESS-264.zip\");\n+        zf = new ZipFile(archive);\n+        final ZipArchiveEntry ze = zf.getEntry(\"test.txt\");\n         assertEquals(5, ze.getSize());\n         assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n                           IOUtils.toByteArray(zf.getInputStream(ze)));\n \n     @Test\n     public void testUnzipBZip2CompressedEntry() throws Exception {\n-        File archive = getFile(\"bzip2-zip.zip\");\n-        zf = new ZipFile(archive);\n-        ZipArchiveEntry ze = zf.getEntry(\"lots-of-as\");\n+        final File archive = getFile(\"bzip2-zip.zip\");\n+        zf = new ZipFile(archive);\n+        final ZipArchiveEntry ze = zf.getEntry(\"lots-of-as\");\n         assertEquals(42, ze.getSize());\n-        byte[] expected = new byte[42];\n+        final byte[] expected = new byte[42];\n         Arrays.fill(expected , (byte)'a');\n         assertArrayEquals(expected, IOUtils.toByteArray(zf.getInputStream(ze)));\n     }\n      * central directory order is different from entry data order.\n      */\n     private void readOrderTest() throws Exception {\n-        File archive = getFile(\"ordertest.zip\");\n+        final File archive = getFile(\"ordertest.zip\");\n         zf = new ZipFile(archive);\n     }\n \n     private static void assertEntryName(final ArrayList<ZipArchiveEntry> entries,\n                                         final int index,\n                                         final String expectedName) {\n-        ZipArchiveEntry ze = entries.get(index);\n+        final ZipArchiveEntry ze = entries.get(index);\n         assertEquals(\"src/main/java/org/apache/commons/compress/archivers/zip/\"\n                      + expectedName + \".java\",\n                      ze.getName());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipLongTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipLongTest.java\n      */\n     @Test\n     public void testToBytes() {\n-        ZipLong zl = new ZipLong(0x12345678);\n-        byte[] result = zl.getBytes();\n+        final ZipLong zl = new ZipLong(0x12345678);\n+        final byte[] result = zl.getBytes();\n         assertEquals(\"length getBytes\", 4, result.length);\n         assertEquals(\"first byte getBytes\", 0x78, result[0]);\n         assertEquals(\"second byte getBytes\", 0x56, result[1]);\n      */\n     @Test\n     public void testPut() {\n-        byte[] arr = new byte[5];\n+        final byte[] arr = new byte[5];\n         ZipLong.putLong(0x12345678, arr, 1);\n         assertEquals(\"first byte getBytes\", 0x78, arr[1]);\n         assertEquals(\"second byte getBytes\", 0x56, arr[2]);\n      */\n     @Test\n     public void testFromBytes() {\n-        byte[] val = new byte[] {0x78, 0x56, 0x34, 0x12};\n-        ZipLong zl = new ZipLong(val);\n+        final byte[] val = new byte[] {0x78, 0x56, 0x34, 0x12};\n+        final ZipLong zl = new ZipLong(val);\n         assertEquals(\"value from bytes\", 0x12345678, zl.getValue());\n     }\n \n      */\n     @Test\n     public void testEquals() {\n-        ZipLong zl = new ZipLong(0x12345678);\n-        ZipLong zl2 = new ZipLong(0x12345678);\n-        ZipLong zl3 = new ZipLong(0x87654321);\n+        final ZipLong zl = new ZipLong(0x12345678);\n+        final ZipLong zl2 = new ZipLong(0x12345678);\n+        final ZipLong zl3 = new ZipLong(0x87654321);\n \n         assertTrue(\"reflexive\", zl.equals(zl));\n \n      */\n     @Test\n     public void testSign() {\n-        ZipLong zl = new ZipLong(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});\n+        final ZipLong zl = new ZipLong(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});\n         assertEquals(0x00000000FFFFFFFFl, zl.getValue());\n     }\n \n     @Test\n     public void testClone() {\n-        ZipLong s1 = new ZipLong(42);\n-        ZipLong s2 = (ZipLong) s1.clone();\n+        final ZipLong s1 = new ZipLong(42);\n+        final ZipLong s2 = (ZipLong) s1.clone();\n         assertNotSame(s1, s2);\n         assertEquals(s1, s2);\n         assertEquals(s1.getValue(), s2.getValue());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipShortTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipShortTest.java\n      */\n     @Test\n     public void testToBytes() {\n-        ZipShort zs = new ZipShort(0x1234);\n-        byte[] result = zs.getBytes();\n+        final ZipShort zs = new ZipShort(0x1234);\n+        final byte[] result = zs.getBytes();\n         assertEquals(\"length getBytes\", 2, result.length);\n         assertEquals(\"first byte getBytes\", 0x34, result[0]);\n         assertEquals(\"second byte getBytes\", 0x12, result[1]);\n      */\n     @Test\n     public void testPut() {\n-        byte[] arr = new byte[3];\n+        final byte[] arr = new byte[3];\n         ZipShort.putShort(0x1234, arr, 1);\n         assertEquals(\"first byte getBytes\", 0x34, arr[1]);\n         assertEquals(\"second byte getBytes\", 0x12, arr[2]);\n      */\n     @Test\n     public void testFromBytes() {\n-        byte[] val = new byte[] {0x34, 0x12};\n-        ZipShort zs = new ZipShort(val);\n+        final byte[] val = new byte[] {0x34, 0x12};\n+        final ZipShort zs = new ZipShort(val);\n         assertEquals(\"value from bytes\", 0x1234, zs.getValue());\n     }\n \n      */\n     @Test\n     public void testEquals() {\n-        ZipShort zs = new ZipShort(0x1234);\n-        ZipShort zs2 = new ZipShort(0x1234);\n-        ZipShort zs3 = new ZipShort(0x5678);\n+        final ZipShort zs = new ZipShort(0x1234);\n+        final ZipShort zs2 = new ZipShort(0x1234);\n+        final ZipShort zs3 = new ZipShort(0x5678);\n \n         assertTrue(\"reflexive\", zs.equals(zs));\n \n      */\n     @Test\n     public void testSign() {\n-        ZipShort zs = new ZipShort(new byte[] {(byte)0xFF, (byte)0xFF});\n+        final ZipShort zs = new ZipShort(new byte[] {(byte)0xFF, (byte)0xFF});\n         assertEquals(0x0000FFFF, zs.getValue());\n     }\n \n     @Test\n     public void testClone() {\n-        ZipShort s1 = new ZipShort(42);\n-        ZipShort s2 = (ZipShort) s1.clone();\n+        final ZipShort s1 = new ZipShort(42);\n+        final ZipShort s2 = (ZipShort) s1.clone();\n         assertNotSame(s1, s2);\n         assertEquals(s1, s2);\n         assertEquals(s1.getValue(), s2.getValue());\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipUtilTest.java\n     @Before\n     public void setUp() throws Exception {\n         time = new Date();\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(time);\n-        int year = cal.get(Calendar.YEAR);\n-        int month = cal.get(Calendar.MONTH) + 1;\n-        long value =  ((year - 1980) << 25)\n+        final int year = cal.get(Calendar.YEAR);\n+        final int month = cal.get(Calendar.MONTH) + 1;\n+        final long value =  ((year - 1980) << 25)\n             |         (month << 21)\n             |         (cal.get(Calendar.DAY_OF_MONTH) << 16)\n             |         (cal.get(Calendar.HOUR_OF_DAY) << 11)\n             |         (cal.get(Calendar.MINUTE) << 5)\n             |         (cal.get(Calendar.SECOND) >> 1);\n \n-        byte[] result = new byte[4];\n+        final byte[] result = new byte[4];\n         result[0] = (byte) ((value & 0xFF));\n         result[1] = (byte) ((value & 0xFF00) >> 8);\n         result[2] = (byte) ((value & 0xFF0000) >> 16);\n \n     @Test\n     public void testZipLong() throws Exception {\n-        ZipLong test = ZipUtil.toDosTime(time);\n+        final ZipLong test = ZipUtil.toDosTime(time);\n         assertEquals(test.getValue(), zl.getValue());\n     }\n \n \n     @Test\n     public void testMinTime(){\n-        byte[] b1 = ZipUtil.toDosTime(0);\n-        byte b10 = b1[0]; // Save the first byte\n+        final byte[] b1 = ZipUtil.toDosTime(0);\n+        final byte b10 = b1[0]; // Save the first byte\n         b1[0]++; // change it\n-        byte[] b2 = ZipUtil.toDosTime(0); // get the same time\n+        final byte[] b2 = ZipUtil.toDosTime(0); // get the same time\n         assertEquals(b10,b2[0]); // first byte should still be the same\n     }\n \n     @Test\n     public void testOutsideCalendar(){\n-        byte[] b1 = ZipUtil.toDosTime(160441200000L); // 1.1..1975\n+        final byte[] b1 = ZipUtil.toDosTime(160441200000L); // 1.1..1975\n         assertEquals(0, b1[0]);\n         assertEquals(33, b1[1]);\n         assertEquals(0, b1[2]);\n \n     @Test\n     public void testInsideCalendar(){\n-        TimeZone tz = TimeZone.getDefault();\n-        long date = 476096400000L; // 1.1.1985, 10:00 am GMT\n-        byte[] b1 = ZipUtil.toDosTime(date - tz.getOffset(date));\n+        final TimeZone tz = TimeZone.getDefault();\n+        final long date = 476096400000L; // 1.1.1985, 10:00 am GMT\n+        final byte[] b1 = ZipUtil.toDosTime(date - tz.getOffset(date));\n         assertEquals(0, b1[0]);\n         assertEquals(72, b1[1]);\n         assertEquals(65, b1[2]);\n \n     @Test\n     public void testReverse() {\n-        byte[][] bTest = new byte[6][];\n+        final byte[][] bTest = new byte[6][];\n         bTest[0] = new byte[]{};\n         bTest[1] = new byte[]{1};\n         bTest[2] = new byte[]{1, 2};\n         bTest[4] = new byte[]{1, 2, 3, 4};\n         bTest[5] = new byte[]{1, 2, 3, 4, 5};\n \n-        byte[][] rTest = new byte[6][];\n+        final byte[][] rTest = new byte[6][];\n         rTest[0] = new byte[]{};\n         rTest[1] = new byte[]{1};\n         rTest[2] = new byte[]{2, 1};\n         assertEquals(\"test and result arrays are same length\", bTest.length, rTest.length);\n \n         for (int i = 0; i < bTest.length; i++) {\n-            byte[] result = ZipUtil.reverse(bTest[i]);\n+            final byte[] result = ZipUtil.reverse(bTest[i]);\n             assertTrue(\"reverse mutates in-place\", bTest[i] == result);\n             assertTrue(\"reverse actually reverses\", Arrays.equals(rTest[i], result));\n         }\n \n     @Test\n     public void testBigToLong() {\n-        BigInteger big1 = BigInteger.valueOf(1);\n-        BigInteger big2 = BigInteger.valueOf(Long.MAX_VALUE);\n-        BigInteger big3 = BigInteger.valueOf(Long.MIN_VALUE);\n+        final BigInteger big1 = BigInteger.valueOf(1);\n+        final BigInteger big2 = BigInteger.valueOf(Long.MAX_VALUE);\n+        final BigInteger big3 = BigInteger.valueOf(Long.MIN_VALUE);\n \n         assertEquals(1L, ZipUtil.bigToLong(big1));\n         assertEquals(Long.MAX_VALUE, ZipUtil.bigToLong(big2));\n         assertEquals(Long.MIN_VALUE, ZipUtil.bigToLong(big3));\n \n-        BigInteger big4 = big2.add(big1);\n+        final BigInteger big4 = big2.add(big1);\n         try {\n             ZipUtil.bigToLong(big4);\n             fail(\"Should have thrown IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n-            // All is good.\n-        }\n-\n-        BigInteger big5 = big3.subtract(big1);\n+        } catch (final IllegalArgumentException iae) {\n+            // All is good.\n+        }\n+\n+        final BigInteger big5 = big3.subtract(big1);\n         try {\n             ZipUtil.bigToLong(big5);\n             fail(\"ZipUtil.bigToLong(BigInteger) should have thrown IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // All is good.\n         }\n     }\n \n     @Test\n     public void testLongToBig() {\n-        long l0 = 0;\n-        long l1 = 1;\n-        long l2 = -1;\n-        long l3 = Integer.MIN_VALUE;\n-        long l4 = Long.MAX_VALUE;\n-        long l5 = Long.MIN_VALUE;\n-\n-        BigInteger big0 = ZipUtil.longToBig(l0);\n-        BigInteger big1 = ZipUtil.longToBig(l1);\n-        BigInteger big2 = ZipUtil.longToBig(l2);\n-        BigInteger big3 = ZipUtil.longToBig(l3);\n-        BigInteger big4 = ZipUtil.longToBig(l4);\n+        final long l0 = 0;\n+        final long l1 = 1;\n+        final long l2 = -1;\n+        final long l3 = Integer.MIN_VALUE;\n+        final long l4 = Long.MAX_VALUE;\n+        final long l5 = Long.MIN_VALUE;\n+\n+        final BigInteger big0 = ZipUtil.longToBig(l0);\n+        final BigInteger big1 = ZipUtil.longToBig(l1);\n+        final BigInteger big2 = ZipUtil.longToBig(l2);\n+        final BigInteger big3 = ZipUtil.longToBig(l3);\n+        final BigInteger big4 = ZipUtil.longToBig(l4);\n \n         assertEquals(0, big0.longValue());\n         assertEquals(1, big1.longValue());\n         try {\n             ZipUtil.longToBig(l5);\n             fail(\"ZipUtil.longToBig(long) should have thrown IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n \n         }\n     }\n         // Yay, we can completely test all possible input values in this case!\n         int expectedVal = 128;\n         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\n-            byte b = (byte) i;\n+            final byte b = (byte) i;\n             assertEquals(expectedVal, ZipUtil.signedByteToUnsignedInt(b));\n             expectedVal++;\n             if (expectedVal == 256) {\n     public void testUnsignedIntToSignedByte() {\n         int unsignedVal = 128;\n         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\n-            byte expectedVal = (byte) i;\n+            final byte expectedVal = (byte) i;\n             assertEquals(expectedVal, ZipUtil.unsignedIntToSignedByte(unsignedVal));\n             unsignedVal++;\n             if (unsignedVal == 256) {\n         try {\n             ZipUtil.unsignedIntToSignedByte(-1);\n             fail(\"ZipUtil.unsignedIntToSignedByte(-1) should have thrown IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // All is good.\n         }\n \n         try {\n             ZipUtil.unsignedIntToSignedByte(256);\n             fail(\"ZipUtil.unsignedIntToSignedByte(256) should have thrown IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // All is good.\n         }\n \n--- a/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/changes/ChangeSetTestCase.java\n \n     // Delete a directory tree\n     private void archiveListDeleteDir(final String prefix){\n-        Iterator<String> it = archiveList.iterator();\n+        final Iterator<String> it = archiveList.iterator();\n         while(it.hasNext()){\n-            String entry = it.next();\n+            final String entry = it.next();\n             if (entry.startsWith(prefix+\"/\")){ // TODO won't work with folders\n                 it.remove();\n             }\n \n     // Delete a single file\n     private void archiveListDelete(final String prefix){\n-        Iterator<String> it = archiveList.iterator();\n+        final Iterator<String> it = archiveList.iterator();\n         while(it.hasNext()){\n-            String entry = it.next();\n+            final String entry = it.next();\n             if (entry.equals(prefix)){\n                 it.remove();\n             }\n             in = new FileInputStream(getFile(\"test.txt\"));\n             in2 = new FileInputStream(getFile(\"test2.xml\"));\n \n-            ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n-            ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n-\n-            ChangeSet changes = new ChangeSet();\n+            final ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n+            final ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.add(e, in);\n             changes.add(e2, in2);\n \n             assertEquals(1, changes.getChanges().size());\n-            Change c = changes.getChanges().iterator().next();\n+            final Change c = changes.getChanges().iterator().next();\n             assertEquals(in2, c.getInput());\n         } finally {\n             if (in != null) {\n             in = new FileInputStream(getFile(\"test.txt\"));\n             in2 = new FileInputStream(getFile(\"test2.xml\"));\n \n-            ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n-            ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n-\n-            ChangeSet changes = new ChangeSet();\n+            final ArchiveEntry e = new ZipArchiveEntry(\"test.txt\");\n+            final ArchiveEntry e2 = new ZipArchiveEntry(\"test.txt\");\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.add(e, in, true);\n             changes.add(e2, in2, false);\n \n             assertEquals(1, changes.getChanges().size());\n-            Change c = changes.getChanges().iterator().next();\n+            final Change c = changes.getChanges().iterator().next();\n             assertEquals(in, c.getInput());\n         } finally {\n             if (in != null) {\n     @Test\n     public void testDeleteDir() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.deleteDir(\"bla\");\n             archiveListDeleteDir(\"bla\");\n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteDir2() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.deleteDir(\"la\");\n             archiveListDeleteDir(\"la\");\n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteDir3() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.deleteDir(\"test.txt\");\n             archiveListDeleteDir(\"test.txt\");\n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteFile() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla/test5.xml\");\n             archiveListDelete(\"bla/test5.xml\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteFile2() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"bla\");\n             //archiveListDelete(\"bla\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeletePlusAddSame() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n         result.deleteOnExit();\n \n         File testtxt = null;\n             out = factory.createArchiveOutputStream(archivename,\n                     new FileOutputStream(result));\n \n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test/test3.xml\");\n             archiveListDelete(\"test/test3.xml\");\n \n             // Add a file\n             testtxt = getFile(\"test.txt\");\n-            ArchiveEntry entry = out.createArchiveEntry(testtxt, \"test/test3.xml\");\n+            final ArchiveEntry entry = out.createArchiveEntry(testtxt, \"test/test3.xml\");\n             changes.add(entry, new FileInputStream(testtxt));\n             archiveList.add(\"test/test3.xml\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n             final BufferedInputStream buf = new BufferedInputStream(is);\n             in = factory.createArchiveInputStream(buf);\n             check = this.checkArchiveContent(in, archiveList, false);\n-            File test3xml = new File(check,\"result/test/test3.xml\");\n+            final File test3xml = new File(check,\"result/test/test3.xml\");\n             assertEquals(testtxt.length(), test3xml.length());\n \n-            BufferedReader reader = new BufferedReader(new FileReader(test3xml));\n+            final BufferedReader reader = new BufferedReader(new FileReader(test3xml));\n             String str;\n             while ((str = reader.readLine()) != null) {\n                 // All lines look like this\n     @Test\n     public void testChangeSetResults() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.deleteDir(\"bla\");\n             archiveListDeleteDir(\"bla\");\n \n             // Add a file\n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = out.createArchiveEntry(file1, \"bla/test.txt\");\n+            final ArchiveEntry entry = out.createArchiveEntry(file1, \"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            ChangeSetResults results = performer.perform(ais, out);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetResults results = performer.perform(ais, out);\n             is.close();\n \n             // Checks\n     @Test\n     public void testDeletePlusAdd() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n             changes.deleteDir(\"bla\");\n             archiveListDeleteDir(\"bla\");\n \n             // Add a file\n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = out.createArchiveEntry(file1, \"bla/test.txt\");\n+            final ArchiveEntry entry = out.createArchiveEntry(file1, \"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteFromAndAddToZip() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\n+            final ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"blub/test.txt\");\n \n             changes.delete(\"testdata/test1.xml\");\n             archiveListDelete(\"testdata/test1.xml\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteFromAndAddToZipUsingZipFilePerform() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createArchive(archivename);\n+        final File input = this.createArchive(archivename);\n \n         ArchiveOutputStream out = null;\n         ZipFile ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n         result.deleteOnExit();\n         try {\n \n             out = factory.createArchiveOutputStream(archivename,\n                     new FileOutputStream(result));\n \n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\n+            final ArchiveEntry entry = new ZipArchiveEntry(\"blub/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"blub/test.txt\");\n \n             changes.delete(\"testdata/test1.xml\");\n             archiveListDelete(\"testdata/test1.xml\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n \n         } finally {\n     @Test\n     public void testAddDeleteAdd() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new CpioArchiveEntry(\"blub/test.txt\");\n+            final ArchiveEntry entry = new CpioArchiveEntry(\"blub/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"blub/test.txt\");\n \n             changes.deleteDir(\"blub\");\n             archiveListDeleteDir(\"blub\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n \n             is.close();\n     @Test\n     public void testDeleteAddDelete() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n \n             changes.deleteDir(\"bla\");\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new CpioArchiveEntry(\"bla/test.txt\");\n+            final ArchiveEntry entry = new CpioArchiveEntry(\"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n \n             changes.deleteDir(\"bla\");\n             archiveListDeleteDir(\"bla\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n \n             is.close();\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n \n             final File input = getFile(\"bla.zip\");\n             out = factory.createArchiveOutputStream(\"zip\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n \n         this.checkArchiveContent(temp, expected);\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n \n             final File input = getFile(\"bla.tar\");\n             out = factory.createArchiveOutputStream(\"tar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         this.checkArchiveContent(temp, expected);\n     }\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n             changes.deleteDir(\"META-INF\");\n             changes.delete(\".classpath\");\n             out = factory.createArchiveOutputStream(\"jar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         this.checkArchiveContent(temp, expected);\n     }\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n \n             final File file1 = getFile(\"test.txt\");\n             out = factory.createArchiveOutputStream(\"tar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         expected.add(\"testdata/test.txt\");\n         final ArchiveInputStream in = factory.createArchiveInputStream(\"tar\", new FileInputStream(temp));\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n             changes.deleteDir(\"META-INF\");\n             changes.delete(\".classpath\");\n             changes.delete(\".project\");\n \n             final File file1 = getFile(\"test.txt\");\n-            JarArchiveEntry entry = new JarArchiveEntry(\"testdata/test.txt\");\n+            final JarArchiveEntry entry = new JarArchiveEntry(\"testdata/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n \n             final File input = getFile(\"bla.jar\");\n             out = factory.createArchiveOutputStream(\"jar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         expected.add(\"testdata/test.txt\");\n         this.checkArchiveContent(temp, expected);\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n \n             final File input = getFile(\"bla.ar\");\n             out = factory.createArchiveOutputStream(\"ar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         this.checkArchiveContent(temp, expected);\n     }\n         ArchiveInputStream ais = null;\n         File temp = null;\n         try {\n-            ChangeSet changes = new ChangeSet();\n+            final ChangeSet changes = new ChangeSet();\n             changes.delete(\"test2.xml\");\n \n             final File file1 = getFile(\"test.txt\");\n             out = factory.createArchiveOutputStream(\"ar\",\n                     new FileOutputStream(temp));\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            performer.perform(ais, out);\n-\n-        } finally {\n-            if (out != null) {\n-                out.close();\n-            }\n-            if (ais != null) {\n-                ais.close();\n-            }\n-        }\n-        List<String> expected = new ArrayList<String>();\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            performer.perform(ais, out);\n+\n+        } finally {\n+            if (out != null) {\n+                out.close();\n+            }\n+            if (ais != null) {\n+                ais.close();\n+            }\n+        }\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(\"test1.xml\");\n         expected.add(\"test.txt\");\n         this.checkArchiveContent(temp, expected);\n     @Test\n     public void testAddToEmptyArchive() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createEmptyArchive(archivename);\n+        final File input = this.createEmptyArchive(archivename);\n \n         ArchiveOutputStream out = null;\n         ArchiveInputStream ais = null;\n         InputStream is = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        ChangeSet changes = new ChangeSet();\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        final ChangeSet changes = new ChangeSet();\n         try {\n \n             is = new FileInputStream(input);\n                     new FileOutputStream(result));\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new ZipArchiveEntry(\"bla/test.txt\");\n+            final ArchiveEntry entry = new ZipArchiveEntry(\"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file1));\n             archiveList.add(\"bla/test.txt\");\n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testDeleteAddToOneFileArchive() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createSingleEntryArchive(archivename);\n+        final File input = this.createSingleEntryArchive(archivename);\n \n         ArchiveOutputStream out = null;\n         ArchiveInputStream ais = null;\n         InputStream is = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        ChangeSet changes = new ChangeSet();\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        final ChangeSet changes = new ChangeSet();\n         try {\n \n             is = new FileInputStream(input);\n             archiveListDelete(\"test1.xml\");\n \n             final File file = getFile(\"test.txt\");\n-            ArchiveEntry entry = out.createArchiveEntry(file,\"bla/test.txt\");\n+            final ArchiveEntry entry = out.createArchiveEntry(file,\"bla/test.txt\");\n             changes.add(entry, new FileInputStream(file));\n             archiveList.add(\"bla/test.txt\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testAddDeleteToOneFileArchive() throws Exception {\n         final String archivename = \"cpio\";\n-        File input = this.createSingleEntryArchive(archivename);\n+        final File input = this.createSingleEntryArchive(archivename);\n \n         ArchiveOutputStream out = null;\n         ArchiveInputStream ais = null;\n         InputStream is = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        ChangeSet changes = new ChangeSet();\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        final ChangeSet changes = new ChangeSet();\n         try {\n \n             is = new FileInputStream(input);\n             out = factory.createArchiveOutputStream(archivename,\n                     new FileOutputStream(result));\n             final File file = getFile(\"test.txt\");\n-            ArchiveEntry entry = out.createArchiveEntry(file,\"bla/test.txt\"); \n+            final ArchiveEntry entry = out.createArchiveEntry(file,\"bla/test.txt\"); \n             changes.add(entry, new FileInputStream(file));\n             archiveList.add(\"bla/test.txt\");\n \n             changes.delete(\"test1.xml\");\n             archiveListDelete(\"test1.xml\");\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n             performer.perform(ais, out);\n             is.close();\n \n     @Test\n     public void testAddAllreadyExistingWithReplaceTrue() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n+            final ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n             changes.add(entry, new FileInputStream(file1), true);\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            ChangeSetResults results = performer.perform(ais, out);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetResults results = performer.perform(ais, out);\n             assertTrue(results.getAddedFromChangeSet().contains(\"testdata/test1.xml\"));\n             is.close();\n \n     @Test\n     public void testAddAllreadyExistingWithReplaceFalse() throws Exception {\n         final String archivename = \"zip\";\n-        File input = this.createArchive(archivename);\n-\n-        ArchiveOutputStream out = null;\n-        ArchiveInputStream ais = null;\n-        File result = File.createTempFile(\"test\", \".\"+archivename);\n-        result.deleteOnExit();\n-        try {\n-\n-            final InputStream is = new FileInputStream(input);\n-            ais = factory.createArchiveInputStream(archivename, is);\n-            out = factory.createArchiveOutputStream(archivename,\n-                    new FileOutputStream(result));\n-\n-            ChangeSet changes = new ChangeSet();\n+        final File input = this.createArchive(archivename);\n+\n+        ArchiveOutputStream out = null;\n+        ArchiveInputStream ais = null;\n+        final File result = File.createTempFile(\"test\", \".\"+archivename);\n+        result.deleteOnExit();\n+        try {\n+\n+            final InputStream is = new FileInputStream(input);\n+            ais = factory.createArchiveInputStream(archivename, is);\n+            out = factory.createArchiveOutputStream(archivename,\n+                    new FileOutputStream(result));\n+\n+            final ChangeSet changes = new ChangeSet();\n \n             final File file1 = getFile(\"test.txt\");\n-            ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n+            final ArchiveEntry entry = new ZipArchiveEntry(\"testdata/test1.xml\");\n             changes.add(entry, new FileInputStream(file1), false);\n \n-            ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n-            ChangeSetResults results = performer.perform(ais, out);\n+            final ChangeSetPerformer performer = new ChangeSetPerformer(changes);\n+            final ChangeSetResults results = performer.perform(ais, out);\n             assertTrue(results.getAddedFromStream().contains(\"testdata/test1.xml\"));\n             assertTrue(results.getAddedFromChangeSet().isEmpty());\n             assertTrue(results.getDeleted().isEmpty());\n--- a/src/test/java/org/apache/commons/compress/compressors/BZip2TestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/BZip2TestCase.java\n             output = new File(dir, \"test.txt.bz2\");\n             final OutputStream out = new FileOutputStream(output);\n             final CompressorOutputStream cos = new CompressorStreamFactory().createCompressorOutputStream(\"bzip2\", out);\n-            FileInputStream in = new FileInputStream(input);\n+            final FileInputStream in = new FileInputStream(input);\n             IOUtils.copy(in, cos);\n             cos.close();\n             in.close();\n             final InputStream is = new FileInputStream(toDecompress);\n             final CompressorInputStream in =\n                 new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is);\n-            FileOutputStream os = new FileOutputStream(decompressed);\n+            final FileOutputStream os = new FileOutputStream(decompressed);\n             IOUtils.copy(in, os);\n             is.close();\n             os.close();\n         final File output = new File(dir, \"bla.txt\");\n         final InputStream is = new FileInputStream(input);\n         final CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is);\n-        FileOutputStream os = new FileOutputStream(output);\n+        final FileOutputStream os = new FileOutputStream(output);\n         IOUtils.copy(in, os);\n         is.close();\n         os.close();\n--- a/src/test/java/org/apache/commons/compress/compressors/DeflateTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DeflateTestCase.java\n         final File output = new File(dir, \"test1.xml.deflate\");\n         final OutputStream out = new FileOutputStream(output);\n         try {\n-            DeflateParameters params = new DeflateParameters();\n+            final DeflateParameters params = new DeflateParameters();\n             params.setWithZlibHeader(false);\n             final CompressorOutputStream cos = new DeflateCompressorOutputStream(out, params);\n             try {\n         final File output = new File(dir, \"bla.tar\");\n         final InputStream is = new FileInputStream(input);\n         try {\n-            DeflateParameters params = new DeflateParameters();\n+            final DeflateParameters params = new DeflateParameters();\n             params.setWithZlibHeader(false);\n             final CompressorInputStream in = new DeflateCompressorInputStream(is, params);\n             FileOutputStream out = null;\n--- a/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/DetectCompressorTestCase.java\n     \n     @Test\n     public void testDetection() throws Exception {\n-        CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n+        final CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n         assertNotNull(bzip2);\n         assertTrue(bzip2 instanceof BZip2CompressorInputStream);\n \n-        CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n+        final CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n         assertNotNull(gzip);\n         assertTrue(gzip instanceof GzipCompressorInputStream);\n         \n-        CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n+        final CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n         assertNotNull(pack200);\n         assertTrue(pack200 instanceof Pack200CompressorInputStream);\n \n-        CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n+        final CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n         assertNotNull(xz);\n         assertTrue(xz instanceof XZCompressorInputStream);\n \n-        CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n+        final CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\");\n         assertNotNull(zlib);\n         assertTrue(zlib instanceof DeflateCompressorInputStream);\n \n         try {\n             factory.createCompressorInputStream(new ByteArrayInputStream(new byte[0]));\n             fail(\"No exception thrown for an empty input stream\");\n-        } catch (CompressorException e) {\n+        } catch (final CompressorException e) {\n             // expected\n         }\n     }\n         try {\n             fac.setDecompressConcatenated(true);\n             fail(\"Expected IllegalStateException\");\n-        } catch (IllegalStateException ise) {\n+        } catch (final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             fac.setDecompressConcatenated(true);\n             fail(\"Expected IllegalStateException\");\n-        } catch (IllegalStateException ise) {\n+        } catch (final IllegalStateException ise) {\n             // expected\n         }\n     }\n     @Test\n     public void testMutiples() throws Exception {\n         for(int i=0; i <tests.length; i++) {\n-            TestData test = tests[i];\n+            final TestData test = tests[i];\n             final CompressorStreamFactory fac = test.factory;\n             assertNotNull(\"Test entry \"+i, fac);\n             assertEquals(\"Test entry \"+i, test.concat, fac.getDecompressConcatenated());\n-            CompressorInputStream in = getStreamFor(test.fileName, fac);\n+            final CompressorInputStream in = getStreamFor(test.fileName, fac);\n             assertNotNull(\"Test entry \"+i,in);\n-            for (char entry : test.entryNames) {\n+            for (final char entry : test.entryNames) {\n                 assertEquals(\"Test entry\" + i, entry, in.read());                \n             }\n             assertEquals(0, in.available());\n--- a/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/FramedSnappyTestCase.java\n         final File original = getFile(\"bla.tar\");\n         final FileInputStream written = new FileInputStream(output);\n         try {\n-            FileInputStream orig = new FileInputStream(original);\n+            final FileInputStream orig = new FileInputStream(original);\n             try {\n                 assertArrayEquals(IOUtils.toByteArray(written),\n                                   IOUtils.toByteArray(orig));\n--- a/src/test/java/org/apache/commons/compress/compressors/GZipTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/GZipTestCase.java\n             in.close();\n             out.close();\n \n-            byte[] data = ((ByteArrayOutputStream) out).toByteArray();\n+            final byte[] data = ((ByteArrayOutputStream) out).toByteArray();\n             in = new ByteArrayInputStream(data, 0, data.length - 1);\n             cin = new CompressorStreamFactory()\n                 .createCompressorInputStream(\"gz\", in);\n             try {\n                 IOUtils.copy(cin, out);\n                 fail(\"Expected an exception\");\n-            } catch (IOException ioex) {\n+            } catch (final IOException ioex) {\n                 // the whole point of the test\n             }\n \n \n     @Test\n     public void testInteroperabilityWithGzipCompressorInputStream() throws Exception {\n-        FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n+        final FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n         byte[] content;\n         try {\n             content = IOUtils.toByteArray(fis);\n             fis.close();\n         }\n         \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-\n-        GzipParameters parameters = new GzipParameters();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+        final GzipParameters parameters = new GzipParameters();\n         parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\n         parameters.setOperatingSystem(3);\n         parameters.setFilename(\"test3.xml\");\n         parameters.setComment(\"Test file\");\n         parameters.setModificationTime(System.currentTimeMillis());\n-        GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n+        final GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n         out.write(content);\n         out.flush();\n         out.close();\n \n-        GzipCompressorInputStream in = new GzipCompressorInputStream(new ByteArrayInputStream(bout.toByteArray()));\n-        byte[] content2 = IOUtils.toByteArray(in);\n+        final GzipCompressorInputStream in = new GzipCompressorInputStream(new ByteArrayInputStream(bout.toByteArray()));\n+        final byte[] content2 = IOUtils.toByteArray(in);\n \n         Assert.assertArrayEquals(\"uncompressed content\", content, content2);\n     }\n \n     @Test\n     public void testInteroperabilityWithGZIPInputStream() throws Exception {\n-        FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n+        final FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n         byte[] content;\n         try {\n             content = IOUtils.toByteArray(fis);\n             fis.close();\n         }\n         \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-\n-        GzipParameters parameters = new GzipParameters();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+        final GzipParameters parameters = new GzipParameters();\n         parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\n         parameters.setOperatingSystem(3);\n         parameters.setFilename(\"test3.xml\");\n         parameters.setComment(\"Test file\");\n         parameters.setModificationTime(System.currentTimeMillis());\n-        GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n+        final GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n         out.write(content);\n         out.flush();\n         out.close();\n \n-        GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(bout.toByteArray()));\n-        byte[] content2 = IOUtils.toByteArray(in);\n+        final GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(bout.toByteArray()));\n+        final byte[] content2 = IOUtils.toByteArray(in);\n \n         Assert.assertArrayEquals(\"uncompressed content\", content, content2);\n     }\n \n     @Test\n     public void testInvalidCompressionLevel() {\n-        GzipParameters parameters = new GzipParameters();\n+        final GzipParameters parameters = new GzipParameters();\n         try {\n             parameters.setCompressionLevel(10);\n             fail(\"IllegalArgumentException not thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             parameters.setCompressionLevel(-5);\n             fail(\"IllegalArgumentException not thrown\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     private void testExtraFlags(final int compressionLevel, final int flag) throws Exception {\n-        FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n+        final FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n         byte[] content;\n         try {\n             content = IOUtils.toByteArray(fis);\n             fis.close();\n         }\n         \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        \n-        GzipParameters parameters = new GzipParameters();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        \n+        final GzipParameters parameters = new GzipParameters();\n         parameters.setCompressionLevel(compressionLevel);\n-        GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n+        final GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n         IOUtils.copy(new ByteArrayInputStream(content), out);\n         out.flush();\n         out.close();\n     \n     @Test\n     public void testOverWrite() throws Exception {\n-        GzipCompressorOutputStream out = new GzipCompressorOutputStream(new ByteArrayOutputStream());\n+        final GzipCompressorOutputStream out = new GzipCompressorOutputStream(new ByteArrayOutputStream());\n         out.close();\n         try {\n             out.write(0);\n             fail(\"IOException expected\");\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testMetadataRoundTrip() throws Exception {\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n                 \n-        GzipParameters parameters = new GzipParameters();\n+        final GzipParameters parameters = new GzipParameters();\n         parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\n         parameters.setModificationTime(123456000);\n         parameters.setOperatingSystem(13);\n         parameters.setFilename(\"test3.xml\");\n         parameters.setComment(\"Umlaute m\u00f6glich?\");\n-        GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n-        FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n+        final GzipCompressorOutputStream out = new GzipCompressorOutputStream(bout, parameters);\n+        final FileInputStream fis = new FileInputStream(getFile(\"test3.xml\"));\n         try {\n             IOUtils.copy(fis, out);\n         } finally {\n             out.close();\n         }\n         \n-        GzipCompressorInputStream input =\n+        final GzipCompressorInputStream input =\n             new GzipCompressorInputStream(new ByteArrayInputStream(bout.toByteArray()));\n         input.close();\n-        GzipParameters readParams = input.getMetaData();\n+        final GzipParameters readParams = input.getMetaData();\n         assertEquals(Deflater.BEST_COMPRESSION, readParams.getCompressionLevel());\n         assertEquals(123456000, readParams.getModificationTime());\n         assertEquals(13, readParams.getOperatingSystem());\n--- a/src/test/java/org/apache/commons/compress/compressors/Pack200TestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/Pack200TestCase.java\n \n             ArchiveEntry entry = in.getNextEntry();\n             while (entry != null) {\n-                File archiveEntry = new File(dir, entry.getName());\n+                final File archiveEntry = new File(dir, entry.getName());\n                 archiveEntry.getParentFile().mkdirs();\n                 if (entry.isDirectory()) {\n                     archiveEntry.mkdir();\n                     entry = in.getNextEntry();\n                     continue;\n                 }\n-                OutputStream out = new FileOutputStream(archiveEntry);\n+                final OutputStream out = new FileOutputStream(archiveEntry);\n                 IOUtils.copy(in, out);\n                 out.close();\n                 entry = in.getNextEntry();\n         try {\n             final ArchiveInputStream in = new ArchiveStreamFactory()\n                 .createArchiveInputStream(\"jar\", is);\n-            List<String> files = new ArrayList<String>();\n+            final List<String> files = new ArrayList<String>();\n             files.add(\"testdata/test1.xml\");\n             files.add(\"testdata/test2.xml\");\n             checkArchiveContent(in, files);\n     public void testGoodSignature() throws Exception {\n         final InputStream is = new FileInputStream(getFile(\"bla.pack\"));\n         try {\n-            byte[] sig = new byte[4];\n+            final byte[] sig = new byte[4];\n             is.read(sig);\n             assertTrue(Pack200CompressorInputStream.matches(sig, 4));\n         } finally {\n     public void testBadSignature() throws Exception {\n         final InputStream is = new FileInputStream(getFile(\"bla.jar\"));\n         try {\n-            byte[] sig = new byte[4];\n+            final byte[] sig = new byte[4];\n             is.read(sig);\n             assertFalse(Pack200CompressorInputStream.matches(sig, 4));\n         } finally {\n     public void testShortSignature() throws Exception {\n         final InputStream is = new FileInputStream(getFile(\"bla.pack\"));\n         try {\n-            byte[] sig = new byte[2];\n+            final byte[] sig = new byte[2];\n             is.read(sig);\n             assertFalse(Pack200CompressorInputStream.matches(sig, 2));\n         } finally {\n \n     @Test\n     public void testInputStreamMethods() throws Exception {\n-        Map<String, String> m = new HashMap<String, String>();\n+        final Map<String, String> m = new HashMap<String, String>();\n         m.put(\"foo\", \"bar\");\n         final InputStream is =\n             new Pack200CompressorInputStream(new FileInputStream(getFile(\"bla.jar\")),\n             assertTrue(is.markSupported());\n             is.mark(5);\n             assertEquals(0x50, is.read());\n-            byte[] rest = new byte[3];\n+            final byte[] rest = new byte[3];\n             assertEquals(3, is.read(rest));\n             assertEquals(0x4b, rest[0]);\n             assertEquals(3, rest[1]);\n     @Test\n     public void testOutputStreamMethods() throws Exception {\n         final File output = new File(dir, \"bla.pack\");\n-        Map<String, String> m = new HashMap<String, String>();\n+        final Map<String, String> m = new HashMap<String, String>();\n         m.put(\"foo\", \"bar\");\n         final OutputStream out = new FileOutputStream(output);\n         try {\n--- a/src/test/java/org/apache/commons/compress/compressors/XZTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/XZTestCase.java\n \n     @Test\n     public void testXZCreation()  throws Exception {\n-        long max = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax();\n+        final long max = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax();\n         System.out.println(\"XZTestCase: HeapMax=\"+max+\" bytes \"+(double)max/(1024*1024)+\" MB\");\n         final File input = getFile(\"test1.xml\");\n         final File output = new File(dir, \"test1.xml.xz\");\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStreamTest.java\n \n     @Test(expected = IOException.class)\n     public void shouldThrowAnIOExceptionWhenAppliedToAZipFile() throws Exception {\n-        FileInputStream in = new FileInputStream(getFile(\"bla.zip\"));\n+        final FileInputStream in = new FileInputStream(getFile(\"bla.zip\"));\n         try {\n             new BZip2CompressorInputStream(in);\n         } finally {\n     @Test\n     public void readOfLength0ShouldReturn0() throws Exception {\n         // Create a big random piece of data\n-        byte[] rawData = new byte[1048576];\n+        final byte[] rawData = new byte[1048576];\n         for (int i=0; i < rawData.length; ++i) {\n             rawData[i] = (byte) Math.floor(Math.random()*256);\n         }\n \n         // Compress it\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n         bzipOut.write(rawData);\n         bzipOut.flush();\n         bzipOut.close();\n         baos.close();\n \n         // Try to read it back in\n-        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n-        BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n-        byte[] buffer = new byte[1024];\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        final BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n+        final byte[] buffer = new byte[1024];\n         Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n         Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n         Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/BlockSortTest.java\n \n     @Test\n     public void testSortFixture() {\n-        DS ds = setUpFixture();\n+        final DS ds = setUpFixture();\n         ds.s.blockSort(ds.data, FIXTURE.length - 1);\n         assertFixtureSorted(ds.data);\n         assertEquals(0, ds.data.origPtr);\n \n     @Test\n     public void testSortFixtureMainSort() {\n-        DS ds = setUpFixture();\n+        final DS ds = setUpFixture();\n         ds.s.mainSort(ds.data, FIXTURE.length - 1);\n         assertFixtureSorted(ds.data);\n     }\n \n     @Test\n     public void testSortFixtureFallbackSort() {\n-        DS ds = setUpFixture();\n+        final DS ds = setUpFixture();\n         ds.s.fallbackSort(ds.data, FIXTURE.length - 1);\n         assertFixtureSorted(ds.data);\n     }\n \n     @Test\n     public void testSortFixture2() {\n-        DS ds = setUpFixture2();\n+        final DS ds = setUpFixture2();\n         ds.s.blockSort(ds.data, FIXTURE2.length - 1);\n         assertFixture2Sorted(ds.data);\n         assertEquals(1, ds.data.origPtr);\n \n     @Test\n     public void testSortFixture2MainSort() {\n-        DS ds = setUpFixture2();\n+        final DS ds = setUpFixture2();\n         ds.s.mainSort(ds.data, FIXTURE2.length - 1);\n         assertFixture2Sorted(ds.data);\n     }\n \n     @Test\n     public void testSortFixture2FallbackSort() {\n-        DS ds = setUpFixture2();\n+        final DS ds = setUpFixture2();\n         ds.s.fallbackSort(ds.data, FIXTURE2.length - 1);\n         assertFixture2Sorted(ds.data);\n     }\n \n     @Test\n     public void testFallbackSort() {\n-        BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n-        BlockSort s = new BlockSort(data);\n-        int[] fmap = new int[FIXTURE.length];\n+        final BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n+        final BlockSort s = new BlockSort(data);\n+        final int[] fmap = new int[FIXTURE.length];\n         s.fallbackSort(fmap, FIXTURE, FIXTURE.length);\n         assertArrayEquals(FIXTURE_SORTED, fmap);\n     }\n     }\n \n     private DS setUpFixture(final byte[] fixture) {\n-        BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n+        final BZip2CompressorOutputStream.Data data = new BZip2CompressorOutputStream.Data(1);\n         System.arraycopy(fixture, 0, data.block, 1, fixture.length);\n         return new DS(data, new BlockSort(data));\n     }\n--- a/src/test/java/org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/bzip2/PythonTruncatedBzip2Test.java\n \n     @BeforeClass\n     public static void initializeTestData() throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        BZip2CompressorOutputStream bz2out = new BZip2CompressorOutputStream(out);\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final BZip2CompressorOutputStream bz2out = new BZip2CompressorOutputStream(out);\n         bz2out.write(TEXT.getBytes(), 0, TEXT.getBytes().length);\n         bz2out.close();\n         DATA = out.toByteArray();\n \n     @Before\n     public void initializeChannel() throws IOException {\n-        InputStream source = new ByteArrayInputStream(TRUNCATED_DATA);\n+        final InputStream source = new ByteArrayInputStream(TRUNCATED_DATA);\n         this.bz2Channel = makeBZ2C(source);\n     }\n \n         //with BZ2File(self.filename) as f:\n         //    self.assertRaises(EOFError, f.read)\n         System.out.println(\"Attempt to read the whole thing in, should throw ...\");\n-        ByteBuffer buffer = ByteBuffer.allocate(8192);\n+        final ByteBuffer buffer = ByteBuffer.allocate(8192);\n         bz2Channel.read(buffer);\n     }\n \n         try {\n             bz2Channel.read(buffer);\n             Assert.fail(\"The read should have thrown.\");\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             // pass\n         }\n     }\n \n     private static ReadableByteChannel makeBZ2C(final InputStream source) throws IOException {\n-        BufferedInputStream bin = new BufferedInputStream(source);\n-        BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);\n+        final BufferedInputStream bin = new BufferedInputStream(source);\n+        final BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);\n \n         return Channels.newChannel(bZin);\n     }\n     // Helper method since Arrays#copyOfRange is Java 1.6+\n     // Does not check parameters, so may fail if they are incompatible\n     private static byte[] copyOfRange(final byte[] original, final int from, final int to) {\n-        int length = to - from;\n-        byte buff[] = new byte[length];\n+        final int length = to - from;\n+        final byte buff[] = new byte[length];\n         System.arraycopy(original, from, buff, 0, length);\n         return buff;\n     }\n--- a/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStreamTest.java\n         final File input = AbstractTestCase.getFile(\"bla.tar.deflatez\");\n         final InputStream is = new FileInputStream(input);\n         try {\n-            DeflateCompressorInputStream in =\n+            final DeflateCompressorInputStream in =\n                 new DeflateCompressorInputStream(is);\n             Assert.assertTrue(in.available() > 0);\n             in.close();\n         final File input = AbstractTestCase.getFile(\"bla.tar.deflatez\");\n         final InputStream is = new FileInputStream(input);\n         try {\n-            DeflateCompressorInputStream in =\n+            final DeflateCompressorInputStream in =\n                 new DeflateCompressorInputStream(is);\n             Assert.assertEquals(1, in.skip(1));\n             in.close();\n         final File input = AbstractTestCase.getFile(\"bla.tar.deflatez\");\n         final InputStream is = new FileInputStream(input);\n         try {\n-            DeflateCompressorInputStream in =\n+            final DeflateCompressorInputStream in =\n                 new DeflateCompressorInputStream(is);\n             // tar header starts with filename \"test1.xml\"\n             Assert.assertEquals('t', in.read());\n         final File input = AbstractTestCase.getFile(\"bla.tar.deflatez\");\n         final InputStream is = new FileInputStream(input);\n         try {\n-            DeflateCompressorInputStream in =\n+            final DeflateCompressorInputStream in =\n                 new DeflateCompressorInputStream(is);\n             IOUtils.toByteArray(in);\n             Assert.assertEquals(-1, in.read());\n--- a/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorOutputStreamTest.java\n \n     @Test\n     public void canReadASingleByteFlushAndFinish() throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        DeflateCompressorOutputStream cos = new DeflateCompressorOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final DeflateCompressorOutputStream cos = new DeflateCompressorOutputStream(bos);\n         cos.write(99);\n         cos.flush();\n         cos.finish();\n--- a/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateParametersTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/deflate/DeflateParametersTest.java\n \n     @Test\n     public void shouldBeAbleToSetCompressionLevel() {\n-        DeflateParameters p = new DeflateParameters();\n+        final DeflateParameters p = new DeflateParameters();\n         p.setCompressionLevel(5);\n         Assert.assertEquals(5, p.getCompressionLevel());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void shouldNotBeAbleToSetCompressionLevelToANegativeValue() {\n-        DeflateParameters p = new DeflateParameters();\n+        final DeflateParameters p = new DeflateParameters();\n         p.setCompressionLevel(-2);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void shouldNotBeAbleToSetCompressionLevelToADoubleDigitValue() {\n-        DeflateParameters p = new DeflateParameters();\n+        final DeflateParameters p = new DeflateParameters();\n         p.setCompressionLevel(12);\n     }\n }\n--- a/src/test/java/org/apache/commons/compress/compressors/lzma/LZMAUtilsTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/lzma/LZMAUtilsTestCase.java\n \n     @Test\n     public void testMatches() {\n-        byte[] data = {\n+        final byte[] data = {\n             (byte) 0x5D, 0, 0,\n         };\n         assertFalse(LZMAUtils.matches(data, 2));\n--- a/src/test/java/org/apache/commons/compress/compressors/pack200/Pack200UtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/pack200/Pack200UtilsTest.java\n \n                 ArchiveEntry entry = in.getNextEntry();\n                 while (entry != null) {\n-                    File archiveEntry = new File(dir, entry.getName());\n+                    final File archiveEntry = new File(dir, entry.getName());\n                     archiveEntry.getParentFile().mkdirs();\n                     if (entry.isDirectory()) {\n                         archiveEntry.mkdir();\n                         entry = in.getNextEntry();\n                         continue;\n                     }\n-                    OutputStream out = new FileOutputStream(archiveEntry);\n+                    final OutputStream out = new FileOutputStream(archiveEntry);\n                     IOUtils.copy(in, out);\n                     out.close();\n                     entry = in.getNextEntry();\n \n                 ArchiveEntry entry = in.getNextEntry();\n                 while (entry != null) {\n-                    File archiveEntry = new File(dir, entry.getName());\n+                    final File archiveEntry = new File(dir, entry.getName());\n                     archiveEntry.getParentFile().mkdirs();\n                     if (entry.isDirectory()) {\n                         archiveEntry.mkdir();\n                         entry = in.getNextEntry();\n                         continue;\n                     }\n-                    OutputStream out = new FileOutputStream(archiveEntry);\n+                    final OutputStream out = new FileOutputStream(archiveEntry);\n                     IOUtils.copy(in, out);\n                     out.close();\n                     entry = in.getNextEntry();\n--- a/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java\n     @Test\n     public void testMatches() throws IOException {\n         assertFalse(FramedSnappyCompressorInputStream.matches(new byte[10], 10));\n-        byte[] b = new byte[12];\n+        final byte[] b = new byte[12];\n         final File input = getFile(\"bla.tar.sz\");\n-        FileInputStream in = new FileInputStream(input);\n+        final FileInputStream in = new FileInputStream(input);\n         try {\n             IOUtils.readFully(in, b);\n         } finally {\n \n         final FileInputStream sz = new FileInputStream(outputSz);\n         try {\n-            FileInputStream gz = new FileInputStream(outputGz);\n+            final FileInputStream gz = new FileInputStream(outputGz);\n             try {\n                 assertArrayEquals(IOUtils.toByteArray(sz),\n                                   IOUtils.toByteArray(gz));\n     @Test\n     public void testRemainingChunkTypes() throws Exception {\n         final FileInputStream isSz = new FileInputStream(getFile(\"mixed.txt.sz\"));\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         try {\n-            FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz);\n+            final FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz);\n             IOUtils.copy(in, out);\n             out.close();\n         } finally {\n     public void testAvailable() throws Exception {\n         final FileInputStream isSz = new FileInputStream(getFile(\"mixed.txt.sz\"));\n         try {\n-            FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz);\n+            final FramedSnappyCompressorInputStream in = new FramedSnappyCompressorInputStream(isSz);\n             assertEquals(0, in.available()); // no chunk read so far\n             assertEquals('1', in.read());\n             assertEquals(3, in.available()); // remainder of first uncompressed block\n \n     @Test\n     public void testUnskippableChunk() {\n-        byte[] input = new byte[] {\n+        final byte[] input = new byte[] {\n             (byte) 0xff, 6, 0, 0, 's', 'N', 'a', 'P', 'p', 'Y',\n             2, 2, 0, 0, 1, 1\n         };\n         try {\n-            FramedSnappyCompressorInputStream in =\n+            final FramedSnappyCompressorInputStream in =\n                 new FramedSnappyCompressorInputStream(new ByteArrayInputStream(input));\n             in.read();\n             fail(\"expected an exception\");\n             in.close();\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             assertTrue(ex.getMessage().contains(\"unskippable chunk\"));\n         }\n     }\n--- a/src/test/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/xz/XZCompressorInputStreamTest.java\n public class XZCompressorInputStreamTest {\n     @Test\n     public void redundantTestOfAlmostDeprecatedMatchesMethod() {\n-        byte[] data = {\n+        final byte[] data = {\n             (byte) 0xFD, '7', 'z', 'X', 'Z', '\\0'\n         };\n         Assert.assertFalse(XZCompressorInputStream.matches(data, 5));\n--- a/src/test/java/org/apache/commons/compress/compressors/xz/XZUtilsTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/xz/XZUtilsTestCase.java\n \n     @Test\n     public void testMatches() {\n-        byte[] data = {\n+        final byte[] data = {\n             (byte) 0xFD, '7', 'z', 'X', 'Z', '\\0'\n         };\n         assertFalse(XZUtils.matches(data, 5));\n--- a/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/BitInputStreamTest.java\n \n     @Test(expected = IllegalArgumentException.class)\n     public void shouldNotAllowReadingOfANegativeAmountOfBits() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         bis.readBits(-1);\n         bis.close();\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void shouldNotAllowReadingOfMoreThan63BitsAtATime() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         bis.readBits(64);\n         bis.close();\n     }\n \n     @Test\n     public void testReading24BitsInLittleEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x000140f8, bis.readBits(24));\n         bis.close();\n     }\n \n     @Test\n     public void testReading24BitsInBigEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n         assertEquals(0x00f84001, bis.readBits(24));\n         bis.close();\n     }\n \n     @Test\n     public void testReading17BitsInLittleEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x000140f8, bis.readBits(17));\n         bis.close();\n     }\n \n     @Test\n     public void testReading17BitsInBigEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n         // 1-11110000-10000000\n         assertEquals(0x0001f080, bis.readBits(17));\n         bis.close();\n \n     @Test\n     public void testReading30BitsInLittleEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x2f0140f8, bis.readBits(30));\n         bis.close();\n     }\n \n     @Test\n     public void testReading30BitsInBigEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n         // 111110-00010000-00000000-01001011\n         assertEquals(0x3e10004b, bis.readBits(30));\n         bis.close();\n \n     @Test\n     public void testReading31BitsInLittleEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x2f0140f8, bis.readBits(31));\n         bis.close();\n     }\n \n     @Test\n     public void testReading31BitsInBigEndian() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.BIG_ENDIAN);\n         // 1111100-00100000-00000000-10010111\n         assertEquals(0x7c200097, bis.readBits(31));\n         bis.close();\n \n     @Test\n     public void testClearBitCache() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x08, bis.readBits(4));\n         bis.clearBitCache();\n         assertEquals(0, bis.readBits(1));\n \n     @Test\n     public void testEOF() throws IOException {\n-        BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n+        final BitInputStream bis = new BitInputStream(getStream(), ByteOrder.LITTLE_ENDIAN);\n         assertEquals(0x2f0140f8, bis.readBits(30));\n         assertEquals(-1, bis.readBits(3));\n         bis.close();\n--- a/src/test/java/org/apache/commons/compress/utils/CountingStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/CountingStreamTest.java\n     public void output() throws Exception {\n         // I don't like \"test all at once\" tests either, but the class\n         // is so trivial\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        CountingOutputStream o = new CountingOutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final CountingOutputStream o = new CountingOutputStream(bos);\n         o.write(1);\n         assertEquals(1, o.getBytesWritten());\n         o.write(new byte[] { 2, 3 });\n     public void input() throws Exception {\n         // I don't like \"test all at once\" tests either, but the class\n         // is so trivial\n-        ByteArrayInputStream bis =\n+        final ByteArrayInputStream bis =\n             new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 });\n-        CountingInputStream i = new CountingInputStream(bis);\n+        final CountingInputStream i = new CountingInputStream(bis);\n         assertEquals(1, i.read());\n         assertEquals(1, i.getBytesRead());\n         byte[] b = new byte[2];\n--- a/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/IOUtilsTest.java\n     }\n \n     private void skip(final StreamWrapper wrapper) throws Exception {\n-        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n+        final ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n             });\n-        InputStream sut = wrapper.wrap(in);\n+        final InputStream sut = wrapper.wrap(in);\n         Assert.assertEquals(10, IOUtils.skip(sut, 10));\n         Assert.assertEquals(11, sut.read());\n     }", "timestamp": 1460221828, "metainfo": ""}