{"sha": "93a15dde57abc1953d889abe5aa84341c835bbb8", "log": "Add initial support for ARJ archives. Document it.  We only support reading at the moment, and only support the STORED (absense of) compression with no encryption or multi-volume support.  Jira issue key: COMPRESS-226    ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n \n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\n+import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\n      */\n     public static final String AR = \"ar\";\n     /**\n+     * Constant used to identify the ARJ archive format.\n+     * @since 1.6\n+     */\n+    public static final String ARJ = \"arj\";\n+    /**\n      * Constant used to identify the CPIO archive format.\n      * @since 1.1\n      */\n     private String entryEncoding = null;\n \n     /**\n-     * Returns the encoding to use for zip and tar files, or null for\n-     * the default.\n+     * Returns the encoding to use for arj, zip and tar files,\n+     * or null for the default.\n      *\n      * @return entry encoding, or null\n      * @since 1.5\n     }\n \n     /**\n-     * Sets the encoding to use for zip and tar files. Use null for\n-     * the default.\n+     * Sets the encoding to use for arj, zip and tar files.\n+     * Use null for the default.\n      *\n      * @since 1.5\n      */\n     /**\n      * Create an archive input stream from an archiver name and an input stream.\n      * \n-     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n+     * @param archiverName the archive name, i.e. \"ar\", \"arj\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n      * @param in the input stream\n      * @return the archive input stream\n      * @throws ArchiveException if the archiver name is not known\n \n         if (AR.equalsIgnoreCase(archiverName)) {\n             return new ArArchiveInputStream(in);\n+        }\n+        if (ARJ.equalsIgnoreCase(archiverName)) {\n+            if (entryEncoding != null) {\n+                return new ArjArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new ArjArchiveInputStream(in);\n+            }\n         }\n         if (ZIP.equalsIgnoreCase(archiverName)) {\n             if (entryEncoding != null) {\n                 return new ArArchiveInputStream(in);\n             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                 return new CpioArchiveInputStream(in);\n+            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n+                return new ArjArchiveInputStream(in);\n             }\n \n             // Dump needs a bigger buffer to check the signature;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveEntry.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.arj;\n+\n+import java.io.File;\n+import java.util.Date;\n+import java.util.regex.Matcher;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.zip.ZipUtil;\n+\n+/**\n+ * An entry in an ARJ archive.\n+ * \n+ * @NotThreadSafe\n+ */\n+public class ArjArchiveEntry implements ArchiveEntry {\n+    private final LocalFileHeader localFileHeader;\n+    \n+    public ArjArchiveEntry() {\n+        localFileHeader = new LocalFileHeader();\n+    }\n+    \n+    ArjArchiveEntry(final LocalFileHeader localFileHeader) {\n+        this.localFileHeader = localFileHeader;\n+    }\n+\n+    public String getName() {\n+        if ((localFileHeader.arjFlags & LocalFileHeader.Flags.PATHSYM) != 0) {\n+            return localFileHeader.name.replaceAll(\"/\",\n+                    Matcher.quoteReplacement(File.separator));\n+        } else {\n+            return localFileHeader.name;\n+        }\n+    }\n+\n+    public long getSize() {\n+        return localFileHeader.originalSize;\n+    }\n+\n+    public boolean isDirectory() {\n+        return localFileHeader.fileType == LocalFileHeader.FileTypes.DIRECTORY;\n+    }\n+\n+    public Date getLastModifiedDate() {\n+        return new Date(ZipUtil.dosToJavaTime(\n+                0xffffFFFFL & localFileHeader.dateTimeModified));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/ArjArchiveInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.arj;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.zip.CRC32;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveException;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.utils.BoundedInputStream;\n+import org.apache.commons.compress.utils.CRC32VerifyingInputStream;\n+\n+/**\n+ * Implements the \"arj\" archive format as an InputStream.\n+ * <p>\n+ * <a href=\"http://farmanager.com/svn/trunk/plugins/multiarc/arc.doc/arj.txt\">Reference</a>\n+ * @NotThreadSafe\n+ */\n+public class ArjArchiveInputStream extends ArchiveInputStream {\n+    private static final boolean DEBUG = false;\n+    private static final int ARJ_MAGIC_1 = 0x60;\n+    private static final int ARJ_MAGIC_2 = 0xEA;\n+    private final DataInputStream in;\n+    private final String charset;\n+    private final MainHeader mainHeader;\n+    private LocalFileHeader currentLocalFileHeader = null;\n+    private InputStream currentInputStream = null;\n+    \n+    /**\n+     * Constructs the ArjInputStream, taking ownership of the inputStream that is passed in.\n+     * @param inputStream the underlying stream, whose ownership is taken\n+     * @param charset the charset used for file names and comments\n+     *   in the archive\n+     * @throws IOException\n+     */\n+    public ArjArchiveInputStream(final InputStream inputStream,\n+            final String charset) throws ArchiveException {\n+        in = new DataInputStream(inputStream);\n+        this.charset = charset;\n+        try {\n+            mainHeader = readMainHeader();\n+            if ((mainHeader.arjFlags & MainHeader.Flags.GARBLED) != 0) {\n+                throw new ArchiveException(\"Encrypted ARJ files are unsupported\");\n+            }\n+            if ((mainHeader.arjFlags & MainHeader.Flags.VOLUME) != 0) {\n+                throw new ArchiveException(\"Multi-volume ARJ files are unsupported\");\n+            }\n+        } catch (IOException ioException) {\n+            throw new ArchiveException(ioException.getMessage(), ioException);\n+        }\n+    }\n+\n+    /**\n+     * Constructs the ArjInputStream, taking ownership of the inputStream that is passed in,\n+     * and using the CP437 character encoding.\n+     * @param inputStream the underlying stream, whose ownership is taken\n+     * @throws IOException\n+     */\n+    public ArjArchiveInputStream(final InputStream inputStream)\n+            throws ArchiveException {\n+        this(inputStream, \"CP437\");\n+    }\n+    \n+    @Override\n+    public void close() {\n+        try {\n+            in.close();\n+        } catch (IOException ignored) {\n+        }\n+    }\n+    \n+    private static final void debug(final String message) {\n+        if (DEBUG) {\n+            System.out.println(message);\n+        }\n+    }\n+    \n+    private static final int read16(final DataInputStream in) throws IOException {\n+        final int value = in.readUnsignedShort();\n+        return Integer.reverseBytes(value) >>> 16;\n+    }\n+    \n+    private final String readString(final DataInputStream in) throws IOException {\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        int nextByte;\n+        while ((nextByte = in.readUnsignedByte()) != 0) {\n+            buffer.write(nextByte);\n+        }\n+        return new String(buffer.toByteArray(), charset);\n+    }\n+    \n+    private byte[] readHeader() throws IOException {\n+        boolean found = false;\n+        byte[] basicHeaderBytes = null;\n+        do {\n+            int first = 0;\n+            int second = in.readUnsignedByte();\n+            do {\n+                first = second;\n+                second = in.readUnsignedByte();\n+            } while (first != ARJ_MAGIC_1 && second != ARJ_MAGIC_2);\n+            final int basicHeaderSize = read16(in);\n+            if (basicHeaderSize == 0) {\n+                // end of archive\n+                return null;\n+            }\n+            if (basicHeaderSize <= 2600) {\n+                basicHeaderBytes = new byte[basicHeaderSize];\n+                in.readFully(basicHeaderBytes);\n+                final int basicHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+                final CRC32 crc32 = new CRC32();\n+                crc32.update(basicHeaderBytes);\n+                if (basicHeaderCrc32 == (int)crc32.getValue()) {\n+                    found = true;\n+                }\n+            }\n+        } while (!found);\n+        return basicHeaderBytes;\n+    }\n+    \n+    private MainHeader readMainHeader() throws IOException {\n+        final byte[] basicHeaderBytes = readHeader();\n+        if (basicHeaderBytes == null) {\n+            throw new IOException(\"Archive ends without any headers\");\n+        }\n+        final DataInputStream basicHeader = new DataInputStream(\n+                new ByteArrayInputStream(basicHeaderBytes));\n+        \n+        final int firstHeaderSize = basicHeader.readUnsignedByte();\n+        final byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\n+        basicHeader.readFully(firstHeaderBytes);\n+        final DataInputStream firstHeader = new DataInputStream(\n+                new ByteArrayInputStream(firstHeaderBytes));\n+        \n+        final MainHeader mainHeader = new MainHeader();\n+        mainHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n+        mainHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n+        mainHeader.hostOS = firstHeader.readUnsignedByte();\n+        mainHeader.arjFlags = firstHeader.readUnsignedByte();\n+        mainHeader.securityVersion = firstHeader.readUnsignedByte();\n+        mainHeader.fileType = firstHeader.readUnsignedByte();\n+        mainHeader.reserved = firstHeader.readUnsignedByte();\n+        mainHeader.dateTimeCreated = Integer.reverseBytes(firstHeader.readInt());\n+        mainHeader.dateTimeModified = Integer.reverseBytes(firstHeader.readInt());\n+        mainHeader.archiveSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n+        mainHeader.securityEnvelopeFilePosition = Integer.reverseBytes(firstHeader.readInt());\n+        mainHeader.fileSpecPosition = read16(firstHeader);\n+        mainHeader.securityEnvelopeLength = read16(firstHeader);\n+        mainHeader.encryptionVersion = firstHeader.readUnsignedByte();\n+        mainHeader.lastChapter = firstHeader.readUnsignedByte();\n+        \n+        try {\n+            mainHeader.arjProtectionFactor = firstHeader.readUnsignedByte();\n+            mainHeader.arjFlags2 = firstHeader.readUnsignedByte();\n+            firstHeader.readUnsignedByte();\n+            firstHeader.readUnsignedByte();\n+        } catch (EOFException eof) {\n+        }\n+        \n+        mainHeader.name = readString(basicHeader);\n+        mainHeader.comment = readString(basicHeader);\n+        \n+        final  int extendedHeaderSize = read16(in);\n+        if (extendedHeaderSize > 0) {\n+            mainHeader.extendedHeaderBytes = new byte[extendedHeaderSize];\n+            in.readFully(mainHeader.extendedHeaderBytes);\n+            final int extendedHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+            final CRC32 crc32 = new CRC32();\n+            crc32.update(mainHeader.extendedHeaderBytes);\n+            if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n+                throw new IOException(\"Extended header CRC32 verification failure\");\n+            }\n+        }\n+        \n+        debug(mainHeader.toString());\n+        \n+        return mainHeader;\n+    }\n+    \n+    private LocalFileHeader readLocalFileHeader() throws IOException {\n+        final byte[] basicHeaderBytes = readHeader();\n+        if (basicHeaderBytes == null) {\n+            return null;\n+        }\n+        final DataInputStream basicHeader = new DataInputStream(\n+                new ByteArrayInputStream(basicHeaderBytes));\n+        \n+        final int firstHeaderSize = basicHeader.readUnsignedByte();\n+        final byte[] firstHeaderBytes = new byte[firstHeaderSize - 1];\n+        basicHeader.readFully(firstHeaderBytes);\n+        final DataInputStream firstHeader = new DataInputStream(\n+                new ByteArrayInputStream(firstHeaderBytes));\n+\n+        final LocalFileHeader localFileHeader = new LocalFileHeader();\n+        localFileHeader.archiverVersionNumber = firstHeader.readUnsignedByte();\n+        localFileHeader.minVersionToExtract = firstHeader.readUnsignedByte();\n+        localFileHeader.hostOS = firstHeader.readUnsignedByte();\n+        localFileHeader.arjFlags = firstHeader.readUnsignedByte();\n+        localFileHeader.method = firstHeader.readUnsignedByte();\n+        localFileHeader.fileType = firstHeader.readUnsignedByte();\n+        localFileHeader.reserved = firstHeader.readUnsignedByte();\n+        localFileHeader.dateTimeModified = Integer.reverseBytes(firstHeader.readInt());\n+        localFileHeader.compressedSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n+        localFileHeader.originalSize = 0xffffFFFFL & Integer.reverseBytes(firstHeader.readInt());\n+        localFileHeader.originalCrc32 = Integer.reverseBytes(firstHeader.readInt());\n+        localFileHeader.fileSpecPosition = read16(firstHeader);\n+        localFileHeader.fileAccessMode = read16(firstHeader);\n+        localFileHeader.firstChapter = firstHeader.readUnsignedByte();\n+        localFileHeader.lastChapter = firstHeader.readUnsignedByte();\n+        \n+        try {\n+            localFileHeader.extendedFilePosition = Integer.reverseBytes(firstHeader.readInt());\n+            localFileHeader.dateTimeAccessed = Integer.reverseBytes(firstHeader.readInt());\n+            localFileHeader.dateTimeCreated = Integer.reverseBytes(firstHeader.readInt());\n+            localFileHeader.originalSizeEvenForVolumes = Integer.reverseBytes(firstHeader.readInt());\n+        } catch (EOFException eof) {\n+        }\n+        \n+        localFileHeader.name = readString(basicHeader);\n+        localFileHeader.comment = readString(basicHeader);\n+\n+        ArrayList<byte[]> extendedHeaders = new ArrayList<byte[]>();\n+        int extendedHeaderSize;\n+        while ((extendedHeaderSize = read16(in)) > 0) {\n+            final byte[] extendedHeaderBytes = new byte[extendedHeaderSize];\n+            in.readFully(extendedHeaderBytes);\n+            final int extendedHeaderCrc32 = Integer.reverseBytes(in.readInt());\n+            final CRC32 crc32 = new CRC32();\n+            crc32.update(extendedHeaderBytes);\n+            if (extendedHeaderCrc32 != (int)crc32.getValue()) {\n+                throw new IOException(\"Extended header CRC32 verification failure\");\n+            }\n+            extendedHeaders.add(extendedHeaderBytes);\n+        }\n+        localFileHeader.extendedHeaders = extendedHeaders.toArray(new byte[extendedHeaders.size()][]);\n+        \n+        debug(localFileHeader.toString());\n+        \n+        return localFileHeader;\n+    }\n+    \n+    public static boolean matches(final byte[] signature, final int length) {\n+        return length >= 2 &&\n+                (0xff & signature[0]) == ARJ_MAGIC_1 &&\n+                (0xff & signature[1]) == ARJ_MAGIC_2;\n+    }\n+    \n+    public String getArchiveName() {\n+        return mainHeader.name;\n+    }\n+    \n+    public String getArchiveComment() {\n+        return mainHeader.comment;\n+    }\n+    \n+    @Override\n+    public ArjArchiveEntry getNextEntry() throws IOException {\n+        if (currentInputStream != null) {\n+            while (currentInputStream.read() >= 0) {\n+            }\n+            currentLocalFileHeader = null;\n+            currentInputStream = null;\n+        }\n+        \n+        currentLocalFileHeader = readLocalFileHeader();\n+        if (currentLocalFileHeader != null) {\n+            currentInputStream = new BoundedInputStream(in, currentLocalFileHeader.compressedSize);\n+            if (currentLocalFileHeader.method == LocalFileHeader.Methods.STORED) {\n+                currentInputStream = new CRC32VerifyingInputStream(currentInputStream,\n+                        currentLocalFileHeader.originalSize, currentLocalFileHeader.originalCrc32);\n+            }\n+            return new ArjArchiveEntry(currentLocalFileHeader);\n+        } else {\n+            currentInputStream = null;\n+            return null;\n+        }\n+    }\n+    \n+    @Override\n+    public boolean canReadEntryData(ArchiveEntry ae) {\n+        return currentLocalFileHeader.method == LocalFileHeader.Methods.STORED;\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        if (currentLocalFileHeader.method != LocalFileHeader.Methods.STORED) {\n+            throw new IOException(\"Unsupported compression method \" + currentLocalFileHeader.method);\n+        }\n+        return currentInputStream.read();\n+    }\n+    \n+    @Override\n+    public int read(final byte[] b, final int off, final int len) throws IOException {\n+        if (currentLocalFileHeader.method != LocalFileHeader.Methods.STORED) {\n+            throw new IOException(\"Unsupported compression method \" + currentLocalFileHeader.method);\n+        }\n+        return currentInputStream.read(b, off, len);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/LocalFileHeader.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.arj;\n+\n+import java.util.Arrays;\n+\n+class LocalFileHeader {\n+    int archiverVersionNumber;\n+    int minVersionToExtract;\n+    int hostOS;\n+    int arjFlags;\n+    int method;\n+    int fileType;\n+    int reserved;\n+    int dateTimeModified;\n+    long compressedSize;\n+    long originalSize;\n+    int originalCrc32;\n+    int fileSpecPosition;\n+    int fileAccessMode;\n+    int firstChapter;\n+    int lastChapter;\n+    \n+    int extendedFilePosition;\n+    int dateTimeAccessed;\n+    int dateTimeCreated;\n+    int originalSizeEvenForVolumes;\n+    \n+    String name;\n+    String comment;\n+    \n+    byte[][] extendedHeaders = null;\n+    \n+    static class Flags {\n+        static final int GARBLED = 0x01;\n+        static final int VOLUME = 0x04;\n+        static final int EXTFILE = 0x08;\n+        static final int PATHSYM = 0x10;\n+        static final int BACKUP = 0x20;\n+    }\n+    \n+    static class FileTypes {\n+        static final int BINARY = 0;\n+        static final int SEVEN_BIT_TEXT = 1;\n+        static final int DIRECTORY = 3;\n+        static final int VOLUME_LABEL = 4;\n+        static final int CHAPTER_LABEL = 5;\n+    }\n+    \n+    static class Methods {\n+        static final int STORED = 0;\n+        static final int COMPRESSED_MOST = 1;\n+        static final int COMPRESSED_FASTEST = 4;\n+        static final int NO_DATA_NO_CRC = 8;\n+        static final int NO_DATA = 9;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(\"LocalFileHeader [archiverVersionNumber=\");\n+        builder.append(archiverVersionNumber);\n+        builder.append(\", minVersionToExtract=\");\n+        builder.append(minVersionToExtract);\n+        builder.append(\", hostOS=\");\n+        builder.append(hostOS);\n+        builder.append(\", arjFlags=\");\n+        builder.append(arjFlags);\n+        builder.append(\", method=\");\n+        builder.append(method);\n+        builder.append(\", fileType=\");\n+        builder.append(fileType);\n+        builder.append(\", reserved=\");\n+        builder.append(reserved);\n+        builder.append(\", dateTimeModified=\");\n+        builder.append(dateTimeModified);\n+        builder.append(\", compressedSize=\");\n+        builder.append(compressedSize);\n+        builder.append(\", originalSize=\");\n+        builder.append(originalSize);\n+        builder.append(\", originalCrc32=\");\n+        builder.append(originalCrc32);\n+        builder.append(\", fileSpecPosition=\");\n+        builder.append(fileSpecPosition);\n+        builder.append(\", fileAccessMode=\");\n+        builder.append(fileAccessMode);\n+        builder.append(\", firstChapter=\");\n+        builder.append(firstChapter);\n+        builder.append(\", lastChapter=\");\n+        builder.append(lastChapter);\n+        builder.append(\", extendedFilePosition=\");\n+        builder.append(extendedFilePosition);\n+        builder.append(\", dateTimeAccessed=\");\n+        builder.append(dateTimeAccessed);\n+        builder.append(\", dateTimeCreated=\");\n+        builder.append(dateTimeCreated);\n+        builder.append(\", originalSizeEvenForVolumes=\");\n+        builder.append(originalSizeEvenForVolumes);\n+        builder.append(\", name=\");\n+        builder.append(name);\n+        builder.append(\", comment=\");\n+        builder.append(comment);\n+        builder.append(\", extendedHeaders=\");\n+        builder.append(Arrays.toString(extendedHeaders));\n+        builder.append(\"]\");\n+        return builder.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/arj/MainHeader.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.arj;\n+\n+import java.util.Arrays;\n+\n+class MainHeader {\n+    int archiverVersionNumber;\n+    int minVersionToExtract;\n+    int hostOS;\n+    int arjFlags;\n+    int securityVersion;\n+    int fileType;\n+    int reserved;\n+    int dateTimeCreated;\n+    int dateTimeModified;\n+    long archiveSize;\n+    int securityEnvelopeFilePosition;\n+    int fileSpecPosition;\n+    int securityEnvelopeLength;\n+    int encryptionVersion;\n+    int lastChapter;\n+    int arjProtectionFactor;\n+    int arjFlags2;\n+    String name;\n+    String comment;\n+    byte[] extendedHeaderBytes = null;\n+    \n+    static class Flags {\n+        static final int GARBLED = 0x01;\n+        static final int OLD_SECURED_NEW_ANSI_PAGE = 0x02;\n+        static final int VOLUME = 0x04;\n+        static final int ARJPROT = 0x08;\n+        static final int PATHSYM = 0x10;\n+        static final int BACKUP = 0x20;\n+        static final int SECURED = 0x40;\n+        static final int ALTNAME = 0x80;\n+    }\n+\n+    \n+    @Override\n+    public String toString() {\n+        final StringBuilder builder = new StringBuilder();\n+        builder.append(\"MainHeader [archiverVersionNumber=\");\n+        builder.append(archiverVersionNumber);\n+        builder.append(\", minVersionToExtract=\");\n+        builder.append(minVersionToExtract);\n+        builder.append(\", hostOS=\");\n+        builder.append(hostOS);\n+        builder.append(\", arjFlags=\");\n+        builder.append(arjFlags);\n+        builder.append(\", securityVersion=\");\n+        builder.append(securityVersion);\n+        builder.append(\", fileType=\");\n+        builder.append(fileType);\n+        builder.append(\", reserved=\");\n+        builder.append(reserved);\n+        builder.append(\", dateTimeCreated=\");\n+        builder.append(dateTimeCreated);\n+        builder.append(\", dateTimeModified=\");\n+        builder.append(dateTimeModified);\n+        builder.append(\", archiveSize=\");\n+        builder.append(archiveSize);\n+        builder.append(\", securityEnvelopeFilePosition=\");\n+        builder.append(securityEnvelopeFilePosition);\n+        builder.append(\", fileSpecPosition=\");\n+        builder.append(fileSpecPosition);\n+        builder.append(\", securityEnvelopeLength=\");\n+        builder.append(securityEnvelopeLength);\n+        builder.append(\", encryptionVersion=\");\n+        builder.append(encryptionVersion);\n+        builder.append(\", lastChapter=\");\n+        builder.append(lastChapter);\n+        builder.append(\", arjProtectionFactor=\");\n+        builder.append(arjProtectionFactor);\n+        builder.append(\", arjFlags2=\");\n+        builder.append(arjFlags2);\n+        builder.append(\", name=\");\n+        builder.append(name);\n+        builder.append(\", comment=\");\n+        builder.append(comment);\n+        builder.append(\", extendedHeaderBytes=\");\n+        builder.append(Arrays.toString(extendedHeaderBytes));\n+        builder.append(\"]\");\n+        return builder.toString();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n import java.util.BitSet;\n import java.util.zip.CRC32;\n \n+import org.apache.commons.compress.utils.BoundedInputStream;\n import org.apache.commons.compress.utils.CRC32VerifyingInputStream;\n \n /**\n         }\n         return value;\n     }\n-    \n-    private static class BoundedInputStream extends InputStream {\n-        private final InputStream in;\n-        private long bytesRemaining;\n-        \n-        public BoundedInputStream(final InputStream in, final long size) {\n-            this.in = in;\n-            bytesRemaining = size;\n-        }\n-        \n-        @Override\n-        public int read() throws IOException {\n-            if (bytesRemaining > 0) {\n-                --bytesRemaining;\n-                return in.read();\n-            } else {\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int read(byte[] b, int off, int len) throws IOException {\n-            if (bytesRemaining == 0) {\n-                return -1;\n-            }\n-            int bytesToRead = len;\n-            if (bytesToRead > bytesRemaining) {\n-                bytesToRead = (int) bytesRemaining;\n-            }\n-            final int bytesRead = in.read(b, off, bytesToRead);\n-            if (bytesRead >= 0) {\n-                bytesRemaining -= bytesRead;\n-            }\n-            return bytesRead;\n-        }\n-\n-        @Override\n-        public void close() {\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/BoundedInputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.utils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public class BoundedInputStream extends InputStream {\n+    private final InputStream in;\n+    private long bytesRemaining;\n+    \n+    public BoundedInputStream(final InputStream in, final long size) {\n+        this.in = in;\n+        bytesRemaining = size;\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        if (bytesRemaining > 0) {\n+            --bytesRemaining;\n+            return in.read();\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (bytesRemaining == 0) {\n+            return -1;\n+        }\n+        int bytesToRead = len;\n+        if (bytesToRead > bytesRemaining) {\n+            bytesToRead = (int) bytesRemaining;\n+        }\n+        final int bytesRead = in.read(b, off, bytesToRead);\n+        if (bytesRead >= 0) {\n+            bytesRemaining -= bytesRead;\n+        }\n+        return bytesRead;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+}", "timestamp": 1368956177, "metainfo": ""}