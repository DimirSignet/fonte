{"sha": "d7119be63642c0cc862e636071b96daaa0b99ec0", "log": "Replace magic strings \"UTF-8\", \"US-ASCII\", and so on with references to a new .util class CharsetNames (like in other commons components.) The Charsets class will be more useful when [compress] moves to Java 6 and can use String#getBytes(Charset) instead of String#getBytes(String).  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n import org.apache.commons.compress.utils.ArchiveUtils;\n+import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n  * The TarInputStream reads a UNIX tar archive as an InputStream.\n                     while((ch = i.read()) != -1) {\n                         read++;\n                         if (ch == '='){ // end of keyword\n-                            String keyword = coll.toString(\"UTF-8\");\n+                            String keyword = coll.toString(CharsetNames.UTF_8);\n                             // Get rest of entry\n                             byte[] rest = new byte[len - read];\n                             int got = i.read(rest);\n                             }\n                             // Drop trailing NL\n                             String value = new String(rest, 0,\n-                                                      len - read - 1, \"UTF-8\");\n+                                                      len - read - 1, CharsetNames.UTF_8);\n                             headers.put(keyword, value);\n                             break;\n                         }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n+import org.apache.commons.compress.utils.CharsetNames;\n import org.apache.commons.compress.utils.CountingOutputStream;\n \n /**\n                 + 3 /* blank, equals and newline */\n                 + 2 /* guess 9 < actual length < 100 */;\n             String line = len + \" \" + key + \"=\" + value + \"\\n\";\n-            int actualLength = line.getBytes(\"UTF-8\").length;\n+            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n             while (len != actualLength) {\n                 // Adjust for cases where length < 10 or > 100\n                 // or where UTF-8 encoding isn't a single octet\n                 // first pass so we'd need a second.\n                 len = actualLength;\n                 line = len + \" \" + key + \"=\" + value + \"\\n\";\n-                actualLength = line.getBytes(\"UTF-8\").length;\n+                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n             }\n             w.write(line);\n         }\n-        byte[] data = w.toString().getBytes(\"UTF-8\");\n+        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n         pex.setSize(data.length);\n         putArchiveEntry(pex);\n         write(data);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n import java.io.UnsupportedEncodingException;\n import java.util.zip.CRC32;\n import java.util.zip.ZipException;\n+\n+import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n  * A common base class for Unicode extra information extra fields.\n         nameCRC32 = crc32.getValue();\n \n         try {\n-            unicodeName = text.getBytes(\"UTF-8\");\n+            unicodeName = text.getBytes(CharsetNames.UTF_8);\n         } catch (UnsupportedEncodingException e) {\n             throw new RuntimeException(\"FATAL: UTF-8 encoding not supported.\", e);\n         }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n import java.nio.charset.UnsupportedCharsetException;\n import java.util.HashMap;\n import java.util.Map;\n+\n+import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n  * Static helper functions for robustly encoding filenames in zip files. \n     /**\n      * variant name of the encoding UTF-8 used for comparisions.\n      */\n-    private static final String UTF_DASH_8 = \"utf-8\";\n+    private static final String UTF_DASH_8 = CharsetNames.UTF_8;\n \n     /**\n      * name of the encoding UTF-8\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/CharsetNames.java\n+package org.apache.commons.compress.utils;\n+\n+/**\n+ * Character encoding names required of every implementation of the Java platform.\n+ * \n+ * From the Java documentation <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard\n+ * charsets</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported. Consult the release\n+ * documentation for your implementation to see if any other encodings are supported. </cite>\n+ * </p>\n+ * \n+ * <ul>\n+ * <li><code>US-ASCII</code><br/>\n+ * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n+ * <li><code>ISO-8859-1</code><br/>\n+ * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n+ * <li><code>UTF-8</code><br/>\n+ * Eight-bit Unicode Transformation Format.</li>\n+ * <li><code>UTF-16BE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n+ * <li><code>UTF-16LE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n+ * <li><code>UTF-16</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n+ * accepted on input, big-endian used on output.)</li>\n+ * </ul>\n+ * \n+ * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not\n+ * foreseen that [codec] would be made to depend on [lang].\n+ * \n+ * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * @author Apache Software Foundation\n+ * @since 1.4\n+ * @version $Id$\n+ */\n+public class CharsetNames {\n+    /**\n+     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1. </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String ISO_8859_1 = \"ISO-8859-1\";\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String US_ASCII = \"US-ASCII\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n+     * (either order accepted on input, big-endian used on output)\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16 = \"UTF-16\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16BE = \"UTF-16BE\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16LE = \"UTF-16LE\";\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_8 = \"UTF-8\";\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/utils/Charsets.java\n+package org.apache.commons.compress.utils;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.UnsupportedCharsetException;\n+\n+/**\n+ * Charsets required of every implementation of the Java platform.\n+ * \n+ * From the Java documentation <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard\n+ * charsets</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported. Consult the release\n+ * documentation for your implementation to see if any other encodings are supported. </cite>\n+ * </p>\n+ * \n+ * <ul>\n+ * <li><code>US-ASCII</code><br/>\n+ * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n+ * <li><code>ISO-8859-1</code><br/>\n+ * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n+ * <li><code>UTF-8</code><br/>\n+ * Eight-bit Unicode Transformation Format.</li>\n+ * <li><code>UTF-16BE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n+ * <li><code>UTF-16LE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n+ * <li><code>UTF-16</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n+ * accepted on input, big-endian used on output.)</li>\n+ * </ul>\n+ * \n+ * This perhaps would best belong in the Commons Lang project. Even if a similar class is defined in Commons Lang, it is\n+ * not foreseen that Commons Codec would be made to depend on Commons Lang.\n+ * \n+ * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * @author Apache Software Foundation\n+ * @since 1.4\n+ * @version $Id$\n+ */\n+public class Charsets {\n+    \n+    //\n+    // This class should only contain Charset instances for required encodings. This guarantees that it will load correctly and\n+    // without delay on all Java platforms.\n+    //\n+    \n+    /**\n+     * Returns the given Charset or the default Charset if the given Charset is null. \n+     * \n+     * @param charset\n+     *            A charset or null.\n+     * @return the given Charset or the default Charset if the given Charset is null\n+     */\n+    public static Charset toCharset(Charset charset) {\n+        return charset == null ? Charset.defaultCharset() : charset;\n+    }\n+\n+    /**\n+     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n+     * \n+     * @param charset\n+     *            The name of the requested charset, may be null.\n+     * @return a Charset for the named charset\n+     * @throws UnsupportedCharsetException\n+     *             If the named charset is unavailable\n+     */\n+    public static Charset toCharset(String charset) {\n+        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n+    }\n+\n+    /**\n+     * CharsetNamesISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1. </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n+     * (either order accepted on input, big-endian used on output)\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java\n  */\n package org.apache.commons.compress.archivers;\n \n-import java.io.ByteArrayInputStream;\n-import org.junit.Test;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayInputStream;\n+\n+import org.junit.Test;\n \n public class ArchiveStreamFactoryTest {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/CpioTestCase.java\n \n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveEntry;\n-import org.apache.commons.compress.archivers.cpio.CpioConstants;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n+import org.apache.commons.compress.archivers.cpio.CpioConstants;\n import org.apache.commons.compress.utils.IOUtils;\n \n public final class CpioTestCase extends AbstractTestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/JarTestCase.java\n import java.io.InputStream;\n import java.io.OutputStream;\n \n+import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.utils.IOUtils;\n-\n-import org.apache.commons.compress.AbstractTestCase;\n \n public final class JarTestCase extends AbstractTestCase {\n     public void testJarArchiveCreation() throws Exception {\n--- a/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/TarTestCase.java\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.utils.CharsetNames;\n import org.apache.commons.compress.utils.IOUtils;\n \n public final class TarTestCase extends AbstractTestCase {\n \n     public void testTarArchiveLongNameCreation() throws Exception {\n         String name = \"testdata/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456.xml\";\n-        byte[] bytes = name.getBytes(\"UTF-8\");\n+        byte[] bytes = name.getBytes(CharsetNames.UTF_8);\n         assertEquals(bytes.length, 99);\n \n         final File output = new File(dir, \"bla.tar\");\n         final File input = getFile(\"COMPRESS-114.tar\");\n         final InputStream is = new FileInputStream(input);\n         final ArchiveInputStream in = new TarArchiveInputStream(is,\n-                                                                \"iso-8859-1\");\n+                CharsetNames.ISO_8859_1);\n         TarArchiveEntry entry = (TarArchiveEntry)in.getNextEntry();\n         assertEquals(\"3\\u00b1\\u00b1\\u00b1F06\\u00b1W2345\\u00b1ZB\\u00b1la\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1BLA\", entry.getName());\n         entry = (TarArchiveEntry)in.getNextEntry();\n--- a/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStreamTest.java\n \n import java.io.BufferedInputStream;\n import java.io.FileInputStream;\n+\n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.utils.ArchiveUtils;\n--- a/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStreamTest.java\n package org.apache.commons.compress.archivers.ar;\n \n import java.io.ByteArrayOutputStream;\n+import java.io.File;\n import java.io.FileOutputStream;\n-import java.io.File;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n+\n import org.apache.commons.compress.AbstractTestCase;\n \n public class ArArchiveOutputStreamTest extends AbstractTestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/cpio/CpioUtilTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioUtilTest.java\n  */\n package org.apache.commons.compress.archivers.cpio;\n \n-import org.junit.Test;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n \n public class CpioUtilTest {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveEntryTest.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n+import static org.junit.Assert.assertEquals;\n+\n import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n \n public class DumpArchiveEntryTest {\n     @Test\n--- a/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStreamTest.java\n package org.apache.commons.compress.archivers.dump;\n \n import java.io.FileInputStream;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.AbstractTestCase;\n \n public class DumpArchiveInputStreamTest extends AbstractTestCase {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtilTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/dump/DumpArchiveUtilTest.java\n  */\n package org.apache.commons.compress.archivers.dump;\n \n+import static org.junit.Assert.assertEquals;\n+\n import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n \n public class DumpArchiveUtilTest {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+\n import junit.framework.TestCase;\n \n import org.apache.commons.compress.AbstractTestCase;\n--- a/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveEntry.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/memory/MemoryArchiveEntry.java\n package org.apache.commons.compress.archivers.memory;\n \n import java.util.Date;\n+\n import org.apache.commons.compress.archivers.ArchiveEntry;\n \n public final class MemoryArchiveEntry implements ArchiveEntry {\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/BigFilesIT.java\n \n package org.apache.commons.compress.archivers.tar;\n \n-import java.util.Random;\n-\n-import org.junit.Test;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n \n+import java.util.Random;\n+\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n+import org.junit.Test;\n \n public class BigFilesIT {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/SparseFilesTest.java\n import java.io.FileInputStream;\n import java.net.URI;\n import java.net.URL;\n+\n import junit.framework.TestCase;\n \n public class SparseFilesTest extends TestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.util.Locale;\n+\n import junit.framework.TestCase;\n \n import org.apache.commons.compress.AbstractTestCase;\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStreamTest.java\n \n package org.apache.commons.compress.archivers.tar;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.util.Date;\n import java.util.Map;\n import java.util.TimeZone;\n+\n+import org.apache.commons.compress.utils.CharsetNames;\n import org.junit.Test;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n \n public class TarArchiveInputStreamTest {\n \n     public void readSimplePaxHeader() throws Exception {\n         Map<String, String> headers = new TarArchiveInputStream(null)\n             .parsePaxHeaders(new ByteArrayInputStream(\"30 atime=1321711775.972059463\\n\"\n-                                                      .getBytes(\"UTF-8\")));\n+                                                      .getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n         assertEquals(\"1321711775.972059463\", headers.get(\"atime\"));\n     }\n     public void readPaxHeaderWithEmbeddedNewline() throws Exception {\n         Map<String, String> headers = new TarArchiveInputStream(null)\n             .parsePaxHeaders(new ByteArrayInputStream(\"28 comment=line1\\nline2\\nand3\\n\"\n-                                                      .getBytes(\"UTF-8\")));\n+                                                      .getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n         assertEquals(\"line1\\nline2\\nand3\", headers.get(\"comment\"));\n     }\n     public void readNonAsciiPaxHeader() throws Exception {\n         String ae = \"\\u00e4\";\n         String line = \"11 path=\"+ ae + \"\\n\";\n-        assertEquals(11, line.getBytes(\"UTF-8\").length);\n+        assertEquals(11, line.getBytes(CharsetNames.UTF_8).length);\n         Map<String, String> headers = new TarArchiveInputStream(null)\n-            .parsePaxHeaders(new ByteArrayInputStream(line.getBytes(\"UTF-8\")));\n+            .parsePaxHeaders(new ByteArrayInputStream(line.getBytes(CharsetNames.UTF_8)));\n         assertEquals(1, headers.size());\n         assertEquals(ae, headers.get(\"path\"));\n     }\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStreamTest.java\n import org.apache.commons.compress.AbstractTestCase;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.utils.CharsetNames;\n \n public class TarArchiveOutputStreamTest extends AbstractTestCase {\n \n                                 + TarConstants.MODELEN\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN, 12,\n-                                \"UTF-8\"));\n+                                CharsetNames.UTF_8));\n         TarArchiveInputStream tin =\n             new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n                                 + TarConstants.MODELEN\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN, 12,\n-                                \"UTF-8\"));\n-        assertEquals(\"6 a=b\\n\", new String(data, 512, 6, \"UTF-8\"));\n+                                CharsetNames.UTF_8));\n+        assertEquals(\"6 a=b\\n\", new String(data, 512, 6, CharsetNames.UTF_8));\n     }\n \n     public void testPaxHeadersWithLength99() throws Exception {\n                                 + TarConstants.MODELEN\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN, 12,\n-                                \"UTF-8\"));\n+                                CharsetNames.UTF_8));\n         assertEquals(\"99 a=0123456789012345678901234567890123456789\"\n               + \"01234567890123456789012345678901234567890123456789\"\n-              + \"012\\n\", new String(data, 512, 99, \"UTF-8\"));\n+              + \"012\\n\", new String(data, 512, 99, CharsetNames.UTF_8));\n     }\n \n     public void testPaxHeadersWithLength101() throws Exception {\n                                 + TarConstants.MODELEN\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN, 12,\n-                                \"UTF-8\"));\n+                                CharsetNames.UTF_8));\n         assertEquals(\"101 a=0123456789012345678901234567890123456789\"\n               + \"01234567890123456789012345678901234567890123456789\"\n-              + \"0123\\n\", new String(data, 512, 101, \"UTF-8\"));\n+              + \"0123\\n\", new String(data, 512, 101, CharsetNames.UTF_8));\n     }\n \n     private byte[] writePaxHeader(Map<String, String> m) throws Exception {\n         tos.closeArchiveEntry();\n         byte[] data = bos.toByteArray();\n         assertEquals(\"160 path=\" + n + \"\\n\",\n-                     new String(data, 512, 160, \"UTF-8\"));\n+                     new String(data, 512, 160, CharsetNames.UTF_8));\n         TarArchiveInputStream tin =\n             new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n                                 + TarConstants.UIDLEN\n                                 + TarConstants.GIDLEN\n                                 + TarConstants.SIZELEN, 12,\n-                                \"UTF-8\"));\n+                                CharsetNames.UTF_8));\n         TarArchiveInputStream tin =\n             new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n         tos.close();\n         byte[] data = bos.toByteArray();\n         assertEquals(\"11 path=\" + n + \"\\n\",\n-                     new String(data, 512, 11, \"UTF-8\"));\n+                     new String(data, 512, 11, CharsetNames.UTF_8));\n         TarArchiveInputStream tin =\n             new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n         tos.close();\n         byte[] data = bos.toByteArray();\n         assertEquals(\"15 linkpath=\" + n + \"\\n\",\n-                     new String(data, 512, 15, \"UTF-8\"));\n+                     new String(data, 512, 15, CharsetNames.UTF_8));\n         TarArchiveInputStream tin =\n             new TarArchiveInputStream(new ByteArrayInputStream(data));\n         TarArchiveEntry e = tin.getNextTarEntry();\n--- a/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarUtilsTest.java\n package org.apache.commons.compress.archivers.tar;\n \n import junit.framework.TestCase;\n+\n import org.apache.commons.compress.archivers.zip.ZipEncoding;\n import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n+import org.apache.commons.compress.utils.CharsetNames;\n \n public class TarUtilsTest extends TestCase {\n \n         byte [] buffer;\n         final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n         final String maxOctal = \"77777777777 \"; // Maximum valid octal\n-        buffer = maxOctal.getBytes(\"UTF-8\");\n+        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n         value = TarUtils.parseOctal(buffer,0, buffer.length);\n         assertEquals(MAX_OCTAL, value);\n         buffer[buffer.length-1]=0;\n             fail(\"Expected IllegalArgumentException - not all NULs\");\n         } catch (IllegalArgumentException expected) {\n         }\n-        buffer = \"abcdef \".getBytes(\"UTF-8\"); // Invalid input\n+        buffer = \"abcdef \".getBytes(CharsetNames.UTF_8); // Invalid input\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException\");\n         } catch (IllegalArgumentException expected) {\n         }\n-        buffer = \"77777777777\".getBytes(\"UTF-8\"); // Invalid input - no trailer\n+        buffer = \"77777777777\".getBytes(CharsetNames.UTF_8); // Invalid input - no trailer\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - no trailer\");\n         } catch (IllegalArgumentException expected) {\n         }\n-        buffer = \" 0 07 \".getBytes(\"UTF-8\"); // Invalid - embedded space\n+        buffer = \" 0 07 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded space\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - embedded space\");\n         } catch (IllegalArgumentException expected) {\n         }\n-        buffer = \" 0\\00007 \".getBytes(\"UTF-8\"); // Invalid - embedded NUL\n+        buffer = \" 0\\00007 \".getBytes(CharsetNames.UTF_8); // Invalid - embedded NUL\n         try {\n             TarUtils.parseOctal(buffer,0, buffer.length);\n             fail(\"Expected IllegalArgumentException - embedded NUL\");\n     public void testNegative() throws Exception {\n         byte [] buffer = new byte[22];\n         TarUtils.formatUnsignedOctalString(-1, buffer, 0, buffer.length);\n-        assertEquals(\"1777777777777777777777\", new String(buffer, \"UTF-8\"));\n+        assertEquals(\"1777777777777777777777\", new String(buffer, CharsetNames.UTF_8));\n     }\n \n     public void testOverflow() throws Exception {\n         byte [] buffer = new byte[8-1]; // a lot of the numbers have 8-byte buffers (nul term)\n         TarUtils.formatUnsignedOctalString(07777777L, buffer, 0, buffer.length);\n-        assertEquals(\"7777777\", new String(buffer, \"UTF-8\"));\n+        assertEquals(\"7777777\", new String(buffer, CharsetNames.UTF_8));\n         try {\n             TarUtils.formatUnsignedOctalString(017777777L, buffer, 0, buffer.length);\n             fail(\"Should have cause IllegalArgumentException\");\n \n     public void testRoundEncoding() throws Exception {\n         // COMPRESS-114\n-        ZipEncoding enc = ZipEncodingHelper.getZipEncoding(\"iso-8859-1\");\n+        ZipEncoding enc = ZipEncodingHelper.getZipEncoding(CharsetNames.ISO_8859_1);\n         String s = \"0302-0601-3\\u00b1\\u00b1\\u00b1F06\\u00b1W220\\u00b1ZB\\u00b1LALALA\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1\\u00b1CAN\\u00b1\\u00b1DC\\u00b1\\u00b1\\u00b104\\u00b1060302\\u00b1MOE.model\";\n         byte buff[] = new byte[100];\n         int len = TarUtils.formatNameBytes(s, buff, 0, buff.length, enc);\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/EncryptedArchiveTest.java\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n+\n import junit.framework.TestCase;\n \n public class EncryptedArchiveTest extends TestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBitTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/GeneralPurposeBitTest.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.util.Arrays;\n+\n import junit.framework.TestCase;\n \n public class GeneralPurposeBitTest extends TestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Enumeration;\n+\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.utils.IOUtils;\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java\n import java.net.URISyntaxException;\n import java.net.URL;\n \n+import junit.framework.TestCase;\n+\n import org.apache.commons.compress.archivers.ArchiveEntry;\n-\n-import junit.framework.TestCase;\n \n /**\n  * JUnit 3 testcase for a multi-volume zip file.\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/TestZipEncodings.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/TestZipEncodings.java\n import java.nio.ByteBuffer;\n \n import junit.framework.TestCase;\n+\n+import org.apache.commons.compress.utils.CharsetNames;\n \n /**\n  * Test zip encodings.\n         assertEquals(testBytes, encoded);\n \n         assertEquals(false, enc.canEncode(UNENC_STRING));\n-        assertEquals(\"%U2016\".getBytes(\"US-ASCII\"), enc.encode(UNENC_STRING));\n+        assertEquals(\"%U2016\".getBytes(CharsetNames.US_ASCII), enc.encode(UNENC_STRING));\n         assertEquals(false, enc.canEncode(BAD_STRING));\n-        assertEquals(BAD_STRING_ENC.getBytes(\"US-ASCII\"),\n+        assertEquals(BAD_STRING_ENC.getBytes(CharsetNames.US_ASCII),\n                      enc.encode(BAD_STRING));\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n import java.util.zip.CRC32;\n \n import org.apache.commons.compress.AbstractTestCase;\n+import org.apache.commons.compress.utils.CharsetNames;\n \n public class UTF8ZipFilesTest extends AbstractTestCase {\n \n-    private static final String UTF_8 = \"utf-8\";\n     private static final String CP437 = \"cp437\";\n-    private static final String US_ASCII = \"US-ASCII\";\n     private static final String ASCII_TXT = \"ascii.txt\";\n     private static final String EURO_FOR_DOLLAR_TXT = \"\\u20AC_for_Dollar.txt\";\n     private static final String OIL_BARREL_TXT = \"\\u00D6lf\\u00E4sser.txt\";\n \n     public void testUtf8FileRoundtripExplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(UTF_8, true, true);\n+        testFileRoundtrip(CharsetNames.UTF_8, true, true);\n     }\n \n     public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(UTF_8, false, true);\n+        testFileRoundtrip(CharsetNames.UTF_8, false, true);\n     }\n \n     public void testCP437FileRoundtripExplicitUnicodeExtra()\n \n     public void testASCIIFileRoundtripExplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(US_ASCII, false, true);\n+        testFileRoundtrip(CharsetNames.US_ASCII, false, true);\n     }\n \n     public void testUtf8FileRoundtripImplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(UTF_8, true, false);\n+        testFileRoundtrip(CharsetNames.UTF_8, true, false);\n     }\n \n     public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(UTF_8, false, false);\n+        testFileRoundtrip(CharsetNames.UTF_8, false, false);\n     }\n \n     public void testCP437FileRoundtripImplicitUnicodeExtra()\n \n     public void testASCIIFileRoundtripImplicitUnicodeExtra()\n         throws IOException {\n-        testFileRoundtrip(US_ASCII, false, false);\n+        testFileRoundtrip(CharsetNames.US_ASCII, false, false);\n     }\n \n     /*\n         file.deleteOnExit();\n         ZipArchiveInputStream zi = null;\n         try {\n-            createTestFile(file, US_ASCII, false, true);\n+            createTestFile(file, CharsetNames.US_ASCII, false, true);\n             FileInputStream archive = new FileInputStream(file);\n-            zi = new ZipArchiveInputStream(archive, US_ASCII, true);\n+            zi = new ZipArchiveInputStream(archive, CharsetNames.US_ASCII, true);\n             assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());\n             assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());\n             assertEquals(ASCII_TXT, zi.getNextEntry().getName());\n         file.deleteOnExit();\n         ZipFile zf = null;\n         try {\n-            createTestFile(file, US_ASCII, false, true);\n-            zf = new ZipFile(file, US_ASCII, true);\n+            createTestFile(file, CharsetNames.US_ASCII, false, true);\n+            zf = new ZipFile(file, CharsetNames.US_ASCII, true);\n             assertNotNull(zf.getEntry(ASCII_TXT));\n             assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n             assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n             }\n \n             zos.putArchiveEntry(ze);\n-            zos.write(\"Hello, world!\".getBytes(\"US-ASCII\"));\n+            zos.write(\"Hello, world!\".getBytes(CharsetNames.US_ASCII));\n             zos.closeArchiveEntry();\n \n             ze = new ZipArchiveEntry(EURO_FOR_DOLLAR_TXT);\n             }\n \n             zos.putArchiveEntry(ze);\n-            zos.write(\"Give me your money!\".getBytes(\"US-ASCII\"));\n+            zos.write(\"Give me your money!\".getBytes(CharsetNames.US_ASCII));\n             zos.closeArchiveEntry();\n \n             ze = new ZipArchiveEntry(ASCII_TXT);\n             }\n \n             zos.putArchiveEntry(ze);\n-            zos.write(\"ascii\".getBytes(\"US-ASCII\"));\n+            zos.write(\"ascii\".getBytes(CharsetNames.US_ASCII));\n             zos.closeArchiveEntry();\n \n             zos.finish();\n \n             assertEquals(crc.getValue(), ucpf.getNameCRC32());\n             assertEquals(expectedName, new String(ucpf.getUnicodeName(),\n-                                                  UTF_8));\n+                                                  CharsetNames.UTF_8));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraFieldTest.java\n \n import java.math.BigInteger;\n import java.util.zip.ZipException;\n+\n import junit.framework.TestCase;\n \n public class Zip64ExtendedInformationExtraFieldTest extends TestCase {\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Zip64SupportIT.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeNotNull;\n+import static org.junit.Assume.assumeTrue;\n+\n import java.io.BufferedOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.util.Random;\n \n import org.apache.commons.compress.AbstractTestCase;\n-\n import org.junit.Test;\n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.junit.Assume.assumeNotNull;\n-import static org.junit.Assume.assumeTrue;\n \n public class Zip64SupportIT {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import static org.junit.Assert.assertEquals;\n+\n import java.io.File;\n import java.io.FileInputStream;\n import java.net.URI;\n import java.net.URL;\n+\n import org.junit.Test;\n-\n-import static org.junit.Assert.assertEquals;\n \n public class ZipArchiveInputStreamTest {\n \n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipEightByteIntegerTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipEightByteIntegerTest.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.math.BigInteger;\n+\n import junit.framework.TestCase;\n \n /**\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileTest.java\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collections;\n+\n import junit.framework.TestCase;\n \n public class ZipFileTest extends TestCase {\n--- a/src/test/java/org/apache/commons/compress/compressors/BZip2UtilsTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/BZip2UtilsTestCase.java\n  */\n package org.apache.commons.compress.compressors;\n \n+import junit.framework.TestCase;\n+\n import org.apache.commons.compress.compressors.bzip2.BZip2Utils;\n-\n-import junit.framework.TestCase;\n \n public class BZip2UtilsTestCase extends TestCase {\n \n--- a/src/test/java/org/apache/commons/compress/compressors/GzipUtilsTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/GzipUtilsTestCase.java\n  */\n package org.apache.commons.compress.compressors;\n \n+import junit.framework.TestCase;\n+\n import org.apache.commons.compress.compressors.gzip.GzipUtils;\n-\n-import junit.framework.TestCase;\n \n public class GzipUtilsTestCase extends TestCase {\n \n--- a/src/test/java/org/apache/commons/compress/compressors/XZUtilsTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/compressors/XZUtilsTestCase.java\n  */\n package org.apache.commons.compress.compressors;\n \n+import junit.framework.TestCase;\n+\n import org.apache.commons.compress.compressors.xz.XZUtils;\n-\n-import junit.framework.TestCase;\n \n public class XZUtilsTestCase extends TestCase {\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/utils/CharsetsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.compress.utils;\n+\n+import java.nio.charset.Charset;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Sanity checks for {@link Charsets}.\n+ * \n+ * @version $Id$\n+ */\n+public class CharsetsTest {\n+\n+    @Test\n+    public void testToCharset() {\n+        Assert.assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null));\n+        Assert.assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null));\n+        Assert.assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset()));\n+        Assert.assertEquals(Charset.forName(\"UTF-8\"), Charsets.toCharset(Charset.forName(\"UTF-8\")));\n+    }\n+\n+    @Test\n+    public void testIso8859_1() {\n+        Assert.assertEquals(\"ISO-8859-1\", Charsets.ISO_8859_1.name());\n+    }\n+\n+    @Test\n+    public void testUsAscii() {\n+        Assert.assertEquals(\"US-ASCII\", Charsets.US_ASCII.name());\n+    }\n+\n+    @Test\n+    public void testUtf16() {\n+        Assert.assertEquals(\"UTF-16\", Charsets.UTF_16.name());\n+    }\n+\n+    @Test\n+    public void testUtf16Be() {\n+        Assert.assertEquals(\"UTF-16BE\", Charsets.UTF_16BE.name());\n+    }\n+\n+    @Test\n+    public void testUtf16Le() {\n+        Assert.assertEquals(\"UTF-16LE\", Charsets.UTF_16LE.name());\n+    }\n+\n+    @Test\n+    public void testUtf8() {\n+        Assert.assertEquals(\"UTF-8\", Charsets.UTF_8.name());\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/compress/utils/CountingStreamTest.java\n+++ b/src/test/java/org/apache/commons/compress/utils/CountingStreamTest.java\n  */\n package org.apache.commons.compress.utils;\n \n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n+\n import org.junit.Test;\n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n \n public class CountingStreamTest {\n ", "timestamp": 1333233364, "metainfo": ""}