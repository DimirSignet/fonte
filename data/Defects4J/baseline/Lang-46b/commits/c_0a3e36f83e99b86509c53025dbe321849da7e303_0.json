{"sha": "0a3e36f83e99b86509c53025dbe321849da7e303", "log": "Using isEmpty() internally.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * @author Phil Steitz\n  * @author Al Chou\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.124 2004/02/16 23:48:10 ggregory Exp $\n+ * @version $Id: StringUtils.java,v 1.125 2004/02/18 22:32:50 fredrik Exp $\n  */\n public class StringUtils {\n     // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n      */\n     public static String trimToNull(String str) {\n         String ts = trim(str);\n-        return (ts == null || ts.length() == 0 ? null : ts);\n+        return (isEmpty(ts) ? null : ts);\n     }\n \n     /**\n      * @return the stripped String, <code>null</code> if null String input\n      */\n     public static String strip(String str, String stripChars) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n         str = stripStart(str, stripChars);\n      * @since 2.0\n      */\n     public static int indexOf(String str, char searchChar) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return -1;\n         }\n         return str.indexOf(searchChar);\n      * @since 2.0\n      */\n     public static int indexOf(String str, char searchChar, int startPos) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return -1;\n         }\n         return str.indexOf(searchChar, startPos);\n      * @since 2.0\n      */\n     public static int lastIndexOf(String str, char searchChar) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return -1;\n         }\n         return str.lastIndexOf(searchChar);\n      * @since 2.0\n      */\n     public static int lastIndexOf(String str, char searchChar, int startPos) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return -1;\n         }\n         return str.lastIndexOf(searchChar, startPos);\n      * @since 2.0\n      */\n     public static boolean contains(String str, char searchChar) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return false;\n         }\n         return (str.indexOf(searchChar) >= 0);\n      * @since 2.0\n      */\n     public static int indexOfAny(String str, char[] searchChars) {\n-        if (StringUtils.isEmpty(str) || searchChars == null || searchChars.length == 0) {\n+        if (isEmpty(str) || searchChars == null || searchChars.length == 0) {\n             return -1;\n         }\n         for (int i = 0; i < str.length(); i++) {\n      * @since 2.0\n      */\n     public static int indexOfAny(String str, String searchChars) {\n-        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n             return -1;\n         }\n         return indexOfAny(str, searchChars.toCharArray());\n      * @since 2.0\n      */\n     public static int indexOfAnyBut(String str, char[] searchChars) {\n-        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+        if (isEmpty(str) || searchChars == null || searchChars.length == 0) {\n             return -1;\n         }\n         outer : for (int i = 0; i < str.length(); i++) {\n      * @since 2.0\n      */\n     public static int indexOfAnyBut(String str, String searchChars) {\n-        if (str == null || str.length() == 0 || searchChars == null || searchChars.length() == 0) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n             return -1;\n         }\n         for (int i = 0; i < str.length(); i++) {\n      * @since 2.0\n      */\n     public static String substringBefore(String str, String separator) {\n-        if (str == null || separator == null || str.length() == 0) {\n+        if (isEmpty(str) || separator == null) {\n             return str;\n         }\n         if (separator.length() == 0) {\n      * @since 2.0\n      */\n     public static String substringAfter(String str, String separator) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n         if (separator == null) {\n      * @since 2.0\n      */\n     public static String substringBeforeLast(String str, String separator) {\n-        if (str == null || separator == null || str.length() == 0 || separator.length() == 0) {\n+        if (isEmpty(str) || isEmpty(separator)) {\n             return str;\n         }\n         int pos = str.lastIndexOf(separator);\n      * @since 2.0\n      */\n     public static String substringAfterLast(String str, String separator) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n-        if (separator == null || separator.length() == 0) {\n+        if (isEmpty(separator)) {\n             return EMPTY;\n         }\n         int pos = str.lastIndexOf(separator);\n     }\n \n     /**\n-     * <p>Splits the provided text into an array with a maximum length, \n+     * <p>Splits the provided text into an array with a maximum length,\n      * separators specified.</p>\n      *\n      * <p>The separator is not included in the returned String array.\n      * <p>A <code>null</code> input String returns <code>null</code>.\n      * A <code>null</code> separatorChars splits on whitespace.</p>\n      *\n-     * <p>If more than <code>max</code> delimited substrings are found, the last \n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n      * returned string includes all characters after the first <code>max - 1</code>\n      * returned strings (including separator characters).</p>\n      *\n      * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n      * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n      * </pre>\n-     * \n+     *\n      * @param str  the String to parse, may be null\n      * @param separatorChars  the characters used as the delimiters,\n      *  <code>null</code> splits on whitespace\n      * @return the String without whitespaces, <code>null</code> if null String input\n      */\n     public static String deleteWhitespace(String str) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n         int sz = str.length();\n      * @since 2.1\n      */\n     public static String removeStart(String str, String remove) {\n-        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n         if (str.startsWith(remove)){\n      * @since 2.1\n      */\n     public static String removeEnd(String str, String remove) {\n-        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(remove)) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n         if (str.endsWith(remove)) {\n      *  <code>null</code> if null String input\n      */\n     public static String replace(String text, String repl, String with, int max) {\n-        if (text == null || repl == null || with == null || repl.length() == 0 || max == 0) {\n+        if (text == null || isEmpty(repl) || with == null || max == 0) {\n             return text;\n         }\n \n      * @since 2.0\n      */\n     public static String replaceChars(String str, String searchChars, String replaceChars) {\n-        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchChars)) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n             return str;\n         }\n         if (replaceChars == null) {\n      * @return String without newline, <code>null</code> if null String input\n      */\n     public static String chomp(String str) {\n-        if (str == null || str.length() == 0) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n \n      * @return String without trailing separator, <code>null</code> if null String input\n      */\n     public static String chomp(String str, String separator) {\n-        if (str == null || str.length() == 0 || separator == null) {\n+        if (isEmpty(str) || separator == null) {\n             return str;\n         }\n         if (str.endsWith(separator)) {\n         if (str == null) {\n             return null;\n         }\n-        if (padStr == null || padStr.length() == 0) {\n+        if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n         int padLen = padStr.length();\n         if (str == null) {\n             return null;\n         }\n-        if (padStr == null || padStr.length() == 0) {\n+        if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n         int padLen = padStr.length();\n         if (str == null || size <= 0) {\n             return str;\n         }\n-        if (padStr == null || padStr.length() == 0) {\n+        if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n         int strLen = str.length();\n      * @return the number of occurrences, 0 if either String is <code>null</code>\n      */\n     public static int countMatches(String str, String sub) {\n-        if (str == null || str.length() == 0 || sub == null || sub.length() == 0) {\n+        if (isEmpty(str) || isEmpty(sub)) {\n             return 0;\n         }\n         int count = 0;", "timestamp": 1077143570, "metainfo": ""}