{"sha": "faba313cd82fc744dc5e9e3b02680d7c823d3196", "log": "Checked back in for consideration in 1.0   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n+package org.apache.commons.lang;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+/**\n+ * A set of static utilities for use with ClassUtils.\n+ *\n+ * @author  bayard@generationjava.com\n+ * @version $Id: ClassUtils.java,v 1.1 2002/08/14 04:51:28 bayard Exp $\n+ */\n+final public class ClassUtils {\n+\n+    /**\n+     * Create an object from the classname. Must have an empty constructor.\n+     *\n+     * @param classname String name of the class\n+     *\n+     * @return Object instance of the class or null\n+     */\n+    static public Object createObject(String classname) {\n+        Class tmpClass = null;\n+\n+        tmpClass = getClass(classname);\n+\n+        return createObject(tmpClass);\n+    }\n+\n+    /**\n+     * Create an object from a class. \n+     *\n+     * @param clss Class object to instantiate\n+     *\n+     * @return Object instance of the class or null\n+     */\n+    static public Object createObject(Class clss) {\n+\n+        try {\n+            return clss.newInstance();\n+        } catch (IllegalAccessException  iae) {\n+            System.err.println(\"Cant instantiate \" + clss.getName() + \" because \" +\n+                   iae.getMessage());\n+        } catch (InstantiationException  ie) {\n+            System.err.println(\"Cant instantiate \" + clss.getName() + \" because \" +\n+                   ie.getMessage());\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Is this Class in the CLASSPATH\n+     *\n+     * @param classname String of the class\n+     *\n+     * @return boolean exists or not.\n+     */\n+    static public boolean classExists(String classname) {\n+        Class tmpClass = null;\n+\n+        /* try and load class */\n+        try {\n+            tmpClass = Class.forName(classname);\n+        } catch (ClassNotFoundException cnfe) {\n+            return false;\n+        } catch (IllegalArgumentException iae) {\n+            return false;\n+        }\n+     \n+        return true;   \n+    }\n+\n+    /**\n+     * Get the Class object for a classname.\n+     *\n+     * @param classname String of the class\n+     *\n+     * @return Class instance for the class.\n+     */\n+    static public Class getClass(String classname) {\n+        Class tmpClass = null;\n+\n+        /* try an load class */\n+        try {\n+            tmpClass = Class.forName(classname);\n+        } catch (ClassNotFoundException cnfe) {\n+            System.out.println(\"Can't resolve classname \" + classname);\n+        } catch (IllegalArgumentException iae) {\n+            System.err.println(\"Cant resolve \" + tmpClass.getName() + \" because \" + iae.getMessage());\n+        }\n+     \n+        return tmpClass;   \n+    }\n+\n+    /**\n+     * Is this Class object an instance of the class with this name.\n+     *\n+     * @param clss Class instance\n+     * @param inst String name of potential supertype\n+     *\n+     * @return boolean was it an instanceof\n+     */\n+    static public boolean classInstanceOf(Class clss, String inst) {\n+        if(classImplements(clss,inst)) {\n+            return true;\n+        } else\n+        if(classExtends(clss,inst)) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Does this Class implement an interface with this name.\n+     *\n+     * @param clss Class instance\n+     * @param exts String name of potential interface\n+     *\n+     * @return boolean was it an implementor\n+     */\n+    static public boolean classImplements(Class clss, String exts) {\n+\n+      Class sprcls = clss;\n+      Class excls  = getClass(exts);\n+\n+      while(sprcls != null) {\n+        Class[] interfaces = sprcls.getInterfaces();\n+\n+        for(int i=0;i<interfaces.length;i++) {\n+            if(interfaces[i].equals(excls)) {\n+                return true;\n+            }\n+        }\n+\n+        sprcls = sprcls.getSuperclass();\n+      }\n+\n+      return false;\n+    }\n+\n+    /**\n+     * Does this Class extend a superclass with this name.\n+     *\n+     * @param clss Class instance\n+     * @param exts String name of potential superclass\n+     *\n+     * @return boolean was it a superclass\n+     */\n+    static public boolean classExtends(Class clss, String exts) {\n+        if(clss == null) {\n+            return false;\n+        }\n+        if(clss.getName().equals(exts)) {\n+            return true;\n+        }\n+        Class sprcls = clss.getSuperclass();\n+        Class excls = getClass(exts);\n+\n+//        while(! sprcls.equals(sprcls.getSuperclass()) ) {\n+        while( sprcls != null ) {\n+            if(sprcls.equals(excls)) {\n+                return true;\n+            }\n+            sprcls = sprcls.getSuperclass();\n+        }\n+        return false;\n+    }\n+\n+}", "timestamp": 1029300688, "metainfo": ""}