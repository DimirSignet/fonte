{"sha": "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034", "log": "Format @since 2.4 methods to match the rest of the file. For example, expressions use no spaces around parens.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n      * @since 2.4\n      */\n     public static boolean containsAny(String str, char[] searchChars) {\n-        if (str == null || str.length() == 0 ||\n-            searchChars == null || searchChars.length == 0) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n             return false;\n         }\n         for (int i = 0; i < str.length(); i++) {\n     }\n \n     /**\n-     * <p>Checks if the String contains any character in the given\n-     * set of characters.</p>\n-     *\n-     * <p>A <code>null</code> String will return <code>false</code>.\n-     * A <code>null</code> search string will return <code>false</code>.</p>\n-     *\n+     * <p>\n+     * Checks if the String contains any character in the given set of characters.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n+     * <code>false</code>.\n+     * </p>\n+     * \n      * <pre>\n      * StringUtils.containsAny(null, *)            = false\n      * StringUtils.containsAny(\"\", *)              = false\n      * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n      * StringUtils.containsAny(\"aba\",\"z\")          = false\n      * </pre>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param searchChars  the chars to search for, may be null\n-     * @return the <code>true</code> if any of the chars are found,\n-     * <code>false</code> if no match or null input\n+     * \n+     * @param str\n+     *            the String to check, may be null\n+     * @param searchChars\n+     *            the chars to search for, may be null\n+     * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n     public static boolean containsAny(String str, String searchChars) {\n      * @since 2.4\n      */\n     public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n-        return splitByWholeSeparatorWorker( str, separator, -1, true ) ;\n+        return splitByWholeSeparatorWorker(str, separator, -1, true);\n     }\n \n     /**\n      * @return an array of parsed Strings, <code>null</code> if null String was input\n      * @since 2.4\n      */\n-    public static String[] splitByWholeSeparatorPreserveAllTokens( String str, String separator, int max ) {\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n         return splitByWholeSeparatorWorker(str, separator, max, true);\n     }\n \n      * @return an array of parsed Strings, <code>null</code> if null String input\n      * @since 2.4\n      */\n-    private static String[] splitByWholeSeparatorWorker( String str, String separator, \n-                                                         int max, boolean preserveAllTokens ) \n-    {\n+    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n         if (str == null) {\n             return null;\n         }\n \n-        int len = str.length() ;\n+        int len = str.length();\n \n         if (len == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n \n-        if ( ( separator == null ) || ( EMPTY.equals( separator ) ) ) {\n+        if ((separator == null) || (EMPTY.equals(separator))) {\n             // Split on whitespace.\n-            return splitWorker( str, null, max, preserveAllTokens ) ;\n-        }\n-\n-\n-        int separatorLength = separator.length() ;\n-\n-        ArrayList substrings = new ArrayList() ;\n-        int numberOfSubstrings = 0 ;\n-        int beg = 0 ;\n-        int end = 0 ;\n-        while ( end < len ) {\n-            end = str.indexOf( separator, beg ) ;\n-\n-            if ( end > -1 ) {\n-                if ( end > beg ) {\n-                    numberOfSubstrings += 1 ;\n-\n-                    if ( numberOfSubstrings == max ) {\n-                        end = len ;\n-                        substrings.add( str.substring( beg ) ) ;\n+            return splitWorker(str, null, max, preserveAllTokens);\n+        }\n+\n+        int separatorLength = separator.length();\n+\n+        ArrayList substrings = new ArrayList();\n+        int numberOfSubstrings = 0;\n+        int beg = 0;\n+        int end = 0;\n+        while (end < len) {\n+            end = str.indexOf(separator, beg);\n+\n+            if (end > -1) {\n+                if (end > beg) {\n+                    numberOfSubstrings += 1;\n+\n+                    if (numberOfSubstrings == max) {\n+                        end = len;\n+                        substrings.add(str.substring(beg));\n                     } else {\n                         // The following is OK, because String.substring( beg, end ) excludes\n                         // the character at the position 'end'.\n-                        substrings.add( str.substring( beg, end ) ) ;\n+                        substrings.add(str.substring(beg, end));\n \n                         // Set the starting point for the next search.\n                         // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                         // which is the right calculation:\n-                        beg = end + separatorLength ;\n+                        beg = end + separatorLength;\n                     }\n                 } else {\n                     // We found a consecutive occurrence of the separator, so skip it.\n-                    if( preserveAllTokens ) {\n-                        numberOfSubstrings += 1 ;\n-                        if ( numberOfSubstrings == max ) {\n-                            end = len ;\n-                            substrings.add( str.substring( beg ) ) ;\n+                    if (preserveAllTokens) {\n+                        numberOfSubstrings += 1;\n+                        if (numberOfSubstrings == max) {\n+                            end = len;\n+                            substrings.add(str.substring(beg));\n                         } else {\n-                            substrings.add( EMPTY );\n+                            substrings.add(EMPTY);\n                         }\n                     }\n-                    beg = end + separatorLength ;\n+                    beg = end + separatorLength;\n                 }\n             } else {\n                 // String.substring( beg ) goes from 'beg' to the end of the String.\n-                substrings.add( str.substring( beg ) ) ;\n-                end = len ;\n-            }\n-        }\n-\n-        return (String[]) substrings.toArray( new String[substrings.size()] ) ;\n-    }\n-\n-\n-    //-----------------------------------------------------------------------\n+                substrings.add(str.substring(beg));\n+                end = len;\n+            }\n+        }\n+\n+        return (String[]) substrings.toArray(new String[substrings.size()]);\n+    }\n+\n+    // -----------------------------------------------------------------------\n     /**\n      * <p>Splits the provided text into an array, using whitespace as the\n      * separator, preserving all tokens, including empty tokens created by \n             if (type == currentType) {\n                 continue;\n             }\n-            if (camelCase && type == Character.LOWERCASE_LETTER\n-                    && currentType == Character.UPPERCASE_LETTER) {\n+            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                 int newTokenStart = pos - 1;\n                 if (newTokenStart != tokenStart) {\n                     list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n-        if (startsWithIgnoreCase(str, remove)){\n+        if (startsWithIgnoreCase(str, remove)) {\n             return str.substring(remove.length());\n         }\n         return str;\n      * @since 2.4\n      */\n     public static String replaceEachRepeatedly(String text, String[] repl, String[] with) {\n-\n         // timeToLive should be 0 if not used or nothing to replace, else it's\n         // the length of the replace array\n         int timeToLive = repl == null ? 0 : repl.length;\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] repl, String[] with,\n-            boolean repeat, int timeToLive) {\n-\n-        // mchyzer Performance note:  This creates very few new objects (one major goal)\n+    private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n+\n+        // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n-        \n-        if (text == null || text.length() == 0 || \n-            repl == null || repl.length == 0 || \n-            with == null || with.length == 0) \n-        {\n+\n+        if (text == null || text.length() == 0 || repl == null || repl.length == 0 || with == null || with.length == 0) {\n             return text;\n         }\n \n \n         // make sure lengths are ok, these need to be equal\n         if (replLength != withLength) {\n-            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + replLength + \" vs \" + withLength);\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+                + replLength\n+                + \" vs \"\n+                + withLength);\n         }\n \n         // keep track of which still have matches\n                 continue;\n             }\n             tempIndex = text.indexOf(repl[i]);\n-            \n+\n             // see if we need to keep searching for this\n             if (tempIndex == -1) {\n                 noMoreMatchesForReplIndex[i] = true;\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i=0; i<repl.length; i++) {\n+        for (int i = 0; i < repl.length; i++) {\n             int greater = with[i].length() - repl[i].length();\n-            if(greater > 0) {\n+            if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n         }\n         // have upper-bound at 20% increase, then let Java take over\n-        increase = Math.min(increase, text.length() / 5); \n-    \n+        increase = Math.min(increase, text.length() / 5);\n+\n         StringBuffer buf = new StringBuffer(text.length() + increase);\n \n         while (textIndex != -1) {\n                     continue;\n                 }\n                 tempIndex = text.indexOf(repl[i], start);\n-                \n-                //see if we need to keep searching for this\n+\n+                // see if we need to keep searching for this\n                 if (tempIndex == -1) {\n                     noMoreMatchesForReplIndex[i] = true;\n                 } else {\n         int shortestStrLen = Integer.MAX_VALUE;\n         int longestStrLen = 0;\n \n-        // find the min and max string lengths; this avoids checking to make \n+        // find the min and max string lengths; this avoids checking to make\n         // sure we are not exceeding the length of the string each time through\n         // the bottom loop.\n-        for (int i=0; i<arrayLen; i++) {\n+        for (int i = 0; i < arrayLen; i++) {\n             if (strs[i] == null) {\n                 anyStringNull = true;\n                 shortestStrLen = 0;\n-            } else {   \n+            } else {\n                 allStringsNull = false;\n                 shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n                 longestStrLen = Math.max(strs[i].length(), longestStrLen);\n         // handle lists containing some nulls or some empty strings\n         if (shortestStrLen == 0) {\n             return 0;\n-        } \n+        }\n \n         // find the position with the first difference across all strings\n         int firstDiff = -1;\n-        for (int stringPos = 0; stringPos<shortestStrLen; stringPos++) {\n+        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n             char comparisonChar = strs[0].charAt(stringPos);\n-            for (int arrayPos = 1; arrayPos<arrayLen; arrayPos++) {\n+            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                 if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n                     firstDiff = stringPos;\n                     break;\n         }\n \n         if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n-            // we compared all of the characters up to the length of the \n-            // shortest string and didn't find a match, but the string lengths \n+            // we compared all of the characters up to the length of the\n+            // shortest string and didn't find a match, but the string lengths\n             // vary, so return the length of the shortest string.\n             return shortestStrLen;\n         }\n             // there were no common initial characters\n             return EMPTY;\n         } else {\n-            // we found a common initial character sequence \n+            // we found a common initial character sequence\n             return strs[0].substring(0, smallestIndexOfDiff);\n         }\n     }  ", "timestamp": 1202329317, "metainfo": ""}