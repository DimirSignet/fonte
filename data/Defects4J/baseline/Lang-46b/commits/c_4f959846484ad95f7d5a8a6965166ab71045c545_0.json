{"sha": "4f959846484ad95f7d5a8a6965166ab71045c545", "log": "BitField moved over from the [util] project.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/util/BitField.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+/**\n+ * Manage operations dealing with bit-mapped fields.\n+ * <p>\n+ * Code originated from the POI project.\n+ *\n+ * @author Scott Sanders (sanders at apache dot org)\n+ * @author Marc Johnson (mjohnson at apache dot org)\n+ * @author Andrew C. Oliver (acoliver at apache dot org)\n+ * @author Stephen Colebourne\n+ * @version $Id: BitField.java,v 1.1 2002/12/18 02:50:36 bayard Exp $\n+ */\n+public class BitField {\n+    private final int _mask;\n+    private final int _shift_count;\n+\n+    /**\n+     * Create a BitField instance\n+     *\n+     * @param mask the mask specifying which bits apply to this\n+     *             BitField. Bits that are set in this mask are the\n+     *             bits that this BitField operates on\n+     */\n+\n+    public BitField(final int mask) {\n+        _mask = mask;\n+        int count = 0;\n+        int bit_pattern = mask;\n+\n+        if (bit_pattern != 0) {\n+            while ((bit_pattern & 1) == 0) {\n+                count++;\n+                bit_pattern >>= 1;\n+            }\n+        }\n+        _shift_count = count;\n+    }\n+\n+    /**\n+     * Obtain the value for the specified BitField, appropriately\n+     * shifted right. Many users of a BitField will want to treat the\n+     * specified bits as an int value, and will not want to be aware\n+     * that the value is stored as a BitField (and so shifted left so\n+     * many bits)\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return the selected bits, shifted right appropriately\n+     */\n+\n+    public int getValue(final int holder) {\n+        return getRawValue(holder) >> _shift_count;\n+    }\n+\n+    /**\n+     * Obtain the value for the specified BitField, appropriately\n+     * shifted right, as a short. Many users of a BitField will want\n+     * to treat the specified bits as an int value, and will not want\n+     * to be aware that the value is stored as a BitField (and so\n+     * shifted left so many bits)\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the selected bits, shifted right appropriately\n+     */\n+\n+    public short getShortValue(final short holder) {\n+        return (short) getValue(holder);\n+    }\n+\n+    /**\n+     * Obtain the value for the specified BitField, unshifted\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return the selected bits\n+     */\n+\n+    public int getRawValue(final int holder) {\n+        return (holder & _mask);\n+    }\n+\n+    /**\n+     * Obtain the value for the specified BitField, unshifted\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the selected bits\n+     */\n+\n+    public short getShortRawValue(final short holder) {\n+        return (short) getRawValue(holder);\n+    }\n+\n+    /**\n+     * Is the field set or not? This is most commonly used for a\n+     * single-bit field, which is often used to represent a boolean\n+     * value; the results of using it for a multi-bit field is to\n+     * determine whether *any* of its bits are set\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return true if any of the bits are set, else false\n+     */\n+\n+    public boolean isSet(final int holder) {\n+        return (holder & _mask) != 0;\n+    }\n+\n+    /**\n+     * Are all of the bits set or not? This is a stricter test than\n+     * isSet, in that all of the bits in a multi-bit set must be set\n+     * for this method to return true\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return true if all of the bits are set, else false\n+     */\n+\n+    public boolean isAllSet(final int holder) {\n+        return (holder & _mask) == _mask;\n+    }\n+\n+    /**\n+     * Replace the bits with new values.\n+     *\n+     * @param holder the int data containint the bits we're interested\n+     *               in\n+     * @param value the new value for the specified bits\n+     *\n+     * @return the value of holder with the bits from the value\n+     *         parameter replacing the old bits\n+     */\n+\n+    public int setValue(final int holder, final int value) {\n+        return (holder & ~_mask) | ((value << _shift_count) & _mask);\n+    }\n+\n+    /**\n+     * Replace the bits with new values.\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     * @param value the new value for the specified bits\n+     *\n+     * @return the value of holder with the bits from the value\n+     *         parameter replacing the old bits\n+     */\n+\n+    public short setShortValue(final short holder, final short value) {\n+        return (short) setValue(holder, value);\n+    }\n+\n+    /**\n+     * Clear the bits.\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *         (set to 0)\n+     */\n+\n+    public int clear(final int holder) {\n+        return holder & ~_mask;\n+    }\n+\n+    /**\n+     * Clear the bits.\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *         (set to 0)\n+     */\n+\n+    public short clearShort(final short holder) {\n+        return (short) clear(holder);\n+    }\n+\n+    /**\n+     * Clear the bits.\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *         (set to 0)\n+     */\n+\n+    public byte clearByte(final byte holder) {\n+        return (byte) clear(holder);\n+    }\n+\n+    /**\n+     * Set the bits.\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     *\n+     * @return the value of holder with the specified bits set to 1\n+     */\n+\n+    public int set(final int holder) {\n+        return holder | _mask;\n+    }\n+\n+    /**\n+     * Set the bits.\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the value of holder with the specified bits set to 1\n+     */\n+\n+    public short setShort(final short holder) {\n+        return (short) set(holder);\n+    }\n+\n+    /**\n+     * Set the bits.\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *               interested in\n+     *\n+     * @return the value of holder with the specified bits set to 1\n+     */\n+\n+    public byte setByte(final byte holder) {\n+        return (byte) set(holder);\n+    }\n+\n+    /**\n+     * Set a boolean BitField\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *               in\n+     * @param flag indicating whether to set or clear the bits\n+     *\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+\n+    public int setBoolean(final int holder, final boolean flag) {\n+        return flag ? set(holder) : clear(holder);\n+    }\n+\n+    /**\n+     * Set a boolean BitField\n+     *\n+     * @param holder the short data containing the bits we're\n+     *               interested in\n+     * @param flag indicating whether to set or clear the bits\n+     *\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+\n+    public short setShortBoolean(final short holder, final boolean flag) {\n+        return flag ? setShort(holder) : clearShort(holder);\n+    }\n+\n+    /**\n+     * Set a boolean BitField\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *               interested in\n+     * @param flag indicating whether to set or clear the bits\n+     *\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+\n+    public byte setByteBoolean(final byte holder, final boolean flag) {\n+        return flag ? setByte(holder) : clearByte(holder);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/util/BitFieldTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//lang/src/test/org/apache/commons/lang/util/Attic/BitFieldTest.java,v 1.1 2002/12/18 02:50:36 bayard Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/12/18 02:50:36 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.lang.util;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Class to test BitField functionality\n+ *\n+ * @author Scott Sanders (sanders at apache dot org)\n+ * @author Marc Johnson\n+ * @author Glen Stampoultzis (gstamp@iprimus.com.au)\n+ * @version $Id: BitFieldTest.java,v 1.1 2002/12/18 02:50:36 bayard Exp $\n+ */\n+\n+public class BitFieldTest\n+    extends TestCase\n+{\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(BitFieldTest.class);\n+    \tsuite.setName(\"BitField Tests\");\n+        return suite;\n+    }\n+\n+    private static BitField bf_multi  = new BitField(0x3F80);\n+    private static BitField bf_single = new BitField(0x4000);\n+\n+    /**\n+     * Constructor BitFieldTest\n+     *\n+     * @param name\n+     */\n+\n+    public BitFieldTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * test the getValue() method\n+     */\n+\n+    public void testGetValue()\n+    {\n+        assertEquals(bf_multi.getValue(-1), 127);\n+        assertEquals(bf_multi.getValue(0), 0);\n+        assertEquals(bf_single.getValue(-1), 1);\n+        assertEquals(bf_single.getValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortValue() method\n+     */\n+\n+    public void testGetShortValue()\n+    {\n+        assertEquals(bf_multi.getShortValue(( short ) -1), ( short ) 127);\n+        assertEquals(bf_multi.getShortValue(( short ) 0), ( short ) 0);\n+        assertEquals(bf_single.getShortValue(( short ) -1), ( short ) 1);\n+        assertEquals(bf_single.getShortValue(( short ) 0), ( short ) 0);\n+    }\n+\n+    /**\n+     * test the getRawValue() method\n+     */\n+\n+    public void testGetRawValue()\n+    {\n+        assertEquals(bf_multi.getRawValue(-1), 0x3F80);\n+        assertEquals(bf_multi.getRawValue(0), 0);\n+        assertEquals(bf_single.getRawValue(-1), 0x4000);\n+        assertEquals(bf_single.getRawValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortRawValue() method\n+     */\n+\n+    public void testGetShortRawValue()\n+    {\n+        assertEquals(bf_multi.getShortRawValue(( short ) -1),\n+                     ( short ) 0x3F80);\n+        assertEquals(bf_multi.getShortRawValue(( short ) 0), ( short ) 0);\n+        assertEquals(bf_single.getShortRawValue(( short ) -1),\n+                     ( short ) 0x4000);\n+        assertEquals(bf_single.getShortRawValue(( short ) 0), ( short ) 0);\n+    }\n+\n+    /**\n+     * test the isSet() method\n+     */\n+\n+    public void testIsSet()\n+    {\n+        assertTrue(!bf_multi.isSet(0));\n+        for (int j = 0x80; j <= 0x3F80; j += 0x80)\n+        {\n+            assertTrue(bf_multi.isSet(j));\n+        }\n+        assertTrue(!bf_single.isSet(0));\n+        assertTrue(bf_single.isSet(0x4000));\n+    }\n+\n+    /**\n+     * test the isAllSet() method\n+     */\n+\n+    public void testIsAllSet()\n+    {\n+        for (int j = 0; j < 0x3F80; j += 0x80)\n+        {\n+            assertTrue(!bf_multi.isAllSet(j));\n+        }\n+        assertTrue(bf_multi.isAllSet(0x3F80));\n+        assertTrue(!bf_single.isAllSet(0));\n+        assertTrue(bf_single.isAllSet(0x4000));\n+    }\n+\n+    /**\n+     * test the setValue() method\n+     */\n+\n+    public void testSetValue()\n+    {\n+        for (int j = 0; j < 128; j++)\n+        {\n+            assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);\n+            assertEquals(bf_multi.setValue(0, j), j << 7);\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setValue(0x3f80, 128), 0);\n+        for (int j = 0; j < 2; j++)\n+        {\n+            assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);\n+            assertEquals(bf_single.setValue(0, j), j << 14);\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setValue(0x4000, 2), 0);\n+    }\n+\n+    /**\n+     * test the setShortValue() method\n+     */\n+\n+    public void testSetShortValue()\n+    {\n+        for (int j = 0; j < 128; j++)\n+        {\n+            assertEquals(bf_multi\n+                .getShortValue(bf_multi\n+                    .setShortValue(( short ) 0, ( short ) j)), ( short ) j);\n+            assertEquals(bf_multi.setShortValue(( short ) 0, ( short ) j),\n+                         ( short ) (j << 7));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setShortValue(( short ) 0x3f80, ( short ) 128),\n+                     ( short ) 0);\n+        for (int j = 0; j < 2; j++)\n+        {\n+            assertEquals(bf_single\n+                .getShortValue(bf_single\n+                    .setShortValue(( short ) 0, ( short ) j)), ( short ) j);\n+            assertEquals(bf_single.setShortValue(( short ) 0, ( short ) j),\n+                         ( short ) (j << 14));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setShortValue(( short ) 0x4000, ( short ) 2),\n+                     ( short ) 0);\n+    }\n+\n+    public void testByte()\n+    {\n+        assertEquals(1, new BitField(1).setByteBoolean(( byte ) 0, true));\n+        assertEquals(2, new BitField(2).setByteBoolean(( byte ) 0, true));\n+        assertEquals(4, new BitField(4).setByteBoolean(( byte ) 0, true));\n+        assertEquals(8, new BitField(8).setByteBoolean(( byte ) 0, true));\n+        assertEquals(16, new BitField(16).setByteBoolean(( byte ) 0, true));\n+        assertEquals(32, new BitField(32).setByteBoolean(( byte ) 0, true));\n+        assertEquals(64, new BitField(64).setByteBoolean(( byte ) 0, true));\n+        assertEquals(-128,\n+                     new BitField(128).setByteBoolean(( byte ) 0, true));\n+        assertEquals(0, new BitField(1).setByteBoolean(( byte ) 1, false));\n+        assertEquals(0, new BitField(2).setByteBoolean(( byte ) 2, false));\n+        assertEquals(0, new BitField(4).setByteBoolean(( byte ) 4, false));\n+        assertEquals(0, new BitField(8).setByteBoolean(( byte ) 8, false));\n+        assertEquals(0, new BitField(16).setByteBoolean(( byte ) 16, false));\n+        assertEquals(0, new BitField(32).setByteBoolean(( byte ) 32, false));\n+        assertEquals(0, new BitField(64).setByteBoolean(( byte ) 64, false));\n+        assertEquals(0, new BitField(128).setByteBoolean(( byte ) 128,\n+                                     false));\n+        assertEquals(-2, new BitField(1).setByteBoolean(( byte ) 255, false));\n+        byte clearedBit = new BitField(0x40).setByteBoolean(( byte ) -63,\n+                                       false);\n+\n+        assertEquals(false, new BitField(0x40).isSet(clearedBit));\n+    }\n+\n+    /**\n+     * test the clear() method\n+     */\n+\n+    public void testClear()\n+    {\n+        assertEquals(bf_multi.clear(-1), 0xFFFFC07F);\n+        assertEquals(bf_single.clear(-1), 0xFFFFBFFF);\n+    }\n+\n+    /**\n+     * test the clearShort() method\n+     */\n+\n+    public void testClearShort()\n+    {\n+        assertEquals(bf_multi.clearShort(( short ) -1), ( short ) 0xC07F);\n+        assertEquals(bf_single.clearShort(( short ) -1), ( short ) 0xBFFF);\n+    }\n+\n+    /**\n+     * test the set() method\n+     */\n+\n+    public void testSet()\n+    {\n+        assertEquals(bf_multi.set(0), 0x3F80);\n+        assertEquals(bf_single.set(0), 0x4000);\n+    }\n+\n+    /**\n+     * test the setShort() method\n+     */\n+\n+    public void testSetShort()\n+    {\n+        assertEquals(bf_multi.setShort(( short ) 0), ( short ) 0x3F80);\n+        assertEquals(bf_single.setShort(( short ) 0), ( short ) 0x4000);\n+    }\n+\n+    /**\n+     * test the setBoolean() method\n+     */\n+\n+    public void testSetBoolean()\n+    {\n+        assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));\n+        assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));\n+        assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));\n+        assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));\n+    }\n+\n+    /**\n+     * test the setShortBoolean() method\n+     */\n+\n+    public void testSetShortBoolean()\n+    {\n+        assertEquals(bf_multi.setShort(( short ) 0),\n+                     bf_multi.setShortBoolean(( short ) 0, true));\n+        assertEquals(bf_single.setShort(( short ) 0),\n+                     bf_single.setShortBoolean(( short ) 0, true));\n+        assertEquals(bf_multi.clearShort(( short ) -1),\n+                     bf_multi.setShortBoolean(( short ) -1, false));\n+        assertEquals(bf_single.clearShort(( short ) -1),\n+                     bf_single.setShortBoolean(( short ) -1, false));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/util/UtilTestSuite.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Test suite for the Util package.\n+ *\n+ * @author <a href=\"mailto:bayard@apache.org\">Henri Yandell</a>\n+ * @version $Id: UtilTestSuite.java,v 1.1 2002/12/18 02:50:36 bayard Exp $\n+ */\n+public class UtilTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public UtilTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Util Tests\");\n+        suite.addTest(BitFieldTest.suite());\n+        return suite;\n+    }\n+}", "timestamp": 1040179836, "metainfo": ""}