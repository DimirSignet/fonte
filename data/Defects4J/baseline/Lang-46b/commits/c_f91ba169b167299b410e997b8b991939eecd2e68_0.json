{"sha": "f91ba169b167299b410e997b8b991939eecd2e68", "log": "Rename Tokenizer to StrTokenizer and move to text subpackage   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Tokenizes a string based based on delimiters (separators)\n+ * and supporting quoting and ignored character concepts.\n+ * <p>\n+ * This class can split a String into many smaller strings.\n+ * It aims to do a similar job to java util StringTokenizer, however it offers\n+ * much more control and flexibility. By default, it is setup like StringTokenizer.\n+ * <p>\n+ * The input String is split into a number of <i>tokens</i>.\n+ * Each token is separated from the next String by a <i>delimiter</i>.\n+ * One or more delimiter characters must be specified.\n+ * <p>\n+ * The processing then strips all the <i>ignored</i> characters from each side of the token.\n+ * The token may also have <i>quotes</i> to mark an area not to be stripped or tokenized.\n+ * Empty tokens may be removed or returned as null.\n+ * This example is based on the CSV tokenizer.\n+ * <pre>\n+ * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \"a, b , c\"    - Three tokens \"a\",\"b\",\"c\"   (ignored space characters stripped)\n+ * \"a, \" b \", c\" - Three tokens \"a\",\" b \",\"c\" (quoted text untouched)\n+ * </pre>\n+ * <p>\n+ *\n+ * This tokenizer has the following properties and options:\n+ *\n+ * <table>\n+ *  <tr>\n+ *   <th>Property</th><th>Type</th><th>Default</th>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n+ *  </tr>\n+ * </table>\n+ *\n+ * @author Matthew Inger\n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @since 2.1\n+ * @version $Id: StrTokenizer.java,v 1.1 2004/10/06 22:29:24 scolebourne Exp $\n+ */\n+public class StrTokenizer implements ListIterator, Cloneable {\n+\n+    /**\n+     * A Matcher which matches the comma character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher COMMA_MATCHER = new CharMatcher(',');\n+    /**\n+     * A Matcher which matches the tab character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher TAB_MATCHER = new CharMatcher('\\t');\n+    /**\n+     * A Matcher which matches the space character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher SPACE_MATCHER = new CharMatcher(' ');\n+    /**\n+     * A Matcher which matches the same characters as StringTokenizer,\n+     * namely space, tab, newline, formfeed.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher SPLIT_MATCHER = createCharSetMatcher(\" \\t\\n\\r\\f\");\n+    /**\n+     * A Matcher which matches the double quote character.\n+     * Best used for <code>quote</code>.\n+     */\n+    public static final Matcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n+    /**\n+     * A Matcher which matches the double quote character.\n+     * Best used for <code>quote</code>.\n+     */\n+    public static final Matcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n+    /**\n+     * A Matcher which matches the String trim() whitespace characters.\n+     * Best used for <code>ignored</code>.\n+     */\n+    public static final Matcher TRIM_MATCHER = new TrimMatcher();\n+    /**\n+     * A Matcher that matches no characters. Don't use this for delimiters!\n+     * Best used for <code>ignored</code>.\n+     */\n+    public static final Matcher NONE_MATCHER = new NoMatcher();\n+    \n+    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n+    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n+    static {\n+        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(COMMA_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+\n+        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(TAB_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+    }\n+\n+    /** The text to work on */\n+    private char chars[];\n+    /** The input text, null if char[] input */\n+    private String text;\n+    /** The parsed tokens */\n+    private String tokens[];\n+    /** The current iteration position */\n+    private int tokenPos;\n+\n+    /** The delimiter matcher */\n+    private Matcher delim = SPLIT_MATCHER;\n+    /** The quote matcher */\n+    private Matcher quote = NONE_MATCHER;\n+    /** The ignored matcher */\n+    private Matcher ignored = NONE_MATCHER;\n+    /** Whether to return empty tokens as null */\n+    private boolean emptyAsNull = false;\n+    /** Whether to ignore empty tokens */\n+    private boolean ignoreEmptyTokens = true;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates a matcher from a set of characters.\n+     * \n+     * @param chars  the characters to match, must not be null\n+     * @throws IllegalArgumentException if the character set is null or empty\n+     */\n+    public static Matcher createCharSetMatcher(char[] chars) {\n+        if (chars == null || chars.length == 0) {\n+            throw new IllegalArgumentException(\"Characters must not be null or empty\");\n+        }\n+        if (chars.length == 1) {\n+            return new CharMatcher(chars[0]);\n+        }\n+        return new CharSetMatcher(chars);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string representing a set of characters.\n+     * \n+     * @param chars  the characters to match, must not be null\n+     * @throws IllegalArgumentException if the character set is null or empty\n+     */\n+    public static Matcher createCharSetMatcher(String chars) {\n+        if (chars == null || chars.length() == 0) {\n+            throw new IllegalArgumentException(\"Characters must not be null or empty\");\n+        }\n+        if (chars.length() == 1) {\n+            return new CharMatcher(chars.charAt(0));\n+        }\n+        return new CharSetMatcher(chars.toCharArray());\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a character.\n+     * \n+     * @param ch  the character to match, must not be null\n+     */\n+    public static Matcher createCharMatcher(char ch) {\n+        return new CharMatcher(ch);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string.\n+     * \n+     * @param str  the string to match, must not be null\n+     * @throws IllegalArgumentException if the string is null or empty\n+     */\n+    public static Matcher createStringMatcher(String str) {\n+        if (str == null || str.length() == 0) {\n+            throw new IllegalArgumentException(\"String must not be null or empty\");\n+        }\n+        return new StringMatcher(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings.\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     */\n+    public static StrTokenizer getCSVInstance() {\n+        return (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.\n+     * \n+     * @param input  the string to parse\n+     */\n+    public static StrTokenizer getCSVInstance(String input) {\n+        StrTokenizer tok = (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.\n+     * \n+     * @param input  the text to parse\n+     */\n+    public static StrTokenizer getCSVInstance(char[] input) {\n+        StrTokenizer tok = (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     */\n+    public static StrTokenizer getTSVInstance() {\n+        return (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings\n+     * initializing it with the given input.\n+     * \n+     * @param input  the string to parse\n+     */\n+    public static StrTokenizer getTSVInstance(String input) {\n+        StrTokenizer tok = (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings\n+     * initializing it with the given input.\n+     * \n+     * @param input  the text to parse\n+     */\n+    public static StrTokenizer getTSVInstance(char[] input) {\n+        StrTokenizer tok = (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer, but with no text to tokenize.\n+     * <p>\n+     * This constructor is normally used with {@link #reset(String)}.\n+     */\n+    public StrTokenizer() {\n+        super();\n+        this.text = \"\";\n+        this.chars = new char[0];\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed\n+     */\n+    public StrTokenizer(String input) {\n+        super();\n+        this.text = input;\n+        this.chars = input.toCharArray();  // no clone as toCharArray() clones\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public StrTokenizer(String input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter string.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter string\n+     */\n+    public StrTokenizer(String input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(String input, Matcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(String input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     * \n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     * @param quote  the field quoted string matcher\n+     */\n+    public StrTokenizer(String input, Matcher delim, Matcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     */\n+    public StrTokenizer(char[] input) {\n+        super();\n+        this.text = null;\n+        this.chars = (char[]) input.clone();\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified character.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     * @param delim the field delimiter character\n+     */\n+    public StrTokenizer(char[] input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified string.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     * @param delim the field delimiter string\n+     */\n+    public StrTokenizer(char[] input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(char[] input, Matcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, Matcher delim, Matcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    // API\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of tokens found in the String.\n+     * \n+     * @return the number of matched tokens\n+     */\n+    public int size() {\n+        tokenize();\n+        return tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token from the String.\n+     * \n+     * @return the next sequential token, or null when no more tokens are found\n+     */\n+    public String nextToken() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets the previous token from the String.\n+     * \n+     * @return the previous sequential token, or null when no more tokens are found\n+     */\n+    public String previousToken() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list.\n+     * \n+     * @return the tokens as a String array\n+     */\n+    public String[] getAllTokens() {\n+        tokenize();\n+        return (String[]) tokens.clone();\n+    }\n+\n+    /**\n+     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n+     * <p>\n+     * This method allows the same tokenizer to be reused for the same String.\n+     */\n+    public void reset() {\n+        tokenPos = 0;\n+        tokens = null;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     * \n+     * @param input  the new string to tokenize\n+     */\n+    public void reset(String input) {\n+        reset();\n+        this.text = input;\n+        chars = input.toCharArray();  // no clone as toCharArray() clones\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     * \n+     * @param input  the new character array to tokenize, cloned\n+     */\n+    public void reset(char [] input) {\n+        reset();\n+        this.text = null;\n+        chars = (char[]) input.clone();\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more tokens.\n+     * \n+     * @return true if there are more tokens\n+     */\n+    public boolean hasNext() {\n+        tokenize();\n+        return (tokenPos < tokens.length);\n+    }\n+\n+    /**\n+     * Gets the next token. This method is equivalent to {@link #nextToken()}.\n+     * \n+     * @return the next String token\n+     */\n+    public Object next() {\n+        return nextToken();\n+    }\n+\n+    /**\n+     * Gets the index of the next token to return.\n+     * \n+     * @return the next token index\n+     */\n+    public int nextIndex() {\n+        return tokenPos;\n+    }\n+\n+    /**\n+     * Checks whether there are any previous tokens that can be iterated to.\n+     * \n+     * @return true if there are previous tokens\n+     */\n+    public boolean hasPrevious() {\n+        tokenize();\n+        return (tokenPos > 0);\n+    }\n+\n+    /**\n+     * Gets the token previous to the last returned token.\n+     * \n+     * @return the previous token\n+     */\n+    public Object previous() {\n+        return previousToken();\n+    }\n+\n+    /**\n+     * Gets the index of the previous token.\n+     * \n+     * @return the previous token index\n+     */\n+    public int previousIndex() {\n+        return (tokenPos - 1);\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void set(Object obj) {\n+        throw new UnsupportedOperationException(\"set() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(Object obj) {\n+        throw new UnsupportedOperationException(\"add() is unsupported\");\n+    }\n+\n+    // Implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Performs the tokenization if it hasn't already been done.\n+     */\n+    private void tokenize() {\n+        if (tokens == null) {\n+            this.tokens = readTokens();\n+        }\n+    }\n+\n+    /**\n+     * Read all the tokens.\n+     */\n+    private String[] readTokens() {\n+        int len = chars.length;\n+        char cbuf[] = new char[len];\n+        StringBuffer token = new StringBuffer();\n+        int start = 0;\n+        List tokens = new ArrayList();\n+        String tok = null;\n+\n+        // Keep going until we run out of characters\n+        while (start < len) {\n+            // read the next token\n+            start = readNextToken(start, cbuf, token);\n+            tok = token.toString();\n+\n+            // Add the token, following the rules\n+            // in this object\n+            addToken(tokens, tok);\n+\n+            // Reset the string buffer to zero length\n+            token.setLength(0);\n+\n+            // Handle the special case where the very last\n+            // character is a delimiter, in which case, we\n+            // need another empty string\n+            if (start == len && delim.isMatch(chars, len, start - 1) == 1) {\n+                // Add the token, following the rules\n+                // in this object\n+                addToken(tokens, \"\");\n+            }\n+        }\n+\n+        return (String[]) tokens.toArray(new String[tokens.size()]);\n+    }\n+\n+    /**\n+     * Adds a token to a list, paying attention to the parameters we've set.\n+     * \n+     * @param list  the list to add to\n+     * @param tok  the token to add\n+     */\n+    private void addToken(List list, String tok) {\n+        if (tok == null || tok.length() == 0) {\n+            if (ignoreEmptyTokens) {\n+                return;\n+            }\n+            if (emptyAsNull) {\n+                tok = null;\n+            }\n+        }\n+        list.add(tok);\n+    }\n+\n+    /**\n+     * Reads character by character through the String to get the next token.\n+     * \n+     * @param start  the first character of field\n+     * @param cbuf  a character buffer for temporary computations (so we\n+     *  don't have to keep recreating one)\n+     * @param token  a StringBuffer where the output token will go\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string\n+     */\n+    private int readNextToken(int start, char cbuf[], StringBuffer token) {\n+        token.setLength(0);\n+        int len = chars.length;\n+\n+        // Skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        int ignoreLen = 0;\n+        int delimLen = 0;\n+        int quoteLen = 0;\n+        while (start < len &&\n+                (ignoreLen = ignored.isMatch(chars, len, start)) >= 1 &&\n+                (delimLen = delim.isMatch(chars, len, start)) < 1 &&\n+                (quoteLen = quote.isMatch(chars, len, start)) < 1) {\n+            start += ignoreLen;\n+        }\n+        \n+        if (start >= len) {\n+            return start;\n+        } else {\n+            // lengths not setup\n+            if ((delimLen = delim.isMatch(chars, len, start)) >= 1) {\n+                start += delimLen;\n+            } else if ((quoteLen = quote.isMatch(chars, len, start)) >= 1) {\n+                start = readQuoted(start + quoteLen, cbuf, token);\n+            } else {\n+                start = readUnquoted(start, token);\n+            }\n+        }\n+//            \n+//            // lengths not setup\n+//            if ((delimLen = delim.isMatch(chars, start)) >= 1) {\n+//                start += delimLen;\n+//            } else if ((quoteLen = quote.isMatch(chars, start)) >= 1) {\n+//                start = readQuoted(start + quoteLen, cbuf, token);\n+//            } else {\n+//                start = readUnquoted(start, token);\n+//            }\n+//        } else {\n+//            if (delimLen > 0) {\n+//                start += delimLen;\n+//            } else if (quoteLen >= 1) {\n+//                start = readQuoted(start + quoteLen, cbuf, token);\n+//            } else {\n+//                start = readUnquoted(start, token);\n+//            }\n+//        }\n+\n+        return start;\n+    }\n+\n+    /**\n+     * Reads a quoted string token.\n+     * \n+     * @param start The first character of field, immediately after any quote\n+     * @param cbuf A character buffer for temporary computations (so we\n+     *             don't have to keep recreating one)\n+     * @param token A StringBuffer where the output token will go.\n+     * @return The starting position of the next field (the character\n+     *         immediately after the delimiter, or if end of string found,\n+     *         then the length of string.\n+     */\n+    private int readQuoted(int start, char cbuf[], StringBuffer token) {\n+        // Loop until we've found the end of the quoted\n+        // string or the end of the input\n+        int cbufcnt = 0;\n+        int pos = start;\n+        boolean done = false;\n+        boolean quoting = true;\n+        int len = chars.length;\n+        int delimLen = 0;\n+        int quoteLen = 0;\n+\n+        while (pos < len && !done) {\n+            // Quoting mode can occur several times throughout\n+            // a given string, so must switch between quoting\n+            // and non-quoting until we encounter a non-quoted\n+            // delimiter, or end of string, which indicates end\n+            // of token.\n+            if (quoting) {\n+                // If we've found a quote character, see if it's\n+                // followed by a second quote.  If so, then we need\n+                // to actually put the quote character into the token\n+                // rather than end the token.\n+                if ((quoteLen = quote.isMatch(chars, len, pos)) >= 1) {\n+                    if (pos + 1 < len && chars[pos + 1] == chars[pos]) {\n+                        cbuf[cbufcnt++] = chars[pos];\n+                        pos += 2;\n+                    } else {\n+                        // End the quoting if we get to this condition\n+                        quoting = false;\n+                        pos += quoteLen;\n+                    }\n+                } else {\n+                    // Otherwise, just put the character into the token\n+                    cbuf[cbufcnt++] = chars[pos];\n+                    pos++;\n+                }\n+            }\n+            // If we're not in quoting mode, if we encounter\n+            // a delimiter, the token is ended.  If we encounter\n+            // a quote, we start quoting mode, otherwise, just append\n+            // the character\n+            else {\n+                // If we're\n+                if ((delimLen = delim.isMatch(chars, len, pos)) >= 1) {\n+                    done = true;\n+                } else {\n+                    if ((quoteLen = quote.isMatch(chars, len, pos)) >= 1) {\n+                        quoting = true;\n+                        pos += quoteLen;\n+                    } else {\n+                        cbuf[cbufcnt++] = chars[pos];\n+                        pos++;\n+                    }\n+                }\n+            }\n+        }\n+\n+        token.append(cbuf, 0, cbufcnt);\n+\n+        return pos + delimLen;\n+    }\n+\n+    /**\n+     * Read an unquoted string until a delimiter is found.\n+     * \n+     * @param start  the first character of field\n+     * @param token  a StringBuffer where the output token will go.\n+     * @return  the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string.\n+     */\n+    private int readUnquoted(int start, StringBuffer token) {\n+        // Find delimiter or end of string\n+        char[] chars = this.chars;\n+        int len = chars.length;\n+        int pos = start;\n+        int delimLen = 0;\n+        while (pos < len && (delimLen = delim.isMatch(chars, len, pos)) < 1) {\n+            pos++;\n+        }\n+\n+        token.append(chars, start, Math.min(pos, len) - start);\n+\n+        return pos + delimLen;\n+    }\n+\n+    // Delimiter\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field delimiter matcher.\n+     * \n+     * @return the delimiter matcher in use\n+     */\n+    public Matcher getDelimiterMatcher() {\n+        return delim;\n+    }\n+\n+    /**\n+     * Sets the field delimiter matcher.\n+     * <p>\n+     * The delimitier is used to separate one token from another.\n+     * \n+     * @param delim  the delimiter matcher to use\n+     */\n+    public void setDelimiterMatcher(Matcher delim) {\n+        if (delim == null) {\n+            this.delim = NONE_MATCHER;\n+        } else {\n+            this.delim = delim;\n+        }\n+    }\n+\n+    /**\n+     * Sets the field delimiter character\n+     * \n+     * @param delim  the delimiter character to use\n+     */\n+    public void setDelimiterChar(char delim) {\n+        setDelimiterMatcher(new CharMatcher(delim));\n+    }\n+\n+    /**\n+     * Sets the field delimiter character\n+     * \n+     * @param delim  the delimiter character to use\n+     */\n+    public void setDelimiterString(String delim) {\n+        if (delim == null || delim.length() == 0) {\n+            setDelimiterMatcher(NONE_MATCHER);\n+        } else if (delim.length() == 1) {\n+            setDelimiterMatcher(new CharMatcher(delim.charAt(0)));\n+        } else {\n+            setDelimiterMatcher(new StringMatcher(delim));\n+        }\n+    }\n+\n+    // Quote\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the quote matcher currently in use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * The default value is '\"' (double quote).\n+     * \n+     * @return the quote matcher in use\n+     */\n+    public Matcher getQuoteMatcher() {\n+        return quote;\n+    }\n+\n+    /**\n+     * Set the quote matcher to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * \n+     * @param quote  the quote matcher to use, null ignored\n+     */\n+    public void setQuoteMatcher(Matcher quote) {\n+        if (quote != null) {\n+            this.quote = quote;\n+        }\n+    }\n+\n+    /**\n+     * Sets the quote character to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * \n+     * @param quote  the quote character to use\n+     */\n+    public void setQuoteChar(char quote) {\n+        setQuoteMatcher(new CharMatcher(quote));\n+    }\n+\n+    // Ignored\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ignored character matcher.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * The default value is space (' ') and all char control characters (32 and less).\n+     * \n+     * @return the ignored matcher in use\n+     */\n+    public Matcher getIgnoredMatcher() {\n+        return ignored;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to ignore.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * \n+     * @param ignored  the ignored matcher to use, null ignored\n+     */\n+    public void setIgnoredMatcher(Matcher ignored) {\n+        if (ignored != null) {\n+            this.ignored = ignored;\n+        }\n+    }\n+\n+    /**\n+     * Set the character to ignore.\n+     * <p>\n+     * This character is ignored when parsing the String, unless it is\n+     * within a quoted region.\n+     * \n+     * @param ignored  the ignored character to use\n+     */\n+    public void setIgnoredChar(char ignored) {\n+        setIgnoredMatcher(new CharMatcher(ignored));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently returns empty tokens as null.\n+     * The default for this property is false.\n+     * \n+     * @return true if empty tokens are returned as null\n+     */\n+    public boolean isEmptyTokenAsNull() {\n+        return emptyAsNull;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should return empty tokens as null.\n+     * The default for this property is false.\n+     * \n+     * @param emptyAsNull  whether empty tokens are returned as null\n+     */\n+    public void setEmptyTokenAsNull(boolean emptyAsNull) {\n+        this.emptyAsNull = emptyAsNull;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently ignores empty tokens.\n+     * The default for this property is false.\n+     * \n+     * @return true if empty tokens are not returned\n+     */\n+    public boolean isIgnoreEmptyTokens() {\n+        return ignoreEmptyTokens;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should ignore and not return empty tokens.\n+     * The default for this property is false.\n+     * \n+     * @param ignoreEmptyTokens  whether empty tokens are not returned\n+     */\n+    public void setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+        this.ignoreEmptyTokens = ignoreEmptyTokens;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     * \n+     * @return the string content being parsed\n+     */\n+    public String getContent() {\n+        if (text == null) {\n+            text = new String(chars);\n+        }\n+        return text;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create a new instance of this Tokenizer.\n+     * The new instance is reset so that it will be at the start of the token list.\n+     */\n+    public Object clone() {\n+        try {\n+            StrTokenizer cloned = (StrTokenizer) super.clone();\n+            // chars[] does not need additional clone as it is treated as immutable\n+            cloned.reset();\n+            return cloned;\n+            \n+        } catch (CloneNotSupportedException ex) {\n+            return null;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Defines the interface used to match a set of characters during tokenization.\n+     * Standard implementations of this interface are provided in the library.\n+     * These are accessed via the create*() factory methods on StrTokenizer.\n+     * If your application needs more unusual matching, implement this interface directly.\n+     */\n+    public static interface Matcher {\n+        /**\n+         * Returns true if the specified character position matches.\n+         * <p>\n+         * This method is called to check for a match.\n+         * The parameter <code>pos</code> represents the current position to be\n+         * checked in the string <code>text</code> (a character array which must\n+         * not be changed).\n+         * The text length is also provided for efficiency.\n+         * The API guarantees that <code>pos</code> is a valid index for <code>text</code>.\n+         * <p>\n+         * The matching code may check one character or many.\n+         * It must return zero for no match, or a positive number if a match was found.\n+         * The number indicates the number of characters that matched.\n+         * \n+         * @param text  the text content to match against, do not change\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position for the match, valid for text\n+         * @return the number of matching characters, zero for no match\n+         */\n+        int isMatch(char[] text, int textLen, int pos);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class CharSetMatcher implements Matcher {\n+        private char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a character array.\n+         * \n+         * @param chars  the characters to match, must not be null\n+         */\n+        CharSetMatcher(char chars[]) {\n+            super();\n+            this.chars = (char[]) chars.clone();\n+            Arrays.sort(this.chars);\n+        }\n+\n+        /**\n+         * Returns whether or not the given charatcer matches.\n+         * \n+         * @param text  the text content to match against\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] text, int textLen, int pos) {\n+            return (Arrays.binarySearch(chars, text[pos]) >= 0 ? 1 : 0);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a character for matching purposes.\n+     */\n+    static final class CharMatcher implements Matcher {\n+        private char ch;\n+\n+        /**\n+         * Constructor that creates a matcher that matches a single character.\n+         * \n+         * @param ch  the character to match\n+         */\n+        CharMatcher(char ch) {\n+            super();\n+            this.ch = ch;\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         * \n+         * @param text  the text content to match against\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] text, int textLen, int pos) {\n+            return (ch == text[pos] ? 1 : 0);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class StringMatcher implements Matcher {\n+        private char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a String.\n+         * \n+         * @param chars  the characters to match, must not be null\n+         */\n+        StringMatcher(String str) {\n+            super();\n+            chars = str.toCharArray();\n+        }\n+\n+        /**\n+         * Returns whether or not the given text matches the stored string.\n+         * \n+         * @param text  the text content to match against\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] text, int textLen, int pos) {\n+            int len = chars.length;\n+            if (pos + len >= textLen) {\n+                return 0;\n+            }\n+            for (int i = 0; i < chars.length; i++, pos++) {\n+                if (chars[i] != text[pos]) {\n+                    return 0;\n+                }\n+            }\n+            return len;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to match no characters.\n+     */\n+    static final class NoMatcher implements Matcher {\n+\n+        NoMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Always returns <code>false</code>.\n+         * \n+         * @param text  the text content to match against\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] text, int textLen, int pos) {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Class used to match whitespace as per trim().\n+     */\n+    static final class TrimMatcher implements Matcher {\n+\n+        TrimMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns whether or not the given charatcer matches.\n+         * \n+         * @param text  the text content to match against\n+         * @param textLen  the length of the text\n+         * @param pos  the starting position\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] text, int textLen, int pos) {\n+            return (text[pos] <= 32 ? 1 : 0);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * Unit test for Tokenizer.\n+ *\n+ * @author Matthew Inger\n+ */\n+public class StrTokenizerTest extends TestCase {\n+    \n+    /**\n+     * JUnit constructor.\n+     * @param name\n+     */\n+    public StrTokenizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrTokenizerTest.class);\n+        suite.setName(\"TokenizerTest Tests\");\n+        return suite;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test1() {\n+\n+        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \"\",\n+            \"\",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test2() {\n+\n+        String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c \",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \" \",\n+            \" \",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test3() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \" c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            \" \",\n+            \" \",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test4() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test5() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            null,\n+            null,\n+            null,\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test6() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+//        tok.setTreatingEmptyAsNull(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \" c\",\n+            \"d;\\\"e\",\n+            \"f\",\n+            null,\n+            null,\n+            null,\n+        };\n+\n+        int nextCount = 0;\n+        while (tok.hasNext()) {\n+            tok.next();\n+            nextCount++;\n+        }\n+\n+        int prevCount = 0;\n+        while (tok.hasPrevious()) {\n+            tok.previous();\n+            prevCount++;\n+        }\n+\n+        assertTrue(tokens.length == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\"\n+                + \" using the 'hasNext' and 'next' methods\",\n+                nextCount == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\"\n+                + \" using the 'hasPrevious' and 'previous' methods\",\n+                prevCount == expected.length);\n+\n+    }\n+\n+\n+    public void test7() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrTokenizer.SPACE_MATCHER);\n+        tok.setQuoteMatcher(StrTokenizer.DOUBLE_QUOTE_MATCHER);\n+        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"\",\n+            \"\",\n+            \"b\",\n+            \"c\",\n+            \"d e\",\n+            \"f\",\n+            \"\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+\n+    public void test8() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrTokenizer.SPACE_MATCHER);\n+        tok.setQuoteMatcher(StrTokenizer.DOUBLE_QUOTE_MATCHER);\n+        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens [] = tok.getAllTokens();\n+\n+        String expected[] = new String[]\n+        {\n+            \"a\",\n+            \"b\",\n+            \"c\",\n+            \"d e\",\n+            \"f\",\n+        };\n+\n+        assertTrue(tokens.length == expected.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i]\n+                    + \"' but was expected to be '\" + expected[i]\n+                    + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void testBasic1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic2() {\n+        String input = \"a \\nb\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic3() {\n+        String input = \"a \\nb\\u0001\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\u0001\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic4() {\n+        String input = \"a \\\"b\\\" c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\\\"b\\\"\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicQuoted1() {\n+        String input = \"a \\\"b\\\" c\";\n+        StrTokenizer tok = new StrTokenizer(input, ' ', '\"');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicDelim1() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicDelim2() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ',');\n+        assertEquals(\"a:b:c\", tok.next());\n+    }\n+    \n+    public void testBasicEmpty1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicEmpty2() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testGetContent() {\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertSame(input, tok.getContent());\n+        \n+        tok = new StrTokenizer(input.toCharArray());\n+        assertEquals(input, tok.getContent());\n+    }\n+\n+    public void testReset() {\n+        String input = \"a b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        tok.reset();\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        tok.reset(\"d e\");\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(\"e\", tok.next());\n+        tok.reset(\"f g\".toCharArray());\n+        assertEquals(\"f\", tok.next());\n+        assertEquals(\"g\", tok.next());\n+    }\n+    \n+    public void testMatcher() {\n+        assertEquals(1, StrTokenizer.SPACE_MATCHER.isMatch(new char[] {' '}, 1, 0));\n+        assertEquals(0, StrTokenizer.SPACE_MATCHER.isMatch(new char[] {'\\n'}, 1, 0));\n+        assertEquals(0, StrTokenizer.SPACE_MATCHER.isMatch(new char[] {'\\u0001'}, 1, 0));\n+        \n+        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[] {' '}, 1, 0));\n+        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[] {'\\n'}, 1, 0));\n+        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[] {'\\u0001'}, 1, 0));\n+        \n+        assertEquals(1, StrTokenizer.SPLIT_MATCHER.isMatch(new char[] {' '}, 1, 0));\n+        assertEquals(1, StrTokenizer.SPLIT_MATCHER.isMatch(new char[] {'\\n'}, 1, 0));\n+        assertEquals(0, StrTokenizer.SPLIT_MATCHER.isMatch(new char[] {'\\u0001'}, 1, 0));\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n  * Test suite for the Text package.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: TextTestSuite.java,v 1.1 2004/09/05 00:56:31 bayard Exp $\n+ * @version $Id: TextTestSuite.java,v 1.2 2004/10/06 22:29:24 scolebourne Exp $\n  */\n public class TextTestSuite extends TestCase {\n     \n         TestSuite suite = new TestSuite();\n         suite.setName(\"Commons-Lang-Text Tests\");\n         suite.addTest(InterpolationTest.suite());\n+        suite.addTest(StrTokenizerTest.suite());\n         return suite;\n     }\n+\n }", "timestamp": 1097101765, "metainfo": ""}