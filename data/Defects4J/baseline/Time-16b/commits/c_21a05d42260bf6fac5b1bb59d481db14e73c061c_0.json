{"sha": "21a05d42260bf6fac5b1bb59d481db14e73c061c", "log": "Remove withXxx methods from ReadableInstant   ", "commit": "\n--- a/JodaTime/src/example/org/joda/example/time/Examples.java\n+++ b/JodaTime/src/example/org/joda/example/time/Examples.java\n         System.out.println(\"ISO string version:    in.toString():            \" + in.toString());\n         System.out.println(\"No chronology:         in.getChronology():       \" + in.getChronology());\n         System.out.println(\"No time zone:          in.getDateTimeZone():     \" + in.getZone());\n+        System.out.println(\"Change millis:         in.withMillis(0):         \" + in.withMillis(0L));\n         System.out.println(\"\");\n         System.out.println(\"Convert to DateTime:   in.toDateTime():          \" + in.toDateTime());\n         System.out.println(\"Convert to trusted:    in.toTrustedISODateTime():\" + in.toTrustedISODateTime());\n         System.out.println(\"Compare millisecond:   in.isEqual(in2):          \" + in.isEqual(in2));\n         System.out.println(\"Compare millisecond:   in.isAfter(in2):          \" + in.isAfter(in2));\n         System.out.println(\"Compare millisecond:   in.isBefore(in2):         \" + in.isBefore(in2));\n-        System.out.println(\"\");\n-        System.out.println(\"Change chrono IGNORED: in.withChronology(...):   \" + in.withChronology(null));\n-        System.out.println(\"Change zone IGNORED:   in.withZone(...):         \" + in.withZone(null));\n-        System.out.println(\"Change zone IGNORED:   in.withZoneRetainFields(...):\" + in.withZoneRetainFields(null));\n-        System.out.println(\"Change millis:         in.withMillis(0):         \" + in.withMillis(0L));\n     }\n }\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {\n-        return instant.withMillis(addTo(instant.getMillis(), scalar));\n+    public final Instant addTo(ReadableInstant instant, int scalar) {\n+        return new Instant(addTo(instant.getMillis(), scalar));\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n         super();\n     }\n \n+    // Accessors\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the time zone of the datetime from the chronology, or null if there\n      * isn't any chronology.\n         return (chrono != null ? chrono.getZone() : null);\n     }\n \n-    // Accessors\n-    //-----------------------------------------------------------------------\n     /**\n      * Get the value of the specified field.\n      * <p>\n      * For example:\n      * <pre>\n      * Instant dt = new Instant();\n-     * int gjYear = dt.get(ISOChronology.getInstance().year());\n+     * int gjYear = dt.get(GJChronology.getInstance().year());\n      * </pre>\n      * \n      * @param field  the DateTimeField subclass to use\n             throw new IllegalArgumentException(\"The DateTimeField must not be null\");\n         }\n         return field.get(getMillis());\n-    }\n-\n-    /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * millisecond instant.\n-     * <p>\n-     * This method is useful for finding the local time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London, the result\n-     * from this method with Europe/Paris would be 13:30.\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone, and does not change the\n-     * millisecond instant, with the effect that the field values usually change.\n-     * Immutable implementations may return <code>this</code> if appropriate.\n-     *\n-     * @param newDateTimeZone  the new time zone\n-     * @return a copy of this instant with a different time zone\n-     * @see #withZoneRetainFields\n-     */\n-    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {\n-        final Chronology originalChrono = getChronology();\n-        if (originalChrono == null) {\n-            // Without an original chronology, no new time zone can be\n-            // set. Call withMillis to allow subclass to decide if a clone\n-            // should be made or not.\n-            return withMillis(getMillis());\n-        }\n-        return withChronology(originalChrono.withZone(newDateTimeZone));\n-    }\n-\n-    /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * field values.\n-     * <p>\n-     * This method is useful for finding the millisecond time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n-     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone and the millisecond instant to keep\n-     * the field values the same.\n-     * Immutable implementations may return <code>this</code> if appropriate.\n-     *\n-     * @param newDateTimeZone  the new time zone\n-     * @return a copy of this instant with a different time zone\n-     * @see #withZone\n-     */\n-    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {\n-        final long originalMillis = getMillis();\n-        final Chronology originalChrono = getChronology();\n-        final DateTimeZone originalZone;\n-        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {\n-            // Without an original chronology or time zone, no new time zone\n-            // can be set. Call withMillis to allow subclass to decide if a\n-            // clone should be made or not.\n-            return withMillis(originalMillis);\n-        }\n-\n-        ReadableInstant newInstant = withChronology(originalChrono.withZone(newDateTimeZone));\n-        newDateTimeZone = newInstant.getZone();\n-\n-        if (newDateTimeZone == null || newDateTimeZone == originalZone) {\n-            // New time zone didn't stick or didn't change. Skip millis adjustment.\n-            return newInstant;\n-        }\n-\n-        long newMillis = originalMillis + originalZone.getOffset(originalMillis);\n-        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);\n-\n-        return newInstant.withMillis(newMillis);\n     }\n \n     // Conversion\n--- a/JodaTime/src/java/org/joda/time/DateOnly.java\n+++ b/JodaTime/src/java/org/joda/time/DateOnly.java\n import java.io.Serializable;\n \n import org.joda.time.chrono.ISOChronology;\n-// Import for @link support\n-import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.DateOnlyFieldProperty;\n \n  * <li>minimum value\n  * </ul>\n  * <p>\n- * DateOnly is thread-safe and immutable, provided that the Chronology is as\n- * well. All standard Chronology classes supplied are thread-safe and\n- * immutable.\n+ * DateOnly is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n  */\n public class DateOnly extends AbstractPartialInstant implements Serializable {\n \n-    static final long serialVersionUID = -5796551185494585279L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5796551185494585279L;\n \n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs an instance from an Object that represents a date.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * Constructs an instance from an Object that represents a date, using the\n      * specified chronology.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n               chronology);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets a copy of this instant with different millis.\n      * <p>\n      * The returned object will be a new instance of the same implementation type.\n      * Only the millis will change, the chronology is kept.\n+     * Time fields will be removed from the specified millis.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this instant with different millis\n      */\n-    public ReadableInstant withMillis(long newMillis) {\n+    public final DateOnly withMillis(long newMillis) {\n         newMillis = resetUnsupportedFields(newMillis);\n-        return newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology());\n-    }\n-    \n+        return (newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology()));\n+    }\n+\n     /**\n      * Gets a copy of this instant with a different chronology.\n      * <p>\n      * The returned object will be a new instance of the same implementation type.\n      * Only the chronology will change, the millis are kept.\n+     * The chronology will be converted to a UTC zone.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n      */\n-    public ReadableInstant withChronology(Chronology newChronology) {\n-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()\n-            : newChronology.withUTC();\n-        return newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology);\n-    }\n-\n+    public final DateOnly withChronology(Chronology newChronology) {\n+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();\n+        return (newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the lower limiting field, dayOfYear.\n      *\n      */\n     protected final void setChronology(Chronology chronology) {\n     }\n-    \n+\n }\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n \n import java.io.Serializable;\n \n-// Import for @link support\n-import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.DateTimeFieldProperty;\n \n  * </ul>\n  *\n  * <p>\n- * DateTime is thread-safe and immutable, provided that the Chronology is as\n- * well. All standard Chronology classes supplied are thread-safe and\n- * immutable.\n+ * DateTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n  *\n  * @author Stephen Colebourne\n  * @author Kandarp Shah\n public class DateTime extends AbstractDateTime\n         implements ReadableDateTime, Serializable {\n     \n-    static final long serialVersionUID = -5171125899451703815L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5171125899451703815L;\n \n     // Constructors\n     //-----------------------------------------------------------------------\n      * If the object contains no chronology, <code>ISOChronology</code>\n      * in the default time zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * If the object contains no chronology, <code>ISOChronology</code> is used.\n      * If the specified time zone is null, the default zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * <p>\n      * If the chronology is null, ISOChronology in the default time zone is used.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this instant with different millis\n      */\n-    public ReadableInstant withMillis(long newMillis) {\n-        return newMillis == getMillis() ? this : new DateTime(newMillis, getChronology());\n-    }\n-    \n+    public final DateTime withMillis(long newMillis) {\n+        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n+    }\n+\n     /**\n      * Gets a copy of this instant with a different chronology.\n      * <p>\n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n      */\n-    public ReadableInstant withChronology(Chronology newChronology) {\n-        return newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology);\n-    }\n-    \n+    public final DateTime withChronology(Chronology newChronology) {\n+        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with a different time zone, preserving the\n+     * millisecond instant.\n+     * <p>\n+     * This method is useful for finding the local time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London, the result\n+     * from this method with Europe/Paris would be 13:30.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method changes alters the time zone, and does not change the\n+     * millisecond instant, with the effect that the field values usually change.\n+     * Immutable implementations may return <code>this</code> if appropriate.\n+     *\n+     * @param newDateTimeZone  the new time zone\n+     * @return a copy of this instant with a different time zone\n+     * @see #withZoneRetainFields\n+     */\n+    public final DateTime withZone(DateTimeZone newDateTimeZone) {\n+        return withChronology(getChronology().withZone(newDateTimeZone));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with a different time zone, preserving the\n+     * field values.\n+     * <p>\n+     * This method is useful for finding the millisecond time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method changes alters the time zone and the millisecond instant to keep\n+     * the field values the same.\n+     * Immutable implementations may return <code>this</code> if appropriate.\n+     *\n+     * @param newDateTimeZone  the new time zone\n+     * @return a copy of this instant with a different time zone\n+     * @see #withZone\n+     */\n+    public final DateTime withZoneRetainFields(DateTimeZone newDateTimeZone) {\n+        final long originalMillis = getMillis();\n+        final Chronology originalChrono = getChronology();\n+        final DateTimeZone originalZone;\n+        if (originalChrono == null || (originalZone = originalChrono.getZone()) == null) {\n+            // Without an original chronology or time zone, no new time zone\n+            // can be set. Call withMillis to allow subclass to decide if a\n+            // clone should be made or not.\n+            return withMillis(originalMillis);\n+        }\n+\n+        DateTime newInstant = withChronology(originalChrono.withZone(newDateTimeZone));\n+        newDateTimeZone = newInstant.getZone();\n+\n+        if (newDateTimeZone == null || newDateTimeZone == originalZone) {\n+            // New time zone didn't stick or didn't change. Skip millis adjustment.\n+            return newInstant;\n+        }\n+\n+        long newMillis = originalMillis + originalZone.getOffset(originalMillis);\n+        newMillis -= newDateTimeZone.getOffsetFromLocal(newMillis);\n+\n+        return newInstant.withMillis(newMillis);\n+    }\n+\n     // Date properties\n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n public final class Instant extends AbstractInstant\n         implements ReadableInstant, Serializable {\n \n-    static final long serialVersionUID = 3299096530934209741L;\n+    /** Serialization lock */\n+\tprivate static final long serialVersionUID = 3299096530934209741L;\n \n     /** The millis from 1970-01-01T00:00:00Z */\n     private final long iMillis;\n         iMillis = converter.getInstantMillis(instant);\n     }\n \n-    /**\n-     * Gets a copy of this instant with different millis, as an Instant.\n-     * <p>\n-     * The returned object will be either be a new Instant or\n-     * <code>this</code>.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be either be a new Instant or <code>this</code>.\n      *\n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this instant with different millis\n      */\n-    public ReadableInstant withMillis(long newMillis) {\n+    public Instant withMillis(long newMillis) {\n         return newMillis == iMillis ? this : new Instant(newMillis);\n     }\n-    \n-    /**\n-     * Since Instant does not support chronologies, this method always returns\n-     * <code>this</code>.\n-     *\n-     * @param newChronology  ignored\n-     * @return this\n-     */\n-    public ReadableInstant withChronology(Chronology newChronology) {\n-        return this;\n-    }\n-    \n-    /**\n-     * Since Instant does not support time zones, this method always returns\n-     * <code>this</code>.\n-     *\n-     * @param newDateTimeZone  ignored\n-     * @return this\n-     */\n-    public ReadableInstant withZone(DateTimeZone newDateTimeZone) {\n-        return this;\n-    }\n-\n-    /**\n-     * Since Instant does not support time zones, this method always returns\n-     * <code>this</code>.\n-     *\n-     * @param newDateTimeZone  ignored\n-     * @return this\n-     */\n-    public ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone) {\n-        return this;\n-    }\n \n     // Accessors\n     //-----------------------------------------------------------------------\n      * \n      * @return the number of milliseconds since 1970-01-01T00:00:00Z\n      */\n-    public final long getMillis() {\n+    public long getMillis() {\n         return iMillis;\n     }\n \n      * @param base ignored\n      * @return the number of milliseconds since 1970-01-01T00:00:00Z\n      */\n-    public final long getMillis(ReadableInstant base) {\n+    public long getMillis(ReadableInstant base) {\n         return iMillis;\n     }\n \n      * @param zone ignored\n      * @return the number of milliseconds since 1970-01-01T00:00:00Z\n      */\n-    public final long getMillis(ReadableInstant base, DateTimeZone zone) {\n+    public long getMillis(ReadableInstant base, DateTimeZone zone) {\n         return iMillis;\n     }\n \n      * \n      * @return null\n      */\n-    public final Chronology getChronology() {\n+    public Chronology getChronology() {\n         return null;\n     }\n \n      * \n      * @return ISO8601 date formatted string\n      */\n-    public final String toString() {\n+    public String toString() {\n         return ISODateTimeFormat.getInstanceUTC().dateTime().print(this);\n     }\n \n--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java\n      * @throws IllegalArgumentException if the instant is null\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n-    ReadableInstant addTo(ReadableInstant instant, int scalar);\n+    Instant addTo(ReadableInstant instant, int scalar);\n \n     /**\n      * Adds this duration into the given mutable instant.\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n      * @throws IllegalArgumentException if the field is null\n      */\n     int get(DateTimeField field);\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets a copy of this instant with different millis, preserving the\n-     * chronology.\n-     * <p>\n-     * The returned object will be a new instance of the same implementation\n-     * type. Only the millis will change, the chronology and time zone are\n-     * kept. Immutable implementations may return <code>this</code> if\n-     * appropriate.\n-     *\n-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n-     * @return a copy of this instant with different millis\n-     */\n-    ReadableInstant withMillis(long newMillis);\n-    \n-    /**\n-     * Gets a copy of this instant with a different chronology, preserving the\n-     * millisecond instant.\n-     * <p>\n-     * The returned object will be a new instance of the same implementation\n-     * type. Only the chronology will change, the millis are kept. Immutable\n-     * implementations may return <code>this</code> if appropriate.\n-     *\n-     * @param newChronology  the new chronology\n-     * @return a copy of this instant with a different chronology\n-     */\n-    ReadableInstant withChronology(Chronology newChronology);\n-    \n-    /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * millisecond instant.\n-     * <p>\n-     * This method is useful for finding the local time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London, the result\n-     * from this method with Europe/Paris would be 13:30.\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone, and does not change the\n-     * millisecond instant, with the effect that the field values usually change.\n-     * Immutable implementations may return <code>this</code> if appropriate.\n-     *\n-     * @param newDateTimeZone  the new time zone\n-     * @return a copy of this instant with a different time zone\n-     * @see #withZoneRetainFields\n-     */\n-    ReadableInstant withZone(DateTimeZone newDateTimeZone);\n-\n-    /**\n-     * Gets a copy of this instant with a different time zone, preserving the\n-     * field values.\n-     * <p>\n-     * This method is useful for finding the millisecond time in another timezone.\n-     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n-     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n-     * <p>\n-     * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone and the millisecond instant to keep\n-     * the field values the same.\n-     * Immutable implementations may return <code>this</code> if appropriate.\n-     *\n-     * @param newDateTimeZone  the new time zone\n-     * @return a copy of this instant with a different time zone\n-     * @see #withZone\n-     */\n-    ReadableInstant withZoneRetainFields(DateTimeZone newDateTimeZone);\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return the value as an <code>Instant</code> object\n      */\n     Instant toInstant();\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n      * @throws IllegalArgumentException if the instant is null\n      */\n     boolean isBefore(ReadableInstant readableInstant);\n-    \n+\n     /**\n      * Is the millisecond value equal to the millisecond passed in.\n      *\n      * @throws IllegalArgumentException if the instant is null\n      */\n     boolean isEqual(ReadableInstant readableInstant);\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the value as a String in a recognisable ISO8601 format.\n      * @return the value as an ISO8601 string\n      */\n     String toString();\n-    \n+\n }\n--- a/JodaTime/src/java/org/joda/time/TimeOnly.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java\n import java.io.Serializable;\n \n import org.joda.time.chrono.ISOChronology;\n-// Import for @link support\n-import org.joda.time.convert.ConverterManager;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.property.TimeOnlyFieldProperty;\n \n  */\n public class TimeOnly extends AbstractPartialInstant implements Serializable {\n \n-    static final long serialVersionUID = -8414446947366046476L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -8414446947366046476L;\n \n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n      * Constructs an instance from an Object that represents a time.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * Constructs an instance from an Object that represents a time, using the\n      * specified chronology.\n      * <p>\n-     * The recognised object types are defined in {@link ConverterManager} and\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n      * include ReadableInstant, String, Calendar and Date.\n      *\n      * @param instant  the datetime object, must not be null\n      * <p>\n      * The returned object will be a new instance of the same implementation type.\n      * Only the millis will change, the chronology is kept.\n+     * Date fields will be removed from the millis.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n      * @return a copy of this instant with different millis\n      */\n-    public ReadableInstant withMillis(long newMillis) {\n+    public final TimeOnly withMillis(long newMillis) {\n         newMillis = resetUnsupportedFields(newMillis);\n-        return newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology());\n+        return (newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology()));\n     }\n     \n     /**\n      * <p>\n      * The returned object will be a new instance of the same implementation type.\n      * Only the chronology will change, the millis are kept.\n+     * The chronology will be converted to a UTC zone.\n      * Immutable subclasses may return <code>this</code> if appropriate.\n      *\n      * @param newChronology  the new chronology\n      * @return a copy of this instant with a different chronology\n      */\n-    public ReadableInstant withChronology(Chronology newChronology) {\n-        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()\n-            : newChronology.withUTC();\n-        return newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology);\n+    public final TimeOnly withChronology(Chronology newChronology) {\n+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC() : newChronology.withUTC();\n+        return (newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology));\n     }\n \n     /**", "timestamp": 1082071014, "metainfo": ""}