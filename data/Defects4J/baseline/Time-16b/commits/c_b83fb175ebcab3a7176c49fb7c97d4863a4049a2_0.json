{"sha": "b83fb175ebcab3a7176c49fb7c97d4863a4049a2", "log": "Add isMatch() method to Partial   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Partial.java\n+++ b/JodaTime/src/java/org/joda/time/Partial.java\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * Partial is an immutable partial datetime where the fields supported\n- * are defined by the constructor.\n+ * Partial is an immutable partial datetime supporting any set of datetime fields.\n+ * <p>\n+ * A Partial instance can be used to hold any combination of fields.\n+ * The instance does not contain a time zone, so any datetime is local.\n+ * <p>\n+ * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n+ * This method compares each field on this partial with those of the instant\n+ * and determines if the partial matches the instant.\n+ * Given this definition, an empty Partial instance represents any datetime\n+ * and always matches.\n  * <p>\n  * Calculations on Partial are performed using a {@link Chronology}.\n  * This chronology is set to be in the UTC time zone for all calculations.\n      *\n      * @param date  an date to check against, null means now\n      * @return true if this date is after the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     */\n-    public boolean isAfter(Partial date) {\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     */\n+    public boolean isAfter(ReadablePartial date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"Partial cannot be null\");\n         }\n      *\n      * @param date  an date to check against, null means now\n      * @return true if this date is before the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     */\n-    public boolean isBefore(Partial date) {\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     */\n+    public boolean isBefore(ReadablePartial date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"Partial cannot be null\");\n         }\n      *\n      * @param date  an date to check against, null means now\n      * @return true if this date is the same as the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     */\n-    public boolean isEqual(Partial date) {\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     */\n+    public boolean isEqual(ReadablePartial date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"Partial cannot be null\");\n         }\n         return compareTo(date) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this partial match the specified instant.\n+     * <p>\n+     * A match occurs when all the fields of this partial are the same as the\n+     * corresponding fields on the specified instant.\n+     *\n+     * @param instant  an instant to check against, null means now in default zone\n+     * @return true if this partial matches the specified instant\n+     */\n+    public boolean isMatch(ReadableInstant instant) {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        for (int i = 0; i < iTypes.length; i++) {\n+            int value = iTypes[i].getField(chrono).get(millis);\n+            if (value != iValues[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestPartial_Basics.suite());\n         suite.addTest(TestPartial_Constructors.suite());\n         suite.addTest(TestPartial_Properties.suite());\n+        suite.addTest(TestPartial_Match.suite());\n         \n         suite.addTest(TestAbstractPartial.suite());\n         suite.addTest(TestBasePartial.suite());\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestPartial_Match.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for Partial.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestPartial_Match extends TestCase {\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final int OFFSET = 1;\n+    private static final Chronology COPTIC_PARIS = Chronology.getCoptic(PARIS);\n+    private static final Chronology COPTIC_LONDON = Chronology.getCoptic(LONDON);\n+    private static final Chronology COPTIC_TOKYO = Chronology.getCoptic(TOKYO);\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology ISO_PARIS = Chronology.getISO(PARIS);\n+    private static final Chronology ISO_LONDON = Chronology.getISO(LONDON);\n+    private static final Chronology ISO_TOKYO = Chronology.getISO(TOKYO);\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n+    private static final Chronology BUDDHIST_PARIS = Chronology.getBuddhist(PARIS);\n+    private static final Chronology BUDDHIST_LONDON = Chronology.getBuddhist(LONDON);\n+    private static final Chronology BUDDHIST_TOKYO = Chronology.getBuddhist(TOKYO);\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    \n+    private long TEST_TIME_NOW =\n+            10L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 20L * DateTimeConstants.MILLIS_PER_MINUTE\n+            + 30L * DateTimeConstants.MILLIS_PER_SECOND\n+            + 40L;\n+            \n+    private long TEST_TIME1 =\n+        1L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 2L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 3L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 4L;\n+        \n+    private long TEST_TIME2 =\n+        1L * DateTimeConstants.MILLIS_PER_DAY\n+        + 5L * DateTimeConstants.MILLIS_PER_HOUR\n+        + 6L * DateTimeConstants.MILLIS_PER_MINUTE\n+        + 7L * DateTimeConstants.MILLIS_PER_SECOND\n+        + 8L;\n+        \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestPartial_Match.class);\n+    }\n+\n+    public TestPartial_Match(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        zone = DateTimeZone.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(zone);\n+        zone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsMatch() {\n+        // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday)\n+        Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2);\n+        DateTime instant = new DateTime(2005, 7, 5, 0, 0, 0, 0);\n+        assertEquals(true, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 7, 4, 0, 0, 0, 0);\n+        assertEquals(false, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 7, 6, 0, 0, 0, 0);\n+        assertEquals(false, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 7, 12, 0, 0, 0, 0);\n+        assertEquals(true, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 7, 19, 0, 0, 0, 0);\n+        assertEquals(true, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 7, 26, 0, 0, 0, 0);\n+        assertEquals(true, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 8, 2, 0, 0, 0, 0);\n+        assertEquals(false, test.isMatch(instant));\n+        \n+        instant = new DateTime(2006, 7, 5, 0, 0, 0, 0);\n+        assertEquals(false, test.isMatch(instant));\n+        \n+        instant = new DateTime(2005, 6, 5, 0, 0, 0, 0);\n+        assertEquals(false, test.isMatch(instant));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private Partial createYMDwPartial(Chronology chrono, int year, int month, int dow) {\n+        return new Partial(\n+            new DateTimeFieldType[] {\n+                    DateTimeFieldType.year(),\n+                    DateTimeFieldType.monthOfYear(),\n+                    DateTimeFieldType.dayOfWeek()},\n+            new int[] {year, month, dow},\n+            chrono);\n+    }\n+\n+}", "timestamp": 1121296394, "metainfo": ""}