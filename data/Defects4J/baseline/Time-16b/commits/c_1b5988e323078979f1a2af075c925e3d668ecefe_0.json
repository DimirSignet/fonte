{"sha": "1b5988e323078979f1a2af075c925e3d668ecefe", "log": "DateTimeFormat.forFields(List) method can't handle immutable [1877843]  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java\n package org.joda.time.format;\n \n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n      * </pre>\n      * * indiates that this is not an official ISO format and can be excluded\n      * by passing in <code>strictISO</code> as <code>true</code>.\n+     * <p>\n+     * This method can side effect the input collection of fields.\n+     * If the input collection is modifiable, then each field that was added to\n+     * the formatter will be removed from the collection, including any duplicates.\n+     * If the input collection is unmodifiable then no side effect occurs.\n+     * <p>\n+     * This side effect processing is useful if you need to know whether all\n+     * the fields were converted into the formatter or not. To achieve this,\n+     * pass in a modifiable list, and check that it is empty on exit.\n      *\n      * @param fields  the fields to get a formatter for, not null,\n-     *  updated by the method call, which removes those fields built in the formatter\n+     *  updated by the method call unless unmodifiable,\n+     *  removing those fields built in the formatter\n      * @param extended  true to use the extended format (with separators)\n      * @param strictISO  true to stick exactly to ISO8601, false to include additional formats\n      * @return a suitable formatter\n         if (fields == null || fields.size() == 0) {\n             throw new IllegalArgumentException(\"The fields must not be null or empty\");\n         }\n-        int inputSize = fields.size();\n+        Set workingFields = new HashSet(fields);\n+        int inputSize = workingFields.size();\n         boolean reducedPrec = false;\n         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n         // date\n-        if (fields.contains(DateTimeFieldType.monthOfYear())) {\n-            reducedPrec = dateByMonth(bld, fields, extended, strictISO);\n-        } else if (fields.contains(DateTimeFieldType.dayOfYear())) {\n-            reducedPrec = dateByOrdinal(bld, fields, extended, strictISO);\n-        } else if (fields.contains(DateTimeFieldType.weekOfWeekyear())) {\n-            reducedPrec = dateByWeek(bld, fields, extended, strictISO);\n-        } else if (fields.contains(DateTimeFieldType.dayOfMonth())) {\n-            reducedPrec = dateByMonth(bld, fields, extended, strictISO);\n-        } else if (fields.contains(DateTimeFieldType.dayOfWeek())) {\n-            reducedPrec = dateByWeek(bld, fields, extended, strictISO);\n-        } else if (fields.remove(DateTimeFieldType.year())) {\n+        if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\n+            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\n+            reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\n+            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\n+            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\n+            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.remove(DateTimeFieldType.year())) {\n             bld.append(yearElement());\n             reducedPrec = true;\n-        } else if (fields.remove(DateTimeFieldType.weekyear())) {\n+        } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\n             bld.append(weekyearElement());\n             reducedPrec = true;\n         }\n-        boolean datePresent = (fields.size() < inputSize);\n+        boolean datePresent = (workingFields.size() < inputSize);\n         \n         // time\n-        time(bld, fields, extended, strictISO, reducedPrec, datePresent);\n+        time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\n         \n         // result\n         if (bld.canBuildFormatter() == false) {\n             throw new IllegalArgumentException(\"No valid format for fields: \" + fields);\n+        }\n+        \n+        // side effect the input collection to indicate the processed fields\n+        // handling unmodifiable collections with no side effect\n+        try {\n+            fields.retainAll(workingFields);\n+        } catch (UnsupportedOperationException ex) {\n+            // ignore, so we can handle unmodifiable collections\n         }\n         return bld.toFormatter();\n     }\n--- a/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormat_Fields.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestISODateTimeFormat_Fields.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n \n import junit.framework.TestCase;\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testForFields_calBased_YMD_unmodifiable() {\n+        DateTimeFieldType[] fields = new DateTimeFieldType[] {\n+                DateTimeFieldType.year(),\n+                DateTimeFieldType.monthOfYear(),\n+                DateTimeFieldType.dayOfMonth(),\n+        };\n+        int[] values = new int[] {2005, 6, 25};\n+        List types = Collections.unmodifiableList(new ArrayList(Arrays.asList(fields)));\n+        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n+        assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n+        assertEquals(3, types.size());\n+        \n+        types = Arrays.asList(fields);\n+        f = ISODateTimeFormat.forFields(types, true, true);\n+        assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n+        assertEquals(3, types.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForFields_calBased_YMD_duplicates() {\n+        DateTimeFieldType[] fields = new DateTimeFieldType[] {\n+                DateTimeFieldType.year(),\n+                DateTimeFieldType.monthOfYear(),\n+                DateTimeFieldType.dayOfMonth(),\n+        };\n+        DateTimeFieldType[] dupFields = new DateTimeFieldType[] {\n+                DateTimeFieldType.year(),\n+                DateTimeFieldType.monthOfYear(),\n+                DateTimeFieldType.dayOfMonth(),\n+                DateTimeFieldType.monthOfYear(),\n+        };\n+        int[] values = new int[] {2005, 6, 25};\n+        List types = new ArrayList(Arrays.asList(dupFields));\n+        DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n+        assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n+        assertEquals(0, types.size());\n+        \n+        types = Arrays.asList(dupFields);\n+        f = ISODateTimeFormat.forFields(types, true, true);\n+        assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n+        assertEquals(4, types.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testForFields_calBased_Y() {\n         DateTimeFieldType[] fields = new DateTimeFieldType[] {\n                 DateTimeFieldType.year(),", "timestamp": 1205599260, "metainfo": ""}