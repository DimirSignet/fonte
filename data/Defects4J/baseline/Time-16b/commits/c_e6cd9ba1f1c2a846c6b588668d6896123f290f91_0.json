{"sha": "e6cd9ba1f1c2a846c6b588668d6896123f290f91", "log": "Rely on interface rather than redeclaration when adding Comparable to ReadablePartial interface for better backwards compatibility", "commit": "\n--- a/src/main/java/org/joda/time/ReadablePartial.java\n+++ b/src/main/java/org/joda/time/ReadablePartial.java\n  * Defines a partial time that does not support every datetime field, and is\n  * thus a local time.\n  * <p>\n- * A <code>ReadablePartial</code> supports a subset of those fields on the chronology.\n- * It cannot be compared to a <code>ReadableInstant</code>, as it does not fully\n+ * A {@code ReadablePartial} supports a subset of those fields on the chronology.\n+ * It cannot be compared to a {@code ReadableInstant}, as it does not fully\n  * specify an instant in time. The time it does specify is a local time, and does\n  * not include a time zone.\n  * <p>\n- * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>\n- * using the <code>toDateTime</code> method. This works by providing a full base\n+ * A {@code ReadablePartial} can be converted to a {@code ReadableInstant}\n+ * using the {@code toDateTime} method. This works by providing a full base\n  * instant that can be used to 'fill in the gaps' and specify a time zone.\n+ * <p>\n+ * {@code ReadablePartial} is {@code Comparable} from v2.0.\n+ * The comparison is based on the fields, compared in order, from largest to smallest.\n+ * The first field that is non-equal is used to determine the result.\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n     int hashCode();\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Compares this partial with another returning an integer\n-     * indicating the order.\n-     * <p>\n-     * The fields are compared in order, from largest to smallest.\n-     * The first field that is non-equal is used to determine the result.\n-     * Thus a year-hour partial will first be compared on the year, and then\n-     * on the hour.\n-     * <p>\n-     * The specified object must be a partial instance whose field types\n-     * match those of this partial. If the partial instance has different\n-     * fields then a {@code ClassCastException} is thrown.\n-     *\n-     * @param partial  an object to check against\n-     * @return negative if this is less, zero if equal, positive if greater\n-     * @throws ClassCastException if the partial is the wrong class\n-     *  or if it has field types that don't match\n-     * @throws NullPointerException if the partial is null\n-     * @since 2.0, previously on {@code AbstractPartial}\n-     */\n-    int compareTo(ReadablePartial partial);\n+//  This is commented out to improve backwards compatibility\n+//    /**\n+//     * Compares this partial with another returning an integer\n+//     * indicating the order.\n+//     * <p>\n+//     * The fields are compared in order, from largest to smallest.\n+//     * The first field that is non-equal is used to determine the result.\n+//     * Thus a year-hour partial will first be compared on the year, and then\n+//     * on the hour.\n+//     * <p>\n+//     * The specified object must be a partial instance whose field types\n+//     * match those of this partial. If the partial instance has different\n+//     * fields then a {@code ClassCastException} is thrown.\n+//     *\n+//     * @param partial  an object to check against\n+//     * @return negative if this is less, zero if equal, positive if greater\n+//     * @throws ClassCastException if the partial is the wrong class\n+//     *  or if it has field types that don't match\n+//     * @throws NullPointerException if the partial is null\n+//     * @since 2.0, previously on {@code AbstractPartial}\n+//     */\n+//    int compareTo(ReadablePartial partial);\n \n     //-----------------------------------------------------------------------\n     /**", "timestamp": 1306017011, "metainfo": ""}