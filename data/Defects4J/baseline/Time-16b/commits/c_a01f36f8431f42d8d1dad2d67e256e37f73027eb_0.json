{"sha": "a01f36f8431f42d8d1dad2d67e256e37f73027eb", "log": "Reset interval behaviour back to v1.2, except fixing a bug in overlaps() when passing in null  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n     /**\n      * Gets the overlap between this interval and another interval.\n      * <p>\n-     * This method returns the amount of the overlap, only if the\n-     * intervals do overlap.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. This method returns the amount of the overlap,\n+     * only if the intervals actually do overlap.\n      * If the intervals do not overlap, then null is returned.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n      * <p>\n      * The chronology of the returned interval is the same as that of\n      * this interval (the chronology of the interval parameter is not used).\n      * Gets the gap between this interval and another interval.\n      * The other interval can be either before or after this interval.\n      * <p>\n-     * This method returns the amount of the gap only if the\n-     * intervals do actually have a gap between them.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval has a gap to another interval if there is a non-zero\n+     * duration between them. This method returns the amount of the gap only\n+     * if the intervals do actually have a gap between them.\n      * If the intervals overlap or abut, then null is returned.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n      * <p>\n      * The chronology of the returned interval is the same as that of\n      * this interval (the chronology of the interval parameter is not used).\n     /**\n      * Does this interval abut with the interval specified.\n      * <p>\n-     * An interval abuts if it starts immediately after, or\n-     * ends immediately before this interval without overlap.\n-     * Thus this method returns true if\n-     * <code>thisStart == otherEnd || thisEnd == otherStart </code>.\n-     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval abuts if it starts immediately after, or ends immediately\n+     * before this interval without overlap.\n      * A zero duration interval abuts with itself.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n      * <p>\n      * For example:\n      * <pre>\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Does this time interval contain or equal the specified instant.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The instant is contained if it is at the start or middle of this interval\n-     * but not at the end.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and only contains the instant equal to its start and end.\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) contains 10:00  = false (equals end)\n      * [09:00 to 10:00) contains 10:01  = false (after end)\n      * \n-     * [14:00 to 14:00) contains 14:00  = true (equal)\n+     * [14:00 to 14:00) contains 14:00  = false (zero duration contains nothing)\n      * </pre>\n-     * Passng in a <code>null</code> parameter will have the same effect as\n-     * calling {@link #containsNow()}.\n-     * \n+     *\n      * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n      */\n     boolean contains(ReadableInstant instant);\n     \n     /**\n-     * Does this time interval contain or equal the specified time interval.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The other interval is contained if this interval wholly contains, starts,\n-     * finishes or equals it.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and will contain itself (because it is equal to itself). It will also\n-     * be contained by a larger interval at the start, middle but not the end.\n+     * Does this time interval contain the specified time interval.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. The other interval is contained if this interval\n+     * wholly contains, starts, finishes or equals it.\n+     * A zero duration interval cannot contain anything.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The <code>contains</code> method is not related to these states.\n+     * In particular, a zero duration interval is contained at the start of\n+     * a larger interval, but does not overlap (it abuts instead).\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n      * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n      * \n-     * [14:00 to 14:00) contains [14:00 to 14:00)  = true (equal)\n+     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n      * </pre>\n-     * Passng in a <code>null</code> parameter will have the same effect as\n-     * calling {@link #containsNow()}.\n-     * \n-     * @param interval  the time interval to compare to, null means a zero length interval now\n+     *\n+     * @param interval  the time interval to compare to, null means a zero duration interval now\n      * @return true if this time interval contains the time interval\n      */\n     boolean contains(ReadableInterval interval);\n     /**\n      * Does this time interval overlap the specified time interval.\n      * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The intervals overlap if at least some of the time interval is in common.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and will overlap itself and larger intervals. The size of the overlap will\n-     * be a zero duration interval equal to the original zero duration interval.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. \n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n      * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n      * \n-     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n      * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n      * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n      * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n      * \n      * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n      * \n-     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = true\n+     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n      * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n      * </pre>\n-     * \n+     *\n      * @param interval  the time interval to compare to, null means a zero length interval now\n      * @return true if the time intervals overlap\n      */\n--- a/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractInterval.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Does this time interval contain or equal the specified millisecond instant.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * A zero duration intervals only contains the instant equal to its start and end.\n-     * <p>\n-     * NOTE: From v1.3, comparing a zero duration interval to an instant\n-     * with the same value will return true because they are equal\n+     * Does this time interval contain the specified millisecond instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n      *\n      * @param millisInstant  the instant to compare to,\n      *  millisecond instant from 1970-01-01T00:00:00Z\n     public boolean contains(long millisInstant) {\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n-        return (millisInstant >= thisStart && millisInstant < thisEnd) ||\n-            (thisStart == millisInstant && thisEnd == millisInstant);\n-    }\n-\n-    /**\n-     * Does this time interval contain or equal the current instant.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * A zero duration intervals only contains the instant equal to its start and end.\n-     * <p>\n-     * NOTE: From v1.3, comparing a zero duration interval to an instant\n-     * with the same value will return true because they are equal\n+        return (millisInstant >= thisStart && millisInstant < thisEnd);\n+    }\n+\n+    /**\n+     * Does this time interval contain the current instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n      *\n      * @return true if this time interval contains the current instant\n      */\n     }\n \n     /**\n-     * Does this time interval contain or equal the specified instant.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The instant is contained if it is at the start or middle of this interval\n-     * but not at the end.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and only contains the instant equal to its start and end.\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) contains 10:00  = false (equals end)\n      * [09:00 to 10:00) contains 10:01  = false (after end)\n      * \n-     * [14:00 to 14:00) contains 14:00  = true (equal)\n+     * [14:00 to 14:00) contains 14:00  = false (zero duration contains nothing)\n      * </pre>\n      * Passng in a <code>null</code> parameter will have the same effect as\n      * calling {@link #containsNow()}.\n-     * <p>\n-     * NOTE: From v1.3, comparing a zero duration interval to an instant\n-     * with the same value will return true because they are equal\n      *\n      * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n     }\n \n     /**\n-     * Does this time interval contain or equal the specified time interval.\n-     * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The other interval is contained if this interval wholly contains, starts,\n-     * finishes or equals it.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and will contain itself (because it is equal to itself). It will also\n-     * be contained by a larger interval at the start, middle but not the end.\n+     * Does this time interval contain the specified time interval.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. The other interval is contained if this interval\n+     * wholly contains, starts, finishes or equals it.\n+     * A zero duration interval cannot contain anything.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The <code>contains</code> method is not related to these states.\n+     * In particular, a zero duration interval is contained at the start of\n+     * a larger interval, but does not overlap (it abuts instead).\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n      * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n      * \n-     * [14:00 to 14:00) contains [14:00 to 14:00)  = true (equal)\n+     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n      * </pre>\n      * Passng in a <code>null</code> parameter will have the same effect as\n      * calling {@link #containsNow()}.\n-     * <p>\n-     * NOTE: From v1.3, comparing a zero duration interval to itself\n-     * will return true because they are equal\n      *\n      * @param interval  the time interval to compare to, null means a zero duration interval now\n      * @return true if this time interval contains the time interval\n         long otherEnd = interval.getEndMillis();\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n-        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) ||\n-            (thisStart == otherStart && thisEnd == otherEnd);\n+        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);\n     }\n \n     /**\n      * Does this time interval overlap the specified time interval.\n      * <p>\n-     * Non-zero duration intervals are inclusive of the start instant and exclusive of the end.\n-     * The intervals overlap if at least some of the time interval is in common.\n-     * <p>\n-     * A zero duration interval represents the smallest possible interval\n-     * and will overlap itself and larger intervals. The size of the overlap will\n-     * be a zero duration interval equal to the original zero duration interval.\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. \n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n      * <p>\n      * For example:\n      * <pre>\n      * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n      * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n      * \n-     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n      * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n      * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n      * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n      * \n      * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n      * \n-     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = true\n+     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n      * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n      * </pre>\n-     * NOTE: From v1.3, comparing a zero duration interval at the start of\n-     * another interval will now return true, and comparing a zero duration\n-     * interval to itself will return true\n-     * \n+     *\n      * @param interval  the time interval to compare to, null means a zero length interval now\n      * @return true if the time intervals overlap\n      */\n     public boolean overlaps(ReadableInterval interval) {\n-        if (interval == null) {\n-            return containsNow();\n-        }\n-        long otherStart = interval.getStartMillis();\n-        long otherEnd = interval.getEndMillis();\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n-        \n-        return (thisStart < otherEnd && otherStart < thisEnd) ||\n-            (thisStart == otherStart &&\n-                    (thisStart == thisEnd || otherStart == otherEnd));\n+        if (interval == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            return (thisStart < now && now < thisEnd);\n+        }  else {\n+            long otherStart = interval.getStartMillis();\n+            long otherEnd = interval.getEndMillis();\n+            return (thisStart < otherEnd && otherStart < thisEnd);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n         assertEquals(false, interval.overlaps(test1020));\n         assertEquals(false, interval.contains(test1020));\n         \n-        // [10,10) [10,20) - abuts and contains-one-way and overlaps\n+        // [10,10) [10,20) - abuts and contains-one-way\n         interval = new Interval(10, 10);\n         assertNull(test1020.gap(interval));\n         assertEquals(true,  test1020.abuts(interval));\n-        assertEquals(true,  test1020.overlaps(interval));\n+        assertEquals(false, test1020.overlaps(interval));  // abuts, so can't overlap\n         assertEquals(true,  test1020.contains(interval));  // normal contains zero-duration\n         assertNull(interval.gap(test1020));\n         assertEquals(true,  interval.abuts(test1020));\n-        assertEquals(true,  interval.overlaps(test1020));\n+        assertEquals(false, interval.overlaps(test1020));  // abuts, so can't overlap\n         assertEquals(false, interval.contains(test1020));  // zero-duration does not contain normal\n         \n         // [12,12) [10,20) - contains-one-way and overlaps\n         assertEquals(false, test0808.overlaps(test1010));\n         assertEquals(false, test0808.contains(test1010));\n         \n-        // [10,10) [10,10) - abuts and overlaps\n+        // [10,10) [10,10) - abuts\n         assertNull(test1010.gap(test1010));\n         assertEquals(true,  test1010.abuts(test1010));\n-        assertEquals(true,  test1010.overlaps(test1010));\n-        assertEquals(true,  test1010.contains(test1010));\n+        assertEquals(false, test1010.overlaps(test1010));\n+        assertEquals(false, test1010.contains(test1010));\n     }\n \n     //-----------------------------------------------------------------------\n \n     public void testContains_long_zeroDuration() {\n         assertEquals(false, interval33.contains(2));  // value before\n-        assertEquals(true,  interval33.contains(3));\n+        assertEquals(false, interval33.contains(3));  // zero length duration contains nothing\n         assertEquals(false, interval33.contains(4));  // value after\n     }\n \n         DateTimeUtils.setCurrentMillisFixed(2);\n         assertEquals(false, interval33.containsNow());  // value before\n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(true,  interval33.containsNow());\n+        assertEquals(false, interval33.containsNow());  // zero length duration contains nothing\n         DateTimeUtils.setCurrentMillisFixed(4);\n         assertEquals(false, interval33.containsNow());  // value after\n     }\n \n     public void testContains_RI_zeroDuration() {\n         assertEquals(false, interval33.contains(new Instant(2)));  // value before\n-        assertEquals(true,  interval33.contains(new Instant(3)));\n+        assertEquals(false, interval33.contains(new Instant(3)));  // zero length duration contains nothing\n         assertEquals(false, interval33.contains(new Instant(4)));  // value after\n     }\n \n     }\n \n     public void testContains_RInterval_zeroDuration() {\n-        assertEquals(true,  interval33.contains(interval33));\n+        assertEquals(false, interval33.contains(interval33));  // zero length duration contains nothing\n         assertEquals(false, interval33.contains(interval37));  // zero-duration cannot contain anything\n         assertEquals(true,  interval37.contains(interval33));\n         assertEquals(false, interval33.contains(new Interval(1, 2)));  // zero-duration cannot contain anything\n         DateTimeUtils.setCurrentMillisFixed(2);\n         assertEquals(false, interval33.contains((ReadableInterval) null));  // gap before\n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(true,  interval33.contains((ReadableInterval) null));\n+        assertEquals(false, interval33.contains((ReadableInterval) null));  // zero length duration contains nothing\n         DateTimeUtils.setCurrentMillisFixed(4);\n         assertEquals(false, interval33.contains((ReadableInterval) null));  // gap after\n     }\n         assertEquals(false, interval37.overlaps(new Interval(2, 2)));  // gap before\n         \n         assertEquals(false, interval37.overlaps(new Interval(2, 3)));  // abuts before\n-        assertEquals(true,  interval37.overlaps(new Interval(3, 3)));\n+        assertEquals(false, interval37.overlaps(new Interval(3, 3)));  // abuts before\n         \n         assertEquals(true,  interval37.overlaps(new Interval(2, 4)));\n         assertEquals(true,  interval37.overlaps(new Interval(3, 4)));\n         DateTimeUtils.setCurrentMillisFixed(2);\n         assertEquals(false, interval37.overlaps((ReadableInterval) null));  // gap before\n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(true,  interval37.overlaps((ReadableInterval) null));\n+        assertEquals(false, interval37.overlaps((ReadableInterval) null));  // abuts before\n         DateTimeUtils.setCurrentMillisFixed(4);\n         assertEquals(true,  interval37.overlaps((ReadableInterval) null));\n         DateTimeUtils.setCurrentMillisFixed(6);\n         assertEquals(false, interval37.overlaps((ReadableInterval) null));  // gap after\n         \n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(true,  interval33.overlaps((ReadableInterval) null));\n+        assertEquals(false, interval33.overlaps((ReadableInterval) null));  // abuts before and after\n     }\n \n     public void testOverlaps_RInterval_zeroDuration() {\n-        assertEquals(true,  interval33.overlaps(interval33));\n-        assertEquals(true,  interval33.overlaps(interval37));\n-        assertEquals(true,  interval37.overlaps(interval33));\n+        assertEquals(false, interval33.overlaps(interval33));  // abuts before and after\n+        assertEquals(false, interval33.overlaps(interval37));  // abuts before\n+        assertEquals(false, interval37.overlaps(interval33));  // abuts before\n         assertEquals(false, interval33.overlaps(new Interval(1, 2)));\n         assertEquals(false, interval33.overlaps(new Interval(8, 9)));\n         assertEquals(true,  interval33.overlaps(new Interval(1, 9)));\n         assertEquals(null, interval37.overlap(new Interval(2, 2)));  // gap before\n         \n         assertEquals(null, interval37.overlap(new Interval(2, 3)));  // abuts before\n-        assertEquals(new Interval(3, 3), interval37.overlap(new Interval(3, 3)));\n+        assertEquals(null, interval37.overlap(new Interval(3, 3)));  // abuts before\n         \n         assertEquals(new Interval(3, 4), interval37.overlap(new Interval(2, 4)));  // truncated start\n         assertEquals(new Interval(3, 4), interval37.overlap(new Interval(3, 4)));\n         DateTimeUtils.setCurrentMillisFixed(2);\n         assertEquals(null, interval37.overlap((ReadableInterval) null));  // gap before\n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(new Interval(3, 3), interval37.overlap((ReadableInterval) null));\n+        assertEquals(null, interval37.overlap((ReadableInterval) null));  // abuts before\n         DateTimeUtils.setCurrentMillisFixed(4);\n         assertEquals(new Interval(4, 4), interval37.overlap((ReadableInterval) null));\n         DateTimeUtils.setCurrentMillisFixed(6);\n         assertEquals(null, interval37.overlap((ReadableInterval) null));  // gap after\n         \n         DateTimeUtils.setCurrentMillisFixed(3);\n-        assertEquals(new Interval(3, 3), interval33.overlap((ReadableInterval) null));\n+        assertEquals(null, interval33.overlap((ReadableInterval) null));  // abuts before and after\n     }\n \n     public void testOverlap_RInterval_zone() {\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n     public void testOverlaps_RInterval() {\n         MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n         \n-        assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1)));\n+        assertEquals(false, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1)));\n         assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1)));\n         \n         assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1 + 1)));\n         assertEquals(true, test.overlaps((ReadableInterval) null));\n         \n         MutableInterval empty = new MutableInterval(TEST_TIME1, TEST_TIME1);\n-        assertEquals(true, empty.overlaps(empty));\n-        assertEquals(true, empty.overlaps(test));\n-        assertEquals(true, test.overlaps(empty));\n+        assertEquals(false, empty.overlaps(empty));\n+        assertEquals(false, empty.overlaps(test));\n+        assertEquals(false, test.overlaps(empty));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1153955472, "metainfo": ""}