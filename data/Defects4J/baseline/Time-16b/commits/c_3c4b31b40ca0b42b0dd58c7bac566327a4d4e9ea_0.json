{"sha": "3c4b31b40ca0b42b0dd58c7bac566327a4d4e9ea", "log": "Add Comparable support to all ReadablePartials via AbstractPartial and comments   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Partial.java\n+++ b/JodaTime/src/java/org/joda/time/Partial.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Compares this ReadablePartial with another returning an integer\n-     * indicating the order.\n-     * <p>\n-     * The specified object must be a ReadablePartial whose field types\n-     * match those of this partial. Normally that means that the partials\n-     * must be the same class.\n-     *\n-     * @param partial  an object to check against\n-     * @return negative if this is less, zero if equal, positive if greater\n-     * @throws ClassCastException if the partial is the wrong class\n-     *  or if it has field types that don't match\n-     * @throws NullPointerException if the partial is null\n-     */\n-    public int compareTo(Object partial) {\n-        if (this == partial) {\n-            return 0;\n-        }\n-        ReadablePartial other = (ReadablePartial) partial;\n-        if (size() != other.size()) {\n-            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n-        }\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            if (getFieldType(i) != other.getFieldType(i)) {\n-                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n-            }\n-        }\n-        // fields are ordered largest first\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            if (getValue(i) > other.getValue(i)) {\n-                return 1;\n-            }\n-            if (getValue(i) < other.getValue(i)) {\n-                return -1;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Is this partial later than the specified partial.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is after the date passed in\n-     * @throws IllegalArgumentException if the specified partial is null\n-     * @throws ClassCastException if the partial has field types that don't match\n-     */\n-    public boolean isAfter(ReadablePartial date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"Partial cannot be null\");\n-        }\n-        return compareTo(date) > 0;\n-    }\n-\n-    /**\n-     * Is this partial earlier than the specified partial.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is before the date passed in\n-     * @throws IllegalArgumentException if the specified partial is null\n-     * @throws ClassCastException if the partial has field types that don't match\n-     */\n-    public boolean isBefore(ReadablePartial date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"Partial cannot be null\");\n-        }\n-        return compareTo(date) < 0;\n-    }\n-\n-    /**\n-     * Is this partial the same as the specified partial.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is the same as the date passed in\n-     * @throws IllegalArgumentException if the specified partial is null\n-     * @throws ClassCastException if the partial has field types that don't match\n-     */\n-    public boolean isEqual(ReadablePartial date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"Partial cannot be null\");\n-        }\n-        return compareTo(date) == 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Does this partial match the specified instant.\n      * <p>\n      * A match occurs when all the fields of this partial are the same as the\n--- a/JodaTime/src/java/org/joda/time/ReadablePartial.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePartial.java\n      */\n     int hashCode();\n \n+// NOTE: This method should have existed in Joda-Time v1.0.\n+// We STRONGLY recommend that all implementations of ReadablePartial\n+// implement this method, as per AbstractPartial.\n+// The simplest way to do this is to extend AbstractPartial.\n+// v2.0 of Joda-Time will include this method in this interface.\n+//    //-----------------------------------------------------------------------\n+//    /**\n+//     * Compares this partial with another returning an integer\n+//     * indicating the order.\n+//     * <p>\n+//     * The fields are compared in order, from largest to smallest.\n+//     * The first field that is non-equal is used to determine the result.\n+//     * Thus a YearHour partial will first be compared on the year, and then\n+//     * on the hour.\n+//     * <p>\n+//     * The specified object must be a partial instance whose field types\n+//     * match those of this partial. If the parial instance has different\n+//     * fields then a ClassCastException is thrown.\n+//     *\n+//     * @param partial  an object to check against\n+//     * @return negative if this is less, zero if equal, positive if greater\n+//     * @throws ClassCastException if the partial is the wrong class\n+//     *  or if it has field types that don't match\n+//     * @throws NullPointerException if the partial is null\n+//     * @since 2.0\n+//     */\n+//    int compareTo(Object partial);\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Get the value as a String in a recognisable ISO8601 format, only\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Is this TimeOfDay later than the specified TimeOfDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current time.\n-     *\n-     * @param time  a time to check against, null means now\n-     * @return true if this time is after the time passed in\n-     * @throws IllegalArgumentException if the specified TimeOfDay is null\n-     * @since 1.1\n-     */\n-    public boolean isAfter(TimeOfDay time) {\n-        if (time == null) {\n-            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n-        }\n-        return super.compareTo(time) > 0;\n-    }\n-\n-    /**\n-     * Is this TimeOfDay earlier than the specified TimeOfDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current time.\n-     *\n-     * @param time  a time to check against, null means now\n-     * @return true if this time is before the time passed in\n-     * @throws IllegalArgumentException if the specified TimeOfDay is null\n-     * @since 1.1\n-     */\n-    public boolean isBefore(TimeOfDay time) {\n-        if (time == null) {\n-            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n-        }\n-        return super.compareTo(time) < 0;\n-    }\n-\n-    /**\n-     * Is this TimeOfDay the same as the specified TimeOfDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current time.\n-     *\n-     * @param time  a time to check against, null means now\n-     * @return true if this time is the same as the time passed in\n-     * @throws IllegalArgumentException if the specified TimeOfDay is null\n-     * @since 1.1\n-     */\n-    public boolean isEqual(TimeOfDay time) {\n-        if (time == null) {\n-            throw new IllegalArgumentException(\"TimeOfDay cannot be null\");\n-        }\n-        return super.compareTo(time) == 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Output the time in the ISO8601 format THH:mm:ss.SSS.\n      * \n      * @return ISO8601 formatted string\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Is this YearMonthDay later than the specified YearMonthDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is after the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     * @since 1.1\n-     */\n-    public boolean isAfter(YearMonthDay date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n-        }\n-        return super.compareTo(date) > 0;\n-    }\n-\n-    /**\n-     * Is this YearMonthDay earlier than the specified YearMonthDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is before the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     * @since 1.1\n-     */\n-    public boolean isBefore(YearMonthDay date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n-        }\n-        return super.compareTo(date) < 0;\n-    }\n-\n-    /**\n-     * Is this YearMonthDay the same as the specified YearMonthDay.\n-     * <p>\n-     * You may not pass null into this method. This is because you need\n-     * a time zone to accurately determine the current date.\n-     *\n-     * @param date  an date to check against, null means now\n-     * @return true if this date is the same as the date passed in\n-     * @throws IllegalArgumentException if the specified YearMonthDay is null\n-     * @since 1.1\n-     */\n-    public boolean isEqual(YearMonthDay date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"YearMonthDay cannot be null\");\n-        }\n-        return super.compareTo(date) == 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Output the date in the ISO8601 format YYYY-MM-DD.\n      * \n      * @return ISO8601 formatted string\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public abstract class AbstractPartial implements ReadablePartial {\n+public abstract class AbstractPartial\n+        implements ReadablePartial, Comparable {\n \n     //-----------------------------------------------------------------------\n     /**\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     * @since 1.1\n+     */\n+    public int compareTo(Object partial) {\n+        if (this == partial) {\n+            return 0;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (size() != other.size()) {\n+            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+            }\n+        }\n+        // fields are ordered largest first\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) > other.getValue(i)) {\n+                return 1;\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return -1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is this partial later than the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is after the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isAfter(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) > 0;\n+    }\n+\n+    /**\n+     * Is this partial earlier than the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is before the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isBefore(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) < 0;\n+    }\n+\n+    /**\n+     * Is this partial the same as the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * If all fields are equal, the result is true.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is the same as the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isEqual(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Uses the specified formatter to convert this partial to a String.\n      *\n      * @param formatter  the formatter to use, null means use <code>toString()</code>.\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n  */\n public abstract class BasePartial\n         extends AbstractPartial\n-        implements ReadablePartial, Comparable, Serializable {\n+        implements ReadablePartial, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 2353678632973660L;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Compares this ReadablePartial with another returning an integer\n-     * indicating the order.\n-     * <p>\n-     * The specified object must be a ReadablePartial whose field types\n-     * match those of this partial. Normally that means that the partials\n-     * must be the same class.\n-     *\n-     * @param partial  an object to check against\n-     * @return negative if this is less, zero if equal, positive if greater\n-     * @throws ClassCastException if the partial is the wrong class\n-     *  or if it has field types that don't match\n-     * @throws NullPointerException if the partial is null\n-     * @since 1.1\n-     */\n-    public int compareTo(Object partial) {\n-        if (this == partial) {\n-            return 0;\n-        }\n-        ReadablePartial other = (ReadablePartial) partial;\n-        if (size() != other.size()) {\n-            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n-        }\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            if (getFieldType(i) != other.getFieldType(i)) {\n-                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n-            }\n-        }\n-        // fields are ordered largest first\n-        for (int i = 0, isize = size(); i < isize; i++) {\n-            if (getValue(i) > other.getValue(i)) {\n-                return 1;\n-            }\n-            if (getValue(i) < other.getValue(i)) {\n-                return -1;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Output the date using the specified format pattern.\n      *\n      * @param pattern  the pattern specification, null means use <code>toString</code>\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n         assertEquals(true, test1.equals(new MockInstant()));\n         assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE));\n     }\n-    \n+\n     class MockInstant extends MockPartial {\n         public Chronology getChronology() {\n             return Chronology.getCopticUTC();\n         assertEquals(+1, test3.compareTo(test1));\n         assertEquals(0, test3.compareTo(test2));\n         \n-        assertEquals(+1, test2.compareTo(new MockInstant()));\n-        assertEquals(0, test1.compareTo(new MockInstant()));\n-        \n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.hourOfDay(),\n+            DateTimeFieldType.minuteOfHour(),\n+            DateTimeFieldType.secondOfMinute(),\n+            DateTimeFieldType.millisOfSecond(),\n+        };\n+        int[] values = new int[] {10, 20, 30, 40};\n+        Partial p = new Partial(types, values);\n+        assertEquals(0, test1.compareTo(p));\n         try {\n             test1.compareTo(null);\n             fail();\n             fail();\n         } catch (ClassCastException ex) {}\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testIsEqual_TOD() {\n         TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n         assertEquals(+1, test3.compareTo(test1));\n         assertEquals(0, test3.compareTo(test2));\n         \n-        assertEquals(+1, test2.compareTo(new MockInstant()));\n-        assertEquals(0, new YearMonthDay(1970, 6, 9).compareTo(new MockInstant()));\n-        \n+        DateTimeFieldType[] types = new DateTimeFieldType[] {\n+            DateTimeFieldType.year(),\n+            DateTimeFieldType.monthOfYear(),\n+            DateTimeFieldType.dayOfMonth(),\n+        };\n+        int[] values = new int[] {2005, 6, 2};\n+        Partial p = new Partial(types, values);\n+        assertEquals(0, test1.compareTo(p));\n         try {\n             test1.compareTo(null);\n             fail();", "timestamp": 1122417255, "metainfo": ""}